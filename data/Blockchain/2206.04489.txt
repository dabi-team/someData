2
2
0
2

n
u
J

9

]

R
C
.
s
c
[

1
v
9
8
4
4
0
.
6
0
2
2
:
v
i
X
r
a

Holistic Verification of Blockchain Consensus

NATHALIE BERTRAND, Univ Rennes, Inria, CNRS, IRISA, France
VINCENT GRAMOLI, University of Sydney, Australia
IGOR KONNOV, Informal Systems, Austria
MARIJANA LAZIƒÜ, TU Munich, Germany
PIERRE THOLONIAT, Columbia University, USA
JOSEF WIDDER, Informal Systems, Austria

Blockchain has recently attracted the attention of the industry due, in part, to its ability to automate asset transfers. It requires

distributed participants to reach a consensus on a block despite the presence of malicious (a.k.a. Byzantine) participants. Malicious

participants exploit regularly weaknesses of these blockchain consensus algorithms, with sometimes devastating consequences. In

fact, these weaknesses are quite common and are well illustrated by the Ô¨Çaws in the hand-written proofs of existing blockchain

consensus protocols [63]. Paradoxically, until now, no blockchain consensus has been holistically veriÔ¨Åed using model checking.

In this paper, we remedy this paradox by model checking for the Ô¨Årst time a blockchain consensus used in industry. We propose a

holistic approach to verify the consensus algorithm of the Red Belly Blockchain [20], for any number ùëõ of processes and any number
ùëì < ùëõ/3 of Byzantine processes. We decompose directly the algorithm pseudocode in two parts‚Äîan inner broadcast algorithm and
an outer decision algorithm‚Äîeach modelled as a threshold automaton [36], and we formalize their expected properties in linear-time

temporal logic. We then automatically check the inner broadcasting algorithm, under a carefully identiÔ¨Åed fairness assumption. For

the veriÔ¨Åcation of the outer algorithm, we simplify the model of the inner algorithm by relying on its checked properties. Doing so,

we formally verify not only the safety properties of the Red Belly Blockchain consensus but also its liveness in about 70 seconds.

1 INTRODUCTION

1.1 Context

Today, the market capitalization of the seminal blockchain, called Bitcoin, is about $803B1, which incentivizes mali-
cious participants to Ô¨Ånd problematic executions that would allow them to steal Ô¨Ånancial assets. As the blockchain

requires a distributed set of machines to agree on a unique block of transactions to be appended to the chain, attackers

naturally try to exploit consensus vulnerabilities: they force participants to disagree so that they wrongly believe that

two conÔ¨Çicting transactions are legitimate, leading to what is known as a double spending. In 2014, malicious partici-

pants managed to exploit Bitcoin consensus vulnerabilities to steal $83,000 through a network attack. In August 2021,

570,000 transactions were reverted in a more recent version of Bitcoin, Bitcoin SV, by forcing its blockchain consen-

sus protocol to violate its safety property (i.e., agreement). With 3 attacks on the same blockchain within 4 months,
thefts are becoming commonplace.2 Unsurprisingly, various bugs in speciÔ¨Åcations and in proofs of blockchain consen-
sus protocols appear in the literature [1, 62]. This is illustrated by the Ô¨Çaw in the consensus algorithms now used in

in-production blockchains [63]. The crux of the problem is that reasoning about distributed executions of blockchain

consensus protocols is hard due to several sources of non-determinism, and in particular asynchrony and faults. As a

result, formally verifying that a blockchain consensus protocol is safe and live is key to mitigate Ô¨Ånancial losses.

Recent progress in mechanical proofs represent the Ô¨Årst steps towards verifying blockchain consensus. For instance,

parameterized model checking aims at verifying algorithms for an arbitrary number ùëõ of processes [11] that is unknown

at design time. In some contexts, it reduces the model checking for any fault number ùëì and its upper bound ùë° to bounded

1https://coinmarketcap.com.
2cointelegraph.com/news/bitcoin-sv-rocked-by-three-51-attacks-in-as-many-months

1

 
 
 
 
 
 
Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

model checking questions [29]. The threshold automaton (TA) framework for communication-closed algorithms [7, 36]
targets algorithms with thresholds in guards such as ‚Äúnumber of messages from distinct processes exceeds 2ùë° + 1‚Äù, and
in the resilience condition, typically of the form ùëõ > 3ùë°. The parameterized model checking of threshold automata
builds upon a reduction [26, 42] that reorders steps of asynchronous executions to obtain simpler executions, which

are equivalent to the original executions with respect to safety and liveness properties. Such a technique has recently

proved instrumental in verifying fully asynchronous parts of consensus algorithms, like broadcast algorithms [36].

Due to the famous unfeasability of deterministic consensus in asynchronous setting [28], this promising method was
not applied to proving deterministic consensus algorithms3. In fact, the aforementioned reduction technique cannot
apply to partial synchrony [25]: moving the message reception step to a later point in the execution might violate an

assumed message delay. Yet, these delays are important as typical partially synchronous consensus algorithms feature

timers to catch up with the unknown bound on the delay to receive a message. Most known veriÔ¨Åcation techniques

therefore target either synchronous (lock-step) or asynchronous semantics. In addition, partially synchronous consen-

sus algorithms generally rely on a coordinator process that helps other processes converge and whose identiÔ¨Åer rotates

across rounds. Some eÔ¨Äorts have been devoted to proving the termination of partially synchronous consensus algo-

rithms, like Paxos, assuming synchrony [30]. The drawback is that such algorithms aim at tolerating non-synchronous

periods before reaching a global stabilization time (GST) after which they terminate. Proving that such an algorithm

terminates under synchrony does not show that the algorithm would also terminate if processes reached GST at dif-

ferent points of their execution. Instead, one would also need to show that correct processes can catch up in the same

round. This would, in turn, require proving the correctness of a synchronizer algorithm [25].

Verifying consensus is even more subtle when processes are Byzantine as they can execute arbitrary steps, changing

their local state and the values they share. One needs to reason about executions with all possible scenarios resulting

from arbitrary behaviors, multiplying the already large number of interleaved executions. The veriÔ¨Åcation of such

algorithms is thus either restricted to showing safety properties, like agreement and validity, and ignoring liveness [40];

or to proving separate parts of the blockchain consensus [44]. Such noticeable eÔ¨Äorts are well illustrated with the series

of attempts to verify the Stellar Consensus Protocol (SCP) [43]: Ivy is used to model a slightly diÔ¨Äerent algorithm in

which the key novelty of the SCP consensus algorithm, which is its dynamic quorum system [51] called quorum slices,

is replaced by static quorums [45]. In addition, it relies on axioms some of which are proved separately in Isabelle/HOL

without being linked to the Ivy axioms [22]. Without a holistic approach, the veriÔ¨Åcation of the components of a

protocol does not imply that the protocol is veriÔ¨Åed.

1.2 Contributions

In this paper, we verify holistically the safety and liveness properties of a Byzantine consensus used in the Red Belly

Blockchain system [20], a scalable blockchain used in production. Our approach is holistic because it starts from the

pseudocode of the distributed algorithm as typically presented in the distributed computing literature, models this

pseudocode and its components into disambiguated threshold automata (TAs), model checks the desired properties of

these components expressed in LTL formulae, simpliÔ¨Åes the TA of the consensus algorithm with these veriÔ¨Åed prop-

erties and model checks the safety and liveness of the consensus protocol. The advantage is that the formally veriÔ¨Åed

algorithm matches the pseudocode and no user-deÔ¨Åned invariants or proofs need to be checked, which drastically

reduces the risks of human errors.

3Here deterministic means that randomization is forbidden. However, the environment (e.g., communication delays, scheduler) introduces non-
determinism in the algorithm execution.

2

Holistic Verification of Blockchain Consensus

(1) We formally verify a Byzantine consensus algorithm [19] used for e-voting [14], accountability [18] and

blockchain [20]. This consensus algorithm now runs in the network of the Red Belly Blockchain [20] main-

tained by the Red Belly Network company. It executes in asynchronous rounds that broadcast binary values

and compare the delivered values to the parity of the round to decide. To model check the algorithm holistically,

we replace the partial synchrony assumption by a fairness assumption. Interestingly, our fairness assumption

only requires that in any inÔ¨Ånite sequence of rounds, there exists a round where, at all correct processes, a

broadcast instance delivers the same binary value, or bit, Ô¨Årst.

(2) We exploit the modularity of distributed algorithms in parameterized model checking. We Ô¨Årst model the con-

sensus algorithm into two simpler algorithms modeled as threshold automata (TAs): (i) an inner broadcast TA

modeling a binary value variant of the reliable broadcast [47] and (ii) an outer decision TA modeling a round-

based execution that inspects the delivered messages [19] to decide. We express the guarantees of the inner

broadcast primitive as temporal logic properties that we automatically verify and we replace the inner TA in the

global TA by a gadget TA that captures the proven temporal speciÔ¨Åcation. We automatically verify the global

TA with model checking.

(3) We show the practicality of our veriÔ¨Åcation technique by running the parameterized model checker ByMC [36]
for any number ùëõ of processes and any arbitrary number ùëì < ùëõ/3 of Byzantine processes. We compare the
execution times when model checking the naive TA encoding the consensus algorithm and when model checking

both the inner TA encoding the broadcast algorithm and then the outer TA. We demonstrate empirically that,

although a parallel execution of ByMC on 64 cores could not prove the safety of the naive TA within 3 days, it

proves both the liveness and safety of the simpliÔ¨Åed TA in about 70 seconds.

1.3 Outline

In Section 2 we introduce our preliminary deÔ¨Ånitions, in Section 3 we model our binary value broadcast algorithm

pseudocode into a corresponding threshold automaton, in Section 4 we explain how the formal veriÔ¨Åcation of the

properties of the broadcast algorithm helps us model check the consensus algorithm and in Section 5 we verify the

consensus algorithm. In Section 6 we present the results of the model checker. In Section 7, we present the related

work and in Section 8, we conclude. In the Appendix we explain the multiple-round TA to one-round TA reduction (A),

provide examples related to fairness (B), missing proofs (C and E) and detailed speciÔ¨Åcations (D and F).

2 PRELIMINARIES

The consensus algorithm runs over ùëõ asynchronous sequential processes from the set Œ† = {ùëù1, . . . , ùëùùëõ}. The pro-
cesses communicate by exchanging messages through an asynchronous reliable fully connected point-to-point net-

work, hence there is no bound on the delay to transfer a message but this delay is Ô¨Ånite.

Failure model. Up to ùë° < ùëõ/3 processes can exhibit a Byzantine behavior [54], and behave arbitrarily. We refer to
ùëì ‚â§ ùë° as the actual number of Byzantine processes. A Byzantine process is called faulty, a non-faulty process is correct.

Algorithm semantics. The asynchronous semantics of a distributed algorithm executed by processes in Œ† assumes
discrete time and at each point in time, exactly one process takes a step. We assume that two messages cannot be

received at the same time by the same process. The global execution then consists in an interleaving of the individual
steps taken by the processes. Process ùëùùëñ sends a message to ùëù ùëó by invoking the primitive ‚Äúsend header(ùëö) to ùëù ùëó ‚Äù, where

3

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

header indicates the type of message and ùëö its contents. Process ùëùùëñ receives a message by executing the primitive
‚Äúreceive()‚Äù. The shorthand broadcast(header,ùëö) represents ‚Äúfor each ùëù ùëó ‚àà Œ† do send header(ùëö) to ùëù ùëó ‚Äù. And the
right arrow in broadcast(header,ùëö) ‚Üí messages indicates, when speciÔ¨Åed, that ‚Äúupon reception of header(ùëö) from
process ùëù ‚Ä≤
ùëó ] ‚à™ {ùëö}‚Äù. The process id is used as a subscript to denote that a variable is
local to a process‚Äîfor instance varùëñ is local to process ùëùùëñ‚Äîand is omitted when it is clear from the context.

ùëó ] ‚Üê messages[ùëù ‚Ä≤

ùëó do messages[ùëù ‚Ä≤

The veriÔ¨Åcation method considered in this paper exploits the fact that the algorithms are communication-closed [26],

i.e. only messages from the current loop iteration or round of a process may inÔ¨Çuence its steps. This can be implemented
by tagging every message by its round number ùëü ; during round ùëü all received messages with tag ùëü ‚Ä≤ < ùëü are discarded
and all received messages with tag ùëü ‚Ä≤ > ùëü are stored for later.

The consensus problem. Assuming that each correct process proposes a binary value, the binary Byzantine consen-

sus problem is for each of them to decide on a binary value in such a way that the following properties are satisÔ¨Åed:

(1) Termination. Every correct process eventually decides on a value.

(2) Agreement. No two correct processes decide on diÔ¨Äerent values.

(3) Validity. If all correct processes propose the same value, no other value can be decided.

Threshold automaton (TA). A threshold automaton [37] describes the behavior of a process in a distributed algo-

rithm. Its nodes are locations representing local states, and labeled edges are guarded rules. Formally, it is a tuple
hL, I, Œì, P, R, RCi where L is the set of locations, I ‚äÇ L is the set of initial locations, Œì is the set of shared variables
that all processes can update, P is the Ô¨Ånite set of parameter variables, R is the set of rules, and RC is the resilience con-
dition over N|Œ† |
. Rules are deÔ¨Åned as tuples hfrom, to, ùúô, ¬Æùë¢i, where from (resp. to) describes the source (resp. destination)
0
locations, and the rule label is ùúô ‚Ü¶‚Üí ¬Æùë¢. Formula ùúô is called a threshold guard or simply a guard.

1: bv-broadcast(BV, hval, ùëñi):
2:

broadcast(BV, hval, ùëñi)
repeat:

3:

4:

5:

6:

7:

if (BV, hùë£, ‚àói) received from (ùë° + 1) distinct processes but not yet re-broadcast then

broadcast(BV, hùë£, ùëñi)

if (BV, hùë£, ‚àói) received from (2ùë° + 1) distinct processes then

contestants ‚Üê contestants ‚à™ {ùë£ }

Fig. 1. The pseudocode of the binary value broadcast for process ùëùùëñ .

Example 2.1. As an example, Fig. 1 presents the pseudocode of the binary value broadcast and Fig. 2 its TA. (The

modeling of pseudocode (Fig. 1) into TA (Fig. 2) will be described in detail in Section 3.1.) To illustrate the TA notations,
note that two of the locations in L = {ùëâ0, ùëâ1, ùêµ0, ùêµ1, ùêµ01, ùê∂0, ùê∂1, ùê∂ùêµ0, ùê∂ùêµ1, ùê∂01} are initial: I = {ùëâ0, ùëâ1}. Shared variables
are ùëè0 and ùëè1 and can be updated by each process traversing the TA, while parameters are ùëõ, ùë° and ùëì and remain
unchanged across the execution. The set of rules R consists of {ùëüùëñ | 1 ‚â§ ùëñ ‚â§ 12} together with 7 self-loops. The self-
loops mimic the asynchrony between processes in the system. For example, rule ùëü3 is deÔ¨Åned as hùêµ0, ùê∂0, ùëè0‚â•2ùë°+1‚àíùëì , ¬Æ0i.
The resilience condition is ùëõ > 3ùë° ‚àß ùë° ‚â• ùëì ‚â• 0.

A multi-round threshold automaton is intuitively deÔ¨Åned such that one round is represented by a threshold automa-

ton, and additional so-called round-switch rules connect Ô¨Ånal locations with initial ones, and therefore allow processes

4

Holistic Verification of Blockchain Consensus

ùëü1 : ùëè0++

ùëâ0

ùêµ0

ùëü2 : ùëè1++

ùëè

ùëâ1

ùêµ1

2

‚â•

ùëè

0

ùë° + 1 ‚àí ùëì
ùëü

3

ùê∂0

ùëü4

ùëè1‚â•ùë°+1‚àíùëì ‚Ü¶‚Üíùëè1++
0 ‚â• ùë° + 1 ‚àí ùëì ‚Ü¶‚Üí ùëè
ùëè1‚â•2ùë°+1‚àíùëì

0 + +

5

ùëü

ùëü6

ùê∂1

ùêµ01

ùëè1‚â•ùë°+1‚àíùëì ‚Ü¶‚Üíùëè1++
ùëü7
ùë° + 1 ‚àí ùëì
ùëü

‚â•

ùëè

2

0

8

ùê∂ùêµ0

ùëè1‚â•2ùë°+1‚àíùëì

ùëü9

ùëè

ùëè1‚â•2ùë°+1‚àíùëì
ùëü11
ùë° + 1 ‚àí ùëì
ùëü

‚â•

2

0

1

2

ùê∂01

1 ‚àí ùëì ‚Ü¶‚Üí ùëè

ùëü

0

1

0 ‚â• ùë° +

ùëè

0 + +

ùê∂ùêµ1

Fig. 2. The threshold automaton model for the binary value broadcast.

to move from one round to the following one. We typically depict those round-switch rules as dotted arrows. Examples

of such multi-round TA are depicted later in Figures 3 and 4. When it is clear from the context that there are multiple

rounds, we simply call them threshold automata, and to stress that a TA does not have multiple rounds, we may call it

a one-round TA.

Counter systems. The semantics of a (one-round) threshold automaton TA are given by a counter system Sys(TA) =
hŒ£, ùêº,ùëá i where Œ£ is the set of all conÔ¨Ågurations among which ùêº are the initial ones, and ùëá is the transition relation. A
conÔ¨Åguration ùúé ‚àà Œ£ of a one-round TA captures the values of location counters (counting the number of processes
at each location of L, therefore non-negative integers), values of global variables, and parameter values. A transition
ùë° ‚àà ùëá is unlocked in ùúé if there exists a rule ùëü = hfrom, to, ùúô, ¬Æùë¢i ‚àà R such that ùúô evaluates to true in ùúé, and location counter
of from is at least 1, denoted ùúÖ [from] ‚â• 1, showing that at least one process is currently in from. In this case we can

execute transition ùë° on ùúé by moving a process along the rule ùëü from location from to location to, which is modeled by
decrementing counter ùúÖ [from], incrementing ùúÖ [to], and updating global variables according to the update vector ¬Æùë¢.

A counter system Sys(TA) of a multi-round TA is deÔ¨Åned analogously. A conÔ¨Åguration captures the values of location

counters and global variables in each round, and parameter values (that do not change over rounds). Then we deÔ¨Åne

that a transition is unlocked in a round ùëÖ by evaluating the guard ùúô and the counter of location from in the round ùëÖ.
The execution of the transition in ùúé accordingly updates ùúÖ [from, ùëÖ], ùúÖ [to, ùëÖ] and global variables of that round, while

the values of these variables in other rounds stay unchanged.

Linear temporal logic notations. Following a standard model checking approach, we use formulas in linear temporal

logic (LTL) [55] to formalize the desired properties of distributed algorithms. The basic elements of these formulas,

called atomic propositions, are predicates over conÔ¨Ågurations related (i) to the emptiness of each location at each
round and (ii) to the evaluation of threshold guards in each round. They have the following form: (i) ùúÖ [ùêø, ùëÖ] ‚â† 0
expresses that at least one correct process is in location ùêø in round ùëÖ, while ùúÖ [ùêø, ùëÖ] = 0 expresses the opposite (in
one-round systems we just write ùúÖ [ùêø] ‚â† 0 or ùúÖ [ùêø] = 0); (ii) the evaluation of [ùëè0, ùëÖ]‚â•2ùë°+1‚àíùëì depends on the values
of the shared variable ùëè0 in round ùëÖ and parameters ùë° and ùëì (in one-round systems we just write ùëè0‚â•2ùë°+1‚àíùëì ). LTL
builds on propositional logic with ‚áí for ‚Äòimplication‚Äô, ‚à® for ‚Äòor‚Äô and ‚àß for ‚Äòand‚Äô, and has extra temporal operators ‚ô¶
standing for ‚Äòeventually‚Äô and (cid:3) for ‚Äòalways‚Äô. LTL formulas are evaluated over inÔ¨Ånite runs of Sys(TA). Examples of LTL

5

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

properties in a one-round system are (BV-Justv), (BV-Oblv) and (BV-Unifv) (see page 8). LTL properties in multi-round
systems often have quantiÔ¨Åers over round variables, as for example in (Agreeùë£) and (Validùë£) (see page 12).

The tool ByMC is used to automatically verify a speciÔ¨Åc fragment of LTL on one-round systems [35, 36], which is

suÔ¨Écient to express safety and liveness properties of consensus [10]. Moreover, thanks to communication-closure, the

veriÔ¨Åcation for this fragment of temporal logic on multi-round systems reduces to one-round systems [10, Theorem 6]

(see also Appendix A).

The assumption of reliable communication is modeled as follows at the TA level: if the guard of a rule is true inÔ¨Ånitely

often, then the origin location of that rule will eventually be empty. This reÔ¨Çects that an if branch of the pseudo-code

is taken if the condition is true. This progress assumption is in particular crucial to prove liveness properties: in the

sequel, we prepend it to the liveness properties in the TA speciÔ¨Åcation.

3 THE BINARY VALUE BROADCAST

To overcome the limited scalability of model checking tools, our holistic veriÔ¨Åcation approach consists of decomposing

a distributed algorithm into encapsulated components of pseudocode that can be modelled in threshold automata and

veriÔ¨Åed in isolation to obtain a simpliÔ¨Åed threshold automaton that is amenable to automated veriÔ¨Åcation.

In this section we focus on a binary value broadcast, or bv-broadcast for short, that will serve as the main building

block of the Byzantine consensus algorithm of Section 4. In Section 3.1 we formally model the bv-broadcast algorithm

pseudocode as a threshold automaton that tolerates a number ùëì of Byzantine failures upper-bounded by ùë° among ùëõ

processes. In Section 3.2 we model the speciÔ¨Åcation of bv-broadcast in LTL and verify, within 10 seconds, that it holds.

In Section 3.3 we introduce the fairness of an inÔ¨Ånite sequence of executions of bv-broadcast that will play a crucial

role in verifying holistically in Section 5 the Byzantine consensus algorithm.

3.1 Modeling the binary value broadcast pseudocode into a threshold automaton

The binary value broadcast [47], or bv-broadcast for short, is a communication primitive guaranteeing that all binary

values ‚Äúbv-delivered‚Äù were ‚Äúbv-broadcast‚Äù by a correct process. It is particularly useful to solve the Byzantine consensus

problem with randomization [15, 48] or partial synchrony [14, 19]. As discussed before, Figures 1 and 2 in Section 2

give its pseudocode and the corresponding threshold automaton, respectively. We now explain how we model our

bv-broadcast pseudocode (Fig. 1) parameterized by ùëõ and ùëì into a threshold automaton (Fig. 2) using the synthesis

methodology [41].

Pseudocode of the binary value broadcast. The bv-broadcast algorithm pseudocode (Fig. 1) aims at having at least
2ùë°+1 processes broadcasting the same binary value. Each process starts this algorithm in one of two states, depending
on its input value 0 or 1. Once a correct process receives a value from ùë°+1 distinct processes, it broadcasts it (line 4)

if it did not do it already (line 4); broadcast is not Byzantine fault tolerant and just sends a message to all the other
processes. Once a correct process receives a value from 2ùë°+1 distinct processes, it delivers it. Here the delivery at
process ùëùùëñ is modeled by adding the value to the set contestants, which will simplify the pseudocode of the Byzantine
consensus algorithm in Section 4.1.

Threshold automaton of the binary value broadcast. To match the two initial states from which a process starts
the bv-broadcast algorithm, we start the corresponding TA of Fig. 2 with two initial locations ùëâ0 or ùëâ1, indicating
whether the (correct) process initially has value 0 or 1, resp. We can see form the pseudocode (Fig. 1) that a correct

6

Holistic Verification of Blockchain Consensus

process ùëùùëñ sends only two types of messages, (BV, h0, ùëñi) and (BV, h1, ùëñi), these trigger the corresponding receptions
at other processes. We thus deÔ¨Åne in the TA (Fig. 2) two global variables ùëè0 and ùëè1, resp., to capture the number of
the two types of messages sent by correct processes. Thus, for example, ùëè0++ models a process broadcasting message
(BV, h0, ùëñi). Because the algorithm only counts messages regardless of sender identities, we replace the messages from
the pseudocode into ùëè0 and ùëè1 shared variables that are increased whenever a message is sent.

From local to global variables for model checking. While producing a formal model, extra care is needed to avoid
introducing redundancies. For example, line 4 indicates that the process broadcasts value ùë£ if it received ùë£ from ùë°+1

distinct processes. Instead of maintaining local receive variables, it is suÔ¨Écient to enable a guard based on global send

variables. Indeed, to remove redundant local receive variables, one can use the quantiÔ¨Åer elimination for Presburger

arithmetic [56] and obtain quantiÔ¨Åer-free guard expressions over the shared variables that are valid inputs to ByMC [34,

38]. For more details, note that Stoilkovska et al. [61] eliminated the quantiÔ¨Åer over the similar receive variables in

Ben-Or‚Äôs consensus algorithm [8] with the SMT solver Z3 [21]. Finally, the point-to-point reliable channels ensure
that ùëù ùëó sends message ùëö to ùëùùëñ implies that eventually ùëùùëñ receives message ùëö from ùëù ùëó . Hence shared variables ùëè0 and
ùëè1 of the TA denote, respectively, the number of messages (BV, h0, ùëñi) and (BV, h1, ùëñi) sent by correct processes in the
pseudocode.

Modeling arbitrary (Byzantine) behaviors in the TA. In order to model that, among the received messages, ùëì

messages could have been sent by Byzantine processes, we need to map the ‚Äòif‚Äô statement of the pseudocode, comparing
the number of receptions from distinct processes to ùë°+1, to the TA guards, comparing the number ùëè1+ùëì of messages
sent to ùë° + 1. As ùëè1 counts the messages sent by correct processes and ùëì is the number of faulty processes that can send
arbitrary values, a correct process can move from ùêµ0 to ùêµ01 as soon as ùë°+1‚àíùëì correct processes have sent 1, provided
that ùëì faulty processes have also sent 1. As a result, the guard of rule ùëü4 only evaluates over global send variables as: if
more than ùë°+1 messages of type ùëè1 have been sent by correct processes (hence the guard ùëè1 ‚â• ùë°+1‚àíùëì ), then the shared
variable ùëè1 is incremented, mimicking the broadcast of a new message of type ùëè1. Rule ùëü3 corresponds to lines 6‚Äì7 and
delivers value ùë£ = 0 by storing it into variable contestants upon reception of this value from 2ùë° + 1 distinct processes.
Hence, reaching location ùê∂0 in the TA indicates that the value 0 has been delivered. As a process might stay in this
location forever, we add a self-loop with guard condition set to true.

locations

ùëâ0 ùëâ1 ùêµ0 ùêµ1 ùêµ01 ùê∂0 ùê∂ùêµ0 ùê∂1 ùê∂ùêµ1 ùê∂01

val. broadcast

val. delivered

/

/

/

/

0

/

1

/

0,1

/

0

0

0,1

0

1

1

0,1

1

0,1

0,1

Table 1. The locations of correct processes

Other locations and rules. The locations of the automaton correspond to the exclusive situations for a correct process
depicted in Table 1. After location ùê∂0, a process is still able to broadcast 1 and eventually deliver 1 after that. After
location ùêµ01, a process is able to deliver 0 and then deliver 1, or deliver 1 Ô¨Årst and then deliver 0, depending on the
order in which the guards are satisÔ¨Åed. Apart from the self-loops, note that the automaton is a directed acyclic graph.

7

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

Also, on every path in the graph, a shared variable is incremented only once. This reÔ¨Çects that in the pseudocode, a

value may only be broadcast if it has not been broadcast before.

3.2 Properties of the binary value broadcast

As was previously proved by hand [47, 48], the bv-broadcast primitive satisÔ¨Åes four properties: BV-JustiÔ¨Åcation, BV-

Obligation, BV-Uniformity and BV-Termination. Here, we formalize these properties in linear temporal logic (LTL) to

formally and automatically prove they hold. As we will discuss in Section 6, we verify them for any parameters ùëõ and
ùë° < ùëõ/3 in less then 10 seconds.

The BV-JustiÔ¨Åcation property states: ‚ÄúIf ùëùùëñ is correct and ùë£ ‚àà contestantsùëñ, then ùë£ has been bv-broadcast by some
correct process‚Äù where ùë£ ‚àà {0, 1}. Alternatively, ‚Äúif ùë£ is not bv-broadcast by some correct process and ùëùùëñ is correct,
then ùë£ ‚àâ contestantsùëñ‚Äù. In the TA from Fig. 2, ùë£ ‚àà contestantsùëñ corresponds to process ùëñ being in one of the locations ùê∂ùë£,
ùê∂ùêµùë£ or ùê∂01. Thus, justiÔ¨Åcation can be expressed in LTL as the conjunction BV-Just0 ‚àß BV-Just1 where, BV-Justv is the
following formula:

ùúÖ [ùëâùë£] = 0 ‚áí (cid:3)

ùúÖ [ùê∂ùë£] = 0 ‚àß ùúÖ [ùê∂ùêµùë£] = 0 ‚àß ùúÖ [ùê∂01] = 0
(cid:0)

(cid:1)

.

(BV-Justv)

BV-Obligation requires that if at least (ùë°+1) correct processes bv-broadcast the same value ùë£, then ùë£ is eventually
added to the set contestantsùëñ of each correct process ùëùùëñ. This can again be formalized as BV-Obl0 ‚àß BV-Obl1 where
BV-Oblv is the following formula:

(cid:3)

(cid:16)ùëèùë£ ‚â• ùë°+1 ‚áí ‚ô¶

(cid:0) √õ
ùêø ‚ààLocsùë£

ùúÖ [ùêø] = 0

(cid:1)(cid:17) ,

(BV-Oblv)

where Locsùë£ = {ùëâ0, ùëâ1, ùêµ0, ùêµ1, ùêµ01, ùê∂1‚àíùë£, ùê∂ùêµ1‚àíùë£} are all the possible locations of a process ùëñ if ùë£ ‚àâ contestantsùëñ .

BV-Uniformity requires that if a value ùë£ is added to the set contestantsùëñ of a correct process ùëùùëñ, then eventually
ùë£ ‚àà contestants ùëó at every correct process ùëù ùëó . We formalize this as BV-Unif0 ‚àß BV-Unif1 where BV-Unifv is the following:

‚ô¶ (ùúÖ [ùê∂ùë£]‚â†0 ‚à® ùúÖ [ùê∂ùêµùë£]‚â†0 ‚à® ùúÖ [ùê∂01]‚â†0) ‚áí ‚ô¶

ùúÖ [ùêø]=0 ,

√õ
ùêø ‚ààLocsùë£

(BV-Unifv)

where Locsùë£ is deÔ¨Åned as in (BV-Oblv).

Finally, the BV-Termination property claims that eventually the set contestantsùëñ of each correct process ùëùùëñ is non

empty. This can be phrased as the following LTL formula BV-Term:

‚ô¶

ùúÖ [ùëâ0]=0 ‚àß ùúÖ [ùëâ1]=0 ‚àß ùúÖ [ùêµ0]=0 ‚àß ùúÖ [ùêµ1]=0 ‚àß ùúÖ [ùêµ01]=0
(cid:0)

(cid:1)

,

(BV-Term)

forcing each correct process to be in one of the ‚ÄúÔ¨Ånal‚Äù locations ùê∂0, ùê∂1, ùê∂01, ùê∂ùêµ0, ùê∂ùêµ1.

3.3 A fairness assumption to solve consensus

The traditional approach to establishing guarantee properties in veriÔ¨Åcation is to require that all fair computations,

instead of all computations, satisfy the property [4]. We thus introduce the fairness assumption that will be crucial in

the rest of this paper. In order to deÔ¨Åne it, we Ô¨Årst deÔ¨Åne a good execution of the bv-broadcast with respect to binary

value ùë£ as an execution:

DeÔ¨Ånition 3.1 (ùë£-good bv-broadcast). A bv-broadcast execution is ùë£-good if all its correct processes bv-deliver ùë£ Ô¨Årst.

We express this property in LTL. A bv-broadcast execution is ùë£-good if no process ever visits locationsùê∂1‚àíùë£ and ùê∂ùêµ1‚àíùë£:

(cid:3)

(cid:16)ùúÖ [ùê∂1‚àíùë£] = 0 ‚àß ùúÖ [ùê∂ùêµ1‚àíùë£] = 0(cid:17) .
8

Holistic Verification of Blockchain Consensus

Second, we consider an inÔ¨Ånite sequence of bv-broadcast executions, tagged with ùëü ‚àà N. It is important to stress that
the setting is asynchronous, that is, processes invoke bv-broadcast inÔ¨Ånitely many times, but at their own relative speed.

Thus, they do not all invoke the bv-broadcast tagged with the same number ùëü at the same time. Nonetheless, every
process invokes bv-broadcast inÔ¨Ånitely many times and in the ùëü th invocation its behavior depends on the messages
sent in the ùëü th invocation of other processes. Therefore, we refer to the ùëü th execution of bv-broadcast even though the
processes invoke it at diÔ¨Äerent times.

DeÔ¨Ånition 3.2 (fairness). An inÔ¨Ånite sequence of bv-broadcast executions is fair if there exists an ùëü such that the ùëü th

execution is (ùëü mod 2)-good.

For simplicity, we use the terminology fair bv-broadcast when the inÔ¨Ånite sequence of bv-broadcast executions is

fair. We illustrate in Appendix B a possible execution of bv-broadcast whose existence implies fairness.

4 SIMPLIFIED AUTOMATON FOR BYZANTINE CONSENSUS

In this section we exploit the results of the Ô¨Årst veriÔ¨Åcation phase of Section 3 to simplify the threshold automaton of

the Byzantine consensus algorithm. In Section 4.1 we introduce the pseudocode of the Byzantine consensus algorithm

and its threshold automaton obtained with the naive modeling described in Section 3.1. In Section 4.2 we replace, in

this threshold automaton, the inner bv-broadcast automaton by a smaller one obtained thanks to the bv-broadcast

properties that are now veriÔ¨Åed. The veriÔ¨Åcation of the resulting simpliÔ¨Åed automaton is deferred to Section 5.

4.1 The Byzantine consensus algorithm

Algorithm 1 is the DBFT Byzantine consensus algorithm [19] that relies on the fair binary value broadcast of Section 3.

It is currently used in the Red Belly Blockchain, a recent blockchain that achieves unprecedented scalability [20]. More

precisely, the DBFT binary consensus comes in two diÔ¨Äerent variants: (i) a Ô¨Årst variant that is safe but not live in the

asynchronous setting, (ii) a second variant that is safe and live under the partial synchrony assumption. We use the

Ô¨Årst variant of it (without coordinator or timeout) here and show that it is live under our new fairness assumption.
The DBFT binary consensus invokes bv-broadcast(¬∑) at line 6 and uses a set contestants of binary values, whose scope
is global, updated by the bv-broadcast (Fig. 1, line 7) and accessed by the procedure propose(¬∑) (Alg. 1, line 7).

9

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

Algorithm 1 The Byzantine consensus algorithm at process ùëùùëñ

1: Global scope variable:

2:

contestants ‚äÜ {0, 1}, set of binary values, init. ‚àÖ.

3: propose(est):
ùëü ‚Üê 0

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

repeat:

bv-broadcast(est, hest, ùëñ i)
wait until (contestants ‚â† ‚àÖ)

broadcast(aux, hcontestants, ùëñ i) ‚Üí favorites
wait until ‚àÉùëê1, . . . , ùëêùëõ‚àíùë° : ‚àÄ1 ‚â§ ùëó ‚â§ ùëõ ‚àí ùë° favorites [ùëê ùëó ] ‚â† ‚àÖ ‚àß (qualiÔ¨Åers ‚Üê ‚à™‚àÄ1‚â§ ùëó ‚â§ùëõ‚àíùë° favorites [ùëê ùëó ]) ‚äÜ contestants

if qualiÔ¨Åers = {ùë£ } then

est ‚Üê ùë£
if ùë£ = (ùëü mod 2) then decide (ùë£)

else est ‚Üê (ùëü mod 2)

ùëü ‚Üê ùëü + 1

As mentioned in Section 2, recall that the algorithm is communication-closed, so that for simplicity in the presen-

tation we omit the current round number ùëü as the subscript of the variables and the parameter of the function calls.
Variable favorites is an array of ùëõ indices whose ùëó th slot records, upon delivery, the message broadcast by process ùëó in
the current round. Each process ùëùùëñ manages the following local variables: the current estimate est, initially the input
value of ùëùùëñ; and a set of binary values qualiÔ¨Åers. This algorithm maintains a round number ùëü , initially 0 (line 4), and
incremented at the end of each iteration of the loop at line 14. Process ùëùùëñ exchanges est and aux messages (lines 6‚Äì8),
until it receives aux messages from ùëõ ‚àí ùë° distinct processes whose values were bv-delivered by ùëùùëñ (line 9). Process ùëùùëñ
then tries at line 12 to decide a value ùë£ that depends on the content of qualiÔ¨Åers and the parity of the round. If qualiÔ¨Åers
is a singleton there are two possible cases: if the value is the parity of the round then ùëùùëñ decides this value (line 12),
otherwise it sets its estimate to this value (line 11). If favorites contains both binary values, then ùëùùëñ sets its estimate to
the parity of the round (line 13). Although ùëùùëñ does not exit the inÔ¨Ånite loop to help other processes decide, it can safely
exit the loop after two rounds at the end of the second round that follows the Ô¨Årst decision because all processes will
be guaranteed to have decided. Note that even though a process may invoke decide(¬∑) multiple times at line 12, only

the Ô¨Årst decision matters as the decided value does not change (see Section 5).

The eÔ¨Äect of fairness. Note that the fairness notion from Section 3.3 ensures there is a round ùëü in which all correct
processes bv-deliver (ùëü mod 2) Ô¨Årst. The following lemma states that under the fairness assumption there is a round

of Algorithm 1 in which all correct processes start with the same estimate. The proof is deferred to Appendix C.

Lemma 4.1. If the inÔ¨Ånite sequence of bv-broadcast executions of Algorithm 1 is fair, with the ùëü th execution being

(ùëü mod 2)-good, then all correct processes start round ùëü +1 of Algorithm 1 with estimate ùëü mod 2.

Modeling deterministic consensus. Figure 3 depicts the threshold automaton (TA) obtained by modeling Algo-

rithm 1 with the method we detailed in Section 3.1. The TA depicts two iterations of the repeat loop (line 5), since

10

Holistic Verification of Blockchain Consensus

ùëü1 : ùëè0 ++

ùê∂0

ùëü

3

ùëü4

ùêµ0

ùëü2 : ùëè1 ++

ùêµ01

ùëü

5

ùêµ1

ùëü6

ùê∂1

ùëâ0

ùëâ1

ùê∂ùêµ0

ùê∂ùêµ1

ùëü7

ùëü

8

ùëü9
ùëü

1 0

ùëü13

ùëü11

ùëü

2

1

ùëü19

ùëü20

1 : ùëè ‚Ä≤
ùëü ‚Ä≤

0 ++

ùëü ‚Ä≤

3

ùëü‚Ä≤
4

ùê∂ ‚Ä≤
0

ùêµ ‚Ä≤
0

ùëü‚Ä≤
7

‚Ä≤

8

ùëü

2 : ùëè ‚Ä≤
ùëü ‚Ä≤

1 ++

ùêµ ‚Ä≤
01

ùëü ‚Ä≤

5

ùêµ ‚Ä≤
1

ùëü‚Ä≤
6

ùê∂ ‚Ä≤
1

ùëü‚Ä≤
9
‚Ä≤

1 0

ùëü

ùëü 1 4

ùê∂01

ùëü18

ùëü 1 5

ùëü16

ùëü
17

ùëâ ‚Ä≤
0

ùëâ ‚Ä≤
1

ùê∏0

ùê∏1

ùê∑1

ùëü21

ùëü 22

ùê∂ùêµ ‚Ä≤
0

ùê∂ùêµ ‚Ä≤
1

ùëü ‚Ä≤
13

ùëü‚Ä≤
11

‚Ä≤

ùëü

2

1

ùëü ‚Ä≤
19

ùëü ‚Ä≤
1 4

ùê∂ ‚Ä≤
01

ùëü‚Ä≤
18

ùê∑0

‚Ä≤
ùëü

1 5

ùëü ‚Ä≤
16

ùëü‚Ä≤
17

ùê∏‚Ä≤
0

ùê∏‚Ä≤
1

Fig. 3. The naive threshold automaton of the Byzantine consensus of Algorithm 1 where the embedded bv-broadcast automaton
is depicted with dashed arrows. Precise formulations of all rules are in Appendix D. Note that the rules ùëü20, ùëü21 and ùëü22 represent
transitions from the end of an odd round to the beginning of the following (even) round of Algorithm 1, while the dotted edges
represent transitions from the end of an even round to the beginning of the following (odd) one.

Algorithm 1 favors diÔ¨Äerent values depending on the parity of the round number. For simplicity, we refer to the con-

catenation of two consecutive rounds of the algorithm as a superround of the TA. As one can expect, this TA embeds

the TA of the bv-broadcast which is depicted by the dashed arrows, just as Algorithm 1 invokes the bv-broadcast algo-

rithm of Fig. 1. We thus distinguish the outer TA modeling the consensus algorithm from the inner TA modeling the

bv-broadcast algorithm. Although Algorithm 1 is relatively simple, the global TA happens to be too large to be veriÔ¨Åed

through model checking, as we explain in Section 6; the main limiting factor is its 14 unique guards that constrain the

variables to enable rules in the TA. The detail of each rule of the TA is deferred to Appendix D.

4.2 Simplified threshold automaton

Our objective is to formally prove that Algorithm 1 is unconditionally safe, and that it is live under the assumption of

fairness at the bv-broadcast level. Since the threshold automaton of Figure 3 is too large to be handled automatically,

we build on the properties proved for the bv-broadcast to simplify in the threshold automaton from Figure 3 the part

representing the bv-broadcast. On the resulting simpler threshold automaton, assuming fairness of the bv-broadcast,

we prove the termination of Algorithm 1 with the Byzantine model checker ByMC in Section 6.

High-level idea. Ideally, the simpliÔ¨Åed threshold automaton could be obtained from the one of Fig. 3 by merging all

internal states of the bv-broadcast into a single state with two possible outcomes. However, such a merge is not trivial

because the bv-broadcast procedure ‚Äúleaks‚Äù into the consensus algorithm. First of all, line 7 of Algorithm 1 refers to

contestants, a global variable that is modiÔ¨Åed by the bv-broadcast algorithm (Fig. 1). Second, a process can execute

line 8 of Algorithm 1 even if the bv-broadcast has not terminated. To capture this porosity, we introduce a new shared

variable, some additional states and a transition rule that exploits a correctness property of the bv-broadcast.

A superround ùëÖ of the simpliÔ¨Åed automaton from Fig. 4 captures round 2ùëÖ‚àí1 followed by round 2ùëÖ of Algorithm 1.

One can thus restate Lemma 4.1 as the following corollary in the TA terminology. The proof is deferred to Appendix E.

‚Ä¢ If there exists ùëÖ ‚àà N with ùëü = 2ùëÖ‚àí1, then (cid:3)
‚Ä¢ If there exists ùëÖ ‚àà N with ùëü = 2ùëÖ, then (cid:3) (ùúÖ [ùëÄ ‚Ä≤

Corollary 4.2. Let ùëü ‚àà N be such that the ùëü th execution of bv-broadcast in Algorithm 1 is (ùëü mod 2)-good. Then:
ùúÖ [ùëÄ0, ùëÖ] = 0) holds.
(cid:0)
1, ùëÖ] = 0
11

holds.

(cid:1)

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

+

+

0

1‚Ü¶‚Üí ùëé

ùëÄ0

ùë†1:bvb

0++

‚â•

b

0

v

ùë† 3: b

ùëÄ

+

+

b

1

v

b

2 :

ùë†

ùë†
4:

bvb

1‚â•

1‚Ü¶‚Üí

ùëé

1+

+

ùëâ0

ùëâ1

ùë†5 : ùëé0 ‚â• ùëõ ‚àí ùë° ‚àí ùëì

ùë†
6:

b

v

b
1

‚â•

1

ùëÄ01

‚â•1
bvb0

:
ùë†7

ùëì

‚àí

‚àí ùë°

ùëõ

‚â•

ùëé

0

ùë†

9 :
ùë†10 : ùëé0+ùëé1‚â•ùëõ‚àíùë°‚àíùëì

ùë†11:ùëé

1‚â•

ùëõ‚àíùë°‚àíùëì

ùëÄ1

ùë†8 : ùëé1 ‚â• ùëõ ‚àí ùë° ‚àí ùëì

ùë† ‚Ä≤
1

ùë† ‚Ä≤
2

ùê∏0

ùê∏1

ùë†12

ùëâ ‚Ä≤
0

ùëâ ‚Ä≤
1

ùë†13

ùë†14

ùê∑1

ùë† ‚Ä≤
3

ùëÄ ‚Ä≤
0

ùë† ‚Ä≤
6

ùëÄ ‚Ä≤

ùë† ‚Ä≤
4

ùëÄ ‚Ä≤
01

ùë† ‚Ä≤
7

ùëÄ ‚Ä≤
1

ùë† ‚Ä≤
9

ùë† ‚Ä≤
10

ùë† ‚Ä≤
11

ùë† ‚Ä≤
5

ùë† ‚Ä≤
8

ùê∑0

ùê∏‚Ä≤
0

ùê∏‚Ä≤
1

Fig. 4. The simplified threshold automaton of the Byzantine consensus of Algorithm 1 obtained after model checking the bv-
ùëó , 1 ‚â§ ùëñ ‚â§ 11, are obtained from ùë† ùëó by replacing each variable ùëê ‚àà {ùëé0, ùëé1, bvb0, bvb1 } with its corresponding
broadcast. Rules ùë†‚Ä≤
one ùëê‚Ä≤.

5 VERIFICATION OF BYZANTINE CONSENSUS

In this section we formally prove that Algorithm 1 solves the Byzantine consensus problem with the fair bv-broadcast

and without partial synchrony. (Appendix B provides a counter-example illustrating why the algorithm does not termi-

nate without the fair broadcast.) In particular, we apply a methodology developed for crash fault tolerant randomized

consensus [10] to our context to prove both the safety (Section 5.1) and liveness (Section 5.2) properties of the deter-

ministic Byzantine consensus algorithm.

5.1 Safety

Under no fairness assumption, one can prove the safety properties‚Äîagreement and validity‚Äîof the Byzantine consen-

sus based on bv-broadcast. Precisely, we formulate these properties in LTL and want to establish that they hold on the

threshold automaton of Fig. 4.

Agreement requires that no two correct processes disagree, that is, if one process decides ùë£ then no process should
decide 1‚àíùë£ for all binary values ùë£ ‚àà {0, 1}. Thus, we want to prove that the following formula holds for both values

of ùë£:

‚àÄùëÖ ‚àà N, ‚àÄùëÖ‚Ä≤ ‚àà N

(Agreeùë£)
stating that for any two superrounds ùëÖ and ùëÖ‚Ä≤, if eventually a process decides ùë£, then globally (in any superround) no
process will decide 1 ‚àí ùë£. In terms of the TA from Fig. 4, if a process enters location ùê∑ùë£ no process should enter location
ùê∑1‚àíùë£ (not only in that superround, but in any other).

‚ô¶ ùúÖ [ùê∑ùë£, ùëÖ] ‚â† 0 ‚áí (cid:3) ùúÖ [ùê∑1‚àíùë£, ùëÖ‚Ä≤] = 0(cid:17) ,

(cid:16)

Validity requires that if no process proposes a value ùë£ ‚àà {0, 1}, no process should ever decide that value. Hence, we

want to prove the following formula for both values of ùë£:

‚àÄùëÖ ‚àà N

(cid:16)ùúÖ [ùëâùë£, 1] = 0 ‚áí (cid:3) ùúÖ [ùê∑ùë£, ùëÖ] = 0(cid:17) ,

(Validùë£)

stating that if initially no process has value ùë£, then globally (in any superround) no process decides ùë£. In terms of the
TA, if location ùëâùë£ is initially empty (in superround 1), then no process should enter location ùê∑ùë£ in any superround.

ByMC can only check formulas of the form ‚àÄùëÖ ‚àà N ùúë [ùëÖ] (see Appendix A). Thus, automatically checking (Agreeùë£)
and (Validùë£) is non-trivial, as they both involve two superround numbers: ùëÖ and ùëÖ‚Ä≤ in (Agreeùë£), and 1 and ùëÖ in (Validùë£).
We instead check well-chosen one-superround invariants (Inv1ùë£) and (Inv2ùë£):

12

Holistic Verification of Blockchain Consensus

‚àÄùëÖ ‚àà N

(cid:16)

‚àÄùëÖ ‚àà N

(cid:16)

‚ô¶ ùúÖ [ùê∑ùë£, ùëÖ] ‚â† 0 ‚áí (cid:3)

ùúÖ [ùê∑1‚àíùë£, ùëÖ] = 0 ‚àß ùúÖ [ùê∏‚Ä≤
(cid:0)
(cid:3) ùúÖ [ùëâùë£, ùëÖ] = 0 ‚áí (cid:3)

ùúÖ [ùê∑ùë£, ùëÖ] = 0 ‚àß ùúÖ [ùê∏‚Ä≤
(cid:0)

1‚àíùë£, ùëÖ] = 0

(cid:1)(cid:17) ,

ùë£, ùëÖ] = 0

(cid:1)(cid:17) .

(Inv1ùë£)

(Inv2ùë£)

The choice of these invariants follows a previous approach used for the crash fault tolerant consensus where it is
shown that these invariants imply (Agreeùë£) and (Validùë£) [10, Proposition 2]. Intuitively, this follows from the fact that
(i) emptiness of ùê∑0 and ùê∏‚Ä≤
0 in one superround leads to the emptiness of ùëâ0 in the next superround, and (ii) emptiness
of ùê∏‚Ä≤
1 (and ùê∑1) in one superround leads to the emptiness of ùëâ1 in the next superround. Therefore, in order to prove
agreement and validity, we only need to prove (Inv1ùë£) and (Inv2ùë£) for both values ùë£ ‚àà {0, 1}. We successfully do this
automatically with ByMC (see Section 6).

5.2 Liveness

We now aim at proving termination of Algorithm 1. First, we need to prove that every superround eventually termi-

nates, in the sense that for every round eventually there are no processes in any location of that round to the exception
of the Ô¨Ånal ones (ùê∑0, ùê∏‚Ä≤

1). Formally, using ByMC we prove the following:

0 and ùê∏‚Ä≤

‚àÄùëÖ ‚àà N ‚ô¶

(cid:16) √õ
ùêø ‚ààL\{ùê∑0,ùê∏‚Ä≤

0,ùê∏‚Ä≤
1 }

ùúÖ [ùêø, ùëÖ] = 0(cid:17) .

(SRoundTerm)

From this property and the shape of the TA from Fig. 4, it easily follows that if no process ever enters ùê∏‚Ä≤
1 of
some superround, then all processes visit ùê∑0 in that superround. Similarly, if no process ever enters ùê∏0 and ùê∏1 of some
superround, then all processes visit ùê∑1 in that superround. This allows us to express termination as the following LTL
property on the threshold automaton of Fig. 4:

0 and ùê∏‚Ä≤

‚àÉùëÖ ‚àà N

(cid:3)

(cid:16)

ùúÖ [ùê∏0, ùëÖ] = 0 ‚àß ùúÖ [ùê∏1, ùëÖ] = 0
(cid:0)

‚à® (cid:3)

ùúÖ [ùê∏‚Ä≤
(cid:0)

0, ùëÖ] = 0 ‚àß ùúÖ [ùê∏‚Ä≤

1, ùëÖ] = 0

(cid:1)(cid:17) .

(cid:1)
In words, there is a superround ùëÖ in which either (i) all processes visit ùê∑1, or (ii) all processes visit ùê∑0. Here again
formula (Term) is non-trivial to check since it contains an existential quantiÔ¨Åer over superrounds, that cannot be

(Term)

handled by the model checker ByMC. Adapting the technique from [10, Section 7] to a non-randomized context, it is

suÔ¨Écient to prove a couple of properties on the threshold automaton of Fig. 4, that we detail below. The Ô¨Årst property
expresses that if no process starts a superround ùëÖ with value ùë£, then all processes decide 1‚àíùë£ in superround ùëÖ:

‚àÄùëÖ ‚àà N

(cid:16)

(cid:3)

ùúÖ [ùê∏0, ùëÖ] = 0 ‚àß ùúÖ [ùê∏1, ùëÖ] = 0
(cid:0)
ùúÖ [ùê∏‚Ä≤
(cid:0)
The second property claims that (i) emptiness of ùëÄ0 in superround ùëÖ implies (emptiness of ùê∏0 and therefore also)
emptiness of ùê∑0 and ùê∏‚Ä≤

ùúÖ [ùëâ0, ùëÖ] = 0
(cid:0)
ùúÖ [ùëâ1, ùëÖ] = 0
(cid:0)

1 in superround ùëÖ implies emptiness of ùê∏‚Ä≤

0 in ùëÖ and (ii) emptiness of ùëÄ ‚Ä≤

0, ùëÖ] = 0 ‚àß ùúÖ [ùê∏‚Ä≤

(cid:1)(cid:17)
(cid:1)(cid:17) .

1, ùëÖ] = 0

1 in ùëÖ:

‚àß (cid:16)

‚áí (cid:3)

(Dec)

‚áí (cid:3)

(cid:3)

(cid:1)

(cid:1)

‚àÄùëÖ ‚àà N

(cid:16)(cid:0)

(cid:3) ùúÖ [ùëÄ0, ùëÖ] = 0) ‚áí (cid:3) (ùúÖ [ùê∑0, ùëÖ] ‚àß ùúÖ [ùê∏‚Ä≤

0, ùëÖ] = 0)

(cid:1)

‚àß

(cid:0)

(cid:3) ùúÖ [ùëÄ ‚Ä≤

1, ùëÖ] = 0) ‚áí (cid:3) ùúÖ [ùê∏‚Ä≤

1, ùëÖ] = 0

(cid:1)(cid:17) .

(Good)

The main idea is to exploit the fairness of bv-broadcast, which ensures the existence of a round ùëü which is (ùëü mod 2)-
good. Intuitively, the next superround ùëÖ = ‚åàùëü /2‚åâ is the desired witness for (Term), namely the one in which all processes
decide (not necessarily for the Ô¨Årst time). We formalize this in our main result:

13

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

Theorem 5.1. Assuming fairness of the bv-broadcast, Algorithm 1 terminates.

Proof. First we prove formulas (SRoundTerm) and (Dec) and (Good) automatically using the model checker ByMC.

Formula (SRoundTerm) guarantees that formula (Term) indeed expresses termination. Next, we show that formulas

(Dec) and (Good) together imply (Term). Indeed, since we assume fairness of the bv-broadcast, from Corollary 4.2 we

know that there is a superround ùëÖ in which one of the following two scenarios happen:

‚Ä¢ (cid:3) ùúÖ [ùëÄ ‚Ä≤

1, ùëÖ] = 0. In this case formula (Good) implies (cid:3) ùúÖ [ùê∏‚Ä≤

1, ùëÖ] = 0. Note that the form of the (dotted) round-
switch rules yield that no process starts the superround ùëÖ+1 with value 1, that is, we have (cid:3) ùúÖ [ùëâ1, ùëÖ+1] = 0.
Then formula (Dec) implies (cid:3)
, which makes formula (Term) true, that is, all
processes visit ùê∑0 in superround ùëÖ+1.

0, ùëÖ+1] = 0 ‚àß ùúÖ [ùê∏‚Ä≤

1, ùëÖ+1] = 0

ùúÖ [ùê∏‚Ä≤
(cid:0)

(cid:1)

‚Ä¢ (cid:3) ùúÖ [ùëÄ0, ùëÖ] = 0. In this case formula (Good) implies (cid:3) (ùúÖ [ùê∑0, ùëÖ]‚àßùúÖ [ùê∏‚Ä≤

. Now the round-switch rules yield
that no process starts the superround ùëÖ+1 with value 0, that is, we have (cid:3) ùúÖ [ùëâ0, ùëÖ+1] = 0. Then formula (Dec)
implies (cid:3)
, which satisÔ¨Åes formula (Term), that is, all processes visit ùê∑1 in ùëÖ+1.
As a consequence, our automated proofs of properties (SRoundTerm) and (Dec) and (Good) guarantee termination of
(cid:3)

ùúÖ [ùê∏0, ùëÖ+1] = 0 ‚àß ùúÖ [ùê∏1, ùëÖ+1] = 0
(cid:0)

Algorithm 1 under fairness of bv-broadcast.

0, ùëÖ] = 0)

(cid:1)

(cid:1)

6 EXPERIMENTS

In this section, we model check the safety but also the liveness properties of Byzantine consensus for any parameters
ùë° and ùëõ > 3ùë°. In particular, we show that we formally verify the simpliÔ¨Åed representation of the blockchain consensus
in less than 70 seconds, whereas we could not model check its naive representation.

Experimental settings. We used the parallelized version of ByMC 2.4.4 with MPI. The bv-broadcast and the simpliÔ¨Åed

automaton were veriÔ¨Åed on a laptop with Intel¬Æ Core‚Ñ¢ i7-1065G7 CPU @ 1.30GHz √ó 8 and 32 GB of memory. The naive

Threshold Automaton (TA) timed-out even on a 4 AMD Opteron 6276 16-core CPU with 64 cores at 2300MHz with 64

GB of memory. Good and Dec are only relevant for the simpliÔ¨Åed automaton. The speciÔ¨Åcation of the termination for

ByMC is deferred to Appendix F.

Results. Table 2 depicts the time (6th column) it takes to verify each property (3rd column) automatically. In particular,

it lists the TA (1st column) on which these properties were tested, as well as the size of these TA (2nd column) as

the number of guards locations and rules they contain. A schema (4th column) is a sequence of unlocked guards

(contexts) and rule sequences that is used to generate execution paths [36] whose average length appears in the 5th

column. It demonstrates the eÔ¨Éciency of our approach as it allows to verify all properties of the Byzantine consensus

automatically in less than 70 seconds whereas a non-compositional approach timed out. Although not indicated here,
we also generated a counter-example of Inv10 for ùëõ > 3ùë° on the composite automaton in ‚àº4 s.

7 RELATED WORK

Interactive theorem provers [57, 59, 66] already checked proofs of consensus algorithms used in the blockchain industry.

In particular, Coq helped prove the Raft consensus algorithm [67], which is not Byzantine fault tolerant but part of

crash fault tolerant distributed ledgers [5, 12], and the Byzantine consensus algorithm of the Algorand blockchain [3].

In addition, Dafny [30] proved MultiPaxos, a consensus algorithm that tolerates crash failures. Isabelle/HOL [52] was

used to prove Byzantine fault tolerant algorithms [17] and was combined with Ivy to try to prove the Byzantine

14

Holistic Verification of Blockchain Consensus

TA Size

bv-broadcast
(Fig. 2)

Naive
consensus
(Fig. 3)

SimpliÔ¨Åed
consensus
(Fig. 4)

4 unique
guards
10 locations
19 rules

14 unique
guards
24 locations
45 rules

10 unique
guards
16 locations
37 rules

Property
BV-Just0
BV-Obl0
BV-Unif0
BV-Term

# schemas Avg. length Time
5.61s
90
6.87s
90
27.64s
760
6.75s
90

54
79
97
79

>100 000
Inv10
>100 000
Inv20
SRound-Term >100 000

6
Inv10
Inv20
2
SRound-Term 2
2
Good0
2
Dec0

-
-
-

102
73
109
67
73

>24h
>24h
>24h

4.68s
4.56s
4.13s
4.55s
4.62s

Table 2. Although none of the properties of the naive blockchain consensus could be verified within a day of execution of the model
checker, it takes about ‚àº4 s to verify each property on the simplified representation of the blockchain consensus. Overall it takes
less than 70 seconds to verify both that the binary value broadcast and the simplified representation of the blockchain consensus
are correct.

consensus protocol of the Stellar blockchain [44] as discussed in the introduction. Theorem provers check proofs, not

the algorithms. Hence, one has to invest eÔ¨Äorts into writing detailed mechanical proofs.

Specialized decision procedures are a way of proving consensus algorithms. They were used to prove Paxos [39],

which could itself be used in the aforementioned crash fault tolerant distributed ledgers. Crash fault tolerant consensus

algorithms were manually encoded with their invariants and properties to prove formulae using the Z3 SMT solver [24].
Decision procedures also proved the safety of Byzantine fault tolerant consensus algorithms when ùëì = ùë° [9] but not
their termination. Similarly, a proof by reÔ¨Ånement of the safety of a Byzantine variant of Paxos was proposed [40]

but its liveness is not proven. These decision procedures require the user to Ô¨Åt the speciÔ¨Åcation into a suitable logical

fragment.

Explicit-state model checking fully automates veriÔ¨Åcation of distributed algorithms [31, 68]. It allows to check the re-

liable broadcast algorithm [32], a common component of various blockchain consensus algorithms [18, 19, 46]. TLC [68]

checked a reduction of fault tolerant distributed algorithms in the Heard-Of model that exploits their communication-

closed property [16]. And the agreement of consensus algorithms was proved in the asynchronous setting [53]. These

explicit-state tools enumerate all reachable states and thus suÔ¨Äer from state explosion.

Symbolic model checkers [13] cope with this explosion by representing state transitions eÔ¨Éciently. NuSMV and SAT

helped check consensus algorithms for up to 10 processes [64, 65]. Apalache [33] uses satisÔ¨Åability modulo theories
(SMT) to check inductive invariants and verify symbolic executions of TLA+ speciÔ¨Åcations of the reliable broadcast
and crash fault tolerant consensus algorithms but requires parameters to be Ô¨Åxed. These tools cannot be used to prove

(or disprove) correctness for an arbitrary number of processes.

Parameterized model checking [23] works for an arbitrary number ùëõ of processes [11]. Although the problem is

undecidable [6] in general, one can verify speciÔ¨Åc classes of algorithms [27]. Indeed, distributed algorithms with a

ring-based topology were checked with automata-theoretic method [2] and with Presburger arithmetics formulae

15

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

veriÔ¨Åed by an SMT solver [58]. Bosco [60] has been the focus of various parameterized veriÔ¨Åcation techniques [7, 41],

however, it acts as a fast path wrapper around a separate correct consensus algorithm that remains itself to be proven.

The condition-based consensus algorithm [49, 50] was veriÔ¨Åed [7] with the Byzantine model checker ByMC [34, 36, 38],

only under the condition that the diÔ¨Äerence between the numbers of processes initialized with 0 and 1 diÔ¨Äer by at least

ùë°. Recently, the crash fault tolerant Ben-Or consensus algorithm was proved correct with a probabilistic reasoning

extension of ByMC [10]. In this paper, we also exploit ByMC but prove the Byzantine consensus algorithm [19] of an

existing blockchain [20].

8 CONCLUSION

We presented the Ô¨Årst formal veriÔ¨Åcation of a blockchain consensus algorithm thanks to a new holistic approach.

Previous attempts to formally verify the liveness of blockchain consensus consisted of verifying diÔ¨Äerent parts of the

consensus algorithm without verifying the sum of the parts. By modeling directly the pseudocode into a disambiguated

threshold automaton we guarantee that the ‚Äúactual‚Äù algorithm is veriÔ¨Åed. By model checking the threshold automaton

without the need for user-deÔ¨Åned invariants and proofs, we drastically reduce the risks of human errors. We believe

that this holistic veriÔ¨Åcation technique will help verify or identify bugs in other distributed algorithms based on various

broadcast primitives.

REFERENCES

[1] Ittai Abraham, Guy Golan Gueta, Dahlia Malkhi, Lorenzo Alvisi, Rama Kotla, and Jean-Philippe Martin. 2017. Revisiting Fast Practical Byzantine

Fault Tolerance. Technical Report. arXiv. https://arxiv.org/abs/1712.01367

[2] C. Aiswarya, Benedikt Bollig, and Paul Gastin. 2018. An automata-theoretic approach to the veriÔ¨Åcation of distributed algorithms. Information

and Computation 259, 3 (2018), 305‚Äì327.

[3] Musab A. Alturki, Jing Chen, Victor Luchangco, Brandon M. Moore, Karl Palmskog, Lucas Pe√±a, and Grigore Rosu. 2019. Towards a VeriÔ¨Åed Model

of the Algorand Consensus Protocol in Coq. In International Workshops on Formal Methods (FM‚Äô19). 362‚Äì367.

[4] Rajeev Alur and Thomas A. Henzinger. 1994. Finitary fairness. In Annual IEEE Symposium on Logic in Computer Science (LICS‚Äô94). IEEE Computer

Society Press, 52‚Äì61.

[5] Elli Androulaki, Artem Barger, Vita Bortnikov, Christian Cachin, Konstantinos Christidis, Angelo De Caro, David Enyeart, Christopher Ferris,
Gennady Laventman, Yacov Manevich, Srinivasan Muralidharan, Chet Murthy, Binh Nguyen, Manish Sethi, Gari Singh, Keith Smith, Alessandro
Sorniotti, Chrysoula Stathakopoulou, Marko Vukoliƒá, Sharon Weed Cocco, and Jason Yellick. 2018. Hyperledger Fabric: A Distributed Operating
System for Permissioned Blockchains. In ACM European Conference on Computer Systems (CCS‚Äô18).

[6] Krzysztof R Apt and Dexter C Kozen. 1986. Limits for Automatic VeriÔ¨Åcation of Finite-State Concurrent Systems. Inform. Process. Lett. 22, 6 (May

1986), 307‚Äì309.

[7] A. R. Balasubramanian, Javier Esparza, and Marijana Lazic. 2020. Complexity of VeriÔ¨Åcation and Synthesis of Threshold Automata. In International

Symposium on Automated Technology for VeriÔ¨Åcation and Analysis (ATVA‚Äô20). 144‚Äì160.

[8] Michael Ben-Or. 1983. Another Advantage of Free Choice (Extended Abstract): Completely Asynchronous Agreement Protocols. In Annual ACM

Symposium on Principles of Distributed Computing (PODC‚Äô83). 27‚Äì30.

[9] Idan Berkovits, Marijana Lazic, Giuliano Losa, Oded Padon, and Sharon Shoham. 2019. VeriÔ¨Åcation of Threshold-Based Distributed Algorithms by

Decomposition to Decidable Logics. In International Conference on Computer Aided VeriÔ¨Åcation (CAV‚Äô19). 245‚Äì266.

[10] Nathalie Bertrand, Igor Konnov, Marijana Lazic, and Josef Widder. 2019. VeriÔ¨Åcation of Randomized Consensus Algorithms Under Round-Rigid

Adversaries. In International Conference on Concurrency Theory (CONCUR‚Äô19). 33:1‚Äì33:15.

[11] Roderick Bloem, Swen Jacobs, Ayrat Khalimov, Igor Konnov, Sasha Rubin, Helmut Veith, and Josef Widder. 2015. Decidability of Parameterized

VeriÔ¨Åcation. Morgan & Claypool Publishers.

[12] Richard Gendal Brown, James Carlyle, Ian Grigg, and Mike Hearn. 2016. Corda: An Introduction. R3 CEV, August (2016).
[13] Jerry R. Burch, Edmund M. Clarke, Kenneth L. McMillan, David L. Dill, and L. J. Hwang. 1990. Symbolic Model Checking: 10ÀÜ20 States and Beyond.

In Annual Symposium on Logic in Computer Science (LICS‚Äô90). 428‚Äì439.

[14] Christian Cachin, Daniel Collins, Tyler Crain, and Vincent Gramoli. 2020. Anonymity Preserving Byzantine Vector Consensus. In European Sym-

posium on Research in Computer Security (ESORICS‚Äô20). 133‚Äì152.

[15] Christian Cachin and Luca Zanolini. 2020. Asymmetric Byzantine Consensus. Technical Report 2005.08795. arXiv.

16

Holistic Verification of Blockchain Consensus

[16] Mouna Chaouch-Saad, Bernadette Charron-Bost, and Stephan Merz. 2009. A Reduction Theorem for the VeriÔ¨Åcation of Round-Based Distributed

Algorithms. In International Workshop on Reachability Problems (RP‚Äô09). 93‚Äì106.

[17] Bernadette Charron-Bost, Henri Debrat, and Stephan Merz. 2011. Formal VeriÔ¨Åcation of Consensus Algorithms Tolerating Malicious Faults. In SSS.

120‚Äì134.

[18] Pierre Civit, Seth Gilbert, and Vincent Gramoli. 2021. Polygraph: Accountable Byzantine Agreement. In Proceedings of the 41st IEEE International

Conference on Distributed Computing Systems (ICDCS‚Äô21).

[19] Tyler Crain, Vincent Gramoli, Mikel Larrea,

and Michel Raynal.

2018.

and

sus
In International
http://gramoli.redbellyblockchain.io/web/doc/pubs/DBFT-preprint.pdf

its Applications

to Blockchains.

Symposium on Network Computing

DBFT: EÔ¨Écient Leaderless Byzantine Consen-
(NCA‚Äô18).

and Applications

[20] Tyler Crain, Christopher Natoli, and Vincent Gramoli. 2021. Red Belly: A Secure, Fair and Scalable Open Blockchain. In IEEE Symposium on Security

and Privacy (S&P‚Äô21).

[21] Leonardo Mendon√ßa de Moura and Nikolaj Bj√∏rner. 2008. Z3: An EÔ¨Écient SMT Solver. In International Conference on Tools and Algorithms for

Construction and Analysis of Systems (TACAS‚Äô08). 337‚Äì340.

[22] Stellar developers. [n.d.]. Caveat 3. https://github.com/stellar/scp-proofs Accessed: 13-02-2022.
[23] Rodney G. Downey and Michael R. Fellows. 1999. Parameterized Complexity. Springer.
[24] Cezara Dragoi, Thomas A. Henzinger, Helmut Veith, Josef Widder, and Damien ZuÔ¨Äerey. 2014. A Logic-Based Framework for Verifying Consensus

Algorithms. In International Conference on VeriÔ¨Åcation, Model Checking and Abstract Interpretation (VMCAI‚Äô14). 161‚Äì181.

[25] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. 1988. Consensus in the Presence of Partial Synchrony. J. ACM 35, 2 (April 1988), 288‚Äì323.
[26] Tzilla Elrad and Nissim Francez. 1982. Decomposition of Distributed Programs into Communication-Closed Layers. Science of Computer Program-

ming 2, 3 (1982), 155‚Äì173.

[27] E. Allen Emerson and Vineet Kahlon. 2000. Reducing Model Checking of the Many to the Few. In International Conference on Automated Deduction

(CADE‚Äô17). 236‚Äì254.

[28] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. 1985. Impossibility of Distributed Consensus with One Faulty Process. J. ACM 32, 2

(April 1985), 374‚Äì382.

[29] Dana Fisman, Orna Kupferman, and Yoad Lustig. 2008. On Verifying Fault Tolerance of Distributed Protocols. In International Conference on Tools

and Algorithms for Construction and Analysis of Systems (TACAS‚Äô08). 315‚Äì331.

[30] Chris Hawblitzel, Jon Howell, Manos Kapritsos, Jacob R. Lorch, Bryan Parno, Michael L. Roberts, Srinath T. V. Setty, and Brian Zill. 2015. IronFleet:

proving practical distributed systems correct. In Symposium on Operating Systems Principles (SOSP‚Äô15). 1‚Äì17.

[31] Gerard Holzmann. 2003. The SPIN Model Checker. Addison-Wesley.
[32] Annu John, Igor Konnov, Ulrich Schmid, Helmut Veith, and Josef Widder. 2013. Towards Modeling and Model Checking Fault-Tolerant Distributed

Algorithms. In International Symposium on Model Checking Software (SPIN‚Äô13) (LNCS), Vol. 7976. 209‚Äì226.

[33] Igor Konnov, Jure Kukovec, and Thanh-Hai Tran. 2019. TLA+ model checking made symbolic. Proceedings of the ACM on Programming Languages

3, OOPSLA (2019), 123:1‚Äì123:30.

[34] Igor Konnov, Marijana Lazic, Ilina Stoilkovska, and Josef Widder. 2020. Tutorial: Parameterized VeriÔ¨Åcation with Byzantine Model Checker. In

International Conference on Formal Techniques for (Networked and) Distributed Systems (FORTE‚Äô20). 189‚Äì207.

[35] Igor Konnov, Marijana Lazic, Helmut Veith, and Josef Widder. 2017. Para2: parameterized path reduction, acceleration, and SMT for reachability

in threshold-guarded distributed algorithms. Formal Methods in System Design 51, 2 (2017), 270‚Äì307.

[36] Igor Konnov, Marijana Lazic, Helmut Veith, and Josef Widder. 2017. A short counterexample property for safety and liveness veriÔ¨Åcation of

fault-tolerant distributed algorithms. In Symposium on Principles of Programming Languages (POPL‚Äô17). ACM, 719‚Äì734.

[37] Igor Konnov, Helmut Veith, and Josef Widder. 2017. On the completeness of bounded model checking for threshold-based distributed algorithms:

Reachability. Information and Computation 252 (2017), 95‚Äì109.

[38] Igor Konnov and Josef Widder. 2018. ByMC: Byzantine Model Checker. In ISoLA. 327‚Äì342.
[39] Bernhard Kragl, Constantin Enea, Thomas A. Henzinger, Suha Orhun Mutluergil, and Shaz Qadeer. 2020. Inductive sequentialization of asynchro-

nous programs. In ACM-SIGPLAN Symposium on Programming Language Design and Implementation (PLDI‚Äô20). 227‚Äì242.

[40] Leslie Lamport. 2011. Byzantizing Paxos by ReÔ¨Ånement. In International Symposium on Distributed Computing (DISC‚Äô11). 211‚Äì224.
[41] Marijana Lazic, Igor Konnov, Josef Widder, and Roderick Bloem. 2017. Synthesis of Distributed Algorithms with Parameterized Threshold Guards.

In International Conference on Principles of Distributed Systems (OPODIS‚Äô17). 32:1‚Äì32:20.

[42] Richard J. Lipton. 1975. Reduction: A Method of Proving Properties of Parallel Programs. Commun. ACM 18, 12 (1975), 717‚Äì721.
[43] Marta Lokhava, Giuliano Losa, David Mazi√®res, Graydon Hoare, Nicolas Barry, Eli Gafni, Jonathan Jove, Rafa≈Ç Malinowsky, and Jed McCaleb. 2019.
Fast and Secure Global Payments with Stellar. In Proceedings of the 27th ACM Symposium on Operating Systems Principles (SOSP ‚Äô19). 80‚Äì96.
[44] Giuliano Losa and Mike Dodds. 2020. On the Formal VeriÔ¨Åcation of the Stellar Consensus Protocol. In Workshop on Formal Methods for Blockchains

(FMBC@CAV‚Äô20). 9:1‚Äì9:9.

[45] Giuliano Losa, Eli Gafni, and David Mazi√®res. 2019. Stellar Consensus by Instantiation. In 33rd International Symposium on Distributed Computing,

DISC 2019 (LIPIcs), Jukka Suomela (Ed.), Vol. 146. 27:1‚Äì27:15.

[46] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. 2016. The Honey Badger of BFT Protocols. In Conference on Computer and

Communications Security (CCS‚Äô16).

17

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

[47] Achour Most√©faoui, Hamouna Moumen, and Michel Raynal. 2014. Signature-free Asynchronous Byzantine Consensus with ùëá < ùëÅ /3 and ùëÇ (ùëÅ 2)

Messages. In Symposium on Principles of Distributed Computing (PODC‚Äô14). 2‚Äì9.

[48] Achour Most√©faoui, Hamouna Moumen, and Michel Raynal. 2015. Signature-free asynchronous binary Byzantine consensus with ùë° < ùëõ/3, ùëÇ (ùëõ2)

messages and ùëÇ (1) expected time. Journal of the ACM (2015).

[49] Achour Most√©faoui, Eric Mourgaya, Philippe Raipin Parv√©dy, and Michel Raynal. 2003. Evaluating the Condition-Based Approach to Solve Con-

sensus. In Dependable Systems and Networks (DSN‚Äô03). 541‚Äì550.

[50] Achour Most√©faoui, Sergio Rajsbaum, and Michel Raynal. 2003. Conditions on Input Vectors for Consensus Solvability in Asynchronous Distributed

Systems. Journal of the ACM 50, 6 (Nov. 2003), 922‚Äì954.

[51] Moni Naor and Udi Wieder. 2003. Scalable and Dynamic Quorum Systems. In Proceedings of the Twenty-Second Annual Symposium on Principles of

Distributed Computing. 114‚Äì122.

[52] Tobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. 2002. Isabelle/HOL - A Proof Assistant for Higher-Order Logic. Lecture Notes in Computer

Science, Vol. 2283. Springer.

[53] Tatsuya Noguchi, Tatsuhiro Tsuchiya, and Tohru Kikuno. 2012. Safety VeriÔ¨Åcation of Asynchronous Consensus Algorithms with Model Checking.

In International Symposium on Dependable Computing (PRDC‚Äô12). 80‚Äì88.

[54] Marshall C. Pease, Robert E. Shostak, and Leslie Lamport. 1980. Reaching Agreement in the Presence of Faults. Journal of the ACM 27, 2 (1980),

228‚Äì234.

[55] Amir Pnueli. 1977. The Temporal Logic of Programs. In IEEE Annual Symposium on Foundations of Computer Science (FOCS‚Äô77). 46‚Äì57.
[56] Moj≈ºesz Presburger. 1929. √úber die Vollst√§ndigkeit eines gewissen Systems der Arithmetik ganzer Zahlen, in welchem die Addition als einzige

Operation hervortritt. In Comptes Rendus du congr√®s de Math√©maticiens des Pays Slaves. 92‚Äì101.

[57] Vincent Rahli, David Guaspari, Mark Bickford, and Robert L. Constable. 2015. Formal SpeciÔ¨Åcation, VeriÔ¨Åcation, and Implementation of Fault-

Tolerant Systems using EventML. Electronic Communication of the European Association of Software Science and Technology 72 (2015).

[58] Arnaud Sangnier, Nathalie Sznajder, Maria Potop-Butucaru, and S√©bastien Tixeuil. 2020. Parameterized veriÔ¨Åcation of algorithms for oblivious

robots on a ring. Formal Methods in System Design 56, 1 (2020), 55‚Äì89.

[59] Ilya Sergey, James R. Wilcox, and Zachary Tatlock. 2018. Programming and proving with distributed protocols. Proceedings of the ACM on

Programming Languages 2, POPL (2018), 28:1‚Äì28:30.

[60] Yee Jiun Song and Robbert van Renesse. 2008. Bosco: One-Step Byzantine Asynchronous Consensus. In International Symposium on Distributed

Computing (DISC‚Äô08). 438‚Äì450.

[61] Ilina Stoilkovska, Igor Konnov, Josef Widder, and Florian Zuleger. 2020. Eliminating Message Counters in Threshold Automata. In International

Symposium on Automated Technology for VeriÔ¨Åcation and Analysis (ATVA‚Äô20). 196‚Äì212.

[62] Pierre Sutra. 2020. On the correctness of Egalitarian Paxos. Inform. Process. Lett. 156 (2020), 105901. https://doi.org/10.1016/j.ipl.2019.105901
[63] Pierre Tholoniat and Vincent Gramoli. 2022. Formal VeriÔ¨Åcation of Blockchain Byzantine Fault Tolerance. In Handbook on Blockchain, Duc A. Tran,

My T. Thai, and Bhaskar Krishnamachari (Eds.). Springer Nature.

[64] Tatsuhiro Tsuchiya and Andr√© Schiper. 2008. Using Bounded Model Checking to Verify Consensus Algorithms. In Distributed Computing, Gadi

Taubenfeld (Ed.). 466‚Äì480.

[65] Tatsuhiro Tsuchiya and Andr√© Schiper. 2011. VeriÔ¨Åcation of consensus algorithms using satisÔ¨Åability solving. Distributed Computing 23, 5-6 (2011),

341‚Äì358.

[66] Klaus von Gleissenthall, Rami G√∂khan Kici, Alexander Bakst, Deian Stefan, and Ranjit Jhala. 2019. Pretend synchrony: synchronous veriÔ¨Åcation

of asynchronous distributed programs. Proceedings of the ACM on Programming Languages 3, POPL (2019), 59:1‚Äì59:30.

[67] James R. Wilcox, Doug Woos, Pavel Panchekha, Zachary Tatlock, Xi Wang, Michael D. Ernst, and Thomas E. Anderson. 2015. Verdi: a framework
for implementing and formally verifying distributed systems. In ACM-SIGPLAN Symposium on Programming Language Design and Implementation
(PLDI‚Äô15). 357‚Äì368.

[68] Yuan Yu, Panagiotis Manolios, and Leslie Lamport. 1999. Model Checking TLA+ SpeciÔ¨Åcations. In CHARME. 54‚Äì66.

A REDUCING MULTI-ROUND TA TO ONE-ROUND TA

Let us Ô¨Årst formally deÔ¨Åne a (Ô¨Ånite or inÔ¨Ånite) run in a (one-round or multi-round) counter system Sys(TA). It is an
alternating sequence of conÔ¨Ågurations and transitions ùúé0, ùë°1, ùúé1, ùë°2, . . . such that ùúé0 ‚àà ùêº is an initial conÔ¨Åguration and
for every ùëñ ‚â• 1 we have that ùë°ùëñ is unlocked in ùúéùëñ‚àí1, and executing it leads to ùúéùëñ , denoted ùë°ùëñ (ùúéùëñ‚àí1) = ùúéùëñ .

Here we brieÔ¨Çy describe the reasoning behind the reduction of multi-round TAs to one-round TAs [10, Theorem 6].

Note that the behavior of a process in one round only depends on the variables (the number of messages) of that

round. Namely, we check if a transition is unlocked in a round by evaluating a guard and a location counter in that

round. This allows us to modify a run by swapping two transitions from diÔ¨Äerent rounds, as they do not aÔ¨Äect each
other, and preserve LTL-X properties, which are properties expressed in LTL without the next operator X . The type
18

Holistic Verification of Blockchain Consensus

of swapping we are interested in is the one where a transition of round ùëÖ is followed by a transition of round ùëÖ‚Ä≤ < ùëÖ.
Starting from any (fully asynchronous) run, if we keep swapping all such pairs of transitions, we will obtain a run
in which processes synchronize at the end of each round and which has the same LTL-X properties as the initial one.
This, so-called round-rigid structure, allows us to isolate a single round and analyze it. Still, diÔ¨Äerent rounds might
behave diÔ¨Äerently as they have diÔ¨Äerent initial conÔ¨Ågurations. If we have a formula ‚àÄùëÖ ‚àà N. ùúë [ùëÖ], where ùúë [ùëÖ] is
in the above mentioned fragment of (multi-round) LTL, then Theorem 6 of [10] shows exactly that it is equivalent to
check that (i) this formula holds (or ùúë [ùëÖ] holds on all rounds ùëÖ) on a multi-round TA, and (ii) formula ùúë [1] (or just ùúë)
holds on the one-round TA‚Ä≤ (naturally obtained from the TA by removing dotted round-switch rules) with respect to all
possible initial conÔ¨Ågurations of all rounds. Thus, we can verify properties of the form ‚àÄùëÖ ‚àà N. ùúë [ùëÖ] on multi-round
threshold automata, by using ByMC to check ùúë on a one-round threshold automaton with an enlarged set of initial

conÔ¨Ågurations.

B EXAMPLES OF FAIRNESS AND OF NON-TERMINATION WITHOUT FAIRNESS

First, we explain that the fairness is satisÔ¨Åed as soon as one execution of bv-broadcast has correct processes deliver-

ing all values broadcast by correct processes Ô¨Årst. Then, we explain that the Byzantine consensus algorithm cannot

terminate without an additional assumption, like fairness.

Relevance of the fairness assumption. It is interesting to note that our fairness assumption is satisÔ¨Åed by the existence

of an execution with a particular reception order of some messages of the two broadcasts within the bv-broadcast.
Consider that ùë° = ‚åàùëõ/3‚åâ ‚àí 1 and that at the beginning of a round ùëü , the two following properties hold: (i) estimate
ùëü mod 2 is more represented than estimate (1 ‚àí ùëü ) mod 2 among correct processes and (ii) all correct processes deliver

the values broadcast by correct processes before any value broadcast during the bv-broadcast by Byzantine processes

are delivered. Indeed, the existence of such a round ùëü in any inÔ¨Ånite sequence of executions of bv-broadcast implies
that this sequence is fair (Def. 3.2): as ùëü mod 2 is the only value that can be broadcast by ùë°+1 correct processes, this is
the Ô¨Årst value that is received from ùë°+1 distinct processes and rebroadcast by the rest of the correct processes. This is

thus also the Ô¨Årst value that is bv-delivered by all correct processes.

Non-termination without fairness. It is interesting to note why Algorithm 1 does not solve consensus when ùë° < ùëõ/3
and without our fairness assumption. We exhibit an example of execution of the algorithm with ùëõ = 4 and ùëì = 1, starting
at round ùëü and for which the estimates of the correct processes are kept as (1‚àíùëü ) mod 2, (1‚àíùëü ) mod 2, ùëü mod 2 in rounds
ùëü and ùëü +2. Repeating this while incrementing ùëü yields an inÔ¨Ånite execution, so that the algorithm never terminates.

Lemma B.1. Algorithm 1 does not terminate without fairness.

Proof. Consider, for example, processes ùëù1, ùëù2, ùëù3 and ùëù4 where ùëù4 is Byzantine and where 0, 0, 1 are the input values
of the correct processes ùëù1, ùëù2, ùëù3, respectively, at round 1. We show that at the beginning of round 2, ùëù1, ùëù2, ùëù3 have
estimates 0, 1, 1. First, as a result of the broadcast (line 2), consider that ùëù1 and ùëù2 receive 0 from ùëù1, ùëù2 and ùëù4 so that
ùëù1, ùëù2 bv-deliver 0. Second, ùëù2 and ùëù3 receive 1 from ùëù3, ùëù4 and Ô¨Ånally ùëù2 so that ùëù2, ùëù3 bv-deliver 1. Third, ùëù3 receives
0 from ùëù0, ùëù2 and Ô¨Ånally from ùëù3 itself, hence ùëù3 bv-delivers 0. Now we have: (a) ùëù1, ùëù2, ùëù3 bv-deliver 0, 0, 1 and (b)
ùëù2, ùëù3 later bv-deliver 1 and 0, respectively. As a result of (a), we have ùëù1, ùëù2 broadcast, and say ùëù4 sends, haux, 0, ¬∑i so
that ùëù0 receives these three messages, ùëù1, ùëù2 broadcast haux, 0, ¬∑i, and say ùëù4 sends, haux, 1, ¬∑i to ùëù2 so that ùëù2 receives
these messages, ùëù1 broadcasts haux, 0, ¬∑i while ùëù3 broadcasts, and say ùëù4 sends, haux, 1, ¬∑i so that ùëù3 receives these
messages. Finally, by (b) we have contestants2 = contestants3 = {0, 1}. This implies that the ùëõ ‚àí ùë° Ô¨Årst values inserted in
19

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

favorites1, favorites2 and favorites3 in round ùëü are values {0}, {0, 1}, {0, 1}, respectively. Finally, qualiÔ¨Åers1, qualiÔ¨Åers2
and qualiÔ¨Åers3 are {0}, {0, 1} and {0, 1}, respectively. And ùëù1, ùëù2, ùëù3 set their estimate to 0, 1, 1.

It is easy to see that a symmetric execution in round ùëü ‚Ä≤ = ùëü + 1 leads processes to change their estimate from 0, 1, 1
(cid:3)

to 0, 0, 1 looping back to the state where ùëü mod 2 = 1 and estimate are (1 ‚àí ùëü ) mod 2, (1 ‚àí ùëü ) mod 2, ùëü mod 2.

C STARTING A ROUND WITH IDENTICAL ESTIMATE

Lemma C.1 (Lemma 4.1). If the inÔ¨Ånite sequence of bv-broadcast invocations of Algorithm 1 is fair, with the ùëü th invo-
cation (in round ùëü ) being (ùëü mod 2)-good, then all correct processes start round ùëü +1 of Algorithm 1 with estimate ùëü mod 2.

Proof. The argument is that all correct processes wait until a growing preÔ¨Åx of the bv-delivered values that are re-
broadcast implies that there is a subset of favorites, called qualiÔ¨Åers, containing messages from ùëõ ‚àí ùë° distinct processes
such that ‚àÄùë£ ‚àà qualiÔ¨Åers. ùë£ ‚àà contestants. As we assume that the inÔ¨Ånite sequence of bv-broadcast invocations of
Algorithm 1 is fair, with the ùëü th invocation being (ùëü mod 2)-good, then we know that in round ùëü for every pair of correct
processes ùëùùëñ and ùëù ùëó we have pi.qualiÔ¨Åers ‚äÜ pj.qualiÔ¨Åers or pj.qualiÔ¨Åers ‚äÜ pi.qualiÔ¨Åers. If pi.qualiÔ¨Åers = pj.qualiÔ¨Åers for
all pairs, then by examination of the code, we know that they will set their estimate est to the same value depending

on the parity of the current round.

Consider instead, with no loss of generality, that pi.qualiÔ¨Åers is a strict subset of pj.qualiÔ¨Åers in round ùëü . As their
values can only be binaries, in {0, 1}, this means that pi.qualiÔ¨Åers is a singleton, say {ùë§ }. As all correct processes bv-
deliver ùëü mod 2 Ô¨Årst, which is then broadcast into pi.favorites, we have ùë§ = ùëü mod 2 and ùëùùëñ‚Äôs estimate becomes ùëü mod 2
(cid:3)
at line 11. As pj.qualiÔ¨Åers is {0, 1}, the estimate of ùëù ùëó is also set to ùëü mod 2 but at line 13.

D LARGE TA

Table 3 details the rules for the Ô¨Årst half of the threshold automaton from Fig. 3.

Rules
ùëü1
ùëü2
ùëü3
ùëü4
ùëü5
ùëü6
ùëü14, ùëü15, ùëü16
ùëü8
ùëü9
ùëü10
ùëü11
ùëü12
ùëü13
ùëü7, ùëü18, ùëü19
ùëü16
ùëü17
ùëü20, ùëü21, ùëü22

Guard
Update
true
ùëè0 ++
true
ùëè1 ++
ùëè0 ‚â• 2ùë°+1‚àíùëì
ùëé0++
ùëè1 ‚â• ùë°+1‚àíùëì
ùëè1 ++
ùëè0 ‚â• ùë°+1‚àíùëì
ùëè0 ++
ùëè1 ‚â• 2ùë°+1‚àíùëì
ùëé1++
ùëé0 ‚â• ùëõ‚àíùë°‚àíùëì
‚Äî
ùëè1 ‚â• ùë°+1‚àíùëì
ùëè1 ++
ùëè1 ‚â• 2ùë°+1‚àíùëì
ùëé1++
ùëè0 ‚â• 2ùë°+1‚àíùëì
ùëé0++
ùëè0 ‚â• ùë°+1‚àíùëì
ùëè0 ++
ùëè1 ‚â• 2ùë°+1‚àíùëì
‚Äî
ùëè0 ‚â• 2ùë°+1‚àíùëì
‚Äî
ùëé1 ‚â• ùëõ‚àíùë°‚àíùëì
‚Äî
ùëé0 ‚â• ùëõ‚àíùë°‚àíùëì
‚Äî
ùëé0+ùëé1 ‚â• ùëõ‚àíùë°‚àíùëì ‚Äî
‚Äî
true

Table 3. The rules of the threshold automaton from Fig. 3. We omit self loops that have trivial guard true and no update.

20

Holistic Verification of Blockchain Consensus

E MISSING PROOF OF COROLLARY 4.2

We restate here Corollary 4.2 and give its proof.

Corollary E.1. Let ùëü ‚àà N be such that the ùëü th execution of bv-broadcast in Algorithm 1 is (ùëü mod 2)-good. Then:

‚Ä¢ If there exists ùëÖ ‚àà N with ùëü = 2ùëÖ‚àí1, then (cid:3)
‚Ä¢ If there exists ùëÖ ‚àà N with ùëü = 2ùëÖ, then (cid:3) (ùúÖ [ùëÄ ‚Ä≤

ùúÖ [ùëÄ0, ùëÖ] = 0) holds.
(cid:0)
1, ùëÖ] = 0

holds.

(cid:1)

Proof. By deÔ¨Ånition of an (ùëü mod 2)-good execution, we know that in this particular invocation of bv-broadcast,

all correct processes bv-deliver ùëü mod 2 Ô¨Årst. It follows from Lemma 4.1, that all correct processes start the next round
with estimate set to ùëü mod 2. There are two cases to consider depending on the parity of the round: If ùëü mod 2 = 1,
then this is the Ô¨Årst round of superround ùëÖ, i.e., ùëü = 2ùëÖ ‚àí 1. As a result, (cid:3)
. If ùëü mod 2 = 0, then this is
the second round of superround ùëÖ, i.e., ùëü = 2ùëÖ. As a result, (cid:3)
(cid:3)
1, ùëÖ] = 0

ùúÖ [ùëÄ0, ùëÖ] = 0
(cid:0)
.

(cid:1)

ùúÖ [ùëÄ ‚Ä≤
(cid:0)

(cid:1)

F SPECIFICATION OF THE TERMINATION PROPERTY IN THE SIMPLIFIED THRESHOLD

AUTOMATON FOR CONSENSUS ALGORITHM

The reliable communication assumption and the properties guaranteed by the bv-broadcast are expressed as precon-

ditions for s_round_termination. The progress conditions work exactly the same as in [10]. However, since the shared

counters representing the bv-broadcast execution do not represent regular messages, we cannot directly use the re-

liable communication assumption. Instead, we use the properties of the bv-broadcast that we proved in a separate

automaton.

In practice, instead of using progress preconditions on the bv-broadcast counters in s_round_termination, such as:

(locM

== 0 || bvb1 < 1) && (locM == 0 || bvb0 < 1) &&

(locM1 == 0 || bvb0 < 1) && (locM0 == 0 || bvb1 < 1)

we use the following:

/* BV-Termination */
(locM

== 0) &&

/* BV-Obligation */
(locM1 == 0 || bvb0 < T + 1) && (locM0 == 0 || bvb1 < T + 1) &&

/* BV-Uniformity */
(locM1 == 0 || aux0 == 0) && (locM0 == 0 || aux1 == 0) &&

One can note that we do not use BV-JustiÔ¨Åcation as a precondition in this speciÔ¨Åcation. Instead, the BV-JustiÔ¨Åcation
property is baked in the structure of the simpliÔ¨Åed threshold automaton (in the guard of the transition ùëÄ ‚Üí ùëÄ0, ùëÄ1).

The complete speciÔ¨Åcation of the termination property follows:

21

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Laziƒá, Pierre Tholoniat, and Josef Widder

s_round_termination:

<>[](

(locV0

== 0) &&

(locV1

== 0) &&

(locM01x

== 0 || aux0x + aux1x < N - T)

)

->

<>(

/* BV-Termination */
(locM

== 0) &&

/* BV-Obligation */
(locM1 == 0 || bvb0 < T + 1) &&

(locM0 == 0 || bvb1 < T + 1) &&

/* BV-Uniformity */
(locM1 == 0 || aux0 == 0) &&

(locM0 == 0 || aux1 == 0) &&

/* Business as usual */
(locM1

== 0 || aux1 < N - T) &&

(locM0

== 0 || aux0 < N - T) &&

(locM01

== 0 || aux0 + aux1 < N - T) &&

);

locV0

== 0 &&

locV1

== 0 &&

locM

== 0 &&

locM0

== 0 &&

locM1

== 0 &&

locM01

== 0 &&

locE0

== 0 &&

locE1

== 0 &&

locD1

== 0 &&

locMx

== 0 &&

locM0x

== 0 &&

locM1x

== 0 &&

locM01x == 0

(locD1

== 0) &&

(locE0

== 0) &&

(locE1

== 0) &&

/* BV-Termination */
(locMx

== 0 ) &&

/* BV-Obligation */
(locM1x

== 0 || bvb0x < T + 1) &&

inv1_0: <>(locD0 != 0) -> [](locD1 == 0 && locE1x == 0);

inv2_0: [](locV0 == 0) -> [](locD0 == 0 && locE0x == 0);

inv1_1: <>(locD1 != 0) -> [](locD0 == 0 && locE0x == 0);

inv2_1: [](locV1 == 0) -> [](locD1 == 0 && locE1x == 0);

(locM0x

== 0 || bvb1x < T + 1) &&

dec_0: [](locV0 == 0) -> [](locE0 == 0 && locE1 == 0);

/* BV-Uniformity */
(locM1x == 0 || aux0x == 0) &&

(locM0x == 0 || aux1x == 0) &&

dec_1: [](locV1 == 0) -> [](locE0x == 0 && locE1x == 0);

good_0: [](locM0 == 0) -> [](locD0 == 0 && locE0x == 0);

(locM1x

== 0 || aux1x < N - T) &&

(locM0x

== 0 || aux0x < N - T) &&

good_1: [](locM1x == 0) -> [](locE1x == 0);

(locM01x

== 0 || aux1x < N - T) &&

(locM01x

== 0 || aux0x < N - T) &&

22

