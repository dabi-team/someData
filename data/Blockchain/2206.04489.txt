2
2
0
2

n
u
J

9

]

R
C
.
s
c
[

1
v
9
8
4
4
0
.
6
0
2
2
:
v
i
X
r
a

Holistic Verification of Blockchain Consensus

NATHALIE BERTRAND, Univ Rennes, Inria, CNRS, IRISA, France
VINCENT GRAMOLI, University of Sydney, Australia
IGOR KONNOV, Informal Systems, Austria
MARIJANA LAZIÄ†, TU Munich, Germany
PIERRE THOLONIAT, Columbia University, USA
JOSEF WIDDER, Informal Systems, Austria

Blockchain has recently attracted the attention of the industry due, in part, to its ability to automate asset transfers. It requires

distributed participants to reach a consensus on a block despite the presence of malicious (a.k.a. Byzantine) participants. Malicious

participants exploit regularly weaknesses of these blockchain consensus algorithms, with sometimes devastating consequences. In

fact, these weaknesses are quite common and are well illustrated by the ï¬‚aws in the hand-written proofs of existing blockchain

consensus protocols [63]. Paradoxically, until now, no blockchain consensus has been holistically veriï¬ed using model checking.

In this paper, we remedy this paradox by model checking for the ï¬rst time a blockchain consensus used in industry. We propose a

holistic approach to verify the consensus algorithm of the Red Belly Blockchain [20], for any number ğ‘› of processes and any number
ğ‘“ < ğ‘›/3 of Byzantine processes. We decompose directly the algorithm pseudocode in two partsâ€”an inner broadcast algorithm and
an outer decision algorithmâ€”each modelled as a threshold automaton [36], and we formalize their expected properties in linear-time

temporal logic. We then automatically check the inner broadcasting algorithm, under a carefully identiï¬ed fairness assumption. For

the veriï¬cation of the outer algorithm, we simplify the model of the inner algorithm by relying on its checked properties. Doing so,

we formally verify not only the safety properties of the Red Belly Blockchain consensus but also its liveness in about 70 seconds.

1 INTRODUCTION

1.1 Context

Today, the market capitalization of the seminal blockchain, called Bitcoin, is about $803B1, which incentivizes mali-
cious participants to ï¬nd problematic executions that would allow them to steal ï¬nancial assets. As the blockchain

requires a distributed set of machines to agree on a unique block of transactions to be appended to the chain, attackers

naturally try to exploit consensus vulnerabilities: they force participants to disagree so that they wrongly believe that

two conï¬‚icting transactions are legitimate, leading to what is known as a double spending. In 2014, malicious partici-

pants managed to exploit Bitcoin consensus vulnerabilities to steal $83,000 through a network attack. In August 2021,

570,000 transactions were reverted in a more recent version of Bitcoin, Bitcoin SV, by forcing its blockchain consen-

sus protocol to violate its safety property (i.e., agreement). With 3 attacks on the same blockchain within 4 months,
thefts are becoming commonplace.2 Unsurprisingly, various bugs in speciï¬cations and in proofs of blockchain consen-
sus protocols appear in the literature [1, 62]. This is illustrated by the ï¬‚aw in the consensus algorithms now used in

in-production blockchains [63]. The crux of the problem is that reasoning about distributed executions of blockchain

consensus protocols is hard due to several sources of non-determinism, and in particular asynchrony and faults. As a

result, formally verifying that a blockchain consensus protocol is safe and live is key to mitigate ï¬nancial losses.

Recent progress in mechanical proofs represent the ï¬rst steps towards verifying blockchain consensus. For instance,

parameterized model checking aims at verifying algorithms for an arbitrary number ğ‘› of processes [11] that is unknown

at design time. In some contexts, it reduces the model checking for any fault number ğ‘“ and its upper bound ğ‘¡ to bounded

1https://coinmarketcap.com.
2cointelegraph.com/news/bitcoin-sv-rocked-by-three-51-attacks-in-as-many-months

1

 
 
 
 
 
 
Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

model checking questions [29]. The threshold automaton (TA) framework for communication-closed algorithms [7, 36]
targets algorithms with thresholds in guards such as â€œnumber of messages from distinct processes exceeds 2ğ‘¡ + 1â€, and
in the resilience condition, typically of the form ğ‘› > 3ğ‘¡. The parameterized model checking of threshold automata
builds upon a reduction [26, 42] that reorders steps of asynchronous executions to obtain simpler executions, which

are equivalent to the original executions with respect to safety and liveness properties. Such a technique has recently

proved instrumental in verifying fully asynchronous parts of consensus algorithms, like broadcast algorithms [36].

Due to the famous unfeasability of deterministic consensus in asynchronous setting [28], this promising method was
not applied to proving deterministic consensus algorithms3. In fact, the aforementioned reduction technique cannot
apply to partial synchrony [25]: moving the message reception step to a later point in the execution might violate an

assumed message delay. Yet, these delays are important as typical partially synchronous consensus algorithms feature

timers to catch up with the unknown bound on the delay to receive a message. Most known veriï¬cation techniques

therefore target either synchronous (lock-step) or asynchronous semantics. In addition, partially synchronous consen-

sus algorithms generally rely on a coordinator process that helps other processes converge and whose identiï¬er rotates

across rounds. Some eï¬€orts have been devoted to proving the termination of partially synchronous consensus algo-

rithms, like Paxos, assuming synchrony [30]. The drawback is that such algorithms aim at tolerating non-synchronous

periods before reaching a global stabilization time (GST) after which they terminate. Proving that such an algorithm

terminates under synchrony does not show that the algorithm would also terminate if processes reached GST at dif-

ferent points of their execution. Instead, one would also need to show that correct processes can catch up in the same

round. This would, in turn, require proving the correctness of a synchronizer algorithm [25].

Verifying consensus is even more subtle when processes are Byzantine as they can execute arbitrary steps, changing

their local state and the values they share. One needs to reason about executions with all possible scenarios resulting

from arbitrary behaviors, multiplying the already large number of interleaved executions. The veriï¬cation of such

algorithms is thus either restricted to showing safety properties, like agreement and validity, and ignoring liveness [40];

or to proving separate parts of the blockchain consensus [44]. Such noticeable eï¬€orts are well illustrated with the series

of attempts to verify the Stellar Consensus Protocol (SCP) [43]: Ivy is used to model a slightly diï¬€erent algorithm in

which the key novelty of the SCP consensus algorithm, which is its dynamic quorum system [51] called quorum slices,

is replaced by static quorums [45]. In addition, it relies on axioms some of which are proved separately in Isabelle/HOL

without being linked to the Ivy axioms [22]. Without a holistic approach, the veriï¬cation of the components of a

protocol does not imply that the protocol is veriï¬ed.

1.2 Contributions

In this paper, we verify holistically the safety and liveness properties of a Byzantine consensus used in the Red Belly

Blockchain system [20], a scalable blockchain used in production. Our approach is holistic because it starts from the

pseudocode of the distributed algorithm as typically presented in the distributed computing literature, models this

pseudocode and its components into disambiguated threshold automata (TAs), model checks the desired properties of

these components expressed in LTL formulae, simpliï¬es the TA of the consensus algorithm with these veriï¬ed prop-

erties and model checks the safety and liveness of the consensus protocol. The advantage is that the formally veriï¬ed

algorithm matches the pseudocode and no user-deï¬ned invariants or proofs need to be checked, which drastically

reduces the risks of human errors.

3Here deterministic means that randomization is forbidden. However, the environment (e.g., communication delays, scheduler) introduces non-
determinism in the algorithm execution.

2

Holistic Verification of Blockchain Consensus

(1) We formally verify a Byzantine consensus algorithm [19] used for e-voting [14], accountability [18] and

blockchain [20]. This consensus algorithm now runs in the network of the Red Belly Blockchain [20] main-

tained by the Red Belly Network company. It executes in asynchronous rounds that broadcast binary values

and compare the delivered values to the parity of the round to decide. To model check the algorithm holistically,

we replace the partial synchrony assumption by a fairness assumption. Interestingly, our fairness assumption

only requires that in any inï¬nite sequence of rounds, there exists a round where, at all correct processes, a

broadcast instance delivers the same binary value, or bit, ï¬rst.

(2) We exploit the modularity of distributed algorithms in parameterized model checking. We ï¬rst model the con-

sensus algorithm into two simpler algorithms modeled as threshold automata (TAs): (i) an inner broadcast TA

modeling a binary value variant of the reliable broadcast [47] and (ii) an outer decision TA modeling a round-

based execution that inspects the delivered messages [19] to decide. We express the guarantees of the inner

broadcast primitive as temporal logic properties that we automatically verify and we replace the inner TA in the

global TA by a gadget TA that captures the proven temporal speciï¬cation. We automatically verify the global

TA with model checking.

(3) We show the practicality of our veriï¬cation technique by running the parameterized model checker ByMC [36]
for any number ğ‘› of processes and any arbitrary number ğ‘“ < ğ‘›/3 of Byzantine processes. We compare the
execution times when model checking the naive TA encoding the consensus algorithm and when model checking

both the inner TA encoding the broadcast algorithm and then the outer TA. We demonstrate empirically that,

although a parallel execution of ByMC on 64 cores could not prove the safety of the naive TA within 3 days, it

proves both the liveness and safety of the simpliï¬ed TA in about 70 seconds.

1.3 Outline

In Section 2 we introduce our preliminary deï¬nitions, in Section 3 we model our binary value broadcast algorithm

pseudocode into a corresponding threshold automaton, in Section 4 we explain how the formal veriï¬cation of the

properties of the broadcast algorithm helps us model check the consensus algorithm and in Section 5 we verify the

consensus algorithm. In Section 6 we present the results of the model checker. In Section 7, we present the related

work and in Section 8, we conclude. In the Appendix we explain the multiple-round TA to one-round TA reduction (A),

provide examples related to fairness (B), missing proofs (C and E) and detailed speciï¬cations (D and F).

2 PRELIMINARIES

The consensus algorithm runs over ğ‘› asynchronous sequential processes from the set Î  = {ğ‘1, . . . , ğ‘ğ‘›}. The pro-
cesses communicate by exchanging messages through an asynchronous reliable fully connected point-to-point net-

work, hence there is no bound on the delay to transfer a message but this delay is ï¬nite.

Failure model. Up to ğ‘¡ < ğ‘›/3 processes can exhibit a Byzantine behavior [54], and behave arbitrarily. We refer to
ğ‘“ â‰¤ ğ‘¡ as the actual number of Byzantine processes. A Byzantine process is called faulty, a non-faulty process is correct.

Algorithm semantics. The asynchronous semantics of a distributed algorithm executed by processes in Î  assumes
discrete time and at each point in time, exactly one process takes a step. We assume that two messages cannot be

received at the same time by the same process. The global execution then consists in an interleaving of the individual
steps taken by the processes. Process ğ‘ğ‘– sends a message to ğ‘ ğ‘— by invoking the primitive â€œsend header(ğ‘š) to ğ‘ ğ‘— â€, where

3

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

header indicates the type of message and ğ‘š its contents. Process ğ‘ğ‘– receives a message by executing the primitive
â€œreceive()â€. The shorthand broadcast(header,ğ‘š) represents â€œfor each ğ‘ ğ‘— âˆˆ Î  do send header(ğ‘š) to ğ‘ ğ‘— â€. And the
right arrow in broadcast(header,ğ‘š) â†’ messages indicates, when speciï¬ed, that â€œupon reception of header(ğ‘š) from
process ğ‘ â€²
ğ‘— ] âˆª {ğ‘š}â€. The process id is used as a subscript to denote that a variable is
local to a processâ€”for instance varğ‘– is local to process ğ‘ğ‘–â€”and is omitted when it is clear from the context.

ğ‘— ] â† messages[ğ‘ â€²

ğ‘— do messages[ğ‘ â€²

The veriï¬cation method considered in this paper exploits the fact that the algorithms are communication-closed [26],

i.e. only messages from the current loop iteration or round of a process may inï¬‚uence its steps. This can be implemented
by tagging every message by its round number ğ‘Ÿ ; during round ğ‘Ÿ all received messages with tag ğ‘Ÿ â€² < ğ‘Ÿ are discarded
and all received messages with tag ğ‘Ÿ â€² > ğ‘Ÿ are stored for later.

The consensus problem. Assuming that each correct process proposes a binary value, the binary Byzantine consen-

sus problem is for each of them to decide on a binary value in such a way that the following properties are satisï¬ed:

(1) Termination. Every correct process eventually decides on a value.

(2) Agreement. No two correct processes decide on diï¬€erent values.

(3) Validity. If all correct processes propose the same value, no other value can be decided.

Threshold automaton (TA). A threshold automaton [37] describes the behavior of a process in a distributed algo-

rithm. Its nodes are locations representing local states, and labeled edges are guarded rules. Formally, it is a tuple
hL, I, Î“, P, R, RCi where L is the set of locations, I âŠ‚ L is the set of initial locations, Î“ is the set of shared variables
that all processes can update, P is the ï¬nite set of parameter variables, R is the set of rules, and RC is the resilience con-
dition over N|Î  |
. Rules are deï¬ned as tuples hfrom, to, ğœ™, Â®ğ‘¢i, where from (resp. to) describes the source (resp. destination)
0
locations, and the rule label is ğœ™ â†¦â†’ Â®ğ‘¢. Formula ğœ™ is called a threshold guard or simply a guard.

1: bv-broadcast(BV, hval, ğ‘–i):
2:

broadcast(BV, hval, ğ‘–i)
repeat:

3:

4:

5:

6:

7:

if (BV, hğ‘£, âˆ—i) received from (ğ‘¡ + 1) distinct processes but not yet re-broadcast then

broadcast(BV, hğ‘£, ğ‘–i)

if (BV, hğ‘£, âˆ—i) received from (2ğ‘¡ + 1) distinct processes then

contestants â† contestants âˆª {ğ‘£ }

Fig. 1. The pseudocode of the binary value broadcast for process ğ‘ğ‘– .

Example 2.1. As an example, Fig. 1 presents the pseudocode of the binary value broadcast and Fig. 2 its TA. (The

modeling of pseudocode (Fig. 1) into TA (Fig. 2) will be described in detail in Section 3.1.) To illustrate the TA notations,
note that two of the locations in L = {ğ‘‰0, ğ‘‰1, ğµ0, ğµ1, ğµ01, ğ¶0, ğ¶1, ğ¶ğµ0, ğ¶ğµ1, ğ¶01} are initial: I = {ğ‘‰0, ğ‘‰1}. Shared variables
are ğ‘0 and ğ‘1 and can be updated by each process traversing the TA, while parameters are ğ‘›, ğ‘¡ and ğ‘“ and remain
unchanged across the execution. The set of rules R consists of {ğ‘Ÿğ‘– | 1 â‰¤ ğ‘– â‰¤ 12} together with 7 self-loops. The self-
loops mimic the asynchrony between processes in the system. For example, rule ğ‘Ÿ3 is deï¬ned as hğµ0, ğ¶0, ğ‘0â‰¥2ğ‘¡+1âˆ’ğ‘“ , Â®0i.
The resilience condition is ğ‘› > 3ğ‘¡ âˆ§ ğ‘¡ â‰¥ ğ‘“ â‰¥ 0.

A multi-round threshold automaton is intuitively deï¬ned such that one round is represented by a threshold automa-

ton, and additional so-called round-switch rules connect ï¬nal locations with initial ones, and therefore allow processes

4

Holistic Verification of Blockchain Consensus

ğ‘Ÿ1 : ğ‘0++

ğ‘‰0

ğµ0

ğ‘Ÿ2 : ğ‘1++

ğ‘

ğ‘‰1

ğµ1

2

â‰¥

ğ‘

0

ğ‘¡ + 1 âˆ’ ğ‘“
ğ‘Ÿ

3

ğ¶0

ğ‘Ÿ4

ğ‘1â‰¥ğ‘¡+1âˆ’ğ‘“ â†¦â†’ğ‘1++
0 â‰¥ ğ‘¡ + 1 âˆ’ ğ‘“ â†¦â†’ ğ‘
ğ‘1â‰¥2ğ‘¡+1âˆ’ğ‘“

0 + +

5

ğ‘Ÿ

ğ‘Ÿ6

ğ¶1

ğµ01

ğ‘1â‰¥ğ‘¡+1âˆ’ğ‘“ â†¦â†’ğ‘1++
ğ‘Ÿ7
ğ‘¡ + 1 âˆ’ ğ‘“
ğ‘Ÿ

â‰¥

ğ‘

2

0

8

ğ¶ğµ0

ğ‘1â‰¥2ğ‘¡+1âˆ’ğ‘“

ğ‘Ÿ9

ğ‘

ğ‘1â‰¥2ğ‘¡+1âˆ’ğ‘“
ğ‘Ÿ11
ğ‘¡ + 1 âˆ’ ğ‘“
ğ‘Ÿ

â‰¥

2

0

1

2

ğ¶01

1 âˆ’ ğ‘“ â†¦â†’ ğ‘

ğ‘Ÿ

0

1

0 â‰¥ ğ‘¡ +

ğ‘

0 + +

ğ¶ğµ1

Fig. 2. The threshold automaton model for the binary value broadcast.

to move from one round to the following one. We typically depict those round-switch rules as dotted arrows. Examples

of such multi-round TA are depicted later in Figures 3 and 4. When it is clear from the context that there are multiple

rounds, we simply call them threshold automata, and to stress that a TA does not have multiple rounds, we may call it

a one-round TA.

Counter systems. The semantics of a (one-round) threshold automaton TA are given by a counter system Sys(TA) =
hÎ£, ğ¼,ğ‘‡ i where Î£ is the set of all conï¬gurations among which ğ¼ are the initial ones, and ğ‘‡ is the transition relation. A
conï¬guration ğœ âˆˆ Î£ of a one-round TA captures the values of location counters (counting the number of processes
at each location of L, therefore non-negative integers), values of global variables, and parameter values. A transition
ğ‘¡ âˆˆ ğ‘‡ is unlocked in ğœ if there exists a rule ğ‘Ÿ = hfrom, to, ğœ™, Â®ğ‘¢i âˆˆ R such that ğœ™ evaluates to true in ğœ, and location counter
of from is at least 1, denoted ğœ… [from] â‰¥ 1, showing that at least one process is currently in from. In this case we can

execute transition ğ‘¡ on ğœ by moving a process along the rule ğ‘Ÿ from location from to location to, which is modeled by
decrementing counter ğœ… [from], incrementing ğœ… [to], and updating global variables according to the update vector Â®ğ‘¢.

A counter system Sys(TA) of a multi-round TA is deï¬ned analogously. A conï¬guration captures the values of location

counters and global variables in each round, and parameter values (that do not change over rounds). Then we deï¬ne

that a transition is unlocked in a round ğ‘… by evaluating the guard ğœ™ and the counter of location from in the round ğ‘….
The execution of the transition in ğœ accordingly updates ğœ… [from, ğ‘…], ğœ… [to, ğ‘…] and global variables of that round, while

the values of these variables in other rounds stay unchanged.

Linear temporal logic notations. Following a standard model checking approach, we use formulas in linear temporal

logic (LTL) [55] to formalize the desired properties of distributed algorithms. The basic elements of these formulas,

called atomic propositions, are predicates over conï¬gurations related (i) to the emptiness of each location at each
round and (ii) to the evaluation of threshold guards in each round. They have the following form: (i) ğœ… [ğ¿, ğ‘…] â‰  0
expresses that at least one correct process is in location ğ¿ in round ğ‘…, while ğœ… [ğ¿, ğ‘…] = 0 expresses the opposite (in
one-round systems we just write ğœ… [ğ¿] â‰  0 or ğœ… [ğ¿] = 0); (ii) the evaluation of [ğ‘0, ğ‘…]â‰¥2ğ‘¡+1âˆ’ğ‘“ depends on the values
of the shared variable ğ‘0 in round ğ‘… and parameters ğ‘¡ and ğ‘“ (in one-round systems we just write ğ‘0â‰¥2ğ‘¡+1âˆ’ğ‘“ ). LTL
builds on propositional logic with â‡’ for â€˜implicationâ€™, âˆ¨ for â€˜orâ€™ and âˆ§ for â€˜andâ€™, and has extra temporal operators â™¦
standing for â€˜eventuallyâ€™ and (cid:3) for â€˜alwaysâ€™. LTL formulas are evaluated over inï¬nite runs of Sys(TA). Examples of LTL

5

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

properties in a one-round system are (BV-Justv), (BV-Oblv) and (BV-Unifv) (see page 8). LTL properties in multi-round
systems often have quantiï¬ers over round variables, as for example in (Agreeğ‘£) and (Validğ‘£) (see page 12).

The tool ByMC is used to automatically verify a speciï¬c fragment of LTL on one-round systems [35, 36], which is

suï¬ƒcient to express safety and liveness properties of consensus [10]. Moreover, thanks to communication-closure, the

veriï¬cation for this fragment of temporal logic on multi-round systems reduces to one-round systems [10, Theorem 6]

(see also Appendix A).

The assumption of reliable communication is modeled as follows at the TA level: if the guard of a rule is true inï¬nitely

often, then the origin location of that rule will eventually be empty. This reï¬‚ects that an if branch of the pseudo-code

is taken if the condition is true. This progress assumption is in particular crucial to prove liveness properties: in the

sequel, we prepend it to the liveness properties in the TA speciï¬cation.

3 THE BINARY VALUE BROADCAST

To overcome the limited scalability of model checking tools, our holistic veriï¬cation approach consists of decomposing

a distributed algorithm into encapsulated components of pseudocode that can be modelled in threshold automata and

veriï¬ed in isolation to obtain a simpliï¬ed threshold automaton that is amenable to automated veriï¬cation.

In this section we focus on a binary value broadcast, or bv-broadcast for short, that will serve as the main building

block of the Byzantine consensus algorithm of Section 4. In Section 3.1 we formally model the bv-broadcast algorithm

pseudocode as a threshold automaton that tolerates a number ğ‘“ of Byzantine failures upper-bounded by ğ‘¡ among ğ‘›

processes. In Section 3.2 we model the speciï¬cation of bv-broadcast in LTL and verify, within 10 seconds, that it holds.

In Section 3.3 we introduce the fairness of an inï¬nite sequence of executions of bv-broadcast that will play a crucial

role in verifying holistically in Section 5 the Byzantine consensus algorithm.

3.1 Modeling the binary value broadcast pseudocode into a threshold automaton

The binary value broadcast [47], or bv-broadcast for short, is a communication primitive guaranteeing that all binary

values â€œbv-deliveredâ€ were â€œbv-broadcastâ€ by a correct process. It is particularly useful to solve the Byzantine consensus

problem with randomization [15, 48] or partial synchrony [14, 19]. As discussed before, Figures 1 and 2 in Section 2

give its pseudocode and the corresponding threshold automaton, respectively. We now explain how we model our

bv-broadcast pseudocode (Fig. 1) parameterized by ğ‘› and ğ‘“ into a threshold automaton (Fig. 2) using the synthesis

methodology [41].

Pseudocode of the binary value broadcast. The bv-broadcast algorithm pseudocode (Fig. 1) aims at having at least
2ğ‘¡+1 processes broadcasting the same binary value. Each process starts this algorithm in one of two states, depending
on its input value 0 or 1. Once a correct process receives a value from ğ‘¡+1 distinct processes, it broadcasts it (line 4)

if it did not do it already (line 4); broadcast is not Byzantine fault tolerant and just sends a message to all the other
processes. Once a correct process receives a value from 2ğ‘¡+1 distinct processes, it delivers it. Here the delivery at
process ğ‘ğ‘– is modeled by adding the value to the set contestants, which will simplify the pseudocode of the Byzantine
consensus algorithm in Section 4.1.

Threshold automaton of the binary value broadcast. To match the two initial states from which a process starts
the bv-broadcast algorithm, we start the corresponding TA of Fig. 2 with two initial locations ğ‘‰0 or ğ‘‰1, indicating
whether the (correct) process initially has value 0 or 1, resp. We can see form the pseudocode (Fig. 1) that a correct

6

Holistic Verification of Blockchain Consensus

process ğ‘ğ‘– sends only two types of messages, (BV, h0, ğ‘–i) and (BV, h1, ğ‘–i), these trigger the corresponding receptions
at other processes. We thus deï¬ne in the TA (Fig. 2) two global variables ğ‘0 and ğ‘1, resp., to capture the number of
the two types of messages sent by correct processes. Thus, for example, ğ‘0++ models a process broadcasting message
(BV, h0, ğ‘–i). Because the algorithm only counts messages regardless of sender identities, we replace the messages from
the pseudocode into ğ‘0 and ğ‘1 shared variables that are increased whenever a message is sent.

From local to global variables for model checking. While producing a formal model, extra care is needed to avoid
introducing redundancies. For example, line 4 indicates that the process broadcasts value ğ‘£ if it received ğ‘£ from ğ‘¡+1

distinct processes. Instead of maintaining local receive variables, it is suï¬ƒcient to enable a guard based on global send

variables. Indeed, to remove redundant local receive variables, one can use the quantiï¬er elimination for Presburger

arithmetic [56] and obtain quantiï¬er-free guard expressions over the shared variables that are valid inputs to ByMC [34,

38]. For more details, note that Stoilkovska et al. [61] eliminated the quantiï¬er over the similar receive variables in

Ben-Orâ€™s consensus algorithm [8] with the SMT solver Z3 [21]. Finally, the point-to-point reliable channels ensure
that ğ‘ ğ‘— sends message ğ‘š to ğ‘ğ‘– implies that eventually ğ‘ğ‘– receives message ğ‘š from ğ‘ ğ‘— . Hence shared variables ğ‘0 and
ğ‘1 of the TA denote, respectively, the number of messages (BV, h0, ğ‘–i) and (BV, h1, ğ‘–i) sent by correct processes in the
pseudocode.

Modeling arbitrary (Byzantine) behaviors in the TA. In order to model that, among the received messages, ğ‘“

messages could have been sent by Byzantine processes, we need to map the â€˜ifâ€™ statement of the pseudocode, comparing
the number of receptions from distinct processes to ğ‘¡+1, to the TA guards, comparing the number ğ‘1+ğ‘“ of messages
sent to ğ‘¡ + 1. As ğ‘1 counts the messages sent by correct processes and ğ‘“ is the number of faulty processes that can send
arbitrary values, a correct process can move from ğµ0 to ğµ01 as soon as ğ‘¡+1âˆ’ğ‘“ correct processes have sent 1, provided
that ğ‘“ faulty processes have also sent 1. As a result, the guard of rule ğ‘Ÿ4 only evaluates over global send variables as: if
more than ğ‘¡+1 messages of type ğ‘1 have been sent by correct processes (hence the guard ğ‘1 â‰¥ ğ‘¡+1âˆ’ğ‘“ ), then the shared
variable ğ‘1 is incremented, mimicking the broadcast of a new message of type ğ‘1. Rule ğ‘Ÿ3 corresponds to lines 6â€“7 and
delivers value ğ‘£ = 0 by storing it into variable contestants upon reception of this value from 2ğ‘¡ + 1 distinct processes.
Hence, reaching location ğ¶0 in the TA indicates that the value 0 has been delivered. As a process might stay in this
location forever, we add a self-loop with guard condition set to true.

locations

ğ‘‰0 ğ‘‰1 ğµ0 ğµ1 ğµ01 ğ¶0 ğ¶ğµ0 ğ¶1 ğ¶ğµ1 ğ¶01

val. broadcast

val. delivered

/

/

/

/

0

/

1

/

0,1

/

0

0

0,1

0

1

1

0,1

1

0,1

0,1

Table 1. The locations of correct processes

Other locations and rules. The locations of the automaton correspond to the exclusive situations for a correct process
depicted in Table 1. After location ğ¶0, a process is still able to broadcast 1 and eventually deliver 1 after that. After
location ğµ01, a process is able to deliver 0 and then deliver 1, or deliver 1 ï¬rst and then deliver 0, depending on the
order in which the guards are satisï¬ed. Apart from the self-loops, note that the automaton is a directed acyclic graph.

7

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

Also, on every path in the graph, a shared variable is incremented only once. This reï¬‚ects that in the pseudocode, a

value may only be broadcast if it has not been broadcast before.

3.2 Properties of the binary value broadcast

As was previously proved by hand [47, 48], the bv-broadcast primitive satisï¬es four properties: BV-Justiï¬cation, BV-

Obligation, BV-Uniformity and BV-Termination. Here, we formalize these properties in linear temporal logic (LTL) to

formally and automatically prove they hold. As we will discuss in Section 6, we verify them for any parameters ğ‘› and
ğ‘¡ < ğ‘›/3 in less then 10 seconds.

The BV-Justiï¬cation property states: â€œIf ğ‘ğ‘– is correct and ğ‘£ âˆˆ contestantsğ‘–, then ğ‘£ has been bv-broadcast by some
correct processâ€ where ğ‘£ âˆˆ {0, 1}. Alternatively, â€œif ğ‘£ is not bv-broadcast by some correct process and ğ‘ğ‘– is correct,
then ğ‘£ âˆ‰ contestantsğ‘–â€. In the TA from Fig. 2, ğ‘£ âˆˆ contestantsğ‘– corresponds to process ğ‘– being in one of the locations ğ¶ğ‘£,
ğ¶ğµğ‘£ or ğ¶01. Thus, justiï¬cation can be expressed in LTL as the conjunction BV-Just0 âˆ§ BV-Just1 where, BV-Justv is the
following formula:

ğœ… [ğ‘‰ğ‘£] = 0 â‡’ (cid:3)

ğœ… [ğ¶ğ‘£] = 0 âˆ§ ğœ… [ğ¶ğµğ‘£] = 0 âˆ§ ğœ… [ğ¶01] = 0
(cid:0)

(cid:1)

.

(BV-Justv)

BV-Obligation requires that if at least (ğ‘¡+1) correct processes bv-broadcast the same value ğ‘£, then ğ‘£ is eventually
added to the set contestantsğ‘– of each correct process ğ‘ğ‘–. This can again be formalized as BV-Obl0 âˆ§ BV-Obl1 where
BV-Oblv is the following formula:

(cid:3)

(cid:16)ğ‘ğ‘£ â‰¥ ğ‘¡+1 â‡’ â™¦

(cid:0) Ã›
ğ¿ âˆˆLocsğ‘£

ğœ… [ğ¿] = 0

(cid:1)(cid:17) ,

(BV-Oblv)

where Locsğ‘£ = {ğ‘‰0, ğ‘‰1, ğµ0, ğµ1, ğµ01, ğ¶1âˆ’ğ‘£, ğ¶ğµ1âˆ’ğ‘£} are all the possible locations of a process ğ‘– if ğ‘£ âˆ‰ contestantsğ‘– .

BV-Uniformity requires that if a value ğ‘£ is added to the set contestantsğ‘– of a correct process ğ‘ğ‘–, then eventually
ğ‘£ âˆˆ contestants ğ‘— at every correct process ğ‘ ğ‘— . We formalize this as BV-Unif0 âˆ§ BV-Unif1 where BV-Unifv is the following:

â™¦ (ğœ… [ğ¶ğ‘£]â‰ 0 âˆ¨ ğœ… [ğ¶ğµğ‘£]â‰ 0 âˆ¨ ğœ… [ğ¶01]â‰ 0) â‡’ â™¦

ğœ… [ğ¿]=0 ,

Ã›
ğ¿ âˆˆLocsğ‘£

(BV-Unifv)

where Locsğ‘£ is deï¬ned as in (BV-Oblv).

Finally, the BV-Termination property claims that eventually the set contestantsğ‘– of each correct process ğ‘ğ‘– is non

empty. This can be phrased as the following LTL formula BV-Term:

â™¦

ğœ… [ğ‘‰0]=0 âˆ§ ğœ… [ğ‘‰1]=0 âˆ§ ğœ… [ğµ0]=0 âˆ§ ğœ… [ğµ1]=0 âˆ§ ğœ… [ğµ01]=0
(cid:0)

(cid:1)

,

(BV-Term)

forcing each correct process to be in one of the â€œï¬nalâ€ locations ğ¶0, ğ¶1, ğ¶01, ğ¶ğµ0, ğ¶ğµ1.

3.3 A fairness assumption to solve consensus

The traditional approach to establishing guarantee properties in veriï¬cation is to require that all fair computations,

instead of all computations, satisfy the property [4]. We thus introduce the fairness assumption that will be crucial in

the rest of this paper. In order to deï¬ne it, we ï¬rst deï¬ne a good execution of the bv-broadcast with respect to binary

value ğ‘£ as an execution:

Deï¬nition 3.1 (ğ‘£-good bv-broadcast). A bv-broadcast execution is ğ‘£-good if all its correct processes bv-deliver ğ‘£ ï¬rst.

We express this property in LTL. A bv-broadcast execution is ğ‘£-good if no process ever visits locationsğ¶1âˆ’ğ‘£ and ğ¶ğµ1âˆ’ğ‘£:

(cid:3)

(cid:16)ğœ… [ğ¶1âˆ’ğ‘£] = 0 âˆ§ ğœ… [ğ¶ğµ1âˆ’ğ‘£] = 0(cid:17) .
8

Holistic Verification of Blockchain Consensus

Second, we consider an inï¬nite sequence of bv-broadcast executions, tagged with ğ‘Ÿ âˆˆ N. It is important to stress that
the setting is asynchronous, that is, processes invoke bv-broadcast inï¬nitely many times, but at their own relative speed.

Thus, they do not all invoke the bv-broadcast tagged with the same number ğ‘Ÿ at the same time. Nonetheless, every
process invokes bv-broadcast inï¬nitely many times and in the ğ‘Ÿ th invocation its behavior depends on the messages
sent in the ğ‘Ÿ th invocation of other processes. Therefore, we refer to the ğ‘Ÿ th execution of bv-broadcast even though the
processes invoke it at diï¬€erent times.

Deï¬nition 3.2 (fairness). An inï¬nite sequence of bv-broadcast executions is fair if there exists an ğ‘Ÿ such that the ğ‘Ÿ th

execution is (ğ‘Ÿ mod 2)-good.

For simplicity, we use the terminology fair bv-broadcast when the inï¬nite sequence of bv-broadcast executions is

fair. We illustrate in Appendix B a possible execution of bv-broadcast whose existence implies fairness.

4 SIMPLIFIED AUTOMATON FOR BYZANTINE CONSENSUS

In this section we exploit the results of the ï¬rst veriï¬cation phase of Section 3 to simplify the threshold automaton of

the Byzantine consensus algorithm. In Section 4.1 we introduce the pseudocode of the Byzantine consensus algorithm

and its threshold automaton obtained with the naive modeling described in Section 3.1. In Section 4.2 we replace, in

this threshold automaton, the inner bv-broadcast automaton by a smaller one obtained thanks to the bv-broadcast

properties that are now veriï¬ed. The veriï¬cation of the resulting simpliï¬ed automaton is deferred to Section 5.

4.1 The Byzantine consensus algorithm

Algorithm 1 is the DBFT Byzantine consensus algorithm [19] that relies on the fair binary value broadcast of Section 3.

It is currently used in the Red Belly Blockchain, a recent blockchain that achieves unprecedented scalability [20]. More

precisely, the DBFT binary consensus comes in two diï¬€erent variants: (i) a ï¬rst variant that is safe but not live in the

asynchronous setting, (ii) a second variant that is safe and live under the partial synchrony assumption. We use the

ï¬rst variant of it (without coordinator or timeout) here and show that it is live under our new fairness assumption.
The DBFT binary consensus invokes bv-broadcast(Â·) at line 6 and uses a set contestants of binary values, whose scope
is global, updated by the bv-broadcast (Fig. 1, line 7) and accessed by the procedure propose(Â·) (Alg. 1, line 7).

9

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

Algorithm 1 The Byzantine consensus algorithm at process ğ‘ğ‘–

1: Global scope variable:

2:

contestants âŠ† {0, 1}, set of binary values, init. âˆ….

3: propose(est):
ğ‘Ÿ â† 0

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

repeat:

bv-broadcast(est, hest, ğ‘– i)
wait until (contestants â‰  âˆ…)

broadcast(aux, hcontestants, ğ‘– i) â†’ favorites
wait until âˆƒğ‘1, . . . , ğ‘ğ‘›âˆ’ğ‘¡ : âˆ€1 â‰¤ ğ‘— â‰¤ ğ‘› âˆ’ ğ‘¡ favorites [ğ‘ ğ‘— ] â‰  âˆ… âˆ§ (qualiï¬ers â† âˆªâˆ€1â‰¤ ğ‘— â‰¤ğ‘›âˆ’ğ‘¡ favorites [ğ‘ ğ‘— ]) âŠ† contestants

if qualiï¬ers = {ğ‘£ } then

est â† ğ‘£
if ğ‘£ = (ğ‘Ÿ mod 2) then decide (ğ‘£)

else est â† (ğ‘Ÿ mod 2)

ğ‘Ÿ â† ğ‘Ÿ + 1

As mentioned in Section 2, recall that the algorithm is communication-closed, so that for simplicity in the presen-

tation we omit the current round number ğ‘Ÿ as the subscript of the variables and the parameter of the function calls.
Variable favorites is an array of ğ‘› indices whose ğ‘— th slot records, upon delivery, the message broadcast by process ğ‘— in
the current round. Each process ğ‘ğ‘– manages the following local variables: the current estimate est, initially the input
value of ğ‘ğ‘–; and a set of binary values qualiï¬ers. This algorithm maintains a round number ğ‘Ÿ , initially 0 (line 4), and
incremented at the end of each iteration of the loop at line 14. Process ğ‘ğ‘– exchanges est and aux messages (lines 6â€“8),
until it receives aux messages from ğ‘› âˆ’ ğ‘¡ distinct processes whose values were bv-delivered by ğ‘ğ‘– (line 9). Process ğ‘ğ‘–
then tries at line 12 to decide a value ğ‘£ that depends on the content of qualiï¬ers and the parity of the round. If qualiï¬ers
is a singleton there are two possible cases: if the value is the parity of the round then ğ‘ğ‘– decides this value (line 12),
otherwise it sets its estimate to this value (line 11). If favorites contains both binary values, then ğ‘ğ‘– sets its estimate to
the parity of the round (line 13). Although ğ‘ğ‘– does not exit the inï¬nite loop to help other processes decide, it can safely
exit the loop after two rounds at the end of the second round that follows the ï¬rst decision because all processes will
be guaranteed to have decided. Note that even though a process may invoke decide(Â·) multiple times at line 12, only

the ï¬rst decision matters as the decided value does not change (see Section 5).

The eï¬€ect of fairness. Note that the fairness notion from Section 3.3 ensures there is a round ğ‘Ÿ in which all correct
processes bv-deliver (ğ‘Ÿ mod 2) ï¬rst. The following lemma states that under the fairness assumption there is a round

of Algorithm 1 in which all correct processes start with the same estimate. The proof is deferred to Appendix C.

Lemma 4.1. If the inï¬nite sequence of bv-broadcast executions of Algorithm 1 is fair, with the ğ‘Ÿ th execution being

(ğ‘Ÿ mod 2)-good, then all correct processes start round ğ‘Ÿ +1 of Algorithm 1 with estimate ğ‘Ÿ mod 2.

Modeling deterministic consensus. Figure 3 depicts the threshold automaton (TA) obtained by modeling Algo-

rithm 1 with the method we detailed in Section 3.1. The TA depicts two iterations of the repeat loop (line 5), since

10

Holistic Verification of Blockchain Consensus

ğ‘Ÿ1 : ğ‘0 ++

ğ¶0

ğ‘Ÿ

3

ğ‘Ÿ4

ğµ0

ğ‘Ÿ2 : ğ‘1 ++

ğµ01

ğ‘Ÿ

5

ğµ1

ğ‘Ÿ6

ğ¶1

ğ‘‰0

ğ‘‰1

ğ¶ğµ0

ğ¶ğµ1

ğ‘Ÿ7

ğ‘Ÿ

8

ğ‘Ÿ9
ğ‘Ÿ

1 0

ğ‘Ÿ13

ğ‘Ÿ11

ğ‘Ÿ

2

1

ğ‘Ÿ19

ğ‘Ÿ20

1 : ğ‘ â€²
ğ‘Ÿ â€²

0 ++

ğ‘Ÿ â€²

3

ğ‘Ÿâ€²
4

ğ¶ â€²
0

ğµ â€²
0

ğ‘Ÿâ€²
7

â€²

8

ğ‘Ÿ

2 : ğ‘ â€²
ğ‘Ÿ â€²

1 ++

ğµ â€²
01

ğ‘Ÿ â€²

5

ğµ â€²
1

ğ‘Ÿâ€²
6

ğ¶ â€²
1

ğ‘Ÿâ€²
9
â€²

1 0

ğ‘Ÿ

ğ‘Ÿ 1 4

ğ¶01

ğ‘Ÿ18

ğ‘Ÿ 1 5

ğ‘Ÿ16

ğ‘Ÿ
17

ğ‘‰ â€²
0

ğ‘‰ â€²
1

ğ¸0

ğ¸1

ğ·1

ğ‘Ÿ21

ğ‘Ÿ 22

ğ¶ğµ â€²
0

ğ¶ğµ â€²
1

ğ‘Ÿ â€²
13

ğ‘Ÿâ€²
11

â€²

ğ‘Ÿ

2

1

ğ‘Ÿ â€²
19

ğ‘Ÿ â€²
1 4

ğ¶ â€²
01

ğ‘Ÿâ€²
18

ğ·0

â€²
ğ‘Ÿ

1 5

ğ‘Ÿ â€²
16

ğ‘Ÿâ€²
17

ğ¸â€²
0

ğ¸â€²
1

Fig. 3. The naive threshold automaton of the Byzantine consensus of Algorithm 1 where the embedded bv-broadcast automaton
is depicted with dashed arrows. Precise formulations of all rules are in Appendix D. Note that the rules ğ‘Ÿ20, ğ‘Ÿ21 and ğ‘Ÿ22 represent
transitions from the end of an odd round to the beginning of the following (even) round of Algorithm 1, while the dotted edges
represent transitions from the end of an even round to the beginning of the following (odd) one.

Algorithm 1 favors diï¬€erent values depending on the parity of the round number. For simplicity, we refer to the con-

catenation of two consecutive rounds of the algorithm as a superround of the TA. As one can expect, this TA embeds

the TA of the bv-broadcast which is depicted by the dashed arrows, just as Algorithm 1 invokes the bv-broadcast algo-

rithm of Fig. 1. We thus distinguish the outer TA modeling the consensus algorithm from the inner TA modeling the

bv-broadcast algorithm. Although Algorithm 1 is relatively simple, the global TA happens to be too large to be veriï¬ed

through model checking, as we explain in Section 6; the main limiting factor is its 14 unique guards that constrain the

variables to enable rules in the TA. The detail of each rule of the TA is deferred to Appendix D.

4.2 Simplified threshold automaton

Our objective is to formally prove that Algorithm 1 is unconditionally safe, and that it is live under the assumption of

fairness at the bv-broadcast level. Since the threshold automaton of Figure 3 is too large to be handled automatically,

we build on the properties proved for the bv-broadcast to simplify in the threshold automaton from Figure 3 the part

representing the bv-broadcast. On the resulting simpler threshold automaton, assuming fairness of the bv-broadcast,

we prove the termination of Algorithm 1 with the Byzantine model checker ByMC in Section 6.

High-level idea. Ideally, the simpliï¬ed threshold automaton could be obtained from the one of Fig. 3 by merging all

internal states of the bv-broadcast into a single state with two possible outcomes. However, such a merge is not trivial

because the bv-broadcast procedure â€œleaksâ€ into the consensus algorithm. First of all, line 7 of Algorithm 1 refers to

contestants, a global variable that is modiï¬ed by the bv-broadcast algorithm (Fig. 1). Second, a process can execute

line 8 of Algorithm 1 even if the bv-broadcast has not terminated. To capture this porosity, we introduce a new shared

variable, some additional states and a transition rule that exploits a correctness property of the bv-broadcast.

A superround ğ‘… of the simpliï¬ed automaton from Fig. 4 captures round 2ğ‘…âˆ’1 followed by round 2ğ‘… of Algorithm 1.

One can thus restate Lemma 4.1 as the following corollary in the TA terminology. The proof is deferred to Appendix E.

â€¢ If there exists ğ‘… âˆˆ N with ğ‘Ÿ = 2ğ‘…âˆ’1, then (cid:3)
â€¢ If there exists ğ‘… âˆˆ N with ğ‘Ÿ = 2ğ‘…, then (cid:3) (ğœ… [ğ‘€ â€²

Corollary 4.2. Let ğ‘Ÿ âˆˆ N be such that the ğ‘Ÿ th execution of bv-broadcast in Algorithm 1 is (ğ‘Ÿ mod 2)-good. Then:
ğœ… [ğ‘€0, ğ‘…] = 0) holds.
(cid:0)
1, ğ‘…] = 0
11

holds.

(cid:1)

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

+

+

0

1â†¦â†’ ğ‘

ğ‘€0

ğ‘ 1:bvb

0++

â‰¥

b

0

v

ğ‘  3: b

ğ‘€

+

+

b

1

v

b

2 :

ğ‘ 

ğ‘ 
4:

bvb

1â‰¥

1â†¦â†’

ğ‘

1+

+

ğ‘‰0

ğ‘‰1

ğ‘ 5 : ğ‘0 â‰¥ ğ‘› âˆ’ ğ‘¡ âˆ’ ğ‘“

ğ‘ 
6:

b

v

b
1

â‰¥

1

ğ‘€01

â‰¥1
bvb0

:
ğ‘ 7

ğ‘“

âˆ’

âˆ’ ğ‘¡

ğ‘›

â‰¥

ğ‘

0

ğ‘ 

9 :
ğ‘ 10 : ğ‘0+ğ‘1â‰¥ğ‘›âˆ’ğ‘¡âˆ’ğ‘“

ğ‘ 11:ğ‘

1â‰¥

ğ‘›âˆ’ğ‘¡âˆ’ğ‘“

ğ‘€1

ğ‘ 8 : ğ‘1 â‰¥ ğ‘› âˆ’ ğ‘¡ âˆ’ ğ‘“

ğ‘  â€²
1

ğ‘  â€²
2

ğ¸0

ğ¸1

ğ‘ 12

ğ‘‰ â€²
0

ğ‘‰ â€²
1

ğ‘ 13

ğ‘ 14

ğ·1

ğ‘  â€²
3

ğ‘€ â€²
0

ğ‘  â€²
6

ğ‘€ â€²

ğ‘  â€²
4

ğ‘€ â€²
01

ğ‘  â€²
7

ğ‘€ â€²
1

ğ‘  â€²
9

ğ‘  â€²
10

ğ‘  â€²
11

ğ‘  â€²
5

ğ‘  â€²
8

ğ·0

ğ¸â€²
0

ğ¸â€²
1

Fig. 4. The simplified threshold automaton of the Byzantine consensus of Algorithm 1 obtained after model checking the bv-
ğ‘— , 1 â‰¤ ğ‘– â‰¤ 11, are obtained from ğ‘  ğ‘— by replacing each variable ğ‘ âˆˆ {ğ‘0, ğ‘1, bvb0, bvb1 } with its corresponding
broadcast. Rules ğ‘ â€²
one ğ‘â€².

5 VERIFICATION OF BYZANTINE CONSENSUS

In this section we formally prove that Algorithm 1 solves the Byzantine consensus problem with the fair bv-broadcast

and without partial synchrony. (Appendix B provides a counter-example illustrating why the algorithm does not termi-

nate without the fair broadcast.) In particular, we apply a methodology developed for crash fault tolerant randomized

consensus [10] to our context to prove both the safety (Section 5.1) and liveness (Section 5.2) properties of the deter-

ministic Byzantine consensus algorithm.

5.1 Safety

Under no fairness assumption, one can prove the safety propertiesâ€”agreement and validityâ€”of the Byzantine consen-

sus based on bv-broadcast. Precisely, we formulate these properties in LTL and want to establish that they hold on the

threshold automaton of Fig. 4.

Agreement requires that no two correct processes disagree, that is, if one process decides ğ‘£ then no process should
decide 1âˆ’ğ‘£ for all binary values ğ‘£ âˆˆ {0, 1}. Thus, we want to prove that the following formula holds for both values

of ğ‘£:

âˆ€ğ‘… âˆˆ N, âˆ€ğ‘…â€² âˆˆ N

(Agreeğ‘£)
stating that for any two superrounds ğ‘… and ğ‘…â€², if eventually a process decides ğ‘£, then globally (in any superround) no
process will decide 1 âˆ’ ğ‘£. In terms of the TA from Fig. 4, if a process enters location ğ·ğ‘£ no process should enter location
ğ·1âˆ’ğ‘£ (not only in that superround, but in any other).

â™¦ ğœ… [ğ·ğ‘£, ğ‘…] â‰  0 â‡’ (cid:3) ğœ… [ğ·1âˆ’ğ‘£, ğ‘…â€²] = 0(cid:17) ,

(cid:16)

Validity requires that if no process proposes a value ğ‘£ âˆˆ {0, 1}, no process should ever decide that value. Hence, we

want to prove the following formula for both values of ğ‘£:

âˆ€ğ‘… âˆˆ N

(cid:16)ğœ… [ğ‘‰ğ‘£, 1] = 0 â‡’ (cid:3) ğœ… [ğ·ğ‘£, ğ‘…] = 0(cid:17) ,

(Validğ‘£)

stating that if initially no process has value ğ‘£, then globally (in any superround) no process decides ğ‘£. In terms of the
TA, if location ğ‘‰ğ‘£ is initially empty (in superround 1), then no process should enter location ğ·ğ‘£ in any superround.

ByMC can only check formulas of the form âˆ€ğ‘… âˆˆ N ğœ‘ [ğ‘…] (see Appendix A). Thus, automatically checking (Agreeğ‘£)
and (Validğ‘£) is non-trivial, as they both involve two superround numbers: ğ‘… and ğ‘…â€² in (Agreeğ‘£), and 1 and ğ‘… in (Validğ‘£).
We instead check well-chosen one-superround invariants (Inv1ğ‘£) and (Inv2ğ‘£):

12

Holistic Verification of Blockchain Consensus

âˆ€ğ‘… âˆˆ N

(cid:16)

âˆ€ğ‘… âˆˆ N

(cid:16)

â™¦ ğœ… [ğ·ğ‘£, ğ‘…] â‰  0 â‡’ (cid:3)

ğœ… [ğ·1âˆ’ğ‘£, ğ‘…] = 0 âˆ§ ğœ… [ğ¸â€²
(cid:0)
(cid:3) ğœ… [ğ‘‰ğ‘£, ğ‘…] = 0 â‡’ (cid:3)

ğœ… [ğ·ğ‘£, ğ‘…] = 0 âˆ§ ğœ… [ğ¸â€²
(cid:0)

1âˆ’ğ‘£, ğ‘…] = 0

(cid:1)(cid:17) ,

ğ‘£, ğ‘…] = 0

(cid:1)(cid:17) .

(Inv1ğ‘£)

(Inv2ğ‘£)

The choice of these invariants follows a previous approach used for the crash fault tolerant consensus where it is
shown that these invariants imply (Agreeğ‘£) and (Validğ‘£) [10, Proposition 2]. Intuitively, this follows from the fact that
(i) emptiness of ğ·0 and ğ¸â€²
0 in one superround leads to the emptiness of ğ‘‰0 in the next superround, and (ii) emptiness
of ğ¸â€²
1 (and ğ·1) in one superround leads to the emptiness of ğ‘‰1 in the next superround. Therefore, in order to prove
agreement and validity, we only need to prove (Inv1ğ‘£) and (Inv2ğ‘£) for both values ğ‘£ âˆˆ {0, 1}. We successfully do this
automatically with ByMC (see Section 6).

5.2 Liveness

We now aim at proving termination of Algorithm 1. First, we need to prove that every superround eventually termi-

nates, in the sense that for every round eventually there are no processes in any location of that round to the exception
of the ï¬nal ones (ğ·0, ğ¸â€²

1). Formally, using ByMC we prove the following:

0 and ğ¸â€²

âˆ€ğ‘… âˆˆ N â™¦

(cid:16) Ã›
ğ¿ âˆˆL\{ğ·0,ğ¸â€²

0,ğ¸â€²
1 }

ğœ… [ğ¿, ğ‘…] = 0(cid:17) .

(SRoundTerm)

From this property and the shape of the TA from Fig. 4, it easily follows that if no process ever enters ğ¸â€²
1 of
some superround, then all processes visit ğ·0 in that superround. Similarly, if no process ever enters ğ¸0 and ğ¸1 of some
superround, then all processes visit ğ·1 in that superround. This allows us to express termination as the following LTL
property on the threshold automaton of Fig. 4:

0 and ğ¸â€²

âˆƒğ‘… âˆˆ N

(cid:3)

(cid:16)

ğœ… [ğ¸0, ğ‘…] = 0 âˆ§ ğœ… [ğ¸1, ğ‘…] = 0
(cid:0)

âˆ¨ (cid:3)

ğœ… [ğ¸â€²
(cid:0)

0, ğ‘…] = 0 âˆ§ ğœ… [ğ¸â€²

1, ğ‘…] = 0

(cid:1)(cid:17) .

(cid:1)
In words, there is a superround ğ‘… in which either (i) all processes visit ğ·1, or (ii) all processes visit ğ·0. Here again
formula (Term) is non-trivial to check since it contains an existential quantiï¬er over superrounds, that cannot be

(Term)

handled by the model checker ByMC. Adapting the technique from [10, Section 7] to a non-randomized context, it is

suï¬ƒcient to prove a couple of properties on the threshold automaton of Fig. 4, that we detail below. The ï¬rst property
expresses that if no process starts a superround ğ‘… with value ğ‘£, then all processes decide 1âˆ’ğ‘£ in superround ğ‘…:

âˆ€ğ‘… âˆˆ N

(cid:16)

(cid:3)

ğœ… [ğ¸0, ğ‘…] = 0 âˆ§ ğœ… [ğ¸1, ğ‘…] = 0
(cid:0)
ğœ… [ğ¸â€²
(cid:0)
The second property claims that (i) emptiness of ğ‘€0 in superround ğ‘… implies (emptiness of ğ¸0 and therefore also)
emptiness of ğ·0 and ğ¸â€²

ğœ… [ğ‘‰0, ğ‘…] = 0
(cid:0)
ğœ… [ğ‘‰1, ğ‘…] = 0
(cid:0)

1 in superround ğ‘… implies emptiness of ğ¸â€²

0 in ğ‘… and (ii) emptiness of ğ‘€ â€²

0, ğ‘…] = 0 âˆ§ ğœ… [ğ¸â€²

(cid:1)(cid:17)
(cid:1)(cid:17) .

1, ğ‘…] = 0

1 in ğ‘…:

âˆ§ (cid:16)

â‡’ (cid:3)

(Dec)

â‡’ (cid:3)

(cid:3)

(cid:1)

(cid:1)

âˆ€ğ‘… âˆˆ N

(cid:16)(cid:0)

(cid:3) ğœ… [ğ‘€0, ğ‘…] = 0) â‡’ (cid:3) (ğœ… [ğ·0, ğ‘…] âˆ§ ğœ… [ğ¸â€²

0, ğ‘…] = 0)

(cid:1)

âˆ§

(cid:0)

(cid:3) ğœ… [ğ‘€ â€²

1, ğ‘…] = 0) â‡’ (cid:3) ğœ… [ğ¸â€²

1, ğ‘…] = 0

(cid:1)(cid:17) .

(Good)

The main idea is to exploit the fairness of bv-broadcast, which ensures the existence of a round ğ‘Ÿ which is (ğ‘Ÿ mod 2)-
good. Intuitively, the next superround ğ‘… = âŒˆğ‘Ÿ /2âŒ‰ is the desired witness for (Term), namely the one in which all processes
decide (not necessarily for the ï¬rst time). We formalize this in our main result:

13

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

Theorem 5.1. Assuming fairness of the bv-broadcast, Algorithm 1 terminates.

Proof. First we prove formulas (SRoundTerm) and (Dec) and (Good) automatically using the model checker ByMC.

Formula (SRoundTerm) guarantees that formula (Term) indeed expresses termination. Next, we show that formulas

(Dec) and (Good) together imply (Term). Indeed, since we assume fairness of the bv-broadcast, from Corollary 4.2 we

know that there is a superround ğ‘… in which one of the following two scenarios happen:

â€¢ (cid:3) ğœ… [ğ‘€ â€²

1, ğ‘…] = 0. In this case formula (Good) implies (cid:3) ğœ… [ğ¸â€²

1, ğ‘…] = 0. Note that the form of the (dotted) round-
switch rules yield that no process starts the superround ğ‘…+1 with value 1, that is, we have (cid:3) ğœ… [ğ‘‰1, ğ‘…+1] = 0.
Then formula (Dec) implies (cid:3)
, which makes formula (Term) true, that is, all
processes visit ğ·0 in superround ğ‘…+1.

0, ğ‘…+1] = 0 âˆ§ ğœ… [ğ¸â€²

1, ğ‘…+1] = 0

ğœ… [ğ¸â€²
(cid:0)

(cid:1)

â€¢ (cid:3) ğœ… [ğ‘€0, ğ‘…] = 0. In this case formula (Good) implies (cid:3) (ğœ… [ğ·0, ğ‘…]âˆ§ğœ… [ğ¸â€²

. Now the round-switch rules yield
that no process starts the superround ğ‘…+1 with value 0, that is, we have (cid:3) ğœ… [ğ‘‰0, ğ‘…+1] = 0. Then formula (Dec)
implies (cid:3)
, which satisï¬es formula (Term), that is, all processes visit ğ·1 in ğ‘…+1.
As a consequence, our automated proofs of properties (SRoundTerm) and (Dec) and (Good) guarantee termination of
(cid:3)

ğœ… [ğ¸0, ğ‘…+1] = 0 âˆ§ ğœ… [ğ¸1, ğ‘…+1] = 0
(cid:0)

Algorithm 1 under fairness of bv-broadcast.

0, ğ‘…] = 0)

(cid:1)

(cid:1)

6 EXPERIMENTS

In this section, we model check the safety but also the liveness properties of Byzantine consensus for any parameters
ğ‘¡ and ğ‘› > 3ğ‘¡. In particular, we show that we formally verify the simpliï¬ed representation of the blockchain consensus
in less than 70 seconds, whereas we could not model check its naive representation.

Experimental settings. We used the parallelized version of ByMC 2.4.4 with MPI. The bv-broadcast and the simpliï¬ed

automaton were veriï¬ed on a laptop with IntelÂ® Coreâ„¢ i7-1065G7 CPU @ 1.30GHz Ã— 8 and 32 GB of memory. The naive

Threshold Automaton (TA) timed-out even on a 4 AMD Opteron 6276 16-core CPU with 64 cores at 2300MHz with 64

GB of memory. Good and Dec are only relevant for the simpliï¬ed automaton. The speciï¬cation of the termination for

ByMC is deferred to Appendix F.

Results. Table 2 depicts the time (6th column) it takes to verify each property (3rd column) automatically. In particular,

it lists the TA (1st column) on which these properties were tested, as well as the size of these TA (2nd column) as

the number of guards locations and rules they contain. A schema (4th column) is a sequence of unlocked guards

(contexts) and rule sequences that is used to generate execution paths [36] whose average length appears in the 5th

column. It demonstrates the eï¬ƒciency of our approach as it allows to verify all properties of the Byzantine consensus

automatically in less than 70 seconds whereas a non-compositional approach timed out. Although not indicated here,
we also generated a counter-example of Inv10 for ğ‘› > 3ğ‘¡ on the composite automaton in âˆ¼4 s.

7 RELATED WORK

Interactive theorem provers [57, 59, 66] already checked proofs of consensus algorithms used in the blockchain industry.

In particular, Coq helped prove the Raft consensus algorithm [67], which is not Byzantine fault tolerant but part of

crash fault tolerant distributed ledgers [5, 12], and the Byzantine consensus algorithm of the Algorand blockchain [3].

In addition, Dafny [30] proved MultiPaxos, a consensus algorithm that tolerates crash failures. Isabelle/HOL [52] was

used to prove Byzantine fault tolerant algorithms [17] and was combined with Ivy to try to prove the Byzantine

14

Holistic Verification of Blockchain Consensus

TA Size

bv-broadcast
(Fig. 2)

Naive
consensus
(Fig. 3)

Simpliï¬ed
consensus
(Fig. 4)

4 unique
guards
10 locations
19 rules

14 unique
guards
24 locations
45 rules

10 unique
guards
16 locations
37 rules

Property
BV-Just0
BV-Obl0
BV-Unif0
BV-Term

# schemas Avg. length Time
5.61s
90
6.87s
90
27.64s
760
6.75s
90

54
79
97
79

>100 000
Inv10
>100 000
Inv20
SRound-Term >100 000

6
Inv10
Inv20
2
SRound-Term 2
2
Good0
2
Dec0

-
-
-

102
73
109
67
73

>24h
>24h
>24h

4.68s
4.56s
4.13s
4.55s
4.62s

Table 2. Although none of the properties of the naive blockchain consensus could be verified within a day of execution of the model
checker, it takes about âˆ¼4 s to verify each property on the simplified representation of the blockchain consensus. Overall it takes
less than 70 seconds to verify both that the binary value broadcast and the simplified representation of the blockchain consensus
are correct.

consensus protocol of the Stellar blockchain [44] as discussed in the introduction. Theorem provers check proofs, not

the algorithms. Hence, one has to invest eï¬€orts into writing detailed mechanical proofs.

Specialized decision procedures are a way of proving consensus algorithms. They were used to prove Paxos [39],

which could itself be used in the aforementioned crash fault tolerant distributed ledgers. Crash fault tolerant consensus

algorithms were manually encoded with their invariants and properties to prove formulae using the Z3 SMT solver [24].
Decision procedures also proved the safety of Byzantine fault tolerant consensus algorithms when ğ‘“ = ğ‘¡ [9] but not
their termination. Similarly, a proof by reï¬nement of the safety of a Byzantine variant of Paxos was proposed [40]

but its liveness is not proven. These decision procedures require the user to ï¬t the speciï¬cation into a suitable logical

fragment.

Explicit-state model checking fully automates veriï¬cation of distributed algorithms [31, 68]. It allows to check the re-

liable broadcast algorithm [32], a common component of various blockchain consensus algorithms [18, 19, 46]. TLC [68]

checked a reduction of fault tolerant distributed algorithms in the Heard-Of model that exploits their communication-

closed property [16]. And the agreement of consensus algorithms was proved in the asynchronous setting [53]. These

explicit-state tools enumerate all reachable states and thus suï¬€er from state explosion.

Symbolic model checkers [13] cope with this explosion by representing state transitions eï¬ƒciently. NuSMV and SAT

helped check consensus algorithms for up to 10 processes [64, 65]. Apalache [33] uses satisï¬ability modulo theories
(SMT) to check inductive invariants and verify symbolic executions of TLA+ speciï¬cations of the reliable broadcast
and crash fault tolerant consensus algorithms but requires parameters to be ï¬xed. These tools cannot be used to prove

(or disprove) correctness for an arbitrary number of processes.

Parameterized model checking [23] works for an arbitrary number ğ‘› of processes [11]. Although the problem is

undecidable [6] in general, one can verify speciï¬c classes of algorithms [27]. Indeed, distributed algorithms with a

ring-based topology were checked with automata-theoretic method [2] and with Presburger arithmetics formulae

15

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

veriï¬ed by an SMT solver [58]. Bosco [60] has been the focus of various parameterized veriï¬cation techniques [7, 41],

however, it acts as a fast path wrapper around a separate correct consensus algorithm that remains itself to be proven.

The condition-based consensus algorithm [49, 50] was veriï¬ed [7] with the Byzantine model checker ByMC [34, 36, 38],

only under the condition that the diï¬€erence between the numbers of processes initialized with 0 and 1 diï¬€er by at least

ğ‘¡. Recently, the crash fault tolerant Ben-Or consensus algorithm was proved correct with a probabilistic reasoning

extension of ByMC [10]. In this paper, we also exploit ByMC but prove the Byzantine consensus algorithm [19] of an

existing blockchain [20].

8 CONCLUSION

We presented the ï¬rst formal veriï¬cation of a blockchain consensus algorithm thanks to a new holistic approach.

Previous attempts to formally verify the liveness of blockchain consensus consisted of verifying diï¬€erent parts of the

consensus algorithm without verifying the sum of the parts. By modeling directly the pseudocode into a disambiguated

threshold automaton we guarantee that the â€œactualâ€ algorithm is veriï¬ed. By model checking the threshold automaton

without the need for user-deï¬ned invariants and proofs, we drastically reduce the risks of human errors. We believe

that this holistic veriï¬cation technique will help verify or identify bugs in other distributed algorithms based on various

broadcast primitives.

REFERENCES

[1] Ittai Abraham, Guy Golan Gueta, Dahlia Malkhi, Lorenzo Alvisi, Rama Kotla, and Jean-Philippe Martin. 2017. Revisiting Fast Practical Byzantine

Fault Tolerance. Technical Report. arXiv. https://arxiv.org/abs/1712.01367

[2] C. Aiswarya, Benedikt Bollig, and Paul Gastin. 2018. An automata-theoretic approach to the veriï¬cation of distributed algorithms. Information

and Computation 259, 3 (2018), 305â€“327.

[3] Musab A. Alturki, Jing Chen, Victor Luchangco, Brandon M. Moore, Karl Palmskog, Lucas PeÃ±a, and Grigore Rosu. 2019. Towards a Veriï¬ed Model

of the Algorand Consensus Protocol in Coq. In International Workshops on Formal Methods (FMâ€™19). 362â€“367.

[4] Rajeev Alur and Thomas A. Henzinger. 1994. Finitary fairness. In Annual IEEE Symposium on Logic in Computer Science (LICSâ€™94). IEEE Computer

Society Press, 52â€“61.

[5] Elli Androulaki, Artem Barger, Vita Bortnikov, Christian Cachin, Konstantinos Christidis, Angelo De Caro, David Enyeart, Christopher Ferris,
Gennady Laventman, Yacov Manevich, Srinivasan Muralidharan, Chet Murthy, Binh Nguyen, Manish Sethi, Gari Singh, Keith Smith, Alessandro
Sorniotti, Chrysoula Stathakopoulou, Marko VukoliÄ‡, Sharon Weed Cocco, and Jason Yellick. 2018. Hyperledger Fabric: A Distributed Operating
System for Permissioned Blockchains. In ACM European Conference on Computer Systems (CCSâ€™18).

[6] Krzysztof R Apt and Dexter C Kozen. 1986. Limits for Automatic Veriï¬cation of Finite-State Concurrent Systems. Inform. Process. Lett. 22, 6 (May

1986), 307â€“309.

[7] A. R. Balasubramanian, Javier Esparza, and Marijana Lazic. 2020. Complexity of Veriï¬cation and Synthesis of Threshold Automata. In International

Symposium on Automated Technology for Veriï¬cation and Analysis (ATVAâ€™20). 144â€“160.

[8] Michael Ben-Or. 1983. Another Advantage of Free Choice (Extended Abstract): Completely Asynchronous Agreement Protocols. In Annual ACM

Symposium on Principles of Distributed Computing (PODCâ€™83). 27â€“30.

[9] Idan Berkovits, Marijana Lazic, Giuliano Losa, Oded Padon, and Sharon Shoham. 2019. Veriï¬cation of Threshold-Based Distributed Algorithms by

Decomposition to Decidable Logics. In International Conference on Computer Aided Veriï¬cation (CAVâ€™19). 245â€“266.

[10] Nathalie Bertrand, Igor Konnov, Marijana Lazic, and Josef Widder. 2019. Veriï¬cation of Randomized Consensus Algorithms Under Round-Rigid

Adversaries. In International Conference on Concurrency Theory (CONCURâ€™19). 33:1â€“33:15.

[11] Roderick Bloem, Swen Jacobs, Ayrat Khalimov, Igor Konnov, Sasha Rubin, Helmut Veith, and Josef Widder. 2015. Decidability of Parameterized

Veriï¬cation. Morgan & Claypool Publishers.

[12] Richard Gendal Brown, James Carlyle, Ian Grigg, and Mike Hearn. 2016. Corda: An Introduction. R3 CEV, August (2016).
[13] Jerry R. Burch, Edmund M. Clarke, Kenneth L. McMillan, David L. Dill, and L. J. Hwang. 1990. Symbolic Model Checking: 10Ë†20 States and Beyond.

In Annual Symposium on Logic in Computer Science (LICSâ€™90). 428â€“439.

[14] Christian Cachin, Daniel Collins, Tyler Crain, and Vincent Gramoli. 2020. Anonymity Preserving Byzantine Vector Consensus. In European Sym-

posium on Research in Computer Security (ESORICSâ€™20). 133â€“152.

[15] Christian Cachin and Luca Zanolini. 2020. Asymmetric Byzantine Consensus. Technical Report 2005.08795. arXiv.

16

Holistic Verification of Blockchain Consensus

[16] Mouna Chaouch-Saad, Bernadette Charron-Bost, and Stephan Merz. 2009. A Reduction Theorem for the Veriï¬cation of Round-Based Distributed

Algorithms. In International Workshop on Reachability Problems (RPâ€™09). 93â€“106.

[17] Bernadette Charron-Bost, Henri Debrat, and Stephan Merz. 2011. Formal Veriï¬cation of Consensus Algorithms Tolerating Malicious Faults. In SSS.

120â€“134.

[18] Pierre Civit, Seth Gilbert, and Vincent Gramoli. 2021. Polygraph: Accountable Byzantine Agreement. In Proceedings of the 41st IEEE International

Conference on Distributed Computing Systems (ICDCSâ€™21).

[19] Tyler Crain, Vincent Gramoli, Mikel Larrea,

and Michel Raynal.

2018.

and

sus
In International
http://gramoli.redbellyblockchain.io/web/doc/pubs/DBFT-preprint.pdf

its Applications

to Blockchains.

Symposium on Network Computing

DBFT: Eï¬ƒcient Leaderless Byzantine Consen-
(NCAâ€™18).

and Applications

[20] Tyler Crain, Christopher Natoli, and Vincent Gramoli. 2021. Red Belly: A Secure, Fair and Scalable Open Blockchain. In IEEE Symposium on Security

and Privacy (S&Pâ€™21).

[21] Leonardo MendonÃ§a de Moura and Nikolaj BjÃ¸rner. 2008. Z3: An Eï¬ƒcient SMT Solver. In International Conference on Tools and Algorithms for

Construction and Analysis of Systems (TACASâ€™08). 337â€“340.

[22] Stellar developers. [n.d.]. Caveat 3. https://github.com/stellar/scp-proofs Accessed: 13-02-2022.
[23] Rodney G. Downey and Michael R. Fellows. 1999. Parameterized Complexity. Springer.
[24] Cezara Dragoi, Thomas A. Henzinger, Helmut Veith, Josef Widder, and Damien Zuï¬€erey. 2014. A Logic-Based Framework for Verifying Consensus

Algorithms. In International Conference on Veriï¬cation, Model Checking and Abstract Interpretation (VMCAIâ€™14). 161â€“181.

[25] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. 1988. Consensus in the Presence of Partial Synchrony. J. ACM 35, 2 (April 1988), 288â€“323.
[26] Tzilla Elrad and Nissim Francez. 1982. Decomposition of Distributed Programs into Communication-Closed Layers. Science of Computer Program-

ming 2, 3 (1982), 155â€“173.

[27] E. Allen Emerson and Vineet Kahlon. 2000. Reducing Model Checking of the Many to the Few. In International Conference on Automated Deduction

(CADEâ€™17). 236â€“254.

[28] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. 1985. Impossibility of Distributed Consensus with One Faulty Process. J. ACM 32, 2

(April 1985), 374â€“382.

[29] Dana Fisman, Orna Kupferman, and Yoad Lustig. 2008. On Verifying Fault Tolerance of Distributed Protocols. In International Conference on Tools

and Algorithms for Construction and Analysis of Systems (TACASâ€™08). 315â€“331.

[30] Chris Hawblitzel, Jon Howell, Manos Kapritsos, Jacob R. Lorch, Bryan Parno, Michael L. Roberts, Srinath T. V. Setty, and Brian Zill. 2015. IronFleet:

proving practical distributed systems correct. In Symposium on Operating Systems Principles (SOSPâ€™15). 1â€“17.

[31] Gerard Holzmann. 2003. The SPIN Model Checker. Addison-Wesley.
[32] Annu John, Igor Konnov, Ulrich Schmid, Helmut Veith, and Josef Widder. 2013. Towards Modeling and Model Checking Fault-Tolerant Distributed

Algorithms. In International Symposium on Model Checking Software (SPINâ€™13) (LNCS), Vol. 7976. 209â€“226.

[33] Igor Konnov, Jure Kukovec, and Thanh-Hai Tran. 2019. TLA+ model checking made symbolic. Proceedings of the ACM on Programming Languages

3, OOPSLA (2019), 123:1â€“123:30.

[34] Igor Konnov, Marijana Lazic, Ilina Stoilkovska, and Josef Widder. 2020. Tutorial: Parameterized Veriï¬cation with Byzantine Model Checker. In

International Conference on Formal Techniques for (Networked and) Distributed Systems (FORTEâ€™20). 189â€“207.

[35] Igor Konnov, Marijana Lazic, Helmut Veith, and Josef Widder. 2017. Para2: parameterized path reduction, acceleration, and SMT for reachability

in threshold-guarded distributed algorithms. Formal Methods in System Design 51, 2 (2017), 270â€“307.

[36] Igor Konnov, Marijana Lazic, Helmut Veith, and Josef Widder. 2017. A short counterexample property for safety and liveness veriï¬cation of

fault-tolerant distributed algorithms. In Symposium on Principles of Programming Languages (POPLâ€™17). ACM, 719â€“734.

[37] Igor Konnov, Helmut Veith, and Josef Widder. 2017. On the completeness of bounded model checking for threshold-based distributed algorithms:

Reachability. Information and Computation 252 (2017), 95â€“109.

[38] Igor Konnov and Josef Widder. 2018. ByMC: Byzantine Model Checker. In ISoLA. 327â€“342.
[39] Bernhard Kragl, Constantin Enea, Thomas A. Henzinger, Suha Orhun Mutluergil, and Shaz Qadeer. 2020. Inductive sequentialization of asynchro-

nous programs. In ACM-SIGPLAN Symposium on Programming Language Design and Implementation (PLDIâ€™20). 227â€“242.

[40] Leslie Lamport. 2011. Byzantizing Paxos by Reï¬nement. In International Symposium on Distributed Computing (DISCâ€™11). 211â€“224.
[41] Marijana Lazic, Igor Konnov, Josef Widder, and Roderick Bloem. 2017. Synthesis of Distributed Algorithms with Parameterized Threshold Guards.

In International Conference on Principles of Distributed Systems (OPODISâ€™17). 32:1â€“32:20.

[42] Richard J. Lipton. 1975. Reduction: A Method of Proving Properties of Parallel Programs. Commun. ACM 18, 12 (1975), 717â€“721.
[43] Marta Lokhava, Giuliano Losa, David MaziÃ¨res, Graydon Hoare, Nicolas Barry, Eli Gafni, Jonathan Jove, RafaÅ‚ Malinowsky, and Jed McCaleb. 2019.
Fast and Secure Global Payments with Stellar. In Proceedings of the 27th ACM Symposium on Operating Systems Principles (SOSP â€™19). 80â€“96.
[44] Giuliano Losa and Mike Dodds. 2020. On the Formal Veriï¬cation of the Stellar Consensus Protocol. In Workshop on Formal Methods for Blockchains

(FMBC@CAVâ€™20). 9:1â€“9:9.

[45] Giuliano Losa, Eli Gafni, and David MaziÃ¨res. 2019. Stellar Consensus by Instantiation. In 33rd International Symposium on Distributed Computing,

DISC 2019 (LIPIcs), Jukka Suomela (Ed.), Vol. 146. 27:1â€“27:15.

[46] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. 2016. The Honey Badger of BFT Protocols. In Conference on Computer and

Communications Security (CCSâ€™16).

17

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

[47] Achour MostÃ©faoui, Hamouna Moumen, and Michel Raynal. 2014. Signature-free Asynchronous Byzantine Consensus with ğ‘‡ < ğ‘ /3 and ğ‘‚ (ğ‘ 2)

Messages. In Symposium on Principles of Distributed Computing (PODCâ€™14). 2â€“9.

[48] Achour MostÃ©faoui, Hamouna Moumen, and Michel Raynal. 2015. Signature-free asynchronous binary Byzantine consensus with ğ‘¡ < ğ‘›/3, ğ‘‚ (ğ‘›2)

messages and ğ‘‚ (1) expected time. Journal of the ACM (2015).

[49] Achour MostÃ©faoui, Eric Mourgaya, Philippe Raipin ParvÃ©dy, and Michel Raynal. 2003. Evaluating the Condition-Based Approach to Solve Con-

sensus. In Dependable Systems and Networks (DSNâ€™03). 541â€“550.

[50] Achour MostÃ©faoui, Sergio Rajsbaum, and Michel Raynal. 2003. Conditions on Input Vectors for Consensus Solvability in Asynchronous Distributed

Systems. Journal of the ACM 50, 6 (Nov. 2003), 922â€“954.

[51] Moni Naor and Udi Wieder. 2003. Scalable and Dynamic Quorum Systems. In Proceedings of the Twenty-Second Annual Symposium on Principles of

Distributed Computing. 114â€“122.

[52] Tobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. 2002. Isabelle/HOL - A Proof Assistant for Higher-Order Logic. Lecture Notes in Computer

Science, Vol. 2283. Springer.

[53] Tatsuya Noguchi, Tatsuhiro Tsuchiya, and Tohru Kikuno. 2012. Safety Veriï¬cation of Asynchronous Consensus Algorithms with Model Checking.

In International Symposium on Dependable Computing (PRDCâ€™12). 80â€“88.

[54] Marshall C. Pease, Robert E. Shostak, and Leslie Lamport. 1980. Reaching Agreement in the Presence of Faults. Journal of the ACM 27, 2 (1980),

228â€“234.

[55] Amir Pnueli. 1977. The Temporal Logic of Programs. In IEEE Annual Symposium on Foundations of Computer Science (FOCSâ€™77). 46â€“57.
[56] MojÅ¼esz Presburger. 1929. Ãœber die VollstÃ¤ndigkeit eines gewissen Systems der Arithmetik ganzer Zahlen, in welchem die Addition als einzige

Operation hervortritt. In Comptes Rendus du congrÃ¨s de MathÃ©maticiens des Pays Slaves. 92â€“101.

[57] Vincent Rahli, David Guaspari, Mark Bickford, and Robert L. Constable. 2015. Formal Speciï¬cation, Veriï¬cation, and Implementation of Fault-

Tolerant Systems using EventML. Electronic Communication of the European Association of Software Science and Technology 72 (2015).

[58] Arnaud Sangnier, Nathalie Sznajder, Maria Potop-Butucaru, and SÃ©bastien Tixeuil. 2020. Parameterized veriï¬cation of algorithms for oblivious

robots on a ring. Formal Methods in System Design 56, 1 (2020), 55â€“89.

[59] Ilya Sergey, James R. Wilcox, and Zachary Tatlock. 2018. Programming and proving with distributed protocols. Proceedings of the ACM on

Programming Languages 2, POPL (2018), 28:1â€“28:30.

[60] Yee Jiun Song and Robbert van Renesse. 2008. Bosco: One-Step Byzantine Asynchronous Consensus. In International Symposium on Distributed

Computing (DISCâ€™08). 438â€“450.

[61] Ilina Stoilkovska, Igor Konnov, Josef Widder, and Florian Zuleger. 2020. Eliminating Message Counters in Threshold Automata. In International

Symposium on Automated Technology for Veriï¬cation and Analysis (ATVAâ€™20). 196â€“212.

[62] Pierre Sutra. 2020. On the correctness of Egalitarian Paxos. Inform. Process. Lett. 156 (2020), 105901. https://doi.org/10.1016/j.ipl.2019.105901
[63] Pierre Tholoniat and Vincent Gramoli. 2022. Formal Veriï¬cation of Blockchain Byzantine Fault Tolerance. In Handbook on Blockchain, Duc A. Tran,

My T. Thai, and Bhaskar Krishnamachari (Eds.). Springer Nature.

[64] Tatsuhiro Tsuchiya and AndrÃ© Schiper. 2008. Using Bounded Model Checking to Verify Consensus Algorithms. In Distributed Computing, Gadi

Taubenfeld (Ed.). 466â€“480.

[65] Tatsuhiro Tsuchiya and AndrÃ© Schiper. 2011. Veriï¬cation of consensus algorithms using satisï¬ability solving. Distributed Computing 23, 5-6 (2011),

341â€“358.

[66] Klaus von Gleissenthall, Rami GÃ¶khan Kici, Alexander Bakst, Deian Stefan, and Ranjit Jhala. 2019. Pretend synchrony: synchronous veriï¬cation

of asynchronous distributed programs. Proceedings of the ACM on Programming Languages 3, POPL (2019), 59:1â€“59:30.

[67] James R. Wilcox, Doug Woos, Pavel Panchekha, Zachary Tatlock, Xi Wang, Michael D. Ernst, and Thomas E. Anderson. 2015. Verdi: a framework
for implementing and formally verifying distributed systems. In ACM-SIGPLAN Symposium on Programming Language Design and Implementation
(PLDIâ€™15). 357â€“368.

[68] Yuan Yu, Panagiotis Manolios, and Leslie Lamport. 1999. Model Checking TLA+ Speciï¬cations. In CHARME. 54â€“66.

A REDUCING MULTI-ROUND TA TO ONE-ROUND TA

Let us ï¬rst formally deï¬ne a (ï¬nite or inï¬nite) run in a (one-round or multi-round) counter system Sys(TA). It is an
alternating sequence of conï¬gurations and transitions ğœ0, ğ‘¡1, ğœ1, ğ‘¡2, . . . such that ğœ0 âˆˆ ğ¼ is an initial conï¬guration and
for every ğ‘– â‰¥ 1 we have that ğ‘¡ğ‘– is unlocked in ğœğ‘–âˆ’1, and executing it leads to ğœğ‘– , denoted ğ‘¡ğ‘– (ğœğ‘–âˆ’1) = ğœğ‘– .

Here we brieï¬‚y describe the reasoning behind the reduction of multi-round TAs to one-round TAs [10, Theorem 6].

Note that the behavior of a process in one round only depends on the variables (the number of messages) of that

round. Namely, we check if a transition is unlocked in a round by evaluating a guard and a location counter in that

round. This allows us to modify a run by swapping two transitions from diï¬€erent rounds, as they do not aï¬€ect each
other, and preserve LTL-X properties, which are properties expressed in LTL without the next operator X . The type
18

Holistic Verification of Blockchain Consensus

of swapping we are interested in is the one where a transition of round ğ‘… is followed by a transition of round ğ‘…â€² < ğ‘….
Starting from any (fully asynchronous) run, if we keep swapping all such pairs of transitions, we will obtain a run
in which processes synchronize at the end of each round and which has the same LTL-X properties as the initial one.
This, so-called round-rigid structure, allows us to isolate a single round and analyze it. Still, diï¬€erent rounds might
behave diï¬€erently as they have diï¬€erent initial conï¬gurations. If we have a formula âˆ€ğ‘… âˆˆ N. ğœ‘ [ğ‘…], where ğœ‘ [ğ‘…] is
in the above mentioned fragment of (multi-round) LTL, then Theorem 6 of [10] shows exactly that it is equivalent to
check that (i) this formula holds (or ğœ‘ [ğ‘…] holds on all rounds ğ‘…) on a multi-round TA, and (ii) formula ğœ‘ [1] (or just ğœ‘)
holds on the one-round TAâ€² (naturally obtained from the TA by removing dotted round-switch rules) with respect to all
possible initial conï¬gurations of all rounds. Thus, we can verify properties of the form âˆ€ğ‘… âˆˆ N. ğœ‘ [ğ‘…] on multi-round
threshold automata, by using ByMC to check ğœ‘ on a one-round threshold automaton with an enlarged set of initial

conï¬gurations.

B EXAMPLES OF FAIRNESS AND OF NON-TERMINATION WITHOUT FAIRNESS

First, we explain that the fairness is satisï¬ed as soon as one execution of bv-broadcast has correct processes deliver-

ing all values broadcast by correct processes ï¬rst. Then, we explain that the Byzantine consensus algorithm cannot

terminate without an additional assumption, like fairness.

Relevance of the fairness assumption. It is interesting to note that our fairness assumption is satisï¬ed by the existence

of an execution with a particular reception order of some messages of the two broadcasts within the bv-broadcast.
Consider that ğ‘¡ = âŒˆğ‘›/3âŒ‰ âˆ’ 1 and that at the beginning of a round ğ‘Ÿ , the two following properties hold: (i) estimate
ğ‘Ÿ mod 2 is more represented than estimate (1 âˆ’ ğ‘Ÿ ) mod 2 among correct processes and (ii) all correct processes deliver

the values broadcast by correct processes before any value broadcast during the bv-broadcast by Byzantine processes

are delivered. Indeed, the existence of such a round ğ‘Ÿ in any inï¬nite sequence of executions of bv-broadcast implies
that this sequence is fair (Def. 3.2): as ğ‘Ÿ mod 2 is the only value that can be broadcast by ğ‘¡+1 correct processes, this is
the ï¬rst value that is received from ğ‘¡+1 distinct processes and rebroadcast by the rest of the correct processes. This is

thus also the ï¬rst value that is bv-delivered by all correct processes.

Non-termination without fairness. It is interesting to note why Algorithm 1 does not solve consensus when ğ‘¡ < ğ‘›/3
and without our fairness assumption. We exhibit an example of execution of the algorithm with ğ‘› = 4 and ğ‘“ = 1, starting
at round ğ‘Ÿ and for which the estimates of the correct processes are kept as (1âˆ’ğ‘Ÿ ) mod 2, (1âˆ’ğ‘Ÿ ) mod 2, ğ‘Ÿ mod 2 in rounds
ğ‘Ÿ and ğ‘Ÿ +2. Repeating this while incrementing ğ‘Ÿ yields an inï¬nite execution, so that the algorithm never terminates.

Lemma B.1. Algorithm 1 does not terminate without fairness.

Proof. Consider, for example, processes ğ‘1, ğ‘2, ğ‘3 and ğ‘4 where ğ‘4 is Byzantine and where 0, 0, 1 are the input values
of the correct processes ğ‘1, ğ‘2, ğ‘3, respectively, at round 1. We show that at the beginning of round 2, ğ‘1, ğ‘2, ğ‘3 have
estimates 0, 1, 1. First, as a result of the broadcast (line 2), consider that ğ‘1 and ğ‘2 receive 0 from ğ‘1, ğ‘2 and ğ‘4 so that
ğ‘1, ğ‘2 bv-deliver 0. Second, ğ‘2 and ğ‘3 receive 1 from ğ‘3, ğ‘4 and ï¬nally ğ‘2 so that ğ‘2, ğ‘3 bv-deliver 1. Third, ğ‘3 receives
0 from ğ‘0, ğ‘2 and ï¬nally from ğ‘3 itself, hence ğ‘3 bv-delivers 0. Now we have: (a) ğ‘1, ğ‘2, ğ‘3 bv-deliver 0, 0, 1 and (b)
ğ‘2, ğ‘3 later bv-deliver 1 and 0, respectively. As a result of (a), we have ğ‘1, ğ‘2 broadcast, and say ğ‘4 sends, haux, 0, Â·i so
that ğ‘0 receives these three messages, ğ‘1, ğ‘2 broadcast haux, 0, Â·i, and say ğ‘4 sends, haux, 1, Â·i to ğ‘2 so that ğ‘2 receives
these messages, ğ‘1 broadcasts haux, 0, Â·i while ğ‘3 broadcasts, and say ğ‘4 sends, haux, 1, Â·i so that ğ‘3 receives these
messages. Finally, by (b) we have contestants2 = contestants3 = {0, 1}. This implies that the ğ‘› âˆ’ ğ‘¡ ï¬rst values inserted in
19

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

favorites1, favorites2 and favorites3 in round ğ‘Ÿ are values {0}, {0, 1}, {0, 1}, respectively. Finally, qualiï¬ers1, qualiï¬ers2
and qualiï¬ers3 are {0}, {0, 1} and {0, 1}, respectively. And ğ‘1, ğ‘2, ğ‘3 set their estimate to 0, 1, 1.

It is easy to see that a symmetric execution in round ğ‘Ÿ â€² = ğ‘Ÿ + 1 leads processes to change their estimate from 0, 1, 1
(cid:3)

to 0, 0, 1 looping back to the state where ğ‘Ÿ mod 2 = 1 and estimate are (1 âˆ’ ğ‘Ÿ ) mod 2, (1 âˆ’ ğ‘Ÿ ) mod 2, ğ‘Ÿ mod 2.

C STARTING A ROUND WITH IDENTICAL ESTIMATE

Lemma C.1 (Lemma 4.1). If the inï¬nite sequence of bv-broadcast invocations of Algorithm 1 is fair, with the ğ‘Ÿ th invo-
cation (in round ğ‘Ÿ ) being (ğ‘Ÿ mod 2)-good, then all correct processes start round ğ‘Ÿ +1 of Algorithm 1 with estimate ğ‘Ÿ mod 2.

Proof. The argument is that all correct processes wait until a growing preï¬x of the bv-delivered values that are re-
broadcast implies that there is a subset of favorites, called qualiï¬ers, containing messages from ğ‘› âˆ’ ğ‘¡ distinct processes
such that âˆ€ğ‘£ âˆˆ qualiï¬ers. ğ‘£ âˆˆ contestants. As we assume that the inï¬nite sequence of bv-broadcast invocations of
Algorithm 1 is fair, with the ğ‘Ÿ th invocation being (ğ‘Ÿ mod 2)-good, then we know that in round ğ‘Ÿ for every pair of correct
processes ğ‘ğ‘– and ğ‘ ğ‘— we have pi.qualiï¬ers âŠ† pj.qualiï¬ers or pj.qualiï¬ers âŠ† pi.qualiï¬ers. If pi.qualiï¬ers = pj.qualiï¬ers for
all pairs, then by examination of the code, we know that they will set their estimate est to the same value depending

on the parity of the current round.

Consider instead, with no loss of generality, that pi.qualiï¬ers is a strict subset of pj.qualiï¬ers in round ğ‘Ÿ . As their
values can only be binaries, in {0, 1}, this means that pi.qualiï¬ers is a singleton, say {ğ‘¤ }. As all correct processes bv-
deliver ğ‘Ÿ mod 2 ï¬rst, which is then broadcast into pi.favorites, we have ğ‘¤ = ğ‘Ÿ mod 2 and ğ‘ğ‘–â€™s estimate becomes ğ‘Ÿ mod 2
(cid:3)
at line 11. As pj.qualiï¬ers is {0, 1}, the estimate of ğ‘ ğ‘— is also set to ğ‘Ÿ mod 2 but at line 13.

D LARGE TA

Table 3 details the rules for the ï¬rst half of the threshold automaton from Fig. 3.

Rules
ğ‘Ÿ1
ğ‘Ÿ2
ğ‘Ÿ3
ğ‘Ÿ4
ğ‘Ÿ5
ğ‘Ÿ6
ğ‘Ÿ14, ğ‘Ÿ15, ğ‘Ÿ16
ğ‘Ÿ8
ğ‘Ÿ9
ğ‘Ÿ10
ğ‘Ÿ11
ğ‘Ÿ12
ğ‘Ÿ13
ğ‘Ÿ7, ğ‘Ÿ18, ğ‘Ÿ19
ğ‘Ÿ16
ğ‘Ÿ17
ğ‘Ÿ20, ğ‘Ÿ21, ğ‘Ÿ22

Guard
Update
true
ğ‘0 ++
true
ğ‘1 ++
ğ‘0 â‰¥ 2ğ‘¡+1âˆ’ğ‘“
ğ‘0++
ğ‘1 â‰¥ ğ‘¡+1âˆ’ğ‘“
ğ‘1 ++
ğ‘0 â‰¥ ğ‘¡+1âˆ’ğ‘“
ğ‘0 ++
ğ‘1 â‰¥ 2ğ‘¡+1âˆ’ğ‘“
ğ‘1++
ğ‘0 â‰¥ ğ‘›âˆ’ğ‘¡âˆ’ğ‘“
â€”
ğ‘1 â‰¥ ğ‘¡+1âˆ’ğ‘“
ğ‘1 ++
ğ‘1 â‰¥ 2ğ‘¡+1âˆ’ğ‘“
ğ‘1++
ğ‘0 â‰¥ 2ğ‘¡+1âˆ’ğ‘“
ğ‘0++
ğ‘0 â‰¥ ğ‘¡+1âˆ’ğ‘“
ğ‘0 ++
ğ‘1 â‰¥ 2ğ‘¡+1âˆ’ğ‘“
â€”
ğ‘0 â‰¥ 2ğ‘¡+1âˆ’ğ‘“
â€”
ğ‘1 â‰¥ ğ‘›âˆ’ğ‘¡âˆ’ğ‘“
â€”
ğ‘0 â‰¥ ğ‘›âˆ’ğ‘¡âˆ’ğ‘“
â€”
ğ‘0+ğ‘1 â‰¥ ğ‘›âˆ’ğ‘¡âˆ’ğ‘“ â€”
â€”
true

Table 3. The rules of the threshold automaton from Fig. 3. We omit self loops that have trivial guard true and no update.

20

Holistic Verification of Blockchain Consensus

E MISSING PROOF OF COROLLARY 4.2

We restate here Corollary 4.2 and give its proof.

Corollary E.1. Let ğ‘Ÿ âˆˆ N be such that the ğ‘Ÿ th execution of bv-broadcast in Algorithm 1 is (ğ‘Ÿ mod 2)-good. Then:

â€¢ If there exists ğ‘… âˆˆ N with ğ‘Ÿ = 2ğ‘…âˆ’1, then (cid:3)
â€¢ If there exists ğ‘… âˆˆ N with ğ‘Ÿ = 2ğ‘…, then (cid:3) (ğœ… [ğ‘€ â€²

ğœ… [ğ‘€0, ğ‘…] = 0) holds.
(cid:0)
1, ğ‘…] = 0

holds.

(cid:1)

Proof. By deï¬nition of an (ğ‘Ÿ mod 2)-good execution, we know that in this particular invocation of bv-broadcast,

all correct processes bv-deliver ğ‘Ÿ mod 2 ï¬rst. It follows from Lemma 4.1, that all correct processes start the next round
with estimate set to ğ‘Ÿ mod 2. There are two cases to consider depending on the parity of the round: If ğ‘Ÿ mod 2 = 1,
then this is the ï¬rst round of superround ğ‘…, i.e., ğ‘Ÿ = 2ğ‘… âˆ’ 1. As a result, (cid:3)
. If ğ‘Ÿ mod 2 = 0, then this is
the second round of superround ğ‘…, i.e., ğ‘Ÿ = 2ğ‘…. As a result, (cid:3)
(cid:3)
1, ğ‘…] = 0

ğœ… [ğ‘€0, ğ‘…] = 0
(cid:0)
.

(cid:1)

ğœ… [ğ‘€ â€²
(cid:0)

(cid:1)

F SPECIFICATION OF THE TERMINATION PROPERTY IN THE SIMPLIFIED THRESHOLD

AUTOMATON FOR CONSENSUS ALGORITHM

The reliable communication assumption and the properties guaranteed by the bv-broadcast are expressed as precon-

ditions for s_round_termination. The progress conditions work exactly the same as in [10]. However, since the shared

counters representing the bv-broadcast execution do not represent regular messages, we cannot directly use the re-

liable communication assumption. Instead, we use the properties of the bv-broadcast that we proved in a separate

automaton.

In practice, instead of using progress preconditions on the bv-broadcast counters in s_round_termination, such as:

(locM

== 0 || bvb1 < 1) && (locM == 0 || bvb0 < 1) &&

(locM1 == 0 || bvb0 < 1) && (locM0 == 0 || bvb1 < 1)

we use the following:

/* BV-Termination */
(locM

== 0) &&

/* BV-Obligation */
(locM1 == 0 || bvb0 < T + 1) && (locM0 == 0 || bvb1 < T + 1) &&

/* BV-Uniformity */
(locM1 == 0 || aux0 == 0) && (locM0 == 0 || aux1 == 0) &&

One can note that we do not use BV-Justiï¬cation as a precondition in this speciï¬cation. Instead, the BV-Justiï¬cation
property is baked in the structure of the simpliï¬ed threshold automaton (in the guard of the transition ğ‘€ â†’ ğ‘€0, ğ‘€1).

The complete speciï¬cation of the termination property follows:

21

Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana LaziÄ‡, Pierre Tholoniat, and Josef Widder

s_round_termination:

<>[](

(locV0

== 0) &&

(locV1

== 0) &&

(locM01x

== 0 || aux0x + aux1x < N - T)

)

->

<>(

/* BV-Termination */
(locM

== 0) &&

/* BV-Obligation */
(locM1 == 0 || bvb0 < T + 1) &&

(locM0 == 0 || bvb1 < T + 1) &&

/* BV-Uniformity */
(locM1 == 0 || aux0 == 0) &&

(locM0 == 0 || aux1 == 0) &&

/* Business as usual */
(locM1

== 0 || aux1 < N - T) &&

(locM0

== 0 || aux0 < N - T) &&

(locM01

== 0 || aux0 + aux1 < N - T) &&

);

locV0

== 0 &&

locV1

== 0 &&

locM

== 0 &&

locM0

== 0 &&

locM1

== 0 &&

locM01

== 0 &&

locE0

== 0 &&

locE1

== 0 &&

locD1

== 0 &&

locMx

== 0 &&

locM0x

== 0 &&

locM1x

== 0 &&

locM01x == 0

(locD1

== 0) &&

(locE0

== 0) &&

(locE1

== 0) &&

/* BV-Termination */
(locMx

== 0 ) &&

/* BV-Obligation */
(locM1x

== 0 || bvb0x < T + 1) &&

inv1_0: <>(locD0 != 0) -> [](locD1 == 0 && locE1x == 0);

inv2_0: [](locV0 == 0) -> [](locD0 == 0 && locE0x == 0);

inv1_1: <>(locD1 != 0) -> [](locD0 == 0 && locE0x == 0);

inv2_1: [](locV1 == 0) -> [](locD1 == 0 && locE1x == 0);

(locM0x

== 0 || bvb1x < T + 1) &&

dec_0: [](locV0 == 0) -> [](locE0 == 0 && locE1 == 0);

/* BV-Uniformity */
(locM1x == 0 || aux0x == 0) &&

(locM0x == 0 || aux1x == 0) &&

dec_1: [](locV1 == 0) -> [](locE0x == 0 && locE1x == 0);

good_0: [](locM0 == 0) -> [](locD0 == 0 && locE0x == 0);

(locM1x

== 0 || aux1x < N - T) &&

(locM0x

== 0 || aux0x < N - T) &&

good_1: [](locM1x == 0) -> [](locE1x == 0);

(locM01x

== 0 || aux1x < N - T) &&

(locM01x

== 0 || aux0x < N - T) &&

22

