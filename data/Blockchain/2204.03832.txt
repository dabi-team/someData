Scaling Bockchain with Adaptivity

Yan Huang, Yu Zhou, Tao Zhu, Yuzhuang Xu, Hehe Wang,
Weihuai Liu, Jingxiu Hu, Pushan Xiao
China UnionPay

2
2
0
2

r
p
A
8

]

C
D
.
s
c
[

1
v
2
3
8
3
0
.
4
0
2
2
:
v
i
X
r
a

Abstract

This paper presents Balloon, a scalable blockchain consensus
protocol which could dynamically adapt its performance to
the overall computation power change. Balloon is based on
a parallel chain architecture combined with a greedy heavi-
est sub-chain selection strategy. It adopts an inovative block
sampling approach to assess the change of block generation
rate in the network. By introducing view change mechanism,
Balllon is able to dynamically adjust the number of parallel
sub-chains. Balloon redeﬁnes the concept of block subtree
weight with view change in consideration, so that a total order
of blocks could be obtained safely. To deal with rapidly in-
creasing block generation rate in the blockchain network, par-
ticipants of previous Nakamoto-style protocols are required
to continuously increase their mining difﬁculty so as to main-
tain an expected security gurantee. Balloon, however, could
accomadate a ﬁxed difﬁculty setup and assign superﬂuous
block processing capability to new sub-chains, which makes
it more open and also economical.

1 Introduction

Blockchain has attacted numerous attention since the incep-
tion of bitcoin in 2008 [19] and 2009 [20]. A major drive
behind this is the boom of cryptocurrency industry, though
it has the potential of optimizing the practice of other indus-
tries [22, 26, 30] for its efﬁciency in coordinating between
multiple stakeholders. Compared to traditional web service,
blockchain could be viewed as a new sercie model under
which stakeholders could equally and autonomously partic-
ipate in the network to achieve certain goals, e.g., bitcoin
token transfer or more complex type of transactions deﬁned
by smart contract [31]. At its core, peer-to-peer network and
consensus protocol form the backbone of most blockchain
systems.

Bitcoin is the ﬁrst blockchain system that has provided
cryptocurrency service to Internet-scale miners. Proof of
Work (i.e., PoW [8]) is used to reach agreemnt on a total

order of blocks. Despite its unsatisfying performance (about 7
transaction per second), it is still supported by miners around
the world for its stable scalability and security. However, the
safety gurantee is maintained by continuously increasing the
mining difﬁculty over the years (with more partipants join-
ing), which costs too much on the total computation power
invested per block. For example, bitcoin consumes approxi-
mately 2132.34 kWh per transaction [7], about the average
consumption of an U.S. household in 70.75 days [2]. More-
over, higher mining difﬁculty limits the access of nodes to
bitcoin network, making the blockchain more centralized and
actually less open. Later blockchains (e.g., ethereum [31],
conﬂux [16], prism [3], etc.) also suffer from that.

We present Balloon, a scalable blockchain consensus pro-
tocol which could dynamically adapt its block throughput to
the overall computation power change. Balloon is constructed
on a parallel chain achitecture combined with a variant of
GHOST [28] in order to obtain high performance. At its core,
Balloon uses an inovative block sampling approach to dynam-
ically evaluates the change of computation power in the net-
work and adjusts the number of its sub-chains (if necessary)
with what we call view change mechanism. We reconstruct
GHOST safely accross all views so as to achieve ﬁnal con-
sensus on blocks and transactions. Balloon makes it possible
to use a ﬁxed block mining difﬁculty without impairing the
chain security. Its accessibility to nodes with general hard-
ware is promising to create a more open and fair blockchain
network.

There are three main obstacles to the design of Balloon.
First, it needs an efﬁcient way to assess the overall block
generation rate before adjusting its parallel chain. Second,
Balloon should not sacraﬁce its safety during the adjustment
to balance superﬂuous power in the network. Finally, a total
order of blocks across all views should be ﬁnally obtained
safely. Balloon tackles these obstacles with several new tech-
niques which is described as follows.

Dynamic block sampling. Whenever mining a new block,
a miner would search for blocks with a speciﬁc clock and
time distance from the current one. These sampling blocks

1

 
 
 
 
 
 
would then be added to corresponding block ﬁeld. Clock is an
inner property of block to identify the logical order between
different block events. The ﬁrst sampling block is found along
its guider chain (i.e., largest clock direction). After that, other
sampling blocks are collected based on its clock and view.
Balloon utilizes sampling blocks to estimate block generate
concurrency during a speciﬁc period (i.e., epoch).

View change mechanism. Balloon periodically detects
if there is a potential chain adjustment and responds to sig-
niﬁcant change of computation power by view change. The
process moves Balloon into a new view with different number
of sub-chains so as to balance superﬂuous network power or
just enter into a more silent mode with low block throughput.
To ensure its safety, Baloon adapts to apparent increasing
of computation power in a responsive way and decreasing
of it in a conservative way, which could efﬁciently counter
an attacker’s manipulation of computation power invested.
Moreover, blocks in a new view will have larger clocks than
that of its previous views (excluding blocks after anchors) to
further strengthen Balloon’s safety.

Reconstructing GHOST across views. View change com-
plexifes the total ordering of Balloon since GHOST could
not be applied directly and safely. To solve this, Balloon ﬁrst
deserts main sub-chain blocks after anchors (from which view
change started) to ensure global consistency acrross views.
On the other hand, deserted blocks would still contribute to
corresponding block sub-tree weight. Moreover, for those in
subsequent views (including both main view and split one),
the weight of them would also count for corresponding blocks
in a speciﬁc view. Based on these observations, we redeﬁne
block sub-stree and its weight for Balloon and eventually
reach agreement on a total order of blocks.

The remaining of this paper is organized as follows. Section
2 gives an introduction on related work. Section 3 describes
some of the key assumptions and goals. Section 4 provides an
overview of Balloon and its details are presented in Section 5.
Finally, we conclude our work in Section 6.

2 Related Work

Nakamoto and GHOST. Nakamoto consensus protocol is
used in Bitcoin [19] and many other cryptocurrencies for
its scalability in dynamic peer-to-peer (i.e., P2P) networks.
It could maintain a steady block processing capability with
nodes joining and leaving dynamically. Its agreement is
reached on the longest chain of blocks. GHOST [28] is an
improvement on the security of Bitcoin, which is partly used
in Ethereum. It selects main chain blocks along the direction
of heaviest block subtree. Both protocols have probalistic
safety gurantee under which honest nodes must occupy more
than half of the overall computational power. To keep a stable
safety guarantee and performance, block mining difﬁculty is
continuously increased with more nodes joining in the net-
work. Therefore, the cost of computation power on a block

will be rapidly increasing, which limits the access of ordinary
nodes to the network . It is neither sustainable nor econom-
ical in the long run. Despite their unsatisfying performance
and sustainbility, they inspired many later works on desiging
large-scale consensus protocol in a dynamic P2P network.
Balloon is one of them.

BFT protocols. PBFT [5] is a typical consensensus proto-
col that could tolerate byzantine faults [14, 23]. It is designed
as a service-oriented replicated state machine [25], which
could achieve a deterministic agreement among a known
ﬁxed set of participants. For PBFT and its earlier followers
like Zyzzyva [12], Q/U protocol [1] and also its recent vari-
ants (e.g., Tendermint [4], HotStuff [32]), they scale poorly
to large groups (normally with a size of several or dozens
of nodes), not to mention open networks. Moreover, they re-
quire a deterministic membership known beforehand which
is not practical in a dynamical P2P network. Algorand [6, 9]
combines a stateless agreement protocol BA* with veriﬁable
random function (i.e., VRF [18]) to improve its scalability in
a open dynamic network. Like traditional BFT protocols, BA*
runs by round and waits to collect expected number of votes
in every round to achieve a ﬁnal or tentative goal. Therefore,
the scalability of Algorand is still heavily effected by the size
of its committe.

Structuring block/transaction tree. For GHOST and
Nakamoto consensus, side chain blocks are deprecated though
they occupy a large portion of the network’s bandwidth. To
better utilize the resource and thus improve the block through-
put, protocols of structuring concurrent blocks in the tradi-
tional chain were proposed. Inclusive protocol [15] proposes a
general methodology of reconstructing GHOST or Nakamoto
chain into a directed acyclic structure (called block DAG) and
then generateing a total order of it. Phantom [27] takes a new
ordering approach to Inclusive’s block DAG based on the ob-
servation that honest nodes in block DAG are well-connected.
Conﬂux [16] is an improvement on Inclusive protocol. It
adopts an adaptive weight mechanism to counter liveness
attacks on GHOST. Prism [3] structures blocks into three
types (i.e., vote block, proposer block and transaction block)
and mines randomly on corresponding types of Nakamoto
chains. Voter chains collectively vote for a total order of leader
proposer blocks which is then used to order concurrent trans-
action block events, achieving a high block throughput. Like
bitcoin or ethereum, these protocols would gradually increase
its mining difﬁculty and thus cost per block in the computa-
tion power with more nodes joining in order to keep a desired
safety gurantee. Avalanche [24] structures the chain into a
block-less DAG. It has good scalability for the use of a ran-
dom sampling approach to reach probalistic agreement on
transactions. DAG in Avalanche is used for query batching
purpose.

Parallel chain architecture. OHIE [33] is a Nakamoto-
style parallel chain protocol with high transaction throughput.
Blocks are mined randomly on its symmetric sub-chains. It

2

deﬁnes two additional ﬁelds (not part of a block), rank and
next_rank, to help blocks grow so it could be totally ordered.
Since block rank is determined by its parent block instead of
its latest trailing block, the process could not reﬂect the actual
order of block events and its observation of an unbounded
trend between sub-chain growth rates makes the case worse.
Eunomia [21] improves OHIE by introducing virtual logical
clock to order concurrent blocks. Balloon also utilizes the
concept of logical clock except that it includes it within cor-
responding block ﬁeld as its inner property. It makes logical
clock not "virtual" anymore and simpler to calculate. More-
over, by introducing the concept of guider and guider chain,
block clock in Balloon has more natural semantics and usage.
Different from OHIE and Eunomia, a variant of GHOST is
used in Balloon as a sub-chain building block to further im-
prove its performance and security instead of using Nakamoto
consensus. In practice, both OHIE and Eunomia are not com-
plete because they have not take into account the change of
computation power in blockchain. Actually, the security gu-
rantee could not be maintained with continuously increasing
nodes participating in the network. A recent work [29] on
parallel chain mining difﬁculty adjustment maybe useful for
applying OHIE to practical blockchain systems. Besides, they
also could not adapt its performance to computation power
change like Balloon.

3 System Model

Balloon aims to acheive two main goals 1) Safety. With
overwhelming probability, honest nodes of Balloon would
eventually reach agreement on a total order of blocks and
thus their transactions. 2) Liveness. Balloon could continue
to make progress by mining and processing new blocks with
transactions.

Assumptions. The safety of Balloon does not rely on net-
work synchrony. To ensure a satisfying adaptivity property,
however, a weak d-synchrony assumption is used. For ex-
ample, during a enough long period, the network is allowed
to be asynchronous for some time discretely, but the total
time of it should be signifcantly smaller compared to that of
d-synchrony duration. Moreover, during other times, blocks
should be received within a known block propagation delay
bound d after they were sent through gossip protocol. Like
many consensus protocols, strong network synchrony is essen-
tial for Balloon to gurantee its liveness (i.e., to make progress).
Since Balloon is a GHOST-style protocol, we make the same
computation power assumption, i.e., adversaries’ total block
generation rate qλ should be less than that of honest nodes
λ, i.e., q < 1. Furthermore, Balloon makes an ideal GHOST
assumption to increases its adaptivity. That is, there exists an
ideal r0 = λ0d with a ﬁxed difﬁculty setup, which could ensure
GHOST has a satisfying performance and security gurantee.
This assumption is practical and r0 could also be obtained
by experiment on single GHOST chain as well. Actually,

adaptivity is aimed to make sure that sub-chains in Balloon
could work efﬁciently and safely like single GHOST, which
has been inspected thoroughly and comprehensively over the
years. Other assumptions on cryptographic hash functions and
sigatures follow common standard, e.g., cryptographic hash
functions used in blockchain should be collision-resistant.

4 Overview

Balloon inherits the idea of consensus through competition
from Nakamoto consensus so as to scale blockchain to as
many nodes as possible. Every node in Balloon will compete
with their computation power to ﬁnd a valid block (e.g. whose
hash has required number of leading zeros). A parallel con-
sensus architecture combined with GHOST is introduced to
increase the blockchain throughput. During any stable period
(i.e. no chain adjustment happens), all nodes mine blocks
randomly and these (if valid) will be assigned to random
sub-chains. With more nodes partipating in the blockchain
network (or more computation power invested), Balloon will
periodically initiate a view change to dynamically increase
the number of running sub-chains, or vice versa. Balloon
reconstructs GHOST to all blockchain views so as to guaran-
tee overall system safety. We now describe some of the key
insights of Balloon.

Expanding GHOST to Parallel. Miners in Balloon gen-
erate valid blocks by ﬁnding valid PoW puzzles. They start
from a single GHOST chain or a multiple of it. We ﬁrst mod-
ify GHOST by calculating the total weights of a block tree
instead of the total number of blocks within. The weight of
block is deﬁned as its mining difﬁculty (like in Ethereum).
As other parallel blockchains [3, 33], we add merkle tree root
of all latest main sub-chain blocks to the raw block to avoid
potential attacks. Later after it is successfully mined, the par-
ent hash and corresponding proof are added accordingly. A
common genesis block which records protocol-speciﬁc pa-
rameters is created before that.

When mining blocks, a miner will select one block from
the current blockchain (only including main chain blocks
of those parallel sub-chains) and add its block hash as an
inner part of the block. We deﬁne this block as the guider
block. It is an inborn property of any valid Balloon block. It
reﬂects the happen-before relation of blocks [13]. Any guider
path of a block dates back to the common blockchain genesis
and we call these ordered blocks along the path guider chain.
Naturally, we use it to reconstruct Balloon’s inner logical
clock [13]. We thus deﬁne block clock as the total number of
blocks along the corresponding guider chain (not including
the block itself) and add it to corresponding block ﬁeld as
another inner property.

Before the ﬁrst view change starts, Balloon orders blocks
of multiple sub-chains (corresponding main chain) based on
their block clocks. It is simple and natural, since block clock
reﬂects the relative chronological order of block generation

3

Figure 1: Example of Balloon Chain Structure. It started with a single chain and check if there is a view change every 2 clocks
(Note: ﬁrst epoch is special, see §5.3). V∗ is the main view number. epoch is deﬁned within view and would be reset along with
view change. Grey blocks would be deserted in the ﬁnal total ordering though their weights contribute to Balloon’s safety.

just like what block number does in a single chain. For blocks
with the same clock, which signiﬁes concurrency of block
generation, we could break ties by their hashes or sub-chain
ids. When there is a chain adjustment, however, things become
complicated and Balloon uses a parallel variant of GHOST to
guarantee protocol safety.

Sampling Blocks When Mining. We propose the idea
of block sampling to assess overall block generation rate
and dynamically adjust the number of parallel sub-chains ac-
cordingly. Block Sampling happens during block generation.
Whenever mining a new block, a miner would ﬁrst locate a
reference sampling block along its guider chain. In Balloon,
we assume there is a known upper bound on block propaga-
tion delay most of the time to ensure accuracy of dynamic
chain adjustment, though protocol safety doest not rely on
it. Obviously, the time difference between the reference sam-
pling block and current one to mine should be larger than the
known bound. Practically, we make the difference slightly
larger so as to sample blocks more accurately. The miner will
then search for all blocks with the same clock as the reference
on its sub-chain. Other blocks not in the same view will also
be considered (not all of them) if they share the same block
clock. They are called sampling blocks of the current block
to mine and hashes of them are included into corresponding

block ﬁeld as another inner property.

We observe that guider chains are symmetric and make
progress synchronously with Balloon. Therefore, the guider
chain could serve as the timeline for chain adjustment and
block clock is the logical time. Balloon could thus be divided
into different clock periods in a view along the guider chain
and we use epoch to identify them. For any sub-chain in an
epoch, we would calculate the average number of sampling
blocks per block as an approximation of λd. The accuracy of
this generation rate depends largely on our knowledge of the
propagation delay bound and the epoch length we actually
use.

Adjusting Chain Democratically. For PoW-based con-
sensus protocols like Nakamoto or GHOST, they try to avoid
double-spend or liveness attack by maintaining a relatively
low block generation rate. Most of the time, this is done by
continuously increasing the mining difﬁculty. In Balloon,
however, we try to detect the "superﬂuous" computation
power and periodically distribute it onto newly generated
sub-chains, or vice versa with the power decreasing.

Balloon triggers chain adjustment based on the number of
current sub-chain votes available. A vote is casted if the aver-
age number of sampling blocks in an epoch is signiﬁcantly
larger or smaller than the expected one (i.e., λ0d in section

4

#0#1#2#3#4#0#1#2#3#0#1#2#2#3#3#0#0#1#2#1#2#0#1genesis blockanchor blocknew genesisanchor blockVprev = 1, Vnext = 2Vprev = 2, Vnext = 3ordinary block epoch = 1epoch = 1#2epoch = 1#3epoch = 2Vprev = 3, Vnext = 3 (no view change)Referencing anchor blockReferencing guider blockReferencing parent blocknew genesis3). The signiﬁcance level is set with a tradeoff between safety
and performance. When miners collect more than half of the
same sub-chain votes in an epoch, they would prepare a view
change. Otherwise, they do nothing and continue to the next
epoch. For adversaries, they should occupy more than half of
the network computation power to force a view change.

Determining Chain Structure of New View. Before mak-
ing the adjustment, miners ﬁrst determines the number of sub-
chains in the new view. Two dynamic strategies are available,
namely, consertive strategy and responsive one. In the ﬁrst
one, miners always add or delete ﬁxed number of sub-chains
after the switch. It is conservative because adversaries could
not apparently impair system security by ﬁrst sharply reduc-
ing its overall computation power during one epoch (which
forces a chain adjustment) and then restoring it in the next
view. On the other hand, the responsive strategy requires the
number of sub-chains in the next epoch be totally determined
by the signiﬁcance level of the average numnber of sampling
blocks. It could adapt the chain more quickly to sharp change
of computation power and allow better performance capacity
after an signiﬁcant increase. Balloon combines two of them
by adopting conservative strategy when the number of sub-
chains are decreasing and responsive one when there will be
an increase.

Binding New Genesis to Anchors. For convenience, we
use the concept of view to distinguish between different par-
allel chain structures, i.e., before and after chain adjustment.
We deﬁne anchor block as the last main sub-chain block in
a epoch after which a view change is prepared. The result of
chain adjustment is a complete list of new genesis blocks for
the new view. Different from normal block mining, a newly
mined genesis block references all anchor blocks in the pre-
vious view explicitly or implicitly. It could either include
corresponding block hashes to its ﬁeld directly or references
some valid new genesis block indirectly. This way, blockchain
of different views are thus connected as a whole.

After that, Balloon enters into a new view and miners will
mine from new genesis blocks just as they did in previous
one. The guider of a new genesis is the anchor block with the
largest clock. New mining blocks afterwards will only refer-
ence those of the same view as their corresponding guiders.
Total Order of Blocks and Transactions. The view
change process moves Balloon into a new view. Block clocks
are higher than that of corresponding prevous view, which
makes it still safer to order blocks based on clocks. To guaran-
tee protocol safety, we reconstruct GHOST with observation
that the weight of any block in subsequent views should con-
tribute to the total weight of corresponding anchor block tree.
One view after another, we search for main sub-chain blocks
using the reconstructed GHOST and thus generate an ordered
list of them based on clocks. Finally, a total order of blocks
across all Balloon views is obtained. For transactions within,
we handle them by corresponding block order and just skip
conﬂict transactions, e.g., repeated ones.

5 Balloon Consensus Design

In normal cases, the structure of Balloon is stable and newly
mined blocks will be assigned randomly onto sub-chains.
During this period, miners continuously sample certain past
blocks. They use the estimated sampling block generation rate
to decide whether to adjust the chain structure at the end of an
epoch. Besides, the new structure is determined based on it if
a chain adjustment bill is "passed". Valid new genesis blocks
should be ﬁrst generated before Balloon could ﬁnally mining
in the new view. For blocks in different views, Balloon further
expands the sub-chain GHOST rule to reach agreement on
the total order of them without imparing its safety.

5.1 Basic Parallel Chain Mining

A typical mining procedure for normal blocks within a view
is presented in Algorithm 1. It starts with the latest main sub-
chain blocks Bm of current view derived from Algorithm 6
(§5.4). Bm serves as snapshot for generating merkle proof
of this block later. Honest blocks always determine b.guider
based on their Bm (line 2, e.g. bx ∈ Gp is inappropriate) in case
of possible clock attack where an adversary may continuously
expanding its guider chain and send them to connected nodes
causing transaction delay or even rejection.

Algorithm 1: Basic Balloon mining process.
Input: Gp: block graph of current parallel chain,

Bm: list of latest main sub-chain blocks

Output: b: a newly mined block

1 b.root ← merkle_root(Bm)
bx.clock
2 b.guider ← arg max

bx∈Bm

update(nonce)

3 b.clock ← b.guider.clock + 1
4 b.samples ← Sample(Gp, b)
5 while difﬁculty(b) < Diffrequired do
6
7 end
8 b.nonce ← nonce
9 hc ← chain_hash(b)
10 nv ←|| Bm ||
11 sid ← hc % nv
12 (b.parent, b.proo f ) ← merkle_proo f (Bm, sid)
13 b.number ← b.parent.number + 1
14
15 return b

The introduction of block sampling (line 4, detailed in §5.2)
is what Balloon mining differentiates most from other consen-
sus protocols. Hashes of corresponding sampling blocks will
be included within. Di f frequired is the target difﬁculty a new
block should satisfy. Different from other protocols relying on
computation power, Balloon adopts a fairer strategy by using a
ﬁxed difﬁculty setup (Di f frequired of line 5) which is relevant

5

with expected hardware processing ability on participating
nodes. "Superﬂuous" computation power crowding in will be
periodically balanced by view change process which will be
discussed in §5.3. Chain hash hc is calculated by applying
hash function to an ordered ﬁelds of b except its parent and
proof ﬁeld (different from block hash). Sub-chain id sid of
our newly mined block is derived with a mod operation based
on chain hash hc and current number of sub-chain nv. Finally,
b’s parent and its corresponding merkle proof are retrieved to
assemble a complete block.

5.2 Dynamic Block Sampling

Most Nakamoto-style single chain protocols (e.g. bitcoin,
ethereum, etc.) adapt to the network’s increasing computation
power by adjusting only its main chain growth rate, which
could not work correctly in a globally high block generation
rate scenario. Balloon introduces block sampling to continu-
ously monitor the variance of overall block generation rate and
thus the computation power invested in the whole blockchain
network. Algorithm 2 details how sampling blocks are col-
lected.

Algorithm 2: Block sampling in Balloon.
Input: b: block to make sampling for,

Gp: block graph of current parallel chain

Output: S: sampling blocks found

1 bh ← b.guider
2 GC(b) = GC(bh) ◦ bh // Trace until initial genesis
3 Anchors(b) = Anchors(Genesis(b))
4 SameView(b1, b2) = SameAnchors(b1, b2)
5 SP(b) = {bs | Di f fclock(bh, bs) ≥ m &&
Di f ftime(bh, bs) ≥ n ∗ D, bs ∈ GC(b)}

6 bst ← arg max
bx∈SP(b)

bx.clock

7 Bc ← {bc | bc.clock = bst .clock &&

SameView(bc, bst ) && SameChain(bc, bst ), bc ∈ Gp}

8 Bp ← {bp | bp.clock = bst .clock &&

SameView(bp, bst ) → f alse}

9 Bps ← {bps | SameChain(bps, bst ), bps ∈ Bp)}
10 S ← Bc ∪ Bps
11
12 return S

As shown in Algorithm 2, GC(b), the guider chain of block
b, is an ordered list of blocks along its guider path dating back
to the globally conﬁgured genesis g0. Obviously, all GC(∗)
begin from g0. We deﬁne anchor blocks of any block b as
those of its corresponding genesis along the parent path. A
genesis’s anchors are blocks in the previous view from which
new genesis is mined (see Algorithm 4). We call blocks with
the completely identical set of anchors are in the same view
(line 4). Obviously, blocks having the same view number are
not necessarily in the same view.

The goal of block sampling is to capture the average level of
block concurrency in the Balloon network. For single chain
architecture, this is achieved by calculating the number of
blocks of the same block height. In Balloon, however, we
measure block concurrency by concurrent blocks per clock.
Actually, if we reduce Balloon to single chain mode, block
clock and height merge completely with each other. We now
start by determining the ﬁrst expected sampling block bst
along its guider chain (i.e. timeline). After that, we will then
ﬁnd its counterparts.

Under weak d-synchronous network, there are two main
factors that directly inﬂuence which bst we may use, namely,
sampling accuracy and freshness. On one hand, too old blocks
could not reﬂect correctly the recent change of network com-
putation power. On the other hand, fresh blocks are usually
not completely received locally. Lines 5 and 6 describe this
tradeoff. Di f fclock and Di f ftime are two functions calculating
clock and time difference between blocks, respectively. D is
the upper bound of block propagation delay. The bst we use
should at least m clocks away from b’s guider and n*D before
it (m, n ≥ 1)).

Bc is a set of blocks sharing the same view, sub-chain id,
and clock with bst . SameChain(b1, b2) gives whether b1, b2
have the same sub-chain id using nv of b2’s view. Balloon
also sample blocks of different views from bst but share the
same clock and could also map to bst ’s current sub-chain
(i.e. Bps in line 9). Finally, Bc and Bps together constitute
b’s sampling blocks S (i.e., b.samples). Balloon utilizes S
to approximate the block concurrency level of a single sub-
chain. Besides, it is worthy to note that attacks on the sampling
accuracy and freshness of a single block will do little harm
to Balloon’s safety, since only statistical behavior of block
samples is utilized, as discussed in the next subsection. In
practice, however, we could set an upper limit on the number
of sampling hashes b.samples could include, so as to counter
attacks of ﬂooding too high sampling payload into a block to
mine.

5.3 Adaptive Chain Adjustment

Balloon will dynamically adjust the number of sub-chains if
it detects signiﬁcant changes in the network’s computation
power. We use the concept of view change to distinguish
status before and after this adjustment.

Triggering chain adjustment. Algorithm 3 shows how
Balloon detects a potential view change. The process starts
with genesis blocks of current view and ends with the latest
main sub-chain blocks in the same view. It regularly collects
samples of all sub-chains during a deterministic period called
epoch. The length of an epoch is measured by clock (e.g., Cp
in line 8), which is more responsive than the real time. For
the ﬁrst epoch, the range of clocks could be different (line
17), since the initial clocks of genesis blocks on different sub-
chains may vary from each other. The upper bound of the

6

ﬁrst epoch range is decided by the largest clock of them (i.e.,
cg in line 2). After the ﬁrst epoch, different sub-chains share
the same epoch range (line 8, 9, 18). The setting of epoch
length Cp is a tradeoff. Bigger epoch distance (measured
by clocks) means more block samples available and better
sampling accuracy, but it also brings poor responsiveness and
thus bad adaptivity. Considering views may be split from
different nodes, it is obvious that the concept of epoch is only
meaningful in a speciﬁed view scenario as seen in Fig 1.

For every single sub-chain, Balloon collects block samples
and make independant vote decesions. Bs is the set of blocks
to use for current epoch, based on which we deﬁne a potential
anchor block as one with the largest clock in Bs. It is potential
because a real anchor should be used for a real view change
process but it is yet known as of now. rate reﬂects the block
concurrency level over a certain period (e.g. block propagation
delay or other time presets in line 5 of Algorithm 2). r0 is the
corresponding reference level under which a single GHOST
sub-chain could achieve satisfying performance and security
gurantee. α0 is the minimum signiﬁcance level of rate change
that Balloon could tolerate, beyond which a view change vote
(for adapting to higher or lower computation power) is casted.
It is introduced because frequent view changes would incur
more risks of being attacked and meanwhile decrease the
overall Balloon chain performance (e.g. switching cost, split
view, etc.). Vote records all types of votes casted by sub-chains
and remembers them seperately (i.e., Vote(0) for no change,
Vote(1) for decreasing rate, and Vote(2) for increasing rate).
The ﬁnal view change decision of an epoch is then made
when enough of its sub-chains cast their votes. If more than
half of sub-chain votes have been casted to support keeping
the status quo (i.e. no change), there would no view change
at the end of this epoch (line 27). On the contrary, when more
than half of them unanimously vote for decreasing rate or the
other, a view change process will be initiated but under one
extra condition that all sub-chains have cast their ballot (line
39). This extra requirement is essential otherwise miners may
select anchors randomly and thus enter into different views,
causing blockchain inconsistency. Finally, Balloon begins its
view change with consistent anchors Ba and corresponding
sampling rates R.

Entering into new view. A fresh new view setup consist
of two components, the number of sub-chains nv+1 in the new
view and corresponding genesis blocks to beigin with (e.g.,
bg), as shown in Algorithm 4. To determine nv+1, Balloon
adopts two different strategies with an emphasis on respon-
siveness and security, respectively. On one hand, if the overall
computation power is signiﬁcantly increasing (i.e., vote_up
is true), nv is set to quickly adapt to this change. max(R) cor-
responds to sub-chain with the largest change and Balloon
directly follows it. An alternative approach includes adapting
only to the average computation power change. It is subop-
timal becasue the security of sub-chains beyond this level
is compromised. On the other hand, a conservative strategy

Algorithm 3: Triggering chain adjustment.
Input: Bm: list of latest main sub-chain blocks of
current view, Bg: list of genesis blocks of
current view corresponding to Bm
Output: Whether to trigger view change

1 nv ←|| Bg ||
2 cg ← max{bg.clock | bg ∈ Bg}
3 epoch ← 1
4 undone ← true
5 while undone do
6

Vote ← (0, 0, 0)
(Ba, R) ← (φ, φ)
cs ← cg + (epoch − 1) ∗Cp
ct ← cs +Cp − 1
n ← 1
while n ≤ nv do
b ← Bm(n)
cb ← b.clock
if cb < ct then

undone ← f alse
break

if epoch = 1 then cs ← Bg(n);
Ancests(b) = Ancests(b.parent) ∪ b
Bs ← {bs | cs ≤ bs.clock ≤ ct , bs ∈ Ancests(b)}
ba ← arg max

bs.clock

bs∈Bs
Ba ← Ba ∪ ba
total ← ∑bs∈Bs || bs.samples ||
rate ← total/ || Bs ||
α ←|| rate − r0 || /r0
if α ≤ α0 then

Vote(0) ← Vote(0) + 1
if Vote(0) > nv/2 then break;

else

R ← R ◦ rate
if rate > r0 then

Vote(1) ← Vote(1) + 1

else

Vote(2) ← Vote(2) + 1

end

end
n ← n + 1

end
na ←|| Ba ||
if na = nv && (Vote(1) > nv/2 || Vote(2) > nv/2)
then

vote_up ← Vote(1) > nv/2
startViewChange(Ba, R, vote_up)
break

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

epoch ← epoch + 1

43
44 end
45 return

7

is used to cope with apparent decrease in the overall power
change. α1 is the maximum rate change level allowed during
a view change. It is preset and determines the lower bound on
nv+1 so as to resist attacks by malicious nodes like reducing
its computation power in a short time. rm further restrains
how far nv+1 could deviate from nv. In both scenarios, nv+1
is decided by nv and speciﬁed rate change level (line 3, 6).

Algorithm 4: View change process.
Input: Ba: anchor blocks, R: rates beyond allowed

level α0, nv: number of sub-chains of old view,
vote_up: true if vote for rate high.

Output: bg, genesis block of new view

1 nv ←|| Ba ||
2 if vote_up then

3

nv+1 ← (cid:100)nv ∗

max(R)
r0

(cid:101)

4 else
5

6

rm ← max{r | r < r0, r ∈ R}
nv+1 ← (cid:100)nv ∗ max{

, 1 − α1}(cid:101)

rm
r0

7 end
8 bg.root ← null
9 (bg.parent, bg.proo f ) ← (null, null)
10 Bg ← {b | b.anchors → Ba || (b.parent → null &&

b.guider ∈ Bg)}

11 if Bg → φ then
12

bg.anchors ← Ba
bg.guider ← arg max

ba∈Ba

bg.anchors ← φ
bg.guider ← arg max

13

16

14 else
15

ba.clock

b.clock // better liveness

b∈Bg

17 end
18 bg.clock ← bg.guider.clock + 1
19 bg.samples ← Sample(Gp, bg)
20 while difﬁculty(bg) < required_diff do
21
22 end
23 bg.nonce ← nonce
24 return bg

update(nonce)

Genesis blocks are generated in a way similar to normal
block mining except some new characteristics. First, a genesis
block should include anchors Bm as one of its inner property
(i.e., b.anchors) and the one with largest clock as its guider if
it is the ﬁrst one of its view. Second, for later genesis block to
mine, it would choose existing ones with the largest clock as
its guider and anchors is then deﬁned as that of the guider’s.
Third, snapshot root, parent, and its proof are meaningless
ﬁelds for new genesis. Actually, they could ﬁnd all of them in
their anchors. Finally, new genesis blocks continue to do the
sampling job. It seems a little trickly for cross view sampling,

8

but the rules and rationale presented in §5.2 still apply. After
all sub-chains have its corresponding genesis, honest nodes
would stop genesis block generation and start to mine normal
blocks.

5.4 Global Consensus on Blocks

Compared to GHOST protocol, the total ordering of blocks
in Balloon is mainly compexiﬁed by mechanisms of block
sampling and chain adjustment, also mixed with the paral-
lel chain achitecture. Balloon ﬁrst simpliﬁes the process by
redeﬁning the subtree weight of blocks on a global scale in
terms of possible view change and split. After that, it deals
with blocks one epoch after another.

Algorithm 5: Block subtree weight redeﬁnition.
1 Children(b) ={ bc | bc.parent → b, bc ∈ Gp}
2 Offspr(b) = (cid:83)
bc∈Children(b) Offspr(bc) ∪ {b}
3 Anchors(b) = Anchors(Genesis(b))
4 Reformers(b) = { ba | isAnchor(ba) → True, ba ∈
Offspr(b)} // Mabye multiple anchors per route
5 Changers(b) = { bg | isGenesis(bg) → True &&
Reformers(b) ∩ Anchors(bg) (cid:54)= φ , bg ∈ Gp}

6 Successors(b) =

(cid:83)

br∈Changers(b) O f f spr(br) ∪ Successors(br)
7 Supporters(b) = { bs | SameChain(bs, b), bs ∈

Successors(b)}

8 SubTB(b) = O f f spr(br) ∪ Supporters(b)
9
10 SubTW(b) = ∑Weight(bw), bw ∈ SubT B(b)

Redeﬁning block subtree. Our key insight is that blocks
in subsequent views should also contribute to the stability
and security of blocks in the previous view. Steps of how we
retrieve Balloon block subtree weight SubTW(b) are given in
Algorithm 5. Offspr(b) is the set of all blocks that could trace
back to b along its parent path. It is obvious that blocks in
Offspr(b) are in the same view since genesis blocks do not
have parent ﬁeld set (Algorithm 4). Recall that we have de-
ﬁned anchors of a genesis block as blocks within its anchors
ﬁeld or that of its guider. Based on that, we could deﬁne an-
chors of any block (i.e., Anchors(b) in line 3) as that of its
corresponding sub-chain genesis. Re f ormers(b) is a set of
anchor blocks in O f f spr(b). A block is an anchor if it is a po-
tential anchor (line 20, Algorithm 3) and there is at least one
valid view change based on it (Algorithm 4). Changers(b) is a
set of genesis blocks who has anchors within Re f ormers(b).
Successors(b) is a set of all blocks in the following views
which may contribute to b’s weight. It is deﬁned recursively
as all blocks that may trace back to b through view change rela-
tion. After that, from the view of b, we choose those that could
map to b’s current sub-chain which we call Supporters(b). As
explained in Algorithm 2, SameChain(b1, b2) checks whether

b1 and b2 have the same sub-chain id based on the total num-
ber of sub-chains in b’s view. Finally, we could deﬁne subtree
blocks of b (i.e., SubTB(b)) as its Offspr plus Supporters.
Therefore, the block subtree weight (i.e., SubTW(b)) is the
accumulated weight of blocks within that. It is noted that, just
like its counterpart in GHOST, SubT B(b) is directly derived
from b’s position in the valid chain graph and does not rely on
any undeterminitic state info (e.g., current view). Therefore,
it is feasible to be used in Balloon chain ordering.

Ordering blocks across views. Block ordering in Balloon
is different from other parallel chain protocols in mainly three
aspects. First, Balloon orders blocks by view and only main
views (compared to view split) are considered. Since view
change process (see Algorithm 4) ensures clocks are increas-
ing as a whole for blocks in the subsequent view, it does not
break the protocol’s safety. Second, main sub-chain blocks
are retrieved by applying a variant of GHOST independantly
which utilizes SubTW (see Algorithm 5). Finally, in a speciﬁc
view, blocks after anchors (i.e., Offspr(b) except anchor b)
will not be ordered anymore though they still contribute to
the overall security (by block weight) of the protocol. After
that, a consistent order of blocks could be derivated by sorting
them based on their block clocks and hashes. Algorithm 6
details how a total order of blocks is obtained from the ground
up given a full picture of current block graph Gp and some
initial setups.

As shown in Algorithm 6, v is the current view number
to differentiate from other main views, Nv is the number of
sub-chains in main view v, Gv is a set of corresponding gene-
sis blocks which is initially set to be the same (i.e., g0), and
C is the total order of blocks we would like to get. As men-
tioned earlier, Balloon handles blocks in a view order and will
generate a view-wise order of blocks Cv whose contactention
constitutes the expected C. In a speciﬁc view, however, blocks
are processed one epoch after another. Therefore, at the start
of an epoch, the starting blocks of corresponding sub-chains
are either geneses (ﬁrst view, line 8) or potential anchors (line
19, 26). For a speciﬁc sub-chain in an epoch, selection of main
chain blocks (line 18) follows greedy heaviest strategy with
the use of new block subtree weight deﬁned in Algorithm 5.
After every epoch, we check whether there is a view change
to be triggered (i.e., CheckVC, detailed in Algorithm 3). We
would update our view and genesis if necessary (check against
Algorithm 4) and then continue to process blocks in the new
view until the end. Cv contains all main sub-chain blocks in a
view, which would be sorted by their clocks before process-
ing blocks in the new view. Finally, a total order of blocks
is retrieved safely. As for transactions, they follow a general
order of blocks. For repeated and conﬂicted transactions, the
validity of them is determined by their corresponding blocks
and later ones are deemed invalid.

Besides, users of Balloon chain usually need to determine
when to conﬁrm a block and transactions within. With re-
construction of SubTW in Balloon, the conﬁrmation policy

9

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

Algorithm 6: Total order of blocks.
Input: Block graph of current parallel chain Gp
Output: An ordered list of blocks C

1 v ← 1
2 Nv ← n0
3 Gv(·) ← g0
4 C ← φ
5 while True do
vc ← f alse
6
Cv ← φ
A(∗) ← Gv(∗)
while True do
n ← 1
while n ≤ Nv do

7

9

8

10

11

// Last potential anchor or genesis
b ← A(n)
abk ← null // Next potential anchor
while b (cid:54)= null do
Cv ← Cv ◦ b
//null if not found
bm ← arg max

SubTW (bc)

bc∈Children(b)

if isPotentialAnchor(bm) → False then

b ← bm

else

abk ← bm
break

end

end
// Update potential anchor block (if any)
A(n) ← abk
n ← n+1

end
// View change check
if checkVC(A) → True then
Update(Gv+1, Nv+1)
// Add anchors of old view
Cv ← Cv ∪ A(∗)
vc ← True
break

else

// All blocks processed, exit
if A(∗) → null then

break

end

end
SortBlocks(Cv) // By its clock and hash
// Collect blocks or current epoch
C ← C ◦ Cv
if vc → f alse then break // task done;
v ← v+1

47
48 end
49 return C

is similar to GHOST or GHAST [17] on a single sub-chain.
For example, we could deﬁne if a block b is conﬁrmed on the
sub-chain if SubT B(b) or SubTW (b) is signiﬁcantly bigger
(e.g., by a certain percent or some number of blocks) than that
of its peers (i.e., blocks with the same parent). For genesis
after a view change, its peers are genesis blocks on the same
sub-chain in the same view. Based on that, we now deﬁne,
a block b is conﬁrmed on the Ballloon parallel chain only
if all main sub-chain blocks in the same view (including b)
whose clocks are not higher than b.clock are conﬁrmed on
their corresponding sub-chains. Many previous works have
provided analysis on block conﬁrmation and its safety impli-
cations for GHOST-style consensus protocols [10, 17, 28] ,
which is therefore omitted here.

5.5 Safety and Liveness

This section gives a general discussion on the safety and live-
ness of Balloon. In the past few years, many researchers have
provided their insights on properties of GHOST or its deriva-
tive protocols (e.g., [11, 17, 28]). From a certain perspective,
Balloon protocol is more like a GHOST version for Parallel
chain protocols (with SubT B and SubTW redeﬁned), except
that it could dynamically adapts to the network’s computa-
tion power. As a result, Balloon inherits safety and liveness of
GHOST in the ﬁrst place. Second, block sampling mechanism
is applied during block mining for possible chain adjustment.
It has no direct impact on the block ordering and thus does no
harm to safety. Actually, it is designed for adaptivity, which
means the system could adapt to the overall computation
power change satisfyingly (e.g., accurately and quickly, §5.2,
§5.3). Finally, views in Balloon may be split during the view
change process as a result of network asynchrony. However,
views across different nodes will eventually merge again with
blocks sent later, just like the main chain convergence in
GHOST.

6 Conclusion

This paper presents Balloon, a scalable parallel chain protocol
with good adaptivity. It could adapt its block throughput and
performance to the change of computation power. It costs
less resource per block and is more economical. Furthermore,
Balloon could accomadate small block mining difﬁculties
accessible to general computation hardware, which would
make it more open and fair.

References

[1] Michael Abd-El-Malek, Gregory R Ganger, Garth R
Goodson, Michael K Reiter, and Jay J Wylie. Fault-
scalable byzantine fault-tolerant services. ACM SIGOPS
Operating Systems Review, 39(5):59–74, 2005.

[2] U.S. Energy Information Administration. Energy use in
homes. https://www.eia.gov/energyexplained/
use-of-energy/electricity-use-in-homes.php.
Accessed: 2022-04.

[3] Vivek Bagaria, Sreeram Kannan, David Tse, Giulia
Fanti, and Pramod Viswanath. Prism: Deconstructing
the blockchain to approach physical limits. In Proceed-
ings of the 2019 ACM SIGSAC Conference on Computer
and Communications Security, pages 585–602, 2019.

[4] Ethan Buchman. Tendermint: Byzantine fault tolerance
in the age of blockchains. PhD thesis, University of
Guelph, 2016.

[5] Miguel Castro, Barbara Liskov, et al. Practical byzantine
fault tolerance. In the Third USENIX Symposium on
Operating Systems Design and Implementation (OSDI),
volume 99, pages 173–186, 1999.

[6] Jing Chen and Silvio Micali. Algorand. arXiv preprint

arXiv:1607.01341, 2016.

[7] Digiconomist.

Bitcoin energy consumption in-
http://p2pfoundation.ning.com/forum/
dex.
topics/bitcoin-open-source. Accessed: 2022-04.

[8] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The
bitcoin backbone protocol: Analysis and applications.
In Annual International Conference on the Theory and
Applications of Cryptographic Techniques, pages 281–
310. Springer, 2015.

[9] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vla-
chos, and Nickolai Zeldovich. Algorand: Scaling byzan-
tine agreements for cryptocurrencies. In Proceedings of
the 26th Symposium on Operating Systems Principles,
pages 51–68, 2017.

[10] Aggelos Kiayias and Giorgos Panagiotakos. On trees,
chains and fast transactions in the blockchain. In In-
ternational Conference on Cryptology and Information
Security in Latin America, pages 327–351. Springer,
2017.

[11] Lucianna Kiffer, Rajmohan Rajaraman, and Abhi Shelat.
A better method to analyze blockchain consistency. In
Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security, pages 729–
744, 2018.

[12] Ramakrishna Kotla, Lorenzo Alvisi, Mike Dahlin, Allen
Clement, and Edmund Wong. Zyzzyva: speculative
byzantine fault tolerance. In Proceedings of 21st ACM
SIGOPS Symposium on Operating Systems Principles,
pages 45–58, 2007.

10

[26] Janusz J Sikorski, Joy Haughton, and Markus Kraft.
Blockchain technology in the chemical
industry:
Machine-to-machine electricity market. Applied En-
ergy, 195:234–246, 2017.

[27] Yonatan Sompolinsky, Shai Wyborski, and Aviv Zo-
har. Phantom ghostdag: a scalable generalization of
nakamoto consensus: September 2, 2021. In Proceed-
ings of the 3rd ACM Conference on Advances in Finan-
cial Technologies, pages 57–70, 2021.

[28] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate
transaction processing in bitcoin. In International Con-
ference on Financial Cryptography and Data Security,
pages 507–527. Springer, 2015.

[29] Xuechao Wang, Viswa Virinchi Muppirala, Lei Yang,
Sreeram Kannan, and Pramod Viswanath. Securing
parallel-chain protocols under variable mining power.
In Proceedings of the 2021 ACM SIGSAC Conference on
Computer and Communications Security, pages 1700–
1721, 2021.

[30] Yingli Wang, Jeong Hugh Han, and Paul Beynon-Davies.
Understanding blockchain technology for future sup-
ply chains: a systematic literature review and research
agenda. Supply Chain Management: An International
Journal, 2018.

[31] Gavin Wood et al. Ethereum: A secure decentralised
generalised transaction ledger. Ethereum project yellow
paper, 151(2014):1–32, 2014.

[32] Maofan Yin, Dahlia Malkhi, Michael K Reiter,
Guy Golan Gueta, and Ittai Abraham. Hotstuff: Bft
consensus with linearity and responsiveness. In Pro-
ceedings of the 2019 ACM Symposium on Principles of
Distributed Computing, pages 347–356, 2019.

[33] Haifeng Yu, Ivica Nikoli´c, Ruomu Hou, and Prateek
In
Saxena. Ohie: Blockchain scaling made simple.
2020 IEEE Symposium on Security and Privacy (SP),
pages 90–105. IEEE, 2020.

[13] Leslie Lamport. Time, clocks, and the ordering of events
in a distributed system. Communications, 1978.

[14] LESLIE LAMPORT, ROBERT SHOSTAK, and MAR-
SHALL PEASE. The byzantine generals problem. ACM
Transactions on Programming Languages and Systems,
4(3):382–401, 1982.

[15] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar.
Inclusive block chain protocols. In International Con-
ference on Financial Cryptography and Data Security,
pages 528–547. Springer, 2015.

[16] Chenxin Li, Peilun Li, Dong Zhou, Zhe Yang, Ming Wu,
Guang Yang, Wei Xu, Fan Long, and Andrew Chi-Chih
Yao. A decentralized blockchain with high throughput
and fast conﬁrmation. In 2020 USENIX Annual Techni-
cal Conference (ATC), pages 515–528, 2020.

[17] Chenxing Li, Fan Long, and Guang Yang. Ghast:
Breaking conﬁrmation delay barrier in nakamoto con-
sensus via adaptive weighted blocks. arXiv preprint
arXiv:2006.01072, 2020.

[18] Silvio Micali, Michael Rabin, and Salil Vadhan. Ver-
iﬁable random functions. In 40th Annual Symposium
on Foundations of Computer Science, pages 120–130.
IEEE, 1999.

[19] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic
cash system. 2008. http://bitcoin.org/bitcoin.
pdf.

[20] Satoshi Nakamoto. Bitcoin open source implementation
of p2p currency. 2009. http://p2pfoundation.ning.
com/forum/topics/bitcoin-open-source.

[21] Jianyu Niu.

Eunomia: A permissionless parallel
chain protocol based on logical clock. arXiv preprint
arXiv:1908.07567, 2019.

[22] Oscar Novo. Blockchain meets iot: An architecture for
scalable access management in iot. IEEE Internet of
Things Journal, 5(2):1184–1195, 2018.

[23] Marshall Pease, Robert Shostak, and Leslie Lamport.
Reaching agreement in the presence of faults. Journal
of the ACM (JACM), 27(2):228–234, 1980.

[24] Team Rocket, Maofan Yin, Kevin Sekniqi, Robbert van
Renesse, and Emin Gün Sirer. Scalable and probabilistic
leaderless bft consensus through metastability. arXiv
preprint arXiv:1906.08936, 2019.

[25] Fred B Schneider. Implementing fault-tolerant services
using the state machine approach: A tutorial. ACM
Computing Surveys (CSUR), 22(4):299–319, 1990.

11

