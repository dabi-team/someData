Deep dive into Interledger:
Understanding the Interledger ecosystem

Lucian Trestioreanu, Cyril Cassagnes, and Radu State

Ripple UBRI @ Interdisciplinary Centre for Security, Reliability and Trust,
University of Luxembourg
29, Avenue JF Kennedy, 1855 Luxembourg, Luxembourg

Abstract. At the technical level, the goal of Interledger is to provide an architecture and a
minimal set of protocols to enable interoperability between any value transfer systems. The
Interledger protocol is a protocol for inter-blockchain payments which can also accommodate
FIAT currencies. To understand how it is possible to achieve this goal, several aspects of the
technology require a deeper analysis. For this reason, in our journey to become knowledgeable
and active contributors we decided to create our own test-bed on our premises. By doing so,
we noticed that some aspects are well documented but we found that others might need more
attention and clariﬁcation. Despite a large community eﬀort, the task to keep information on
a fast evolving software ecosystem up-to-date is tedious and not always the main priority for
such a project. The purpose of this tutorial is to guide, through several examples and hands-
on activities, community members who want to engage at diﬀerent levels. The tutorial
consolidates all the relevant information from generating a simple payment to ultimately
creating a test-bed with the Interledger protocol suite between Ripple and other distributed
ledger technology.

2
2
0
2

n
u
J

1
2

]
E
S
.
s
c
[

1
v
6
4
4
0
1
.
6
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
Contents

1 What this document covers

2 Who this document is for

3 The Interledger community

4

4

4

4 The Interledger ecosystem

5
6
4.1 Main components of a uniﬁed payment infrastructure . . . . . . . . . . . . . . . .
8
4.2 The Money transfer system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
4.2.1 The Bilateral Balance . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.2 Payment channels
11
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Settlement
4.2.3
11
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.4 On-Ledger transfers
11
4.3 The Interledger protocol suite . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3.1 The Simple Payment Setup Protocol . . . . . . . . . . . . . . . . . . . . .
12
4.3.2 The Streaming Transport for the Realtime Exchange of Assets and Messages 14
16
4.3.3 The Interledger Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
4.3.4 The Bilateral Transfer Protocol . . . . . . . . . . . . . . . . . . . . . . . .

5 Customer apps for money transfer

5.0.1 Moneyd, Moneyd-GUI and SPSP . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . .
5.0.2 @Kava-Labs: Switch API

6 The connectors

7 The ledgers

7.1 The Ripple ledger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.1.1 Preparation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Start up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.1.2
7.2 The Ethereum ledger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8 Evaluation and discussion

9 Conclusions and future work

List of Figures

1
Payment chain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 Money transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3 Money transfer in practice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Example 1: SPSP payment
4
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
STREAM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
Example 2: STREAM payment . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
STREAM protocol: FSM diagram . . . . . . . . . . . . . . . . . . . . . . . . . .
7
ILP packet ﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
Example 3: ILP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
ILPv4 ﬂow diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11 Packet data structure

2

24
24
37

41

52
52
52
53
59

60

60

7
9
12
14
15
16
17
18
19
20
21

12 Example 4: BTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13 BTP: the ﬁnite state machine diagram . . . . . . . . . . . . . . . . . . . . . . . .
14 The protocol suite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
SPSP and Moneyd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16 Example 5: XRP payment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17 Example 5: XRP payment, advanced . . . . . . . . . . . . . . . . . . . . . . . . .
18 Example 5: Protocol sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19 Example 6: Interledger payment
. . . . . . . . . . . . . . . . . . . . . . . . . . .
20 Example 6: Inter-Ledger payment, advanced . . . . . . . . . . . . . . . . . . . . .
21 Perspective: connections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22 A connector holding two wallets on two diﬀerent networks . . . . . . . . . . . . .
23 Architecture overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24 The protocol stack in the payment chain . . . . . . . . . . . . . . . . . . . . . . .
25 Example 7: advanced Interledger payment . . . . . . . . . . . . . . . . . . . . . .
26 Example 7: interaction diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27 Ecosystem overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28 Protocols and details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

List of Tables

1
2
3
4

. . . . . . . . . . .
A parallel between the Internet and Interledger architectures
Payment pointer to Endpoint conversion . . . . . . . . . . . . . . . . . . . . . . .
Useful Moneyd commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . .
Useful Rippled server commands

22
23
24
25
27
29
29
34
35
36
42
43
44
45
45
64
65

12
13
33
54

3

1 What this document covers

The scope of this document is to provide a walk-through the Interledger ecosystem starting
with the Interledger Protocol (ILP). This ecosystem encompasses Ripple validating servers, ILP
connectors, Moneyd, Switch API and more. The main goal of the document is to create a
panoramic understanding of the ecosystem, how the main project systems and tools are in-
terconnected together with practical insights into the how-tos of using the various associated
systems and tools.

In our Ripple journey, we needed a comprehensive practical understanding of the general
picture, but the required information was rather sparse, making it diﬃcult to join the diﬀerent
bits and pieces together in order to form a complete test-bed (private network).
Indeed, a
positive indicator is the level of activity of the community to push the vision proposed by Ripple.
Consequently, tutorials and various other resources can become outdated after a few weeks. In
order to overcome this problem, this document consolidates the required documentation to setup
and conﬁgure all the diﬀerent parts. We will provide as much detail as possible in order to build
and deploy a private Ripple network and so an Ethereum network.

The rest of this document is organized as follows.

In Section 3, we review the state of
the online documentation and the diﬀerent community communication channels. In Sections 4,
5, 6 and 7 we remind all the important aspects of Ripple, which we subsequently evaluate in
Section 8. Finally, we wrap-up the document in Section 9.

2 Who this document is for

No prerequisites regarding the Interledger ecosystem are expected from the reader. However,
developers, computer science students or people used to deal with computer programming chal-
lenges should be able to reproduce our setup without struggle.

3 The Interledger community

The community deﬁnes diﬀerent communication channels1 for diﬀerent purposes in order to
interact, get support and discuss the evolution of the protocol. The main channels are:

• The company website of Ripple2 itself, established in 2012. The website provides all

information related to business activities with RippleNet:

– The Interledger Forum3
– The Ripple Dev Blog4
– The XRP Chat Forum5
– The XRP Ledger Dev Portal6 for the rippled servers (i.e. validators and trackers) and
general concepts7. This is the development portal of the XRP Ledger, built on the
Ripple open-source platform called rippled, which is the reference implementation.
Thanks to their open source code-base they also have a Bug Bounty program8.

1https://interledger.org/community.html, accessed June 2019
2https://ripple.com/, accessed June 2019
3https://forum.interledger.org/, accessed April 2020
4https://ripple.com/dev-blog/, accessed June 2019
5http://www.xrpchat.com/, accessed June 2019
6https://developers.ripple.com/, accessed June 2019
7https://developers.ripple.com/docs.html, accessed June 2019
8https://ripple.com/bug-bounty/, accessed June 2019

4

• The Interledger website9. This website aggregates pointers towards all resources10. Here

is a sample of the resources accessible from the website:

– The Interledger Forum11
– The reference implementation12 for ILP connector
– The Raﬁki13 ILP connector, which generally has the same purpose as the reference

implementation but a newer, diﬀerent architecture

– The Interledger14 community calls.

• The Interledger Whitepaper publication - A Protocol for Interledger Payments - Stefan

Thomas and Evan Schwartz – self-published online15

• Academic publication: Interledger: creating a standard for payments - Hope-Bailie, Adrian
and Thomas, Stefan - Proceedings of the 25th International Conference Companion on
World Wide Web, p. 281–282

• Not peer-reviewed research paper: The Ripple protocol consensus Algorithm and Analysis

of the XRP Ledger Consensus Protocol 16

• The Interledger Payments Community Group17 whose scope is broader than Interledger
Protocol (ILP) and aims to create an open, universal payment scheme built on Web stan-
dards.

Regarding practical experimentation with Ripple, Ethereum and Interledger, at the time
of writing, the sources of documentation are sparse, disseminated over diﬀerent channels like
websites, forums, conference slides. Therefore, we collect and connect a relevant selection of
these sources. A few tutorials on the Medium Interledger blog18 concern setting up and starting
a JavaScript connector, which is the reference implementation of the Interledger speciﬁcations
and related protocols. Recently, for the same connector, Strata Labs has provided a quick-start
bundle.

4 The Interledger ecosystem

RippleNet19 aims to create a friction-less experience for sending and receiving money globally.
The company targets institutions (e.g. Banks) of the ﬁnancial sector. The key beneﬁt of the
solution is modernizing the traditional systems, which are many times expensive and take days
to settle. However, one type of infrastructure won’t fulﬁll all the requirements. Therefore, they
strongly support the Interledger Protocol (ILP) initiative in order to realize the vision of an
international friction-less payments routing system.
In other words, a standard for bridging
diverse ﬁnancial systems.

9https://interledger.org/, accessed June 2019
10https://interledger.org/community.html, accessed June 2019
11https://forum.interledger.org, accessed June 2019
12https://github.com/interledgerjs, accessed June 2019
13https://github.com/interledgerjs/raﬁki, accessed June 2019
14https://interledger.org/calls.html, accessed June 2019
15https://interledger.org/interledger.pdf, accessed June 2019
16https://arxiv.org/abs/1802.07242, accessed June 2019
17https://www.w3.org/community/interledger, accessed June 2019
18https://medium.com/interledger-blog, accessed June 2019
19https://ripple.com/ripplenet/, accessed July 2019

5

”Ripple has no direct competitors in crypto space, as it is fundamentally diﬀerent from the
most cryptocurrencies: it’s more centralized, totally currency agnostic and uses probabilistic
voting (and not Proof of Work (PoW)) to conﬁrm transactions.” [1]. This is possible thanks to
the Interledger Protocol (ILP), and because the transaction veriﬁcation process of RippleNet is
not coupled to a mint process, which in the case of some others cryptocurrencies generates a
direct income.

Nonetheless, besides lower cost and faster settlement than classic banking transactions, one
of the most interesting aspects regarding the Interledger Protocol (ILP) is that it will seamlessly
manage payments when the sender’s currency is diﬀerent from the receiver’s currency, or when
the sender’s payments network is diﬀerent from the receiver’s payments network. For instance,
a payment is issued on the ﬁat currency network using MasterCard, VISA, wire-transfer and
the receiver receives it on an account (also known as a Wallet) created within a payment system
using a crypto-currency. The Interledger Protocol (ILP) oﬀers a means to bridge the crypto-
currencies and ﬁat to enable interoperable and fast value exchange. Therefore, it is paramount
to underline that Interledger Protocol (ILP) is not a blockchain, a token, nor a central service.
In ILP, money is actually not moved meaning that ILP doesn’t decrease or increase of the
total amount of electronic money in circulation. A connector swapping both currency has an
account for each payment system it supports. Account balances are open and closed between
parties involved in a particular transaction according to transaction instructions of each payment
system involved. The parties are the sender, intermediaries (connectors) and the receiver. This
statement is derived from the original Ripple explanation regarding connectors:

”Interledger connectors do not actually move the money, they rely on plugins for settlement.
Plugins may settle by making a payment on an external payment system like (automated clearing
house) ACH or they may use payments channels over a digital asset ledger like XRP Ledger or
Bitcoin” [2].

In other words, when the receiver’s currency is diﬀerent from the sender’s currency, also,
no money is leaving the sender’s network and no money enters the receiver’s network. What
happens is that at some point along the chain, some connector with accounts on both payment
systems, keeps the sender’s currency in one wallet (belonging to same ledger as the sender) and
forwards the money towards the receiver, now denominated in the receiver’s currency, from its
other wallet holding that currency on the second ledger - the same ledger with the receiver’s.
The main diﬀerence with the classic system running today is that with ILP, the end-to-end
payment becomes completely seamless thanks to the automation of many parts provided by the
Interledger Protocol (ILP) Suite. For example, whereas in the classical banking systems there
is no direct way for the sender to know when the recipient received the money, with ILP this
information is available immediately.

In this section, we are going to quickly go through the payment infrastructure where all
elements belong to one of the following three categories: distributed Ledger, user-level apps for
payment, and connectors. Then, we will discuss the protocols stack and we will go through each
of these components, providing details on each of them.

4.1 Main components of a uniﬁed payment infrastructure

From a high level point of view, the infrastructure comprises three main components:

Ledgers.
In the context of Interledger, a Ledger is any accounting system that holds user
accounts and balances. It can be linked to cryptocurrencies like Bitcoin, Ethereum, XRP or
classic banks, PayPal and more. Here we are going to use the XRP ledger and the ETH ledger

6

which are distributed ledgers.

The XRP ledger comprises of a network of servers running the rippled software in ”validator”
or ”tracking” mode, and the connectors can plug into it. The servers run the blockchain, record
the user accounts and validate the transactions as they arise from connectors. Figure 1 illustrates
the Ledger layer designed by the early adopters of the Interledger ecosystem. Each Connector
is linked to at least two Ledgers (e.g. Ledger 1 = XRP Ledger and Ledger 2 = Ligthning) with
dedicated plugins.

The user accounts are opened and stored on-ledger. In the case of the XRP ledger, this is

how the related account info looks like at the time of opening the account:

{

"result" : {

"account_id" : "rMqUT7uGs6Sz1m9vFr7o85XJ3WDAvgzWmj",
"key_type" : "secp256k1",
"master_key" : "NIP SELF EDGY AQUA COME BAWD RING NEAL HINT HACK HEAT ADEN",
"master_seed" : "shjZQ2E3mYzxHf1VzYBJCQHqLvt7Y",
"master_seed_hex" : "925A2949624EF8CFA8A6C6A6E9211B2C",
"public_key" : "aB4XmhndLn6C3sbsp5qK4Cy3GG9mU4KVe3wqWHatuudZX7CMhsvC",
"public_key_hex" :

"024B8511437A9A20E57C21A42A463DEEFE49D1DBE48ECA7FEEDE50048D02D92152",

"status" : "success"

}

}

- ”account id” is the public address of the account, used to identify the account and perform
transactions.
- ”master seed” is the private key of the account. It is ”the lock” of the account and should be
kept safe and private.
- ”master key” can be used to regenerate the account details if needed.
- ”public key” can be used by third parties for veriﬁcation.

Fig. 1: Payment chain.

ILP connectors. The reference implementation of the connector speciﬁcation is in JavaScript
and so is the new Raﬁki connector. However, other implementations are also written, in Java and
Rust. Figure 1 shows that connectors are bridging all ledgers and their end-users, represented

7

there by the ”sender” and ”receiver”.

Connectors are run by diﬀerent entities and oﬀer payment inter-operability across the pay-
ment platform to the ”customers” running a ”customer app”. The connectors are the ”service
providers”, or ”market makers”, or ”liquidity providers”, because they provide end-users access
to other payment networks, provide payment routing, exchange and liquidity. In order to do
this, the Connectors make use, among others, of the Interledger Protocol (ILP), and ILP ad-
dresses.

ILP address. In order to be able to identify themselves and their users, and route the payments in
a global network, the need for unique identiﬁcation in the internet’s IP style has arisen. As such,
unique ILP addresses are being assigned to each Interledger node. In ILP a node can be a sender, a
connector or a receiver. All nodes implement ILP.

On the production network, any ILP address starts with ”g”. Other preﬁxes can be ”private” ,
”example” , ”peer” , ”self” .. We provide below some ILP address examples. These are thoroughly
explained on the Interledger website [3].

g.scylla - ”scylla” is a connector and ”g.scylla” is its ILP address
g.acme.bob - is the address held by Bob on the ”acme” connector
g.us-fed.ach.0.acmebank.swx0a0.acmecorp.sales.199. ipr.cdfa5e16-e759-4ba3-88f6-8b9dc83c1868.2 - is
a complex, real-life address.

The connectors accept ”dial-up connections” from the ”customer apps”, like an internet
provider would provide internet services by accepting a dial-up connection from a home internet
dial-up modem. As such, they function as Interledger Service Providers (ILSPs).
’An ILSP,
[depicted in Figure 27], is a connector that accepts unsolicited incoming peering requests. It will
have multiple child nodes connect to it and will assign them each an address and then route ILP
packets back and forth for them onto the network. (It’s modelled on the idea of an ISP that
provides customers access to the Internet)’ [4]. When opening payment channels and routing
payments for their customers, depending on the number of customers, a connector could bound
signiﬁcant amounts of money. They assume some risks and expect to make small proﬁts in
exchange for providing the service.

are the third component of the infrastructure, and they provide end-users
Customer apps
access to the Interledger payment system. Examples of customer apps are Moneyd or Switch
API. Figure 1 shows the diﬀerent layers for end-users, i.e. participants willing to generate a
payment.

4.2 The Money transfer system.

The system of money transfer over ILP involves recording and manipulating money at diﬀerent
levels:

• The Bilateral Balance kept between two peers

• Settlement on the payment channel (paychan), which involves signing claims that are
recorded on the payment channel opened between the two peers. The claims concern the
transactions between the two peers resulting from adjusting the Bilateral Balance above.

• On-Ledger recorded transactions, resulted, for example, from redeeming the previous claims
submitted on the payment channel. On-Ledger transactions can also be submitted, for
example, by using the Ripple API.

8

4.2.1 The Bilateral Balance.

Two directly connected peers hold a balance between them, for the ILP packets of value they
exchange. The balance is maintained real-time and it can increase or decrease, according to the
value they exchange.

The balance parameters are:

balance: {

maximum: ’20000000000’, //maximum amount that the other party can owe
settleThreshold: ’-50000000’, //the balance value that triggers an automatic

settlement

settleTo: ’0’ //balance value after settlement

}

Concerning Figure 2, if for example at one given moment, according to the total balance,
Alice owes Bob 20 XRP, Alice’s balance with Bob will be -20 XRP, while Bob’s balance with
Alice will be 20. Their balances will oﬀset each other. This balance can be seen in the Moneyd-
GUI (Graphical User Interface). Concerning Figure 2, this is the ”ILP Balance”, and it is a
not-yet-settled balance.

Fig. 2: The money transfer system.

9

UnderlyingLedger(the RippleXRP main Ledger)AliceBobILP transactionsILP Balance:-maximum-threshold-settletoILP Balance:-maximum-threshold-settletoRedeemclaimsRecord claimsPaychanPaychanbalanceMaximum Balance. Peers can set the maximum balance they are willing to trust (or risk) in
relation to each other in the plugins conﬁguration (for the reference js connectors and Moneyd).

Settle Threshold. The ILP peer balance can be settled manually or automatically. The
connector plugins can be set to automatically settle this balance on the paychan by using the
”settleThreshold ” ﬂag. If, for example, Alice has conﬁgured a settlement threshold of -15, this
means that she will settle with Bob as soon as she owes him 15 XRP or more.

”In a correctly conﬁgured peering the additive inverse (negation) of the settlement threshold

of one peer will be less than the maximum balance of the other peer.” [5]

settleTo. The automatic Settlement process should attempt to re-establish the ILP balance

to this amount. This is done through a paychan claim.

4.2.2 Payment channels.

Payment channels, or in short ”paychans”, are an important feature of nowadays Interledger.
Some distributed ledgers are deﬁning their own payment channel concept. Therefore, it is
important to keep in mind the deﬁnition of the Payment Channel agreed in the documentation
of Interledger20.

Payment channels are opened only between direct peers. Settlement, presented in Section
4.2.3, also occurs only between direct Interledger peers. When two peers connect over ILP,
they open a payment channel. Their bilateral transactions will afterwards be carried on to the
paychan. Paychans are a solution for faster, cheaper and more secure transactions, especially
when the ledger involved is slow or expensive.

Below is an explained example of an Interledger paychan details [6]:

{
account: ’rLR52VSZG3wqSrkcpfkSnaKnYoYyPoJJgy’, //the payer’s XRP account address
amount: ’100000’, //size of the payment channel
balance: ’0’, //the amount the payee expects to have already received from the channel
destination: ’rMqUT7uGs6Sz1m9vFr7o85XJ3WDAvgzWmj’, //the payee’s XRP address
publicKey: ’ED6AF48DB11D68CDF37B22D594DC18B7C1AF2D4157A7F9A487481469A7A7C91AE2’,

//public key used for the channel. Can be the payer’s master key pair. Necessary
to verify and redeem claims.

settleDelay: 3600, //(in seconds) provides time for payee to redeem outstanding claims
sourceTag: 2100406056,
previousAffectingTransactionID:

’8D8FF4F2AD33FAB476CFBD7256D6138419BAAC6EFDAF16ECEEFAC704752B330A’,

previousAffectingTransactionLedgerVersion: 201538
}

When two nodes connect over ILP they negotiate the paychan details according to their
business needs. The main characteristic of a paychan is its size, which is the largest claim
one can sign before they need to add more money. The paychan and its corresponding details,
including size, is recorded on the ledger. This is a guarantee that obligations will be eventually
settled, according to the channel size, with the help of the underlying ledger. The trust invested

20https://github.com/interledger/rfcs/blob/master/0027-interledger-protocol-4/0027-interledger-protocol-

4.md, accessed June 2019

10

in the ledger regarding the paychan is implicit, because the ledger was already trusted when
opening the main accounts.

When transacting on a paychan, the two parties hold a Bilateral Ledger, which records
the transactions performed in-between the two, and the balance. Most of the transactions are
performed oﬀ-ledger, thus improving the speed and transaction costs also. Only when the peers
redeem their recorded paychan claims, the speciﬁc transaction is recorded on-ledger. On the
payment channel each claim is recorded individually, but they can be later redeemed individually
or in bulk on the ledger [6].

4.2.3 Settlement.

Settlement is a core concept used in ILP, which is part of the larger system of money transfer
over ILP. In practice, settling is encountered for example while setting up plugins or in relation
to payment channels. The main concept, illustrated in Figure 2 [7], in practice usually involves
a system of Interledger balances and paychan claims.

In relation to paychans, settlement involves signing a claim for the money owed. Claims do
not need to be directly submitted to the ledger, but for the case of the Ripple ledger which is
fast and cheap, they can [8, 6]. The process will be reﬂected in the paychan balance in Figure 2.
Multiple claims can be signed on the paychan, and the paychan balance will update accordingly.
Note that at this point, no amount or transaction has been yet recorded on-ledger (except the
initial channel creation and funding), so the ledger accounts for Alice and Bob still show the
same balances as before (except for cheap and fast ledgers like the Ripple ledger which makes
it possible to submit claims individually if desired, to make the money available faster).

Claims can be redeemed out of the paychan and into the user ledger account in bulk or

individually. The paychan can be closed or reused.

4.2.4 On-Ledger transfers.

On-ledger transfers can be initiated in diﬀerent ways. The most relevant in ILP is redeeming
the claims submitted on the paychan. Only at this point, the money will show up in the user
wallet. Another possible way to initiate an on-ledger transaction is for example directly using
the Ripple-API.

Note: If Alice and Bob are end-users, or customers, running an ILP customer module to connect to
ILSPs (connectors), the situation presented in Figure 2 will never happen, because Alice and Bob can
never have a direct peering and settlement relationship. Their peering and settlement relationships
are with their direct peers, respectively their parent connectors. So in this case, ”Bob” should be in
fact a ”Connector” such that Figure 2 is correct with respect to real-life situations. As such, a real-life
scenario would look in fact as shown in Figure 3: If Alice wants to send Bob 10 USD, the money will
end up at Connector 1 and she will settle with Connector 1. In its turn, Connector 1 will pay 10 USD
to Connector 2. Connectors 1 and 2 will settle between each other. Further, Connector 2 will forward
the 10 dollars to Bob, and settle with Bob. By means of this chain, Alice has in fact sent Bob 10
USD.

4.3 The Interledger protocol suite

The Interledger architecture is often compared with the Internet architecture, as in Table 1. As
a matter of fact, they adopt the same layered approach [9]. It involves multiple protocols, but
the most important are BTP, ILP, STREAM and SPSP, which are presented below.

11

Fig. 3: The money transfer system in practice.

Table 1: A parallel between the Internet and Interledger architectures. [9]

Internet architecture

Interledger architecture

L5 Application
L4 Transport
L3 Internetwork
L2 Network
L1 Physical

HTTP SMTP NTP L5 Application
TCP UDP QUIC
IP

L4 Transport
L3 Interledger

PPP Ethernet WiFi L2 Link
Copper Fiber Radio L1 Ledger

SPSP HTTP-ILP Paytorrent
IPR PSK STREAM
ILP
BTP
Blockchains, Central Ledgers

4.3.1 The Simple Payment Setup Protocol

The Simple Payment Setup Protocol (SPSP) is a protocol for exchanging the required infor-
mation in order to set-up an Interledger payment between a payee and a payer. It is the most
widely used Interledger Application Layer Protocol today [10]. SPSP makes use of the STREAM
protocol to generate the ILP condition and for data encoding.

Because STREAM does not specify how to exchange the required payment details, some other
protocol and app have to implement this. SPSP is a protocol that uses HTTP for exchanging
payment details between the sender and the receiver, such as the ILP address or shared secret
[11].
In other words, SPSP is a means for exchanging the server details needed for a client
to establish a STREAM connection. It is intended for use by end-user applications, such as a
digital wallet with a user interface to initiate payments. The SPSP Clients and Servers make use
of the STREAM module in order to further process the ILP payments. SPSP messages MUST
be exchanged over HTTPS.

Payment pointers can be used as a persistent identiﬁer on Interledger. They are a stan-
dardized identiﬁer for accounts that are able to receive payments [12]. Payment pointers can
also be used as a unique identiﬁer for an invoice to be paid or for a pull payment agreement.
The main characteristics of the payment pointers are:

• Unique and Easily Recognizable

• Simple Transcription: It should be easy to exchange the payment pointer details with a

payee

12

ILP transactionsUnderlyingLedger(the RippleXRP main Ledger)AliceConnector1ILP transactionsILP Balance:-maximum-threshold-settletoILP Balance:-maximum-threshold-settletoRedeemclaimsRecord claimsPaychanPaychanbalanceConnector2BobILP Balance:-maximum-threshold-settletoILP Balance:-maximum-threshold-settletoRedeemclaimsRecord claimsPaychanPaychanbalanceILP transactionsRedeemclaimsRecord claimsPaychanPaychanbalanceILP Balance:-maximum-threshold-settletoILP Balance:-maximum-threshold-settleto• Flexible: avoid being strongly connected to a speciﬁc protocol

• Widely Usable: should be easy to implement and use.

The syntax is: ”$ host path-abempty” [12].

The SPSP Endpoint is a URL used by the SPSP Client to connect to the SPSP Server,
obtain information about it, and set up payments. The payment pointer automatically resolves
to the SPSP endpoint by means of a simple algorithm. If ”path-abempty” is not speciﬁed, it is
replaced with ”/.well-known/pay” [12]. Table 2 also explains how a Payment pointer is resolved
to an SPSP endpoint.

Table 2: Payment pointer to Endpoint conversion. [12]

Payment pointer
$example.com
$example.com/invoices/12345
$bob.example.com
$example.com/bob

SPSP endpoint
https://example.com/.well-known/pay
https://example.com/invoices/12345
https://bob.example.com/.well-known/pay
https://example.com/bob

Technically, payments could be performed without the use of payment pointers / SPSP
endpoints. However, for ease of use, for the practical reasons explained above, the payment
pointers and SPSP have been introduced on top of the existing technology.

In conclusion, there are multiple forms of identiﬁcation, associated to diﬀerent levels of the

system:

• Ripple account address or Ripple wallet address, used at ledger level to identify your user

account holding the money on the ledger. It is analog to your bank account number

• ILP address, used at ILP level to uniquely identify your ILP node in the global network.

Could be compared to an IP address.

• SPSP endpoint, used by the SPSP protocol/app to set-up an ILP payment

• payment pointer used by humans as an easy-to-handle unique payment identiﬁer, in the

same fashion as an email account address. It is also used in association with SPSP.

Example 1. Concerning the Figure 4:

- Suppose each Alice and Bob have their own accounts in XRP on the XRP Ledger.
- Alice wants to pay Bob in XRP.
- Bob already has his own payment pointer, $example.com/bob, which he easily shares to Alice
verbally. This information is easy for Alice to remember and use. (step (1) in Figure 4)
- Supposing the machine already set-up, at her computer, Alice starts up Moneyd, and is able to
pay Bob just by introducing his payment pointer address ”$example.com/bob” and the amount
paid in Moneyd-GUI, or from a terminal, by using a single line:

”ilp-spsp send –receiver $example.com/bob –amount 100”

Behind the scenes:

13

Fig. 4: Example 1: SPSP payment.

Alice’s SPSP client:
- resolves the payment pointer ”$example.com/bob” to https://example.com/bob
- connects over HTTPS to Bob’s SPSP server, at the address ”https://example.com/bob” (2)
- queries the SPSP server for Bob’s ILP address and a unique secret (2)
Bob’s SPSP server sends Bob’s ILP address and a secret to Alice’s SPSP client (3)
Using this information, Alice’s SPSP client starts an ILP payment to Bob over Interledger (4).

The usage of public endpoints involves employing HTTP, TLS, DNS, and the Certiﬁcate
Authority system for the HTTPS request that SPSP makes. However, the alternatives leave
much to be desired. Few people outside of the cryptocurrency world want cryptographic keys as
identiﬁers and, as of today, there is no alternative for establishing an encrypted connection from
a human-readable identiﬁer that is anywhere nearly as widely supported as DNS and TLS [10].

4.3.2 The Streaming Transport for the Realtime Exchange of Assets and Messages

The Streaming Transport for the Realtime Exchange of Assets and Messages (STREAM)
is a Transport Protocol working with ILPv4. Application level protocols like SPSP make use of
the STREAM protocol to send money. STREAM splits payments into packets, sends them over
ILP, and reassembles them automatically. It can be used to stream micropayments or larger

14

3. GET Bob’sILP addressGET secretAliceBob2. SPSP over http querySPSP serverSPSP client$example.com/bobSPSP endpointhttp://example.com/bobPaymentpointer4. Interledgerpayment1. Bob shareshispaymentpointerdiscrete payments and messages. It is a successor of the Pre-Shared Key V2 (PSK2) Transport
Protocol and is inspired by the QUIC Internet Transport Protocol.

Fig. 5: STREAM is a logical, bidirectional channel over ILP. [9]

As illustrated in Figure 5 with green, a STREAM connection establishes a two-ways, virtual
channel of data and money between the payer and payee. STREAM packets are encoded,
encrypted, and sent as the data ﬁeld in ILP Prepare (type 12 ILP packet), Fulﬁll (type 13
ILP packet), or Reject packets (type 14 ILP packet). The logical connection is used to send
authenticated ILP packets between the ”client” and ”server” (the blue connections in Figure 5).
Either the payer or the payee can be the server or the client. STREAM provides authentication,
encryption, ﬂow control (ensure one party doesn’t send more than the other can process), and
congestion control (avoid ﬂooding the network over its processing power).

STREAM servers are waiting for clients to connect over ILP. The servers connect to a spe-
ciﬁc plugin on the local machine and wait for the ILP packets. Usually, ilp-plugin is used to
connect to Moneyd. The server generates a unique ILP address and shared secret, which will
be used to encrypt data and generate fulﬁllments for ILP packets in relation to a speciﬁc client.
The request for the address and secret, and the response, are not handled by STREAM, but
for example by SPSP. After a client has the ILP address and secret (obtained with SPSP for
example), it can connect to the STREAM server by using these credentials [13, 14].

Example 2. We now provide a more advanced explanation regarding the same situation pre-
sented in Example 1. We will refer to Figure 6, and extend the explanation from Example
1:

• Alice’s SPSP client:

– resolves the payment pointer ”$example.com/bob” to https://example.com/bob
– connects over HTTP to Bob’s SPSP server at address https://example.com/bob (2)
– queries the SPSP server for Bob’s ILP address and a unique secret (2). The SPSP
server forwards the request to the STREAM server module and fetches the answer

• Bob’s SPSP server sends Bob’s ILP address and the secret to Alice’s SPSP client (3)

• Alice’s SPSP client passes the credentials to the STREAM client module which initiates

a logical STREAM connection over ILP, using the ILP modules (4)

• Bob receives his payment over the Interledger (5).

Further details on the STREAM protocol are illustrated in the ﬁnite state machine diagram

of the STREAM protocol, presented in Figure 7.

15

Fig. 6: Example 2: STREAM payment.

4.3.3 The Interledger Protocol

The Interledger Protocol (ILP), currently at version 4, is the main protocol facilitating the Inter
Ledger money transfers. It provides a solution to route payments across disconnected ledgers
while minimizing the sender and receiver’s risk of losing funds. What makes it diﬀerent from
previous versions is that it is optimized for sending many low value packets:

”We talked about the idea of streaming payments, where if you make payments so eﬃcient
that you could pay for like a milliliter of beer or a second of video. That’s the way we think
about eﬃciency of payments.”[15]

It is made for payment channels, which means faster and cheaper payments, while also

accommodating any type of ledger.

ILPv4 involves Hashed Time Lock Agreements (HTLA) [17], and makes use of three packet

types:

• Prepare, corresponding to request, with the following ﬁelds:

– destination - ILP address,

– amount - UInt64,

– condition - UInt256,

– expiration - timestamp,

16

4. STREAM logicalconnectionusingILP addressand secret3. GET Bob’sILP addressGET secretAliceBob2. SPSP over http querySPSP serverSPSP client$example.com/bobSPSP endpointhttp://example.com/bobPaymentpointer5. Interledgerpayment1. Bob shareshispaymentpointerSTREAM module(client)STREAM module(server)ILP moduleILP moduleFig. 7: STREAM protocol: FSM diagram.

17

Fig. 8: ILP packet ﬂow. [16]

– end-to-end (sender-receiver) data - OCTET STRING.

Example of an ilp-prepare packet:

{
amount= 69368000,
executionCondition= fHII9adb3JY3D5drSNSoquLTIUJJhNLMeiiADnW4li0=,
expiresAt= 2019-06-19T11:04:18.149Z,
destination= g.conn1.ilsp_clients.mduni.local.viby9ZjztwCVMtptFjaueqsdlIxWSUba

y7Jo3BxJyGc.elrqFEKZEc8BMcZ4PDUiPEAF,

data= t6lmRiiFZecXhltYNsnyPYSgPld+Itmn+NefM5ytnFJiFDuMieyF9b2vB

o2HPiNm34GpCBlU/HoGaCAsOQ==

}

• Fulﬁll, corresponding to response, and carrying the following ﬁelds:

– execution condition fulﬁllment - UInt256,

This is the proof that the receiver has been paid, so the fulﬁll packets are relayed back
by the connectors from the receiver to the sender. It consists of a simple pre-image
of a hash, and only the receiver can know this information.

– end-to-end (sender-receiver) data - OCTET STRING.

The components of the prepare and fulﬁll packets concerning HTLA are:
- amount, time (expiration), and condition for Prepare, and
- the execution condition fulﬁllment (the hash) for the Fulﬁll packet, which must be re-
ceived before expiration. This implies that the machines involved in the process should be
time-synchronized. This is not an absolute enforcement, but any time oﬀsets will packet
rejection chances.

• Reject, corresponding generally to error messages. They can be returned either by the

receiver or the connectors in speciﬁc conditions and consist of:

– a standardized error code,

– triggered by: - ILP address;

is the identiﬁer of the participant that originally generated the error,

– user-readable error message - UTF8String,

– machine readable error data - OCTET STRING.

The connectors forward the prepare packets from the sender to the receiver, and relay back
the response or the reject from the receiver to the sender, as shown in Figure 8. As such, ILP v4
uses a chaining of HTLAs to achieve an end-to-end transfer [17]. In ILP v4, HTLAs are mainly

18

supported over Simple Payment Channels. Simple Payment Channels are generally supported
by today’s major blockchains like BTC, ETH, XRP,.. [18, 19].

Concerning Figure 8 and ILP v4: even if the original ILP packet is prepared by the Sender
and addressed for the Receiver (end-to-end), the transfer from the Sender to the Receiver will
be in fact a chaining of transfers between the directly connected (and trusted) peers. Each
pair of directly connected peers generally uses a dedicated, separate Payment Channel to settle
their obligations [17, 18, 19]. Other means are possible [19], but not really used or supported [18].

Fig. 9: Example 3: ILP.

Example 3. We will further expand on the Examples 1 and 2, using the Figure 9.

• Alice’s SPSP client:

19

4. STREAM logicalconnectionusingILP addressand secret3. GET Bob’sILP addressGET secretAliceBob2. SPSP over http querySPSP serverSPSP client$example.com/bobSPSP endpointhttp://example.com/bobPaymentpointer1. Bob shareshispaymentpointerSTREAM module(client)STREAM module(server)ILP moduleMoneydILP moduleMoneydAlice’sILP addressBob’sILP addressINTERLEDGERMoney (XRP)Connector5. ILP transferFig. 10: ILPv4 ﬂow diagram.

20

– resolves the payment pointer ”$example.com/bob” to https://example.com/bob

– connects over HTTP to Bob’s SPSP server at address https://example.com/bob (2)

– queries the SPSP server for Bob’s ILP address and a unique secret (2). The SPSP
server forwards the request to the STREAM server module and fetches the answer

• Bob’s SPSP server sends Bob’s ILP address and the secret to Alice’s SPSP client (3)

• Alice’s SPSP client passes the credentials to the STREAM client module which initiates
a logical STREAM connection over ILP, using the ILP module, in our case, Moneyd (4)

• The ILP module, Moneyd, sends the ILP packets corresponding to the STREAM virtual
connection towards its upstream parent connector, which further routes them to its child,
Bob’s Moneyd module (5).

The STREAM module is able to break the payment into multiple packets, which would be
sent over ILP using prepare-fulﬁll-error packets. The STREAM module at the receiver’s end
will ﬁnally reassemble the payment.

Wrapping-up ILP, Figure 10 presents the ﬁnite state machine diagram of an ILP packet and

the protocol ﬂow chart.

4.3.4 The Bilateral Transfer Protocol

The Bilateral Transfer Protocol (BTP) emerged as a necessity, due to a combination of ILP
goals (fast and cheap transactions) and the realities of some ledgers (expensive and/or slow
settlements). With BTP, two parties can send funds directly to each other, up to a maximum
amount they are willing to trust before settlement. BTP is used between connectors (Moneyd
included) for transferring ILP packets and messages necessary to exchange payments, settlement,
conﬁguration and routing information.

Fig. 11: Packet data structure. [20, 21]

As shown in Figure 11, BTP is a ”carrier” for ILP packets and as such, for other protocols
like STREAM for example. BTP establishes the ”link” between connectors, on top of which the
ILP packets are being sent. When setting-up the connector plugins, one also generally sets-up a
BTP connection. The data is sent over web socket connections. One of the peers acts as a server
while the other is connected as a client. It implements a Bilateral Ledger, where the two peers
keep track of their (yet) un-settled accounts and balances. The Bilateral Ledger, a micro-ledger

21

BTP packetILP packetSTREAM packetApplication packetkept by the two peers in-between them, is not to be confused with the Underlying Ledger - the
main ledger where all accounts and transactions are stored, e.g. the Ripple ledger. With regards
to Figure 14, it is to be noted that ILP can still work without BTP [22].

With regards to the current state of BTP, the following post by Ewan Schwartz is worth
mentioning: ”BTP is a binary request/response protocol implemented over WebSockets. It orig-
inally included message types for Prepare, Fulﬁll, Reject and Transfer, but BTP 2.0, which is
used today, stripped out nearly everything except request/response semantics, authentication, and
”sub-protocol” naming”. [10]

Example 4. We can now complete our diagrams presented in Examples 1, 2 and 3 with the
BTP protocol, which is illustrated in Figure 12.

In order to connect to Interledger, each Alice and Bob’s ILP modules establish a BTP
connection over wss with the parent connector. As long as they are connected to Interledger,
this connection will be live. The ILP packets will travel over BTP. While opening the BTP
connection, both of them also negotiate a unique paychan with their direct peer, the connector.
It is to be noted that while we made this choice for clarity, the order we presented SPSP,
STREAM, ILP and BTP is not necessarily the real temporal order of events. This will be further
explained in Examples 5, 6, and 7.

Fig. 12: Example 4: BTP. [20, 21]

22

4. STREAM logicalconnectionusingILP addressand secret3. GET Bob’sILP addressGET secretAliceBob2. SPSP over http querySPSP serverSPSP client$example.com/bobSPSP endpointhttp://example.com/bobPaymentpointer1. Bob shareshispaymentpointerSTREAM module(client)STREAM module(server)ILP moduleMoneydILP moduleMoneydAlice’sILP addressBob’sILP addressINTERLEDGERMoney (XRP)Connector5. ILP transferFig. 13: BTP: the ﬁnite state machine diagram.

The ﬁnite state machine of the BTP protocol is presented in Figure 13.
The relationship between protocols, and especially the STREAM protocol, can be best un-

23

derstood by referring to Figure 28 at the end and reading the thorough explanations provided
by [20, 21].

Other protocols examples are the Interledger Dynamic Conﬁguration Protocol (ILDCP),

or the Route Broadcasting Protocol (RBP). DCP is built over ILP and used to exchange
node information such as ILP address, while RBP is used to transfer routing information. Both
use the data ﬁeld in the ILP packets [20].

In the examples that follow, we are going to make use of BTP, ILP, STREAM and SPSP, a

protocol suite also depicted in Figure 14.

Fig. 14: The protocol suite. [16]

5 Customer apps for money transfer

5.0.1 A customer environment comprising Moneyd, Moneyd-GUI and SPSP client/server.

Moneyd: ’Moneyd provides a quick on-ramp as the ”home router” of the Interledger, giving
apps on your computer access to send and receive money. Although Moneyd can just as easily
connect to the production Interledger, it is not currently designed for heavy production use, so it
lacks features like budgeting that would let you give apps diﬀerent spending limits and permissions
levels.’ [23]

Moneyd connects to the Interledger and sends and receives ILP packets for you.

It is a
simpliﬁed, end-user version of a connector, and as such, it will not send or receive routes as a
regular connector does. Apps running on your machine that require access to ILP will connect
to the Interledger through Moneyd.
When you ﬁre-up Moneyd:

• Moneyd loads ˜/.moneyd.json and instantiates an ILP Connector

• The connector (i.e. ”Moneyd”) opens a web socket connection to its parent connector
(conﬁgured in ˜/.moneyd.json) and creates a payment channel, which can be in XRP,
Ethereum,.. depending on the uplink connection

24

ApplicationTransportInterledgerLinkLedgerSPSPSTREAM...ILPv4...BTP.........• The connector (i.e. ”Moneyd”) listens on the local port 7768 to process ILP payments.

All your local apps (like SPSP) will connect here for ILP.

To install Moneyd for XRP21, just type the following into the terminal:

npm install -g moneyd moneyd-uplink-xrp

The best way to understand it is to conﬁgure it in advanced mode and start in DEBUG

mode.

Conﬁgure it using: ’moneyd xrp:conﬁgure –advanced’. A conﬁguration ﬁle will be created
in the user root folder, as ˜/.moneyd.json. If needed, this ﬁle can be inspected and manually
updated afterwards.

Start in DEBUG mode using: ’DEBUG=* moneyd xrp:start –admin-api-port 7769’. The op-
tion ’–admin-api-port 7769’ will open the port 7769 as Moneyd admin port, such that Moneyd-
GUI can connect to it and administration can be performed in a web browser.

Moneyd-GUI is a frontend for Moneyd (or the reference js connector), which displays
statistics, sends and receives money, and helps with troubleshooting 22. Running on the same
machine with Moneyd or with the js reference Connector, it can be installed with23:
npm install -g moneyd-gui.
It will connect automatically to the port above, after being started with:
’npm start’ in ’/home/user/moneyd-gui’.
In a web browser, it can be accessed by default at http://127.0.0.1/7770.

SPSP: Another business case illustrating the way SPSP and Moneyd/ILP are working to-
gether (because Moneyd is implementing ILP for settlement) was well illustrated in Figure 15.
Both Alice’s and BigCompany’s SPSP client and server are connected to ILP through Moneyd.
Alice’s SPSP client connects to BigCompany’s SPSP server which exposes an HTTPS endpoint
abstracted as a payment pointer [24].

Fig. 15: SPSP and Moneyd [24]. Between the two Moneyd instances there are usually multiple
connectors providing the ILP service.

The protocol follows like below [24]:

21https://github.com/interledgerjs/moneyd, accessed June 2019
22https://medium.com/interledger-blog/use-interledger-with-moneyd-gui-21dee0dc8ba0, accessed June 2019
23https://github.com/interledgerjs/moneyd-gui, accessed June 2019

25

• Alice queries her customer payment pointer (1), and

• receives the ILP destination account and a shared secret (2)

• Using the data obtained, Alice’s SPSP client starts a STREAM connection and sends the

money to BigCompany (3).

’The SPSP module calls the Interledger module with the address and other parameters in
the Interledger packet to send a payment. The Interledger module would send a transfer to
the next connector or destination account along with the Interledger packet and according to
the parameters given. The transfer and Interledger packet would be received by the next host’s
Interledger module and handled by each successive connector and ﬁnally the destination’s SPSP
module’ [25].

As a side note, SPSP ﬁrst started with PSK and was later upgraded to STREAM.

Using the below procedure, one can send and receive money by writing a single line in the
terminal. An SPSP server24 and a client25 should be installed on the recipient’s and sender’s
machines, respectively. They work in pair and have as pre-requisite Moneyd but can also work
alongside the reference connector.

The following lines are provided for the case of a private independent network using IPs as
payment address identiﬁers. For real-life situations where addresses in the form of ’$sharaﬁan.com’
can be provided, the original github guidelines can be used.

In order to transfer money, we should ﬁrst have a receiver address, i.e. start the server
which listens for an incoming payment. Using ’DEBUG’ will provide more info on what happens
behind.

SPSP ’server’ listening for an incoming transfer
Install the server with:
’DEBUG=* ilp-spsp-server –localtunnel false –port 6000’
’–localtunnel false’ : forces the use of IP as the address instead of creating a tunnel and obtaining
an address like ’$mysubdomain.localtunnel.me’ (analogue to ”$example.com/bob”).
’–port 6000’ : the server will listen for incoming payment from an SPSP ’client’ on this port.

An SPSP ’client’ sending money to the server
The money can be then sent by another user/machine having a similar setup, with:
’DEBUG=ilp* ilp-spsp send –receiver http://192.168.1.116:6000 –amount 100’.
Where ’http://192.168.1.116:6000’ is the receiving server’s IP and port.

To conclude this section we provide the following very nice explanation on SPSP, ILP,
Moneyd by Ben Sharaﬁan on the ILP forum, which we feel helps consolidate and clarify the
larger picture:

In Interledger, the sender and receiver don’t have any settlement relationship nor do they

have any trust relationship.

The only relationship is to your direct peer.

If you’re connecting to Interledger through
Moneyd, we would call this peer your ”upstream connector” or ”uplink”. When you send packets
through your upstream connector, Moneyd keeps track of the amounts and settles them.

24https://github.com/interledgerjs/ilp-spsp-server, accessed June 2019
25https://github.com/interledgerjs/ilp-spsp, accessed June 2019

26

SPSP isn’t doing any of the tracking for settlements, that all lies at the Interledger layer.
This lets you save a lot of headache when implementing high level protocols: settlement is always
abstracted away.

Moneyd does settle on-ledger. The conﬁguration that Moneyd uses to connect to its upstream

connector determines the currency that this happens in. (for XRP, moneyd-uplink-xrp).

The currency that SPSP pays in depends on what currency is used by the Moneyd it connects

to. If you use a Moneyd uplink in XRP, then the currency will be XRP [26].

Example 5. XRP payment using Moneyd, SPSP and a connector.

We consider Figure 16 a good starting example because while involving a relatively simple

structure, it still illustrates the main structural components of the Interledger ecosystem:

• A ledger, i.e. the Ripple ledger

• A connector

• Customers:

– Alice, operating Machine A with Moneyd-XRP and SPSP

– Bob, operating Machine B with Moneyd-XRP and SPSP

• The main protocols: BTP, ILP, STREAM and SPSP.

Fig. 16: Example 5: XRP payment.

Alice, Bob and the Connector are connecting to the ledger over a web socket connection
to settle their obligations and exchange ledger-related data with the ledger. In order to access
ILP, Alice and Bob are also connecting to the Connector through BTP+ws connections. The
Connector works like an ILP and payment bridge between them, and because everything happens
in XRP, the exchange rate applied is 1, and the backend used by the connector is ”one-to-one”.

27

BobMachine Busing Bob’s XRP accountAliceMachine Ausing Alice’s XRP accountXRP ledgerConnectorMachine Crate backend:«one-to-one»SPSPBTP+wsBTP+wsws(s)Further, Alice and Bob can initiate exchanges of value, i.e. XRP payments, in this case by using
SPSP.

The case is detailed in Figure 17, where we can identify:

• The Interledger Service Provider (ILSP) machine, containing:

– The connector, where we can identify:

∗ The connector core
∗ Plugins
∗ The rate backend, set as ”one-to-one”

– Moneyd-GUI

– A web browser connecting locally to Moneyd-GUI as a visual admin interface on

http://127.0.0.1:7770

• The XRP ledger, accessible over a web socket connection, usually at port 51233

• Alice’s machine, comprising:

– Moneyd-XRP:

∗ Moneyd-core
∗ XRP plugin
∗ XRP uplink

– Visual admin interface:
∗ Moneyd-GUI
∗ Web browser

– SPSP client and server

• Bob’s machine, with a similar setup.

Using Moneyd-XRP, Alice ”dials-up” to, and opens a paychan with the Connector, thus en-
abling ILP access on her machine. The connection with the Connector is made over BTP+ws.
Between other functions, BTP acts as a ”carrier” for ILP. The paychan is recorded on the ledger.
Alice is able to administer Moneyd through a web browser, using Moneyd-GUI. The SPSP app
running on her machine will get ILP access through Moneyd. Bob’s situation is similar.

The ledger holds Alice’s, Bob’s and ILSP’s XRP accounts, and the paychans corresponding

to the pairs Alice - ILSP (Connector) and Bob - ILSP (Connector).

When Alice sends a payment addressed to Bob, what happens is that the connector pays
Bob on behalf of Alice (if Bob is able to provide the payment condition), and this transaction is
recorded between the Connector and Bob. Further, the Connector presents to Alice the payment
condition he just got from Bob, and Alice pays the Connector in exchange. This transaction is
also recorded between Alice and the Connector. The value has moved from Alice to Bob, and
in turn, two transactions have been recorded: Alice to Connector, and the Connector to Bob.
Further, it is up to these pairs (Alice-Connector and Connector-Bob) to settle these transactions
according to conditions agreed between each other (using the pay channels).

From a technical point of view, the sequence is illustrated in Figure 18, and follows like

below:

28

Fig. 17: Example 5: XRP payment, advanced.

Fig. 18: Example 5: Protocol sequence. BTP, ILP, STREAM and SPSP are being used.

• Alice and Bod start-up and connect their Moneyd instances to the ILP connector. Each
of them opens dedicated payment channels with the connector. Their transactions will be
performed on the payment channels through Moneyd and ILP.

29

“MoneydXRP”“MoneydXRP”MoneydcoreConnector coreXRP uplinkXRP uplinkXRP pluginXRP pluginAlice: 192.168.1.116Bob: 192.168.1.35XRP pluginJsconnectorILP-plugin-miniaccountsRates backend:one-to-oneAlice <-> connector:  XRP pay channelBTP+ws, port 7442Bob <-> connector:  XRP pay channelBTP+ws, port 7442SPSP serverport 6000SPSP clientMoneydGUIMoneydGUIMoneydcoreSPSP clientSPSP serverport 6000Alice PAYS BobBob PAYS AliceWeb browser localhost:7770Web browser localhost:777077697769ILSPMoneyd-GUIWeb browser localhost:7770ws://192.168.1.98: 51233192.168.1.146XRP ledgerAlice XRP accountBob XRP accountILSP XRP accountAlice –ILSP paychanBob –ILSP paychanPaychanusingBTPVirtual STREAM initiatedbetweenAlice and Bob over ILP, usingILP addressand secretMoneydMoneydSPSPSTREAMmoduleSTREAMmoduleSPSPPaychanusingBTPSPSP server connectsto MoneydAlice’sSPSP client queriesBob’sSPSP server for the ILP addressand a secretAlice’sSPSP client receivesILP addressand secretfromBob’sSPSP serverILP PrepareILP FulfillSTREAM over ILPSTREAM finished.End balance on paychan.ALICEBOBSPSP client appSPSP server appConnectorbtpport7768btpport7768btp7442btp7442SPSP client connectsto MoneydThis is an example of a BTP packet sent between Moneyd and the Connector in order to
open a paychan:

btpPacket: { type: 6,

requestId: 1890145753,
data: { protocolData: [ [Object], [Object], [Object] ] } } ; data: {

protocolData:

[ { protocolName: ’channel’,

contentType: 0,
data:
<Buffer 15 8b 1c 3d a9 97 e5 b6 af 10 2d 90 51 b2 cd 3d 8c 58 96 55 02

ec dc 3a 07 02 f9 2c b7 88 61 1b> },

{ protocolName: ’channel_signature’,

contentType: 0,
data:
<Buffer 62 68 63 4c af b5 72 0f 2f 38 58 4a 81 03 cc 68 5a 62 ef 9a 43

91 80 73 40 31 03 8f 49 f8 f5 ae 88 64 fd 7f 14 39 39 d7 5b c3 a2 17
e1 7f c7 d2 49 a4 ... > },

{ protocolName: ’fund_channel’,

contentType: 1,
data:
<Buffer 72 70 4e 33 55 50 6a 59 61 45 72 74 34 52 57 34 67 41 69 71 75

63 4d 43 66 4c 35 6e 4a 4a 43 34 59 7a> } ] } ;

• Bob starts his SPSP server application, which connects to his local Moneyd instance and

starts listening for incoming connections from an SPSP client.

• Using her SPSP client, Alice queries the HTTP payment pointer presented by Bob.

• Alice receives an ILP address to use as destination account for the transaction and a shared

secret.

• Using this information, Alice pays Bob by starting a STREAM payment over ILP. The
ILP service is provided by Moneyd. The shared secret is used by STREAM to authenticate
and encrypt multiple packets, as well as to generate the conditions and fulﬁllments.

• STREAM divides the larger payments into packets and reassembles them. The packets
are encapsulated inside, and sent along with, ILP packets in the data ﬁeld, and will be
retrieved by the STREAM endpoint. During the STREAM connection, one of the parties
acts as a client (the initiator) and the other acts as a server (the one accepting the con-
nection). As STREAM is implemented by the SPSP application, the STREAM server will
be already listening for a STREAM client connection.

Below is an example of a STREAM prepare packet carried by an ILP packet sent over
BTP:

ILP-PLUGIN-BTP: handleIncomigWsMessage: binaryMessage:
<Buffer 06 1f 9d 97 68 81 e9 01 01 03 69 6c 70 00 81 e0 0c 81 dd 00 00 00 00 95

02 f9 00 32 30 31 39 30 36 31 39 30 39 34 33 30 31 35 30 39 45 04 2b e1 cd
98 ... >

ILP-PLUGIN-BTP: handle incoming packet from: ; btpPacket: { type: 6,
requestId: 530421608,

30

data: { protocolData: [ [Object] ] } } ; data: { protocolData:

[ { protocolName: ’ilp’,
contentType: 0,
data:
<Buffer 0c 81 dd 00 00 00 00 95 02 f9 00 32 30 31 39 30 36 31 39 30 39

34 33 30 31 35 30 39 45 04 2b e1 cd 98 68 71 95 50 c5 de 4a f2 1c f1
eb 4e 79 6e 95 cb ... > } ] } ;

ilp-plugin-xrp-paychan: received btp packet. type=TYPE_MESSAGE

requestId=530421608 info=ilp-prepare

ILP_PACKET: binary: <Buffer 0c 81 dd 00 00 00 00 95 02 f9 00 32 30 31 39 30 36
31 39 30 39 34 33 30 31 35 30 39 45 04 2b e1 cd 98 68 71 95 50 c5 de 4a f2
1c f1 eb 4e 79 6e 95 cb ... >

ILP_PACKET: type: 12
ILP_PACKET: contents: <Buffer 00 00 00 00 95 02 f9 00 32 30 31 39 30 36 31 39 30
39 34 33 30 31 35 30 39 45 04 2b e1 cd 98 68 71 95 50 c5 de 4a f2 1c f1 eb
4e 79 6e 95 cb d8 f6 5a ... >

ILP_PACKET: deserializeIlpPrepare:
{
amount= 2500000000 ,
executionCondition= RQQr4c2YaHGVUMXeSvIc8etOeW6Vy9j2WlDZYKIZUbM= ,
expiresAt= 2019-06-19T09:43:01.509Z ,
destination= g.conn1.ilsp_clients.mduni.local.NL8f2khL-VmasfzfA-

w_ds5F15J063Tn4oxDwoXTjGw.gHvuhB1r5GN0UQikoCGahPsj ,

data= YFwVZXQYK7pDTrprLcFOYbyt9qGQm+0APnOaBw5w5iUvvEggyB4Le0J8Bjbav7FKGyJ6Ih95xT8

lss4BCQ==

}

The ﬁrst byte ”06” of the BTP packet is the BTP packet type, 6 in this case.
The next 4 bytes ”1f 9d 97 68”, are the request id in hex - 530421608 in this case.
We can also infer from the ILP-packet header that ”0c” is the packet type - 12 in this case,
and from the body, that ”95 02 f9 00” represents the amount = 2500000000.
This conﬁrms the packet type as STREAM, because it is type 12 [14, 22].

Below is a second example of a BTP packet carrying a STREAM fulﬁll:

{ type: 1,

requestId: 1054375881,
data: { protocolData: [ [Object] ] } } ; data: { protocolData:
[ { protocolName: ’ilp’,
contentType: 0,
data:
<Buffer 0d 5e 78 d3 d3 3e 33 27 b9 44 a1 45 92 f8 d8 98 28 8c 96 e2 20

00 af 8f bd eb 0d a3 24 04 79 0f 9b 75 3d 12 ef 89 a6 79 c1 a5 cc 53
ef c6 0f c1 60 8a ... > } ] } ;

The ﬁrst byte ”0d” is the packet type - 13, meaning fulﬁll. The packet structure is like
below:

{
type: 13,

typeString: ’ilp_fulfill’,
data:
{ fulfillment:

<Buffer 78 d3 d3 3e 33 27 b9 44 a1 45 92 f8 d8 98 28 8c 96 e2 20 00 af 8f

31

bd eb 0d a3 24 04 79 0f 9b 75>,

data:
<Buffer 12 ef 89 a6 79 c1 a5 cc 53 ef c6 0f c1 60 8a 71 38 b5 72 70 a8 f7

54 16 1c 30 65 f5 f1 9e fd 8f ee a6 d0 63 85 36 49 fd ab 5e 18 a6 d9
40 04 d4 5a 61 ... > }

}

• when the transfer is ﬁnished, the STREAM connection is closed.

• at this moment the balances are updated on the payment channels opened between the
parties involved, accordingly. The value can be redeemed out of each payment channel by
each participant.

• after claiming the funds, the payment channel can be either closed or used for other

transactions.

The Interledger balance between Alice and Bob is continuously updated. If for some reason
the STREAM connection is interrupted before the total amount is transferred, the amounts
already transferred are not lost.

”Once peered, the two connectors both track the Interledger account balance and adjust it for

every ILP Packet successfully routed between them.” [5]

Regarding the setup and conﬁguration, for this example, we are going to consider the XRP

Ledger and the connector black boxes, and provide instructions for Moneyd and SPSP.

• On both Alice’s and Bob’s machines:

– If not already installed, install node.js

– Install Moneyd, Moneyd-GUI, SPSP server and SPSP client apps:

∗ ”npm install -g moneyd moneyd-uplink-xrp”
∗ ”npm install -g moneyd-gui”
∗ ”npm install -g ilp-spsp-server ilp-spsp”

– Conﬁgure Moneyd:

∗ ”moneyd xrp:conﬁgure –advanced”

There will be four questions:

· ? BTP host of parent connector:

We are going to use the IP:port(7442) of the connector.

· ? Name to assign to this channel:

Can keep the autogenerated proposal or enter custom name.

· ? XRP secret:

Alice’s/Bob’s XRP account secret: ”sXXXXXXXXXXXXXXXXXXXXXXXX”

· ? Rippled server:

The IP:port of the local Ripple server (ws://192.168.1.98:51235) or for ex-
ample, ”wss://s1.ripple.com”.

– Start Moneyd, Moneyd-GUI and the browser interface:

∗ Start Moneyd:

”DEBUG=* moneyd xrp:start –admin-api-port 7769”

32

∗ Start Moneyd-GUI by issuing:

”npm start” in /home/user/moneyd-gui

∗ Start a web browser and go to:

http://127.0.0.1:7770
In order for all Moneyd-GUI’s graphical interface elements to load, you should
also have internet access.

• On Bob’s machine, start the SPSP server:

DEBUG=* ilp-spsp-server –localtunnel false –port 6000

• From Alice’s machine initiate the SPSP transfer:

DEBUG=ilp* ilp-spsp send –receiver http://192.168.1.116:6000 –amount 100
Obviously, the above IP is just an example and you should use here Bob’s machine’s IP,
according to your network setup.

Additional information and useful commands for Moneyd can be found on Moneyd’s github

page. We provide the Table 3 below, for general reference.

Table 3: Useful Moneyd commands.

command
moneyd xrp:conﬁgure –advanced
moneyd xrp:start –admin-api-port 7769
moneyd start –unsafe-allow-extensions
moneyd xrp:info
moneyd xrp:cleanup
moneyd help
moneyd help <command>

eﬀect
conﬁgure Moneyd in advanced mode
enable the admin api port for Moneyd-GUI use
allow web browser payments
XRP account balance and outstanding paychans
close paychans (get the money back from paychans)
list of Moneyd ﬂags
info on a speciﬁc command

For reference, we also provide an example of a Moneyd-XRP conﬁguration ﬁle, .moneyd.json:

{

"version": 1,
"uplinks": {
"xrp": {

"relation": "parent",
"plugin":

"/home/user/.nvm/versions/node/v10.15.3/lib/node_modules/moneyd-uplink-xrp

/node_modules/ilp-plugin-xrp-asym-client/index.js",

"assetCode": "XRP",
"assetScale": 9,
"balance": {

"minimum": "-Infinity",
"maximum": "20000000000",
"settleThreshold": "50000000",
"settleTo": "1000000"

},
"sendRoutes": false,
"receiveRoutes": false,
"options": {

"currencyScale": 6,

33

"server":

"btp+ws://mduni:85941fd308ac69bfe7a4f6b9726430ea9ee6e6e654bb19b40a419c7a029b6fa7
@192.168.1.146:7443",

"secret": "ssVe1jBi2SUU5HQX6YPoTpRdRDG69",
"address": "rpN3UPjYaErt4RW4gAiqucMCfL5nJJC4Yz",
"xrpServer": "ws://192.168.1.98:51233"

}

}

}

}

Example 6. XRP-ETH ILP payment using Moneyd, SPSP and a connector

We will discuss the conﬁguration presented in Figure 19. It is comprised of:
• The XRP ledger, or the XRP network, made up of servers running the ”Rippled” software.
Mainly, the ledger holds the account balances for all users and validates the transactions
performed in-between users.

• The ETH ledger, with a similar function.

• Alice, holding an account on the XRP ledger, operating Machine A, and running a user-

level ILP XRP app, in this case Moneyd-XRP and SPSP.

• Bob, holding an account on the ETH ledger, operating Machine B, and running a user-level

ILP Ethereum app, in this case Moneyd-ETH and SPSP.

• A Connector, having 2 accounts - one on each ledger. The connector will act as a facilitator
- an intermediary between the two users. It will accept XRP from Alice and will forward
the corresponding value, denominated in ETH, applying its exchange rate, to Bob.

Fig. 19: Example 6: Interledger payment.

A more advanced representation of the same setup is provided in Figure 20 and explained
below. In order to be able to settle the payments in ETH, Machinomy smart contract has to be
deployed on the ETH ledger.

34

BobMachine BETH walletAliceMachine AXRP walletXRP ledgerPaychan-enabledETH ledgerconnector’s XRP walletconnector’s ETH walletConnectorMachine CExchangeSTREAM connectionusingSPSPBTP + ws(s) connectionws(s)ws(s)BTP + ws(s) connectionws(s)ws(s)Fetchfromwww :“ecb” plus “coinmarketcap”Fig. 20: Example 6: Interledger payment, advanced.

• Alice negotiates and opens a paychan denominated in XRP with the connector

• Bob negotiates and opens a paychan denominated in ETH with the connector

• Alice and Bob’s machines comprise the following:

– Moneyd-XRP (Alice) or ETH (Bob), comprising of:

∗ Moneyd-core
∗ XRP/ETH plugin, providing the settlement means
∗ XRP/ETH uplink, providing the uplink to the connector

– Moneyd-GUI, providing a visual admin interface

– SPSP modules:

∗ SPSP server: listens for connections from SPSP clients and receives payments
∗ SPSP client: connects to SPSP servers and sends payments

• The connector, comprising of:

– Connector core

– Diﬀerent plugins:
∗ XRP plugin
∗ ETH plugin
∗ Possibly, ”ilp-plugin-mini-accounts” - to make use of Moneyd-GUI as a visual

admin interface

∗ Possibly other plugins

35

“MoneydXRP”“MoneydETH”MoneydcoreConnector coreXRP uplinkETH uplinkXRP pluginETH pluginAlice: 192.168.1.116Bob: 192.168.1.35XRP pluginETH pluginRates backend«ecb-plus-coinmarketcap»Alice <-> connector  XRP pay channelbtp+ws, port 7442Bob <-> connector  ETH pay channelbtp+ws, port 7442SPSP serverport 6000SPSP clientMoneydGUIMoneydGUIMoneydcoreSPSP clientSPSP serverport 6000Alice PAYS BobBob PAYS AliceWeb browser localhost:7770Web browser localhost:777077697769ws://192.168.1.98: 51233XRP ledgerAlice XRP accountILSP XRP accountAlice –ILSP paychanMachinomyBob –ILSP 2 paychan192.168.1.87:8545ETH ledgerPoA/ GanacheMachinomycontract accountILSP 2 ETH accountBob’s ETH accountJsconnector 2 Ilp-plugin-miniaccountsILSP 2Moneyd-GUIWeb browserLocalhost:7770192.168.1.131Internet:Fetch conversion rate– The rates backend, which fetches the exchange rates from the internet. We will be
using ”ecb-plus-coinmarketcap”. Other possibilities are: ecb, ecb-plus-xrp, , one-
to-one. ”One-to-one” applies an exchange rate of 1 to everything and is used by
connectors operating in a single currency environment.

Fig. 21: Perspective: connections. [20]

Into perspective, the situation can be represented as in Figure 21, where:

• Sender and Receiver are Alice and Bob

• Node B, Node C are Moneyd

• Node A is the connector

• Application is the SPSP client

• Ledger A and B are the XRP and ETH ledgers

• Moneyd connects to the connector over BTP (A) and also has a ledger speciﬁc connection

(B) for settlement.

The protocol interactions are the same as in Example 1, and also Alice’s machine is the same
as in Example 1. The main diﬀerences are that on the ETH ledger, for settlement, Machinomy
smart contract must be deployed, and that the paychan between Bob and the ILSP (Connector)
is recorded there instead of the XRP ledger. As such, on the XRP ledger we ﬁnd:

• Alice’s XRP account

• ILSP (the connector) XRP account

• Alice - ILSP paychan,

while on the ETH side:

• Bob’s ETH account

• ILSP (connector) ETH account

• Bob - ILSP paychan

• The Machinomy smart contract account, deployed in order to help manage the paychans

and settlements on Ethereum.

36

Receiver Sender Node A Ledger A Node C Ledger B (15) SPSP Server Node B Application (C) SPSP over HTTPS (B) Ledger specific connection (A) BTP over WebSocket An advanced diagram of connections and protocols interactions is provided by Ripple in [21].
The explanations are extensive and beyond the scope of this paper, but they can be retrieved
by the interested readers by following the link to the reference.

For orientation, we provide as example a Moneyd-ETH conﬁguration ﬁle:

{

"version": 1,
"uplinks": {
"eth": {

"relation": "parent",
"plugin": "/home/user/node_modules/ilp-plugin-ethereum/index.js",
"assetCode": "ETH",
"assetScale": 9,
"sendRoutes": false,
"receiveRoutes": false,
"options": {

"role": "client",
"ethereumPrivateKey":

"0x72f3b5a36a6719492913f6480b8b5036bf5cc5f312152351886c8e216fc63288",

"ethereumProvider": "kovan",
"outgoingChannelAmount": "50000000",
"balance": {

"maximum": "1000000",
"settleTo": "0",
"settleThreshold": "300000"

},
"server":

"btp+ws://ASDG:294a4788a4b0a7a048332c7d2390e6ce06bcd63e59585493f50e8738650

a948a@192.168.1.131:7442"

}

}

}

}

5.0.2 @Kava-Labs: Switch API

Switch API26 has been built mostly for cryptocurrencies trading like from XRP to ETH or
Lightning. This means that the accounts involved in the currency swap belong to the same
It ’streams money’, meaning that for example, a 20 units transfer would be split into
user.
small chunks and each of these chunks would be separately sent on the paychan until the whole
amount is sent [27, 28].

Switch API handles multiple uplinks, with dedicated plugins for each currency - XRP, ETH
and Lightning. We investigated XRP and ETH. For communicating with the XRP connector we
set up a dedicated XRP plugin27, while for the Ethereum uplink we use a dedicated Ethereum
plugin28.

To handle the ETH settlement, Machinomy contracts have to be deployed on the ETH
network, as explained in Section 7.2. We have tested a stream payment between XRP and ETH

26https://github.com/Kava-Labs/ilp-sdk/blob/master/README.md, accessed June 2019
27https://github.com/Kava-Labs/ilp-plugin-xrp-paychan, accessed June 2019
28https://github.com/interledgerjs/ilp-plugin-ethereum, accessed June 2019

37

using Ganache29 as ETH provider.

Some particular aspects of running Switch API - as of May 2019:

• The modules ”ethers” and ”ilp-plugin-ethereum” must be updated to the last version on

the connector machine and Switch API machine.

• When setting up Switch API the credentials must be lowercase.

• After each run, it creates a conﬁg ﬁle in /home/user/.switch/conﬁg. If run with the same
credentials (for tests), this ﬁle must be manually deleted or would output the warning
”can not create duplicate uplink”.

• When using a private ETH network, Ganache included, the network ID and the Machinomy
contract address should be set. We have used the Kovan network ID, 42, which we have
set in Ganache, while in the following ﬁles, we have changed the address to the Machinomy
contract address deployed on the ETH network (Ganache):

– ’/home/user/node modules/ilp-plugin-ethereum/build/utils/channel.js’ on the refer-
ence node.js connector handling the ETH uplink - the ILSP 2 connector in
Figure 27, AND

– in the same ﬁle on the machine running the Switch API app

42: {

unidirectional: {

abi: Unidirectional_testnet_json_1.default,
address: ’0xa711d0a8b93faacd0f0f1897c11a1d7286d29720’

}

}

The Machinomy contract address is the ”Unidirectional contract” address deployed
by Machinomy.

• Settings regarding settlement, on the machine running Switch API, when running

Switch API on private XRP and ETH networks:

– File: ’switch-api/build/settlement/machinomy.js’ :

remoteConnectors: {

local: {

’Kava Labs’: (token) =>

‘btp+ws://:${token}@192.168.1.131:7442‘ // Reference ETH
connector IP:port. ILSP 2 in Figure 26.

},
testnet: {

’Kava Labs’: (token) =>

‘btp+ws://:${token}@192.168.1.131:7442‘ // Reference ETH
connector IP:port. ILSP 2 in Figure 26.

},
mainnet: {

29https://truﬄeframework.com/ganache, accessed June 2019

38

’Kava Labs’: (token) =>

‘btp+ws://:${token}@192.168.1.131:7442‘

}

}

– File: ’switch-api/build/settlement/xrp-paychan.js’ :

const getXrpServerWebsocketUri = (ledgerEnv) => ledgerEnv === ’mainnet’

? ’ws://192.168.1.98:51233’ // XRP validator IP
: ’ws://192.168.1.98:51233’; // XRP validator IP

. . . . .. . . . .. . . .. . . .. . . .. . . .
remoteConnectors: {

//XRP parent connector

local: {

’Kava Labs’: (token) =>

‘btp+ws://:${token}@192.168.1.146:7444‘ //
XRP referenceConnector - ILSP 1 in Figure 26.

},
testnet: {

’Kava Labs’: (token) =>

‘btp+ws://:${token}@192.168.1.146:7444‘ //
XRP referenceConnector - ILSP 1 in Figure 26.

},
mainnet: {

’Kava Labs’: (token) =>

‘btp+ws://:${token}@192.168.1.146:7444‘ //
XRP referenceConnector - ILSP 1 in Figure 26.

}

}[ledgerEnv],

• Additional settings on the machine running Switch API. The ”Ethers” module pro-

vides support for setting up diﬀerent providers 30.

– ﬁle: /home/user/node modules/ethers/utils/networks.js:

kovan: {

chainId: 42,
name: ’kovan’,
_defaultProvider:

etcDefaultProvider(’http://192.168.1.87:8545’) // set ETH
provider IP and port (Ganache)

}

– in ﬁle /home/user/node modules/ethers/ethers.js, set network to kovan:

function getDefaultProvider(network) {

console.log(’ETHERS.js get default provider (network): network:’,

network);

if (network == null) {

network = ’kovan’; //set kovan

30https://docs.ethers.io/ethers.js/html/api-providers.html, accessed June 2019

39

}

– in ﬁle /home/user/node modules/ilp-plugin-ethereum/build/index.js, set provider to

kovan:

class EthereumPlugin extends eventemitter2_1.EventEmitter2 {

constructor({ role = ’client’, ethereumPrivateKey, ethereumProvider =

’kovan’, getGasPrice, outgoingChanne

• Additional setting on the machine running the connector providing the ETH link:

– in ﬁle /home/user/node modules/ethers/utils/networks.js:

kovan: {

chainId: 42,
name: ’kovan’, _defaultProvider:

etcDefaultProvider(’http://192.168.1.87:8545’) //ETH provider
IP:port (Ganache)

}

• Example script which can be used for streaming XRP-ETH using Switch API [27]:

const { connect } = require(’@kava-labs/switch-api’)
const BigNumber = require(’bignumber.js’)

async function run() {
// Connect the API
console.log(’*** example-js ***: adding API’)
const api = await connect()

//Add new uplink with an account

console.log(’**** example-js ****: addING uplink machinomy’)

const ethUplink = await api.add({
settlerType: ’machinomy’,
privateKey:

’6da09c0a78255932210aaf5b9f61046a00e9e3ab389c7357e388c4b35682342e’

}) //switch Api wallet ETH

console.log(’*** example-js ***: addED uplink eth’)

// Add new uplink with an XRP testnet credential

console.log(’*** example-js ***: addING uplink XRP’)

const xrpUplink = await api.add({
settlerType: ’xrp-paychan’,
secret: ’sasa3hrRUndoxAMoXEc3MMyZHNL3W’ //switch API wallet XRP
})

console.log(’*** example-js ***: addED uplink XRP’)

// Display the amount in client custody, in real-time
xrpUplink.balance$.subscribe(amount => {

console.log(’XRP Interledger balance:’, amount.toString())

})
ethUplink.balance$.subscribe(amount => {

console.log(’ETH Interledger balance:’, amount.toString())

40

})

// Deposit 20 XRP into a payment channel
console.log(’EXAMPLE.js: start depositing 20XRP’)
await api.deposit({
uplink: xrpUplink,
amount: new BigNumber(20)

})
console.log(’EXAMPLE.js: depositED 20xrp’)

// Deposit 0.05 ETH into a payment channel
console.log(’EXAMPLE.js: start depositing 0.05ETH’)
await api.deposit({
uplink: ethUplink,
amount: new BigNumber(0.05)

})
console.log(’EXAMPLE.js: depositED 0.05ETH’)

// Stream 10 XRP to ETH, prefunding only $0.05 at a time
// If the connector cheats or the exchange rate is too low, your funds are

safe!

await api.streamMoney({

amount: new BigNumber(10),
source: xrpUplink,
dest: ethUplink

})

await api.disconnect()

}

run().catch(err => console.error(err))

This ﬁle can be placed in Switch API home directory and run with:

DEBUG=* node –inspect ./ﬁle-name.js

On top of this, Kava Labs has built an app for swapping the BTC, ETH and XRP cryp-

tocurrencies just in a matter of seconds31.

6 The connectors

Connectors are transaction ’intermediaries’ lying in-between the payer and the payee, connecting
them and facilitating the transaction. They are the ’market makers’ or ’liquidity providers’, and
their role is especially evident when the sender’s and receiver’s wallets hold diﬀerent currencies,
as depicted in Figure 22. A connector would take the sender’s money in the sender’s currency
and pay the receiver with the receiver’s currency while charging a small fee for the service. In
order to be able to do this, a connector owns two wallets, one on each currency involved in the
transaction.

’A connector is a host holding a balance on two or more ledgers. Connectors trade a debit
against their balance on one ledger for a credit against their balance on another as a means of

31https://github.com/Kava-Labs/switch, accessed June 2019

41

Fig. 22: A connector (money maker) holding two wallets on two diﬀerent networks.

facilitating the payment between the two ledgers.’ [29]

While providing their services, the connectors act as an internet service provider would. In
Interledger, the entities running the connectors are known as Interledger Service Providers or
ILSPs. For example, the ILP reference connector written in js32 can be run by an ILSP. An
ILSP can run one or more connectors. Moneyd is a stripped version of a connector which is
not sending or receiving routes, and is used as a ”home router”, by end-users or customers in
order to dial-up and connect to the ILSPs running a connector. As such, Moneyd33 or Switch
API34 are examples of ’customer’ apps connecting to their preferred ILSP and sending requests,
as shown in Figure 27.

’Connectors implement the Interledger protocol to forward payments between ledgers and
relay errors back along the path. Connectors implement (or include a module that implements)
the ledger protocol of the ledgers on which they hold accounts. Connectors also implement the
Connector to Connector Protocol (CCP) to coordinate routing and other Interledger control
information.’ [25]

Currently, the connectors rely on plugins to settle the transactions (new architectures are

currently being considered or implemented, e.g. the Raﬁki connector).

Making the analogy to a real-life example, swiping a credit card at a cashier’s desk is con-
sidered a payment. The settlement occurs when the money is debited from the card holder’s
bank and credited to the merchant’s bank. When you swipe the credit card and introduce your
PIN you create and sign an irrevocable obligation for payment. On an Interledger paychan, this
signed obligation for payment is known as a ”claim”. A redeemed claim would translate to a
bank transaction which has been ”cleared” or ”went through” (the money completely left the
payer’s bank account, and are visible and available in the payee’s account; or analogously, the
money completely left the sender’s wallet/ledger and have shown up on the receiver’s wallet,
ledger and currency).

Concerning the plugins, they are installed on the same machine with the connector and con-

32https://github.com/interledgerjs/ilp-connector, accessed June 2019
33https://github.com/interledgerjs/moneyd, accessed June 2019
34https://github.com/Kava-Labs/ilp-sdk/blob/master/README.md, accessed June 2019

42

ﬁgured according to purpose. This architecture is illustrated in Figure 23.

Fig. 23: Architecture overview. [30]

Some plugin examples would be:

• ilp-plugin-xrp-paychan35 creates a direct peer relation with other connectors.

It is an
Unconditional Payment Channel plugin, where one has to trust his peer for the in-ﬂight XRP
amounts.

• ilp-plugin-xrp-asym server36 enables the ILSP server to accept new client connections and
creates an internal ILP account for each of them. It is the plugin appropriate for provider -
customer relationships. This service will be exposed publicly and ’customers’ will connect to
it.

• ilp-plugin-xrp-asym-client37 will be used by a ’customer’ to connect to his provider’s plu-

gin, i.e the ilp-plugin-xrp-asym-server above.

• moneyd’s uplink-xrp plugin38 makes use of ilp-plugin-xrp-asym-client.
• ilp-plugin-mini-accounts39 can be used to connect Moneyd-GUI to Moneyd or to the ref-

erence ILSP connector, for example.

• Kava Labs has been involved in the development of @kava-labs/ilp-plugin-xrp-paychan40
and ilp-plugin-ethereum41. Both can be used in conjunction with Switch API. Ilp-plugin-
ethereum settles Interledger payments with ether and is powered by Machinomy smart con-
tracts for unidirectional payment channel.

Another way to illustrate a payment chain forwarding the payment through the connectors
with the use of SPSP, the ILP protocol, some of the plugins above and the servers from Section
7.1 which form the XRP ledger for example, is provided in Figure 24, with some other ledger
examples being the ETH or Lightning server networks. It is worth being noted that PSK was
upgraded to STREAM. As such, the sender can pay in XRP and the receiver can get his money
in BTC.

35https://github.com/interledgerjs/ilp-plugin-xrp-paychan, accessed June 2019
36https://github.com/interledgerjs/ilp-plugin-xrp-asym-server, accessed June 2019
37https://github.com/interledgerjs/ilp-plugin-xrp-asym-client/, accessed June 2019
38https://github.com/interledgerjs/moneyd-uplink-xrp, accessed June 2019
39https://github.com/interledgerjs/ilp-plugin-mini-accounts, accessed June 2019
40https://github.com/Kava-Labs/ilp-plugin-xrp-paychan, accessed June 2019
41https://github.com/interledgerjs/ilp-plugin-ethereum, accessed June 2019

43

Fig. 24: The protocol stack in the payment chain.

Below we reproduce a nice explanation on payment channels that we found worth adding:
’In order to avoid having to go through the consensus process for each and every transaction,
only the summary of several transactions is validated on the blockchain. The intermediate trans-
actions are conducted outside of the Ripple Ledger, oﬀ-chain. Ripple Labs has said that with
Payment Channels (introduced in summer 2017), several thousand transactions per second can
be processed. This number is approaching the transaction capacity of the VISA network. Because
of the increased eﬃciency, Payment Channels are a feasible micro-payment alternative.’ [31]

Also, payment channels are worth being used with expensive or slow ledgers. The two par-
ties’ transactions are being performed on the paychan under the limits established. Sometimes
they oﬀset each other. When the conditions for settlement are met, the settlement can occur.
This lowers the cost and time involved by the overall process.

Example 7. An advanced XRP-ETH setup using two connectors

Alice, having an XRP account, connects to the ILSP 1 connector and establishes a paychan
using the XRP plugin and uplink. Bob, having an Ethereum account, connects to the ILSP
2 Ethreum enabled connector using an Ethereum plugin and uplink. The two connectors are
peered over XRP and establish a paychan with the ilp-plugin-xrp-paychan. When Alice sends
money to Bob, the payment goes through ILSP 1 and ILSP 2. Alice will settle her balance with
ILSP 1; ILSP 1 will settle its balance with ILSP 2, and ILSP 2 will settle with Bob.

Because ILSP 1 works exclusively in XRP, its exchange rate will always be 1, so the backend
used will be ”one-to-one”. On the other hand, ILSP 2 works on two ledgers and performs ”the
currency exchange” so the backend will make use of the ”ecb-plus-coinmarketcap” option, and
the rate will be fetched from the internet.

On the XRP ledger we ﬁnd Alice’s, ILSP 1 and ILSP 2’s accounts, together with the XRP
paychans established between the pairs Alice - ILSP1 and ILSP1 - ILSP2. Accordingly, on the
ETH network we ﬁnd ILSP2’s and Bob’s accounts along with the paychan Bob - ILSP2.

For this conﬁguration, we will assume the ledgers are already up and running on the same
Local Area Network hardwired or Wi-Fi. Also, internet access is available. Then, the deployment
sequence is:

• Start the connectors, one by one, and wait for them to establish a payment channel between

44

Fig. 25: Example 7: advanced Interledger payment.

them. This will be shown in the connector logs. If using pm2, logs can be enabled with
”pm2 logs connector”.

• Start the Moneyd instances for Alice and Bob and wait for each to establish paychans with

the corresponding connector.

• Start Bob’s SPSP server.

• From Alice’s terminal, use the SPSP client to initiate an SPSP transaction.

• Optionally, Moneyd-GUI and a web browser can be used to administer Moneyd and the

connectors.

The diagram presented in Figure 26 further illustrates how the nodes and protocols interact.

Fig. 26: Example 7: interaction diagram.

45

“MoneydXRP”“MoneydETH”MoneydcoreConnector coreXRP uplinkETH uplinkXRP pluginETH pluginAlice: 192.168.1.116Bob: 192.168.1.35ILP-plugin-xrp-paychanETH pluginJsconnector 2 Ilp-plugin-miniaccountsRates backend«ecb-plus-coinmarketcap»Internet:Fetch conversion rateAlice <-> connector:  XRP pay channelBTP+ws, port 7442Bob <-> connector:  ETH pay channelBtp+ ws, port 7442SPSP serverport 6000SPSP clientMoneydGUIMoneydGUIMoneydcoreSPSP clientSPSP serverport 6000Alice PAYS BobBob PAYS AliceWeb browser localhost:7770Web browser localhost:777077697769Connector coreXRP pluginILSP 1Ilp-plugin-miniaccountsRates backend«one-to-one»Jsconnector 1 ILSP 2Moneyd-GUIMoneyd-GUIWeb browserLocalhost:7770Web browserLocalhost:7770ILP-plugin-xrp-paychanpeerBtp+ wsXRP ledgerAlice –ILSP 1 paychanILSP 1 –ILSP 2 paychanMachinomyBob –ILSP 2 paychan192.168.1.87Alice’s XRP accountILSP 1 XRP accountILSP 2XRP accountETH ledgerPoA/ Ganacheport 8545Machinomysmart contract accountILSP 2 ETH accountBob’s ETH accountws://192.168.1.98:51233192.168.1.146192.168.1.131PaychanusingBTPSPSP server connectsto MoneydPaychanusingBTPPaychanusingBTPbtp7442Virtual STREAM initiatedbetweenAlice and Bob over ILP, usingILP addressand secretMoneydMoneydSPSPSTREAMmoduleSTREAMmoduleSPSPAlice’sSPSP client queriesBob’sSPSP server for the ILP addressand a secretAlice’sSPSP client receivesILP addressand secretfromBob’sSPSP serverILP PrepareILP FulfillSTREAM over ILPSTREAM finished. End balance on paychan.ALICEBOBSPSP client appSPSP server appConnectorbtpport7768btpport7768btp7442SPSP client connectsto MoneydConnectorbtppeering10666The setup for Alice and Bob’s machines is similar to Examples 1 and 2.
In regards to installation and set-up of connectors, a new guide42,43 from Strata Labs has just

been released, so you can try the bundle they propose if you want to hit the ground running.

The tutorial44 provided by Adrian Hope-Bailie is a very good and thorough step-by-step
guide. Inspired from his guide on installing the reference connector, a faster and easier minimal
set-up and a few tips are provided below. This procedure will miss some features in the original
guide. For the advanced set-up, the original post can be followed. For convenience, the Step #
has been kept the same as in the original tutorial.

• Step 5: install node

- curl -o-

https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash

- Restart terminal
- nvm install v10.15.3

• Step 7: install ”redis”45

• Step 8: install pm2

• Step 10: get and fund an XRP Ledger address. Alternative to ’ripple-wallet-cli’, it is also

possible to generate a wallet directly, using the ’wallet propose’ method:
’user@saintmalo: /rippled/ccabuild$ ./rippled –conf /home/user/rippled/cfg/rippled-example.cfg
wallet propose’.

• Step 12: pick an ILP Address. The format should be ’g.somethingunique’. For an inde-
pendent private network, we also used the ’production’ settings and ’g’ as address preﬁx.
Any of the others (private, local, ..) did not seem to work right.

• Step 13: create your conﬁg ﬁle using ’pm2 init’. A ﬁle named ’ecosystem.conﬁg.js’ will be
created, possibly in the folder ’home/user’. Check it, update as needed, and move it to
’/home/user/ilp-connector/’.

• Step 14: start it with:

’cd /home/user/ilp-connector: $ pm2 start ecosystem.conﬁg.js’
Use ’pm2 stop ecosystem.conﬁg.js’ to stop it, ’pm2 restart ecosystem.conﬁg.js –update-
env’ for restart, and ’pm2 logs connector’ to see the logs. The log ﬁles are located in
’/home/user/.pm2/logs/connector-out.log’.

How to setup a connector:
First of all the following example is deployed in Ubuntu bionic (kernel 4.15 but not important).

sudo apt-cache madison npm - at the time of writing 3.5.2.
sudo apt-cache madison nodejs - at the time of writing version 8.10.
sudo apt-get install nodejs npm build-essential

42https://www.stratalabs.io/mainnet, accessed June 2019
43https://github.com/d1no007/easy-connector-bundle, accessed June 2019
44https://medium.com/interledger-blog/running-your-own-ilp-connector-c296a6dcf39a, accessed June 2019
45https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04,

ac-

cessed June 2019

46

npm conﬁg get preﬁx This will return the path for packages installed with -g. In our case,

we will install the packages locally in the folder jsilp.

npm install memdown. We will use memdown for this example but for production, you

should use another type of databases.

pm2 restart launch.conﬁg.js

The connector will be much easier to admin and understand using an interface, at this
moment Moneyd-GUI. Installed on the same machine as the connector, it will provide UI access
in a browser at http://127.0.0.1/7770. For the graphical interface, Moneyd-GUI loads some
resources from online.

Below we provide an example conﬁguration for the ILSP1 Connector from Figure 27. For

our use-case we used ws, but in a real scenario wss is used.

’use strict’
const path = require(’path’)

const address = ’rMqUT7uGs6Sz1m9vFr7o85XJ3WDAvgzWmj’ // <YOUR RIPPLE ADDRESS>
const secret = ’shjZQ2E3mYzxHf1VzYBJCQHqLvt7Y’ // <YOUR RIPPLE SECRET>

const peer1 = {

relation: ’peer’,
plugin: ’ilp-plugin-xrp-paychan’, //peer with another ILSP connector over XRP
assetCode: ’XRP’,
assetScale: 9,

//"Interledger amounts are integers, but most currencies are

// establish a ’peer’ relationship.

typically represented as fractional units, e.g. cents. This property defines
how many Interledger units make up one regular units. For dollars, this would
usually be set to 9, so that Interledger amounts are expressed in nanodollars."

balance: {

maximum: ’1000000000’,
settleThreshold: ’-5000000000’,
settleTo: ’0’

},
options: {

listener: { //If you want your peer to connect to you as a ws client (which

doesn’t change the nature of the liquidity relationship) set the
‘listener‘ argument in the constructor.

port: 10666, //this ws server listens for ws clients on port 10666
secret: ’2afe5e6cece84ed0027f9a2463edfa6358901bd6f1c9f3e1b0e43c13ff1ae2eb’ //

this is the token that your peer must authenticate with.

},
//server: ’btp+ws://:its_a_secret@192.168.1.146:10666’, //this connector would

be a ws client connecting to its peer ws server at port 10666

//It should be possible to use it without credentials like this, also: server:

’btp+ws://:@192.168.1.146:10666’

// You may specify both the server and client options; in that case it is not

deterministic which peer will end up as the ws client.

rippledServer: ’ws://192.168.1.98:51233’,

//the server that you submit

XRP transactions to //MAINNET - wss://s2.ripple.com

peerAddress: ’rLR52VSZG3wqSrkcpfkSnaKnYoYyPoJJgy’, //<PEER RIPPLE ADDRESS>
address,
secret

}

}

47

const ilspServer = {

relation: ’child’,
plugin: ’ilp-plugin-xrp-asym-server’,

to downstream clients

//MoneyD XRP clients
//Moneyd apps will be ’children’
//plugin that exposes the ILSP server

assetCode: ’XRP’,
assetScale: 6,
options: {

port: 7443,
apps

xrpServer: ’ws://192.168.1.98:51233’,
address,
secret

}

}

const SwitchAPIServer = {

//port on which to listen to client

//MAINNET - wss://s2.ripple.com

relation: ’child’,
plugin: ’@kava-labs/ilp-plugin-xrp-paychan’,
assetCode: ’XRP’,
assetScale: 6,
options: {

//Switch API connects as a ’child’

role: ’server’,
port: 7444,
xrpSecret: ’shjZQ2E3mYzxHf1VzYBJCQHqLvt7Y’, //this connector’s secret
xrpServer: ’ws://192.168.1.98:51233’,
// Very asymmetric... you fund a channel for $0.50 in XRP, we’ll open one to

//Switch API will connect on this port

you for $10!

outgoingChannelAmount: ’32658000’,
minIncomingChannelAmount: ’1632900’,
// Use plugin maxPacketAmount (and not connector middleware) so F08s occur

// ~= 10$ in XRP drops
// ~= 0.5$ in XRP drops

before T04s

maxPacketAmount: ’653200’

// ~= 0.2$ in XRP drops

}

}

const moneydGui = {
relation: ’child’,
plugin: ’ilp-plugin-mini-accounts’,
assetCode: ’XRP’,
assetScale: 6,
options: {

//MoneyD GUI for this connector

port: 7768

//MoneyD GUI will connect on this port

}

}

const connectorApp = {
name: ’connector’,
env: {

DEBUG: ’ilp*,connector*’,
CONNECTOR_ENV: ’production’,
CONNECTOR_ADMIN_API: true,
CONNECTOR_ADMIN_API_PORT: 7769,
moneydGUI, set here on 7768

//this should not conflict with

48

CONNECTOR_ILP_ADDRESS: ’g.conn1’,
CONNECTOR_BACKEND: ’one-to-one’,
CONNECTOR_SPREAD: ’0’,
CONNECTOR_STORE: ’memdown’,
//CONNECTOR_STORE: ’ilp-store-redis’,
//CONNECTOR_STORE_CONFIG: JSON.stringify({
//
//
//}),
CONNECTOR_ACCOUNTS: JSON.stringify({

prefix: ’connector’,
port: 6379

//<YOUR ILP ADDRESS>

//comment this if using the store below
//if using a store

conn2: peer1,
ilsp_clients: ilspServer,
moneyd_GUI: moneydGui,
switchXRP: SwitchAPIServer

})

//arbitrary names easy to remember

},
script: path.resolve(__dirname, ’src/index.js’)

}

module.exports = { apps: [ connectorApp ] }

Further, we reproduce an example conﬁguration for the ILSP2 Connector in Figure 27, which
is peered with the ILSP1 Connector. This connector has two wallets, one in XRP and one in
ETH, so it is able to provide cross payments between XRP and ETH. This use case ﬁts the
architecture illustrated in Figure 23. It is also equipped with Moneyd-GUI for easier admin-
istration through a Chrome browser (recommended), and can as well perform SPSP payments
given SPSP is installed. More on SPSP in Section 5.0.1.

’use strict’
const path = require(’path’)

const address = ’rLR52VSZG3wqSrkcpfkSnaKnYoYyPoJJgy’ // <YOUR RIPPLE ADDRESS>
const secret = ’ssrnzXKsJKWDh9cFpmZSLWHN3D5HM’

// <YOUR RIPPLE SECRET>

//to get the gas price
const { convert, usd, gwei } = require(’@kava-labs/crypto-rate-utils’)
const axios = require(’axios’)

const getGasPrice = async () => {

const { data } = await axios.get(

’https://ethgasstation.info/json/ethgasAPI.json’

)

return convert(gwei(data.fast / 10), wei())

}
//
const peer1 = {

relation: ’peer’,
plugin: ’ilp-plugin-xrp-paychan’, //peer with other connector/node over XRP
assetCode: ’XRP’,
assetScale: 9,
balance: {

maximum: ’1000000000’,
settleThreshold: ’-5000000000’,

49

settleTo: ’0’

},
options: {

//listener: {
//port: 10666,
//secret: ’2afe5e6cece84ed0027f9a2463edfa6358901bd6f1c9f3e1b0e43c13ff1ae2ea’

//this connector would be a server listening on port 10666

// this is the token that your peer must authenticate with.

//},
server:

’btp+ws://yourcustomsequence:2afe5e6cece84ed0027f9a2463edfa6358901bd6f1c9f3e1b0e43c13ff1ae2eb@192.168.1.146:10666’,
//this connector is a ws client connecting to its ws server at port 10666

rippledServer: ’ws://192.168.1.98:51233’,

//PORT?

//wss://s2.ripple.com //

?Specify the server that you submit XRP transactions to?

peerAddress: ’rMqUT7uGs6Sz1m9vFr7o85XJ3WDAvgzWmj’, //<PEER RIPPLE ADDRESS>
address,
secret

}

}

const peerETH = {

relation: ’child’,
plugin: ’ilp-plugin-ethereum’,
assetCode: ’ETH’,
assetScale: 9,
options: {

role: ’server’,
port: 7442,
ethereumPrivateKey:

’0x43c50a578883922df30a33eb74418fb568c0081c40256e4675df02dcc28b6ef6’,
//this connector’s ETH address; different from machinomy contract address

ethereumProvider: ’kovan’, //goes to ETH plugin as identifier
getGasPrice: getGasPrice, //’20000000000’,
outgoingChannelAmount: ’71440000’,
minIncomingChannelAmount: ’3570000’, // 0.5usd
// In plugin (and not connector middleware) so F08s occur before T04s
maxPacketAmount: ’1430000’ // 0.2USD

//10 usd

}

}

const ilspServer = {

relation: ’child’,
plugin: ’ilp-plugin-xrp-asym-server’, // ILSP server for downstream clients
assetCode: ’XRP’,
assetScale: 6,
options: {

port: 7443,
xrpServer: ’ws://192.168.1.98:51233’, //MAINNET wss://s2.ripple.com
address,
secret

//port on which to listen to client apps

}

}

const moneydGui = {
relation: ’child’,

50

plugin: ’ilp-plugin-mini-accounts’,
assetCode: ’XRP’,
assetScale: 6,
options: {

port: 7768

}

}

const connectorApp = {
name: ’connector’,
env: {

DEBUG: ’ilp*,connector*’,
CONNECTOR_ENV: ’production’,
CONNECTOR_ADMIN_API: true,
CONNECTOR_ADMIN_API_PORT: 7769,
CONNECTOR_ILP_ADDRESS: ’g.conn2’, //<YOUR ILP ADDRESS>
CONNECTOR_BACKEND: ’one-to-one’,
CONNECTOR_SPREAD: ’0’,
CONNECTOR_STORE: ’memdown’,
//CONNECTOR_STORE: ’ilp-store-redis’,
//CONNECTOR_STORE_CONFIG: JSON.stringify({
//
//
//}),
CONNECTOR_ACCOUNTS: JSON.stringify({

prefix: ’connector’,
port: 6379

conn1: peer1,
ilsp_clients: ilspServer,
moneyd_GUI: moneydGui,
peer_ETH: peerETH

})

},
script: path.resolve(__dirname, ’src/index.js’)

}

module.exports = { apps: [ connectorApp ] }

This connector supports SPSP client-server. This is explained in Section 5.0.1.

Other connectors, functional but still in development, are the Raﬁki 46 connector and the

Rust 47 connector. A basis for a Java connector is also in the works, as Quilt 48.

Raﬁki is a modular connector which is meant to improve on the ”reference” js connector
in regards to practical aspects like cloud deployment, more manageable and ’hot’ changes of
conﬁguration, etc [32].

The Rust connector is meant to be a faster connector for high traﬃc. One important update
is the new concept of ”Settlement engine” and the elimination of the plugins. Oﬃcial informa-
tion on the Settlement Engines’ architecture can be found in the new RFC on the Interledger
website49. Also because of the modular architecture, at least in the case of Rust and at the
present moment, in order to run a connector, the user needs to separately start 3 processes:
the connector itself, the settlement engine, and in some cases the Redis database. Separate

46https://github.com/interledgerjs/raﬁki, accessed June 2019
47https://github.com/emschwartz/interledger-rs/tree/master, accessed June 2019
48https://www.hyperledger.org/projects/quilt, accessed July 2019
49https://interledger.org/rfcs/0038-settlement-engines/, accessed January 2020

51

conﬁguration need to be provided50.

7 The ledgers

7.1 The Ripple ledger

The Rippled XRP ledger is made up of two types of servers: ”trackers” (or stock servers) and
”validators”. They run the same piece of software [33], just with a diﬀerent conﬁguration. Al-
though they can answer user queries, validators should ideally just process the transactions they
receive from the trackers.

’Ideally, validating nodes are clustered with at least two stock nodes, to prevent DoS attacks
and to preserve availability while updating the stock nodes. This conﬁguration enables the vali-
dating node to be cut oﬀ from the internet, except for messages to/from other trusted nodes in the
cluster and SSH connections via a LAN connection. Using two stock nodes provides redundant
communication to the validating node, which is useful in case one of the stock nodes crashes or
goes oﬄine. However, this means a validating node has 3x the cost, 3x the monitoring, and 3x
the time commitment of a stock node. Production validating nodes should have at least 32 GB
of memory as well as a 50 GB+ solid state drive. I encourage operator to refrain from making
API calls (monitoring excepted) on validating nodes’. [34]

Validators participate in the consensus process and vote on fees and amendments. Trackers
are meant to be placed in-between validators and the rest of the network, pick-up traﬃc and
forward it to the validators. They work as relays, protecting the validators. They also can hold
the full history of the ledger and answer queries about old ledgers. On the other hand, the
validators can work with minimal stored history.

Below is the procedure to build and cold-start an independent local validators cluster. One
aspect to keep in mind is that ’there is no rippled setting that deﬁnes which network it uses.
Instead, it uses the consensus of validators it trusts to know which ledger to accept as the truth.
When diﬀerent consensus groups of rippled instances only trust other members of the same
group, each group continues as a parallel network. Even if malicious or misbehaving computers
connect to both networks, the consensus process overrides the confusion as long as the members
of each network are not conﬁgured to trust members of another network in excess of their quorum
settings.’ [35]

7.1.1 Preparation

To build a parallel Rippled servers (validators, trackers) network, which, in its entirety is also
called the ”Rippled Ledger”, the minimal required hardware resources51 need to be planned
in advance. Depending on the available resources, each Rippled server can be deployed on a
diﬀerent physical machine or not. However, for high traﬃc use-cases, in order to streamline I/O,
each server could have its own physical SSD.

To install the pre-packaged Rippled server, the instructions on the Ripple developer portal
should be followed52. Then, another guide is disseminated on the developer portal to install

50https://github.com/interledger-rs/interledger-rs/tree/master/examples, accessed January 2020
51https://developers.ripple.com/system-requirements.html, accessed June 2019
52https://developers.ripple.com/install-rippled.html, accessed June 2019

52

Rippled from the source code53. After that, the following steps must be followed:

• Build the validators keys and tokens, using the published documentation54 and code55.

– Create keys:

~/validator-keys-tool/build/gcc.debug$ ./validator-keys create_keys

– Create tokens:

~/validator-keys-tool/build/gcc.debug$ ./validator-keys create_token --keyfile

/home/user/.ripple/validator-keys.json

• Add generated [validator token] to ’rippled.cfg’.
• Add generated [validators] public keys to ’validators.txt’. Comment the rest of ’valida-

tors.txt’.

• In ’rippled.cfg’, add the peer validators’ IPs in the ﬁeld [ips f ixed] in the form of IP:port

(51235).

• Check that ’validator.txt’ ﬁle name is the same with the name referenced by ’rippled.cfg’.
• Conﬁgure clustering as per the Ripple documentation56, using the validation create57 method:

~/rippled/ccabuild$ ./rippled --conf /home/user/rippled/cfg/rippled-example.cfg

validation_create

7.1.2 Start up

In the case when Docker images have been used, after creating the Docker image of the Rippled
server, this can be loaded and started on each physical/virtual server machine with the following:

- ’sudo docker load -i /path/to/your_docker_image.tar’
- ’sudo docker images’ - to check the image name
- ’sudo docker run -ti -u root --network host --name <container_name> <image_name>’
- ’sudo docker exec -ti -u root <container_name> bash’. To open a second terminal
to the container, just run the command again into a fresh terminal window.

With the docker images loaded on each Rippled server machine, the actual Rippled validators
servers network can be cold-started as follows:

• Start the ﬁrst Rippled server with ’quorum 1’ and wait a few minutes for it to stabilize:

./rippled --conf /home/user/rippled/cfg/rippled-example.cfg --quorum 1

• Start the remaining servers with the same command, waiting for each to stabilize, ﬁrst.

• Restart the servers in the same order, waiting a few minutes for each to stabilize before

starting the next, with ’quorum 2’:

53https://developers.ripple.com/build-run-rippled-ubuntu.html, accessed June 2019
54https://developers.ripple.com/run-rippled-as-a-validator.html#enable-validation-on-your-rippled-server, ac-

cessed June 2019

55https://github.com/ripple/validator-keys-tool, accessed June 2019
56https://developers.ripple.com/cluster-rippled-servers.html, accessed June 2019
57https://developers.ripple.com/validation create.html, accessed June 2019

53

./rippled --conf /home/user/rippled/cfg/rippled-example.cfg --quorum 2

In a new terminal window handling the Docker container, use the ”stop” command in
Table 4 to gracefully stop the servers before restart.

In this minimal set-up though, if any of the servers is restarted, it will lose previously
kept ledger history - even with full history enabled. This won’t stop it working after restart, as
validators do not need full history to work properly. To be able to access previous ledger history,
tracking servers should be also set up. Data API58 is a useful history tool which could also be
set-up if desired, although setting it up on a private network seems not too obvious.

’Ripple API’59 provides the means to interact with the server. For example, in Ripple, all
the money are created in the beginning, and stored in an account with a hard-coded address,
called the ”Genesis account’. One can check the ’Genesis account’ with:

./rippled --conf /home/user/rippled/cfg/rippled-example.cfg account_info

rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh

Some other useful server commands are provided in Table 4. These can be entered from a

separate terminal window handling the docker container.

Table 4: Useful Rippled server commands.

command
wallet propose
stop
restart
server info
server state
peers

eﬀect
create a new wallet with random seed credentials (inactive until funded)
gracefully stop the server
restart the server
various easy-to-read info about the server
almost same info as above, but easier-to-process instead of easy-to-read
info on peer validators: connected? ledger sequences available? ...

Immediately after creating and starting the validators cluster network (which form the XRP
ledger), one can open a few accounts with the ’wallet propose’ command above, and fund them
using for example the following simple procedure. Regarding the wallets, they can be sometimes
classiﬁed as ’hot’ or ’cold’ wallets. The diﬀerence is that ’hot’ wallets are connected to the
internet, while ’cold’ wallets are not.
’Hot’ wallets provide the advantage of quick access but
lower security, like anything connected to the internet. ’Cold’ wallets are slower to access (need
to connect) but more secure due to generally not being online. It is generally recommended to
hold only the amounts necessary for daily operation in the ’hot’ wallet, while the bulk of the
money would be kept oﬄine.

• Install Ripple-API for javascript60.
• Place the two example scripts in the app folder: ’/home/user/ripple api/get-account-info.js’.
• Run them with ’./node modules/.bin/babel-node get-account-info.js’. The code should run on

one of the Ripple servers.

Example script - get account info:

58https://developers.ripple.com/data-api.html, accessed June 2019
59https://developers.ripple.com/rippleapi-reference.html, accessed June 2019
60https://developers.ripple.com/get-started-with-rippleapi-for-javascript.html, accessed June 2019

54

//GET ACCOUNT INFO
’use strict’;
const RippleAPI = require(’ripple-lib’).RippleAPI;

const api = new RippleAPI({

server: ’ws://localhost:6006’

});
api.connect().then(() => {

/* begin custom code ------------------------------------ */
const testAddress = ’rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh’;

console.log(’getting account info for’, testAddress);
return api.getAccountInfo(testAddress);

}).then(info => {

console.log(info);
console.log(’getAccountInfo done’);

/* end custom code -------------------------------------- */

}).then(() => {

return api.disconnect();

}).then(() => {

console.log(’done and disconnected.’);

}).catch(console.error);

Example script - fund an account:

//Account funding
const RippleAPI = require(’ripple-lib’).RippleAPI

// SENDER - ADDRESS 1
const ADDRESS_1 = "rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh"
const SECRET_1 = "snoPBrXtMeMyMHUVTgbuqAfg1SUTb"

// RECEIVER - ADDRESS 2
const ADDRESS_2 = "rMqUT7uGs6Sz1m9vFr7o85XJ3WDAvgzWmj"

const instructions = {maxLedgerVersionOffset: 5}
const currency = ’XRP’
const amount = ’20000000’ // this is not ’drops’ but XRP

const payment = {

source: {

address: ADDRESS_1,
maxAmount: {

value: amount,
currency: currency

}
},
destination: {

address: ADDRESS_2,
amount: {

value: amount,

55

currency: currency

}

}

}

const api = new RippleAPI({

//server: ’wss://s1.ripple.com’
//server: ’wss://s.altnet.rippletest.net:51233’ // TESTNET
server: ’ws://localhost:6006’

//MAINNET

// Localhost

})

api.connect().then(() => {

console.log(’Connected...’)
api.preparePayment(ADDRESS_1, payment, instructions).then(prepared => {
const {signedTransaction, id} = api.sign(prepared.txJSON, SECRET_1)
console.log(id)
api.submit(signedTransaction).then(result => {
console.log(JSON.stringify(result, null, 2))
api.disconnect()

})

})

}).catch(console.error)

The known amendments seem not to be automatically enabled after cold starting a pri-
vate network. In order to force them, we added the [features] stanza in each validator’s conﬁg
ﬁle. Otherwise, the validators would apparently work, but, when trying to open for example a
paychan, would throw the error ”logic not enabled’ - because the paychan amendment is not
enabled. According to documentation61, for an amendment to become enabled, it needs the
support of 80% of validators’ votes for two weeks. If it loses this support, the amendment is
temporarily disabled, and it can be re-enabled after it re-gains this support.

[features]
PayChan
Escrow
CryptoConditions
ﬁx1528
.......

Below is an example conﬁg ﬁle for a private network cluster of 3 validators. The ﬁle is located

in ’home/user/rippled/cfg’. We used a docker container with a compiled version of Rippled.

[server]
port_rpc_admin_local
port_peer
port_ws_admin_local
port_ws_public
port_public

[port_rpc_admin_local]

61https://developers.ripple.com/amendments.html, accessed June 2019

56

port = 5005
ip = 127.0.0.1
admin = 127.0.0.1
protocol = http

[port_peer] //talk to other validators
port = 51235
ip = 0.0.0.0
protocol = peer

[port_ws_admin_local]
port = 6006
ip = 127.0.0.1
admin = 127.0.0.1
protocol = ws

[port_ws_public]
port = 6005
ip = 127.0.0.1
protocol = wss

[port_public] //connectors, moneyd, switch API will connect here
ip = 0.0.0.0
port = 51233
protocol = ws

[node_size] //required for full history
huge

# This is primary persistent datastore for Rippled. This includes transaction
# metadata, account states, and ledger headers. Helpful information can be
# found here: https://ripple.com/wiki/NodeBackEnd
# delete old ledgers while maintaining at least 2000. Do not require an
# external administrative command to initiate deletion.
[node_db] //NuDB type required for full history
type=NuDB
path=/var/lib/rippled/db/nudb
#open_files=2000 //these are not needed for NuDB
#filter_bits=12
#cache_mb=256
#file_size_mb=8
#file_size_mult=2
#online_delete=2000
#advisory_delete=0

[ledger_history] //although enabled, full history seems not to work

//correctly for validators, will need trackers for this.

full

[database_path]
/var/lib/rippled/db

# This needs to be an absolute directory reference, not a relative one.
# Modify this value as required.

57

[debug_logfile]
/var/log/rippled/debug.log

[sntp_servers] // servers for time sync
time.windows.com
time.apple.com
time.nist.gov
pool.ntp.org

# File containing trusted validator keys or validator list publishers.
# Unless an absolute path is specified, it will be considered relative to the
# folder in which the rippled.cfg file is located.
[validators_file]
validators-example.txt

# Turn down default logging to save disk space in the long run.
# Valid values here are trace, debug, info, warning, error, and fatal
[rpc_startup]
{ "command": "log_level", "severity": "trace" } //verbose logging

# If ssl_verify is 1, certificates will be validated.
# To allow the use of self-signed certificates for development or internal use,
# set to ssl_verify to 0.
[ssl_verify]
0

[ips_fixed]
192.168.1.97 51235 //IPs and ports of the other 2 peer validators
192.168.1.132 51235

[peer_private]
1

[node_seed]
shEm9dGAs2aq6MMe9XsXYXKrPmqft

[cluster_nodes]
n9LPJFoTLxVbTtdWADZzPpCwACwC3aLAYGhFcNNR61fD9DTc2w5L ripdbg1
n9KUMms9ZrDgHU7rN9pRTRGMKEWy5Ghk3qj53aCPAbJRur2sTqwp ripdbg3

[validator-token]
eyJtYW5pZmVzdCI6IkpBQUFBQUZ4SWUwYkVlUVp1bGNsKzRadk44cGhXUWJNNWhlV3RKY0hN
YUVKcUpadWVRWm9jWE1oQXYvVWY3MmlaQ0VQZndPZTd0TjNaY0V1UnFDd2Q3U2JkU3hPTnJq
TXlsNWlka2N3UlFJaEFKc3IzL3g2U0RiRGprOHc0Mks2eU91M1FPbW4vNjVIeTM4bkxjbnJa
c1ROQWlBSnRlRTRpdjVqSjRJMytvS0VseEFjTmFUL3VoQnRlSVFyK29RdmVoemJESEFTUU53
RnpLN21kV3lUaTZoTWY4SUJTRUxmZHI1cjhuMFdIeE5BSGNHSXJURDV1N09BK3FKZWZLMzkw
Smx3aE5ydGVLL09LWS8rQldDUHo0ejQ4VXptaHd3PSIsInZhbGlkYXRpb25fc2VjcmV0X2tl
eSI6IkJGMTcyRjJBMzNGQTZDOTdBQ0JBODhBNTA0NThGQzZFRURENzBCNjEwMzdEMjcwNjgz
RTQ3MzRBNUY2OURGRkMifQ==

[features]
PayChan
Escrow
CryptoConditions

58

fix1528
DepositPreauth
FeeEscalation
fix1373
MultiSign
TickSize
fix1623
fix1515
TrustSetAuth
fix1513
fix1512
fix1571
Flow
fix1201
fix1523
fix1543
SortedDirectories
EnforceInvariants
fix1368
DepositAuth
fix1578

7.2 The ETH ledger. Connecting the XRP and ETH ledgers through ’Machinomy’

For the scope of this work, we will assimilate the ETH network to a black-box holding the ETH
wallet accounts, executing commands and providing immediate response. For testing purposes,
such a friendly ’black-box’ can be ’Ganache’62, previously called ’TestRPC’. After download,
Ganache can be started directly:

cd /Downloads
./ganache-1.3.1-x86_64.AppImage

’Machinomy’63 is used to connect the XRP and ETH ledgers. It achieves this by deploying a
speciﬁc contract on the ETH ledger. One contract manages all the channels for Ether micropay-
ments (all the sender-receiver pairs). Thus, Machinomy creates the settlement capability when
ILP payment interacts with the ETH ledger.

’Machinomy is a micropayments SDK for Ethereum platform. State channels is a design
pattern for instant blockchain transactions. It moves most of the transactions oﬀ-chain. As
transactions do not touch the blockchain, fees and waiting times are eliminated, in a secure
way.’ [36]

Machinomy should be installed64 on the same machine with the ETH provider, in this case,
Ganache. After installing Machinomy, a contract can be deployed on the ETH network using
the following:

cd machinomy/node_modules/@machinomy/contracts
yarn truffle migrate --reset

62https://truﬄeframework.com/docs/ganache/quickstart, accessed June 2019, accessed June 2019
63https://machinomy.com/, accessed June 2019
64https://github.com/machinomy/machinomy, accessed June 2019

59

Checking back in Ganache after Machinomy contract deployment, you will notice that a small
amount of ETH has been subtracted from the ﬁrst account, and in the Transactions tab, the
contract has been deployed.

After a Ganache restart, the ’–reset’ option has to be used because Ganache is not persistent.
The contract will be deployed on the ﬁrst Ganache account. The other accounts can be used by
ETH client wallets.

After deploying the Machinomy contract on the ETH network, apps like Switch API can be
used to exchange XRP and ETH back and forth. The plugins should be set to access Ganache
using http://ganache IP:ganache port. A detailed explanation on Switch API is provided in
Section 5.0.2.

8 Evaluation and discussion

In this paper, we have provided the details on how to set-up a private ILP network comprising of
two ledgers - XRP and ETH, ILP service providers (connectors), and customer apps (Moneyd,
SPSP, Switch API). The payments can be streamed from one ledger to the other with the Switch
API app, making use of Machinomy smart contracts deployed on the ETH ledger. Time (the
time on the machines must be synchronised), conversion rates and gas price are fetched from
the internet.

In our opinion, at the present moment, as one moves from the core - the Rippled servers
making-up the ledger, to the periphery - the customer apps, the support and availability of apps
decreases. The most information to be found concerns the Rippled servers, while in regards to
customer apps we have tried so far, at present only Moneyd-XRP seems fairly supported. Some
of the plugins are undergoing changes (e.g. ETH plugin), and with the advent of connectors
like Raﬁki, they may be, at least partially, replaced with new approaches like the ”settlement
engine”. Intuitively this is the way the ecosystem should be built and we are conﬁdent the future
will bring many improvements.

9 Conclusions and future work

Sometimes abstract concepts are explained separately from the actual implementation, making
it diﬃcult to make the connections. This work ﬁlls a hole in the documentation regarding a
lack of a comprehensive high level view of the ecosystem and how the diﬀerent pieces are joined
together.

We are currently studying the all-new @Coil/Raﬁki which is still in beta and will soon

provide the results.

Acknowledgements

This work was supported by the Luxembourg National Research Fund (FNR) through grant
PRIDE15/10621687/SPsquared. In addition, we thankfully acknowledge the support from the
RIPPLE University Blockchain Research Initiative (UBRI) framework for our research.

60

Acronyms

API Abstract Programming Interface. 4, 8, 11, 37–43, 52, 54, 60, 61

BTP Bilateral Transfer Protocol. 11, 21–24, 27–32, 36

FSM Finite State Machine. 2, 17

GUI Graphical User Interface. 13, 25, 28, 32, 33, 35, 43, 45, 47, 49

ILP Interledger Protocol. 4–12, 14–16, 18, 19, 21, 22, 24–30, 32, 34, 42, 43, 46, 59, 60

ILSP Interledger Service Provider. 8, 11, 28, 36, 38, 42–44, 47, 49

SPSP Simple Payment Setup Protocol. 11–15, 19, 21, 22, 24–30, 32–36, 43, 45, 49, 51, 60

Glossary

Moneyd An ILP provider, allowing all applications on an end-user computer to use funds on

the live ILP network. 4, 8, 10, 13, 15, 21, 24–30, 32–37, 42, 43, 45, 60

Proof of Work (PoW) A consensus protocol introduced by Bitcoin, known as mining, which
involves answering to a mathematical problem that requires considerable work to solve,
but is easily veriﬁed once given the answer. 6

Switch API A SDK for cross-chain trading between BTC, ETH, DAI and XRP with In-

terledger Streaming. 4, 8, 37–43, 60

XRP Ripple’s digital payment asset which is used for Interledger payments. 3–7, 9, 10, 13, 19,

24, 25, 27–29, 32–38, 40, 41, 43, 44, 46, 49, 54, 59, 60

References

[1] Dr. Demetrios Zamboglou.

ripple |Explained,

[Online] Accessed: June 6, 2019. https://medium.com/

datadriveninvestor/ripple-explained-4df46678e0bd.

[2] Ripple.

ILP Connector,

[Online] Accessed:

June 6, 2019.

https://github.com/interledgerjs/

ilp-connector#what-is-this.

[3] Ripple.

ILP Addresses - v2.0.0,

[Online] Accessed: June 21, 2019.

https://interledger.org/rfcs/

0015-ilp-addresses/.

[4] Adrian Hope-Bailie. Running your own ILP connector, [Online] Accessed: April 10, 2019. https://medium.

com/interledger-blog/running-your-own-ilp-connector-c296a6dcf39a.

[5] Ripple. Peering, Clearing and Settling, [Online] Accessed: June 18, 2019. https://interledger.org/rfcs/

0032-peering-clearing-settlement/.

[6] Ripple. Payment Channels, [Online] Accessed: June 17, 2019. https://xrpl.org/payment-channels.html.

[7] Adrian-Hope Bailie.

Settlement Architecture,

[Online] Accessed:

June 18, 2019.

https://forum.

interledger.org/t/settlement-architecture/545.

[8] Ben Sharaﬁan. Moneyd - payment channels explanation, [Online] Accessed: June 20, 2019. https://forum.

interledger.org/t/moneyd-payment-channels-explanation/374/3.

[9] Evan
line]
6,
interledger-protocol-stack-deep-dive-boston-interledger-meetup.

Schwartz.
Accessed:

Stack Deep Dive

Protocol
June

2019.

Boston

[On-
-
https://www.slideshare.net/Interledger/

Interledger Meetup,

61

[10] Evan Schwartz. Thoughts on Scaling Interledger Connectors, [Online] Accessed: June 14, 2019. https:
//medium.com/interledger-blog/thoughts-on-scaling-interledger-connectors-7e3cad0dab7f.

[11] Ripple.

Simple Payment

Setup Protocol

(SPSP),

[Online] Accessed:

June

6,

2019.

https://github.com/interledger/rfcs/blob/master/0009-simple-payment-setup-protocol/
0009-simple-payment-setup-protocol.md.

[12] Ripple. Payment Pointers and Payment Setup Protocols , [Online] Accessed: June 14, 2019. https://
github.com/interledger/rfcs/blob/master/0026-payment-pointers/0026-payment-pointers.md.

[13] Evan Schwartz. STREAMing Money and Data Over ILP, [Online] Accessed: June 11, 2019. https://

medium.com/interledger-blog/streaming-money-and-data-over-ilp-fabd76fc991e.

[14] Ripple. STREAM: A Multiplexed Money and Data Transport for ILP, [Online] Accessed: June 11, 2019.

https://interledger.org/rfcs/0029-stream/.

[15] Ripple.

Value
ripple-interledger-protocols-role-in-realizing-the-internet-of-value-iov/19033/.

[IoV],

2019.

11,

Ripple
[Online]

InterLedger
Accessed:

Protocol’s
June

role

in

realizing

the

of
https://bcfocus.com/news/

Internet

[16] Ripple.

Install Rippled,

[Online] Accessed:

June 6, 2019.

https://developers.ripple.com/

install-rippled.html.

[17] D. Appelt, A. Hope-Bailie, M. de Jong, E. Schwartz, B. Sharaﬁan, S. Thomas, and B. Way.

ILP v4:
Version 4 of the Interledger protocol, April 2018, [Online] Accessed: June 13, 2019. https://github.com/
interledger/rfcs/blob/2052575084cdeeb94c0e9bd2e3c37960b732fa2d/whitepaper/interledger.pdf.

[18] Evan Schwartz. Trustlines Explanation, [Online] Accessed: June 13, 2019. https://forum.interledger.

org/t/trustlines-explanation/358.

[19] Ripple. Hashed-Timelock Agreements (HTLAs), [Online] Accessed: June 11, 2019. https://interledger.

org/rfcs/0022-hashed-timelock-agreements/#simple-payment-channels.

[20] Ripple. Relationship between Protocols, [Online] Accessed: June 14, 2019. https://interledger.org/rfcs/

0033-relationship-between-protocols/.

[21] Ripple.

Interledger Architecture,

[Online] Accessed: June 6, 2019.

https://interledger.org/rfcs/

0001-interledger-architecture/#protocol-layers.

[22] Ripple. The Bilateral Transfer Protocol, [Online] Accessed: June 11, 2019. https://interledger.org/rfcs/

0023-bilateral-transfer-protocol/draft-2.html.

[23] Ripple. Interledger Check-in, [Online] Accessed: April 15, 2019. https://developers.ripple.com/blog/

2019/interledger-checkin.html.

[24] Sabine

Introducing
line]
6,
June
introducing-pull-payments-to-the-interledger-protocol-d763e21af6ec.

Bertram.
Accessed:

Payments

2019.

Pull

the

to

[On-
https://medium.com/interledger-blog/

Interledger

Protocol,

[25] Ripple. Interledger Protocol (ILP), [Online] Accessed: April 10, 2019. https://interledger.org/rfcs/

0003-interledger-protocol/.

[26] Ben Sharaﬁan. SPSP payments, [Online] Accessed: June 6, 2019. https://forum.interledger.org/t/

spsp-payments/310/7.

[27] Kincaid O’Neil Kava Labs. Lightning fast, non-custodial trades - in 20 lines of code, [Online] Accessed: June
13, 2019. https://medium.com/kava-labs/fast-non-custodial-trading-using-layer-2-ddeb2283f71b.

[28] Kevin Davis Kava Labs. Kava Development Update #3, [Online] Accessed: June 13, 2019. https://medium.

com/kava-labs/kava-development-update-3-69e20f88b4c9.

[29] S. Thomas, E. Schwartz, and A. Hope-Bailie. The Interledger Protocol, July. 2016. [Online] Accessed: April

10, 2019. https://tools.ietf.org/html/draft-thomas-interledger-00.

[30] Adrian Hope-Bailie. Interledger Community Group Call, Nov. 2018. [Online] Accessed: April 10, 2019. https:

//zoom.us/recording/play/rCj_0BZfNzUAHmg1lR52z0mGql55XICJ1CMJMl1sqDRNZmP3xFpyI52rgSOG6C8s?
continueMode=true.

[31] HowToToken Team.
timate Guide,
ripple-different-cryptocurrencies-ultimate-guide/#ripple-payment-channels.

How Is Ripple Diﬀerent From All Other Cryptocurrencies?
2019.

An Ul-
https://howtotoken.com/explained/

[Online] Accessed:

April

10,

[32] Adrian Hope-Bailie.

Introducing Raﬁki,

[Online] Accessed:

June 24, 2019.

https://medium.com/

interledger-blog/introducing-rafiki-e3de4710d3de.

62

[33] Ripple.

Install Rippled,

[Online] Accessed: April 10, 2019.

https://developers.ripple.com/

install-rippled.html.

[34] Rabbit. The Interledger Protocol, July. 2018. [Online] Accessed: April 10, 2019. https://xrpcommunity.

blog/rippled/.

[35] Ripple. Parallel Networks and Consensus, [Online] Accessed: April 10, 2019. https://mduo13.github.io/

ripple-dev-portal/tutorial-rippled-setup.html.

[36] Sergey Ukustov, Andrei Riaskov, Alexander Burtovoy, and Matthew Slipper. Machinomy, [Online] Accessed:

April 10, 2019. https://machinomy.com/.

63

Fig. 27: Ecosystem overview. The machines involved are time-synchronized using time servers.
The ETH gas price and the currency rates are fetched from online. To keep the diagram readable
we didn’t illustrate all plugin connections to the ledgers; each plugin provides for connection to
the appropriate ledger using wss or ws.

64

“MoneydXRP”“MoneydETH”MoneydcoreConnector coreXRP uplinkETH uplinkXRP pluginETH pluginAlice: 192.168.1.76Bob: 192.168.1.35XRP pluginETH plugin kavaILSP 2ETH ledgerPoAInternet:Fetch conversion rateAlice <-> Connector 2:  XRP paychanBTP, port 7442Bob <-> Connector 2:  ETH paychanBTP, port 7442SPSP serverport 6000SPSP clientMoneydGUIMoneydGUIMoneydcoreSPSP clientSPSP serverport 6000MachinomyWeb browser localhost:7770Web browser localhost:777077697769Connector coreXRP pluginILSP 1Ilp-plugin-miniaccountsRates backend“one-to-one”ETH plugin kavaXRP plugin kava“MoneydXRP”XRP uplinkXRP pluginCharlie: 192.168.1.116Charlie <-> Connector 1:  XRP paychanBTP, port 7442SPSP serverport 6000SPSP clientMoneydGUIMoneydcoreWeb browser localhost:77707769Internet:Fetch conversion rateDave, trading with “Switch API”Dave <-> Connector 1:  XRP paychanBTPDave <-> Connector 2:  ETH paychanBTPpeerBTPILP-plugin-xrp-paychanILP-plugin-xrp-paychanXRP plugin kavaws(s)://192.168.1.98: 51233192.168.1.87:8545MoneydGUIWeb browser localhost:7770Rates backend“ecb-plus-coinmarketcap”ILP-plugin-miniaccountsMoneydGUIWeb browser localhost:7770CoincapAPIRipple LedgerTrackersValidatorsJsConnector 1: 192.168.1.146JsConnector 2: 192.168.1.131Switch API coreFig. 28: Protocols and details. Advanced diagram. [20, 21]

65

Sender Node A: g.node-a (13) Routing Table Module Routing Table Account for Ledger B (11) Account Module (12) Bilateral Ledger IP layer connection (e.g. WebSocket) Interaction between programs Explanation of something Node B: g.node-a.child-b Routing Table Module Routing Table Account for Ledger B Account Module Bilateral Ledger (A) BTP over WebSocket (C) SPSP over HTTPS The identifier of nodes (g.xxx) is (3) ILP address Packet Data Structure BTP Packet ILP Packet (7) DCP Packet BTP Packet ILP Packet (8) RBP Packet The details (order, value type, length) are defined as (9) ASN.1 . The ASN.1 structure is encoded in binary by (10) Canonical OER rule. (1) BTP Packet (2) ILP Packet (4) STREAM Packet (5) Application Packet Application Account for Ledger A Account Module Bilateral Ledger (4) STREAM Packet (14) Configuration Module (7) DCP Packet (6) SPSP information (8) RBP Packet Ledger B Account for Node A Account for Node B Payment Channel for Node A and B (B) Ledger specific connection (to receiver SPSP server) (1) BTP Packet (to Node C) (to Ledger A) 