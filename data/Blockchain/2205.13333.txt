2
2
0
2

y
a
M
6
2

]

R
C
.
s
c
[

1
v
3
3
3
3
1
.
5
0
2
2
:
v
i
X
r
a

SoK: Decentralized Randomness Beacon
Protocols

Mayank Raikwar[0000−0002−5479−5748] and Danilo Gligoroski[0000−0002−7078−6139]

Norwegian University of Science and Technology (NTNU) Trondheim, Norway
{mayank.raikwar,danilog}@ntnu.no

Abstract. The scientiﬁc interest in the area of Decentralized Random-
ness Beacon (DRB) protocols has been thriving recently. Partially that
interest is due to the success of the disruptive technologies introduced by
modern cryptography, such as cryptocurrencies, blockchain technologies,
and decentralized ﬁnances, where there is an enormous need for a pub-
lic, reliable, trusted, veriﬁable, and distributed source of randomness. On
the other hand, recent advancements in the development of new crypto-
graphic primitives brought a huge interest in constructing a plethora of
DRB protocols diﬀering in design and underlying primitives.
To the best of our knowledge, no systematic and comprehensive work
systematizes and analyzes the existing DRB protocols. Therefore, we
present a Systematization of Knowledge (SoK) intending to structure
the multi-faced body of research on DRB protocols. In this SoK, we
delineate the DRB protocols along the following axes: their underlying
primitive, properties, and security. This SoK tries to ﬁll that gap by
providing basic standard deﬁnitions and requirements for DRB protocols,
such as Unpredictability, Bias-resistance, Availability (or Liveness), and
Public Veriﬁability. We classify DRB protocols according to the nature
of interactivity among protocol participants. We also highlight the most
signiﬁcant features of DRB protocols such as scalability, complexity, and
performance along with a brief discussion on its improvement. We present
future research directions along with a few interesting research problems.

Keywords: Random Beacon · Bias-resistance · Unpredictability · Secret
Sharing · Veriﬁable Delay Function

1

Introduction

Public digital randomness is an essential building component for a large spec-
trum of applications and protocols. For example, a reliable source of continuous
randomness providing high entropy, also known as random beacon, is crucial for
many security applications. A notion of coin tossing protocol [9] was proposed
by Blum in 1983 that addressed the question of generating the trustworthy ran-
dom value in a network of mutually distrustful participants. Further, Rabin [58]
formalized the notion of the random beacon. Since then, randomness generation
has been advanced signiﬁcantly due to the underlying modern cryptography.

 
 
 
 
 
 
2

Mayank Raikwar and Danilo Gligoroski

Lately, coin tossing protocols became more appealing in Proof-of-Work (PoW)
or Proof-of-Stake (PoS) [39] consensus. Random beacon has a range of applica-
tions that includes cryptographic parameter generation [49], design of byzantine
fault tolerant (BFT) protocols [16,39], privacy-preserving message services [40],
e-voting protocols [1], online gaming [13], publicly auditable selections [13],
anonymous browsing [41], sharded blockchains [23] and smart contracts [48].

Due to the applicability of shared randomness in a variety of applications, a
rich body of literature has emerged that proposes many DRB protocols diﬀering
in their designs and underlying cryptography. Nevertheless, the system models
and design challenges in these DRB protocols are highly disparate. Therefore, to
address these challenges and to provide a general deﬁnition of a DRB protocol,
we present a Systematization of Knowledge (SoK). The purpose of this SoK is
to provide a systematic overview of existing DRB protocols that can help re-
searchers and practitioners to ﬁnd suitable solutions for randomness generation.

Background. An easy approach to achieve continuous randomness is through
a single node or a trusted third party such as NIST [46], Random.org [43] or
Oraclize.it [56]. The NIST beacon continuously outputs hardware-generated ran-
dom values from a quantum-mechanical eﬀect. Since these beacon services are
centralized, they can be unreliable. Moreover, in the past, they suﬀered a signif-
icant public trust deterioration after the revealed backdoor in the NSA-designed
Dual elliptic curve pseudorandom number generator [68]. Due to these problems,
these centralized beacon services are undesirable for secure applications.

As a consequence, Decentralized Randomness Beacon (DRB) protocols were
proposed and constructed where trust is distributed across multiple nodes that
jointly generate random values at a regular interval. More concretely, a con-
sortium of organizations launched a distributed publicly veriﬁable randomness
beacon that periodically provides unbiasable and unpredictable random outputs.
The deployment is known as League of Entropy (LoE)) [51] that aims to provide
collaborative governance for protection of its random beacon. The consortium
believes that their beacon can become a fundamental service on the internet.

DRB protocols can be constructed by employing diﬀerent cryptographic
primitives e.g. Publicly Veriﬁable Secret Sharing schemes (PVSS) [47,69,66,17,18,8,25],
Threshold Crypto-Systems [16,45,31,20,55], Veriﬁable Random Functions (VRF) [27,39,36,71,22,24],
Veriﬁable Delay Functions (VDF) [49,30,34,65,44]. Randomness can also be ex-
tracted from external data sources such as [7,21,13] or from the blockchain
schemes having their own random beacon [47,36,45]. These DRB protocols are
not equally-suited in all applications or use-cases due to the diversity in their
designs, characteristics, and underlying assumptions.

DRB protocols diﬀer signiﬁcantly due to their underlying techniques. A DRB
protocol should have a list of desirable beacon properties along with low com-
munication complexity, low computational cost, and low trust requirement (e.g.,
setup assumptions). Additionally, the DRB protocol should be eﬃcient in prac-
tical settings. Therefore, despite having many constructions of DRB protocols,
a few problems such as scalability, trust, and network assumptions need to be
addressed to construct a desirable DRB protocol for practical applications.

SoK: Decentralized Randomness Beacon Protocols

3

Motivated by the above, the contributions of this SoK are as follows:

1. We provide a formal deﬁnition of a Decentralized Randomness Beacon (DRB)

with a brief description of its security properties (Sect. 2).

2. We present a classiﬁcation of DRB protocols in Interactive and Non-interactive

DRB protocols and we describe these protocols in detail (Sect. 3).

3. We give a brief discussion on several crucial issues related to DRB protocols,
including complexity, scalability, and assumptions. We also identify a few
eﬃcient building components to construct eﬃcient DRB protocols (Sect. 4).

2 Decentralized Randomness Beacon (DRB)

A DRB allows a group of participants to collaboratively produce random val-
ues without the need of a central party. A DRB consists of n participants 1
P = (P1, P2, . . . , Pn). These participants are connected in a distributed manner.
Without loss of generality, we assume that a DRB protocol works in rounds
and maintains a beacon state st for each round. For every round e ∈ {1, 2, . . .},
given the current state ste−1, the DRB protocol collectively produces a random
output ve; the state st0 is jointly computed and agreed from the protocol par-
ticipants during the bootstrapping of the DRB protocol. Following, we present
a formalization of DRB and we formally deﬁne the required security properties
of a DRB. Additionally, we deﬁne a secure DRB protocol in Appendix A.

Deﬁnition 1. (Decentralized Randomness Beacon (DRB)) A DRB on a set of
participants P = (P1, . . . , Pn) is deﬁned as a tuple B of polynomial algorithms:
B = (Setup, LocalRand, GlobalRand, VerifyRand, UpdateSt)

– Setup(1λ, n): Given input security parameter λ, and n participants, it gener-
ates public parameter pp and keypair for each participant (pki, ski). All par-
ticipants agree on public parameter pp and {pki}.

– LocalRand(ste−1, pp, ski, se,i): Given input state ste−1 from round e−1, public
parameter pp, and input seed se,i, a participant Pi computes a local output
value ve,i with a proof πe,i using ski and se,i for round e. Output (i, ve,i, πe,i).
– GlobalRand(ste−1, pp, S = {(i, ve,i, πe,i)}, m): Given input state ste−1, public
parameter pp, a set S of local output values from |S| participants, if |S| ≥ m,
where m is the minimum number of required local output values, the algorithm
computes the beacon output ve for round e by executing a function f on {ve,i}
from set S. It also computes proof of correctness πe using {πe,i} from set S.
Output (ve, πe) or ⊥.

– VerifyRand(ste−1, pp, ve, πe): Given input state ste−1, public parameter pp, a
beacon output ve, and a proof πe, the algorithm veriﬁes the beacon value ve
and the corresponding proof πe. Output 0 or 1.

– UpdateSt(ste−1, pp, ve, πe): Given input state ste−1, public parameter pp, a
beacon output ve, and a proof πe generated at the round e, the algorithm up-
dates the state from ste−1 to ste for round e. Output ste or ⊥.

1 We use node and participant interchangeably in protocols throughout the paper.

4

Mayank Raikwar and Danilo Gligoroski

The security properties of a DRB corresponds to: Unpredictability: An ad-
versary should not be able to predict (precompute) future beacon outcomes;
Bias-Resistance: A single participant or a colluding adversary cannot bias the
future beacon values; Availability (or Liveness): A single participant or a col-
luding adversary can not prevent the generation of the new beacon value; Public
Veriﬁability: Any third party can verify the correctness of the new beacon value.
Note: We use DRB protocols and DRBs interchangeably throughout the paper.
These formal security guarantees of a DRB protocol are evolved during the
time. Initial proposals lack the formal deﬁnitions and mathematical proofs of
their DRB protocols. Nevertheless, the recent proposals put an emphasis on
the security of their protocols. These protocols deﬁne and prove the security
properties of their DRB using the mathematical properties of the underlying
cryptographic primitives. Due to diﬀerent designs, setting up a formal provabil-
ity framework for DRBs should deﬁne the least common security requirements,
therefore, we formulate the desiderata of a DRB protocol as follows where λ is
a security parameter and negl(λ) is a negligible function of λ.

Deﬁnition 2. (Unpredictability) Let A(v1, . . . , ve, ste) be a probabilistic polyno-
mial time algorithm that receives the values v1, . . . , ve and the current state ste
as the input values. Let A outputs a value ve+f for any value (future rounds)
f ≥ 2, and for all rounds e ≥ 1. Then

Pr[A(v1, . . . , ve, ste) = ve+f ] ≤ negl(λ)

(1)

Deﬁnition 3. (Bias-Resistance) Let biti(ve) denotes the i-th bit in the binary
representation of ve, let b = |ve| is the number of bits of ve, and let Ai(v1, . . . , ve−1,
ste−1) for i = 1, . . . , b, be b probabilistic polynomial-time algorithms that receive
the values v1, . . . , ve−1 and the current state ste−1 as input and output one bit:
0 or 1. Then for every round e ≥ 1, every Ai( ) and for all i = 1, . . . , b

Pr[biti(ve) = Ai(v1, . . . , ve−1, ste−1)] ≤

Pr[biti(ve) = 0] ≤

1
2

+ negl(λ)

1
2

+ negl(λ)

(2)

(3)

More concretely, we say that a DRB protocol is Bias-resistant if predicting any
single bit of the random beacon output ve has only a non-negligible advantage
over the trivial guessing strategy that has a probability of 1/2.

Deﬁnition 4. (Availability) Let A be an adversary controlling a fraction of par-
ticipants and P h ⊆ P be a set of honest participants in the DRB protocol. Given
ve, πe, pp and ste−1, for every round e ≥ 1 and for every participant Pi ∈ P h

Pr[UpdateSt(ste−1, pp, ve, πe) (cid:54)= ste] ≤ negl(λ)

(4)

Deﬁnition 5. (Public Veriﬁability) Given VerifyRand( ) as a public probabilistic
polynomial-time algorithm run by an external veriﬁer Px /∈ P that receives ve, πe
and the state ste−1 at the end of round e as input values and outputs a bit 0 or
1 based on the veriﬁcation of ve using πe. Then for every round e ≥ 1

Pr[VerifyRand(ve, πe, ste−1) (cid:54)= 1] ≤ negl(λ)

(5)

SoK: Decentralized Randomness Beacon Protocols

5

3 DRB Classiﬁcation

We classify DRB protocols in two ways: Interactive and Non-Interactive. In-
teractive DRB protocols generate a beacon output in an interactive manner
which involves multiple rounds of communication among participants. However,
Non-Interactive DRB protocols do not involve interactions among participants
to produce a random beacon value for each round. Therefore, non-interactive
DRBs are preferable for decentralized applications. Nevertheless, the setup for
the public parameter generation can be interactive for both types of DRBs.

3.1

Interactive Decentralized Randomness Beacon Protocols

Interactive DRB protocols employ multiple rounds of interaction among partici-
pants in order to produce one beacon output. These protocols are constructed us-
ing interactive cryptographic primitives such as Publicly Veriﬁable Secret Shar-
ing (PVSS) or Interactive Threshold Signature Scheme. The existing interactive
DRB protocols are based on PVSS involving two logical rounds of coin-tossing
wherein the ﬁrst round, the participants broadcast commitments to their shares,
and further, these commitments are revealed in another round. Constructions of
DRBs with other interactive cryptographic primitives, we left as open problems.

Research Problem 1 Construct a DRB protocol based on interactive threshold
signature scheme with better complexity compared to existing interactive DRBs.

The main advantage of PVSS-based DRBs is that the generated randomness
is indistinguishable from uniform. Nevertheless, due to the interaction and broad-
cast, interactive DRBs incur high communication cost. Some of the PVSS-based
DRBs improve upon the general PVSS scheme to reduce the communication
complexity by utilizing a threshold version of PVSS or electing a committee to
perform PVSS or introducing a leader to relay the messages. Hence, these opti-
mized versions of DRB protocols can be used to obtain periodic fresh random-
ness in real-world applications. A PVSS scheme consists of a tuple of algorithms
(PVSS.Setup, PVSS.Share, PVSS.Verify, PVSS.Recon) described in Appendix B.

PVSS-based DRB protocols are mainly of two types: with leader [66,8,25]
and without leader [47,17,18]. In a leader-based protocol, a leader Le is elected
in each round e which is responsible for performing the distribution of the secret
shares of the PVSS scheme. A further illustration can be found in Appendix B.
Following we present a description of PVSS-based interactive DRB protocols.

– Ouroboros [47]: Ouroboros is a PoS-based blockchain where a set of elected
participants run the DRB protocol to fetch the randomness for the leader
election. It operates in two phases commit and reveal. In commit phase, par-
ticipants encrypt the shares for all other participants by running PVSS.Share
and submit the shares on the blockchain. In reveal phase, each participant
decrypts all the encrypted shares that are encrypted using his public key.
Then, each participant computes a local random value using all the decrypted
shares and posts it in the blockchain. Finally, a beacon output is computed
by performing an XOR operation on all the published local random values.

6

Mayank Raikwar and Danilo Gligoroski

– RandHound, RandHerd [69]: Syta et al. constructed scalable randomness gen-
eration protocols by following client-server architecture and threshold cryp-
tography. RandHound is a one-shot on-demand protocol to generate single
randomness. However, RandHerd is a beacon protocol that emits continuous
random values. RandHound divides the servers into groups, and each group
is responsible for running PVSS among the group members. RandHound em-
ploys the commit-reveal technique as deﬁned in Ouroboros for each group.
Finally, to produce global randomness in RandHound, a client operates on
all the received valid local randomness from each server group. RandHerd im-
proves upon the complexity of RandHound by leveraging communication trees
among the server groups and collective signing to produce beacon outputs.
– SCRAPE [17]: Cascudo et al. constructed an honest majority coin-tossing
protocol SCRAPE with guaranteed output delivery. It constructs a threshold
PVSS scheme where sharing, veriﬁcation, and reconstruction take only a linear
number of exponentiations compared to quadratic in basic PVSS scheme [67].
In SCRAPE, all participants have access to a ledger where messages are posted
similar to Ouroboros. Cascudo et al. constructed an eﬃcient share veriﬁcation
procedure with linear complexity by observing the fact that sharing a secret
using PVSS is equivalent to encoding the secret with a Reed Solomon error
correcting code [61]. The dealer in the PVSS scheme [67] not only encrypts
the shares but also commits to the shares. Therefore, to prove that shares in
encrypted shares are the same as shares in commitments, the eﬃcient share
veriﬁcation procedure involving error-correcting code is applied. SCRAPE im-
proves the computation and veriﬁcation cost compared to Ouroboros.

– HydRand [66]: HydRand improves upon the complexity of SCRAPE’s PVSS
protocol. HydRand works in rounds consisting of three phases: propose, ac-
knowledge and vote. In each round, a leader is selected deterministically from
the set of potential leaders and by using the last round randomness. In propose
phase, the leader reveals his previously committed value which is acknowl-
edged, signed and further broadcast by the other participants in acknowledge
phase. In vote phase, each participant performs some checks, including the
checks on the number of received acknowledgments. If the leader does not
reveal his secret, the secret is reconstructed using PVSS.Recon. The beacon
value is computed using the revealed secret and the last round randomness.
– ALBATROSS [18]: ALBATROSS signiﬁcantly improves, amortizes the com-
putation complexity of SCRAPE and provides a universal composability (UC)-
secure model. It shows eﬃciency gain through the packed Shamir secret shar-
ing scheme in PVSS or by using a linear t-resilient function to extract ran-
domness as a vector of random group elements. It utilizes Cooley-Tukey fast
Fourier transformation to amortize the complexity and for further improve-
ment, it uses (cid:80)-protocol to prove that the published sharing is correct. AL-
BATROSS provides two variants of UC security: 1) First variant uses UC-Non-
Interactive Zero-Knowledge (NIZK) proofs for discrete logarithm, 2) Second
variant introduces and uses a new primitive named “designated veriﬁer” homo-
morphic commitments where a sender can open a commitment for one speciﬁc
receiver. Later, the receiver can prove the same opening to a third party.

SoK: Decentralized Randomness Beacon Protocols

7

– RandPiper [8]: Bhat et al. constructed a reconﬁguration-friendly DRB proto-
col RandPiper with strong security guarantees and quadratic communication
complexity. It combines PVSS with State-Machine Replication protocol and
presents two protocols: GRandPiper and BRandPiper. GRandPiper is a com-
munication optimal DRB with strong unpredictability in the presence of a
static adversary. However, BRandPiper shows the best communication com-
plexity and the best possible unpredictability in case of a dynamic adversary.
– SPURT [25]: SPURT protocol constructs a new PVSS scheme using pairing
to produce beacon output and involves a leader. The new PVSS scheme relies
on Decisional Bilinear Diﬃe-Hellman (DBDH) assumption [12]. In addition,
SPURT uses State Machine Replication to lower the communication complex-
ity compared to the broadcast channel used by other DRBs e.g., HydRand.
SPURT operates in a semi-synchronous network and has no trusted setup.

3.2 Non-Interactive Decentralized Randomness Beacon Protocols

We categorize Non-Interactive DRB (NI-DRB) protocols based on the main con-
stituent cryptographic primitive, further, we illustrate these protocols in Table 1.

VDF-based These DRBs are based on stand-alone Veriﬁable Delay Function
VDF = (VDF.Setup, VDF.Eval, VDF.Verify) described in Appendix C. A VDF is
a function f : X → Y that takes a prescribed number of sequential steps to
compute the output and provides exponentially easy veriﬁcation of the output. In
a VDF-based DRB, the participants evaluate an Iteratively Sequential Function
(ISF) to generate their local random values. The veriﬁcation of these values can
be eﬃciently done using VDF.Verify. Due to the non-parallelizable property of
VDF, an adversary cannot bias the output of the random beacon.

Lenstra and Wesolowski [49] constructed a DRB protocol, Unicorn, using a
slow-time hash function named sloth. This function takes inputs from a set of
distrusting participants and outputs a random value. Keeping Unicorn protocol
as a successor to VDF, the following VDF-based DRB protocols are constructed.

– Minimal VDF Randomness Beacon [30]: Justin Drake constructed a minimal
randomness beacon using RANDAO [59] and VDF. RANDAO is a smart
contract based DRB where participants submit their local entropy to the smart
contract, and further, the smart contract produces a single global entropy.
RANDAO biasable entropy is used as input to the VDF to produce unbiasable
randomness. Nevertheless, there is no formal security analysis of this protocol.
– Continuous VDF [34]: Ephraim et al. presented a new notion of Continuous
Veriﬁable Delay Function (cVDF) by adapting Pietrzak scheme [57]. A cVDF
f provides the output computation of each intermediate steps (i.e. f (t) for
t < T ) with an eﬃcient proof πt (used for public veriﬁcation of the output).
A cVDF can be used to construct a DRB protocol where beacon outputs are
generated by applying a suitable hash to the intermediate outputs of each
step. The drawback with this protocol is that the nodes having the most
eﬃcient (fastest) processors can always learn the beacon outputs before the
other participating nodes. A similar argument goes for the Unicorn protocol.

8

Mayank Raikwar and Danilo Gligoroski

– RandRunner [65]: RandRunner leverages trapdoor VDF with strong unique-
ness to construct a DRB protocol. Each participant Pi of RandRunner initial-
izes its public parameter ppi with a corresponding trapdoor ski. The partic-
ipants exchange their public parameters and verify the received ones. Ran-
dRunner executes in consecutive rounds where in each round, a leader is
elected. Further, the leader tries to solve the VDF using its trapdoor, and
other participants attempt to solve the VDF using the common VDF.Eval al-
gorithm. The drawback with the RandRunner protocol is that once a powerful
adversary becomes a leader, it can keep corrupting the round leaders (e.g., via
DoS), withhold its output computed via trapdoor, and keep working on for
the next outputs for many subsequent rounds hence breaking unpredictability.
– RANDCHAIN [44]: RANDCHAIN is a competitive DRB where in each round,
nodes compete to be a leader which solely produces the beacon output. RAND-
CHAIN constructs a non-parallelizable Sequential Proof-of-Work (SeqPoW)
puzzle by employing VDF or Sloth. A node solves the SeqPoW puzzle by incre-
menting an ISF for a randomized time. RANDCHAIN works as a Nakamoto-
based blockchain where nodes synchronize their local blockchains and keep
solving the puzzle to mine new blocks to the main blockchain. RANDCHAIN
mimics a blockchain structure, so it can suﬀer from front-running (block with-
holding) attacks and can also have forks due to problems with blocks’ ﬁnality.

VRF-based These DRBs compute randomness using Veriﬁable Random Func-
tion VRF = (VRF.KeyGen, VRF.Eval, VRF.Verify) described in Appendix D. A
VRF is a pseudorandom function that produces pseudorandom output along
with proof about the correctness of the output. Participants in these DRBs
apply VRF on an input seed to generate their local entropy which is used to
compute the beacon output. VRF-based DRBs are explained as follows:

– Blockchain Protocol Designs: Ouroboros Praos [27], Algorand [39] and Er-
lond [33] blockchains have their DRB as a byproduct. In these DRBs, each
participant Pi runs VDF.Eval on a seed (e.g., previous output or state) using
its secret key ski and the DRB output is computed from the participants’ VRF
outputs. These DRBs do not guarantee generation of uniformly random values
and do not have strong bias-resistance as an adversary can include/exclude
the corrupted participants’ VRF outputs used for DRB output computation.
– Distributed VRF-based DRBs: A distributed VRF (DVRF) [29] based DRB
was ﬁrst introduced by DFINITY [45]. Later DRBs [22,24] employed DFINITY-
DVRF along with BLS cryptography. Nevertheless, these DRBs do not provide
formal security analysis. A recent paper [36] provides two new constructions
of DVRF: 1) DDH-DVRF based on elliptic curve cryptography; 2) GLOW-
DVRF based on cryptographic pairings. These constructions also formalize
a security model with proper security analysis. DRBs based on DDH-DVRF,
and GLOW-DVRF show strong bias resistance and strong pseudorandomness.
– RandChain [71]: RandChain follows commit-and-reveal strategy by building
a sub-routine RandGene using VRF. RandChain has a two-layer hierarchical
blockchain structure where nodes form distinct committees. Each committee

SoK: Decentralized Randomness Beacon Protocols

9

has a local blockchain and generates local entropy through the RandGene
protocol, further, global randomness is computed from these local entropy by
forming a RandChain block. RandChain security depends on a secure sharding
process, followed by a leader election for each shard (committee). However,
both processes can be inﬂuenced by an adversary to obstruct DRB properties.

HE-based These DRBs utilize homomorphic encryption scheme HE = (HE.Setup,
HE.KeyGen, HE.Enc, HE.Dec, HE.Eval). Homomorphic encryption allows perform-
ing arithmetic operations on ciphertext directly without decryption (details in
Appendix E). Following DRBs employ ElGamal encryption [32] as partial HE.

– Nguyen-Van et al. [55]: Their DRB has three components: a Requester, a Pub-
lic Distributed Ledger (PDL), and a Core Layer. The protocol works in rounds
where, ﬁrst, the Requester sends a nonce to the PDL that computes a ticket T
and publishes it. Further, participants of the core layer run a VRF using the
ticket T to check if they are selected as a contributor. Each contributor pub-
lishes a ciphertext computed on a random value using the Requester’s public
key. Later, the Requester performs a homomorphic operation on the published
ciphertexts and computes a single ciphertext. Finally, the Requester publishes
the decrypted value as DRB output with a proof of correct decryption. There
are two drawbacks: 1) A malleable ElGamal encryption, 2) The Requester can
collude with contributors or refuse to decrypt the resulting ciphertext.

– HERB [20]: Homomorphic Encryption Random Beacon (HERB) DRB uses
threshold ElGamal encryption scheme with a distributed key generation (DKG)
protocol. DKG is used to generate a common public key and secret key shares
for participants. Each participant publishes a ciphertext share with proof of
correct encryption (NIZK Proof) on a public bulletin board. These shares gen-
erate an aggregated ciphertext through ElGamal aggregation which is subse-
quently decrypted by a threshold of participants to produce the DRB output.

External Source-based In these DRBs, participants extract the randomness
from an external entropy source, i.e., real-world entropy. These entropy sources
can be public blockchains [14,7], real-time ﬁnancial data [21] or national lot-
tery results [3]. PoW-based blockchains are promising sources but an adversarial
miner can manipulate the generated randomness. Therefore, to achieve most of
the beacon properties, the following DRBs apply diﬀerent defense mechanisms.

– Rand Extractor [21]: Clark et al. [21] created a model to generate randomness
by combining the information theory with computational ﬁnance. They used
the closing prices of the stock market to compute a random output. During
the market’s closing in the day, one entity publishes this random output in the
protocol. This entity can also induce its own local entropy to transparently
construct a publicly veriﬁable ﬁnal randomness, but liveness is hard to achieve.
– Proofs of Delay [14]: In this DRB, a beacon smart contract (BC) publishes the
random beacon values on a public blockchain. The DRB is built on Proof-of-
Delay which uses an ISF such as sloth [49]. In this DRB, a beacon maintainer
executes this ISF and publishes the result to BC with queryable access to the

10

Mayank Raikwar and Danilo Gligoroski

Scheme

VDF-based

VRF-based

HE-based

Advantages
1. These DRBs achieve liveness under the period of full asynchrony.
2. These DRBs avoid byzantine agreement consensus hence have
less communication complexity.
3. It shows strong bias-resistance as long as there is an honest node.
1. Most of these DRBs do not have any trusted setup and achieve
strong notion of pseudo-randomness and bias-resistance [36].
2. These DRBs incur less computation and communication cost.
1. The output of these DRBs for a round e does not depend on the
output of the previous round e − 1.
2. Partial homomorphic encryption schemes used in these DRBs
can be replaced by a lattice-based fully homomorphic scheme to
ensure the post-quantum security.

External
Source
-based

1. These DRBs do not incur communication cost as the DRB
output is published in a public bulletin board.
2. These DRBs work perfectly even in the asynchronous network.

Threshold
Signature
-based

1. These DRBs provide strong bias resistance and unpredictability.
2. Consortium of organizations can participate to construct
such beacon due to threshold property (e.g. Drand [31]).

Disadvantages

1. Front-running attack can hinder some DRB properties.
2. In most of these DRBs, the signiﬁcant powerful adversary
can learn the output of DRB earlier than other nodes.
3. These protocols rely on the new assumptions of VDF.
1. In some of these DRBs, leader uniqueness is not
guaranteed that introduces additional consensus protocol
to agree on the beacon output.
1. Scalability issue due to the homomorphic evaluation of
multiple ciphertexts.
2. The existing DRBs use public ledger to publish the local
and global entropy. But distributing the local entropy in
DRBs using a consensus incur a high communication cost.
1. Most of these DRBs do not provide public veriﬁability.
2. Proof-of-Work based beacons are not energy eﬃcient and
nodes with better hardware can outperform other nodes in
producing the beacon output.
1. These DRBs require either a trusted setup or DKG, hence
do not oﬀer a reconﬁguration-friendly setup.
2. Security of the DRBs depend on the security assumptions
of elliptic curve pairings due to the use of BLS-signature.

Table 1. Advantages and Disadvantages of diﬀerent Non-Interactive DRB protocols

beacon output using a refereed delegation of computation protocol. To show
the honest behavior, the maintainer is incentivized; otherwise punished.

– Bitcoin Beacon [13] [7]: These DRBs extract randomness from the bitcoin
blockchain [53] and follows the security of the bitcoin. In [13], an extractor
fetches the randomness from the block headers. As each block contains several
transactions involving ECDSA signatures [37] that rely on strong randomness
for security hence, the extractor gives good public randomness as a beacon
output. Bentov et al. [7] constructed a bitcoin beacon protocol that fetches
m consecutive blocks B1, B2, . . . , Bm such that the block Bm already have l
subsequent blocks. Further, the protocol acquires a bit bi from each block and
runs a majority function on all these bits as input to get the DRB output.

Threshold Signature-based These DRBs are based on a non-interactive
threshold signature scheme that requires a single round of communication among
participants to produce the unique group signatures from a threshold number
of participants’ signature shares. Most of the existing threshold signature-based
DRBs employ threshold BLS signature. These DRBs require a setup to gener-
ate the secret shares for the participants. Additionally, the complexity of unique
signature construction comply with DRB protocol for practical use.

– Cachin et al. [16], Drand [31]: Cachin et al. presented a common coin protocol
using threshold signature along with a random-access coin-tossing scheme. In
this DRB, a trusted dealer distributes the secret key shares to the partici-
pants. The DRB output is a unique signature on the hash of a counter (epoch
number). Drand [31] follows a similar idea, but it replaces the threshold se-
cret to the threshold BLS key. Drand can be considered as an implementation
of the Cachin et al. scheme. Drand utilizes the DKG protocol of Gennaro et
al. [38] during the setup phase that yields a high communication complexity.
– DFINITY [45]: It also employs a threshold BLS signatures scheme but the
selection of the best initialization vector in the scheme creates a challenge. The
protocol works well even in the partial synchronous network model. It employs
a non-interactive DKG setup and achieves better communication complexity
than Drand. The DRB acts as a VRF that produces unbiasable output.

Note: We present Hybrid DRB protocols in Appendix F.

SoK: Decentralized Randomness Beacon Protocols

11

4 Discussion

4.1 Security Assumptions

The security of all these DRBs depends on well-deﬁned security assumptions.
These assumptions can be assumptions about the underlying network, adversary,
setup, or cryptographic primitives. If these assumptions are failed in some cases,
then the DRB using these assumptions will break its security properties.

– Cryptographic Assumptions (Primitive): As the above described DRBs are
based on cryptographic primitives such as PVSS, VDF, VRF, these DRBs
inherit the security assumptions from the primitives. These assumptions are
well-known hard problems of cryptography such as standard decisional or com-
putational Diﬃe-Hellman assumptions [10] (or their variants) depending on
the underlying cryptographic scheme (e.g., PVSS, DVRF). VDF-based DRBs
depend on the new security assumptions on sequential computation (e.g., it-
erated squaring over groups of unknown order [62]) that are not well studied
and understood in the current literature. Modeling of the hash function as a
random oracle [6] is also considered in security assumptions in some DRBs.
– Network Assumptions (Model): Most of the PVSS-based and VRF-based DRBs
assume a strong synchronous network which can be an unrealistic setting in
the real world. Hence, these DRBs require a lock-step synchronous network
where the messages are delivered before the end of each round. In case of no
lock-step synchrony, participants might employ round synchronization pro-
tocols [54,74]. Some of the DRBs work well in semi-synchronous network
where the messages are delivered within a known ﬁnite time-bound. VDF-
based and external-source-based DRBs work well in an asynchronous network
where messages are delivered without a known time-bound. However, the trust
of these models depends on the underlying setup assumptions or on the public
blockchain, where the local entropy of the participants are posted.

– Setup Assumptions: Many DRB protocols [31,20,8,69,45] require an initial
trusted setup assumption where private keys for the participants and uni-
formly random public parameters are generated by a trusted third party
(dealer) or by a distributed key generation (DKG) protocol. The Security
of DRBs with a trusted third party crucially depends on the action and abil-
ity of the trusted party. Nevertheless, DKG incurs a considerable setup cost
(high communication complexity) with its limitation of adding or replacing
the participants. Therefore, DKG-based DRBs are preferred when the par-
ticipants are ﬁxed. Hence, many recent DRB protocols [66,17,27,2,39] have a
transparent setup where the public parameters are trapdoor free.

Following the above security assumption, most of the DRB protocols perform
well in permissioned systems. However, permissionless systems have a highly dy-
namic set of nodes that maintain the system state. Due to the dynamically
changing participants, integrating an existing DRB with the system is challeng-
ing. Moreover, setting the assumption on a number of adversarial nodes is hard.

Research Problem 2 Study the hardness of embedding the existing DRB pro-
tocols in permissionless systems, based on Proof-of -Work (PoW) or -Stake (PoS).

12

Mayank Raikwar and Danilo Gligoroski

4.2 Complexity

DRB protocols following diﬀerent approaches exhibit diﬀerent complexity. Find-
ing a good balance between computation and communication complexity in a
DRB protocol is a challenging task. Therefore, an extensive amount of work has
been devoted to reduce the complexity of DRB protocols.

– Communication Complexity: Most of the interactive DRB protocols assume a
broadcast channel. Therefore, Ouroboros [47], RandShare [69], and SCRAPE
[17] have a communication complexity of O(n3) due to the broadcasting of
O(n) size message. HydRand [66] improves upon the communication complex-
ity to O(n2) by having a leader-based approach where a leader node performs
the PVSS share distribution. Relaying the messages through a single node to
reduce the communication complexity is also embraced by ALBATROSS [18],
GLOW [36]. RandHound, RandHerd [69], DFINITY [45] employ sharding to
sample a committee for output generation that results in lower communication
complexity. But such a procedure can be immediately subject to attacks by
an adaptive adversary who can corrupt the committee once it is determined.
Most of the non-interactive DRBs [27,39,14,55] have less communication com-
plexity as a successful participant (e.g., leader) usually need to perform one
broadcast. Therefore, it incurs the communication complexity in O(n). More-
over, most of the NI-DRBs involving blockchain [59,44] to publish shared local
and global randomness also have lower communication complexity.
DKG setup based DRBs [20,45,31,16] suﬀer from additional communication
cost. Complexity of DRBs can be improved using asynchronous data dissem-
ination (ADD) [26] or using hbACSS [75](for PVSS-based DRBs).
Research Problem 3 Design a DRB protocol with sub-quadratic communi-
cation complexity together with optimal fault-tolerance.

– Computation Complexity: It is deﬁned as the number of operations needed to
be performed by a participant during one round of DRB protocol. PVSS-based
protocols such as RandShare [69] and Ouroboros [47] requires a computation
complexity of O(n3). An improved version of PVSS further reduces this cost
in SCRAPE [17]. Puzzle-based DRBs [13,14] have a high computational cost
due to the involved puzzle. VDF-based DRBs also have the drawback of high
computational complexity due to the repeated squaring. On the contrary,
VRF-based DRBs incur a minimum computation cost.
Research Problem 4 Design a puzzle-based DRB protocol incurring low com-
putation complexity.

– Veriﬁcation Complexity Veriﬁcation cost refers to the number of operations
performed by an external participant to verify the output of a beacon protocol.
Although VDF-based DRBs have high computational costs, they do provide
eﬃcient veriﬁcation hence incur less veriﬁcation cost. The most eﬃcient DRB
protocols with regard to computation and veriﬁcation complexity are based
on VRF [27,39,71] or threshold crypto-systems [16,45,31,55].
Research Problem 5 Design a PVSS-based DRB protocol with a constant
veriﬁcation complexity, linear communication cost and no trusted setup.

SoK: Decentralized Randomness Beacon Protocols

13

4.3 Scalability

Despite a decade of research on DRB protocols, only quite a few recent DRBs
emphasize the scalability of their DRB. Scalability in a DRB protocol refers to
the number of participants it can support. Many of the described DRB protocols
do not oﬀer good scalability. Especially, DRBs involving DKG setup provide
poor scalability as DKG does not support frequent modiﬁcation in the set of
key holders. In addition, the high complexity along with the underlying network
model in many of these DRBs signiﬁcantly aﬀect the scalability of the DRBs.

A general approach for achieving good scalability is “sharding” which is
considered in recent DRBs, including RandHerd [69], DFINITY [45] and Al-
gorand [39] with the cost of slightly degrading the fault-tolerance. RandHerd
shows a direct consequence of the sharding where nodes are split into smaller
groups. Each group produces local entropy and each group’s entropy is com-
bined to produce the DRB output. Algorand and DFINITY show selection of a
committee to generate the DRB output. Therefore, this orthogonal technique of
randomly sampling a committee for protocol execution can improve scalability.
Another way for improving scalability is using a leader-based approach where
a leader relays the messages to the participants. Moreover, having a public ledger
where participants post their local entropy messages also improves scalability.

Reconﬁguration Friendliness directly impact scalability. A protocol is recon-
ﬁguration friendly when the parameters and list of participants can be changed
dynamically without aﬀecting the current execution. When there is no binding
between the setup and the system, the reconﬁguration becomes easier. DRBs
involving DKG setup are not reconﬁguration-friendly, hence poor scalability. On
the contrary, non-interactive DRBs (with no DKG) show better scalability.

Research Problem 6 Study the (im)possibility of designing a reconﬁguration-
friendly sub-quadratic DRB protocol that do not employ committee sampling.

4.4 Adversarial Model

Most of these DRBs consider a ﬁxed set of n nodes; out of these nodes, f nodes
may exhibit byzantine behavior. An adversary in these DRBs can be deﬁned as:
Active vs. Passive An active adversary actively modiﬁes the messages (e.g.,
public shares, DRB output) in DRB; a passive adversary observes the transcript
(i.e. messages) of an honest run of the DRB and predicts the DRB’s next output.
Adaptive vs. Static An adaptive adversary corrupts the nodes during the
protocol execution, while a static adversary does corruption before the execution.
An adversary can aﬀect the security guarantees of a DRB in many ways,
such as by trying to bias the produced random output, withholding the output,
predicting the future output, or tricking an outsider (third party) into accepting
invalid beacon output. Leader-based DRBs suﬀer from targeted attacks, how-
ever, blockchain-based DRBs suﬀer from blockchain-speciﬁc attacks. Moreover,
unpredictability can be aﬀected by network model.

Research Problem 7 Choose a static secure DRB protocol and transform it to
an adaptively secure DRB that retains the eﬃciency standard of the static one.

14

Mayank Raikwar and Danilo Gligoroski

Table 2. Comparison of Existing Decentralized Randomness Beacon Protocol

y
r
a
s
r
e
v
d
A
e
v
i
t
p
a
d
A

y
t
i
l
i
b
a
t
c
i
d
e
r
p
n
U

e
c
n
a
t
s
i
s
e
R
-
s
a
i
B

e
c
n
a
r
e
l
o
t
-
t
l
u
a
F

s
s
e
n
e
v
i
L

l
e
d
o
M
k
r
o
w
t
e
N

n
o
i
t
a
c
i
n
u
m
m
o
C

y
t
i
x
e
l
p
m
o
C

syn.

(cid:55) (cid:51) (cid:51) (cid:51) 1/2
O(n)
semi-syn. (cid:55) (cid:51) (cid:51)‡ (cid:55) 1/3(cid:5) O(cn)
(cid:51) (cid:51) (cid:51) (cid:51) 1/2 O(n3)
(cid:55) (cid:51) (cid:51) (cid:51) 1/3 O(n2)
(cid:55) (cid:51) (cid:51)‡ (cid:55) 1/2
O(n)

asyn.

syn.

syn.

syn.

syn.

syn.

asyn.

(cid:55) (cid:55)† (cid:51) (cid:51) 1/2
O(1)
semi-syn. (cid:55) (cid:51) (cid:51) (cid:51) 1/3 O(n2)
(cid:55) (cid:51) (cid:51) (cid:51) 1/2 O(n2)
(cid:55) (cid:51) (cid:51) (cid:51) 1/3
O(n)
(cid:55) (cid:51) (cid:51)‡ (cid:51) 1/2 O(n2)
(cid:55) (cid:51) (cid:51) (cid:51) 1/3 O(n2)∗
(cid:55) (cid:51) (cid:51)‡ (cid:51) 1/3 O(n2)
(cid:55) (cid:55) (cid:51) (cid:55) 1/2
O(n)
(cid:55) (cid:51) (cid:51) (cid:51) 1/2 O(n3)
semi-syn. (cid:51) (cid:51) (cid:51)‡ (cid:55) 1/2 O(n)(cid:63)
(cid:55) (cid:51) (cid:51) (cid:51) 1/2
O(n)

syn.

syn.

syn.

syn.

syn

syn.

syn.

syn.

(cid:55) (cid:51) (cid:51)‡ (cid:55) 1/2
O(n)
(cid:55) (cid:51) (cid:51) (cid:51) 1/3 O(cn)
(cid:51) (cid:51) (cid:51) (cid:51) 1/3
O(n)

n
o
i
t
a
t
u
p
m
o
C

y
t
i
x
e
l
p
m
o
C

n
o
i
t
a
c
ﬁ
i
r
e
V

y
t
i
x
e
l
p
m
o
C

O(log n)

O(n)

O(c)
O(n2)
O(n)

O(1)
VDF

O(n)

O(n)

O(n)
O(n2)
O(n)

O(n)

O(1)
O(n2)
O(1)

O(1)

O(1)

O(1)

O(1)

O(1)
O(n2)
O(n)

O(n)

c
i
h
p
a
r
g
o
t
p
y
r
C

e
v
i
t
i

m

i
r
P

PVSS

VRF

PVSS

Uniq. thr-sig.

Hash func.

VDF

BLS thr-sig.

Uniq. thr-sig.

DVRF

PVSS

PHE

PVSS

PHE, VRF

O(1)
O(n3)
O(1)(cid:63)

O(n)
O(n3)
O(1)(cid:63)
very high O(log ∆)◦ Hash func.
Hash func.
very high
O(1)

PVSS

VRF

O(cn)
VDF

O(n)

O(1)

syn.

syn.

VDF

asyn.

(cid:55) (cid:51) (cid:55) (cid:55) 1/2
O(1)
O(n)
(cid:55) (cid:51) (cid:51) (cid:51) 1/3 O(c2 log n) O(c2 log n) O(1)
(cid:55) (cid:51) (cid:51) (cid:51) 1/3 O(c2n)
O(c2n)
syn.
(cid:51) (cid:51) (cid:51)‡ (cid:51) 1/2 O(n2)
O(1)
asyn. (cid:51) (cid:55)(cid:12) (cid:51) (cid:51) 1/3 O(n3)
O(n3)
O(1)
O(1)
(cid:55) (cid:51) (cid:51) (cid:51) 1/2 O(n3)
O(n2)
semi-syn (cid:55) (cid:51) (cid:51) (cid:51) 1/3 O(n2)
O(n)
(cid:55) (cid:51)† (cid:51) (cid:51) 1/2
O(1)

O(c2n)
VDF
O(n3)
O(1)
O(n2)
O(n)
high

asyn.

O(1)

syn.

VRF

VDF

VDF

PVSS, CoSi

PVSS

VDF

VSS

Hash func.

PVSS

PVSS, Pairing (cid:51)

Sloth

(cid:51)

r
e
l
a
e
D
d
e
t
s
u
r
T
o
N

d
e
r
i
u
q
e
r

G
K
D
r
o

(cid:51)

(cid:51)

(cid:51)

(cid:55)

(cid:51)

(cid:51)

(cid:55)

(cid:55)

(cid:55)

(cid:51)

(cid:55)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:55)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

l
o
c
o
t
o
r
P

ALBATROSS [18]

Algorand [39]

BRandPiper [8]

Cachin et. al [16]

Caucus [2]

Continuous VDF [34]

DFINITY [45]

Drand [31]

GLOW [36]

GRandPiper [8]

HERB [20]

HydRand [66]

Nguyen-Van et. al [55]

Ouroboros [47]

Ouroboros Praos [27]

Proof-of-Delay [14]

Proof-of-Work [53]

RandChain [71]

RANDCHAIN [44]

RANDAO [59]

RandHerd [69]

RandHound [69]

RandRunner [65]

RandShare [69]

SCRAPE [17]

SPURT [25]

Unicorn [49]

Rand Extractor [21,13] asyn.± (cid:51) (cid:51)(cid:113) (cid:51) (cid:51) 1/2

Fault-tolerance refers to number of byzantine faults a DRB can tolerate and c is average committee
size.
‡ refers to probabilistic guarantees for unpredictability, and has a bound on the number of future rounds
an adaptive rushing adversary can predict the beacon output.
(cid:5) Due to the randomly sampling a committee of size c in Algorand, the fault-tolerance reduces slightly.
† The node with more computational power learns the beacon output earlier than others.
∗ HERB achieves communication complexity of O(n2) when nodes use Avalanche algorithm or public
blockchain to share their ciphertexts.
(cid:63) Ouroboros Praos is not a stand-alone DRB and does not describe randomness generation approach, so
the presented complexity does not account the additional complexity for communication or veriﬁcation.
◦ The veriﬁcation in beacon smart contract has complexity O(log ∆) in the security parameter ∆.
(cid:12) An additional synchrony assumption is needed to provide liveness in RandShare.
± DRB protocols built on public blockchain also follow the network structure of the respective
blockchain. Therefore,
(cid:113) Liveness can be hindered due to the limited availability of ﬁnancial data caused by closed exchanges
in [21] or due to the fork situation in the blockchain in [13].

[13] uses a synchronous network as it relies on the bitcoin blockchain.

SoK: Decentralized Randomness Beacon Protocols

15

Fig. 1. Overview of throughput for various DRB protocols

4.5 Throughput Evaluation

We report throughput of state-of-the-art public implementations of various DRBs
in Figure 1. DFINITY and SPURT operate on a semi-synchronous network but
BRandPiper, Drand, GLOW, and HydRand assume synchronous networks. The
network delay parameter in these DRBs directly aﬀects the throughput of DRBs.
Drand is a practically deployed DRB protocol. However, when the number of
nodes increases to more than 64, nodes in the DRand abort the DKG step of the
protocol, and yet it suﬀers from signiﬁcant network delay. For HydRand, we chose
the public implementation [64] available on Github. For BRandPiper, we depict
throughput for the Merkle-tree-based implementation, which is quantitatively
practical for real-world scenarios. For SPURT, we used the throughput values
directly from their paper. For DFINITY and GLOW, we followed the public
implementation [35] of DVRFs to get the throughput while assuming no failure.

4.6 Others

– Incentive Some DRBs [14,59] involve incentivizing or punishing the partic-
ipants to enforce fairness against rational adversaries. In particular, these
(dis)incentivizing approaches (e.g., [4]) are considered mostly in smart contract-
based DRBs. Putting an economic incentivization scheme to reward the par-
ticipants of beacon enforces the honest behavior from the participants. An
incentivization scheme can also reward the right computation or veriﬁcation.
Interesting research would be to create an incentive structure for a DRB.
– Output Uniqueness It states that the DRB produces a unique output even in
the presence of an adversary having the trapdoor information of honest par-
ticipants. It implies strong bias-resistance in DRBs. Therefore, DRBs such
as RandRunner [65], DFINITY [45] and GLOW [36] provide strong bias-
resistance due to their output uniqueness. Having this property also prevents
an adversary from manipulating the beacon output for any ﬁnancial gain.
– Universal Composability (UC) It is arguably one of the strongest security
guarantees. A UC-secure protocol ensures that the protocol can be employed
as a building block in more complex systems while preserving its security.
The earlier UC-secure DRBs [47] do not provide bias-resistance. The ﬁrst UC-
secure DRB ALBATROSS [18] leverages UC-secure NIZK proofs. UC-secure
time-lock puzzles (TLP) [5] can be scrutinized to construct a UC-secure DRB.

16

Mayank Raikwar and Danilo Gligoroski

5 New Components for Construction of DRB Protocols

There have been many new eﬃcient constructions of cryptographic primitives
in recent years. These primitives can be embedded as new building blocks or
replace old ones in the DRB protocols to improve the performance of DRBs.

– Using New Veriﬁable Functions: Gurkan et al. [42] constructed a new ag-
gregatable DKG scheme that leverages gossip instead of broadcast commu-
nication to reduce the communication complexity. Further, they introduced
an eﬃcient Veriﬁable Unpredictable Function (VUF) and combined it with
DKG. This threshold VUF can be utilized to construct a DRB protocol.
VDF-based DRBs can beneﬁt from the recent work [63] about batch veri-
ﬁcation of VDF in which the veriﬁcation of beacon outputs during the last
several rounds can be batched and veriﬁed eﬃciently. Work [52] on VDF can
be investigated and applied to construct a practical VDF-based DRB protocol.
Current DRBs are not Post-Quantum (PQ) secure (except DRB [50] that does
not depend on any third party to construct a quantum-safe beacon). Recent
constructions of Post-Quantum VRF [15] and Post-Quantum VDF [19] can be
carefully studied and applied to construct practical PQ-secure DRB protocols.
– Using New Threshold Signatures: Tomescu et al. [70] designed a fast BLS-
based threshold signature scheme (BLS-TSS). Their scheme has fast signature
aggregation and veriﬁcation. There are some DRBs that use the BLS signature
scheme. The new BLS-TSS scheme can be directly applied to these DRBs to
improve their performance. Otherwise, a new large-scale, simple DRB protocol
can be designed and implemented using this new BLS-TSS scheme.

– Using New Erasure Codes: All known Veriﬁable Secret Sharing (VSS) schemes
published so far in the open literature (without exception) use the well-known
Reed-Solomon codes [61]. Reed-Solomon codes are Maximum Distance Sepa-
rable (MDS) erasure codes of type (t, n), where the original message is equally
split in t parts and is encoded to n (where n > t) parts. In the recent decade,
the coding theory community constructed new MDS erasure codes. The most
signiﬁcant line of work was done by Dimakis et al., in [28] where they con-
structed Minimum Bandwidth Regenerating (MBR) codes (optimal in terms
of the repair bandwidth) and Minimum Storage Regenerating (MSR) codes
(optimal in terms of the storage). Soon after that, those MDS codes were
practically employed in Facebook data centers [60], and new variants of MDS
codes e.g. [73] were proposed. Therefore, it would be interesting to research
the potential replacement of the Reed-Solomon code in VSS schemes with
another MDS (MSR) code to improve the performance of VSS-based DRBs.

6 Conclusion

Within recent years, there has been a dramatic surge in the construction of
new Decentralized Randomness Beacon (DRB) protocols due to its emergence in
cryptographic protocols. We present the ﬁrst systematization of knowledge (SoK)
for the existing eﬀorts on DRB protocols. This SoK provides a comprehensive

SoK: Decentralized Randomness Beacon Protocols

17

review of the design paradigms and approaches of DRB protocols. This SoK can
serve as a starting point to explore DRB protocols and can help researchers or
practitioners to pick a DRB protocol well-suited for their application.

In this SoK, we presented basic standard deﬁnitions of a DRB protocol and
its required properties. We discussed the key components and the most signif-
icant features of DRB protocols and summarized the existing DRB protocols
in Table 2. We identiﬁed several research challenges related to the complexity,
scalability, and security of DRB protocols. We highlighted respective solutions to
encounter some of the challenges. Finally, we proposed promising research direc-
tions for the future design of DRB protocols by employing the new cryptographic
components that can help to advance the state-of-the-art of DRB protocols.

References

1. Adida, B.: Helios: Web-based open-audit voting. In: USENIX security symposium.

vol. 17, pp. 335–348 (2008)

2. Azouvi, S., McCorry, P., Meiklejohn, S.: Winning the caucus race: Continuous
leader election via public randomness. arXiv preprint arXiv:1801.07965 (2018)
3. Baigneres, T., Delerablée, C., Finiasz, M., Goubin, L., Lepoint, T., Rivain, M.: Trap
me if you can-million dollar curve. IACR Cryptol. ePrint Arch. p. 1249 (2015)
4. Baum, C., David, B., Dowsley, R.: Insured mpc: Eﬃcient secure computation with
ﬁnancial penalties. In: International Conference on Financial Cryptography and
Data Security. pp. 404–420. Springer (2020)

5. Baum, C., David, B., Dowsley, R., Nielsen, J.B., Oechsner, S.: Tardis: A foundation
of time-lock puzzles in uc. In: Annual International Conference on the Theory and
Applications of Cryptographic Techniques. pp. 429–459. Springer (2021)

6. Bellare, M., Rogaway, P.: Random oracles are practical: A paradigm for designing
eﬃcient protocols. In: Proceedings of the 1st ACM Conference on Computer and
Communications Security. pp. 62–73 (1993)

7. Bentov,

I., Gabizon, A., Zuckerman, D.: Bitcoin beacon. arXiv preprint

arXiv:1605.04559 (2016)

8. Bhat, A., Shrestha, N., Kate, A., Nayak, K.: Randpiper-reconﬁguration-friendly
random beacons with quadratic communication. IACR Cryptol. ePrint Arch. 2020,
1590 (2020)

9. Blum, M.: Coin ﬂipping by telephone a protocol for solving impossible problems.

ACM SIGACT News 15(1), 23–27 (1983)

10. Boneh, D.: The decision diﬃe-hellman problem. In: International Algorithmic

Number Theory Symposium. pp. 48–63. Springer (1998)

11. Boneh, D., Bonneau, J., Bünz, B., Fisch, B.: Veriﬁable delay functions. In:
Shacham, H., Boldyreva, A. (eds.) Advances in Cryptology – CRYPTO 2018. pp.
757–788. Springer International Publishing, Cham (2018)

12. Boneh, D., Lynn, B., Shacham, H.: Short signatures from the weil pairing. In: In-
ternational conference on the theory and application of cryptology and information
security. pp. 514–532. Springer (2001)

13. Bonneau, J., Clark, J., Goldfeder, S.: On bitcoin as a public randomness source.

IACR Cryptol. ePrint Arch. 2015, 1015 (2015)

14. Bünz, B., Goldfeder, S., Bonneau, J.: Proofs-of-delay and randomness beacons in
ethereum. IEEE Security and Privacy on the blockchain (IEEE S&B) (2017)

18

Mayank Raikwar and Danilo Gligoroski

15. Buser, M., Dowsley, R., Esgin, M.F., Kermanshahi, S.K., Kuchta, V., Liu, J.K.,
Phan, R., Zhang, Z.: Post-quantum veriﬁable random function from symmetric
primitives in pos blockchain. IACR Cryptol. ePrint Arch. 2021, 302 (2021)
16. Cachin, C., Kursawe, K., Shoup, V.: Random oracles in constantinople: Practi-
cal asynchronous byzantine agreement using cryptography. Journal of Cryptology
18(3), 219–246 (2005)

17. Cascudo, I., David, B.: Scrape: Scalable randomness attested by public entities.
In: International Conference on Applied Cryptography and Network Security. pp.
537–556. Springer (2017)

18. Cascudo, I., David, B.: Albatross: publicly attestable batched randomness based
on secret sharing. In: International Conference on the Theory and Application of
Cryptology and Information Security. pp. 311–341. Springer (2020)

19. Chavez-Saab, J., Henríquez, F.R., Tibouchi, M.: Veriﬁable isogeny walks: Towards
an isogeny-based postquantum vdf. Cryptology ePrint Archive, Report 2021/1289
20. Cherniaeva, A., Shirobokov, I., Shlomovits, O.: Homomorphic encryption random

beacon. IACR Cryptol. ePrint Arch. 2019, 1320 (2019)

21. Clark, J., Hengartner, U.: On the use of ﬁnancial data as a random beacon.

EVT/WOTE 89 (2010)

22. Corestar: Corestar arcade: Tendermint-based byzantine fault tolerant (bft) mid-

dleware with an embedded bls-based random beacon (2019)

23. Croman, K., Decker, C., Eyal, I., Gencer, A.E., Juels, A., Kosba, A., Miller, A.,
Saxena, P., Shi, E., Sirer, E.G., et al.: On scaling decentralized blockchains. In:
International conference on ﬁnancial cryptography and data security. pp. 106–125.
Springer (2016)

24. DAOBet: Daobet to deliver on-chain random beacon based on bls cryptography

(2019), https://daobet.org/blog/on-chain-random-generator/

25. Das, S., Krishnan, V., Isaac, I.M., Ren, L.: Spurt: Scalable distributed randomness
beacon with transparent setup. IACR Cryptol. ePrint Arch. 2021, 100 (2021)
26. Das, S., Xiang, Z., Ren, L.: Asynchronous data dissemination and its applications.

IACR Cryptol. ePrint Arch. (2021)

27. David, B., Gaži, P., Kiayias, A., Russell, A.: Ouroboros praos: An adaptively-
secure, semi-synchronous proof-of-stake blockchain. In: Annual International Con-
ference on the Theory and Applications of Cryptographic Techniques. pp. 66–98.
Springer (2018)

28. Dimakis, A.G., Godfrey, P.B., Wu, Y., Wainwright, M.J., Ramchandran, K.: Net-
work coding for distributed storage systems. IEEE Trans. Inf. Theory 56(9), 4539–
4551 (Sept 2010). https://doi.org/10.1109/TIT.2010.2054295

29. Dodis, Y.: Eﬃcient construction of (distributed) veriﬁable random functions. In:

International Workshop on Public Key Cryptography. pp. 1–17. Springer (2003)

30. Drake, J.: Minimal vdf randomness beacon. Ethereum Research (2018)
31. drand: Drand - a distributed randomness beacon daemon (2020), https://github.

com/drand/drand

32. ElGamal, T.: A public key cryptosystem and a signature scheme based on discrete
logarithms. IEEE transactions on information theory 31(4), 469–472 (1985)
33. Elrond, A.: Highly scalable public blockchain via adaptive state sharding and secure

proof of stake (2019)

34. Ephraim, N., Freitag, C., Komargodski, I., Pass, R.: Continuous veriﬁable delay
functions. In: Annual International Conference on the Theory and Applications of
Cryptographic Techniques. pp. 125–154. Springer (2020)

35. Fetch.ai.: Distributed veriﬁable random functions: an enabler of decentralized ran-

dom beacons (2020), https://github.com/fetchai/research-dvrf

SoK: Decentralized Randomness Beacon Protocols

19

36. Galindo, D., Liu, J., Ordean, M., Wong, J.M.: Fully distributed veriﬁable random
functions and their application to decentralised random beacons. IACR Cryptol.
ePrint Arch. 2020, 96 (2020)

37. Gennaro, R., Goldfeder, S., Narayanan, A.: Threshold-optimal dsa/ecdsa signa-
tures and an application to bitcoin wallet security. In: International Conference on
Applied Cryptography and Network Security. pp. 156–174. Springer (2016)

38. Gennaro, R., Jarecki, S., Krawczyk, H., Rabin, T.: Secure distributed key gen-
eration for discrete-log based cryptosystems. In: International Conference on the
Theory and Applications of Cryptographic Techniques. pp. 295–310 (1999)

39. Gilad, Y., Hemo, R., Micali, S., Vlachos, G., Zeldovich, N.: Algorand: Scaling
byzantine agreements for cryptocurrencies. In: Proceedings of the 26th symposium
on operating systems principles. pp. 51–68 (2017)

40. Goel, S., Robson, M., Polte, M., Sirer, E.: Herbivore: A scalable and eﬃcient pro-

tocol for anonymous communication. Tech. rep., Cornell University (2003)

41. Goulet, D., Kadianakis, G.: Random number generation during tor voting. Tor’s

protocol speciﬁcations-Proposal 250 (2015)

42. Gurkan, K., Jovanovic, P., Maller, M., Meiklejohn, S., Stern, G., Tomescu, A.:
Aggregatable distributed key generation. In: Annual International Conference on
the Theory and Applications of Cryptographic Techniques. pp. 147–176. Springer
(2021)

43. Haahr, M.: Random.org: True random number service. School of Computer Science

and Statistics, Trinity College, Dublin, Ireland 10 (2010)

44. Han, R., Yu, J., Lin, H.: Randchain: Decentralised randomness beacon from se-

quential proof-of-work. IACR Cryptol. ePrint Arch. 2020, 1033 (2020)

45. Hanke, T., Movahedi, M., Williams, D.: Dﬁnity technology overview series, con-

sensus system. arXiv preprint arXiv:1805.04548 (2018)

46. Kelsey, J., Brandão, L.T., Peralta, R., Booth, H.: A reference for randomness
beacons: Format and protocol version 2. Tech. rep., National Institute of Standards
and Technology (2019)

47. Kiayias, A., Russell, A., David, B., Oliynykov, R.: Ouroboros: A provably secure
proof-of-stake blockchain protocol. In: Annual International Cryptology Confer-
ence. pp. 357–388. Springer (2017)

48. Kosba, A., Miller, A., Shi, E., Wen, Z., Papamanthou, C.: Hawk: The blockchain
model of cryptography and privacy-preserving smart contracts. In: 2016 IEEE
symposium on security and privacy (SP). pp. 839–858 (2016)

49. Lenstra, A.K., Wesolowski, B.: A random zoo: sloth, unicorn, and trx. IACR Cryp-

tol. ePrint Arch. 2015, 366 (2015)

50. Li, Z., Tan, T.G., Szalachowski, P., Sharma, V., Zhou, J.: Post-quantum vrf and

its applications in future-proof blockchain system (2021)

51. LoE: League of entropy : Decentralized randomness beacon (2019), https://www.

cloudflare.com/it-it/leagueofentropy/

52. Loe, A.F., Medley, L., O’Connell, C., Quaglia, E.A.: A practical veriﬁable delay

function and delay encryption scheme. Cryptology ePrint Archive (2021)

53. Nakamoto,

S.:

Bitcoin:

A

peer-to-peer

electronic

cash

system,

http://bitcoin.org/bitcoin.pdf (2009)

54. Naor, O., Baudet, M., Malkhi, D., Spiegelman, A.: Cogsworth: Byzantine view

synchronization. arXiv preprint arXiv:1909.05204 (2019)

55. Nguyen-Van, T., Nguyen-Anh, T., Le, T.D., Nguyen-Ho, M.P., Nguyen-Van, T.,
Le, N.Q., Nguyen-An, K.: Scalable distributed random number generation based on
homomorphic encryption. In: 2019 IEEE International Conference on Blockchain
(Blockchain). pp. 572–579. IEEE (2019)

20

Mayank Raikwar and Danilo Gligoroski

56. Oraclize.it: Provable random number generator, https://provable.xyz
57. Pietrzak, K.: Simple veriﬁable delay functions. In: 10th innovations in theoretical

computer science conference (itcs 2019) (2018)

58. Rabin, M.O.: Transaction protection by beacons. Journal of Computer and System

Sciences 27(2), 256–267 (1983)

59. Randao: Randao: A dao working as rng of ethereum, https://github.com/

randao/randao., [Online; accessed 1-Nov-2021]

60. Rashmi, K.V., Shah, N.B., Gu, D., Kuang, H., Borthakur, D., Ramchandran, K.:
A solution to the network challenges of data recovery in erasure-coded distributed
storage systems: A study on the facebook warehouse cluster. In: 5th USENIX
Workshop on Hot Topics in Storage and File Systems. USENIX (2013)

61. Reed, I.S., Solomon, G.: Polynomial codes over certain ﬁnite ﬁelds. Journal of the

society for industrial and applied mathematics 8(2), 300–304 (1960)

62. Rivest, R.L., Shamir, A., Wagner, D.A.: Time-lock puzzles and timed-release

crypto. . (1996)

63. Rotem, L.: Simple and eﬃcient batch veriﬁcation techniques for veriﬁable delay

functions. Cryptology ePrint Archive (2021)

64. Schindler, P.: Hydrand, https://github.com/PhilippSchindler/hydrand
65. Schindler, P., Judmayer, A., Hittmeir, M., Stifter, N., Weippl, E.: Randrunner:
Distributed randomness from trapdoor vdfs with strong uniqueness. IACR Cryptol.
ePrint Arch. 2020, 942 (2020)

66. Schindler, P., Judmayer, A., Stifter, N., Weippl, E.: Hydrand: Eﬃcient continuous
distributed randomness. In: 2020 IEEE Symposium on Security and Privacy (SP).
pp. 73–89. IEEE (2020)

67. Schoenmakers, B.: A simple publicly veriﬁable secret sharing scheme and its appli-
cation to electronic voting. In: Annual International Cryptology Conference. pp.
148–164. Springer (1999)

68. Shumow, D., Ferguson, N.: On the possibility of a back door in the nist sp800-90

dual ec prng. In: Proc. Crypto. vol. 7 (2007)

69. Syta, E., Jovanovic, P., Kogias, E.K., Gailly, N., Gasser, L., Khoﬃ, I., Fischer, M.J.,
Ford, B.: Scalable bias-resistant distributed randomness. In: 2017 IEEE Sympo-
sium on Security and Privacy (SP). pp. 444–460. Ieee (2017)

70. Tomescu, A., Chen, R., Zheng, Y., Abraham, I., Pinkas, B., Gueta, G.G., De-
vadas, S.: Towards scalable threshold cryptosystems. In: 2020 IEEE Symposium
on Security and Privacy (SP). pp. 877–893 (2020)

71. Wang, G., Nixon, M.: Randchain: Practical scalable decentralized randomness
attested by blockchain. In: 2020 IEEE International Conference on Blockchain
(Blockchain). pp. 442–449. IEEE (2020)

72. Wesolowski, B.: Eﬃcient veriﬁable delay functions. In: Ishai, Y., Rijmen, V. (eds.)
Advances in Cryptology – EUROCRYPT 2019. pp. 379–407. Springer International
Publishing, Cham (2019)

73. Ye, M., Barg, A.: Explicit constructions of high-rate mds array codes with optimal
repair bandwidth. IEEE Transactions on Information Theory 63(4), 2001–2014
(2017)

74. Yin, M., Malkhi, D., Reiter, M.K., Gueta, G.G., Abraham, I.: Hotstuﬀ: Bft consen-
sus with linearity and responsiveness. In: Proceedings of the 2019 ACM Symposium
on Principles of Distributed Computing. pp. 347–356 (2019)

75. Yurek, T., Luo, L., Fairoze, J., Kate, A., Miller, A.K.: hbacss: How to robustly

share many secrets. IACR Cryptol. ePrint Arch. 2021, 159 (2021)

SoK: Decentralized Randomness Beacon Protocols

21

A Secure DRB Protocol

A DRB protocol is said to be secure if for any probabilistic polynomial-time
adversary A corrupting at most t parties in a round e, in a security game G
played between the adversary A and a challenger C, A has negligible advantage.

1. C executes the setup and sends the public parameters of the system to A.
2. A corrupts up to t participants and informs about t corrupted nodes to C.
3. C creates the secret and public keys of honest nodes and sends the public

keys of honest nodes to A.

4. A sends the remaining public parameters (e.g. public keys) of t nodes to C.
5. C and A runs the protocol execution interactively per round where:

(a) C sends all the honest participants’ messages to A.
(b) A decides on the delivery (sends / does not send) of the messages.
(c) At the end of a round e, an honest node outputs the protocol transcript.
6. C samples a bit b ∈ {0, 1} and sends either the DRB output based on tran-

script or a random element.

7. A makes a guess b(cid:48) and the advantage of A is deﬁned as | Pr[b = b(cid:48)] − 1

2 |.

B Publicly Veriﬁable Secret Sharing (PVSS)

In a PVSS scheme, a dealer shares a randomly selected secret s among a set of
n nodes using an (n, t + 1) threshold access-structure. That means, secret s can
be recovered from a set of t + 1 valid shares.

Deﬁnition 6. (PVSS): It is deﬁned as a collection of following algorithms:

– Setup(λ): Given a security parameter λ, generates the public parameters pp
and the public-private key-pair for each node, output the public parameter and
public keys (pp, pk). pp is an implicit input to all the other algorithms.

– Share(s): For a randomly chosen secret s, a dealer creates the secret shares
for each node (cid:126)S = (s1, s2, . . . , sn) along with the encryption of the shares
(cid:126)E = (c1, c2, . . . , cn) where ci = Enc(si) and proof of correct encryption (cid:126)π =
(π1, π2, . . . , πn). It outputs ((cid:126)S, (cid:126)E, (cid:126)π).

– Verify( (cid:126)E, (cid:126)π): Given the encrypted shares and the proofs, any external V can

non-interactively veriﬁes if the sharing is correct. It outputs 0 or 1.

– Recon((cid:126)S): Given valid set (cid:126)S ⊆ {s1, s2, . . . , sn}t+1 of t + 1 decrypted shares, it

reconstructs the secret and outputs s.

In a DRB protocol involving a leader, once the setup phase is completed, for
the round e, ﬁrst a leader election algorithm LeaderElec(e, Oe−1, P1, P2, . . . , Pn)
is executed and a leader Le is selected. The election algorithm can be round-robin
selection or sampling uniformly at random. The leader Le chooses a secret value
sLe (either a new value or previously committed value in the previous round)
and executes the PVSS scheme for secret sLe . At the end of round e, DRB
output Oe is generated using the reconstructed secret and the previous round

22

Mayank Raikwar and Danilo Gligoroski

Fig. 2. PVSS-based DRB protocols with and without leader

(or rounds’) output value. Figure 2 depicts leader and non-leader-based DRB
protocols. In the ﬁrst sub-ﬁgure, a leader is elected, followed by leader’s secret is
shared and beacon output is produced. In the second sub-ﬁgure, all participants
randomly choose secrets at the start of the round and further share the encrypted
shares of the secret to all the other participants. In the ﬁnal stage, the ﬁrst n-t
reconstructed (or decrypted) shares are used to obtain beacon output.

Deﬁnition 7. (PVSS-based Interactive Decentralized Randomness Beacon (I-
DRB)) Given a set of participants P = (P1, P2, . . . , Pn), a PVSS-based I-DRB
without leader can be deﬁned as a tuple B of polynomial-time algorithms:
B = (Setup, Share, Verify, Recon, Aggregation)

– Setup(e, λ): Set the round e = 1. Run PVSS.Setup(λ) and generate public

parameter pp and key-pairs (ski, pki) for each participant.

– Share(e): For a round e, each participant Pi runs PVSS.Share(si) for a ran-
domly chosen value si from the input space and gets ((cid:126)Si, (cid:126)Ei, (cid:126)πi). Pi shares the
encrypted shares and corresponding proofs ( (cid:126)Ei, (cid:126)πi) with other participants.
– Verify(e, { (cid:126)E, (cid:126)π}): Each party Pj runs the share veriﬁcation algorithm PVSS.Verify
( (cid:126)Ei, (cid:126)πi); ∀i, i (cid:54)= j on every shared secret. Let C be the set of ﬁrst n − t partici-
pants who have correctly shared their random secret values.

– Recon(e, {(cid:126)Si}): Each party Pi in C opens the Shamir secret si and the ran-
domness used, other participants Pj; ∀j, j (cid:54)= i verify if it is consistent with
sharing posted during Share phase. If a party Pi refuses to open its secret si,
the secret is reconstructed by executing PVSS.Recon((cid:126)Si).

– Aggregation(e, {si}): Once the valid decrypted or reconstructed shares are avail-
able for the parties Pi ∈ C. The beacon output is generated by executing a
function f on input a set of valid shares {si}. This function f takes all the
valid shares {si} (additionally previous beacon outputs) as input and aggre-
gates these input values to generate the beacon output Oe for round e.

LSecretsLShare Distribution PhaseP1P2PnShare  Verification PhaseSecret  Reconstruction PhasesLAggregation PhaseBeacon Output OeLeader Election for Round eShare Distribution PhaseP1P2PnShare  Verification PhaseSecret  Reconstruction PhaseFirsts1, s2,..  .., sn-t secretsAggregation PhaseBeacon Output OeP1P2Pns1s2snSecretsRound eSoK: Decentralized Randomness Beacon Protocols

23

C Veriﬁable Delay Function (VDF)

Veriﬁable delay function f : X → Y was deﬁned formally by Boneh et al. [11].
After the introduction of VDF, two new proposals [72] [57] were presented. A
VDF has properties of Sequentiality, Uniqueness and (cid:15)-Evaluation time.

Deﬁnition 8. (VDF): A VDF is deﬁned as a tuple of following algorithms:

– Setup(λ, T ): It is a randomized algorithm that takes security parameter λ, time
parameter T and outputs public parameter pp := (G, N, H, T ), where G is a
ﬁnite abelian group of unknown order, N is an RSA modulus, and H : X → G
is a hash function.

– Eval(pp, x, T ): The evaluation algorithm applies T squarings in G starting with
H(x) and outputs the value y ← H(x)(2T )mod N , along with a proof π.
– Verify(pp, x, y, π, T ): The veriﬁcation algorithm outputs a bit ∈ {0, 1}, given
the input as public parameter pp, input value x, output value y, proof π, and
time parameter T .

D Veriﬁable Random Function (VRF)

VRF has properties of Uniqueness, Collision resistance and Pseudorandomness.

Deﬁnition 9. (VRF): A VRF is deﬁned as a tuple of following algorithms:

– KeyGen(r): On input value r, the algorithm generates a secret key sk and a

veriﬁcation key vk.

– Eval(sk, M ): Evaluation algorithm produces pseudorandom output O and the

corresponding proof π on input sk and a message M .

– Verify(vk, M, O, π): Verify algorithm outputs 1 if and only if the output pro-
duced by evaluation algorithm is O and it is veriﬁed by the proof π given the
veriﬁcation key vk and the message M .

E Homomorphic Encryption (HE)

Deﬁnition 10. (HE): An HE scheme is deﬁned as a set of following alogorithms:

– Setup(1λ): Given security parameter λ, Output global parameters params.
– KeyGen(params): Given global parameters param, output a public-private key-

pair (pk, sk).

– Enc(params, pk, µ): Given a message µ ∈ RM, output a ciphertext c.
– Dec(params, sk, c): Given a ciphertext c, output a message µ∗ ∈ RM.
– Eval(pk, f, c1, ..., cl): Given the inputs as public key pk, a function f : Rl

M →
RM which is an arithmetic circuit over RM, and a set of l ciphertexts c1, ..., cl,
output a ciphertext cf .

24

Mayank Raikwar and Danilo Gligoroski

In the above scheme, the message space M of the encryption schemes is a ring
RM, and the functions to be evaluated are represented as arithmetic circuits over
this ring, composed of addition and multiplication gates. HE can be categorized
into: Partially HE that supports only addition or multiplication; Somewhat HE
that allows both operations but with limited times; Fully HE that supports
arbitrary computation by allowing both operations with unlimited times.

F Hybrid DRB Protocols

There are many more DRB protocols. Some of these protocols use more than one
crypto primitive to achieve all DRB properties with better eﬃciency/optimization.

– Mt. Random (PVSS + T(VRF))(eprint 2021/1096): It is a multi-tiered DRB
protocol that combines PVSS, VRF, and Threshold VRF (TVRF) to construct
a DRB with optimal eﬃciency and without compromising security guarantees
of DRB. It is a ﬂexible architecture for DRB where each tier runs a separate
beacon based on PVSS, VRF, and TVRF, and output of one tier works as
a seed for the next tier. Being constructed using diﬀerent crypto-primitives,
each tier diﬀers in the provided randomness and complexity. Due to that, a
high-level application can decide on which tier to use to obtain randomness.
– Harmony (VRF + VDF)(https://harmony.one/whitepaper.pdf): Harmony is
a sharding-based, provably secure, and scalable blockchain. In Harmony, nodes
compute local entropy by executing VRF using their secret keys. DRB output
is computed using VDF where the input for the VDF is constructed from
a threshold number of VRF evaluations from pairwise diﬀerent nodes. DRB
output is made pseudorandom by applying a random oracle on VDF output.
– CRAFT (TLP + VDF)(eprint 2020/784): Baum et. al ﬁrst construct UC-
secure publicly veriﬁable TLP and UC-secure VDF. To construct DRB, they
replace the commitments with the UC-secure TLP in the standard commit-
reveal coin-tossing protocol. Their construction achieves O(n) communication
to generate DRB output. DRB output can be obtained as fast as the commu-
nication channel delay allows when nodes communicate their TLPs faster.
– VeeDo (STARK+VDF)(https://github.com/starkware-libs/veedo): It is based
on STARK-based VDF. STARK is a post-quantum secure zero-knowledge
proof protocol. VeeDo is a smart-contract-based DRB where a beacon smart
contract and a veriﬁer smart contract is placed on-chain. However, heavy com-
putational parts involving VDF and STARK prover are kept oﬀ-chain. A VDF
is run on a seed s from a block hash to compute the DRB output and a proof
is computed using the STARK prover. The VDF output and the proof are
sent to the on-chain contracts for veriﬁcation and subsequently publishing.
– STROBE (RSA-based)(eprint 2021/1643): It is a history-generating DRB
(HGDRB). It allows eﬃcient generation of previous beacon outputs given only
the current beacon value and public key. It is based on origin squaring based
RSA approach of Beaver. It is well-suited for practical applications especially
in streaming designs where it allows client software to generate game states

SoK: Decentralized Randomness Beacon Protocols

25

by computing every missing beacon value and state. It is NIZK-free, concisely
self-verifying and can be eﬃciently used in blockchain and voting systems.
– OptRand (Bilinear paring-based PVSS + NIZK)(eprint 2022/193): It is an
optimally responsive DRB protocol. It employs a pairing-based PVSS scheme
together with a NIZK proof system to produce DRB outputs. Despite the syn-
chrony of the network, it can provide an optimal response and can progress.
Therefore, OptRand can provide availability at actual network speed during
optimistic conditions. It is reconﬁguration-friendly and has low communica-
tion complexity and low latency while generating beacon outputs.

