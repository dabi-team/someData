2
2
0
2

p
e
S
7
2

]

R
C
.
s
c
[

3
v
0
4
9
0
0
.
8
0
2
2
:
v
i
X
r
a

Maximal Extractable Value (MEV) Protection on a DAG

Dahlia Malkhi and Pawel Szalachowski
Chainlink Labs

ABSTRACT
Many cryptocurrency platforms are vulnerable to Maximal Ex-
tractable Value (MEV) attacks [12], where a malicious consensus
leader can inject transactions or change the order of user transac-
tions to maximize its profit.

A promising line of research in MEV mitigation is to enhance
the Byzantine fault tolerance (BFT) consensus core of blockchains
by new functionalities, like hiding transaction contents, such that
malicious parties cannot analyze and exploit them until they are
ordered. An orthogonal line of research demonstrates excellent
performance for BFT protocols designed around Directed Acyclic
Graphs (DAG). They provide high throughput by keeping high net-
work utilization, decoupling transactionsâ€™ dissemination from their
metadata ordering, and encoding consensus logic efficiently over a
DAG representing a causal ordering of disseminated messages.

This paper explains how to combine these two advances. It in-
troduces a DAG-based protocol called Fino, that integrates MEV-
resistance features into DAG-based BFT without delaying the steady
spreading of transactions by the DAG transport and with zero mes-
sage overhead. The scheme operates without complex secret share
verifiability or recoverability, and in the happy path, avoids costly
threshold encryption.

1 INTRODUCTION
1.1 MEV
Over the last few years, we have seen exploding interest in cryp-
tocurrency platforms and applications built upon them, like decen-
tralized finance protocols offering censorship-resistant and open
access to financial instruments; or non-fungible tokens. Many of
these systems are vulnerable to MEV attacks, where a malicious
consensus leader can inject transactions or change the order of
user transactions to maximize its profit. Thus it is not surprising
that at the same time we have witnessed rising phenomena of MEV
professionalization, where an entire ecosystem of MEV exploita-
tion, comprising of MEV opportunity "searchers" and collaborating
miners, has arisen.

Daian et al. [12] introduced a measure of the â€œprofit that can
be made through including, excluding, or re-ordering transactions
within blocksâ€. The original work called the measure miner ex-
tractable value, which was later extended by maximal extractable
value (MEV) [33] and blockchain extractable value (BEV) [36], to
include other forms of attacks, not necessarily performed by miners.
At the time of this writing, an â€œMEV-exploreâ€ tool [1] estimates the
amount of MEV extracted on Ethereum since the 1st of Jan 2020 to
be close to $700M. However, it is safe to assume that the total MEV
extracted is much higher, since MEV-explore limits its estimates
to only one blockchain, a few protocols, and a limited number of
detectable MEV techniques. Although it is difficult to argue that
all MEV is "bad" (e.g., market arbitrage can remove market inef-
ficiencies), it usually introduces some negative externalities like:
network congestion: especially on low-cost chains, MEV actors often

1

try to increase their chances of exploiting an MEV opportunity by
sending a lot of redundant transactions, spamming the underlying
peer-to-peer network; chain congestion: many such transactions fi-
nally make it to the chain, making the chain more congested; higher
blockchain costs: while competing for profitable MEV opportunities,
MEV actors bid higher gas prices to prioritize their transactions,
which results in overall higher blockchain costs for regular users;
consensus stability: some on-chain transactions can create such a
lucrative MEV opportunity that it may be tempting for miner(s) to
create an alternative chain fork with such a transaction extracted
by them, which introduces consensus instability risks.

1.2 Blind Order-Fairness on a DAG
A promising way of thwarting some forms of MEV on blockchains
is to extend their BFT (Byzantine fault tolerance) Consensus core
by new properties like Blind Order-Fairness, where no consensus
party can learn the content of transactions until they are committed
to a total ordering. This notion of Order-then-Reveal is the key
mechanism we focus on in this paper.

An orthogonal line of research concentrates on scaling the BFT
Consensus of blockchains via a DAG communication substrate. A
DAG transport can spread yet-unconfirmed transactions in paral-
lel, every message having utility and carrying transactions that
eventually become committed to a total ordering. The DAG pro-
vides Reliability, Non-equivocation, and Causal-ordering delivery
guarantees, enabling a simple and "zero-overhead" Consensus or-
dering on top of it. That is, participants can interpret their DAG
locally without exchanging more messages and determine a total
ordering of accumulated transactions. Several recent DAG-based
BFT systems, including Blockmania [13], Aleph [19], Narwhal [14],
DAG-Rider [23], and Bullshark [20], demonstrate excellent perfor-
mance.

Combining these two advances, this paper introduces Fino, a
DAG-based BFT Consensus protocol that leverages the Reliability,
Non-Equivocation, and Causality properties of the DAG transport
to implement Order-then-Reveal smoothly and efficiently.

In Fino, users first send transactions to BFT parties encrypted, so
that the Consensus protocol commits to an ordering of transactions
blindly. Users disperse shares of the secret decryption key for each
transaction with parties. After an ordering is committed, opening
encrypted transactions requires retrieving shares from F+1 parties.
To prevent MEV exploits, there must be a unique, deterministic
outcome of encrypted transactions before they are included in the
committed ordering.

Implementing this efficiently so as to meet DAG-based Consen-
sus throughput is the core challenge Fino addresses. Two straw man
approaches are (i) threshold cryptography, but it would incur an
order of milliseconds per transaction, (ii) using polynomial secret-
sharing and verifying shares during dispersal, also requiring costly
cryptography as well as implementing a share-recovery protocol.

 
 
 
 
 
 
Fino operates without complex secret share verifiability or re-
coverability, and to allow progressing with the first 2F+1 messages
(Responsiveness), employs threshold cryptography as a fallback
option.

This works as follows. Users send each transaction encrypted
with a symmetric key while providing two options for decryption.
One is sharing the decryption key using Shamirâ€™s (vanilla) secret-
sharing scheme [38], without share verifiability, recoverability, or
any sophisticated cryptography. This option works extremely fast
in a happy path, where BFT parties reveal their shares immediately
following a transactionâ€™s commit. The second option is based on
threshold encryption, it is used as a fallback mechanism. In both
tracks, share retrieval is orchestrated on the DAG cleanly sepa-
rated from it, without delaying the steady spreading of transactions
by the DAG transport and with zero message overhead. Parties
interpret their local DAGs to arrive at commit decisions on blind or-
dering. After an ordering has committed for a batch of transactions,
parties retrieve decryption shares piggybacked on DAG broadcasts.
Finally, they interpret their local DAGs to arrive at unanimous,
deterministic outcome of transaction opening.

Borrowing a key insight from DispersedLedger [40], Fino verifies
that the (entire) sharing was correct post reconstruction. Importantly,
this is done no matter which track was used, even the reconstruction
is successful. If either the slow or the fast dispersal was incorrect and
fails post-reconstruction verification, the transaction is rejected.

Notably, in the happy path, Fino works an order of magnitude
faster than threshold encryption. During periods of synchrony, It
has a happy path for transaction commit of 2 DAG latencies, plus 3
DAG latencies for determining an opening outcome.

2 BACKGROUND AND PRELIMINARIES
2.1 System Model
The Byzantine fault tolerance (BFT) Consensus core of blockchains
implements state machine replication (SMR), where non-faulty par-
ties agree on an order of transactions and execute them consistently.
We refer to it simply as the BFT approach. The goal of our work
is to extend the BFT approach and build into it protection against
MEV attacks which rely on transaction content analysis.

We assume that the system should be resilient to Byzantine
faults, i.e., faulty parties can implement any adversarial behavior
(like crashing, equivocating, or colluding). We assume a partially
synchronous network [18], where asynchronous periods last up
to unknown global stabilization time (GST), while in synchronous
periods there is a known bound Î” on delays for message delivery.
This model requires a BFT threshold ğ‘ â‰¥ 3ğ¹ + 1, where ğ‘ and ğ¹ is
the number of all and Byzantine faulty nodes, respectively.

2.2 MEV and Blind Order-Fairness
In this paper, we focus on consensus-level MEV mitigation tech-
niques. There are fundamentally two types of MEV-resistant Order-
Fairness properties:

Blind Order-Fairness. A principal line of defense against MEV
stems from committing to transaction ordering without seeing
transaction contents. This notion of MEV resistance, referred to
here as Blind Order-Fairness, is used in a recent SoK on Preventing
Transaction Reordering by Heimbach and Wattenhofer [21], and

2

Dahlia Malkhi and Pawel Szalachowski
Chainlink Labs

is defined as: "when it is not possible for any party to include or
exclude transactions after seeing their contents. Further, it should not
be possible for any party to insert their own transaction before any
transaction whose contents it already been observed."

Time-Based Order-Fairness. Another measure for MEV pro-
tection is brought by sending transactions to all BFT parties simul-
taneously and using the relative arrival order at a majority of the
parties to determine the final ordering. In particular, this notion
of order fairness ensures that "if sufficiently many parties receive a
transaction tx before another txâ€™, then in the final commit order txâ€™ is
not sequenced before tx."

This defines the transactions order and prevents adversaries that
can analyze network traffic and transaction contents from reorder-
ing, censoring, and front-/back-running transactions received by
Consensus parties. Moreover, Time-Based Order-Fairness protects
against a potential collusion between users and BFT leaders/parties
because parties explicitly input relative ordering into the protocol.
Time-Based Order-Fairness is used in various flavors in several
recent works, including Pompe [43], Aequitas [26], Themis [25],
"Wendy Grows Up" [28], and "Quick Order Fairness" [11]. We briefly
discuss some of those protocols in Section 7.

Another notion of fairness found in the literature, that does not

provide Order-Fairness, revolves around participation fairness:

Participation Fairness. A different notion of fairness aims to
ensure censorship-resistance or stronger notions of participation eq-
uity. Participation Fairness guarantees that the committed sequence
of transactions includes a certain portion of honest contribution
(aka "Chain Quality"). Several BFT protocols address Participation
Fairness, including Prime [2], Fairledger [29], HoneyBadger [31].
As mentioned in Section 4, some DAG-based BFT protocols like
Aleph [19], DAG-Rider [23], Tusk [14], and Bullshark [20] use a
layered DAG paradigm. In this approach, Participation Fairness
comes essentially for free because every DAG layer must include
messages from 2F+1 participants. It is worth noting that Partici-
pation Fairness does not prevent a corrupt party from injecting
transactions after it has already observed other transactions, nor
a corrupt leader from reordering transactions after reading them,
violating both Blind and Time-Based Order-Fairness.

2.3 Threshold Methods
Beside standard cryptographic primitives, like a symmetric encryp-
tion scheme or a cryptographic hash function ğ» (), we employ
primitives specifically designed for hiding and opening transac-
tions.

Secret-Sharing. For positive integers ğ‘˜, ğ‘›, where ğ‘˜ â‰¤ ğ‘›, a (k,n)-
threshold scheme is a technique where a secret is distributed among
ğ‘› parties , such that it can be reconstructed by any ğ‘˜ parties, while
any group of ğ‘˜ âˆ’ 1 parties cannot learn the secret. The secret ğ‘† is
selected by a trusted third party, called dealer, who splits it into ğ‘›
individual shares by calling: ğ‘ 1, ..., ğ‘ ğ‘› â† SS.Split(S). After at least
ğ‘˜ parties exchange shares, they can combine them and recover the
secret by calling ğ‘† â† SS.Combine(ğ‘  â€²
1

Shamirâ€™s Secret Sharing (SSS) [38] is one of the first and most
widely used (k,n)-threshold schemes. In SSS, Split(ğ‘†) chooses a
polynomial ğ‘“ of degree ğ‘˜ âˆ’ 1 that hides ğ‘† at the origin point, and

, ..., ğ‘  â€²

ğ‘˜ ).

Maximal Extractable Value (MEV) Protection on a DAG

Table 1: Order-then-Reveal methods.

TE

VSS

Disperse(tx)

ğ‘‡ ğ¸.ğ¸ğ‘›ğ‘ ()

ğ‘‰ ğ‘†ğ‘†.ğ‘†ğ‘ğ‘™ğ‘–ğ‘¡ ()

Fino
ğ‘†ğ‘†.ğ‘†ğ‘ğ‘™ğ‘–ğ‘¡ ()
ğ» (ğ‘¡ğ‘¥-ğ‘˜ğ‘’ğ‘¦)
ğ‘‡ ğ¸.ğ¸ğ‘›ğ‘ ()

ğ‘‡ ğ¸.ğ‘†â„ğ‘ğ‘Ÿğ‘’ğºğ‘’ğ‘› () ğ‘ ğ‘– or ğ‘‰ ğ‘†ğ‘†.ğ‘…ğ‘’ğ‘ğ‘œğ‘£ğ‘’ğ‘Ÿ () ğ‘ ğ‘– or ğ‘‡ ğ¸.ğ‘†â„ğ‘ğ‘Ÿğ‘’ğºğ‘’ğ‘› ()

Retrieve(tx)
optimistic
Retrieve(tx)
pessimistic

Verify(tx)

N/A

N/A

during Retrieve():
ğ‘‡ ğ¸.ğ‘‰ ğ‘’ğ‘Ÿğ‘– ğ‘“ ğ‘¦ ()

during Disperse():
ğ‘‰ ğ‘†ğ‘†.ğ‘‰ ğ‘’ğ‘Ÿğ‘– ğ‘“ ğ‘¦ ()

Reconstruct(tx)
fast
Reconstruct(tx) ğ‘‡ ğ¸.ğ·ğ‘’ğ‘ ()

N/A

N/A

ğ‘‰ ğ‘†ğ‘†.ğ¶ğ‘œğ‘šğ‘ğ‘–ğ‘›ğ‘’ ()

ğ‘‡ ğ¸.ğ‘†â„ğ‘ğ‘Ÿğ‘’ğºğ‘’ğ‘› ()
post Reconstruct():
verify missing shares
verify ğ‘‡ ğ¸.ğ¸ğ‘›ğ‘ ()
ğ‘†ğ‘†.ğ¶ğ‘œğ‘šğ‘ğ‘–ğ‘›ğ‘’ ()
verify ğ» ()
ğ‘‡ ğ¸.ğ·ğ‘’ğ‘ ()

generates ğ‘› points on the polynomial. Then, any ğ‘˜ points allow to
interpolate the polynomial and compute its value at ğ‘“ (0).

Threshold Encryption. A (k,n)-threshold encryption is a scheme
where messages encrypted under a single public encryption key ğ‘ğ‘˜
can be decrypted by a private decryption key, shared among ğ‘› par-
ties â€“ each with its secret key ğ‘ ğ‘˜ğ‘– , where any group of ğ‘˜ parties can
decrypt a message. The message ğ‘š is encrypted with an encryption
algorithm: ğ‘ â† TE.Enc(ğ‘ğ‘˜, ğ‘š). We consider schemes where each
party, upon receiving a ciphertext ğ‘, computes its own decryption
share by invoking: ğ‘‘ğ‘ ğ‘– â† TE.ShareGen(ğ‘ ğ‘˜ğ‘–, ğ‘); and any set of ğ‘˜
unique decryption shares is enough to recover the plaintext, which
, ..., ğ‘‘ğ‘  â€²
we denote ğ‘š â†TE.Dec(ğ‘, ğ‘‘ğ‘  â€²
1
Moreover, some threshold encryption schemes, like shown by
Shoup and Gennaro [39], allow parties to verify that a given decryp-
tion share corresponds to the ciphertext, which we denote by the
TE.Verify(ğ‘, ğ‘‘ğ‘ ğ‘– ) function. Note that, without such a verification,
it is trivial for a malicious party, providing an incorrect share, to
cause decryption failures.

ğ‘˜ ).

3 ORDER-THEN-REVEAL
In this section, we explore methods for implementing the abstract
functionalities for sharing and opening, Disperse(tx), Retrieve(tx),
Reconstruct(tx), Verify(tx). As we shall see below, Verify(tx) can
be implemented either during dispersal or post reconstruction; in
Fino, we choose the latter.

To order transactions blindly, users choose for each transaction
tx a symmetric key tx-key, and send tx encrypted with it to BFT
parties. The goal is to share tx-key with parties, such that a thresh-
old greater than F and no greater than 2F+1 of the parties is required
to reconstruct the key after sharing. In Section 5, we will utilize the
DAG to reveal shares after tx ordering becomes committed.

Disperse(tx) is used to share tx-key with parties along with a
proof of validity of the shares. To delay reconstruction until af-
ter a transaction has been committed to the consensus ordering,
a threshold ğ¹ + 1 of the parties is necessary and sufficient to Re-
trieve(tx). Thereafter, Reconstruct(tx) combines ğ¹ + 1 shares to open
tx. Verify(tx) is used either during dispersal or post reconstruction
to validate a unique reconstruction outcome, no matter which 2ğ¹ +1
shares are retrieved.

3.1 Strawman 1: with Threshold Cryptography
It is relatively straight-forward to implement Order-then-Reveal
methods on a DAG by using threshold encryption. More specifically,
to Disperse(tx), a user sends along with the encrypted tx the
transaction key tx-key, itself encrypted with the public threshold
key ğ‘ â† ğ‘‡ ğ¸.ğ¸ğ‘›ğ‘ (ğ‘ğ‘˜, tx-key). Once a transaction txâ€™s ordering is
committed, to Retrieve(tx), every party callsğ‘‡ ğ¸.ğ‘†â„ğ‘ğ‘Ÿğ‘’ğºğ‘’ğ‘›(ğ‘ ğ‘˜ğ‘–, ğ‘)
generating its decryption share ğ‘‘ğ‘ ğ‘– to be presented. Each received
share can be verified by calling ğ‘‡ ğ¸.ğ‘‰ ğ‘’ğ‘Ÿğ‘– ğ‘“ ğ‘¦(ğ‘, ğ‘‘ğ‘ ğ‘– ), ensuring that
ğ‘–th party is contributing a correct decryption share, and finally
to Reconstruct(tx), the plaintext can be recovered by calling
, ..., ğ‘‘ğ‘ ğ‘–ğ¹ +1 ). A threshold of honest parties can always
ğ‘‡ ğ¸.ğ·ğ‘’ğ‘ (ğ‘, ğ‘‘ğ‘ ğ‘–1
succeed in decrypting messages, hence decipherability of a com-
mitted transaction is guaranteed as soon as 2F+1 shares (of which
F+1 are by honest parties) are revealed.

The main drawback of threshold encryption is that share verifi-
cation and decryption are computationally heavy. It takes an order
of milliseconds per transaction in todayâ€™s computing technology,
as we show later in the paper (see Appendix A).

3.2 Strawman 2: with Verifiable Secret-Sharing
Another way to implement Order-then-Reveal on a DAG is to use
SSS. To Disperse(tx), a user calls ğ‘†ğ‘†.ğ‘†ğ‘ğ‘™ğ‘–ğ‘¡ (ğ‘¡ğ‘¥-ğ‘˜ğ‘’ğ‘¦) to split the
key into shares ğ‘ 1, ..., ğ‘ ğ‘ . Then, it sends individual shares confiden-
tially to BFT parties. To Retrieve(tx), parties can present their SSS
, ..., ğ‘ ğ‘–ğ¹ +1 ). to Reconstruct(tx).
shares, and then use ğ‘†ğ‘†.ğ¶ğ‘œğ‘šğ‘ğ‘–ğ‘›ğ‘’ (ğ‘ ğ‘–1
Combining good shares is three orders of magnitude faster than
threshold encryption and takes a few microseconds in todayâ€™s com-
puting environment (see Appendix A). The challenge in the secret
sharing scheme is that a bad user might send bogus shares to some
parties, or not send shares to some parties at all. Furthermore, re-
constructing the key from different subsets of parties might produce
different keys. Thus, it is far less straight-forward to construct an
opening protocol with secret sharing on a DAG. There are two
fundamental challenges:

Responsiveness: Advancing the Consensus protocol should
be possible when only 2F+1 parties participate. However, of the
2F+1 parties that receive shares for tx, only one share holder may
participate in advancing Consensus. Although unlikely, this situ-
ation could linger indefinitely simply due to the slowness of the
remaining F honest parties (layering the DAG does not solve this
either).

Unique combining: Conversely, if more than F+1 shares are
revealed, combining different subsets could yield different "decryp-
tion" tx-key if the user is bad. Hence, a transaction decryption
might not be uniquely determined. The traditional solution in the
literature to the problem of a bad SSS dealer is to employ a Verifiable
Secret-Sharing ("VSS") scheme, allowing parties to ğ‘†ğ‘†.ğ‘‰ ğ‘’ğ‘Ÿğ‘– ğ‘“ ğ‘¦ (ğ‘ ğ‘– )
shares ğ‘ ğ‘– during Disperse(tx) and to ğ‘†ğ‘†.ğ‘…ğ‘’ğ‘ğ‘œğ‘£ğ‘’ğ‘Ÿ (ğ‘ ğ‘– ) when needed
to fulfill Retrieve(tx). Despite the vast progress in VSS schemes
(see Section 7.1), share recovery requires linear communication.
Additionally, implementing VSS requires non-trivial cryptography.

3

3.3 Fino: no VSS and optimistically no

Threshold Encryption

Fino materializes Order-then-Reveal methods utilizing secret-sharing
during steady-state (happy path), and falls back to threshold encryp-
tion during a period of network instability (fallback path). During
periods of synchrony, if the user is non-faulty, opening is done via
secret-sharing.

To Disperse(tx), users share tx-key with BFT parties twice.
First, they use ğ‘†ğ‘†.ğ‘†ğ‘ğ‘™ğ‘–ğ‘¡ (tx-key) and send shares to parties along
with a commitment to the key ğ» (tx-key). Then, they commit
to the shares by creating a Merkle Tree. Each party will receive
its dedicated share ğ‘ ğ‘– , the shareâ€™s inclusion proof in the tree ğ‘ğ‘– ,
and the root of the tree ğ‘Ÿ . Second, as a fallback, they send ğ‘ â†
ğ‘‡ ğ¸.ğ¸ğ‘›ğ‘ (ğ‘ğ‘˜, tx-key). The actual transaction and information al-
lowing to replicate ğ‘†ğ‘†.ğ‘†ğ‘ğ‘™ğ‘–ğ‘¡ () (i.e., the randomness used for the
polynomial generation) are encrypted symmetrically with tx-key.

In Fino, once a transaction txâ€™s ordering is committed, Retrieve(tx)

has an optimistic path and pessimistic one, as follows:
Optimistic A party that holds an SSS share for tx-key presents
the share with its Merkle tree proof and root. The proof and
root assure other parties that the party presents an authentic
share. A party that does not hold a share for tx-key presents
a threshold key decryption share ğ‘‡ ğ¸.ğ‘†â„ğ‘ğ‘Ÿğ‘’ğºğ‘’ğ‘›(ğ‘ ğ‘˜ğ‘–, ğ‘).
Pessimistic If a party doesnâ€™t receive at least F+1 SSS shares that
result in a successful reconstruction for a pre-defined time
period, it presents a threshold encryption share (if it hasnâ€™t
already).

In order to avoid combinatorial explosion trying to combine F+1
out of 2F+1 (or more) revealed SSS shares, Reconstruct(tx) works
as follows. If combining the F+1 shares from the lowest-numbered
parties succeeds, i.e., if ğ» (ğ‘¡ğ‘¥-ğ‘˜ğ‘’ğ‘¦) = ğ» (ğ‘†ğ‘†.ğ¶ğ‘œğ‘šğ‘ğ‘–ğ‘›ğ‘’ (ğ‘ ğ‘–1
, ..., ğ‘ ğ‘–ğ¹ +1 )),
then use it. Otherwise, use F+1 verified TE decryption shares,
ğ‘‡ ğ¸.ğ·ğ‘’ğ‘ (ğ‘, ğ‘‘ğ‘  ğ‘—1

, ..., ğ‘‘ğ‘  ğ‘—ğ¹ +1 ).

The verification in Fino takes place after the reconstruction phase
in order to guarantee that a malicious user, even collaborating
with a party, cannot influence the outcome of the reconstruction.
We take a similar approach as in AVID-M [40]. In both cases, i.e.,
after the optimistic and pessimistic reconstruction, a party first
decrypts the randomness used to generate the polynomial ğ‘ƒ (the
polynomial has to encode tx-key) and regenerates the N shares of
ğ‘ƒ. Note, that it requires a deterministic way of splitting secret shares
ğ‘†ğ‘†.ğ‘†ğ‘ğ‘™ğ‘–ğ‘¡ () which, in particular, can be based on party identifiers
(e.g., ğ‘ ğ‘– = ğ‘ƒ (ğ‘–ğ‘‘ğ‘– )). After all N shares are available, the party builds a
new Merkle Tree from those shares and verifies whether the root
distributed by the user matches the newly constructed root. This
guarantees that the user has generated and distributed the shares
correctly.

In the optimistic case, the party has to additionally ensure that
the slow path (i.e., threshold decryption) would result in the same
outcome. To verify it, the party threshold re-encrypts tx-key and
checks if the outputs match. We note, that this step is implemen-
tation specific and for some threshold encryption schemes, a user
would need to reveal (e.g., in the symmetric ciphertext or encoded
by ğ‘ƒ) values allowing to recompute the same ciphertext.

4

Dahlia Malkhi and Pawel Szalachowski
Chainlink Labs

4 DAG TRANSPORT
In a DAG-based BFT protocol, parties store messages delivered via
reliable and causally ordered broadcast in a local graph. A message
inserted into the local DAG has the following guarantees: Relia-
bility: there are copies of the message stored on sufficiently many
participants, such that eventually, all honest parties can download
it. Non-equivocation: messages by each party are numbered. If a
party delivers some message as the kâ€™th from a particular sender,
then the message is authenticated by its sender and other parties
deliver the same message as the sender kâ€™th message. Causal Order-
ing: the message carries explicit references to messages which the
sender has previously delivered (including its own). Predecessors
are delivered locally before the message.

Note that the DAGs at different parties may be slightly different
at any moment in time. This is inevitable in a distributed system
due to message scheduling. However, a DAG-based Consensus
protocol allows each participant to interpret its local DAG, reaching
an autonomous conclusion that forms total ordering. Reliability,
Non-equivocation and Causal Ordering make the design of such
protocols extremely simple as we shall see below.

DAG API. A DAG transport exposes two basic APIâ€™s, broadcast()

and deliver().
Broadcast. broadcast() is an asynchronous API for a party to
present payload for the DAG transport to be transmitted to
all other parties. The main use of DAG messages in a DAG-
based Consensus protocol is to pack meta-information on
transactions into a block and present the block for broadcast.
The DAG transport adds references to previously delivered
messages, and broadcasts a message carrying the block and
the causal references to all parties.

Deliver. When another party receives the message carrying the
block, it checks whether it needs to retrieve a copy of any
of the transactions in the block and in causally preceding
messages. Once it obtains a proof-of-availability of all trans-
actions in the block and its causal past, it can acknowledge it.
A partyâ€™s upcall deliver(m) is triggered when sufficiently
many acknowledgments for it are gathered, guaranteeing
that the message itself, the transactions it refers to, and its
entire causal past maintain Reliability, Non-equivocation
and Causal Ordering.
It is worth noting that in the protocol discussed in this pa-
per, the Consensus protocol injects meta-information (e.g.,
complaints), DAG broadcast never stalls or waits for input
from it.

Implementing a DAG. There are various ways to implement
reliable, non-equivocating and causally-ordered broadcast among
ğ‘ = 3ğ¹ + 1ğ‘ğ‘ğ‘Ÿğ‘¡ğ‘–ğ‘’ğ‘ , at most ğ¹ of which are presumed Byzantine
faulty and the rest are honest.
Lifetime of a message. A party packs transaction information and
meta-information into a message, adds references to previ-
ously delivered messages (including the senderâ€™s own pre-
ceding messages), and broadcasts the message to all parties.
Echoing. The key mechanism for reliability and non-equivocation
is for parties to echo a digest of the first message they receive
from a sender with a particular index. When 2ğ¹ + 1 echoes
are collected, the message can be delivered. There are two

Maximal Extractable Value (MEV) Protection on a DAG

ways to echo, one is all-to-all broadcast over authenticated
point-to-point channels a la Bracha Broadcast [9]; the other
is converge-cast with cryptographic signatures a la Ram-
part [37] and Cachin et al. [10]. In either case, echoing can
be streamlined so the amortized per-message communica-
tion is linear, which is anyway the minimum necessary to
spread the message.

Layering. Transports are often constructed in a layer-by-layer regime.

In this regime, each sender is allowed one message per layer,
and a message may refer only to messages in the layer pre-
ceding it. Layering is done so as to regulate transmissions
and saturate network capacity, and has been demonstrated
to be highly effective by various projects [13, 14, 19]. We
reiterate that Fino does not require a layered structure.

5 FINO: MEV PROTECTION ON A DAG
Fino incorporates MEV protection into a BFT protocol for the partial
synchrony model, riding on a DAG transport. BFT parties periodi-
cally pack pending encrypted transactions into a batch and use the
DAG transport to broadcast them. The key insight for operating
Order-then-Reveal on a DAG is that each view must wait until
reconstruction and verification succeeds on transactions tx of the
previous view. In this way, a each view has dual purpose. First, it
commits blindly a new batch of transactions to the total ordering.
Second, it causally follows enough shares to open all previously
committed transactions, setting a deterministic opening.

5.1 The Protocol
Views. The protocol operates in a view-by-view manner. Each view
is numbered, as in view(r), and has a designated leader known to
everyone.

View change. A party enters view(r+1) when two conditions
are met, viewA and viewB: viewA is satisfied when the local DAG
of a party contains F+1 valid votes on proposal(r) or 2F+1 valid
complaint(r) on view(r). viewB is satisfied when every commit-
ted transaction in the local DAG has 2F+1 valid shares revealed that
result in a successful Reconstruct(tx). Note that viewB prevents
BFT parties that do not reveal (correct) shares from enabling the
protocol to make progress without opening committed transactions.
Proposing. When a leader enters a new view(r), it broadcasts
proposal(r).1 Implicitly, proposal(r) suggests to commit to the
global ordering of transactions all the messages in the causal his-
tory of the proposal. A leaderâ€™s proposal(r) is valid if it is well-
formatted and is justified in entering view(r).

Voting. When a party sees a valid leader proposal, it broadcasts
vote(r). A partyâ€™s vote(r) is valid if it follows a valid proposal(r).
Committing. Whenever a leaderâ€™s proposal(r) has F+1 valid
votes in the local DAG, the proposal and its causal history become
committed. The commit order induced by a commit decision is
described below.

Share revealing. When a party observes that a transaction
tx becomes committed, it performs broadcast(Retrieve(tx))
to present its share of the decryption key tx-key. There is an
optimistic-path and a pessimistic one. In the optimistic path, a

1Recall, broadcast() merely presents payload to be transmitted as scheduled by the
DAG transport, e.g., piggybacked on messages carrying other transaction info.

party that holds a SSS share for tx-key uses that, while a party that
does not hold a share presents a threshold-decryption share. In the
pessimistic path, if a party observes there are not enough shares for
tx for a certain period of time, it broadcasts a threshold-decryption
share (if it did not already reveal it in the optimistic path).

Complaining. If a party gives up waiting for a commit to hap-
pen in view(r), it broadcasts complaint(r). Note, a vote(r) by
a party that causally follows a complaint(r) by the party, if exists,
is not interpreted as a valid vote.

Ordering Commits. When a party observes that a leaderâ€™s
proposal(r) becomes committed, it orders newly committed trans-
actions as follows:

(1) Let râ€™ be the highest view râ€™ < r for which proposal(râ€™)
is in the causal history of proposal(r). proposal(râ€™) is
recursively ordered.

(2) The remaining causal predecessors of proposal(r) which
have not yet been ordered are appended to the committed
sequence (within this batch, ordering can be done using any
deterministic rule to linearize the partial ordering into a total
ordering.)

Opening Transactions. When a party observes that a leaderâ€™s
proposal(r) becomes committed, it decrypts every committed
transaction tx in its causal past that hasnâ€™t been decrypted already.
That is, let c be the highest view c < r for which proposal(r)
causally follows F+1 valid votes. Transactions in the causal past of
proposal(c) are opened as follows:

(1) Let râ€™ be the highest view râ€™ < c for which proposal(râ€™)
is in the causal history of proposal(c). proposal(râ€™) is
recursively opened.

(2) The remaining (committed) transactions tx in proposal(c)â€™s
causal past are opened using Reconstruct(tx)) to produce
a key tx-key to decrypt tx. Then Verify(tx) is applied, and
if it fails, the transaction is rejected.
Fig. 1 illustrates a couple of Fino scenarios.

Happy-path scenario. In the first view (view(r)), proposal(r)
becomes committed. The commit sets an ordering for transactions
in the causal past of proposal(r), enabling retrieval of shares for
transactions from proposal(r).

Scenario with a slow leader. A slightly more complex scenario
occurs when a view expires because parties do not observe a leaderâ€™s
proposal becoming committed and they broadcast complaints. Fig. 1
depicts this hapenning in view(r+1). Entering view(r+2) is enabled
by 2F+1 complaints about view(r+1). When proposal(r+1) itself
becomes committed, it indirectly commits proposal(r+1) as well.
Thereafter, parties reveal shares for all pending committed transac-
tions, namely, those in both proposal(r+1) and proposal(r+2).

6 ANALYSIS
Fino is minimally integrated with a DAG transport. BFT Order-
then-Reveal logic is embedded into the DAG structure simply by
broadcasting (more precisely, injecting payloads into broadcasts)
in the form of protocol proposals/votes/complaints and revealing
shares. Importantly, at no time is DAG broadcast slowed down by
the Fino protocol. The reliability and causality properties of the
DAG transport make arguing about safety and liveness relatively
easy.

5

Dahlia Malkhi and Pawel Szalachowski
Chainlink Labs

Figure 1: A commit of proposal(r) is followed by share retrieval. A commit of proposal(r+2) causes an indirect commit of
proposal(r+1), followed by share revealing of both.

6.1 Safety

Lemma 6.1. Assume a proposal(r) ever becomes committed. De-
note by ğ‘Ÿ â€² the minimal view, where ğ‘Ÿ â€² > ğ‘Ÿ , such that proposal(râ€™)
ever becomes committed. Then for every ğ‘Ÿ â‰¤ ğ‘ < ğ‘Ÿ â€², proposal(q+1)
causally follows proposal(r).

Proof. (Sketch) Since proposal(r) becomes committed, by def-
inition F+1 parties sent votes for it. There are two possibilities for
a leaderâ€™s proposal(q+1) to be valid. The first is proposal(q+1)
may reference F+1 valid vote(q) messages. This case occurs only
for ğ‘ == ğ‘Ÿ by the lemma assumption that ğ‘Ÿ â€² â‰¥ ğ‘ + 1 is the mini-
mal view that ever becomes committed. The second possibility can
occur for all ğ‘Ÿ â‰¤ ğ‘ < ğ‘Ÿ â€², namely, proposal(q+1) references 2F+1
valid complaint(q) messages.

In the first case, valid vote(r) causally follows proposal(r),

and a fortiori proposal(r+1) causally follows proposal(r).

In the second case, one of 2F+1 complaint(q) messages is sent
by a party who sent a valid vote(r). By definition, vote(r) must
precede complaint(q), otherwise it is not considered a (valid) vote.
Hence, proposal(q+1) causally follows complaint(q) which fol-
â–¡
lows proposal(r).

Lemma 6.2. If ever a proposal(r) becomes committed, then every

valid proposal(q), where q > r, causally follows proposal(r).

Proof. (Sketch) The proof follows by a simple induction on
â–¡

Lemma 6.1.

Lemma 6.3. If an honest party commits proposal(r), and another
honest party commits proposal(râ€™), where ğ‘Ÿ â€² > ğ‘Ÿ , then the sequence
of transactions committed by proposal(r) is a prefix of the sequence
committed by proposal(râ€™).

Proof. (Sketch) When proposal(râ€™) becomes committed, the
commit ordering rule is recursively applied to valid proposals in
its causal past. By Lemma 6.2, the (committed) proposal(r) is a
causal predecessor of every valid proposal(s), for ğ‘Ÿ < ğ‘  â‰¤ ğ‘Ÿ â€², and
â–¡
eventually the recursion gets to it.

6

Lemma 6.4. If ever a proposal(r) becomes committed, then every
committed transaction proposed by a valid proposal(râ€™), where râ€™
< r, can be uniquely decrypted.

Proof. (Sketch) When proposal(r) becomes committed, then
by Lemma 6.3, all the transactions from previously committed
proposals are part of the committed transaction history. More-
over, committing proposal(r) implies the view change (from r-1)
which occurs only if the condition viewB (see Section 5) is met,
i.e., every committed transaction tx in the local DAG succeeds
Reconstruct(tx), hence can be uniquely decrypted.

It is worth noting that once tx is committed, the binding com-
mitment cmt to the symmetric key tx-key prevents attacks where
a malicious user introduces invalid shares, such that SS.Combine()
outputs different secrets depending on its input shares. Likewise,
threshold-decryption prevents a user from colluding with BFT par-
â–¡
ties to abort tx.

6.2 Liveness
Liveness is guaranteed after GST, i.e., after communication has
become synchronous with a known Î” upper bound on transmission
delays.

After GST, views are semi-synchronized through the DAG. In
particular, suppose that after GST, every broadcast by an honest
party arrives at all honest parties within ğ·ğ·. Once a view(r) with
an honest leader is entered by the first honest party, within ğ·ğ· all
the messages seen by one party are delivered by both the leader and
all other honest parties. Hence, within ğ·ğ·, all honest parties enter
view(r) as well. Within two additional DAG latencies, 2 Â· ğ·ğ·, the
view(r) proposal and votes from all honest parties are spread to
everyone.

Assuming view timers are set to be at least 3 Â· ğ·ğ·, once view(r)
is entered, a future view will not interrupt a commit. In order
to start a future view, its leader must collect either F+1 vote(r)
messages, hence commit proposal(r); or 2F+1 complaint(r) ex-
piration messages, which is impossible as argued above.

Maximal Extractable Value (MEV) Protection on a DAG

As for satisfying Reconstruct(tx) for committed transactions
tx, this is guaranteed, in the worst case, through threshold decryp-
tion.

6.3 Happy-Path Communication complexity
Protocols for the partial synchrony model have unbounded worst
case by nature, hence, we concentrate on the costs incurred during
steady state when a leader is honest and communication with it is
synchronous:

DAG message cost. In order for DAG messages to be delivered
reliably, it must implement reliable broadcast. This incurs either a
quadratic number of messages carried over authenticated channels,
or a quadratic number of signature verifications, per broadcast.
In either case, the quadratic cost may be amortized by pipelining,
driving it in practice to (almost) linear per message.

Commit message cost. Fino sends F+1 broadcast messages, a
proposal and votes, per decision. A decision commits the causal
history of the proposal, consisting of (at least) a linear number of
messages. Moreover, each message may carry multiple transactions
in its payload. As a result, in practice the commit cost is amortized
over many transactions.

6.4 Happy-Path Latency
Commit latency. The commit latency in terms of DAG messages
is 2, one proposal followed by votes.

Opening latency. During periods of stability, there are no com-
plaints about honest leaders by any honest party. If tx is proposed
by an honest leader in view(r), it will receive F+1 votes and be-
come committed within two DAG latencies. Within one more DAG
latency, every honest party will post a message containing a share
for tx. Out of 2F+1 shares, either F+1 are secret-sharing shares or
decryption shares. Thereafter, whenever a leader proposal referenc-
ing 2F+1 shares becomes committed, everyone will be able to open
tx. In such a happy path, opening happens three DAG latencies
after a commit: one for revealing shares, one for a leader proposal
following the shares, and one to commit the proposal.

7 RELATED WORK AND DISCUSSION
Despite the MEV problem being relatively new, there already exist
consensus-related systems aiming at solving it. For instance, Flash
Freezing Flash Boys (F3B) [42] is a commit-and-reveal architecture,
where clients send TDH2-encrypted ciphertexts to be ordered by
Consensus, and afterward to be decrypted via shares released by
a dedicated secret-management committee. Other closely related
techniques and schemes helpful in mitigating MEV are discussed
below.

7.1 Verifiable Secret Sharing (VSS)
The Strawman 2 described in Section 3.2 makes use of VSS. Al-
though we ultimately end us forgoing verifiability/recoverability of
shares, VSS is used in many settings like ours. The overall communi-
cation complexity incurred in VSS on the dealer sharing a secret and
on a party recovering a share has dramatically improved in recent
years. VSS can be implemented inside the asynchronous echo broad-
cast protocol in ğ‘‚ (ğ‘›3) communication complexity using Pedersonâ€™s

7

original two-dimensional polynomial scheme Non-Interactive Poly-
nomial Commitments [34]. Kate et al. [22] introduce a VSS scheme
with ğ‘‚ (ğ‘›2) communication complexity, utilized for asynchronous
VSS by Backes et al. [4]. Basu et al. [5] propose a scheme with linear
ğ‘‚ (ğ‘›) communication complexity.

A related notion to VSS is robust secret sharing (RSS), introduced
by Krawczyk [27] whose scheme was later revised by Bellare and
Rogaway [6]. RSS allows recoverability in case of incorrect (not just
missing) shares, however, these schemes assume an honest dealer.
Duan et al. [17] propose ARSS extending RSS to the asynchronous
setting.

7.2 Time-Based Order-Fairness
Blind Order-Fairness is achieved by deterministically ordering en-
crypted transactions and then, after the order is final, decrypting
them. The deterministic order can be enhanced by sophisticated
ordering logic present in other protocols. In particular, Fino can be
extended to provide Time-Based Fairness additionally ensuring that
the received transactions are not only unreadable by parties, but
also their relative order cannot be influenced by malicious parties
(the transaction order would be defined by the time of its ciphertext
arrival).

For instance, PompÂ¯e [43] proposes a property called Ordering
Linearizability: â€œif all correct parties timestamp transactions tx, txâ€™
such that txâ€™ has a lower timestamp than tx by everyone, then txâ€™ is or-
dered before tx.â€ It implements the property based on an observation
that if parties exchange transactions associated with their receiving
timestamps, then for each transaction its median timestamp, com-
puted out of 2F+1 timestamps collected, is between the minimum
and maximum timestamps of honest parties. Fino can be easily
extended by the Linearizability property offered by PompÂ¯e and
the final protocol is similar to the Fino with Blind Order-Fairness
(see above) with only one modification. Namely, every time a new
batch of transactions becomes committed, parties independently
sort transactions by their aggregate (median) timestamps.

More generally, Fino can easily incorporate other Time-based
Fairness ordering logic. Note that in Fino, the ordering of transac-
tions is determined on encrypted transactions, but time ordering
information should be open. The share revealing, share collection,
and unique decryption following a committed ordering are the same
as presented previously. The final protocol offers much stronger
properties since it not only hides payloads of unordered transactions
from parties, but also prevents parties from reordering received
transactions.

One form of Time-based Order-Fairness introduced in Aequitas [26]

is Batch-Order Fairness: â€œif sufficiently many (at least Â½ of the) parties
receive a transaction tx before another transaction txâ€™, then no honest
party can deliver tx in a block after txâ€™, â€ and a protocol achieving
it. Other forms of Time-Based Order-Fairness which may be used
in Fino include â€œWendy Grows Upâ€ [28], which introduced Timed
Relative Fairness, â€œif there is a time t such that all honest parties saw
(according to their local clock) tx before t and txâ€™ after t , then tx must
be scheduled before txâ€™, â€ and â€œQuick Order Fairnessâ€ [11], which
defined Differential-Order Fairness, â€œwhen the number of correct par-
ties that broadcast tx before txâ€™ exceeds the number that broadcast txâ€™

before tx by more than 2ğ¹ + ğœ…, for some ğœ… â‰¥ 0, then the protocol must
not deliver txâ€™ before tx (but they may be delivered together).â€

Themis [25] is a protocol realizing Batch-Order Fairness, where
parties do not rely on timestamps (as in PompÂ¯e) but only on their
relative transaction orders reported. Themis can also be integrated
with Fino, however, to make it compatible this design requires some
modifications to Finâ€™s underlying DAG protocol. More concretely,
Themis assumes that the fraction of bad parties cannot be one
quarter, i.e., F out of 4F+1. A leader makes a proposal based on
3F+1 out of 4F+1 transaction orderings (each reported by a distinct
party). Therefore, we would need to modify the DAG transport so
that parties reference 3F+1 preceding messages (rather than 2F+1).

7.3 DAG-based BFT
There are many known BFT solutions for partial synchrony, and
more specifically, several recent solutions that ride on a DAG [14, 20,
24]. When constructing Fino, we wanted to build MEV protection
into a simple DAG-based BFT solution, described below. Notwith-
standing, we remark that Finoâ€™s MEV protection can possibly be
incorporated into other DAG-riding BFT solutions.

We borrowed a subprotocol from Bullshark [20] that deals with
partial synchrony, modifying it so that DAG transmissions would
never stall waiting for BFT protocol steps or timers. Fino is differ-
ent from the borrowed Bullshark component in that BFT protocol
steps (e.g., view changes, proposals, votes, and complaints) are in-
jected into the DAG at any time, independent of DAG layers. It
uses broadcast() (defined in Section 2) to present these steps as
payloads to the DAG transport, completely asynchronously, while
normal DAG transmissions continue. A hallmark of the DAG-riding
approach, which Fino preserves while adding Blind Order-Fairness,
is zero message overhead.

Narwhal [14] is a recent DAG transport that has a layer-by-layer
structure, each layer having at most one message per sender and re-
ferring to 2F+1 messages in the preceding layer. A similarly layered
DAG construction appears earlier in Aleph [19], but it does not
underscore the separation of transaction dissemination from DAG
messages. Narwhal-HS is a BFT Consensus protocol within [14]
based on HotStuff [41] for the partial synchrony model, in which
Narwhal is used as a "mempool". In order to drive Consensus deci-
sions, Narwhal-HS adds messages outside Narwhal, using the DAG
only for spreading transactions.

DAG-Rider [23] and Tusk [14] build randomized BFT Consensus
for the asynchronous model riding on Narwhal, These protocols
are zero message overhead over the DAG, not exchanging any
messages outside the Narwhal protocol. Both are structured with
purpose-built DAG layers grouped into "waves" of 4 (2) layers each.
Narwal waits for the Consensus protocol to inject input value every
wave, though in practice, this does not delay the DAG materially.
Bullshark [20] builds BFT Consensus riding on Narwhal for the
partial synchrony model. It is designed with 8-layer waves driving
commit, each layer purpose-built to serve a different step in the
protocol. Bullshark is a "zero message overhead" protocol over the
DAG, however, due to a rigid wave-by-wave structure, the DAG is
modified to wait for Bullshark timers/steps to insert transactions
into the DAG. In particular, if leader(s) of a wave are faulty or slow,
some DAG layers wait to fill until consensus timers expire.

8

Dahlia Malkhi and Pawel Szalachowski
Chainlink Labs

More generally, since the eighties, causally ordered reliable broad-
cast has been utilized in forming distributed Consensus protocols,
e.g., [3, 8, 16, 30, 32, 35].

The notion of the secure, causal, reliable broadcast was intro-
duced by Reiter and Birman [37], and later refined by Cachin [10]
and Duan et al. [17]. This primitive was utilized in a variety of
BFT replicated systems, but not necessarily in the form of zero
message overhead protocols riding on a DAG. Several of these pre
blockchain-era BFT protocols are DAG based, notably Total [32] and
ToTo [16], both of which are BFT solutions for the asynchronous
model.

8 CONCLUSIONS
In this paper, we show how DAG-based BFT protocols can be en-
hanced to mitigate MEV â€“ arguably one of the main threats to
the success of cryptocurrencies. We investigate the design space
of achieving Blind Order-Fairness, and we propose an approach
that focuses on practicality. We present preliminary correctness
and performance results which indicate that our scheme is secure
and efficient. In the future, we plan to extend our analysis and
experiments, and investigate other cryptographic tools which can
improve our scheme.

ACKNOWLEDGMENT
We are grateful to Soumya Basu, Christian Cachin, Ari Juels, Mahimna
Kelkar, Lefteris Kokoris-Kogias, Oded Naor, Mike Reiter for many
comments that helped improve this writeup.

REFERENCES
[1] 2022. MeV-Explore v1. https://explore.flashbots.net/. (2022). Accessed: 2022-07-

18.

[2] Yair Amir, Brian Coan, Jonathan Kirsch, and John Lane. 2010. Prime: Byzantine

replication under attack. IEEE TDSC (2010).

[3] Yair Amir, Danny Dolev, Shlomo Kramer, and Dalia Malki. 1991. Transis: A
communication sub-system for high availability. Hebrew University of Jerusalem.
Leibniz Center for Research in Computer . . . .

[4] Michael Backes, Amit Datta, and Aniket Kate. 2013. Asynchronous computational

VSS with reduced communication complexity. In CT-RSA. Springer.

[5] Soumya Basu, Alin Tomescu, Ittai Abraham, Dahlia Malkhi, Michael K Reiter,
and Emin GÃ¼n Sirer. 2019. Efficient verifiable secret sharing with share recovery
in BFT protocols. In ACM CCS.

[6] Mihir Bellare and Phillip Rogaway. 2007. Robust computational secret sharing

and a unified account of classical secret-sharing goals. In ACM CCS.

[7] Daniel J Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang.
2012. High-speed high-security signatures. Journal of cryptographic engineering
(2012).

[8] Ken Birman and Thomas Joseph. 1987. Exploiting virtual synchrony in distributed

systems. In ACM SOSP.

[9] Gabriel Bracha. 1987. Asynchronous Byzantine agreement protocols. Information

and Computation (1987).

[10] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. 2001. Secure

and efficient asynchronous broadcast protocols. In CRYPTO. Springer.

[11] Christian Cachin, Jovana MiÄ‡iÄ‡, and Nathalie Steinhauer. 2021. Quick Order

Fairness. arXiv preprint arXiv:2112.06615 (2021).

[12] Philip Daian, Steven Goldfeder, Tyler Kell, Yunqi Li, Xueyuan Zhao, Iddo Bentov,
Lorenz Breidenbach, and Ari Juels. 2020. Flash boys 2.0: Frontrunning in decen-
tralized exchanges, miner extractable value, and consensus instability. In IEEE SP.
IEEE.

[13] George Danezis and David Hrycyszyn. 2018. Blockmania: from block dags to

consensus. arXiv preprint arXiv:1809.01620 (2018).

[14] George Danezis, Lefteris Kokoris-Kogias, Alberto Sonnino, and Alexander Spiegel-
man. 2022. Narwhal and Tusk: a DAG-based mempool and efficient BFT consen-
sus. In EuroSys.

[15] Henry de Valence, Jack Grigg, George Tankersley, Filippo Valsorda, and Isis
Lovecruft. 2020. The ristretto255 Group. IETF CFRG Internet Draft. (2020).

access to, i.e., the secret sharing scheme uses the Ed25519 curve [7],
while TDH2 uses ristretto255 [15] as the underlying prime-order
group. Performance for both schemes is presented in a setting where
6 shares out of 16 are required to recover the plaintext.

Table 2: Comparison of the implementationsâ€™ performance.

Scheme

TDH2-based
SSS-based

Disperse
311.6ğœ‡ğ‘ 
52.7ğœ‡ğ‘ 

ShareGen
434.8ğœ‡ğ‘ 
N/A

ShareVerify
492.5ğœ‡ğ‘ 
2.7ğœ‡ğ‘ 

Reconstruct
763.9ğœ‡ğ‘ 
3.5ğœ‡ğ‘ 

The results presented in Table 2 are obtained on an Apple M1 Pro.
Disperse refers to the overhead on the client-side while ShareGen
is the operation of deriving a decryption share from the TDH2
ciphertext by each party (this operation is absent in the SSS-based
scheme). In TDH2, ShareVerify verifies whether a decryption
share matches the ciphertext, while in the SSS-based scheme it
only checks whether a share belongs to the tree aggregated by the
signed Merkle root attached by the client. Reconstruct recovers
the plaintext from the ciphertext and the number of shares.

As demonstrated by these micro-measurements, the SSS-based
scheme is much more efficient: In our blind ordering scenario us-
ing threshold encryption, each party processing a TDH2 ciphertext
would call ShareGen once to derive its decryption share, ShareVerify
k-1 times to verify the threshold number of received shares, and
Reconstruct once to obtain the plaintext. Assuming k=6, the total
computational overhead for a single transaction to be recovered
would take around 3.7ms CPU time. With the secret sharing scheme,
the party would also call ShareVerify k-1 times and Reconstruct
once, which requires only 17ğœ‡ğ‘  CPU time.

The last operation that we evaluated is Verify, ensuring that
the secret shares and threshold ciphertext produce the same output.
In our setting, the verification in the optimistic case takes 338ğœ‡ğ‘ 
CPU time on average. That means, that in the optimistic path the
total overhead would be around 355ğœ‡ğ‘  per transaction, which is an
order of magnitude faster than with the threshold encryption. In the
pessimistic case, Verify requires 49ğœ‡ğ‘  of CPU time on average, only
slightly increasing the total computation time of the pessimistic
path.

We emphasize that these are micro-benchmarks of the blind-
ing/unblinding of transactions; in the future, we plan to complete
a performance evaluation of the entire DAG-based blind-ordering
protocol.

Maximal Extractable Value (MEV) Protection on a DAG

[16] Danny Dolev, Shlomo Kramer, and Dalia Malki. 1993. Early delivery totally

ordered multicast in asynchronous environments. In FTCS. IEEE.

[17] Sisi Duan, Michael K Reiter, and Haibin Zhang. 2017. Secure causal atomic

broadcast, revisited. In IEEE/IFIP DSN. IEEE.

[18] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. 1988. Consensus in the

presence of partial synchrony. J. ACM (1988).

[19] Adam GÄ…gol and MichaÅ‚ ÅšwiÄ™tek. 2018. Aleph: A leaderless, asynchronous,
byzantine fault tolerant consensus protocol. arXiv preprint arXiv:1810.05256
(2018).

[20] Neil Giridharan, Lefteris Kokoris-Kogias, Alberto Sonnino, and Alexander Spiegel-
arXiv preprint

man. 2022. Bullshark: Dag bft protocols made practical.
arXiv:2201.05677 (2022).

[21] Lioba Heimbach and Roger Wattenhofer. 2022. SoK: Preventing Transaction Re-
ordering Manipulations in Decentralized Finance. arXiv preprint arXiv:2203.11520
(2022).

[22] Aniket Kate, Gregory M Zaverucha, and Ian Goldberg. 2010. Constant-size

commitments to polynomials and their applications. In ASIACRYPT. Springer.

[23] Idit Keidar, Eleftherios Kokoris-Kogias, Oded Naor, and Alexander Spiegelman.

2021. All you need is dag. In ACM PODC.

[24] Idit Keidar, Oded Naor, and Ehud Shapiro. 2022. Cordial Miners: A Family of
Simple, Efficient and Self-Contained Consensus Protocols for Every Eventuality.
arXiv preprint arXiv:2205.09174 (2022).

[25] Mahimna Kelkar, Soubhik Deb, Sishan Long, Ari Juels, and Sreeram Kannan. 2021.
Themis: Fast, strong order-fairness in byzantine consensus. Cryptology ePrint
Archive (2021).

[26] Mahimna Kelkar, Fan Zhang, Steven Goldfeder, and Ari Juels. 2020. Order-fairness

for byzantine consensus. In CRYPTO. Springer.

[27] Hugo Krawczyk. 1993. Secret sharing made short. In CRYPTO. Springer.
[28] Klaus Kursawe. 2021. Wendy grows up: More order fairness. In Financial Crypto.

Springer.

[29] Kfir Lev-Ari, Alexander Spiegelman, Idit Keidar, and Dahlia Malkhi. 2019.
Fairledger: A fair blockchain protocol for financial institutions. arXiv preprint
arXiv:1906.03819 (2019).

[30] Peter M Melliar-Smith, Louise E. Moser, and Vivek Agrawala. 1990. Broadcast

protocols for distributed systems. IEEE TPDS (1990).

[31] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. 2016. The

honey badger of BFT protocols. In ACM CCS.

[32] Louise E Moser and Peter M Melliar-Smith. 1999. Byzantine-resistant total

ordering algorithms. Information and Computation (1999).

[33] Alexandre Obadia, Alejo Salles, Lakshman Sankar, Tarun Chitra, Vaibhav Chellani,
and Philip Daian. 2021. Unity is Strength: A Formalization of Cross-Domain
Maximal Extractable Value. arXiv preprint arXiv:2112.01472 (2021).

[34] Torben Pryds Pedersen. 1991. Non-interactive and information-theoretic secure

verifiable secret sharing. In CRYPTO. Springer.

[35] Larry L Peterson, Nick C Buchholz, and Richard D Schlichting. 1989. Preserving
and using context information in interprocess communication. ACM TOCS
(1989).

[36] Kaihua Qin, Liyi Zhou, and Arthur Gervais. 2021. Quantifying blockchain ex-

tractable value: How dark is the forest? arXiv preprint arXiv:2101.05511 (2021).

[37] Michael K Reiter and Kenneth P Birman. 1994. How to securely replicate services.

ACM TOPLAS (1994).

[38] Adi Shamir. 1979. How to share a secret. Commun. ACM (1979).
[39] Victor Shoup and Rosario Gennaro. 1998. Securing threshold cryptosystems

against chosen ciphertext attack. In EUROCRYPT. Springer.

[40] Lei Yang, Seo Jin Park, Mohammad Alizadeh, Sreeram Kannan, and David Tse.
2022. DispersedLedger: High-Throughput Byzantine Consensus on Variable
Bandwidth Networks. In USENIX NSDI.

[41] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. Hotstuff: Bft consensus with linearity and responsiveness. In ACM
PODC.

[42] Haoqian Zhang, Louis-Henri Merino, Vero Estrada-Galinanes, and Bryan Ford.
2022. Flash Freezing Flash Boys: Countering Blockchain Front-Running. In
DINPS.

[43] Yunhao Zhang, Srinath Setty, Qi Chen, Lidong Zhou, and Lorenzo Alvisi. 2020.
Byzantine ordered consensus without Byzantine oligarchy. In USENIX OSDI.

A EVALUATION (PRELIM.)
Threshold encryption and secret sharing provide slightly different
properties when combined with a protocol like Fino. We imple-
mented both schemes and compared their performance. For secret
sharing, we implemented SSS [38], while for threshold encryption
we implemented the TDH2 scheme [39]. First, we investigated the
computational overhead that these schemes incur. We selected the
schemes with the most efficient cryptographic primitives we had

9

Dahlia Malkhi and Pawel Szalachowski
Chainlink Labs

B FINO PSEUDO-CODE

Algorithm 1: Finoâ€™s main event-handling loop. We omit
validation and basic sanity checks on DAG deliver()
events.

function on deliver(vote(r))
DAG[r].votes.add(vote);
if |DAG[r].votes|>F then

commit(DAG[r].proposal) into DAG.allCommitted;
for tx âˆˆ DAG.allCommitted do

if tx.myShare âˆ‰ tx.shares then

broadcast(Reveal(tx) â€“ optimistic);

end
if |tx.shares|>2F âˆ§ Reconstruct(tx.shares) fails then

broadcast(Reveal(tx) â€“ pessimistic);

end

end
for tx âˆˆ DAG[r].encrypted do
if |tx.shares|>2F then
Reconstruct(tx);

end

end

end
checkViewChange();
function on deliver(share)

tx â† DAG.txs[share.txID];
tx.shares.add(share);
checkViewChange();

function on deliver(complaint(r))

DAG[r].complaints.add(complaint);
checkViewChange();
function on CommitTimeout()
broadcast(complaint(r));
function checkViewChange()

viewAâ† |DAG[r].votes| > F âˆ¨ |DAG[r].complaints| > 2F;
viewBâ† True;
for tx âˆˆ DAG.allCommitted do

if |tx.shares| < 2F + 1 âˆ¨ Reconstruct(tx.shares) fails then

viewBâ†False;
break;

end

end
if viewA and viewB then

r â† r+1;
if self == DAG[r].leader then
broadcast(proposal(r));

end

end

10

