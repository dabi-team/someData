2
2
0
2

n
u
J

9

]

C
D
.
s
c
[

1
v
0
1
7
4
0
.
6
0
2
2
:
v
i
X
r
a

Boston University Department of Physics

Discussion of antum Consensus Algorithms

Samuel Fulton, Lifu Zhang

Abstract Leader election is a crucial process in many areas such as cloud computing, distributed systems, task orchestra-
tion, and blockchain. Oentimes, in a distributed system, the network needs to choose a leader, which would be responsible
for synchronization between dierent processors, data storage, information distribution, and more. In the case where the
network is anonymous, no classical algorithms could solve the problem exactly. However, in the seing of quantum comput-
ers, this problem is readily solved. In this paper, we analyze the quantum consensus algorithm developed by Seiichiro Tani.
We look at the inner workings of the algorithm and develop a circuit representation of the key steps. We review Mochonâ€™s
fault tolerant leader election algorithm. We then implement a simple leader election algorithm on a quantum computer.

Introduction

In this paper, we will introduce distributed sys-
tems and consensus algorithms. We then zoom in
and look at a specific class of distributed systems
known as anonymous or symmetric distributed
From there, we introduce the classi-
systems.
cal approach to breaking symmetry and electing
a leader. We show that there is no classical de-
terministic algorithm for leader election among an
anonymous distributed system. We then introduce
two quantum algorithms developed by Seiichiro
Tani in [Tani et al. (2012)] for anonymous leader
election.
The quantum algorithms for anony-
mous leader election are more than computational
speedups; they are deterministic solutions to a clas-
sically non-deterministic problem. We implement
the second quantum leader election algorithm in
Qiskit. Lastly, we analyze work by Mochon and Ki-
taev, [Mochon (2007)], on developing fault-tolerant
leader election algorithms.

Distributed Systems

We will start with a brief definition of consensus
and distributed systems. We define a distributed
system to be a collection of communicating proces-
sors all working towards a common goal. Letâ€™s con-
sider a toy example. Imagine a distributed system
of computers aempting to factor a large number
ğ‘ . Once one processor â€œbelievesâ€ that it has fac-
tored the number, it proposes its prime factors, ğ‘ƒğ‘– ,
of N. The other processors in the distributed sys-
tem check if (cid:206)ğ‘– ğ‘ƒğ‘– = ğ‘ . If the majority of the pro-

1

cessors agree that (cid:206)ğ‘– ğ‘ƒğ‘– = ğ‘ then ğ‘ƒğ‘– is accepted
as the factors of ğ‘ . All of the processors can now
move on to factoring a dierent prime number ğ‘€,
all the while remembering that the prime factors
of ğ‘ have been decided. Other examples where
consensus algorithms come into play include leader
election, blockchain, load balancing, clock synchro-
nization, and more.

Three things characterize a distributed system:
Agreement, Validity, and Termination. As the name
suggests agreement means that all non-faulty pro-
cessors must agree on the same value. In the case
of factoring ğ‘ , all non-faulty processors must ei-
ther agree that ğ‘ƒğ‘– are the factors of N or all agree
that ğ‘ƒğ‘– are not the factors of ğ‘ . Validity is the asser-
tion that under non-Byzantine conditions, the dis-
tributed system will never return an incorrect re-
sult. In the example of the processors aempting
the factor ğ‘ , this would mean that given suicient
time all non-faulty processors would find the same
prime factors of ğ‘ . Termination is the assertion
that given enough time the processors are guaran-
teed to complete the task.

What do we mean when by non-faulty proces-
sors? There are two types of faulty processors.
The first is a processor that experienced a crash.
This processor stops responding to other proces-
sors in the distributed system. This is a common
occurrence. However, since distributed systems
only need the majority of processors to work, crash
failures are readily dealt with. The second type
of faulty processor experiences Byzantine failure.
Byzantine failure occurs when a processor mal-
functions in a way such that it sends incorrect data

 
 
 
 
 
 
Boston University Department of Physics

to the distributed system. An example of a Byzan-
tine processor is a hacked processor. For consen-
sus problems having Byzantine failures is the worst
scenario. Fault-tolerant consensus algorithms ad-
dress crash and Byzantine failure. The most widely
used consensus algorithms in distributed and cloud
computing systems are Paxos and its variants such
as Ra. These algorithms are used for leader elec-
tion and typically tolerate non-Byzantine failures.

antum Consensus

Mazzarella categorizes quantum consensus into
four classes in [Mazzarella et al.
ğœ-
reduced state consen-
expectation consensus,
sus, symmetric state consensus, and single ğœ-
measurement consensus. Consider a quantum net-
work consist of three qubits, and three observables
of the form.

(2015)].

ğœ 1 = ğœğ‘§ âŠ— ğ¼ âŠ— ğ¼,
ğœ 2 = ğ¼ âŠ— ğœğ‘§ âŠ— ğ¼,
ğœ 3 = ğ¼ âŠ— ğ¼ âŠ— ğœğ‘§ .

The system is in consensus concerning the expec-
tation of ğœğ‘§ if

ğ‘‡ğ‘Ÿ (ğœŒğœ 1) = ğ‘‡ğ‘Ÿ (ğœŒğœ 2) = ğ‘‡ğ‘Ÿ (ğœŒğœ 3).

Noted that antum consensus is achieved by a
quantum network rather than traditional compu-
tational resources. They are similar counterparts,
though we must take account of probabilistic out-
comes due to the stochastic nature of quantum
mechanics. We will show how quantum entangle-
ments can oer an advantage in terms of reaching
an agreement in a distributed seing.

Leader Election

As described in [Bro], â€leader election is the simple
idea of giving one thing (a process, host, thread, ob-
ject, or human) in a distributed system some spe-
cial powers. Those special powers could include
the ability to assign work, the ability to modify a
piece of data, or even the responsibility of handling
all requests in the system.â€ Leader election is ex-
tremely useful for improving eiciency. A leader
can oen bypass consensus algorithms and sim-
ply inform the system about changes that will be
made. Leaders can help with consistency because
they can see all of the changes that have been made
to the system. By acting as a central data cache,
a leader can improve consistency across the entire
system.

Figure 1:

A single leader does introduce some drawbacks.
Namely, a single leader is a critical point for fail-
ure. If the leader crashes the entire distributed sys-
tem may halt. Furthermore, if a single leader ex-
periences Byzantine failure, the entire system may
waste time following incorrect protocols. However,
many of these drawbacks are mitigated through
the use of consensus algorithms. Oentimes, the
improved eiciency of leader election out ways any
drawbacks. In the next section, we will explore how
leaders can be fairly elected.

Leader Election Algorithm I

One interesting consensus problem is the anony-
mous leader election. Anonymous leader election
is used in the case where we have a collection of
identical processors and wish to designate a leader.
Figure 1 depicts an anonymous distributed system.
In the system, processors do not have unique iden-
tification and all run the same protocol. Thus, the
system is symmetric under all permutations. The
symmetry of the system prevents non-probabilistic
leader election. The classical approach outlined by
Seiichiro Tani in [Tani et al. (2005)] is to install a
coin flip in each processor. Each processor flips
a coin if heads it is eligible for leader election. If
the coin is tails, it is a follower. If multiple proces-
sors get heads, then the protocol is repeated with
the eligible candidates. Note that this process is
non-deterministic and has an expected run time of
ğ‘‚ (log(ğ‘›)), where ğ‘› is the number of processors.
Letâ€™s compare this to a simplistic quantum leader
election algorithm, which was proposed in [Tani
et al. (2012)]. We will start with a two-processor
scenario. For this algorithm, we have two proces-
sors ğ´ and ğµ. We generate the quantum state

ğ‘Š =

1
âˆš

2

(|01(cid:105) + |10(cid:105)).

2

Boston University Department of Physics

or

(|01(cid:105) + |10(cid:105)) |00(cid:105) .
If the system collapses to the (|01(cid:105) + |10(cid:105)) |00(cid:105) state,
processor ğ´ measures its |ğ‘…1(cid:105) state and processor
ğµ measures |ğ‘…2(cid:105) state. Whichever processor mea-
sures |1(cid:105) is the leader. If the system collapses into
the state (|00(cid:105) + |11(cid:105)) |11(cid:105), both processors apply
the unitary operation

ğ‘ˆ =

(cid:19)

(cid:18) 1 âˆ’ğ‘–
âˆ’ğ‘–
1

1
âˆš

2

to their ğ‘† states.

ğ‘ˆğ´ âŠ— ğ‘ˆğµ (|00(cid:105) + |11(cid:105))
= ğ‘ˆğ´ |0(cid:105) âŠ— ğ‘ˆğµ |0(cid:105) + ğ‘ˆğ´ |1(cid:105) âŠ— ğ‘ˆğµ |1(cid:105) ,
= (|0(cid:105) âˆ’ ğ‘– |1(cid:105)) âŠ— (|0(cid:105) âˆ’ ğ‘– |1(cid:105))
+ (|0(cid:105) âˆ’ ğ‘– |1(cid:105)) âŠ— (|0(cid:105) âˆ’ ğ‘– |1(cid:105)),
= |00(cid:105) âˆ’ ğ‘– |01(cid:105) + ğ‘–2 |11(cid:105)
+ ğ‘–2 |00(cid:105) âˆ’ ğ‘– |01(cid:105) âˆ’ ğ‘– |10(cid:105) + |11(cid:105) ,
= âˆ’ğ‘– (|01(cid:105) + |10(cid:105)).

Just like in the first case, processor ğ´ measures
its |ğ‘…1(cid:105) state, and processor ğµ measures |ğ‘…2(cid:105) state.
Whichever processor measures |1(cid:105) is the leader.

This algorithm is readily extended into the case
with ğ‘› nodes. Before we start we need one defini-
tion. We say a string ğ‘¥ = ğ‘¥1ğ‘¥2...ğ‘¥ğ‘› is consistent if
all substrings ğ‘¥ğ‘– are equal. Each processors starts
by generating the state

ğ‘…ğ‘– =

1
âˆš

2

(|0(cid:105) + |1(cid:105)).

The state of the system is

(cid:214)

ğ‘…ğ‘– =

ğ‘–

1
âˆš
2ğ‘›

2ğ‘›âˆ’1
âˆ‘ï¸

ğ‘–=0

|ğ‘–(cid:105) .

Each processor stores the consistency of the sys-
tem in the qubit |ğ‘†ğ‘– (cid:105). The circuit for the process is
shown in Fig 3

The global system becomes

|ğ‘…1...ğ‘…ğ‘›ğ‘†1...ğ‘†ğ‘›(cid:105) = ((cid:12)
(cid:12)0âŠ—ğ‘› (cid:11) + (cid:12)
2ğ‘›âˆ’2
âˆ‘ï¸

+

|ğ‘–(cid:105) (cid:12)

(cid:12)0âŠ—ğ‘› (cid:11) .

(cid:12)1âŠ—ğ‘› (cid:11)) (cid:12)

(cid:12)1âŠ—ğ‘› (cid:11)

ğ‘–=1

Each processor now measures its |ğ‘†(cid:105) state. The sys-
tem collapse to either

((cid:12)
(cid:12)0âŠ—ğ‘› (cid:11) + (cid:12)

(cid:12)1âŠ—ğ‘› (cid:11)) (cid:12)

(cid:12)1âŠ—ğ‘› (cid:11)

or

3

2ğ‘›âˆ’2
âˆ‘ï¸

ğ‘–=1

|ğ‘–(cid:105) (cid:12)

(cid:12)0âŠ—ğ‘› (cid:11) .

Figure 2:

We send the first qubit to processor ğ´ and the sec-
ond qubit to processor ğµ. If processor ğ´ measures
|1(cid:105), we know processor ğµ must measure 0 and vice
versa. Whichever processor measures |1(cid:105) becomes
the leader. For ğ‘› processors we generate the state

ğ‘Šğ‘› =

=

1
âˆš
ğ‘›

1
âˆš
ğ‘›

(|10...0(cid:105) + ... + |0...01(cid:105)),

ğ‘›âˆ’1
âˆ‘ï¸

ğ‘˜=0

(cid:12)
ğ‘˜ (cid:69)
(cid:12)
(cid:12)2

.

Each processor receives a qubit. Whichever proces-
sor measures |1(cid:105) is the leader. This algorithm ter-
minates aer one run, which is in stark contrast to
the non-deterministic classical leader election.

Algorithm II

There is a more robust approach to quantum leader
election proposed in [Tani et al. (2012)]. Consider
the case with processors ğ´ and ğµ. Each processor
prepares the state

|ğ‘…1(cid:105) = |ğ‘…2(cid:105) =

1
âˆš

2

(|0(cid:105) + |1(cid:105)).

We send |ğ‘…1(cid:105) and |ğ‘…2(cid:105) through the following circuit,
where ğ‘‹ is the Pauli matrix ğ‘‹ corresponding to a bit
flip, and the remaining two gates are control not
gates.

The output of the circuit is the state

|ğ‘…1 ğ‘…2 ğ‘†1 ğ‘†2(cid:105) = (|00(cid:105) + |11(cid:105)) |11(cid:105)
+ (|01(cid:105) + |10(cid:105)) |00(cid:105) .

In words, ğ‘†1 and ğ‘†2 and both |1(cid:105) if |ğ‘…1(cid:105) and |ğ‘…2(cid:105) are
equal. Processor ğ´ has the state |ğ‘…1 ğ‘†1(cid:105) and proces-
sor ğµ has the |ğ‘…2 ğ‘†2(cid:105) qubit. We note that |ğ‘†1(cid:105) and
|ğ‘†2(cid:105) are entangled. Aer each processor measures
its ğ‘† state, the system will collapse to either

(|00(cid:105) + |11(cid:105)) |11(cid:105)

|R1âŸ©â€¢â€¢Xâ€¢â€¢X|R1âŸ©|R2âŸ©â€¢â€¢Xâ€¢â€¢X|R2âŸ©|0âŸ©1|S1âŸ©|0âŸ©2|SnâŸ©Boston University Department of Physics

ğ‘ˆ .
Instead, for each processor we need an addi-
tional register |ğ‘‡ğ‘– (cid:105) initialized to |0(cid:105). Set ğ‘‡ğ‘– = ğ‘…ğ‘– âŠ• ğ‘‡ğ‘– .
ğ‘‰ğ‘› as the
Then apply ğ‘‰ğ‘› to ğ‘…ğ‘– âŠ— ğ‘‡ğ‘– . We define
matrix

ğ‘…ğ‘›+1

1âˆš

âˆš
âˆš

2
2
ğ‘…ğ‘›
0

1/
(cid:169)
1/
(cid:173)
âˆš
(cid:173)
(cid:173)
(cid:173)
(cid:171)

0
0

âˆš

0
ğ‘…ğ‘› + 1

âˆ’

âˆš

ğ‘›

âˆš

ğ‘…ğ‘›
ğ‘…ğ‘›ğ‘’âˆ’ğ‘– ğœ‹
âˆ’ğ‘–ğ‘’âˆ’ğ‘– ğœ‹ğ¼ğ‘›
2ğ‘›
âˆš
2ğ‘…2ğ‘›
0

âˆš
2
âˆš
2

ğ‘’ğ‘– ğœ‹
ğ‘› /
ğ‘’âˆ’ğ‘– ğœ‹
ğ‘› /
âˆš

âˆ’

ğ‘…ğ‘›
0

,

(cid:170)
(cid:174)
(cid:174)
(cid:174)
(cid:174)
(cid:172)

where ğ‘…ğ‘› and ğ¼ğ‘› are the real and imaginary
parts of ğ‘’ğ‘– ğœ‹
ğ‘› , respectively. This matrix is well de-
fined since 0 < |ğ‘…ğ‘› | < 1. With some calcula-
tions ğ‘‰ğ‘› is shown to be unitary. Similar to the
case where ğ‘› is even, for symmetry to be preserved
the system must be in one of the following states
|00(cid:105) âŠ—ğ‘˜ , |01(cid:105) âŠ—ğ‘˜ , |10(cid:105) âŠ—ğ‘˜ , |11(cid:105) âŠ—ğ‘˜ . However, aer each
processor applies ğ‘‰ğ‘›, the probability of the system
being in any one of these states is

(cid:17)ğ‘›

(cid:17)ğ‘›

Prob(|00(cid:105) âŠ—ğ‘›

) =

1
2ğ‘…ğ‘› + 2
(cid:17)ğ‘›(cid:105)

,

1
âˆš

(cid:104)(cid:16)

âˆš

2

ğ‘›

ğ‘’ğ‘– ğœ‹
2ğ‘…ğ‘› + 2

(cid:16)

âˆš

+

= 0,

Prob(|01(cid:105) âŠ—ğ‘›

) =

+

= 0,

1
âˆš

(cid:104)(cid:16)

âˆš

2
(cid:16) âˆ’ğ‘’ğ‘– ğœ‹
âˆš

ğ‘›

1
2ğ‘…ğ‘› + 2
(cid:17)ğ‘›(cid:105)

,

2ğ‘…ğ‘› + 2

Figure 3:

If the system collapses to

2ğ‘›âˆ’2
âˆ‘ï¸

ğ‘–=1

|ğ‘–(cid:105) (cid:12)

(cid:12)0âŠ—ğ‘› (cid:11)

then the system ğ‘…1â€¦ğ‘…ğ‘› is inconsistent. Since the
system is inconsistent at least one ğ‘…ğ‘– = |0(cid:105) and at
least one (cid:12)
(cid:12)ğ‘… ğ‘— (cid:11) = |1(cid:105). Any processor that measures
its |ğ‘…ğ‘– (cid:105) = |1(cid:105) is a leader candidate. Any processor
that measures its |ğ‘…ğ‘– (cid:105) = |0(cid:105) is a follower. There
are now at most (ğ‘› âˆ’ 1) leader candidate, for which
the process is repeated. In the event that the sys-
tem collapsed to the ((cid:12)
(cid:12)0âŠ—ğ‘› (cid:11) + (cid:12)
(cid:12)1âŠ—ğ‘› (cid:11) state, we
need to apply a unitary such that the symmetry is
broken. If the number of states ğ‘› is even then we
apply the unitary

(cid:12)1âŠ—ğ‘› (cid:11)) (cid:12)

ğ‘ˆ =

(cid:18)

1
âˆ’ğ‘’ğ‘–ğœ‹ /ğ‘›

1
âˆš
2

(cid:19)

,

ğ‘’âˆ’ğ‘–ğœ‹ /ğ‘›
1

to each |ğ‘…ğ‘– (cid:105), which we will show breaks the sym-
metry. For symmetry to be preserved the system
|ğ‘…1...ğ‘…ğ‘›(cid:105) must be in the state |0(cid:105) âŠ—ğ‘› or |1(cid:105) âŠ—ğ‘› . Aer
each processor applies ğ‘ˆ to |ğ‘…ğ‘– (cid:105), the probability of
being in either of these states is

,

Prob(|0(cid:105) âŠ—ğ‘›

) =

1
âˆš

2

(cid:104)(cid:16) 1
âˆš

2

(cid:17)ğ‘›

+

(cid:16) ğ‘’ğ‘– ğœ‹
ğ‘›
âˆš
2

(cid:17)ğ‘›(cid:105)

,

= 0,

and

Prob(|1(cid:105) âŠ—ğ‘›

) =

1
âˆš

2

(cid:104)(cid:16) 1
âˆš
2

(cid:17)ğ‘›

+

ğ‘›

(cid:16) âˆ’ğ‘’ğ‘– ğœ‹
âˆš
2

(cid:17)ğ‘›(cid:105)

,

= 0.

Thus, aer applying ğ‘ˆ the probability of being in
a symmetric state is zero. Aer applying ğ‘ˆ , if a
processor measures its |ğ‘…ğ‘– (cid:105) to be |1(cid:105), it is a leader
candidate. Since the system is in an asymmetric
state, at least one processor will lose eligibility, and
at least one processor will remain eligible.
If the
number of states ğ‘› is odd we cannot simply apply

Prob(|10(cid:105) âŠ—ğ‘›

) =

(cid:104)(cid:16)

1
âˆš

2

âˆ’

âˆš

(cid:16)

âˆš

+

1
2ğ‘…ğ‘› + 2

= 0,

(cid:17)ğ‘›

1
2ğ‘…ğ‘› + 2
(cid:17)ğ‘›(cid:105)

,

Prob(|11(cid:105) âŠ—ğ‘›

) = 0.

Thus, the symmetry is broken. Each processor
now measures |ğ‘…ğ‘– ğ‘‡ğ‘– (cid:105), and the processors with the
largest value of |ğ‘…ğ‘–ğ‘‡ğ‘– (cid:105) are candidates for the next
round. Again, since symmetry was broken, at least
one processor will lose eligibility, and at least one
processor will remain eligible.

4

|R1âŸ©â€¢...â€¢Xâ€¢...â€¢X|R1âŸ©|R2âŸ©â€¢...â€¢Xâ€¢...â€¢X|R2âŸ©...|RnâŸ©â€¢...â€¢Xâ€¢...â€¢X|RnâŸ©|0âŸ©1|S1âŸ©...|0âŸ©n|SnâŸ©Boston University Department of Physics

antum Consensus and Non-
Bias Leader Election

Up to this point, we have been assuming no faulty
processors. Maor Ganz considers the case with a
group of ğ‘› processors who do not trust each other
In his paper, [Ganz
and want to elect a leader.
(2017)], Ganz considers an algorithm that gives an
ğ‘› âˆ’ ğœ– probability of win-
honest processor at least 1
ning. Using classical consensus, this problem was
shown to be impossible by Mochon in [Mochon
(2007)]. However, using quantum consensus Mo-
chon showed that in certain cases one can formu-
late an algorithm with arbitrarily small ğœ–.

This algorithm is based on a series of quantum
coin flips in tournament style. In other words, pro-
cessors are paired and a single quantum coin flip is
used to eliminate a processor from each pair. The
main diiculty is in creating fault-tolerant coin-
flipping.

There are two types of bias coin flipping: strong
and weak coin-flipping. A strong coin-flipping pro-
tocol with bias ğœ– is a protocol in which neither party
is capable of forcing the probability of any given
flip to be greater than 1/2 + ğœ–. In weak coin flip-
ping, both parties, Alice and Bob, have a prede-
termined desired coin outcome. For example, a 1
can be thought of as Alice winning and a 0 can be
thought of as Bob winning. In weak coin flipping,
neither player can shi the probability of the coin
flip towards their desired outcome with probabil-
ity greater than 1/2 + ğœ–. In the classical scenario,
weak and strong coin flipping are essentially equiv-
alent. However, as Mochon states â€in the quantum
world the two are very dierent,â€ [Mochon (2007)].
For this paper, we will only be concerned with weak
coin-flipping.

Machonâ€™s algorithm, or rather his proof of the
existence of an algorithm for weak coin flipping
with arbitrarily small bias is a significant result in
quantum algorithms. However, as stated by Ganz
â€the result has not been peer-reviewed, its novel
techniques (and in particular Kitaevâ€™s point game
formalism) have not been applied anywhere else,
and an explicit protocol is missing,â€ [Ganz (2017)].
With that said, the basic setup for weak coin flip-
ping is quite similar to the setup for algorithms II.
Figure 4 illustrates the process. Alice starts with
state (cid:12)
(cid:11) on space ğ´ and Bob starts with state
(cid:12)ğœ“ğ´,0
(cid:12)
(cid:11) on state ğµ. On every odd round Alice applies
(cid:12)ğœ“ğµ,0
a unitary ğ‘ˆğ´,ğ‘– and projection ğ¸ğ´,ğ‘– to space ğ´ âŠ— ğ‘€,
and on every even round Bob applies a unitary ğ‘ˆğ‘,ğ‘–
and projection ğ¸ğµ,ğ‘– to space ğ‘€ âŠ— ğµ. The basic idea is
that by applying specific unitaries and projections,
an honest player can decrease any bias to arbitrar-

ily small values.
Figure 4: retrieved from [Aharonov et al. (2014)]

Mochonâ€™s paper proving this result is 80 pages,
and we do not have the time to go into detail.
However, this is an impressive result in quantum
information and demonstrates some of the beauty
of the field.

Implementation

By using several existing quantum soware pack-
ages, we were able to simulate antum Leader
Election Algorithm II. We used the packages listed
below.

â€¢ Qiskit is an open-source SDK for working
with quantum computers at the level of
pulses, circuits, and application modules.

â€¢ ProjectQ is an open-source soware frame-
work for quantum computing.
It provides
tools for implementing and running quan-
tum algorithms using either classical hard-
ware.

â€¢ SimulaQron allows distributed simulation of
the nodes in a quantum internet network.

5

Boston University Department of Physics

anonymous parties. Mochon demonstrated that
quantum consensus algorithms can be used to
fairly elect a leader even under Byzantine condi-
tions. While these algorithms have not been used
in practice, they oer excellent insight into both in-
formation theory and quantum mechanics.

References

Leader

election in distributed systems.

hps://d1.awsstatic.com.

Aharonov, Dorit, AndrÂ´e Chailloux, Maor Ganz, Ior-
danis Kerenidis, and LoÂ¨Ä±ck Magnin. 2014. A sim-
pler proof of existence of quantum weak coin
flipping with arbitrarily small bias. SIAM Jour-
nal on Computing, 45.

Ganz, Maor. 2017. antum leader election. an-

tum Information Processing, 16:1â€“17.

Mazzarella, Luca, Alain Sarlee, and Francesco
Ticozzi. 2015. Consensus for quantum networks:
Symmetry from gossip interactions. IEEE Trans-
actions on Automatic Control, 60(1):158â€“172.

Mochon, Carlos. 2007. antum weak coin flipping

with arbitrarily small bias.

Tani, Seiichiro, Hirotada Kobayashi, and Keiji Mat-
sumoto. 2005. antum leader election via exact
amplitude amplification.

Tani, Seiichiro, Hirotada Kobayashi, and Keiji Mat-
sumoto. 2012. Exact quantum algorithms for the
leader election problem. ACM Trans. Comput.
Theory, 4:1:1â€“1:24.

The source of
implementation for simulating
antum Leader Election Algorithm can be found
at
https://github.com/lifuzhang1108/
quantum-consensus.
Pseudo code:

1. Prepare

one-qubit
ğ‘…1,â€¦,ğ‘…6, ğ‘‡1, ...,ğ‘‡6 and ğ‘†6, ..., ğ‘†6.

quantum registers

2. For each processor, do the following:

3. If ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘  = â€œeligible,â€

Set |ğ‘…ğ‘– (cid:105) = (|0(cid:105) + |1(cid:105))/
Set |ğ‘†(cid:105) = |0(cid:105);

âˆš

2

4. Apply circuit in figure 3.

5. Measure |ğ‘†(cid:105).

6. If |ğ‘†(cid:105) = |0(cid:105), measure |ğ‘…ğ‘– (cid:105).

If |ğ‘…ğ‘– (cid:105) = |1(cid:105), ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘  = â€œeligible.â€
If |ğ‘…ğ‘– (cid:105) = |0(cid:105), ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘  = â€œineligible.â€

7. If |ğ‘†(cid:105) = |1(cid:105)

and there are an even number of eligible
processors,
apply unitary ğ‘ˆ to |ğ‘…ğ‘– (cid:105),
measure |ğ‘…ğ‘– (cid:105).
If |ğ‘…ğ‘– (cid:105) = |1(cid:105), ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘  = â€œeligible,â€
If |ğ‘…ğ‘– (cid:105) = |0(cid:105), ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘  = â€œineligible,â€

8. If |ğ‘†(cid:105) = |1(cid:105)

and there are an odd number of eligible
processors,
initialize ğ‘‡ğ‘– and apply unitary ğ‘‰ğ‘› to |ğ‘…ğ‘–ğ‘‡ğ‘– (cid:105).
Measure
|ğ‘…ğ‘–ğ‘‡ğ‘– (cid:105)
ğ‘…ğ‘–ğ‘‡ğ‘–
ğ‘šğ‘ğ‘¥ (ğ‘…1ğ‘‡1, .., ğ‘…ğ‘›ğ‘‡ğ‘›), ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘  = â€œeligible,â€
If ğ‘…ğ‘–ğ‘‡ğ‘– < ğ‘šğ‘ğ‘¥ (ğ‘…1ğ‘‡1, .., ğ‘…ğ‘›ğ‘‡ğ‘›), ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘  = â€œineli-
gible,â€

all

If

=

9. Output status.

Summary

antum computing provides tools for achieving
consensus in a distributed system. It is shown by
Tani that the classically non-deterministic anony-
mous leader election problem is can be solved de-
terministically using quantum computers. As a
proof of concept demonstration, we implemented
the quantum algorithms in Qiskit and simulated
quantum network using SimulaQron, the algo-
rithm can successfully elect a single leader among

6

