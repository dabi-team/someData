Trustless Cross-chain Communication for
Zendoo Sidechains

Alberto Garoﬀolo
alberto@horizen.global
Horizen

Dmytro Kaidalov
dmytro.kaidalov@iohk.io
Input Output

Roman Oliynykov
roman.oliynykov@iohk.io
Input Output
V.N.Karazin Kharkiv National University

September 2022

Abstract

In the Zendoo white paper [7, 1], we introduced a novel sidechain construction for Bitcoin-like
blockchains, which allows a mainchain to create and communicate with sidechains of diﬀerent
types without knowing their internal structure. In this paper, we take a step further by intro-
ducing a comprehensive method for sidechains to communicate amongst each other. We will
also discuss the details of a cross-chain token transfer protocol that extends the generic commu-
nication mechanism. With the cross-chain token transfer protocol, it can enable a broad range
of new applications, such as an exchange platform, that allows the ability to trade tokens issued
from diﬀerent sidechains.

2
2
0
2

p
e
S
8

]

R
C
.
s
c
[

1
v
7
0
9
3
0
.
9
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
Contents

1 Introduction

2 Zendoo Overview

2.1 Ceased sidechain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Sidechain transactions commitment . . . . . . . . . . . . . . . . . . . . . . . . . .

3 Cross-Sidechain Communication Protocol

3.1 Message passing

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sending a message . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.1
3.1.2 Committing a message . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.3 Receiving a message . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Message passing from a ceased sidechain . . . . . . . . . . . . . . . . . . . . . . .

4 Mitto Token Transfer Protocol

4.1 Tokens data structures and state . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Sending tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 Receiving tokens
4.4 Transferring tokens from a ceased sidechain . . . . . . . . . . . . . . . . . . . . .
4.4.1 Withdrawing native tokens
. . . . . . . . . . . . . . . . . . . . . . . . . .
4.4.2 Withdrawing foreign tokens . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.5.1 Token wrapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.5 Design rationale

5 Conclusions

3

3
6
7

8
8
10
10
10
11

12
12
15
17
19
20
20
20
21

21

2

1

Introduction

Since the appearance of Bitcoin [11], blockchain technology has gained great attention in both
industry and academia. Experts from various ﬁelds have started exploring and building new
platforms and applications. The distinguishing feature of Bitcoin - the absence of a centralized
control - is perceived to be disruptive to the existing ﬁnancial systems, thereby making them
more robust, fair, and transparent. Bitcoin inspired the development of many other similar
crypto-platforms with a variety of diﬀerent features.

The adoption of Bitcoin and other cryptocurrencies grew signiﬁcantly during the previous
decade, which also exposed their limitations such as limited throughput, increased latency, and
reduced ability to scale [6]. In 2014, A. Back et al. proposed a concept of sidechains [2] that
has the potential to overcome these limitations. The basic premise is to create many sub-
blockchains that are interoperable with the main blockchain. They operate separately but can
transact with the mainchain native asset. In this way, blockchain systems like Bitcoin can extend
their functionality implemented in a sidechain (e.g., introduce smart contracts [9]).

In 2020, we introduced Zendoo [7, 1] - a universal construction for blockchain systems that
allows users to create and communicate with sidechains of diﬀerent types without knowing their
internal structure. Moreover, we proposed a speciﬁc sidechain construction, named Latus, that
can be built on top of this infrastructure and can realize a decentralized, veriﬁable blockchain
system. It leverages the use of zk-SNARKs [3, 8] to generate succinct proofs of sidechain state
progression [10, 4] that are used to validate cross-chain transfers of assets between the mainchain
and sidechain.

In this paper, we discuss how sidechains can interoperate with one another. The commu-
nication enhances advanced functionalities and enables a plethora of new applications. The
development of cross-blockchain communication involves much complexity. Therefore, it is es-
sential to ensure the security and eﬀectiveness of the developed system. The cross-sidechain
communication protocol (CSCP) utilizes the features of Zendoo to provide security and avoid
the pitfalls of many existing bridging protocols [5]. The protocol provides a way for sidechains
to transfer messages to each other.

Finally, we further build on the cross-sidechain communication protocol and extend it for
transferring tokens issued on diﬀerent sidechains. The main idea is that tokens can be encoded
as messages and then transferred in a veriﬁable method using the CSCP protocol. Thus, trans-
ferring of tokens allows users to utilize and trade them on diﬀerent sidechains, as well as use
them in other decentralized ﬁnancial applications.

The discussion of the cross-sidechain communication protocol for Zendoo is organized in the

following manner:

• Section 2 provides a brief overview of Zendoo and provides a detailed description of im-

portant components for the communication scheme.

• Section 3 provides a detailed description of the generic cross-sidechain communication

protocol.

• Section 4 introduces the Mitto protocol that extends CSCP and speciﬁes secure token

transfers between sidechains.

2 Zendoo Overview

It allows the deployment of customizable
The Zendoo construction was introduced in [7].
sidechains attached to the Bitcoin-like mainchain. Here we provide a general overview and

3

discuss the portions relevant to the cross-sidechain communication protocol. For a full discus-
sion of Zendoo, see the white paper [1].

The main feature of Zendoo is that the mainchain does not know the internal structure of
the sidechains. This feature allows it to build a variety of diﬀerent systems by leveraging the
secure and standardized cross-chain communication.

Zendoo considers the parent-child relationship between the mainchain and sidechains, where
sidechain nodes directly observe the mainchain, while mainchain nodes only observe crypto-
graphically authenticated certiﬁcates from sidechain maintainers. Certiﬁcate authentication
and validation are achieved by using SNARKs [3, 8], which enable constant-sized proofs of ar-
bitrary computations. The main feature of the construction is that sidechains are allowed to
deﬁne their own SNARKs, thereby establishing their own rules for authentication and valida-
tion. All SNARK proofs comply with the same veriﬁcation interface used by the mainchain
which enables universality as the sidechain can use an arbitrary protocol for authenticating its
certiﬁcates. This basic concept is shown in Fig. 2.1.

Figure 2.1: A simpliﬁed communication scheme between a sidechain and the mainchain.

A sidechain is registered to the mainchain by creating a special transaction, which sets the
new sidechain id, its initial state, and more importantly, the SNARK veriﬁcation key. This is
used to validate the certiﬁcates. The mainchain expects certiﬁcates to be submitted in strict
intervals called withdrawal epochs. The length of a withdrawal epoch is also deﬁned in the
sidechain creation transaction.

The basic structure of the withdrawal certiﬁcate is deﬁned by the mainchain and this struc-

ture must be followed by all sidechains.

Deﬁnition 2.1. Withdrawal Certiﬁcate (WCert). A withdrawal certiﬁcate is a standard-
ized posting that allows sidechains (SC) to communicate with the mainchain (MC). Its main
functions are:

• delivering backward transfers to the MC

• serving as a heartbeat message and enabling the mainchain to identify the sidechain status.

WCert is represented by a tuple of the form:

W Cert def= (ledgerId, epochId, quality, BT List, proof data, proof ),

where,

4

ledgerId − an identiﬁer of the sidechain for which WCert is created,
epochId − a number of a withdrawal epoch,
quality
BT List − a list of backward transfers included in this withdrawal certiﬁcate,
proof data − input data to a SNARK veriﬁer,
proof

− an integer value that indicates the quality of this withdrawal certiﬁcate,

− a SNARK proof.

As previously mentioned, the certiﬁcate is veriﬁed upon submission to the mainchain. The

SNARK veriﬁcation interface is the same for all sidechains:

true/f alse ← V erif y(vkW Cert, public input, proof ),
public input def= (wcert sysdata, M H(proof data)),

where,

− a SNARK veriﬁcation key registered upon the sidechain creation;
vkW Cert
wcert sysdata − a part of the public input, which is uniﬁed for all sidechains and
enforced by the mainchain (explained further);

proof data

− a part of the input data deﬁned by the sidechain and passed along the
withdrawal certiﬁcate; it is a list of variables of predeﬁned types whose
semantics are not known to the mainchain;

M H(proof data) − a root hash of a Merkle tree where leaves are variables from proofdata; it
is essential for the SNARK to keep a list of public inputs short. Thus we
combine them in a tree and pass the root hash only1;

proof

− a SNARK proof itself submitted as a part of the certiﬁcate.

The wcert sysdata parameter plays an important role from a security standpoint. The idea
is to allow the mainchain to verify the proof against some public input parameters deﬁned by
the protocol. For instance, the BTList and quality parameters that are part of the certiﬁcate
must be veriﬁed before being used by the mainchain.

The wcert sysdata is represented by the tuple of the following form:

wcert sysdata def= (quality, M H(BT List)), B(i

last)),

where,

quality
M H(BT List) − a root hash of a Merkle tree where leaves are backward transfers from the

− the quality parameter from the withdrawal certiﬁcate,

BTList provided within the certiﬁcate,

H(Bi

last)

− a block hash of the last mainchain block in the withdrawal epoch i.

The ﬂexibility of the scheme comes from the ability of a sidechain to deﬁne proofdata. This
can be an arbitrary set of arguments completely deﬁned by the sidechain. For instance, it
can contain a commitment of the entire state of the sidechain at the moment of creating the
certiﬁcate. Then, the SNARK proof proves the state transition from the state committed in the
previous certiﬁcate.

1A full payload of proofdata is provided during the proof generation as a witness.

5

2.1 Ceased sidechain

As previously stated, the sidechain is obliged to submit a withdrawal certiﬁcate in strict intervals
called withdrawal epochs. If a withdrawal certiﬁcate has not been submitted during this time,
the sidechain is considered ceased and no more withdrawal certiﬁcates for this sidechain will be
accepted by the mainchain. However, the funds can still be withdrawn from the ceased sidechain
by means of a ceased sidechain withdrawal. Since the certiﬁcates are not allowed for the
ceased sidechains, it becomes the backup method to retrieve funds.

Deﬁnition 2.2. Ceased Sidechain Withdrawal (CSW). The CSW is an operation that
allows the movement of coins from the ceased sidechain B to the original mainchain A. It is
represented by a tuple of the following form:

CSW def= (ledgerId, receiver, amount, nullif ier, proof data, proof ),

where,

ledgerId − an identiﬁer of the sidechain for which CSW is created,
receiver − an address of the receiver in the mainchain,
amount − the number of coins to be transferred,
nullif ier − a unique identiﬁer of claimed coins,
proof data − input data to a SNARK veriﬁer,
proof

− a SNARK proof.

The CSW is submitted to the mainchain and has the same validation principle as the with-
drawal certiﬁcate. It is validated by a SNARK proof deﬁned by the sidechain. The veriﬁcation
key vkcsw for the proof is set upon sidechain registration. The syntax of the proofdata and proof
are the same as for the withdrawal certiﬁcate. The basic interface of the SNARK veriﬁer is the
following:

true/f alse ← V erif y(vkcsw, public input, proof ),
public input def= (csw sysdata, M H(proof data)),

where,

vkcsw

− a SNARK veriﬁcation key for the CSW registered upon the sidechain

creation;

csw sysdata

− a part of the public input, which is uniﬁed for all sidechains and

enforced by the mainchain (explained further);

proof data

− a part of the input data deﬁned by the sidechain and passed along the

CSW; it is a list of variables of predeﬁned types whose semantics are not
known to the mainchain;

M H(proof data) − a root hash of a Merkle tree where leaves are variables from proofdata;
− a SNARK proof itself submitted as a part of the CSW.
proof

csw sysdata is deﬁned as:

csw sysdata def= (H(Bw), nullif ier, receiver, amount),

where H(Bw) is a block hash of the mainchain block where the latest withdrawal certiﬁcate

for this sidechain has been submitted.

6

It is completely up to the sidechain to deﬁne the semantics of the proofdata (i.e., what type of
data it contains) and veriﬁcation logic. For instance, one might require proof that a user, who
creates CSW, owns a UTXO holding the amount of coins in the state committed by the last
certiﬁcate before the sidechain was ceased.

See the Zendoo white paper [1] for more information on ceased sidechain withdrawals.

2.2 Sidechain transactions commitment

An important concept for the cross-chain communication in Zendoo is the Sidechain Trans-
actions Commitment (STC). The STC is a special value that is inserted in every mainchain
block and comprises all sidechain-related actions in the MC block for all registered sidechains.
The STC value is a root hash of a Merkle tree that contains all transactions related to any
sidechain (see Fig. 2.2).

Figure 2.2: Sidechain transactions commitment tree.

The root hash h1 commits to all sidechain related transactions included in the MC block.
All SCXHash (h2X ), where X is a sidechain identiﬁer, are ordered by its id and commit to all
transactions related to the sidechain X. W CertHash commits to the WCert for the sidechain
X (if present) and only one WCert is allowed for each sidechain. T xsHash commits to diﬀerent
types of transactions for a particular sidechain.

The STC allows access to all sidechain-related information. Recall that the interface of SNARK
veriﬁcation for both WCert and CSW requires that the input to the proof contains MC block
hash (Def. 2.1-2.2). This means that a SNARK proof can access the entire history of all sidechain
transactions by proving that a certain STC with a certain SC transaction is included in some
MC block. The connection of such MC block to the one provided in the proof can be proved
recursively as the MC blocks are cryptographically chained to each other.

7

h1h21h22h23h24SC1Hash: h21 = H(h31 | h32 | SC1)h31h32TxsHashWCertHashh41h42FTHashBTRHashh51h58FT1SC1BTR4SC1SC2HashSC3HashSC4HashWCertSC1….….….….….SCTxsCommitment3 Cross-Sidechain Communication Protocol

The Zendoo construction deﬁnes only the communication protocol between the mainchain and
a sidechain. It focuses mostly on forward and backward transfers of the native MC asset. A
desirable feature is the ability of disparate sidechains to communicate with one another. It allows
for the creation of powerful new functionality that leverages the beneﬁts of multiple sidechain
networks, simultaneously. However, such cross-sidechain communication can not be a part of
the Zendoo protocol itself because the core concept postulates that the internal structure of the
sidechains is unknown to Zendoo.

Therefore, to enable cross-sidechain communication we introduce a separate Cross-Sidechain

Communication Protocol (CSCP) that extends Zendoo and deﬁnes how the sidechains com-
municate with one another. The basic idea is that sidechains that want to interact with each
other must implement a special generalized interface (see Fig. 3.1).

Figure 3.1: Sidechains A,B,C implement a special CCTP Interface that allows them to commu-
nicate with each other. Sidechain D does not implement the CCTP interface.

The CSCP deﬁnes an abstract mechanism of veriﬁable transferring of messages from one
sidechain to another.
It is implemented by a sidechain using customization capabilities of
Zendoo. The mainchain and Zendoo itself are not aﬀected because Zendoo already has all
the necessary capabilities to create a custom logic inside the sidechains.

Then, the sidechains deﬁne particular types of messages that are exchanged along with the
processing rules for them. For instance, they might implement custom token transfers based on
CSCP interface (see Fig. 3.2).

3.1 Message passing

In a nutshell, the CSCP protocol works the following way: given two sidechains SC1 and SC2,
if a user in SC1 wants to send a message Mi to the sidechain SC2, he creates a transaction
tx(Mi) containing Mi and submits it to SC1. At the end of a withdrawal epoch all cross-
sidechain messages are collected in a Merkle tree, the root hash of the tree becomes a part
of the sidechain state that is included in the withdrawal certiﬁcate. When the certiﬁcate is
conﬁrmed in the mainchain, the state cannot be reverted. Therefore, once the state of SC1
with tx(Mi) has been committed and conﬁrmed in the mainchain, the message can be securely
conﬁrmed in SC2. A user in SC2 can receive a message by directly observing SC1, extracting the
message, and submitting a transaction tx(Mi, proof ) to SC2 together with the proof that the
message Mi has been processed in SC1 and is present in the state conﬁrmed in the withdrawal
certiﬁcate of SC1.

8

Figure 3.2: A layered structure of communication protocols. Zendoo speciﬁes the basic protocol
for communication between the mainchain and a sidechain. CSCP relies on Zendoo and speciﬁes
the abstract protocol for communication amongst the sidechains. Next, the Token Transfer
protocol is built on top of CSCP and speciﬁes a concrete protocol for exchanging tokens among
sidechains.

There are three main phases of the CSCP protocol:

1. Sending the message in the sender sidechain.

2. Committing of the message in the mainchain.

3. Receiving the message in the receiver sidechain.

The main concept is depicted in Fig. 3.3 while the following subsections provide more details

about diﬀerent phases of the protocol.

Figure 3.3: Main phases of the CSCP protocol. The receiving transaction relies on the sending
transaction and commitment of the Sidechain A in the mainchain.

9

3.1.1 Sending a message

The CSCP message is deﬁned as follows:

type CSCP Message {
Int ,
sendingScId:
Int ,
receivingScId :
Int ,
msgType:
ByteArray,
senderId:
receiverId :
ByteArray,
payloadHash: ByteArray

}

where,

sendingScId − the id of the sending sidechain as it was registered in the mainchain;
receivingScId − the id of the receiving sidechain as it was registered in the mainchain;
msgT ype
senderId

− the type of the message (e.g., token);
− the unique id of the sender. The semantics of this id is not known to the

CSCP protocol and is deﬁned by the implementation of the sending
sidechain (e.g., public key);

receiverId

− the unique id of the receiver. The semantics of this id is deﬁned by the

payloadHash − the hash of the message itself.

receiving sidechain (e.g., public key);

The structure of the CSCP message is generalized, where the payload of the message is
represented as a hash, which means that the message can be anything depending on a particular
instantiation of the CSCP protocol. For instance, the message can be some entity like a token,
transaction output, or a text string.

We assume that on the sending sidechain, a user can create a special transaction which
contains CSCP Message. For instance, in the UTXO-based sidechain the message can be rep-
resented as a special output.

3.1.2 Committing a message

At the end of the withdrawal epoch in the sending sidechain, all CSCP messages are combined
into a Merkle tree (Fig. 3.4).

The messages (msgi) are inserted in the tree in the order they are submitted to the sidechain.
The tree contains messages from diﬀerent users and to diﬀerent sidechains. Next, the root hash
of the tree is inserted in the withdrawal certiﬁcate at the end of the epoch as a custom ﬁeld in
the proofdata section. The certiﬁcate proof enforces the validity of the CSCP messages tree.

3.1.3 Receiving a message

To receive a message, a user on the receiving sidechain has to create a special redeem transaction.
To do this, the user directly observes the sending sidechain for messages directed to him, extracts
the message, and constructs a special transaction that includes both the message and the proof
of its validity:

10

Figure 3.4: An example of the Merkle tree with CSCP messages. It contains eight messages,
but the tree expands depending on the actual number of messages in a particular epoch.

CSCP Redeem Tx: {

msg:
payload:
proof:

CSCP Message,
ByteArray,
ByteArray

}

where msg is the original CSCP message from the sending sidechain, the payload is a data
represented by payloadHash, and proof is some abstract proof that veriﬁes the following
statements about message validity:

• The message msg has been accepted and conﬁrmed in the sending sidechain.

• The payload corresponds to payloadHash included in msg.

• The hash of a Merkle tree of CSCP messages containing msg is committed in the with-
drawal certiﬁcate of the sending sidechain and the certiﬁcate has been conﬁrmed in the
mainchain.

• The message msg has not been redeemed in the receiving sidechain.

• The user who redeems the message, has rights to do so.

The CSCP protocol does not deﬁne the exact instantiation of the proof. Depending on the
sidechain implementation there might be diﬀerent ways to implement it. For instance, if the
sidechain is based on Latus construction [1], then its blocks contain references to the MC blocks,
which as discussed in section 2.2, contain Sidechain Transaction Commitment Tree (STC). Given
the access to MC blocks, the sidechain can access STC values, which commit to all SC-related
transactions in all sidechains. Therefore, it can also prove cryptographically that the certiﬁcate
of the sending sidechain with the message was included in the mainchain.

The side eﬀect of processing a received message is deﬁned completely by the SC logic.

3.2 Message passing from a ceased sidechain

Under certain circumstances there might be a need to send a message from a ceased sidechain.
For instance, if the sidechain has tokens that a user wants to recover in another sidechain, then a

11

message can be passed. The CSCP protocol deﬁnes a mechanism based on the Ceased Sidechain
Withdrawal (recall CSW from Def. 2.2) that allows “to withdraw message” from the ceased
sidechain.

In this case, the protocol works in the following way: let there be a ceased sidechain SC1 and
a user U1 who owns some entity E1 (e.g., a token) that is withdrawable by CSW according to
the rules of the sidechain SC1. The CSW SNARK proof of SC1 is implemented in the way that
allows veriﬁcation of the validity of the CSCP Message provided in proofdata as a custom ﬁeld.
A user creates the CSW on the mainchain to withdraw the entity E1 and inserts the message M1
in proofdata. Once the CSW is conﬁrmed in the mainchain, the message can be safely received
in SC2. A user in SC2 can receive a message by directly observing the mainchain, extracting
the message, and submitting a transaction tx(M1, proof ) to SC2 together with the proof that
the message M1 has appeared in the CSW for SC1.

The primary objective of the CSW mechanism, as introduced in the Zendoo white paper [1],
is to recover MC native assets that have been sent to the sidechain. However, it can also be
used for recovering abstract messages as well. In this case, the amount ﬁeld of the CSW has to
be zero, which means that there is a recovery of something other than the native asset.

4 Mitto Token Transfer Protocol

One of the key concepts, when considering blockchain interoperability, is the ability to transfer
assets among diﬀerent chains. There are many considerations, but the main use cases are:

• allow the ability to trade assets from diﬀerent chains,

• enable users to borrow assets on one sidechain by providing tokens issued on another

sidechain as collateral,

• enable transfer of liquidity among diﬀerent sidechains.

In this section we introduce Mitto - an extension to the CSCP protocol that enables trans-
ferring of tokens issued on diﬀerent sidechains. The basic idea is that tokens can be encoded
as messages and transferred in a veriﬁable way using the CSCP protocol. The sent tokens are
burned on the sending side, while on the receiving side they are redeemed when receiving the
message.

One of the main design principles of the Mitto Token Transfer Protocol is that tokens are
tracked by the issuing sidechain when they are sent. Therefore, it is impossible for a malicious
sidechain to send back forged tokens that have not been previously transferred there. This
also implies that the tokens can only be sent from or to the original sidechain, but not among
“foreign” sidechains.

Sidechains that enable token transfer protocol must implement certain interfaces and adhere
to rules of processing tokens that are speciﬁed in this section. The Mitto protocol does not
rely on a speciﬁc sidechain construction and can be integrated into diﬀerent sidechains given
that they follow the general rules of processing tokens. The Mitto protocol can be viewed as
something similar to ERC-20 or ERC-721 standards in Ethereum. For uniﬁcation purposes, the
protocol supports both fungible and non-fungible tokens.

4.1 Tokens data structures and state

The core of the Mitto Token Transfer Protocol is the concept of TokenInstance. It is an entity
that is used to represent tokens inside the sidechain. The protocol does not specify how exactly

12

token instances are managed by the sidechain, it is only assumed that every sidechain that
enables Mitto holds tokens as TokenInstances and follows certain rules when transferring them.
The TokenInstance has the following structure:

Deﬁnition 4.1. Token Instance. TokenInstance is a data structure that represents a single
non-fungible token or some amount of fungible tokens from the same set identiﬁed by a name.
It is deﬁned as follows:

type TokenInstance {
tokenName:
fungibility :
Union {

String ,
Boolean

tokenId:
amount:

Int ,
Int ,

// for non−fungible tokens
// for fungible tokens

}
issuerSidechainID: ByteArray,
ByteArray,
ownerPubKey:
ByteArray,
dataHash:

}

where,

tokenN ame
f ungibility

− a unique name that identiﬁes a set of fungible or non-fungible tokens;
− indicates whether the tokens speciﬁed by tokenName are fungible or
not. Depending on this ﬂag, the TokenInstance structure contains
either tokenId (for non-fungible tokens) or amount ﬁeld (for fungible
tokens). The fungibility ﬂag is the same for all token instances with
the same tokenName;

tokenId

− if the token is non-fungible, then the tokenId deﬁnes a unique

identiﬁer of a particular token in the set deﬁned by the tokenName.
In this case TokenInstance represents a single token with a unique
tokenId ;

amount

− if the token is fungible, then the amount represents an amount of

issuerSidechainID − the unique identiﬁer of the sidechain where the tokens with

fungible tokens held by the token instance;

ownerP ubKey
dataHash

tokenName were originally issued;

− the public key of the owner of a particular token instance;
− the hash of other token-related data that is not relevant to the Mitto
protocol. Recall that the TokenInstance is an abstract data structure
which deﬁnes the basic information needed to manage tokens. A
speciﬁc token type is deﬁned by the sidechain logic and contains
additional data representing the token.

The tokens can be fungible and non-fungible. A fungible token can be represented by several
token instances that have the same tokenName, but diﬀerent amounts. A set of non-fungible
tokens can be represented by several token instances with the same tokenName, but diﬀerent
tokenIDs, where each token instance represents a unique non-fungible token from the set. The
sidechain can issue several diﬀerent sets of fungible or non-fungible tokens.

The TokenInstance structure basically resembles the concept of an output in a UTXO based
blockchain. But in Mitto it is represented abstractly so that the protocol can be implemented
also in a non-UTXO based blockchain.

13

Figure 4.1: Example of sets of fungible (wBTC) and non-fungible (Cars) tokens. TI is a
TokenInstance. A sidechain may issue diﬀerent sets of token instances, it also can contain token
instances issued on other sidechains.

Another data structure that is required to manage tokens in sidechains is SentRecord, which

allows to keep track of tokens that have been sent outside the sidechain.

Deﬁnition 4.2. Sent Record. SentRecord is a data structure that keeps track of the tokens
that were originally issued on the sidechain but then have been sent to some other sidechain. It
is represented as follows:

type SentRecord {

receiverSidechainID: Int ,
tokenName:
fungibility :
Union {

String ,
Boolean

tokenID:
amount:

Int ,
Int ,

// for non−fungible tokens
// for fungible tokens

}

}

where,

receiverSidechainID − unique identiﬁer of the sidechain where the tokens of type

tokenName were sent;

tokenN ame

− a unique name that identiﬁes a set of fungible or non-fungible

f ungibility

tokenId

amount

tokens;

− deﬁnes whether the tokens speciﬁed by tokenName are fungible or
not. Depending on this ﬂag, the SentRecord structure contains
either tokenId (for non-fungible tokens) or amount ﬁeld (for
fungible tokens);

− if the token is non-fungible, tokenId is an identiﬁer of a particular
token that has been sent outside the sidechain of origin. In this
case SendRecord represents a single token with a unique tokenId ;
− if the token is fungible, amount represents an amount of fungible

tokens of type tokenName that have been sent to sidechain
receiverSidechainID.

The TokenInstance and SentRecord are basic structures used for token management in the
Mitto token transfer protocol. It is assumed that a sidechain keeps track of both TokenInstances,
that represent the tokens that a sidechain currently possesses, and SentRecords, that represent

14

the tokens that have been sent outside the sidechain where they were issued. Let formalize the
sidechain state as follows:

SC state
i

= {Stks

i

, Ssent
i

, ...},

where,

• Stks
i

is a set of token instances that are currently owned by the sidechain SCi;

• Ssent
i

is a set of SentRecords to keep track of tokens that were issued on sidechain SCi but
were sent outside it. Each SentRecord from the set keeps track of the amount of tokens of
a particular type that were sent to a particular sidechain.

Note that Stks

i may contain token instances representing tokens issued on other sidechains

(i.e., issuerSidechainID (cid:54)= SCi).

The following sections formalize the rules for transferring tokens using the model described

above.

4.2 Sending tokens

The tokens are sent in the form of CSCP messages which wrap token instances. To send tokens
from SCa to SCb a user creates a special sending transaction txsend
(T It → Mt) on SCa which
SCa
burns a token instance T It and produces an CSCP message Mt with the following data:

Mt: CSCP Message = {

sendingScId
= SCa,
receivingScId = SCb,
msgType
senderId
receiverId
payloadHash

= T okenT ransf er,
= T It.ownerP ubKey,
= receiverPubKey,
= Hash(T It)

}

where receiverP ubKey is the receiver’s public key in SCb speciﬁed by a user. Note that the
validity of the transaction (i.e., that the user is the owner of T It) is veriﬁed upon its processing
by the sidechain.

We formalize the process of sending tokens by deﬁning the validation rules for the txsend
SCa

(TI →
Mt) and the side eﬀects of it to the state of SCa in case the transaction is valid and accepted
by the sidechain SCa.

15

Validation rules

1. Verify T It ∈ Stks

a

(i.e., the token instance exists in the state of SCa).

2. If T It.issuerSidechainId (cid:54)= SCa, then verify that

Mt.receivingScId == T It.issuerSidechainId (i.e., verify that foreign tokens are
sent only to their original blockchain and not elsewhere).

3. Verify semantic validity of Mt:

(a) Mt.sendingScId == SCa;
(b) Mt.receivingScId (cid:54)= SCa;
(c) Mt.msgT ype == T okenT ransf er;
(d) Mt.senderId == T It.ownerP ubKey;
(e) Mt.payloadHash == Hash(T It).

4. Verify that the transaction is authorized by the owner of T It (i.e., there is a signature

on txsend
SCa

(T It → Mt) under the public key T It.ownerP ubKey).

Side eﬀects on the state of SCa

1. T It is removed from Stks
a ;

2. If T It.issuerSidechainId == SCa (i.e., the token issued on this sidechain is being

sent), then:

(a) If T It.f ungibility == f alse, then create a sent record

SRt: SentRecord = {

receiverSidechainID = Mt.receivingScId,
tokenName = T It.tokenN ame,
fungibility = f alse,
tokenId = T It.tokenId

and add SRt to Ssent
by it and sent elsewhere);

a

(the sidechain keeps track of all tokens that were issued

(b) If T It.f ungibility == true, then check if Ssent

(cid:48)

t such that SR

(cid:48)

already contains some sent
t.receivingSidechainID == Mt.receivingScId and

a

t.tokeN ame == T It.tokenN ame. If yes, just update
t.amount = SR

t.amount + T It.amount, otherwise create a sent record

(cid:48)

(cid:48)

record SR
SR
SR

(cid:48)

SRt: SentRecord = {

receiverSidechainID = Mt.receivingScId,
tokenName = T It.tokenN ame,
fungibility = f alse,
amount = T It.amount

}

}

and add SRt to Ssent
that were sent to every other sidechain).

a

(the sidechain keeps track of the total amount of tokens

At the end of the epoch all CSCP messages are collected in the Merkle tree and the hash of
the tree is included in the withdrawal certiﬁcate as a custom ﬁeld, so that they can be received

16

in another sidechain.

4.3 Receiving tokens

To receive a token from SCa in SCb a user creates a special redeem transaction txredeem
(Mt →
T It, proof ) on SCb that includes the message Mt, that has been previously sent from SCa, the
corresponding token instance T It, and a proof of the message validity. The redeem transaction
is an extension of the CSCP Redeem T x (see section 3.1.3). It has the following structure:

SCb

type Mitto Redeem Tx {

CSCP Message,

Mt:
proof : ByteArray,
T It: TokenInstance

}

where Mt is the message that has been previously conﬁrmed in SCa and that wraps the token
instance T It. The proof proves the validity of the message.

As in the case with tokens sending, we formalize the process of receiving by deﬁning the
validation rules for the redeem transaction and the side eﬀects to the state of SCb in case the
transaction is valid and accepted by the sidechain SCb.

17

Validation rules

1. Verify T It.issuerSidechainId == Mt.sendingScId or T It.issuerSidechainId ==
SCb (it is allowed to receive tokens only from the sidechains that issued them or
the tokens that were created by the receiving sidechain).

2. If T It.issuerSidechainId == SCb, then verify that:

(a) If T It.f ungibility == true, then there exists some sent record SR

(cid:48)

t ∈ Ssent
b

such that:

(cid:48)

(cid:48)

(cid:48)

i. SR
ii. SR
iii. SR
iv. SR

t.receivingSidechainID == Mt.sendingScId, and
t.tokenN ame == T It.tokenN ame, and
t.f ungibility == true, and
t.amount ≥ T It.amount (i.e., if we receiving back the native token
and the amount should not be more

then it should be present in Ssent
than has been originally sent to that sidechain).

b

(cid:48)

If such SR

t does not exist, reject the transaction.

(cid:48)

(b) If T It.f ungibility == f alse, then there should exist some sent record SR

(cid:48)

t ∈

Ssent
b

such that:

(cid:48)

i. SR
ii. SR
iii. SR
iv. SR

(cid:48)

t.receivingSidechainID == Mt.sendingScId, and
t.tokenN ame == T It.tokenN ame, and
t.f ungibility == f alse, and
t.tokenId == T It.tokenId (i.e., if we receiving back an NFT token

(cid:48)

(cid:48)

from the tokenN ame set, then it should be present in Ssent

).

b

If such SR

t does not exist, reject the transaction.

(cid:48)

3. If T It.f ungibility == f alse then verify that T It /∈ Stks

(if it is an NFT, it can not

b

already be present in the receiving sidechain).

4. Verify semantic validity of Mt:

(a) Mt.sendingScId (cid:54)= SCb;
(b) Mt.receivingScId == SCb;
(c) Mt.msgT ype == T okenT ransf er;
(d) Mt.senderId == T It.ownerP ubKey;
(e) Mt.payloadHash == Hash(T It).

5. Verify that the message Mt is authorized by the sender (previous owner of T It)

(i.e., there is a signature on Mt under the public key Mt.senderId).

6. Verify that the redeem transaction is authorized by the receiver (the new owner
(T It → Mt, proof ) under the

of T It) on SCb (i.e., there is a signature on txredeem
public key Mt.receiverId).

SCb

7. Verify the proof, which should check the validity of the message according to CSCP

rules (section 3.1.3).

Note that the Mitto token transfer protocol does not specify precise rules for the message

18

validity proof. Similarly to the CSCP protocol, we view Mitto as an abstract protocol that can
be integrated into sidechains with diﬀerent architecture, diﬀerent state management, etc. That
is why at this level of abstraction it is impossible to precisely deﬁne the veriﬁcation logic. For
instance, for the Latus-based sidechains the proof can be a SNARK proof that veriﬁes existence
of the message in the conﬁrmed certiﬁcate of SCa.

Side eﬀects on the state of SCb

1. Let T I new

t

be a copy of T It except that T I new

t

.ownerP ubKey = Mt.receiverId.

2. T I new

t

is added to Stks

b

.

3. If T I new

t

.issuerSidechainID == SCb (i.e., we received back the token that was

issued in this sidechain), then:

(a) If T I new

t

.f ungibility == f alse, then ﬁnd such SRt ∈ Ssent
such that
SRt.receivingSidechainID == Mt.sendingScId, and SRt.tokenN ame ==
T It.tokenN ame, and SRt.tokenId == T It.tokenId and remove it from Ssent
;
b
.f ungibility == true, then ﬁnd such SRt ∈ Ssent
such that
SRt.receivingSidechainID == Mt.sendingScId and SRt.tokenN ame ==
T It.tokenN ame. Then update SRt.amount = SRt.amount − T It.amount. If,
after update, SRt.amount == 0, then remove SRt from Ssent

.

b

b

t

b

(b) If T I new

4.4 Transferring tokens from a ceased sidechain

a

By transferring tokens from a ceased sidechain we understand the case when some sidechain
SBa has been ceased while holding some token instances T Ii ∈ Stks
or storing sent records
SRi ∈ Ssent
for tokens issued by SCa and sent elsewhere, and a user wants to transfer such
tokens. In a nutshell, this can be done by utilizing the Ceased Sidechain Withdrawal mechanism.
A user should create a CSW containing a message with the transferred token instance. The
SNARK proof of the CSW should be designed in a way that allows to prove the existence of
such a TI in the state of the sidechain at the moment of ceasing. Then, the token can be
redeemed in the receiving sidechain by creating a special CSW redeem transaction:

a

type Mitto CSW Redeem Tx {

CSCP Message,

Mt:
proof : ByteArray,
T It: TokenInstance,
CSWt: CSW

}

The validation rules and side eﬀects are almost similar to the one described in section 4.3
for regular redemption. The only exception is the proof, which in this case should verify that
the message has been committed in the CSWt rather than in a withdrawal certiﬁcate. The side
eﬀects remain completely the same as in the case of Mitto Redeem Tx.

While receiving is relatively simple, the token sending from a ceased sidechain is more com-

plex. We consider two basic scenarios of withdrawing tokens from a ceased sidechain:

1. Withdrawing native tokens (i.e., tokens that were issued on the ceased sidechain).

2. Withdrawing foreign tokens (i.e., tokens that were not issued on the ceased sidechain,

but were held there at the moment of ceasing).

19

4.4.1 Withdrawing native tokens

Let assume that the sidechain SCa has ceased. There are two cases to consider:

1. At the moment of ceasing the sidechain SCa was the owner of the token T Ii to be with-
drawn. I.e., there is a token instance T Ii ∈ Stks
is a set of owned tokens at the
moment of ceasing. In this case, it is needed to create a CSW that proves the existence of
T Ii in Stks
and the right to withdraw it. The CSW is submitted to the mainchain. Once
it is conﬁrmed in the mainchain, Mitto CSW Redeem Tx can be used to redeem the token
in another sidechain.

a , where Stks

a

a

a

2. At the moment of ceasing the sidechain SCa did not hold the token to be withdrawn. I.e.,
there is a sent record SRt ∈ Ssent
, that represents a token(s) that were originally issued
in SBa but currently is owned by some sidechain SCc. We assume that SCc is active.
Such tokens can not be directly transferred from SCc to another active sidechain SCb,
because according to the Mitto protocol foreign tokens can be sent only to the sidechain
where they have been originally issued. Therefore, to transfer such tokens, SCc ﬁrst has
to send them back to the ceased sidechain SCa using the standard sending ﬂow. Then,
they can be withdrawn using the CSW mechanism. The CSW should be designed to prove
the following:

(a) there exist a valid message Mt that were sent by SCc to SCa, the message has been

committed to the conﬁrmed withdrawal certiﬁcate of SCc;

(b) the message Mt transfers the token instance T It, which represent a token(s) that

were originally issued by SCa;
(c) there is a sent record SRt ∈ Ssent

a

that conﬁrms that the token(s) have been sent to

SCc previously and that it has not been withdrawn yet.

Once such CSW is conﬁrmed in the mainchain, Mitto CSW Redeem Tx can be used to
redeem the token in the sidechain SCb.

4.4.2 Withdrawing foreign tokens

Let assume that the sidechain SCa has been ceased and it owns a token instance T It ∈ Stks
A ,
In this case it is needed to create a CSW that
such that T It.issuerSidechainId (cid:54)= SCa.
proves the existence of T It in Stks
and the right to withdraw it. The CSW will include a
corresponding message Mt that wraps T It as a custom ﬁeld. Then, T It can be redeemed with
Mitto CSW Redeem Tx in sidechain T It.issuerSidechainId (and only there).

a

4.5 Design rationale

One of the main design principles of the Mitto token transfer protocol is that tokens (in the
form of token instances) can only be sent from the sidechain where they have been originally
issued to some other sidechain and back. But it is disallowed to send tokens from the sidechain
where they have not been issued to another sidechain, which is also not their original place of
issuance.

More formally: if there is a message Mt that sends a token instance T It from sidechain SCa

to SCb, then

• either SCa == T It.issuerSidechainId,

• or SCb == T It.issuerSidechainId.

20

The reason for such a design decision is security. Recall that a sidechain that issues some set
of tokens keeps track (through SentRecord mechanism) of tokens that have been sent outside.
And when these tokens return back they are checked through SentRecords. In this case, it is
impossible for some corrupted sidechain to send back more tokens than was initially sent there
by the issuer. This feature is similar to the Withdrawal Safeguard feature introduced in Zendoo
(see section 4.1.2.2 in [1]).

Let’s consider this situation in more detail and assume that it is allowed to send foreign
tokens from the sidechain where they have not been issued to another third-party sidechain.
Let there be several fungible token instances T Ii of type T It.tokenN ame = SuperCoin, such
that T Ii.issuerSidechainId = SCa. Let assume they are held by SCb at the moment (i.e.,
T It ∈ Stks
) and SCb sends some of them to SCc. But given that this operation is outside SCa,
it can not track this transfer and update sent records accordingly (decrease balance of SCb and
increase balance of SCc). Possible solutions to this problem can be:

b

1. Eliminate recording the receiving sidechain in the sent record and just save the amount of
tokens of a particular type that have been sent outside. But this creates a vulnerability:
if the sidechain SCc becomes corrupted, such that it can forge the sending transaction to
pretend to transfer more tokens that it really has, then the original SCa has no way to
detect this and will accept a malicious transfer that may drain SR.amount to zero and
prevent SCb from transferring back the valid SCa tokens it holds.

2. Eliminate the concept of sent records at all, but then a malicious sidechain would be able
to forge any amount of tokens and send them back to the original sidechain without any
control.

3. Notify the original sidechain SCa every time when tokens are transferred somewhere. I.e.,
if SCb sends T It to SCc, then an additional transaction is created on SCa that updates
SR accordingly. Theoretically, it solves the problem, but it will require to design and
implement complex set of proofs and it would be basically equivalent to sending tokens
through SCa. We do not consider this option due to its complexity.

There are some other solutions as well, but they are even more complex.

4.5.1 Token wrapping

An interesting concept that could also serve as a workaround for the mentioned above problem
is token wrapping. For instance, if a sidechain SCb holds some tokens T Ii issued in SCa, where
T Ii.tokenN ame = ACoin and T Ii.issuerSidechainId = SCa, it can issue a new set of tokens
T Ij, such that T Ij.tokenN ame = wACoin and T Ij.issuerSidechainId = SCb. The idea is
that wACoin tokens can serve as a wrapper for ACoin tokens. Then, SCb can send T Ij to
other sidechains.

Wrapping may be particularly interesting for the native mainchain asset. Given that every
sidechain may contain a certain amount of native MC assets, representing them in the form of
wrapped tokens can simplify interaction among diﬀerent sidechains.

5 Conclusions

We presented a generic protocol for cross-sidechain communication for Zendoo sidechains. It
allows diﬀerent chains to exchange messages with one another in a veriﬁable way. Moreover,
we presented an extension of the protocol that allows to transfer tokens issued on diﬀerent
sidechains.

21

We view our work as a base for building interoperable Zendoo sidechains. The protocol does
not impose any rules on the sidechains structure and can be used by diﬀerent systems with
diﬀerent security models.

References

[1] Roman Oliynykov Alberto Garoﬀolo, Dmytro Kaidalov. Zendoo: a zk-snark veriﬁable cross-
chain transfer protocol enabling decoupled and decentralized sidechains. Cryptology ePrint
Archive: Report 2020/123. https://eprint.iacr.org/2020/123.

[2] Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew
Miller, Andrew Poelstra, Jorge Tim´on, and Pieter Wuille. Enabling blockchain innovations
with pegged sidechains, 2014. https://blockstream.com/sidechains.pdf.

[3] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza.

Succinct non-
interactive zero knowledge for a von neumann architecture. Cryptology ePrint Archive,
Report 2013/879, 2013.

[4] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive proof composition without
a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019. https://eprint.
iacr.org/2019/1021.

[5] Vitalik Buterin.

Skeptical of cross-chain bridges.

online article, 2022.

https://

cryptobriefing.com/vitalik-buterin-skeptical-of-cross-chain-bridges/.

[6] Croman K. et al., editor. On Scaling Decentralized Blockchains, volume 9604 of Financial
Cryptography and Data Security, Lecture Notes in Computer Science. Springer, 07 2016.

[7] Alberto Garoﬀolo, Dmytro Kaidalov, and Roman Oliynykov. Zendoo: a zk-snark veriﬁable
cross-chain transfer protocol enabling decoupled and decentralized sidechains.
In 2020
IEEE 40th International Conference on Distributed Computing Systems (ICDCS), pages
1257–1262, 2020.

[8] Ulrich Hab¨ock, Alberto Garoﬀolo, and Daniele Di Benedetto. Darlin: Recursive proofs
using marlin. Cryptology ePrint Archive, Paper 2021/930, 2021. https://eprint.iacr.
org/2021/930.

[9] Sergio Demian Lerner. Rootstock: Bitcoin powered smart contracts, 2019. https://www.

rsk.co/Whitepapers/RSK-White-Paper-Updated.pdf.

[10] Izaak Meckler and Evan Shapiro. Coda: Decentralized cryptocurrency at scale, 2018.
https://cdn.codaprotocol.com/v2/static/coda-whitepaper-05-10-2018-0.pdf.

[11] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.

https:

//bitcoin.org/bitcoin.pdf.

22

