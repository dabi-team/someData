Privacy-Preserving Energy Storage Sharing with Blockchain and Secure
Multi-Party Computation

1
2
0
2

v
o
N
3

]

R
C
.
s
c
[

1
v
5
0
0
2
0
.
1
1
1
2
:
v
i
X
r
a

NAN WANG, Australian National University
SID CHI-KIN CHAU, Australian National University
YUE ZHOU, Australian National University
Energy storage provides an effective way of shifting temporal energy de-
mands and supplies, which enables significant cost reduction under time-of-
use energy pricing plans. Despite its promising benefits, the cost of present
energy storage remains expensive, presenting a major obstacle to practical
deployment. A more viable solution to improve the cost-effectiveness is by
sharing energy storage, such as community sharing, cloud energy storage
and peer-to-peer sharing. However, revealing private energy demand data
to an external energy storage operator may compromise user privacy, and is
susceptible to data misuses and breaches. In this paper, we explore a novel
approach to support energy storage sharing with privacy protection, based
on privacy-preserving blockchain and secure multi-party computation. We
present an integrated solution to enable privacy-preserving energy storage
sharing, such that energy storage service scheduling and cost-sharing can
be attained without the knowledge of individual users’ demands. It also
supports auditing and verification by the grid operator via blockchain. Fur-
thermore, our privacy-preserving solution can safeguard against a majority
of dishonest users, who may collude in cheating, without requiring a trusted
third-party. We implemented our solution as a smart contract on real-world
Ethereum blockchain platform, and provided empirical evaluation in this
paper1.

Additional Key Words and Phrases: Privacy-Preserving, Energy Storage
Sharing, Blockchain, Secure Multi-Party Computation

INTRODUCTION

1
Energy storage can buffer energy in a storage medium, which is
useful for temporal shifting of energy demands and supplies. In
addition to absorbing excessive renewable energy, energy storage
can effectively reduce the consumption cost under dynamic time-of-
use (ToU) energy pricing plans by storing energy during off-peak
periods and discharging during peak periods. But the present cost
of energy storage systems remains considerably expensive. Energy
storage also incurs significant maintenance cost over time, with
only limited life cycles. There is a possibility of a future technologi-
cal breakthrough that may significantly reduce the current cost of
energy storage in the near future. Hence, despite its benefits, the
current users are reluctant to immediately adopt energy storage at
a wide scale. However, rather than postponing the use of energy
storage, a more viable solution to improve the cost-effectiveness of
present energy storage is by sharing energy storage among multiple
users or out-sourcing to a third-party energy storage operator. In
fact, time-sharing and out-sourcing have been popular concepts,
particularly in cloud computing. Energy storage may also become
an out-sourcible resource in a similar fashion.

1This article is an updated and extended version of the conference paper [40].

Authors’ addresses: Nan Wang, vincent.wang@anu.edu.au, School of Computing, Aus-
tralian National University; Sid Chi-Kin Chau, sid.chau@anu.edu.au, School of Com-
puting, Australian National University; Yue Zhou, yue.zhou@anu.edu.au, School of
Computing, Australian National University.

Currently, there are multiple possible paradigms of energy storage
sharing. First, in community sharing [28], a group of local users,
who do not own individual energy storage, can connect to a shared
energy storage facility. The shared energy storage will be utilized by
the users based on a coordination mechanism. The associated cost
will be split among the users in a fair manner. Second, a non-local
third-party energy storage operator can provide an outsourcing
service as cloud energy storage [29]. The energy storage operator
can offset the energy consumption of remote users by exporting
energy from its energy storage facility. Third, the users, who have
their own energy storage, can pool their energy storage resources
together to support each other in peer-to-peer sharing [9].

All of these energy storage sharing paradigms can be effectively
supported by the notion of virtual net metering (VNM) [18, 36],
which is a flexible bill crediting system for transferring the credits
or debits of a user’s energy account to another, even though they
do not share the same physical metering infrastructure. By VNM,
energy storage operators can possibly transfer the credits of their
energy export to offset the debits of energy import of other users.
VNM has been used to enable community solar energy sharing
in practice [19]. It can also enable energy storage sharing among
a group of geographically distributed users and energy storage
operators.

Although sharing can improve the cost-effectiveness, there is a
heightened concern of user privacy nowadays. Users may need to
disclose private energy demand data to a third-party energy storage
operator in order to schedule the use of shared energy storage. This
may reveal sensitive personal data (e.g., working patterns, number
of occupants, and vacation periods). Potential misuses and breaches
of personal data may lead to serious undesirable consequences. To
bolster user privacy, stricter privacy protection legislations are being
introduced in various countries to restrict personal information
revelations to a third-party (e.g., GDPR in Europe). Because of these
privacy concerns and privacy-related legislations, we are motivated
to ensure proper privacy protection in energy storage sharing with
a third-party operator.

In this paper, we introduce the concept of “privacy-preserving
energy storage sharing”, by which a third-party energy storage oper-
ator should be given only minimal information for its energy storage
service operations without being able to compromise personal data
for other unintended purposes. But the key challenge is how to
design an effective solution to enable proper energy storage service
scheduling and cost-sharing among users, without the knowledge of
individual users’ energy demands, and yet that can still be verified
and audited to eliminate any fraud.

We provide a feasible solution to enable privacy-preserving en-
ergy storage sharing, by drawing on several recent technologies.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

 
 
 
 
 
 
Fig. 1. An illustration of the stages of our solution for privacy-preserving energy storage sharing.

First, blockchain (e.g., Bitcoin, Ethereum) is a disruptive paradigm
that enables decentralized verifiable applications without trusted
intermediaries by integrating a tampering-resistant ledger with a dis-
tributed consensus protocol. Blockchain is an effective platform to
support transparent energy storage sharing and auditable VNM with
grid operators. But blockchain by default does not ensure privacy,
and transaction data is entirely disclosed on the ledger. Recently,
there is a new trend of supporting privacy on blockchain. For exam-
ple, there are privacy-oriented cryptocurrencies, like ZCash, Monero
[4, 33], that utilize zero-knowledge proofs for privacy-preserving
digital asset management, without revealing them. In this paper, we
utilize privacy-preserving blockchain to conceal the private data in
cost-sharing and VNM for energy storage sharing.

Second, secure multi-party computation (or simply called multi-
party computation) has been a subject of extensive research [13],
which provides a general framework to allow multiple parties to
jointly compute a function while concealing the private inputs. Re-
cently, efficient multi-party computation protocols based on secret-
sharing (e.g., SPDZ) have been applied to many practical applications
like privacy-preserving machine learning [10]. In this paper, we ap-
ply multi-party computation to energy storage service scheduling
with concealed individual users’ demands. Moreover, we integrate
multi-party computation with privacy-preserving blockchain to
support confidential cost-sharing and verifiable VNM settlement.

In summary, this paper presents an integrated solution to en-
able privacy-preserving energy storage sharing in all the stages, as
outlined in the following (and also illustrated in Figure 1):

(a) Multi-party Computation for Energy Storage Schedul-
ing: First, the users can compute their aggregate day-ahead
demands by secure multi-party computation, without reveal-
ing individual demands. Then, they can derive the optimal
energy storage service schedule subject to energy storage
service constraints.

(b) Privacy-preserving Cost-sharing Payment: The users can
split the cost of energy storage service based on a fair cost-
sharing scheme in a privacy-preserving manner. The users
can make energy storage service payments via privacy-preserving
blockchain, without disclosing individual transactions. Af-
ter receiving the payments, the energy storage operator will
issue verifiable receipts on blockchain ledger.

(c),(d) Energy Storage Operation & Virtual Net Metering Set-
tlement: The users and energy storage operator will follow
the energy storage service schedule. They do not need to
exchange energy directly, and the energy flows through the

grid. They will settle their energy accounts via VNM. With
verifiable receipts on blockchain ledger, the users can offset
their energy consumption by the energy export from energy
storage, which will be audited by the grid operator.
Particularly, we should ensure privacy protection throughout the
integrated process of scheduling, cost-sharing, payment and audit-
ing, without requiring a trusted third-party. While it may be easier
to ensure privacy in individual processes separately, it is challeng-
ing to ensure privacy in the integrated process. For example, one
can schedule a service, or make a payment separately in a privacy-
preserving manner. However, it is harder to verify the payment with
respect to the scheduled service with privacy protection.

Furthermore, privacy also poses a significant challenge to the
correctness and integrity of operations. Because of concealing their
demands, dishonest users may attempt to cheat by paying less to
energy storage service or claim more in VNM than what they ought
to. These dishonest users may even collude to coordinate their
actions in cheating. Hence, it is critical to safeguard against the
presence of dishonest users. Remarkably, our privacy-preserving
solution is able to safeguard against a majority of dishonest users
(namely, more than 50% of users may be dishonest).

This paper is organized as follows. We first review the related
work and background in Section 2. We then formulate the problem
and models in Section 3, and present the basics of cryptographic com-
ponents and multi-party computation in Sections 4-5. The privacy-
preserving solution is presented in Section 6. We next provide an
empirical evaluation of our implementation on Ethereum blockchain
platform in Section 7. We also discuss several extensions as well as
the limitations of our solution in Section 8. We conclude this work
with future work in Section 9.

2 RELATED WORK AND BACKGROUND
2.1 Energy Storage Sharing
Optimizing energy storage under dynamic pricing plans has been a
popular research topic [17, 22, 32]. Recent studies proposed various
paradigms for energy storage sharing among multiple users, for
instance, cloud energy storage [29], virtual community sharing
[28] and peer-to-peer sharing [9]. Notably, there are many studies
about privacy in smart grid in other aspects. For example, [24, 26]
employed energy storage to hide private consumption behavior by
mixing random energy storage charging and discharging to mask
the consumption patterns. [37] presents privacy-preserving data
aggregation for smart meters that aggregates users demands. None
of these studies addressed the privacy aspect in energy storage

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

sharing. To the best of our knowledge, this is the first paper to
address the issue of privacy-preserving energy storage sharing and
its cost-sharing.

2.2 Virtual Net Metering
To enable energy consumers to share physically disconnected energy
storage from energy storage operators, one can rely on Virtual Net
Metering (VNM) [18, 36] for transferring the credits or debits of a
user’s energy account to another. When energy consumers import
energy from the grid, they will incur debits in their energy accounts.
On the other hand, when energy storage operators export energy
to the grid, they will earn credits in their energy accounts based on
feed-in tariffs. However, simultaneous exporting energy from energy
storage operators and importing energy from energy consumers
with the same amount of energy should be able to offset each other.
In practice, the credits of energy export of energy storage opera-
tors may be transferred to offset the partial debits of energy import
of energy consumers. In this case, it may not require simultaneous
energy export and energy import in VNM. However, maintaining
instantaneous energy balance at VNM is still important to ensure
the stability in power distribution network. While there may be
additional costs in power distribution network such as power trans-
mission cost, balancing the energy generation and consumption
should be the major component in VNM. Note that VNM is en-
tirely an account balancing process, without the need to configure
the energy flow in the power distribution network. VNM has been
proposed to enable novel applications, such as transactive energy
transfer in an energy exchange market, community solar energy
and shared energy storage [19].

2.3 Blockchain Technology
There is an increasing number of applications of blockchain tech-
nology to energy systems. For example, the study [21] applied
blockchain to mitigate trust in peer-to-peer electric vehicle charg-
ing. Blockchain has been applied to microgrid energy exchange and
wholesale markets by prosumers [31]. Renewable energy credits
and emissions trading are also applications of blockchain [25]. In
these applications, the goal of blockchain is to improve transparency
and reduce settlement times, since blockchain system can ensure
integrity and consistency of transactions and settlement on an open
ledger. See [1] for a recent survey about blockchain applications to
energy systems.

Note that none of these studies have considered the privacy on
blockchain, even though the transaction data on the ledger is entirely
disclosed to the public. Our work is one of the first studies to explic-
itly address privacy in blockchain applications of energy systems.
Supporting privacy on blockchain is a crucial research topic in cryp-
tography and security. There have been several privacy-preserving
blockchain platforms with support of privacy (e.g. ZCash, Mon-
ero, Zether [4, 6, 33]). Our work draws on similar concepts from
privacy-preserving blockchain, but also integrates specifically with
the application of energy storage sharing, for example, to support
auditable VNM. Our solution is implemented as a smart contract
on permissionless Ethereum blockchain platform, but it can also be
implemented on a permissioned blockchain platform.

2.4 Privacy-Preserving Solutions
We briefly survey and compare various approaches of privacy-
preserving solutions in the literature. There are two major ap-
proaches: (1) data obfuscation that masks private data with ran-
dom noise, (2) secure multi-party computation that hides private
data while allowing the data to be computed confidentially. Differ-
ential privacy [16], a main example of data obfuscation, is often
used in privacy-preserving data mining to extract certain data prop-
erties in a relatively large dataset. There is an intrinsic trade-off
between the accuracy and privacy of differential privacy. On the
other hand, secure multi-party computation [15, 20] traditionally
employed garbled circuits [23] and homomorphic cryptosystems
[12, 30], which have a high computational complexity. Recently,
information-theoretical secret-sharing (e.g., SPDZ [13, 14]) has been
utilized for secure multi-party computation, which provides high
efficiency. This work employs secure multi-party computation for
privacy-preserving energy storage operation scheduling and cost-
sharing computations without disclosing private energy demands.

3 MODELS AND FORMULATION
In the following, we first formulate the energy storage sharing model
without considering privacy. In the subsequent sections, we will
incorporate privacy protection in the model.

3.1 Problem Setup
First, we describe several key components in the model (and list
some key notations in Table 1):

Table 1. Table of key symbols and notations.

Total number of users
The 𝑖-th user

Per-unit service fee of energy storage at each timeslot
State-of-charge of energy storage at timeslot 𝑡

𝑁
𝑈𝑖
𝑝 (𝑡) Energy price of time-varying pricing scheme at timeslot 𝑡
B(𝑡) Capacity of energy storage at timeslot 𝑡
ps
𝑏 (𝑡)
ec, ed Charging and discharging efficiency ratios
rc, rd Charging and discharging rate constraints
𝑥 + (𝑡) Charging rate from the grid to the energy storage
𝑥 −
𝑖 (𝑡) Discharging rate from the energy storage to 𝑈𝑖
𝑦𝑖 (𝑡) 𝑈𝑖 ’s residual consumption rate from the grid at 𝑡
𝑦 (𝑡) Total residual consumption rate of all users at timeslot 𝑡

Costess Total cost of energy storage service
Cost𝑖 𝑈𝑖 ’s partial original cost without energy storage service
𝑃 pp
𝑖
𝑃 ega
𝑖
Δ𝑖

𝑈𝑖 ’s payment under proportional cost-sharing scheme
𝑈𝑖 ’s payment under egalitarian cost-sharing scheme
(= Cost𝑖 − 𝑃𝑖 ) 𝑈𝑖 ’s saving from energy storage service

(1) Time-Varying Energy Pricing Plan: We consider discrete
timeslots, indexed by 𝑡 ∈ {1, ...,𝑇 }, where 𝑇 is the number
of timeslots in a day. The energy price of a time-varying
time-of-use (ToU) pricing plan at timeslot 𝑡 is denoted by
𝑝 (𝑡). We suppose that the next-day ToU prices (𝑝 (𝑡))𝑇
𝑡 =1 are
announced before the end of today to all users and energy

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

storage operator, such that they can plan their consumption
in a day-ahead manner.

(2) Energy Users: There are 𝑁 (≥ 3)2 users, each denoted by 𝑈𝑖
where 𝑖 ∈ {1, ..., 𝑁 }. 𝑈𝑖 has certain energy demand over time,
represented by a non-negative demand function 𝑎𝑖 (𝑡) > 0
for all 𝑡. The users aim to reduce their energy costs by utiliz-
ing a third-party energy storage service that stores energy
at lower energy prices beforehand. We consider day-ahead
energy storage scheduling, whereby 𝑈𝑖 forecasts her planned
energy demand 𝑎𝑖 (𝑡) in advance, and requests energy storage
service in a day-ahead manner. If the energy from energy
storage service is insufficient, 𝑈𝑖 will need to acquire addi-
tional energy from the grid for the residual consumption rate
denoted by 𝑦𝑖 (𝑡) at the respective price 𝑝 (𝑡).

(3) Energy Storage Service: The energy storage service is pro-
vided by an energy storage operator, who has energy storage
characterized by capacity B(𝑡), which is time-varying for
modeling dynamic energy storage capacity. The energy stor-
age is constrained by charging efficiency ratio ec ≤ 1 and
discharging efficiency ratio ed ≥ 1, charge rate (i.e., ramp-up)
constraint rc and discharge rate (i.e., ramp-down) constraint
rd. Let 𝑏 (𝑡) be the current state-of-charge in the energy stor-
age at time 𝑡, and 𝑥 + (𝑡) be the charging rate from the grid
to the energy storage, whereas 𝑥 −
𝑖 (𝑡) be the discharging rate
from the energy storage to 𝑈𝑖 . When the energy storage is uti-
lized, there is a per-unit service fee at each timeslot, ps, which
allows the energy storage operator to cover the wear-and-tear
and maintenance cost.

Next, we will describe energy storage service scheduling in Sec-
tion 3.2 and fair energy storage service cost-sharing in Section 3.3.
We will present the blockchain model in Section 3.4, and incorporate
privacy protection in the security and threat models in Section 3.5.

3.2 Energy Storage Service Scheduling
The energy storage service requires reservations from the users. The
energy storage service operations will then be scheduled accordingly
to minimize the overall energy cost. We formulate the optimization
problem of energy storage service scheduling in (P1).

(P1) min

𝑇
∑︁

𝑡 =1

(cid:16)
𝑝 (𝑡) · (cid:0)𝑥 + (𝑡) +

𝑁
∑︁

𝑖=1

𝑦𝑖 (𝑡)(cid:1) + ps · 𝑥 + (𝑡)

(cid:17)

s.t. 𝑏 (𝑡 + 1) − 𝑏 (𝑡) = ec𝑥 + (𝑡) − ed

𝑁
∑︁

(cid:16)

𝑖=1

𝑥 −
𝑖 (𝑡)

(cid:17)

,

0 ≤ 𝑏 (𝑡) ≤ B(𝑡), 𝑏 (0) = 0, 𝑏 (𝑇 + 1) = 0,
𝑥 + (𝑡) ≤ rc,
𝑁
∑︁

𝑥 −
𝑖 (𝑡) ≤ rd,

𝑖=1
𝑥 −
𝑖 (𝑡) + 𝑦𝑖 (𝑡) = 𝑎𝑖 (𝑡),

var. 𝑏 (𝑡) ≥ 0, 𝑥 −

𝑖 (𝑡) ≥ 0, 𝑦𝑖 (𝑡) ≥ 0, 𝑥 + (𝑡) ≥ 0

∀𝑡 ∈ {1, ...,𝑇 }, ∀𝑖 ∈ {1, ..., 𝑁 }

(1)

(2)

(3)

(4)

(5)

(6)

(7)

2Our protocols can safeguard against at most 𝑁 − 2 dishonest users.

The objective of (P1) is the total cost, including energy storage
charging 𝑥 + (𝑡) and residual consumption 𝑦𝑖 (𝑡) at the respective
energy price 𝑝 (𝑡) of timeslot 𝑡, as well as the energy storage service
fee ps · 𝑥 + (𝑡). Constraint (2) updates the state-of-charge considering
charging and discharging efficiency ratios. Constraint (3) ensures
feasible state-of-charge. We assume that the initial and final state-of-
charge are 0. Constraints (4)-(5) ensure the charging and discharging
rates within the respective rate constraints. Constraint (6) ensures
the balance of demands, such that each user’s demands are satis-
fied completely. Note that we do not consider the cost of energy
distribution in power distribution network. This is sufficient to cer-
tain scenarios, for example, when the users are close to the energy
storage operator.

We note that (P1) however relies on the knowledge of individual
user’s demand 𝑎𝑖 (𝑡). Hence, we present an alternate problem (P2).

(P2) min

𝑇
∑︁

𝑡 =1

(cid:16)
𝑝 (𝑡) · (cid:0)𝑥 + (𝑡) + 𝑦 (𝑡)(cid:1) + ps · 𝑥 + (𝑡)

(cid:17)

s.t. 𝑏 (𝑡 + 1) − 𝑏 (𝑡) = ec𝑥 + (𝑡) − ed𝑥 − (𝑡),

0 ≤ 𝑏 (𝑡) ≤ B(𝑡), 𝑏 (0) = 0, 𝑏 (𝑇 + 1) = 0,
𝑥 + (𝑡) ≤ rc,
𝑥 − (𝑡) ≤ rd,
𝑥 − (𝑡) + 𝑦 (𝑡) = 𝑎(𝑡),

(8)

(9)

(10)

(11)

(12)

(13)

var. 𝑏 (𝑡) ≥ 0, 𝑥 − (𝑡) ≥ 0, 𝑦 (𝑡) ≥ 0, 𝑥 + (𝑡) ≥ 0

∀𝑡 ∈ {1, ...,𝑇 }

𝑖=1 𝑎𝑖 (𝑡), total discharg-
𝑖 (𝑡) and total consumption rate 𝑦 (𝑡) =

(P2) considers the total demand 𝑎(𝑡) = (cid:205)𝑁
ing rate 𝑥 − (𝑡) ≜ (cid:205)𝑁
𝑖=1 𝑥 −
(cid:205)𝑁
By Theorem 1, energy storage service scheduling can be solved by
(P2), instead of (P1), involving no individual demand 𝑎𝑖 (𝑡).

𝑖=1 𝑦𝑖 (𝑡), as well as the balance of the total demand in Constraint (13).

Theorem 1. If (cid:0)𝑥 − (𝑡), 𝑦 (𝑡)(cid:1)𝑇

then (cid:0)(𝑥 −
𝑎𝑖 (𝑡 )
𝑎 (𝑡 )

𝑖 (𝑡), 𝑦𝑖 (𝑡))𝑁
𝑖=1

𝑖 (𝑡) =
· 𝑦 (𝑡), is an optimal solution of (P1).

(cid:1)𝑇
𝑡 =1, where 𝑥 −

𝑡 =1 is an optimal solution of (P2),
· 𝑥 − (𝑡) and 𝑦𝑖 (𝑡) =

𝑎𝑖 (𝑡 )
𝑎 (𝑡 )

See Appendix. A for the proof.

Remarks: Note that when the energy storage discharges at rate
𝑥 − (𝑡), it can simultaneously compensate the users’ consumption at
the same rate. This can be attained via VNM. We assume that the en-
ergy storage operator announces the parameters ps, ec, ed, rc, rd, (𝑝 (𝑡),
B(𝑡))𝑇
𝑡 =1 in advance. Everyone can compute the solution to (P2) with
the knowledge of (𝑎(𝑡))𝑇

𝑡 =1.

3.3 Fair Cost-sharing of Energy Storage Service
After scheduling the energy storage service, the users are supposed
to share and pay the associate cost to the energy storage operator.
Next, we formulate how the cost of energy storage service should be
shared among users in a fair manner. In (P2), in addition to the cost
that is paid directly by the users to the grid (i.e., (cid:205)𝑇
𝑡 =1 𝑝 (𝑡) · 𝑦 (𝑡)),
there is a cost incurred by the energy storage service as follows:

Costess ≜

𝑇
∑︁

𝑡 =1

(cid:0)𝑝 (𝑡) + ps

(cid:1) · 𝑥 + (𝑡)

(14)

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

Costess should be split fairly among the users. There are several
possible ways of dividing the energy storage service cost Costess.
Particularly, we are interested in the fair ways that take into consid-
eration the individual rationality of each user.

We note that without energy storage service, each user should

originally pay the following cost:

𝑇
∑︁

𝑡 =1

𝑝 (𝑡) · 𝑎𝑖 (𝑡) =

𝑇
∑︁

𝑡 =1

𝑝 (𝑡) · (cid:0)𝑥 −

𝑖 (𝑡) + 𝑦𝑖 (𝑡)(cid:1)

(15)

Let Cost𝑖 ≜ (cid:205)𝑇

𝑡 =1 𝑝 (𝑡) · 𝑥 −

𝑖 (𝑡) be the partial original cost of 𝑈𝑖 in
Eqn. (15) that would have been covered by energy storage service,
which provides a basis on how to split Costess. Note that the other
part in Eqn. (15) (i.e., (cid:205)𝑇
𝑡 =1 𝑝 (𝑡) · 𝑦𝑖 (𝑡)) will be paid regardless of
energy storage service. Noteworthily, if a user does not get any
benefit from energy storage service (i.e., 𝑎𝑖 (𝑡) > 0 only when 𝑝 (𝑡)
is the lowest), then we have 𝑥 −

𝑖 (𝑡) = 0 in (P1) and Cost𝑖 = 0.

𝑖=1 is called budget-balanced, if (cid:205)𝑁

Suppose that each 𝑈𝑖 contributes payment 𝑃𝑖 to cover the energy
storage service cost Costess. A cost-sharing scheme denoted by
(𝑃𝑖 )𝑁
𝑖=1 𝑃𝑖 = Costess, whereas it is
called weakly budget-balanced, if (cid:205)𝑁
𝑖=1 𝑃𝑖 ≥ Costess. A cost-sharing
scheme (𝑃𝑖 )𝑁
𝑖=1 is called individually rational, if Cost𝑖 ≥ 𝑃𝑖 for all
𝑖 ∈ {1, ..., 𝑁 }. Evidently, each user would prefer an individually
rational cost-sharing scheme. Otherwise, some users would rather
not to utilize energy storage service, as it will cost more.

We define two fair cost-sharing schemes, which are based on
similar ideas in [8, 9], and show them to be individually rational by
Theorem 2.

3.3.1 Proportional Cost-sharing Scheme.
One simple fair way is that each 𝑈𝑖 should pay proportionally to

Cost𝑖 . Namely,

𝑃 pp
𝑖 ≜ Costess·

𝑡 =1 𝑥 −
𝑖 (𝑡) · 𝑝 (𝑡)
𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡)
Thus, each user has the same ratio of payment over individual cost

Cost𝑖
𝑖=1 Cost𝑖

(cid:0)𝑝 (𝑡)+ps

(cid:1)·𝑥 + (𝑡)·

(cid:205)𝑁

(cid:205)𝑇

𝑡 =1

=

𝑇
∑︁

(cid:205)𝑇

(i.e.,

𝑃 pp
Cost𝑖 = Costess
𝑖
(cid:205)𝑁
𝑖=1 Cost𝑖
sharing is budget-balanced (i.e., (cid:205)𝑁
payments are always non-negative (i.e., 𝑃 pp

𝑖=1 𝑃 pp

𝑖 = Costess). Note that the

𝑖 ≥ 0).

). It is easy to check that proportional cost-

3.3.2 Egalitarian Cost-sharing Scheme.
Given a payment to energy storage service 𝑃𝑖 , define the user’s
saving of utilizing energy storage service by Δ𝑖 ≜ Cost𝑖 − 𝑃𝑖 . An-
other fair cost-sharing scheme is that each user should split Costess
in a way that attains the same saving for every user. Namely,

𝑃 ega
𝑖

≜ Cost𝑖 −

(cid:205)𝑁

𝑖=1 Cost𝑖 − Costess
𝑁
𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡) − (cid:205)𝑇
(cid:205)𝑇
𝑡 =1
𝑁

𝑥 −
𝑖 (𝑡) · 𝑝 (𝑡) −

=

𝑇
∑︁

𝑡 =1

(16)

(cid:0)𝑝 (𝑡) + ps

(cid:1) · 𝑥 + (𝑡)

𝑖=1 Cost𝑖 −Costess
Thus, each 𝑈𝑖 attains the same saving as: Δega
.
𝑁
It is easy to check that egalitarian cost-sharing is also budget-
balanced (i.e., (cid:205)𝑁

≜

𝑖

= Costess).

𝑖=1 𝑃 ega

𝑖

(cid:205)𝑁

As a comparison, proportional cost-sharing guarantees the same
) among users, whereas egalitarian

percentage of savings (i.e., Δ𝑖
Cost𝑖
cost-sharing guarantees the same savings (i.e., Δ𝑖 ) among users.

Theorem 2. If (cid:0)𝑥 + (𝑡), 𝑥 − (𝑡)(cid:1)𝑇
𝑎𝑖 (𝑡 )
𝑎 (𝑡 ) ·𝑥 − (𝑡) and 𝑦𝑖 (𝑡) =

and let 𝑥 −
and egalitarian cost-sharing schemes are individually rational.

𝑡 =1 is an optimal solution of (P2)
𝑎𝑖 (𝑡 )
𝑎 (𝑡 ) ·𝑦 (𝑡), then proportional

𝑖 (𝑡) =

Let ˆp(𝑡) ≜ 𝑥 − (𝑡 ) ·𝑝 (𝑡 )

and Costorg ≜ (cid:205)𝑇
𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡). The pro-
portional and egalitarian cost-sharing payments are given as follows:

𝑎 (𝑡 )

(cid:40)𝑃 pp
𝑖 = Costess
Costorg
= (cid:205)𝑇
𝑃 ega
𝑖

𝑡 =1 𝑎𝑖 (𝑡) · ˆp(𝑡),
𝑡 =1 𝑎𝑖 (𝑡) · ˆp(𝑡) − Costorg−Costess

· (cid:205)𝑇

𝑁

(17)

𝑖

< 0), when Cost𝑖 < Δega

See Appendix. A for the proof.
Remarks: Egalitarian cost-sharing may have negative payments
(i.e., 𝑃 ega
. Namely, a user may be paid by
other users who have larger original costs, in order to maintain equal
savings among all users. In this case, such a user is not benefited
sufficiently from energy storage service because of the presence of
other users and capacity constraint, and hence, will be compensated
by other users in egalitarian cost-sharing.

𝑖

One may argue whether proportional cost-sharing is better than
egalitarian cost-sharing, because it rules out negative payments.
Here, we provide a solution to support both cost-sharing schemes.
We will leave the decision of adopting which scheme to the users.

3.4 Blockchain Model
In this section, we describe a blockchain model for payments of
energy storage service. We consider an account-based blockchain
model like Ethereum (which is a general-purpose blockchain plat-
form [34]), whereas Bitcoin operates with a different transaction-
output-based model for cryptocurrency transactions only. Smart
contracts are programming code on a blockchain that can provide
customized computation tasks to each transaction (e.g., verification,
data processing). Our payment system can be implemented as a
smart contract.

The payment and auditing of energy storage service are carried
out on a blockchain. Each user has an account on the blockchain.
Users can top-up their accounts in advance. For cost-sharing, the
users can initiate a joint payment transaction to the energy storage
operator. The transaction records on the blockchain will also be
used to verify VNM settlement by the grid operator.

Our blockchain model is based on a common model in the cryp-
tography literature (e.g., Zether [6] that was built on Ethereum),
which can be incorporated with privacy protection to conceal the
transaction records. The blockchain consists of several components:
(1) Ledger: An append-only ledger on a blockchain holds the
records of all accounts and transactions. Note that by default,
there is no privacy protection to the ledger, such that the ac-
count details and transaction histories are visible to the public.
On Ethereum, one can create tokens on the ledger to represent
certain digital assets. Our payment system is implemented by
tokens, which allows us to incorporate privacy protection. To
pay for energy storage service, users are required to purchase
tokens that will be subsequently transfered to the energy
storage operator and redeemed.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

𝑖

𝑖 , 𝐾 s

(tx) using the private key 𝐾 s

(2) Accounts: An account is identified by a public key 𝐾 p and
an address ad, which is the hash of the public key: ad =
H (𝐾 p), where H (·) is a cryptographic hash function. The
user manages the account by a private key 𝐾 s. Each account
holds a balance of tokens, denoted by Bal(ad), which by
default is a publicly visible plaintext. Each 𝑈𝑖 has an account
associated with a tuple (ad𝑖, 𝐾 p
𝑖 , Bal(ad𝑖 )). We denote
the energy storage operator’s account address by adess.
(3) Transactions: To initiate a transaction of tokens from ad𝑖
to ad𝑖′ with transaction value val, the user submits a trans-
action request to the blockchain: tx = (ad𝑖, ad𝑖′, val), along
with a signature sign𝐾 s
𝑖 asso-
ciated with ad𝑖 . The transaction request will be executed3 if
Bal(ad𝑖 ) ≥ val. A multi-transaction can also be requested.
Let mtx = (ad𝑖, ad𝑖′, val𝑖 )𝑁
𝑖=1. mtx will be executed, only if
Bal(ad𝑖 ) ≥ val𝑖 for all 𝑖 and multi-signature sign(𝐾 s
(mtx)
is present. Depending on the cost-sharing scheme, a user will
pay either 𝑃 pp
to the energy storage operator. Each
transaction request by default is a plaintext visible to the
public. We will subsequently conceal the transaction records.
(4) Receipts: The recipient of a transaction can attach a receipt
on the ledger, which may include additional information for
further verification and auditing by a third-party. In VNM
settlement, the grid operator will need to audit the amount
of energy that a user can be offset from energy storage ser-
vice, which can be verified from the receipts associated with
transaction records.

𝑖 or 𝑃 ega

𝑖 ) 𝑁
𝑖=1

𝑖

Note that there may be a negative flow of payment in egalitarian
cost-sharing, such that val𝑖 < 0. Hence, we need to ensure the
corresponding transaction on a blockchain still functions correctly.

Theorem 3. Consider a multi-transaction mtx = (ad𝑖, adess,
𝑖=1, where val𝑖 may be negative. Namely, every ad𝑖 pays to the
𝑖=1 val𝑖 > 0, then mtx can be

val𝑖 )𝑁
energy storage operator adess. If (cid:205)𝑁
handled on a blockchain by the following transaction operations:

Bal(ad𝑖 ) ←Bal(ad𝑖 ) − val𝑖, for all 𝑖

Bal(adess) ←Bal(adess) +

𝑁
∑︁

𝑖=1

val𝑖

(18)

(19)

See Appendix. A for the proof.

3.5 Security & Threat Models
In the previous sections, we have not considered privacy protec-
tion. We define privacy protection in our problem. We assume syn-
chronously authenticated communications among the parties, in-
cluding users, blockchain, energy storage operator and grid operator,
where the protocols proceed in several rounds and the parties can au-
thenticate each other properly so that there is no man-in-the-middle
attack.

Security Requirements.

3.5.1
Our system aims to satisfy the following security requirements:

3We skip some practical issues of a blockchain transaction, like nonce to prevent replay
attack, account-locking against front-running attack, etc. But our model can easily
incorporate the solutions from the security literature (e.g., [6]) to address these issues.

(S1) Demand Concealment: The user’s demand (cid:0)𝑎𝑖 (𝑡)(cid:1)𝑇

𝑡 =1 is pri-
vate information, which should not be revealed to other users
or energy storage operator in energy storage service sched-
uling, cost-sharing and payment. But the parameters, such
as ps, ec, ed, rc, rd, (cid:0)𝑝 (𝑡), B(𝑡)(cid:1)𝑇
𝑡 =1, are publicly known to all
users. We need to ensure the operations of scheduling, cost-
sharing and payment can be achieved correctly without leak-
ing any information about (cid:0)𝑎𝑖 (𝑡)(cid:1)𝑇
𝑡 =1 to others. Specifically,
(cid:17) 𝑁
given (cid:16) (cid:0)𝑎𝑖 (𝑡)(cid:1)𝑇
, we need a privacy-preserving summa-
𝑡 =1
𝑖=1
tion function for the aggregate demand:

Sumprv

(cid:104)(cid:16) (cid:0)𝑎𝑖 (𝑡)(cid:1)𝑇
𝑡 =1

(cid:105)

(cid:17) 𝑁
𝑖=1

= (cid:0)𝑎(𝑡)(cid:1)𝑇

𝑡 =1.

No user should learn any information from Sumprv [·] other
than her own inputs and the final outputs.

(S2) Zero-knowledge Cost-Sharing & Payment: With (cid:0)𝑎(𝑡)(cid:1)𝑇
𝑡 =1,
one can compute the energy storage service schedule (cid:0)(𝑥 + (𝑡),
𝑥 − (𝑡), 𝑦 (𝑡)(cid:1)𝑇
𝑡 =1 by Theorem 1. Then, each 𝑈𝑖 can compute and
𝑖 or 𝑃 ega
make her payment 𝑃𝑖 (= 𝑃 pp
) by Theorem 2. Since
𝑖
𝑎𝑖 (𝑡) is only known to 𝑈𝑖 , we need verifiable “zero-knowledge”
proofs in the payment transactions to show the following
properties without revealing 𝑎𝑖 (𝑡) or 𝑃𝑖 :

(S2.1) Non-negativity of user demands: 𝑎𝑖 (𝑡) ≥ 0 for all 𝑡. s
(S2.2) Correctness of payment: 𝑃𝑖 is computed correctly according

to Theorem 2 for each 𝑈𝑖 .

(S2.3) Sufficient balance of payment: Bal(ad𝑖 ) ≥ 𝑃𝑖 , where ad𝑖 is

the account address of 𝑈𝑖 .

(S2.4) Budget balance of energy storage service: (cid:205)𝑁

𝑖=1 𝑃𝑖 = Costess.
These zero-knowledge proofs will be crucial to safeguard
against dishonest users in cost-sharing payments.

(S3) Auditing for Virtual Net Metering: The grid operator needs
to verify the agreed energy flows from the energy storage
operator to users, namely, (cid:16) (cid:0)𝑥 −
𝑖 (𝑡)(cid:1)𝑇
𝑡 =1. To
𝑡 =1
enable auditing, the energy storage operator needs to provide
a receipt for each 𝑈𝑖 to certify her corresponding schedule
𝑖 (𝑡)(cid:1)𝑇
(cid:0)𝑥 −

𝑡 =1, but without the knowledge of (cid:0)𝑥 −
We emphasize that privacy protection is considered throughout the
integrated process of scheduling, cost-sharing, payment and VNM
auditing, without requiring a trusted third-party.

and (cid:0)𝑥 − (𝑡)(cid:1)𝑇

𝑖 (𝑡)(cid:1)𝑇

(cid:17) 𝑁
𝑖=1

𝑡 =1.

3.5.2 Threat Model.
Any users may be dishonest, who may try to cheat by paying
less to energy storage service or claim more in VNM than what
they ought to. These dishonest users may collude to coordinate
their actions. We aim to ensure the privacy of honest users and the
correctness of scheduling, cost-sharing and payment in the presence
of an adaptive adversary who may corrupt a majority of up to 𝑁 − 2
dishonest users. The adaptive adversary model provides a stronger
security guarantee than the static one, where the adversary may
corrupt users at any time during the protocols rather than before the
protocols. A malicious adversary is more challenging than a classical
semi-honest user due to her ability of deliberately deviating from the
protocols for prying into others’ privacy or sabotage the protocols.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

In case of any dishonest actions being detected, our system will
abort and notify all the users.

Note that our system is not required to identify individual dishon-
est user and it is fundamentally impossible [3] to identify a dishonest
user in multi-party computation with a majority of dishonest users.
There are secure multi-party computation protocols [12] that can
identify a dishonest user, but requiring a majority of honest users
and considerable computational overhead. On the other hand, we
can impose further measures to mitigate dishonesty. For example,
requiring proper user authentication to prevent shilling. Or, we can
require each user to pay a deposit in advance, which will be forfeited
if any dishonesty is detected.

4 CRYPTOGRAPHIC COMPONENTS
Our privacy-preserving solution relies on several basic components
from cryptography. We briefly explain them in this section. More
details can be found in a standard cryptography textbook (e.g., [5]).
Denote by Z𝑝 = {0, ..., 𝑝 − 1} the set of integers modulo 𝑝, for
encrypting private data. For brevity, we simply write “𝑥 + 𝑦” and
“𝑥 · 𝑦” for modular arithmetic without explicitly mentioning“mod 𝑝”.
We consider a usual finite group G of order 𝑝. We pick 𝑔, ℎ as two
generators of G, such that they can generate every element in G by
taking proper powers, namely, for each 𝑒 ∈ G, there exist 𝑥, 𝑦 ∈ Z𝑝
such that 𝑒 = 𝑔𝑥 = ℎ𝑦. The classical discrete logarithmic assumption
states that given 𝑔𝑥 , it is computationally hard to obtain 𝑥, which
underlies the security of many cryptosystems.

4.1 Cryptographic Commitments
A cryptographic commitment allows a user to hide a secret (e.g., to
hide the balances and transactions on a blockchain). We use Ped-
ersen commitment, which is perfectly hiding (i.e., a computionally
unbounded adversary cannot unlock the secret) and computation-
ally binding (i.e., an adversary cannot associate with another secret
in polynomial time). To commit secret value 𝑥 ∈ Z𝑝 , a user first
picks a random number r ∈ Z𝑝 to mask the commitment. Then, the
user computes the commitment by:

Cm(𝑥, r) = 𝑔𝑥 · ℎr (mod 𝑝)

(20)

where 𝑔 is a generator of a multiplicative group Z∗
𝑘 is a secret value and 𝑝 is a large prime number.

𝑝 , ℎ = 𝑔𝑘 (mod 𝑝),

Note that Pedersen commitment satisfies homomorphic property:
Cm(𝑥1 + 𝑥2, r1 + r2) = Cm(𝑥1, r1) · Cm(𝑥2, r2). Sometimes, we simply
write Cm(𝑥) without specifying random r. Next, we use Σ-protocol
to construct zero-knowledge proofs for several useful properties of
cryptographic commitments.

4.2 Zero-knowledge Proofs (ZKP)
In a zero-knowledge proof (of knowledge), a prover convinces a
verifier of the knowledge of a secret without revealing the secret.
For example, to show the knowledge of (𝑥, r) for Cm(𝑥, r) without
revealing (𝑥, r). A zero-knowledge proof of knowledge should sat-
isfy completeness (i.e., the prover always can convince the verifier
if knowing the secret), soundness (i.e., the prover cannot convince
a verifier if not knowing the secret) and zero-knowledge (i.e., the
verifier cannot learn the secret).

4.2.1 Σ-Protocol.
Σ-Protocol is a general approach to construct zero-knowledge
proofs. Given a computationally non-invertible function 𝑓 (·) that
satisfies homomorphic property 𝑓 (𝑎 +𝑏) = 𝑓 (𝑎) + 𝑓 (𝑏) and 𝑓 (𝑥) = 𝑦,
one can prove the knowledge of the concealed 𝑥:

(1) First, the prover sends a commitment 𝑦 ′ = 𝑓 (𝑥 ′), for a random

𝑥 ′, to the verifier.

(2) Next, the verifier replies with a random challenge 𝛽.
(3) The prover replies with 𝑧 = 𝑥 ′+𝛽 ·𝑥 (which does not reveal 𝑥).
(4) Finally, the verifier checks whether 𝑓 (𝑧)

?
= 𝑦 ′ + 𝛽 · 𝑦.

4.2.2 Σ-Protocol Based Zero-knowledge Proofs.
Next, we present four crucial instances of zero-knowledge proofs

based on Σ-protocol:

• ZKP of Commitment (zkpCm): Given Cm(𝑥, 𝑟 ), a prover can
convince a verifier of the knowledge of 𝑥 without revealing
(𝑥, 𝑟 ). Denote the corresponding zero-knowledge proof by
zkpCm[𝑥].

• ZKP of Summation (zkpSum): Given a set of commitments
(cid:0)Cm(𝑥𝑖, r𝑖 )(cid:1)𝑛
𝑖=1 and 𝑦, a prover can convince a verifier of the
knowledge of 𝑦 = (cid:205)𝑛
𝑖=1 𝑥𝑖 without revealing (𝑥𝑖 )𝑛
𝑖=1. Denote
the corresponding zero-knowledge proof by zkpSum[𝑦, (𝑥𝑖 )𝑛
𝑖=1].
• ZKP of Membership (zkpMbs): Given a set X = {𝑥1, ..., 𝑥𝑛 }
and Cm(𝑥, r), a prover can convince a verifier of the knowl-
edge of 𝑥 ∈ X without revealing 𝑥. Denote the corresponding
zero-knowledge proof by zkpMbs[𝑥, X].

• ZKP of Non-Negativity (zkpNN): Given Cm(𝑥, r), a prover
can convince a verifier of the knowledge of 𝑥 ≥ 0 without
revealing 𝑥. Denote the corresponding zero-knowledge proof
by zkpNN[𝑥].

The detailed constructions of these zero-knowledge proofs can be
found in Appendix. B.

4.3 Non-interactive Zero-knowledge Proofs
An interactive zero-knowledge proof that requires a verifier-provided
challenge can be converted to a non-interactive one by Fiat-Shamir
heuristic to remove the verifier-provided challenge.

Let H (·) ↦→ Z𝑝 be a cryptographic hash function. Given a list
of commitments (Cm1, ..., Cm𝑟 ), one can map to a single hash value
by H (Cm1|...|Cm𝑟 ), where the input is the concatenated string of
(Cm1, ..., Cm𝑟 ). In a Σ-protocol, one can set the challenge by 𝛽 =
H (Cm1|...|Cm𝑟 ), where (Cm1, ..., Cm𝑟 ) are all the commitments gen-
erated by the prover prior to the step of verifier-provided chal-
lenge (Step 2 of Σ-protocol). Hence, the prover does not wait for
the verifier-provided random challenge, and instead generates the
random challenge himself. The verifier will generate the same chal-
lenge following the same procedure for verification. We denote the
non-interactive versions of the previous zero-knowledge proofs by
nzkpCm, nzkpSum, nzkpMbs, nzkpNN, respectively.

4.4 Public-Private Key Signatures
Cryptographic signatures are a standard tool to verify the authen-
ticity of some given data. Suppose that a signer has a pair of public
and private keys (𝐾 p, 𝐾 s) for an asymmetric key cryptosystem (e.g.,

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

Fig. 2. An example of information-theoretical secret-sharing. Let us compute
𝑥 + 𝑦, without revealing 𝑥 or 𝑦. Party 1 splits 𝑥 into (𝑥𝑖 ) 4
𝑖=1 and secretly
shares each with one party. So is party 2 for 𝑦. Next, each party 𝑖 computes
𝑧𝑖 = 𝑥𝑖 + 𝑦𝑖 locally. Then, we can obtain the sum 𝑥 + 𝑦 = (cid:205)4
𝑖=1 𝑧𝑖 , when
(𝑧𝑖 ) 4
𝑖=1 are revealed to everyone, which however does not leak either 𝑥𝑖 or
𝑦𝑖 .

RSA). To sign a message 𝑚, the signer first maps 𝑚 by a crypto-
graphic hash function H (𝑚) (e.g., SHA-3). Then the signature of
𝑚 is the encryption sign𝐾 s [𝑚] = Enc𝐾 s [H (𝑚)]. Given (𝑚, 𝐾 p),
anyone can verify the signature sign𝐾 s [𝑚] by checking whether
the decryption Dec𝐾 p [sign𝐾 s [𝑚]]

?
= H (𝑚).

5 MULTI-PARTY COMPUTATION PROTOCOL
Our privacy-preserving solution also relies on a multi-party compu-
tation protocol called SPDZ [13, 14], which allows multiple parties
to jointly compute a function while concealing the private inputs.
SPDZ can safeguard against a majority of dishonest users (i.e., all but
one party can be dishonest), and does not require a trusted dealer
for setup. For clarity, this section presents a simplified version of
SPDZ. Readers can refer to [13, 14] for the detailed description.

Information-theoretical Secret Sharing

5.1
SPDZ relies on the notion of information-theoretical secret-sharing,
whereby private data will be distributed to multiple parties, such
that each party only knows a share of the data, without complete
knowledge of other shares. Hence, computation of individual shares
of data will not reveal the original data, unless all shares are re-
vealed for output or verification. Several distributed computation
operations can be performed locally via SPDZ, while preserving the
secret sharing property.

We consider the computation of a function of an arithmetic circuit
consisting of only additions and multiplications. Suppose a private
number 𝑥 is distributed to 𝑛 parties, such that each party 𝑖 knows
a share 𝑥𝑖 only, where 𝑥 = (cid:205)𝑛
𝑖=1 𝑥𝑖 , but not knowing other shares
𝑥 𝑗 , where 𝑗 ≠ 𝑖. Note that a party is unable to construct 𝑥, without
knowing all the shares. In the following, we write ⟨𝑥⟩ as a secretly
shared number, meaning that there is a vector (𝑥1, ..., 𝑥𝑛), such that
each party 𝑖 knows only 𝑥𝑖 . Given secretly shared ⟨𝑥⟩ and ⟨𝑦⟩, and
a public known constant 𝑐, the following operations can be attained
by local computation at each party, and then the outcome can be
assembled from the individual shares:

A1) ⟨𝑥⟩ + ⟨𝑦⟩ can be computed by (𝑥1 + 𝑦1, ..., 𝑥𝑛 + 𝑦𝑛).
A2) 𝑐 · ⟨𝑥⟩ can be computed by (𝑐 · 𝑥1, ..., 𝑐 · 𝑥𝑛).
A3) 𝑐 + ⟨𝑥⟩ can be computed by (𝑐 + 𝑥1, 𝑥2, ..., 𝑥𝑛).

To reveal ⟨𝑥⟩, each party 𝑖 broadcasts 𝑥𝑖 to other parties. Then each
party can reconstruct 𝑥 = (cid:205)𝑛
𝑖=1 𝑥𝑖 . See an illustration in Figure 2.

Multiplications can also be computed by SPDZ, and the detailed
description can be found in Appendix. D. With additions and multi-
plications, one can construct a large class of computation functions
(including comparison and branching conditions).

However, some parties may be dishonest, who may not perform
the correct local computation. To safeguard against dishonest parties,
an information-theoretical message authentication code (MAC) can
be used for verification. Every secretly shared number is encoded
by a MAC as 𝛾 (𝑥), which is also secretly shared as ⟨𝛾 (𝑥)⟩. The basic
idea is that if a dishonest party wants to modify her share 𝑥𝑖 , then he
also needs to modify 𝛾 (𝑥)𝑖 consistently. This allows dishonesty to be
detectable by checking the corresponding MAC in the final output.
The detailed description of MAC can be found in Appendix. D. In the
following, we write ⟨⟨𝑥⟩⟩ meaning that both ⟨𝑥⟩ and the respective
MAC ⟨𝛾 (𝑥)⟩ are secretly shared among users.

5.2 Overview of SPDZ Protocol
The SPDZ consists of three phases, as outlined as follows:

(1) Pre-processing Phase: In this phase, a collection of shared
random numbers will be constructed to mask the private
input numbers. For each private input number of party 𝑖, there
needs a shared random number ⟨⟨𝑟𝑖 ⟩⟩, where 𝑟𝑖 is revealed to
party 𝑖 only, but not to other parties.

(2) Online Phase: To secretly shares a private input number 𝑥𝑖
using ⟨⟨𝑟𝑖 ⟩⟩, without revealing 𝑥𝑖 , it proceeds as follows:
1) Party 𝑖 computes and reveals 𝑧𝑖 = 𝑥𝑖 − 𝑟𝑖 to all parties.
2) Every party sets ⟨⟨𝑥𝑖 ⟩⟩ ← 𝑧𝑖 + ⟨⟨𝑟𝑖 ⟩⟩ (see A3).
Any computation circuit with additions or multiplications can
be computed by local computations (e.g., A1-A3). The MACs
are updated accordingly to preserve the consistency.

(3) Output and Validation Phase: All MACs will be revealed for
validation. If there is any inconsistency in MACs, then abort.

The details of SPDZ protocol can be found in Appendix. C.

6 PRIVACY-PRESERVING SOLUTION FOR ENERGY

STORAGE SHARING

This section presents an integrated solution for privacy-preserving
energy sharing, based on blockchain, zero-knowledge proofs and
multi-party computation protocol SPDZ.

6.1 Privacy-Preserving Ledger
First, we incorporate privacy protection to hide the transaction
records on the ledger, while still allowing proper verifications for
cost-sharing and VNM. As in other privacy-preserving blockchain
platforms (e.g., Zether [6]), we conceal the balances and transaction
values in the ledger by the respective cryptographic commitments
instead of plaintext values. The accounts in the ledger will become
as follows:

Table 2. Accounts in the privacy-preserving ledger

𝐾 p
ad𝑖
𝑖
ad𝑗 𝐾 p
𝑗
...
...

Cm(Bal(ad𝑖 ))
Cm(Bal(ad𝑗 ))
...

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

A multi-transaction will be concealed as mtx = (ad𝑖, ad𝑖′, Cm(val𝑖 ))𝑁
Because of concealed balances and transaction values, each user
must provide nzkpNN[Bal(ad𝑖 ) − val𝑖 ] along with each transaction
request to prove the non-negativity of the resultant balance. Other-
wise, the transaction request will be denied by the ledger without
the correct nzkpNN.

𝑖=1.

6.2 Privacy-Preserving Protocol Πpess
We design a protocol, denoted by Πpess, to coordinate the users for
privacy-preserving energy storage service scheduling, cost-sharing,
payment and VNM settlement. We denote the energy storage oper-
ator and grid operator by Opres

and Oprgr

respectively.

Before presenting the details of the protocol, we first outline some

high-level ideas:

(1) First, the users need to secretly share private individual de-
mands ⟨⟨𝑎𝑖 (𝑡)⟩⟩. Then, they can compute aggregate demand
⟨⟨𝑎(𝑡)⟩⟩ via SPDZ in a privacy-preserving manner.

(2) To enable subsequent verification of the payment transactions
and VNM, 𝑈𝑖 also needs to announce commitment Cm(𝑎𝑖 (𝑡))
to each other. However, a dishonest user may use incon-
sistent commitment Cm(𝑎𝑖 (𝑡)) with respect to the secretly
shared ⟨⟨𝑎𝑖 (𝑡)⟩⟩. To show the consistency between Cm(𝑎𝑖 (𝑡))
and ⟨⟨𝑎𝑖 (𝑡)⟩⟩, all users need to create zero-knowledge proof
of commitment zkpCm[𝑎𝑖 (𝑡)] via SPDZ using secretly shared
⟨⟨𝑎𝑖 (𝑡)⟩⟩. If zkpCm[𝑎𝑖 (𝑡)] is verified to be correct, then Cm(𝑎𝑖 (𝑡))
and ⟨⟨𝑎𝑖 (𝑡)⟩⟩ are consistent. Each user also creates a zero-
knowledge proof of non-negativity nzkpNN[𝑎𝑖 (𝑡)].

𝑖 or 𝑃 ega

(4) Next, 𝑈𝑖 can make her payment 𝑃𝑖 (= 𝑃 pp

(3) After verifying zkpCm[𝑎𝑖 (𝑡)] and nzkpNN[𝑎𝑖 (𝑡)], the users
reveal ⟨⟨𝑎(𝑡)⟩⟩ and verify the corresponding MAC to ensure
the integrity of 𝑎(𝑡). Then, the users compute the energy
storage service schedule with the knowledge of (cid:0)𝑎(𝑡)(cid:1)𝑇

𝑡 =1.
) by Theo-
rem 2. The users jointly compute the total payments (cid:205)𝑁
𝑖 𝑃𝑖
via SPDZ in a privacy-preserving manner to ensure that the
difference between Costess and (cid:205)𝑁
𝑖 𝑃𝑖 is within a negligible
rounding error 𝜀, such that |Costess − (cid:205)𝑁
𝑖 𝑃𝑖 | < 𝜀. The users
agree and set Costess = (cid:205)𝑁

𝑖 𝑃𝑖 .
(5) To make cost-sharing payments for energy storage service
on the ledger, the users need to create a zero-knowledge proof
that (cid:205)𝑁
𝑃𝑖 ] locally. Then, the users submit a multi-transaction request
with relevant zero-knowledge proofs to the ledger.

𝑖

𝑖=1 𝑃𝑖 = Costess via SPDZ. 𝑈𝑖 also creates nzkpNN[Bal(ad𝑖 )−

(6) After the completion of multi-transaction of payments, the en-
ergy storage service schedule is executed. Afterwards, Opres
signs Cm(cid:0)𝑥 −
𝑖 (𝑡)(cid:1) as a receipt on the ledger for each user. Note
that Cm(cid:0)𝑥 −
𝑖 (𝑡)(cid:1) can be generated based on Cm(cid:0)𝑎𝑖 (𝑡)(cid:1) and the
energy storage service schedule.

(7) The users request VNM settlement with Oprgr

ify 𝑥 −

𝑖 (𝑡) from the signed Cm(cid:0)𝑥 −

𝑖 (𝑡)(cid:1) on the ledger.

, who will ver-

Next, we present the details of the privacy-preserving protocol
Πpess, consisting of four stages (Initialization, Pre-operation Sched-
uling, Cost-sharing Payment & Operation and Post-operation VNM
Settlement), as follows:

Stage 0: Initialization.
In this stage, the system parameters are chosen and the pre-
processing phase of SPDZ is executed among the users. See Ap-
pendix. C for detailed SPDZ pre-processing phase.

Initialization:

(1) Choose and announce a multiplicative group Z∗

𝑝 , two gen-
erators 𝑔, ℎ ∈ Z∗
𝑝 and hash function H (·) ↦→ Z𝑝 as public
information to all users. Note that 𝑔 and ℎ can be obtained
via a coin-tossing protocol [35] among the users such that
log𝑔 ℎ is unknown due to the hardness of discrete logarithm.
(2) The energy storage operator announces ps, ec, ed, rc, rd, (cid:0)𝑝 (𝑡),

B(𝑡)(cid:1)𝑇

𝑡 =1 as public information to all users.
(3) Initialize SPDZ pre-processing phase among all users.

Stage 1: Pre-operation Scheduling.
In this stage, the users will compute their aggregate day-ahead
demands via SPDZ. The users also need to make commitments of
their individual demands (cid:0)𝑎𝑖 (𝑡)(cid:1)𝑇
𝑡 =1, which will be used for audit-
ing in VNM. We ensure that the individual demands shared via
SPDZ match the ones being committed. This can be accomplished
by computing zero-knowledge proof of commitment zkpCm[𝑎𝑖 (𝑡)]
using the secretly shared ⟨⟨𝑎𝑖 (𝑡)⟩⟩. Next, the users will compute the
optimal energy storage service schedule in (P2) based on aggregate
demands (cid:0)𝑎(𝑡)(cid:1)𝑇

𝑡 =1.

Protocol Π (1)

pess:

(1) 𝑈𝑖 commits 𝐶𝑖 (𝑡) = Cm(cid:0)𝑎𝑖 (𝑡), r𝑖 (𝑡)(cid:1) for all 𝑡 and announces
(cid:0)𝐶𝑖 (𝑡)(cid:1)𝑇
𝑡 =1 to all users with (cid:0)nzkpNN[𝑎𝑖 (𝑡)](cid:1)𝑇
𝑡 =1, where r𝑖 (𝑡)
is a random masking number. All users verify nzkpNN[𝑎𝑖 (𝑡)].
If verification of nzkpNN[𝑎𝑖 (𝑡)] fails, announce Abort.
(2) 𝑈𝑖 secretly shares ⟨⟨𝑎𝑖 (𝑡)⟩⟩ and ⟨⟨r𝑖 (𝑡)⟩⟩ via SPDZ for all 𝑡.
(3) To show the equality of 𝑎𝑖 (𝑡) in ⟨⟨𝑎𝑖 (𝑡)⟩⟩ and 𝐶𝑖 (𝑡), 𝑈𝑖 con-

structs an zkpCm[𝑎𝑖 (𝑡)] distributedly via SPDZ:
(a) 𝑈𝑖 randomly generates (cid:0)𝑎′

𝑖 (𝑡)(cid:1) ∈ Z𝑝 and secretly
𝑖 (𝑡)⟩⟩ and ⟨⟨r′
shares as ⟨⟨𝑎′
𝑖 (𝑡) =
Cm(cid:0)𝑎′
𝑖 (𝑡)(cid:1) to all users. Note that all the users must
𝑖 (𝑡), r′
complete this step before proceeding to the next step to
produce a common random challenge 𝛽 (𝑡).

𝑖 (𝑡)⟩⟩. Then 𝑈𝑖 announces 𝐶 ′

𝑖 (𝑡), r′

(b) All the users conduct a coin-tossing protocol to obtain a ran-
dom challenge 𝛽 (𝑡). Firstly, each user announces a commit-
ment 𝐶 ′′
𝑖 (𝑡) of a randomly generated number r′′
𝑖 (𝑡) ∈ Z𝑝 .
Then all the users reveal r′′
𝑖 (𝑡) and compute a random
challenge 𝛽 (𝑡) = (cid:205)𝑁
𝑖 (𝑡).

𝑖=1 r′′
(c) All users compute and reveal ⟨⟨𝑧𝑎𝑖 (𝑡 ) ⟩⟩ = ⟨⟨𝑎′

𝑖 (𝑡)⟩⟩ + 𝛽 (𝑡) ·

⟨⟨𝑎𝑖 (𝑡)⟩⟩ and ⟨⟨𝑧r𝑖 (𝑡 ) ⟩⟩ = ⟨⟨r′
(d) This creates zkpCm[𝑎𝑖 (𝑡)] = {𝐶 ′
verify zkpCm by checking

𝑖 (𝑡)⟩⟩ + 𝛽 (𝑡) · ⟨⟨r𝑖 (𝑡)⟩⟩ for 𝑈𝑖 .

𝑖 (𝑡), 𝑧𝑎𝑖 (𝑡 ), 𝑧r𝑖 (𝑡 ) }. All users

𝑔𝑧𝑎𝑖 (𝑡 ) · ℎ𝑧r𝑖 (𝑡 )

?
= 𝐶 ′

𝑖 (𝑡) · Cm(cid:0)𝑎𝑖 (𝑡), r𝑖 (𝑡)(cid:1) 𝛽 (𝑡 )

(e) If the verification of zkpCm fails, announce Abort.

(4) The users compute ⟨⟨𝑎(𝑡)⟩⟩ ← (cid:205)𝑁

𝑖=1⟨⟨𝑎𝑖 (𝑡)⟩⟩ for all 𝑡 via SPDZ.
Reveal ⟨⟨𝑎(𝑡)⟩⟩ to all users. Check MAC of ⟨⟨𝑎(𝑡)⟩⟩. If the MAC
check fails, announce Abort.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

(5) The users solve (P2) using (cid:0)𝑎(𝑡)(cid:1)𝑇
(6) All users compute Costess ≜ (cid:205)𝑇

Costorg ≜ (cid:205)𝑇

𝑡 =1 𝑝 (𝑡) · 𝑥 − (𝑡),

𝑡 =1 for (cid:0)𝑥 + (𝑡), 𝑥 − (𝑡), 𝑦 (𝑡)(cid:1)𝑇
𝑡 =1
(cid:1) · 𝑥 + (𝑡) and
𝑡 =1
.

(cid:0)𝑝 (𝑡) + ps
ˆp(𝑡) ≜ 𝑥 − (𝑡 ) ·𝑝 (𝑡 )

𝑎 (𝑡 )

Stage 2: Cost-sharing Payment & Operation.
In this stage, the users will split the cost of energy storage service
based on proportional or egalitarian cost-sharing scheme via SPDZ.
The users compute the payment commitments and verify the validity
of Costess by comparing with (cid:205)𝑁
𝑖=1 𝑃𝑖 . Before issuing the multi-
transaction, the users compute nzkpSum[Costess, (𝑃𝑖 )𝑁
𝑖=1] to satisfy
Theorem 3. The users then make energy storage service payments
via privacy-preserving blockchain. After receiving the payments,
the energy storage operator will issue verifiable receipts on the
ledger.

Protocol Π (2)

pess:

(1) 𝑈𝑖 computes 𝑃𝑖 = 𝑃 pp
𝑖

) by Theorem 2, and announces
commitment Cm(𝑃𝑖, r𝑖 ) to all users, and secretly shares ⟨⟨r𝑖 ⟩⟩
via SPDZ.

(or 𝑃 ega
𝑖

(2) The users also compute the total payments via SPDZ by

𝑁
∑︁

𝑖=1

𝑃𝑖 =

𝑁
∑︁

𝑁
∑︁

𝑇
∑︁

·

(cid:16)



=

𝑖=1

𝑖=1

𝑃 ega
𝑖

𝑖=1
𝑁
∑︁

𝑃 pp
𝑖 =

𝑡 =1
𝑇
∑︁

⟨⟨𝑎𝑖 (𝑡)⟩⟩(cid:1),

(cid:0)⟨⟨𝑎𝑖 (𝑡)⟩⟩ · ˆp(𝑡) −

(cid:0) Costess · ˆp(𝑡)
Costorg
𝑁
∑︁



(21)
and check if satisfying |Costess − (cid:205)𝑁
𝑖=1 𝑃𝑖 | < 𝜀, where 𝜀 is a
small fault-tolerant factor, which restricts the rounding error,
arising from computing Costess
or ˆp(𝑡). If satisfied, the users
Costorg
let Costess ← (cid:205)𝑁

Costorg − Costess
𝑁

𝑖=1 𝑃𝑖 . Otherwise, announce Abort.

𝑡 =1

𝑖=1

(cid:1) (cid:17)

(3) The users compute nzkpSum[Costess, (𝑃𝑖 )𝑁

𝑖=1] via SPDZ dis-

tributely:
(a) 𝑈𝑖 randomly generates and secretly shares ⟨⟨r′

𝑖 ⟩⟩ ∈ Z𝑝

before announcing Cm(0, r′
𝑖 ).
(b) All users compute 𝐶 ′ = (cid:206)𝑁
𝑖=1 Cm(0, r′

𝑖 ) and obtain a random
challenge 𝛽 = H (𝐶 ′). Then all users compute ⟨⟨𝑧r⟩⟩ =
(cid:205)𝑛

𝑖=1⟨⟨r𝑖 ⟩⟩. Then reveal ⟨⟨𝑧r⟩⟩.

𝑖 ⟩⟩ + 𝛽 · (cid:205)𝑛

𝑖=1⟨⟨r′

(c) This creates nzkpSum[Costess, (𝑃𝑖 )𝑁

𝑖=1] = {𝐶 ′, 𝑧r}. All users

verify nzkpSum by checking:

𝑔𝛽 ·Costess · ℎ𝑧r

?
= 𝐶 ′ ·

𝑛
(cid:214)

𝑖=1

Cm(𝑃𝑖, r𝑖 )𝛽

If the verification of nzkpSum fails, announce Abort.
(4) 𝑈𝑖 computes nzkpNN[Bal(ad𝑖 ) − 𝑃𝑖 ] based on Cm(𝑃𝑖 ).
(5) Let the account address of Opres
a multi-transaction request

be adess. The users submit

mtx = (cid:0)ad𝑖, adess, Cm(𝑃𝑖 )(cid:1) 𝑁
𝑖=1

to the ledger, along with
nzkpSum[Costess, (𝑃𝑖 )𝑁

𝑖=1] and nzkpNN[Bal(ad𝑖 ) − 𝑃𝑖 ]𝑁
𝑖=1

(6) The ledger verifies nzkpSum and nzkpNN before proceeding
the transaction. If the verification fails, announce Abort.

(7) The users provide the schedule (cid:0)𝑎(𝑡), 𝑥 + (𝑡), 𝑥 − (𝑡), 𝑦 (𝑡)(cid:1)𝑇
. After the transaction completes, Opres

𝑡 =1
will execute

to Opres
the schedule.

Stage 3: Post-operation VNM Settlement.
In this stage, Opres
𝑖 (𝑡)(cid:1)𝑇

storage service (cid:0)𝑥 −
When the users request VNM settlement with Oprgr
verify their claims by the receipts on the ledger.

will sign the receipts of individual energy
𝑡 =1. The receipts will be stored on the ledger.
will

, Oprgr

Protocol Π (3)

pess:

(cid:1) 𝑁
𝑖=1 (from Stage 1) to the ledger.
(ac-

𝑖 (𝑡)) = Cm(𝑎𝑖 (𝑡))

𝑥 − (𝑡 )
𝑎 (𝑡 )

𝑡 =1

(1) The users upload (cid:0)Cm(𝑎𝑖 (𝑡))𝑇
(2) Opres

computes commitment Cm(𝑥 −
cording to Theorem 2) for all 𝑡 and 𝑖.
(3) Let the public-private keys of Opres
[ Cm(𝑥 −

be (𝐾 p
𝑖 (𝑡))] along with Cm(𝑥 −

signs sign𝐾 s
ess
on the ledger.

ess, 𝐾 s
ess). Opres
𝑖 (𝑡)) to be stored

(4) Opres

(cid:0)𝑥 − (𝑡)(cid:1)𝑇

prepares VNM and provides energy export profile
𝑡 =1 to Oprgr

.

(5) 𝑈𝑖 submits a claim for reimbursement by referring to receipt
[Cm(𝑥 −
𝑖 (𝑡))] on the ledger. 𝑈𝑖 also

Cm(𝑥 −
reveals 𝑥 −

𝑖 (𝑡)) and sign𝐾 s
𝑖 (𝑡) to Oprgr
verifies sign𝐾 s

ess

(6) Oprgr

ess
to prove the validity.
[Cm(𝑥 −

𝑖 (𝑡))] by public key 𝐾 p
ess, and
𝑖 (𝑡)(cid:1)𝑇
𝑡 =1 with (cid:0)𝑥 −
will deduct the amount

𝑡 =1.

compares the energy demand profile (cid:0)𝑎𝑖 (𝑡)(cid:1)𝑇
If the verification is consistent, Oprgr
(cid:205)𝑇

𝑖 (𝑡) · 𝑝 (𝑡) from 𝑈𝑖 ’s total payment.

𝑡 =1 𝑥 −

Remarks: In protocol Πpess, each user is required to input her
privacy demand (cid:0)𝑎(𝑡)(cid:1)𝑇
𝑡 =1 in two privacy-preserving ways: (1) com-
mitment Cm(𝑎𝑖 (𝑡)), and (2) secretly shared value in SPDZ ⟨⟨𝑎𝑖 (𝑡)⟩⟩.
While the commitment Cm(𝑎𝑖 (𝑡)) is used to generate other zero-
knowledge proofs for payments and VNM, the secretly shared
⟨⟨𝑎𝑖 (𝑡)⟩⟩ is used to compute service scheduling and cost-sharing.
Both inputs should be consistent (i.e., checked by zkpCm[𝑎𝑖 (𝑡)] that
is constructed via SPDZ). Also, Cm(𝑎𝑖 (𝑡)) can be used to construct
Cm(𝑃𝑖 ) and Cm(𝑥 −
𝑖 (𝑡)) without the knowledge of 𝑎𝑖 (𝑡), because of
its homomorphic property for these constructions.

See Appendix. D for the security analysis of Πpess for satisfying

security requirements S1-S3.

7 EVALUATION
In this section, we present an evaluation study of our solution,
including the effectiveness of energy storage sharing, multi-party
computation protocol performance and the incurred cost of smart
contract implementation on a practical blockchain platform.

7.1 Energy Storage Service Scheduling
We first evaluate the effectiveness of energy storage sharing. We se-
lected 120 users from the Smart* microgrid dataset [2]. We consider
a single 24-hour period, from midnight to next midnight.

In particular, we present the temporal data trace of scheduled
energy storage services for 4 users. We observe that each of the user
can utilize energy storage discharging during peak-hour. Most users

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

Fig. 3. Data trace of energy storage service schedule.

(a) Computational overhead

(b) Communication overhead
Fig. 4. System performance and smart contract gas costs.

(c) Gas cost of executeTransaction()

acquire energy from the grid during off-peak-hour, and partially
during shoulder-hour. Next, we study the saving (Δ𝑖 ) of each user. In
Figure 3, we study different cost-sharing schemes of energy storage
service for 4 users. We observe that proportional cost-sharing gives
each user at the same percentage of saving of 28.78% when energy
storage 𝐵 is 400 kWh, whereas different user has different percentage
of saving with egalitarian cost-sharing, but with the same amount
of saving of $37.90.

7.2 SPDZ Performance
Next, we evaluate the performance of SPDZ in stages 1-2 of Πpess.
We skip stage 3 due to its negligible performance compared with
stages 1-2. We consider 144 time slots in a single 24-hour period.
All the results were averaged over 20 instances.

7.2.1 Computational Overhead. We scaled the number of users
from 5 to 25. Figure 4a displays the average running time incurred at
each user in the stage 1. The running time shows a linearly growing
trend with the increased number of users. The running time starts
from about 0.91 seconds with 5 users to around 4.32 seconds with
25 users. We skip the displaying of the stage 2 due to the negligible
computational overhead of only several milliseconds.

7.2.2 Communication Overhead. Figure 4b shows the average
total volume of the transmission data in stages 1 and 2. It is evident
that the total transmission amount scale linearly with the growing
number of users in both stages. The data volume increases from
3.62 MB with 5 users to about 26.89 MB with 25 users in stage 1. In
contrast, the data volume in stage 2 starts from a merely 5 KB with
5 users to about 40 KB with 25 users. Thus, the total data volume in
stage 1 dominates the entire protocol.

7.3 Ethereum Smart Contract Gas Costs
We implemented the payment systems as a smart contract on real-
world Ethereum blockchain platform. The smart contract is specified

by Solidity programming language [27]. We outline some imple-
mentation components as follows:

(1) Pedersen. This component aims to realize the underlying Ped-

ersen commitment scheme.

(2) ESToken. We created a Ethereum-based cryptocurrency ESTo-
ken for our energy sharing scenario, whereby users are able
to pay the energy cost without revealing the true payments.
(3) MultiSignature. This component allows the users to submit a
multi-transaction request, where the transaction will proceed
unless all the involved users validate the transaction. There
are three main methods: submitTransaction(),
confirmTransaction() and executeTransaction().
Distributed miners will execute the compiled bytecode of the
smart contracts in Ethereum Virtual Machine. Miners will charge
additional Ether/ETH (Ethereum native crytocurrency) called gas
costs, because the extra computational tasks incurred by smart con-
tracts will be broadcast throughout the blockchain. Gas costs are
used to measure the amount of computational resources to execute
the operations required by a transaction. We measured the incurred
gas costs by our smart contracts and used a 255-bit prime number 𝑞
for Pedersen commitment since Solidity supports at most 256-bit
numbers. We employed Truffle Suite [39] as the Ethereum devel-
opment framework to test and measure the average gas costs4 of
Multi-Signature methods, shown in Table 3, where 𝑁 is the num-
ber of users and 𝑁𝑏 indicates the number of bits to represent the
plaintext payment in the nzkpMbs. A transaction initiator must pay
sufficient amount of gas costs to the miner, who creates transaction
blocks on the network. The gasPrice in a transaction allows the
transaction initiator to set the gas price that she is willing to pay.
The higher the gas prices, the higher probability the transaction will
be chosen by the miner in a block. We use the standard gas price 54

4The actual gas costs may vary based on the random generated parameters of the
zero-knowledge proofs. Here, we show the average gas costs.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

Gwei and Ether price5 $4068 USD/ETH to estimate the equivalent
transaction cost in Ether (see [38] and [11]).

Table 3. Table of gas costs for multi-signature methods

Gas Cost Ether USD (as on 25 Oct 21)

submit()
confirm()

106k
3600k

0.0057
0.1944

$ 23.2
$ 790.8

|Input| (bytes)
64 + 64 ×𝑁
128 + 180 ×𝑁𝑏

Figure 4c presents the gas cost of executeTransaction() func-
tion. We observe that the gas cost is linearly proportional to the
number of involved users, starting from 1437k (0.0776 ether, $ 315.7)
with 5 users to 5986k (0.3232 ether, $ 1314.8) with 25 users, since the
verification of nzkpSum depends on the number of users. Overall,
we observe only moderate incurred costs by our smart contract,
which are comparable to other privacy-preserving smart contract
studies in the literature.

8 EXTENSIONS AND LIMITATIONS
In this section, we discuss some possible extensions to enhance our
privacy-preserving energy storage sharing solution. We also discuss
some limitations of our current solution.

8.1 Flexible Demands and Hour-ahead Scheduling
Our current energy storage service scheduling is designed to operate
in a day-ahead manner. There is a limitation that users are not
supposed to alter their requested demand (at least, for the part of
demand that is allocated to be satisfied by scheduled energy storage
discharging). A more flexible approach is desirable to incorporate
both day-ahead and hour-ahead scheduling processes, which is
called dual service scheduling. The hour-ahead scheduling process
allows the users to request energy storage service in a much shorter
time-window.

The dual service scheduling can be achieved by dividing the
capacity of energy storage into two parts: (1) Bd (𝑡) as the capacity for
day-ahead service scheduling and (2) Bh (𝑡) for hour-ahead service
scheduling, such that Bd (𝑡) + Bh (𝑡) = B(𝑡). Both service scheduling
processes can run separately, with hour-ahead scheduling running
before each hour. Our privacy-preserving service scheduling process
can be extended straightforwardly to operate the two parts of service
scheduling in tandem.

8.2 Virtual Net Metering Service Fees
In our current privacy-preserving service scheduling process, we
assume that the energy storage operator can transfer the credits as
a result of exporting energy through discharging energy storage
via virtual net metering to the users, with no additional service fees
from the grid operator. Namely, the energy storage operator can
always transfer the full credits of 𝑥 − (𝑡) · 𝑝 (𝑡) to compensate the
users’ consumption at each timeslot 𝑡.

However, the grid operator may charge additional fees to attain
virtual net metering, in particular, when the energy storage opera-
tor is not located in the same local grid network as the users. For

5The Ether price quote was obtained on 25 Oct 2021.

instance, the grid operator charges fees as svnm percent of the cred-
its transferred in virtual net metering. Namely, when the energy
storage operator transfers the credits of 𝑥 − (𝑡) · 𝑝 (𝑡) to the users,
the users actually receives (1 − svnm) · 𝑥 − (𝑡) · 𝑝 (𝑡).

One possible approach to incorporate in our privacy-preserving

service scheduling process is to modify Cons. (2) as

𝑏 (𝑡 + 1) − 𝑏 (𝑡) = ec𝑥 + (𝑡) − ed

1
(1−svnm)

𝑁
∑︁

(cid:16)

𝑖=1

(cid:17)

𝑥 −
𝑖 (𝑡)

(22)

That is, we reduce the actual amount of discharged energy from
the energy storage as to incorporate the additional service fees for
virtual net metering from the grid operator.

8.3 Reducing Gas Cost on Ethereum
Although our current solution incurs a moderate gas cost on Ethereum,
this is still considerable when the Ether price has increased signif-
icantly in the recent years. High Ether price has deterred many
real-world smart contract projects from operation. We seek to im-
prove the gas cost of our smart contract solution. There are a number
of possible improvements. First, rather than storing the receipts on
the ledger, which can take up a considerable storage space and
costs extra gas cost, we can store a small hash pointer instead on
the ledger. The users can verify the contents of the receipts by
matching with the hash pointer. Second, there should be more effi-
cient zero-knowledge proofs that can be executed on smart contract.
One possible option is Bulletproofs [7], which are more succinct
zero-knowledge proofs than Σ-protocol. Bulletproofs have been
employed in certain privacy-preserving blockchain platforms (e.g.
Monero, Zether [6, 33]). Third, even though we implemented our
solution as a smart contract on permissionless Ethereum blockchain
platform, our solution can also be implemented on a permissioned
blockchain platform, on which the gas cost is not a major concern.

9 CONCLUSION
In this paper, we provide a novel approach to support third-party
energy storage sharing without compromising the privacy of indi-
vidual users. In our privacy-preserving solution, an energy storage
operator is only revealed the minimal information to schedule en-
ergy storage operations, without knowing users’ private demands.
At the same time, the users can divide the cost of energy storage
service fairly among themselves without knowing each other’s de-
mands. Our solution can effectively safeguard against a majority of
dishonest users, without requiring trusted third-parties. We imple-
mented our solution as a smart contract on Ethereum blockchain
platform, which incurs moderate overhead and gas costs in practice.
In future work, we will support robustness against potentially
dishonest energy storage operators. For instance, we can require
an energy storage operator to prove that her energy export profile
matches the service schedules in order to receive the payments
from users. We will also explore the support for peer-to-peer energy
storage sharing by distributing service scheduling and cost-sharing
computation among the end users themselves.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

REFERENCES
[1] Merlinda Andoni, Valentin Robu, David Flynn, Simone Abram, Dale Geach,
David P. Jenkins, Peter McCallum, and Andrew Peacock. 2019. Blockchain tech-
nology in the energy sector: A systematic review of challenges and opportunities.
Renewable and Sustainable Energy Reviews 100 (2019), 143–174.

[2] Sean Barker, Aditya Mishra, David Irwin, Emmanuel Cecchet, Prashant Shenoy,
and Jeannie Albrecht. 2012. Smart*: An Open Data Set and Tools for Enabling
Research in Sustainable Homes. In SustKDD.

[3] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. 1988. Completeness
Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation. In
Annual ACM Symposium on Theory of Computing (STOC).

[4] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers,
and Eran Tromerand Madars Virza. 2014. Zerocash: Decentralized Anonymous
Payments from Bitcoin. In IEEE Symposium on Security and Privacy.

[5] William J. Buchanan. 2017. Cryptography. River Publishers.
[6] Benedikt Bunz, Shashank Agrawal, Mahdi Zamani, and Dan Boneh. 2020. Zether:
Towards Privacy in a Smart Contract World. In Financial Cryptography and Data
Security (FC).

[7] B. Bunz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. 2018. Bullet-
proofs: Short proofs for confidential transactions and more. In IEEE symposium
on security and privacy (SP).

[8] Chi-Kin Chau and Khaled Elbassioni. 2018. Quantifying Inefficiency of Fair Cost-
Sharing Mechanisms for Sharing Economy. IEEE Trans. Control of Network System
5 (Dec 2018), 1809–1818. Issue 4.

[9] Sid Chi-Kin Chau, Jiajia Xu, Wilson Bow, and Khaled Elbassioni. 2019. Peer-to-
Peer Energy Sharing: Effective Cost-Sharing Mechanisms and Social Efficiency.
In ACM Intl. Conf. on Future Energy Systems (e-Energy).

[10] Valerie Chen, Valerio Pastro, and Mariana Raykova. 2018. Secure Computation
for Machine Learning With SPDZ. In Annual Conference on Neural Information
Processing Systems (NeurIPS).

[11] CoinDesk. 2021. https://www.coindesk.com/price/ethereum. (2021).
[12] Ronald Cramer, Ivan Damgård, and Jesper B Nielsen. 2001. Multiparty computation
from threshold homomorphic encryption. In Intl. conference on the theory and
applications of cryptographic techniques.

[13] Ronald Cramer, Ivan Bjerre Damgård, and Jesper Buus Nielsen. 2015. Secure Mul-
tiparty Computation and Secret Sharing. Cambridge University Press. Cambridge
Books Online.

[14] Ivan Damgård, Marcel Keller, Enrique Larraia, Valerio Pastro, Peter Scholl, and
Nigel P. Smart. 2013. Practical Covertly Secure MPC for Dishonest Majority -
or: Breaking the SPDZ Limits. In European Symposium on Research in Computer
Security (ESORICS).

[15] Wenliang Du and Mikhail J Atallah. 2001. Secure multi-party computation prob-
lems and their applications: a review and open problems. In the Workshop on New
Security Paradigms.

[16] Cynthia Dwork, Frank McSherry, Kobbi Nissim, and Adam Smith. 2006. Cali-
brating noise to sensitivity in private data analysis. In Theory of cryptography
conference. Springer.

[17] Neda Edalat, Mehul Motani, Jean Walrand, and Longbo Huang. 2014. Control of
systems that store renewable energy. In ACM Intl. Conf. on Future Energy Systems
(e-Energy).

[18] Pacific Gas and Electric Company. 2018. Understanding the Virtual Net Energy

Metering Program A guide for statements and bills. (2018).

[19] J. Heeter R. Gelman and L. Bird. 2014. Status of Net Metering: Assessing the Potential

to Reach Program Caps. Technical Report.

[20] Oded Goldreich. 1998. Secure multi-party computation. Manuscript. Preliminary

version 78 (1998).

[21] Christian Gorenflo, Lukasz Golab, and Srinivasan Keshav. 2019. Using a Blockchain
to Mitigate Trust in Electric Vehicle Charging. In ACM Intl. Conf. on Future Energy
Systems (e-Energy).

[22] Mohammad H. Hajiesmaili, Minghua Chen, Enrique Mallada, and Chi-Kin Chau.
2017. Crowd-Sourced Storage-Assisted Demand Response in Microgrids. In ACM
Intl. Conf. on Future Energy Systems (e-Energy).

[23] Carmit Hazay and Yehuda Lindell. 2010. Efficient Secure Two-Party Protocols -

Techniques and Constructions. Springer.

[24] Zhichuan Huang, Ting Zhu, Yu Gu, and Yanhua Li. 2016. Shepherd: sharing
energy for privacy preserving in hybrid AC-DC microgrids. In ACM Intl. Conf. on
Future Energy Systems (e-Energy).

[25] Fabian Knirsch, Clemens Brunner, Andreas Unterweger, and Dominik Engel. 2020.
Decentralized and permission-less green energy certificates with GECKO. Energy
Informatics 3, 2 (2020).

[26] Fabian Laforet, Erik Buchmann, and Klemens Bohm. 2016. Towards provable
privacy guarantees using rechargeable energy-storage devices. In ACM Intl. Conf.
on Future Energy Systems (e-Energy).

[27] Solidity Programming Language. 2020. https://docs.soliditylang.org. (2020).
[28] Stephen Lee, Prashant Shenoy, Krithi Ramamritham, and David Irwin. 2018. vSolar:
Virtualizing Community Solar and Storage for Energy Sharing. In ACM Intl. Conf.

on Future Energy Systems (e-Energy).

[29] Jingkun Liu, Ning Zhang, Chongqing Kang, Daniel Kirschen, and Qing Xia. 2017.
Cloud energy storage for residential and small commercial consumers: A business
case study. Applied Energy 188 (2017), 226–236.

[30] Lingjuan Lyu, Sid Chi-Kin Chau, Nan Wang, and Yifeng Zheng. 2020. Cloud-based
Privacy-Preserving Collaborative Consumption for Sharing Economy. IEEE Trans.
Cloud Computing (2020).

[31] Esther Mengelkamp, Johannes Garttner, Kerstin Rock, Scott Kessler, Lawrence
Orsini, and Christof Weinhardt. 2018. Designing microgrid energy markets: A
case study: The Brooklyn Microgrid. Applied Energy 210 (2018), 870–880.
[32] Aditya Mishra, David Irwin, Prashant Shenoy, Jim Kurose, and Ting Zhu. 2012.
SmartCharge: cutting the electricity bill in smart homes with energy storage. In
ACM Intl. Conf. on Future Energy Systems (e-Energy).

[33] Monero. 2021. http://getmonero.org. (2021).
[34] The Ethereum Yellow Paper. 2014. https://ethereum.github.io/yellowpaper/paper.

pdf. (2014).

[35] Quantiki. 2020. https://quantiki.org/wiki/coin-tossing. (2020).
[36] Damian Shaw-Williams and Connie Susilawati. 2020. A techno-economic evalua-
tion of Virtual Net Metering for the Australian community housing sector. Applied
Energy 261 (2020).

[37] Elaine Shi, HTH Chan, Eleanor Rieffel, Richard Chow, and Dawn Song. 2011.
Privacy-preserving aggregation of time-series data. In Annual Network & Dis-
tributed System Security Symposium (NDSS).

[38] ETH Gas Station. 2020. https://ethgasstation.info. (2020).
[39] Truffle Suite. 2020. https://www.trufflesuite.com. (2020).
[40] Nan Wang, Sid Chi-Kin Chau, and Yue Zhou. 2021. Privacy-Preserving Energy

Storage Sharing with Blockchain. In Proc. of ACM e-Energy.

APPENDIX
A PROOFS

Theorem 1. If (cid:0)𝑥 − (𝑡), 𝑦 (𝑡)(cid:1)𝑇

then (cid:0)(𝑥 −
𝑎𝑖 (𝑡 )
𝑎 (𝑡 )

𝑖 (𝑡), 𝑦𝑖 (𝑡))𝑁
𝑖=1

𝑖 (𝑡) =
· 𝑦 (𝑡), is an optimal solution of (P1).

(cid:1)𝑇
𝑡 =1, where 𝑥 −

𝑡 =1 is an optimal solution of (P2),
· 𝑥 − (𝑡) and 𝑦𝑖 (𝑡) =

𝑎𝑖 (𝑡 )
𝑎 (𝑡 )

Proof. Since (cid:0)𝑥 − (𝑡), 𝑦 (𝑡)(cid:1)𝑇

𝑡 =1 is an optimal solution of (P2), it

satisfies the condition 𝑥 − (𝑡) + 𝑦 (𝑡) = 𝑎(𝑡).

𝑎𝑖 (𝑡 )
𝑎 (𝑡 )

𝑎𝑖 (𝑡 )
𝑎 (𝑡 )

We let 𝑥 −
𝑖 (𝑡), 𝑦𝑖 (𝑡)(cid:1)𝑇
(cid:0)𝑥 −
and 𝑡 ∈ {1, ...,𝑇 }, and hence, is a feasible solution of (P1).

· 𝑥 − (𝑡) and 𝑦𝑖 (𝑡) =
· 𝑦 (𝑡), then
𝑖 (𝑡) + 𝑦𝑖 (𝑡) = 𝑎𝑖 (𝑡) for all 𝑖 ∈ {1, ..., 𝑁 }

𝑖 (𝑡) =
𝑡 =1 satisfies 𝑥 −

𝑖 (𝑡), 𝑦 ′

𝑖 (𝑡))𝑁
𝑖=1

Next, we argue that (cid:0)(𝑥 −

(cid:1)𝑇
𝑖 (𝑡), 𝑦𝑖 (𝑡))𝑁
𝑡 =1 is an optimal solution
𝑖=1
of (P1) by contradiction. Suppose that there exists a better solu-
(cid:1)𝑇
tion (cid:0)(𝑥 ′−
𝑡 =1 with a lower total cost in (P2). Then
(cid:0)𝑥 − (𝑡), 𝑦 (𝑡)(cid:1)𝑇
𝑡 =1 is not an optimal solution, because we can find an-
𝑖 (𝑡)(cid:1)𝑇
other better solution by considering (cid:0) (cid:205)𝑁
𝑡 =1
instead, which is also a feasible solution of (P2). This will violate
the optimality of (cid:0)𝑥 − (𝑡), 𝑦 (𝑡)(cid:1).
□

𝑖 (𝑡), (cid:205)𝑁

𝑖=1 𝑥 ′−

𝑖=1 𝑦 ′

Theorem 2. If (cid:0)𝑥 + (𝑡), 𝑥 − (𝑡)(cid:1)𝑇
𝑎𝑖 (𝑡 )
𝑎 (𝑡 ) ·𝑥 − (𝑡) and 𝑦𝑖 (𝑡) =

and let 𝑥 −
and egalitarian cost-sharing schemes are individually rational.

𝑡 =1 is an optimal solution of (P2)
𝑎𝑖 (𝑡 )
𝑎 (𝑡 ) ·𝑦 (𝑡), then proportional

𝑖 (𝑡) =

Let ˆp(𝑡) ≜ 𝑥 − (𝑡 ) ·𝑝 (𝑡 )

and Costorg ≜ (cid:205)𝑇
𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡). The pro-
portional and egalitarian cost-sharing payments are given as follows:

𝑎 (𝑡 )

(cid:40)𝑃 pp
𝑖 = Costess
Costorg
= (cid:205)𝑇
𝑃 ega
𝑖

𝑡 =1 𝑎𝑖 (𝑡) · ˆp(𝑡),
𝑡 =1 𝑎𝑖 (𝑡) · ˆp(𝑡) − Costorg−Costess

· (cid:205)𝑇

𝑁

(23)

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

Proof. For proportional cost sharing, 𝑈𝑖 ’s saving will be

Δpp

𝑖 =

𝑇
∑︁

𝑡 =1

𝑥 −
𝑖 (𝑡) · 𝑝 (𝑡) −

𝑇
∑︁

𝑡 =1

(cid:0)𝑝 (𝑡) + ps

(cid:1) · 𝑥 + (𝑡) ·

(cid:205)𝑇

(cid:205)𝑇

𝑡 =1 𝑥 −
𝑖 (𝑡) · 𝑝 (𝑡)
𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡)
(24)

𝑇
∑︁

(cid:16)

=

𝑡 =1

𝑥 − (𝑡) · 𝑝 (𝑡) −

𝑇
∑︁

𝑡 =1

(cid:0)𝑝 (𝑡) + ps

(cid:1) · 𝑥 + (𝑡)

(cid:17)

·

(cid:205)𝑇

(cid:205)𝑇

𝑡 =1 𝑥 −
𝑖 (𝑡) · 𝑝 (𝑡)
𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡)
(25)

(cid:0)𝑝 (𝑡) + ps

𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡) ≥ (cid:205)𝑇
(cid:0)𝑝 (𝑡) + ps
𝑡 =1
𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡) < (cid:205)𝑇
𝑡 =1

Next, we show (cid:205)𝑇
(cid:1) · 𝑥 + (𝑡) by
contradiction. Suppose (cid:205)𝑇
(cid:1) · 𝑥 + (𝑡),
then (cid:0)𝑥 + (𝑡), 𝑥 − (𝑡)(cid:1)𝑇
𝑡 =1 is not an optimal solution of (P2) because
one can always find a better solution by not charging energy stor-
age according to 𝑥 + (𝑡). Instead, drawing energy at the time it is
needed will only cost (cid:205)𝑇
𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡), which is cheaper than the
cost of charging and subsequently discharging from energy storage
((cid:205)𝑇
(cid:1) ·𝑥 + (𝑡)). Hence, we conclude that (cid:205)𝑇
𝑡 =1 𝑥 − (𝑡)·𝑝 (𝑡) ≥
(cid:205)𝑇
(cid:1) · 𝑥 + (𝑡) and Δpp
𝑖 ≥ 0.

(cid:0)𝑝 (𝑡)+ps
(cid:0)𝑝 (𝑡) + ps

𝑡 =1
𝑡 =1
For egalitarian cost sharing, 𝑈𝑖 ’s saving will be
𝑡 =1 𝑥 − (𝑡) · 𝑝 (𝑡) − (cid:205)𝑇
(cid:205)𝑇
𝑡 =1
𝑁

(cid:0)𝑝 (𝑡) + ps

(cid:1) · 𝑥 + (𝑡)

Δega
𝑖

(26)

=

Following a similar approach by contradiction, we can similarly
□

show that Δega

≥ 0.

𝑖

Theorem 3. Consider a multi-transaction mtx = (ad𝑖, adess,
𝑖=1, where val𝑖 may be negative. Namely, every ad𝑖 pays to the
𝑖=1 val𝑖 > 0, mtx can be handled

val𝑖 )𝑁
energy storage operator adess. If (cid:205)𝑁
on a blockchain by the following transaction operations:

Bal(ad𝑖 ) ←Bal(ad𝑖 ) − val𝑖, for all 𝑖

Bal(adess) ←Bal(adess) +

𝑁
∑︁

𝑖=1

val𝑖

(27)

(28)

Proof. It is straightforward to see that Eqn. (27) applies to the
case when val𝑖 is negative. As long as (cid:205)𝑁
𝑖=1 val𝑖 > 0, there is no
net out-going payment from adess. Therefore, mtx can be handled
□
properly.

B ZERO-KNOWLEDGE PROOFS OF KNOWLEDGE
B.1 Zero-knowledge Proof of Commitment (zkpCm)
Given Cm(𝑥, r), a prover wants to convince a verifier of the knowl-
edge of (𝑥, r). We can apply Σ-protocol as follows:
(1) The prover randomly generates (𝑥 ′, r′) ∈ Z2

𝑝 and sends the

commitment Cm(𝑥 ′, r′) to the verifier.

(2) The verifier sends a random challenge 𝛽 ∈ Z𝑝 to the prover.
(3) The prover replies with 𝑧𝑥 = 𝑥 ′ + 𝛽 · 𝑥 and 𝑧r = r′ + 𝛽 · r.
(4) The verifier checks whether 𝑔𝑧𝑥 · ℎ𝑧r

?
= Cm(𝑥 ′, r′) · Cm(𝑥, r)𝛽 .
Denote a zero-knowledge proof of commitment for Cm(𝑥, r) by
zkpCm[𝑥].

B.2 Zero-knowledge Proof of Summation
Given commitments (cid:0)Cm(𝑥1, r1), ..., Cm(𝑥𝑛, r𝑛)(cid:1) and 𝑦, a prover wants
to convince a verifier of the knowledge of 𝑦 = (cid:205)𝑛
𝑖=1 𝑥𝑖 without re-
vealing (𝑥1, ..., 𝑥𝑛). We can apply Σ-protocol as follows:

(1) The prover randomly generates r′ ∈ Z𝑝 and sends the com-

mitment Cm(0, r′) to the verifier.

(2) The verifier sends a random challenge 𝛽 ∈ Z𝑝 to the prover.
(3) The prover replies with 𝑧r = r′ + 𝛽 · (cid:205)𝑛
(4) The verifier checks whether 𝑔𝛽𝑦 ·ℎ𝑧r

𝑖=1 r𝑖 .
?
= Cm(0, r′)·(cid:206)𝑛

Denote a zero-knowledge proof of summation for (cid:0)Cm(𝑥𝑖, r𝑖 )(cid:1)𝑛
zkpSum[𝑦, (𝑥𝑖 )𝑛

𝑖=1].

𝑖=1 Cm(𝑥𝑖, r𝑖 )𝛽
𝑖=1 by

B.3 Zero-knowledge Proof of Membership
Given a set X = {𝑥1, ..., 𝑥𝑛 } and Cm(𝑥, r), a prover wants to convince
a verifier of the knowledge of 𝑥 ∈ X without revealing 𝑥. We can
apply Σ-protocol as follows:

𝑗 , r′

𝑗 , r′

(1) Suppose 𝑥 = 𝑥𝑖 ∈ X. The prover first randomly generates
𝑗 ) ∈ Z𝑝 and computes the commitment Cm(𝑥 ′
(𝑥 ′
𝑗 ) for all
𝑗 ∈ {1, ..., 𝑛}. Then, the prover randomly generates 𝛽 𝑗 ∈ Z𝑝
for each 𝑗 ∈ {1, ..., 𝑛}\{𝑖}, and computes
(cid:40)𝑥 ′
𝑗 + (𝑥𝑖 − 𝑥 𝑗 )𝛽 𝑗 ,
𝑥 ′
𝑖 ,
Next, the prover sends (Cm(𝑥 ′

if 𝑗 ∈ {1, ..., 𝑛}\{𝑖}
if 𝑗 = 𝑖
𝑗 ), 𝑧𝑥 𝑗 )𝑛
𝑗 , r′

𝑗=1 to the verifier.

(2) The verifier sends a random challenge 𝛽 ∈ Z𝑝 to the prover.
(3) The prover sets 𝛽𝑖 = 𝛽 − (cid:205)𝑗≠𝑖 𝛽 𝑗 , then computes 𝑧r𝑗 = r′
𝑗 + r ·
𝑗=1 to the verifier.

𝛽 𝑗 for all 𝑗 ∈ {1, ..., 𝑛}, and sends (𝛽 𝑗 , 𝑧r𝑗 )𝑛

𝑧𝑥 𝑗 =

(4) The verifier checks whether 𝛽

𝑔𝑧𝑥 𝑗 · ℎ𝑧r𝑗

?
= Cm(𝑥 ′

𝑗 , r′

𝑗 ) ·

(cid:16) Cm(𝑥, r)
𝑔𝑥 𝑗

𝑖=1 𝛽 𝑗 and

?
= (cid:205)𝑛
(cid:17) 𝛽 𝑗

for all 𝑗 ∈ {1, ..., 𝑛}

Denote a zero-knowledge proof of membership for 𝑥 ∈ X by
zkpMbs[𝑥, X].

B.4 Zero-knowledge Proof of Non-Negativity
Given Cm(𝑥, r), a prover wants to convince a verifier of the knowl-
edge of 𝑥 ≥ 0 without revealing 𝑥. Suppose 𝑥 < 2𝑚. We aim to
prove there exist (𝑏1, ..., 𝑏𝑚) such that 𝑏𝑖 ∈ {0, 1} for 𝑖 ∈ {0, ..., 𝑚}
and (cid:205)𝑚
𝑖=1 𝑏𝑖 · 2𝑖−1 = 𝑥. We can apply Σ-protocol as follows:

(1) The prover sends (Cm(𝑏𝑖, r𝑖 ))𝑚

𝑖=1 to the verifier, and provides
zkpMbs[𝑏𝑖, {0, 1}] for each 𝑏𝑖 to prove that 𝑏𝑖 ∈ {0, 1}. Also,
the prover randomly generates r′ ∈ Z𝑝 and sends the com-
mitment Cm(0, r′) to the verifier.

(2) The verifier sends a random challenge 𝛽 ∈ Z𝑝 to the prover.
(3) The prover replies with 𝑧r = r′ + 𝛽 · ((cid:205)𝑚
(4) The verifier checks whether ℎ𝑧r

𝑖=1 r𝑖 · 2𝑖−1 − r).
?
= Cm(0, r′) · Cm(𝑥, r)−𝛽 ·

(cid:206)𝑚

𝑖=1 Cm(𝑏𝑖, r𝑖 )𝛽 ·2𝑖−1 .

Denote a zero-knowledge proof of 𝑥 ≥ 0 by zkpNN[𝑥].

B.5 Security Proof
It is straightforward to prove the completeness of these protocols.
We will provide detailed proofs on their soundness and honest-
verifier zero-knowledge properties below.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

B.5.1

Soundness Proof. Proving soundness is equivalent to show-
ing that there exists a knowledge extractor who makes the prover
successfully answer two random given challenges 𝛽1 and 𝛽2:

• (zkpCm) For 𝑥, we have (𝑧 ′

𝑥 = 𝑥 ′ + 𝛽1 · 𝑥, 𝑧 ′′

𝑥 = 𝑥 ′ + 𝛽2 · 𝑥).
𝑟 = 𝑟 ′ + 𝛽2 · 𝑟 ). Then we
𝑟 = 𝑟 ′ + 𝛽1 · 𝑟 , 𝑧 ′′
For 𝑟 , we have (𝑧 ′
𝑧 ′
𝑟 − 𝑧 ′′
𝑧 ′
𝑥 − 𝑧 ′′
𝑟
𝑥
obtain 𝑥 =
. Finally, we can check
𝛽1 − 𝛽2
𝛽1 − 𝛽2
that 𝑔𝑥ℎ𝑟 = Cm(𝑥, 𝑟 ).

and 𝑟 =

. Finally, we can check for each 𝑗 that

𝑖=1 𝑟𝑖 and 𝑧2 = 𝑟 ′ + 𝛽2 · (cid:205)𝑁

𝑖=1 𝑟𝑖 .
. Finally, we can check that

𝑖=1 𝑥𝑖 .

𝑟 𝑗 = 𝑟 ′ + 𝛽2 · 𝑟 . Then

𝑔𝑦ℎ(cid:205)𝑁

Then we have (cid:205)𝑁

• (zkpSum) Let 𝑧1 = 𝑟 ′ + 𝛽1 · (cid:205)𝑁
𝑧1 − 𝑧2
𝛽1 − 𝛽2

𝑖=1 𝑟𝑖 =
𝑖=1 Cm(𝑥𝑖, r𝑖 ) to prove that 𝑦 = (cid:205)𝑁
𝑖=1 𝑟𝑖 = (cid:206)𝑛
• (zkpMbs) Let 𝑧 ′
𝑗 + 𝛽1 · 𝑟 and 𝑧 ′′
𝑟 𝑗 = 𝑟 ′
𝑟 𝑗 − 𝑧 ′′
𝑧 ′
𝑟 𝑗
𝛽1 − 𝛽2

we have 𝑟 =

𝑔𝑧𝑥 𝑗 ℎ𝑟 =

to prove that 𝑥 ∈ X.

𝑟 = 𝑟 ′ + 𝛽1 · ((cid:205)𝑚

Cm(𝑥, r)
𝑔𝑥 𝑗
• (zkpNN) Let 𝑧 ′
𝑖=1 r𝑖 · 2𝑖−1 − r). Then we have ((cid:205)𝑚
𝑟 ′ + 𝛽2 · ((cid:205)𝑚
𝑟 𝑗 − 𝑧 ′′
𝑧 ′
𝑟 𝑗
. Finally, we can check that ℎ(cid:205)𝑚
𝛽1 − 𝛽2
𝑖=1 Cm(𝑏𝑖, r𝑖 )2𝑖−1

r) =

(cid:206)𝑚
2𝑖−1 ≥ 0.

𝑖=1 r𝑖 · 2𝑖−1 − r) and 𝑧 ′′

𝑟 =
𝑖=1 r𝑖 · 2𝑖−1 −
𝑖=1 r𝑖 ·2𝑖−1−r =

· Cm(𝑥, r)−1 to prove that 𝑥 = (cid:205)𝑁

𝑖=1 𝑏𝑖 ·

B.5.2 Honest-verifier Zero-knowledge Proof. It suffices to show
that there exists a simulator who can produce another set of zero-
knowledge proofs that are computationally indistinguishable from
a given set of zero-knowledge proofs:

• (zkpCm) Cm(𝑥 ′, 𝑟 ′) = 𝑔𝑧𝑥 · ℎ𝑧𝑟 · Cm(𝑥, 𝑟 )−𝛽 .
• (zkpSum) Cm(0, r′) = 𝑔𝛽𝑦 · ℎ𝑧r · (cid:206)𝑁
· ℎ𝑧r𝑗
𝑗 , r′
• (zkpMbs) Cm(𝑥 ′

𝑗 ) = 𝑔𝑧𝑥 𝑗

𝑖=1 Cm(𝑥𝑖, r𝑖 )−𝛽 .
(cid:17)−𝛽 𝑗
(cid:16) Cm(𝑥,r)
·
𝑔𝑥 𝑗

for all 𝑗 ∈

{1, ..., 𝑛}.

• (zkpNN) Cm(0, r′) = ℎ𝑧r · Cm(𝑥, r)𝛽 · (cid:206)𝑚

𝑖=1 Cm(𝑏𝑖, r𝑖 )−𝛽 ·2𝑖−1 .

C SPDZ PROTOCOL
In the following, we present a simplified version of SPDZ for the
clarity of exposition. The full version can be found in [13, 14].

There are three phases in SPDZ protocol: (1) pre-processing phase,
(2) online phase, and (3) output and validation phase. We write ⟨𝑥⟩ as
a secretly shared number, meaning that there is a vector (𝑥1, ..., 𝑥𝑛),
such that each party 𝑖 knows only 𝑥𝑖 . To reveal secretly shared
number ⟨𝑥⟩, each party 𝑖 broadcasts 𝑥𝑖 to other parties. Then each
party can reconstruct 𝑥 = (cid:205)𝑛
𝑖=1 𝑥𝑖 . We write ⟨⟨𝑥⟩⟩ meaning that both
⟨𝑥⟩ and the respective MAC ⟨𝛾 (𝑥)⟩ are secretly shared.

C.1 Online Phase
In the online phase, the parties can jointly compute an arithmetic
circuit, consisting of additions and multiplications with secretly
shared input numbers.

C.1.1 Addition.
Given secretly shared ⟨𝑥⟩ and ⟨𝑦⟩, and a public known constant
𝑐, the following operations can be attained by local computation

at each party, and then the outcome can be assembled from the
individual shares:

A1) ⟨𝑥⟩ + ⟨𝑦⟩ can be computed by (𝑥1 + 𝑦1, ..., 𝑥𝑛 + 𝑦𝑛).
A2) 𝑐 · ⟨𝑥⟩ can be computed by (𝑐 · 𝑥1, ..., 𝑐 · 𝑥𝑛).
A3) 𝑐 + ⟨𝑥⟩ can be computed by (𝑐 + 𝑥1, 𝑥2, ..., 𝑥𝑛).

C.1.2 Multiplication.
Given secretly shared ⟨𝑥⟩ and ⟨𝑦⟩, computing the product ⟨𝑥⟩ ·
⟨𝑦⟩ involves a given multiplication triple. A multiplication triple
is defined by (⟨𝑎⟩, ⟨𝑏⟩, ⟨𝑐⟩), where 𝑎, 𝑏 are some unknown random
numbers and 𝑐 = 𝑎 · 𝑏, are three secretly shared numbers already
distributed among the parties. The triple is assumed to be prepared
in a pre-processing phase. To compute ⟨𝑥⟩ · ⟨𝑦⟩, it follows the below
steps of operations (A4):

A4.1) Compute ⟨𝜖⟩ = ⟨𝑥⟩ − ⟨𝑎⟩ (by A1). Then, reveal ⟨𝜖⟩, which

does not reveal 𝑥.

A4.2) Compute ⟨𝛿⟩ = ⟨𝑦⟩ − ⟨𝑏⟩. Then, reveal ⟨𝛿⟩.
A4.3) Finally, compute ⟨𝑥⟩ · ⟨𝑦⟩ = ⟨𝑐⟩ + 𝜖 · ⟨𝑏⟩ + 𝛿 · ⟨𝑎⟩ + 𝜖 · 𝛿 (by

A1-A3).

𝑖=1 (cid:101)

𝛼𝑥 = (cid:205)𝑛

𝛼𝑖 and 𝛾 (𝑥) = (cid:101)

𝛼𝑖 , where 𝑥 = (cid:205)𝑛
(cid:101)

C.1.3 Message Authentication Code.
To safeguard against dishonest parties, who may perform incor-
rect computation, an information-theoretical message authentica-
tion code (MAC) can be used for verification. We write a MAC key
𝛼, which is unknown to the parties, and is se-
as a global number
(cid:101)
𝛼⟩. Every secretly shared number is encoded by
cretly shared as ⟨(cid:101)
a MAC as 𝛾 (𝑥) = (cid:101)
𝛼𝑥, which is secretly shared as ⟨𝛾 (𝑥)⟩. For each
𝑖=1 𝑥𝑖 ,
⟨𝑥⟩, each party 𝑖 holds a tuple (𝑥𝑖, 𝛾 (𝑥)𝑖 ) and
𝛼 = (cid:205)𝑛
𝑖=1 𝛾 (𝑥)𝑖 . If any party tries to mod-
(cid:101)
ify her share 𝑥𝑖 uncoordinatedly, then he also needs to modify 𝛾 (𝑥)𝑖
accordingly. Otherwise, 𝛾 (𝑥) will be inconsistent. However, it is
difficult to modify 𝛾 (𝑥)𝑖 without coordination among the parties,
such that
𝑖=1 𝛾 (𝑥)𝑖 . Hence, it is possible to detect incorrect
computation (possibly by dishonest parties) by checking the MAC.
To check the consistency of 𝑥, there is no need to reveal ⟨(cid:101)
𝛼⟩.
𝛼𝑖 − 𝑥 · 𝛾 (𝑥)𝑖 from
One only needs to reveal ⟨𝑥⟩, and then reveals
(cid:101)
?
each party 𝑖. One can check whether (cid:205)𝑛
= 0 for
𝑖=1 ((cid:101)
consistency. To prevent a dishonest party from modifying her share
𝑥𝑖 after learning other party’s 𝑥 𝑗 . Each party needs to commit her
share 𝑥𝑖 before revealing 𝑥𝑖 to others.

𝛼𝑖 − 𝑥 · 𝛾 (𝑥)𝑖 )

𝛼𝑥 = (cid:205)𝑛
(cid:101)

To maintain the consistency of MAC for operations A1-A4, the

MAC needs to be updated accordingly as follows:

B1) ⟨𝑥⟩ + ⟨𝑦⟩: Update MAC by (𝛾 (𝑥)1 + 𝛾 (𝑦)1, ..., 𝛾 (𝑥)𝑛 + 𝛾 (𝑦)𝑛).
B2) 𝑐 · ⟨𝑥⟩: Update MAC by (𝑐 · 𝛾 (𝑥)1, ..., 𝑐 · 𝛾 (𝑥)𝑛).
B3) 𝑐 + ⟨𝑥⟩: Update MAC by (𝑐 · 𝛼1 + 𝛾 (𝑥)1, ..., 𝑐 · 𝛼𝑛 + 𝛾 (𝑥)𝑛).
B4) ⟨𝑥⟩ · ⟨𝑦⟩: Update MAC at each individual step of A4.1-A4.3

accordingly by B1-B3.

The additions and multiplications of ⟨⟨𝑥⟩⟩ and ⟨⟨𝑦⟩⟩ follow A1-A4 and
the MACs will be updated accordingly by B1-B4.

To verify the computation of a function, it only requires to check
the MACs of the revealed values and the final outcome, which can
be checked all efficiently together in a batch at the final stage by a
technique of called “random linear combination”.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

C.2 Pre-processing Phase
In the pre-processing phase, all parties need to prepare a collection
of triplets (⟨𝑎⟩, ⟨𝑏⟩, ⟨𝑐⟩) where 𝑐 = 𝑎 · 𝑏, each for a required multipli-
cation operation. Assume that the parties hold secretly shared num-
𝑖=1 𝑎𝑖 and 𝑏 = (cid:205)𝑁
bers 𝑎 = (cid:205)𝑁
𝑖=1 𝑏𝑖 (which has been generated by local
random generation). Note that 𝑎 ·𝑏 = (cid:205)𝑁
𝑖=1 𝑎𝑖𝑏𝑖 + (cid:205)𝑁
𝑎𝑖𝑏 𝑗 .
𝑖=1
𝑎𝑖𝑏𝑖 can be computed locally. To distribute 𝑎𝑖𝑏 𝑗 , one can use par-
tial homomorphic cryptosystems, with encryption function Enc[·]
and decryption function Dec[·] using party 𝑖’s public and private
(𝐾 p
𝑖 , 𝐾 p
[𝑎𝑖 ] to party 𝑗, who responds by
[ ˜𝑐 𝑗 ], where ˜𝑐 𝑗 is a random share gener-
𝐶𝑖 = 𝑏 𝑗 Enc𝐾 p
ated by party 𝑗 and is encrypted by party 𝑖’s public key 𝐾 s
𝑖 . Then
[𝐶 𝑗 ]. Hence, 𝑎𝑖𝑏 𝑗 = ˜𝑐𝑖 + ˜𝑐 𝑗 , which are
party 𝑖 can obtain ˜𝑐 𝑗 = Dec𝐾 s
secret shares 𝑎𝑖𝑏 𝑗 . The above generation assumes honest parties.
To prevent cheating by dishonest parties, one would need to use
proper zero-knowledge proofs before secret sharing [13, 14].

𝑖 ). First, party 𝑖 sends Enc𝐾 p
[𝑎𝑖 ] − Enc𝐾 p

𝑗=𝑖”𝑖≠𝑗

(cid:205)𝑁

𝑖

𝑖

𝑖

𝑖

To generate a random mask ⟨⟨𝑟𝑖 ⟩⟩, each party 𝑗 needs to generate
a random share 𝑟𝑖
𝑗 locally. Then the parties follow the similar proce-
dure of triplet generation to compute the secretly shared product
𝛼𝑟𝑖 .
⟨𝛾 (𝑟𝑖 )⟩, where 𝛾 (𝑟𝑖 ) = (cid:101)

C.3 Output and Validation Phase
We describe random linear combination for batch checking. To check
the MACs of a number of secretly shared numbers ⟨⟨𝑥 1⟩⟩, ..., ⟨⟨𝑥𝑚⟩⟩
in a batch, first generate a set of random (r1, ..., r𝑚). then reveal
⟨⟨𝑥 1⟩⟩, ..., ⟨⟨𝑥𝑚⟩⟩. Each party 𝑖 computes (cid:205)𝑚
𝛼𝑖 −𝑥 𝑗 ·𝛾 (𝑥 𝑗 )𝑖 ) and
?
reveals it. All parties check whether (cid:205)𝑁
𝛼𝑖 −𝑥 𝑗 ·𝛾 (𝑥 𝑗 )𝑖 )
=
𝑖=1
0 for consistency in a batch checking.

𝑗=1 r𝑗 ((cid:101)
(cid:205)𝑚
𝑗=1 r𝑗 ((cid:101)

C.4 Protocol
We summarize the SPDZ protocol as follows:

(1) Pre-processing Phase: In this phase, a collection of shared
random numbers will be constructed that can be used to mask
the private input numbers. For each private input number of
party 𝑖, there is a shared random number ⟨⟨𝑟𝑖 ⟩⟩, where 𝑟𝑖 is
revealed to party 𝑖 only, but not to other parties. All parties
also prepare a collection of triplets (⟨⟨𝑎⟩⟩, ⟨⟨𝑏⟩⟩, ⟨⟨𝑐⟩⟩) where
𝑐 = 𝑎 · 𝑏, each for a required multiplication operation.
(2) Online Phase: To secretly shares a private input number 𝑥𝑖
using ⟨⟨𝑟𝑖 ⟩⟩, without revealing 𝑥𝑖 , it proceeds as follows:
1) Party 𝑖 computes and reveals 𝑧𝑖 = 𝑥𝑖 − 𝑟𝑖 to all parties.
2) Every party sets ⟨⟨𝑥𝑖 ⟩⟩ ← 𝑧𝑖 + ⟨⟨𝑟𝑖 ⟩⟩.

To compute an arithmetic circuit, implement the required ad-
ditions or multiplications by A1-A4 and the MACs are updated
accordingly by B1-B4.

(3) Output and Validation Phase: All MACs will be checked for all
revealed numbers and the final output value. It can check all
in a batch using random linear combination. If there is any
inconsistency in the MACs, then abort.

Note that SPDZ cannot guarantee abort with fairness – dishonest
parties may learn some partial values, even when the protocol aborts.

However, this is a fundamental problem for any multi-party compu-
tation protocol with a majority of dishonest users, where dishonest
parties are not identifiable when the computation is aborted.

D SECURITY ANALYSIS
We adopt the most common approach of security analysis in cryp-
tography, based on the Ideal/Real-Model Simulation paradigm to
prove and formalize the security achieved by our protocols. We next
briefly describe the simulation paradigm. The detailed explanation
can be found in the tutorial [? ].

In the ideal model, all the parties send their private inputs to a
trusted third party, who performs the prescribed computations and
outputs the results to each party. The security requirements are
already satisfied in the ideal model. The real model represents the
realistic view of the privacy-preserving protocol. The security is
defined by comparing what an adversary can learn in the real model
to that in the ideal model. If what can be learned by an adversary
in the real world can be totally simulated in the ideal world, then
the adversary cannot learn more information in the real world than
in the ideal world, we can say that a protocol Π is as secure as its
corresponding ideal functionality F . We give a formal definition of
the security of our protocol as below:

Theorem 4. Assuming the discrete logarithm problem underlying
the Pedersen commitment scheme is hard and the non-interactive
zero-knowledge proofs are secure with access to a random oracle, in
the Fprep-hybrid model [14], the protocol Πpess securely implements
Fpess with abort in the presence of an adaptive, active adversary in a
dishonest-majority setting, if for every probabilistic polynomial-time
(PPT) adversary A in the real model, there also exists a PPT adversary
S in the ideal model, such that for each 𝑖 ∈ 𝑁 :
Fprep
Πpess,A }}

Fprep
Fpess,S

≡ {REAL

{IDEAL

comp

}

where IDEAL and REAL respectively refer to the views and outputs of
the corrupted and honest users in both ideal and real worlds.

We sketch the proof of the above theorem. Our aim is to demon-
strate a simulator in the ideal model that can create a computa-
tionally indistinguishable view from that of the adversary in the
real model. Even with a different set of honest-users’ inputs, the
adversary should still be unable to tell computationally indistin-
guishable differences between the views. The simulator S externally
interacts with the ideal functionality and internally runs a copy
of the protocol Πpess ⋄ Fprep feeding messages to the adversary
A. However, it is a not trivial task for a simulator to emulate an
adaptively malicious adversary, who is able to corrupt users at any
time during the protocol. The challenge lies in the difficulty that
it must produce a consistent view of the corrupted users through-
out the protocol without knowing their inputs. Firstly, we define
an ideal functionality F (1)
in the stage 1 Pre-operation Scheduling
a(t)
computing the total energy demands 𝑎(𝑡) before presenting the
corresponding simulator S (1)
a(t)

.

Functionality F (1)
a(t)
Input: On input (input, 𝑈𝑖 , 𝑎𝑖 (𝑡)), the functionality stores 𝑎𝑖 (𝑡).

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

Output: On input (output) from all honest users, the functionality
computes and outputs 𝑎(𝑡) = (cid:205)𝑁
Abort: On input (abort), the functionality outputs ∅.

𝑖=1 𝑎𝑖 (𝑡) to all the users.

Initialize: The simulator S first calls Fprep to generate a suffi-
cient number of multiplication triples and random numbers. Note
that S has access to all the shares of the MAC key, random num-
bers and multiplication triples as it knows the decryption keys of
public-key cryptosystem in the preprocessing phase. The adversary
A firstly corrupts a set of users, denoted by C. Then the adversary
may adaptively make corruptions on other users during the protocol.
Next, S produces 𝑔, ℎ = 𝑔𝑘 ∈ Z∗
𝑝 , where 𝑘 = log𝑔 ℎ is the trapdoor
to Pedersen commitment, with which S is able to find out two pairs
(𝑚, 𝑟 ), (𝑚′, 𝑟 ′), such that Cm(𝑚, 𝑟 ) = Cm(𝑚′, 𝑟 ′).

Simulator S (1)
a(t)

(1) For honest users 𝑖 ∉ C, S will simply generates dummy in-
puts ˆ𝑎𝑖 (𝑡) = 0, ˆ𝑟𝑖 (𝑡) ∈ 𝑍𝑝 and reveals a commitment ˆ𝐶𝑖 (𝑡) =
Cm(cid:0) ˆ𝑎𝑖 (𝑡), ˆ𝑟𝑖 (𝑡)(cid:1) with an nzkpNN[𝑎𝑖 (𝑡)]. For the corrupted users
𝑖 ∈ C, S can extract their inputs with the knowledge of all
the shares of ⟨⟨𝑟 ⟩⟩ and verifies the nzkpNN[𝑎𝑖 (𝑡)].
Remarks: From the perspective of the adversary, the inputs of
the honest users are indistinguishable from those in the real
world due to the information-theoretically hiding properties
of SPDZ secret-sharing (unless all the 𝑁 shares are collected,
the inputs cannot be reconstructed), and of the Pedersen
commitment.
(2) S firstly calls F (1)
a(t)

to obtain the output 𝑎(𝑡). As S already
computed an output ˆ𝑎(𝑡) using dummy inputs of the honest
users, it can respectively modify the share and MAC of a
random honest user by adding 𝑎(𝑡) − ˆ𝑎(𝑡) and 𝛼 (cid:0)𝑎(𝑡) − ˆ𝑎(𝑡)(cid:1)
with the MAC key 𝛼 initialized in the preprocessing phase.
Then S can perform the MAC check to evaluate and open
𝑎(𝑡). If the check passes, S calls F (1)
to output 𝑎(𝑡) to all
a(t)
the users. Otherwise, S sends Abort to F (1)
a(t)
Remarks: No matter what inputs the adversary generates for
the corrupted users, S can always create a computationally
indistinguishable output distribution in the ideal model from
that in the real model from the view of the adversary A.
For the evaluation of 𝑎(𝑡), each 𝑖-th share 𝛼𝑖𝑎(𝑡) − 𝛾𝑖 (cid:0)𝑎(𝑡)(cid:1)
appears uniformly random to the adversary, which has exactly
the same distribution in both ideal and real models.

.

After the simulator provided the simulated input (cid:0) ˆ𝑎𝑖 (𝑡), ˆ𝑟𝑖 (𝑡), ˆ𝐶𝑖 (𝑡)(cid:1)
for 𝑖 ∉ C, the adversary can corrupt an honest user 𝑈𝑖 at any time. As
aforementioned, the simulator must reveal its entire internal states,
including the inputs, shares of inputs and random values that are
consistent with the commitment ˆ𝐶𝑖 (𝑡) to simulate an adaptive ad-
versary. It is easy to obtain the input 𝑎𝑖 (𝑡) from F (1)
. Regarding the
a(t)
random value, the simulator will take advantage of the trapdoor 𝑘 of
the Pedersen commitment to obtain 𝑟𝑖 (𝑡) = ˆ𝑟𝑖 (𝑡)+(cid:0) ˆ𝑎𝑖 (𝑡)−𝑎𝑖 (𝑡)(cid:1) ·𝑘−1,
such that ˆ𝐶𝑖 (𝑡) = Cm(cid:0)𝑎𝑖 (𝑡), 𝑟𝑖 (𝑡)(cid:1) = Cm(cid:0) ˆ𝑎𝑖 (𝑡), ˆ𝑟𝑖 (𝑡)(cid:1). Moreover, 𝑈𝑖 ’s
share of her initial dummy input ˆ𝑎𝑖 (𝑡) is ˆ𝑎𝑖 (𝑡) + 𝑟𝑖 − 𝑟 . Thus, it is

trivial for the simulator to reveal the share 𝑎𝑖 (𝑡) + ˆ𝑎𝑖 (𝑡) − 𝑟 + 𝑟𝑖 by
adding 𝑎𝑖 (𝑡). (See online phase in Section C.4).

pess and nzkpSum[Costess, (𝑃𝑖 )𝑁

Next, we give a brief description of the SPDZ-based zero-knowledge
proofs zkpCm[𝑎𝑖 (𝑡)] in Π (1)
𝑖=1] in Π (2)
pess.
For zkpCm[𝑎𝑖 (𝑡)], 𝑧𝑎𝑖 (𝑡 ) and 𝑧𝑟𝑖 (𝑡 ) are collectively computed by all
users and will be evaluated via MAC check to prove their correct-
ness. A similar simulator to S (1)
can be constructed to emulate
a(t)
the ideal functionality computing 𝑧𝑎𝑖 (𝑡 ) and 𝑧𝑟𝑖 (𝑡 ) . The challenge
𝛽 (𝑡) is uniformly random independent of the prover’s input as it
is obtained by summing the random values generated by all the
users. Thus, this zero-knowledge proof is secure given the proof of
completeness, soundness, zero-knowledge properties in Section B.5.
The same security argument applies to nzkpSum[Costess, (𝑃𝑖 )𝑁
𝑖=1].
emulating ideal
𝑖 𝑃𝑖 as it

functionality computing the total payment Costess = (cid:205)𝑁
is similar to S (1)
a(t)

We skip the details for the simulator S (2)

except using a different input 𝑃𝑖 .

Costess

E ETHEREUM BLOCKCHAIN PLATFORM & SMART

CONTRACTS

In this section, we provide a brief description of Ethereum blockchain
platform and Solidity programming language as well as the details
on the implementations of the smart contracts in our protocols.

E.1 Background
Bitcoin was the first widely adopted digital currency on a permis-
sionless distributed ledger. Bitcoin relies on a tampering-resistant
ledger based on cryptographic signatures. Tampering-resistance
ensures integrality when the ledger is maintained by a network of
peer-to-peer systems called “miners”. The miners are incentivized by
cryptocurrency rewards for updating and validating the transaction
records. Since the distributed ledger can be modified by multiple
systems simultaneously, it is crucial to ensure consistency by a
distributed consensus protocol among untrusted peer-to-peer sys-
tems, based on proof-of-work (by solving computational puzzles)
or proof-of-stake (by demonstrating ownership of digital assets).

Subsequently, Ethereum was built on the Bitcoin ideas by expand-
ing its functions to support general computing as smart contracts
along with transactions. Bitcoin operates using a transaction-output-
based system, called unspent transaction outputs (UTXOs), whereas
Ethereum operates using accounts and balances in a manner called
state transitions. Smart contracts, which are code programmed in
high-level logic, will be compiled into byte code and executed in the
virtual machine of miners. Miners will charge additional crytocur-
rency payments called gas costs, because the extra computational
tasks incurred by smart contracts will be broadcast throughout
the blockchain. Smart contracts are implemented in a high-level
programming language, such as Solidity [27].

It is worth noting that Bitcoin and Ethereum were only supposed
to enable decentralization, but do not ensure privacy. In fact, the
transaction histories of many crytocurrencies are visible to the pub-
lic. There are certain high-profiled prosecution of darknet operators
based on the evidence of Bitcoin transactions. Supporting privacy
in blockchain is a crucial on-going research topic.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

E.2 Smart Contract Implementation
We next explain how Multi-Signature smart contract can achieve the
step (5) and (6) of the stage Cost-sharing Payment by the following
methods:

(1) submitTransaction(). This method allows each user to
submit the zkpSum[Costess, (𝑃𝑖 )𝑁
𝑖=1] that they have agreed
upon off the chain. The method will compare whether users
have submitted the same zkpSum.

(2) confirmTransaction(). On one hand, this method allows
each user to confirm that the stored zkpSum in the smart con-
tract is the one that they have agreed upon off the chain. On
the other, each user is required to submit a nzkpNN[Bal(ad𝑖 )−
𝑃𝑖 ]𝑁
𝑖=1, which will be validated to prove that there is sufficient
balance in his account to pay for the energy cost.

(3) executeTransaction(). This method can only be executed
by the operator unless all the users have already confirmed
the transaction. The method will validate the zkpSum before
calling ESToken smart contract to credit Costess to the op-
erator’s account and debit the corresponding payment from
each user’s account.

(4) secretlyJointTransfer(). This method, defined within

the EStoken smart contract is invoked by executeTransaction(),
which actually performs the real transfer between multiple
accounts.

ACM SIGENERGY Energy Informatics Review

Volume 1 Issue 1, November 2021

