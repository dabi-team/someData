1
2
0
2
c
e
D
1
2

]

C
D
.
s
c
[

1
v
2
7
0
1
1
.
2
1
1
2
:
v
i
X
r
a

BlockReduce - Scaling Proof-of-Work
Blockchains

Yanni Georghiades
Dept. of ECE
University of Texas Austin
Austin, TX
yanni.georghiades@utexas.edu

Karl Kreder
CEO
GridPlus Inc.
Austin, TX
karl@gridplus.io

Jonathan Downing
Chief Architect
Dominant Strategies
Austin, TX
jonathan@dominantstrategies.io

Alan Orwick
CEO
Dominant Strategies
Austin, TX
alan@dominantstrategies.io

Sriram Vishwanath
Department of ECE
University of Texas, Austin
Austin, TX
sriram@utexas.edu

Abstract—This paper introduces BlockReduce, a Proof-
of-Work (PoW) based blockchain system which achieves
high transaction throughput through a hierarchy of merged
mined blockchains, each operating in parallel on a partition
the overall application state. Most notably, the full PoW
available within the network is applied to all blockchains
in BlockReduce, and cross-blockchain state transitions are
enabled seamlessly within the core protocol. This paper
shows that, given a hierarchy of blockchains and its
associated security model, the protocol scales superlinearly
in transaction throughput with the number of blockchains
operated by the protocol.

Index Terms—blockchain, distributed systems, perfor-

mance, scalability, proof-of-work

I. INTRODUCTION

Blockchains are popular as a means to enable trustless,
decentralized, peer-to-peer value transfer. Among the
approaches to achieving distributed consensus in cryp-
tocurrencies, Proof-of-Work (PoW) is the oldest, most
established, and arguably most well-understood. How-
ever, PoW-based cryptocurrencies are currently limited
in terms of transaction throughput in comparison with
traditional payment mechanisms, such as credit card
transactions. This has resulted in increased transaction
costs as cryptocurrencies rise in popularity and a greater
shift towards alternate scaling mechanisms. In particular
Proof-of-Stake (PoS) and other Proof-of-X consensus
protocols and a proliferation of Layer 2 protocols, side-
chains, and bridges have been proposed and implemented
in order to enable lower transaction fees. All of these
approaches have alternate assumptions and trust models
in comparison with Proof-of-Work and, as a result, come
with their own associated challenges and weaknesses.

The two most notable cryptocurrencies, Bitcoin and
Ethereum, are both PoW-based1 and at the time of this
writing are capable of achieving under 20 transactions
per second [1], [2], whereas Visa alone can execute more
than 2,000 transactions per second on their credit card
network [2]. Indeed, it is now presumed (without proof)
by a majority of people that Proof-of-Work cryptocur-
rencies simply cannot meet the throughput requirements
of a global currency.

In this paper, we introduce BlockReduce, a PoW
cryptocurrency that achieves high transaction through-
put (as a Layer 1 protocol). We describe BlockReduce
by ﬁrst identifying the primary factors that cause low
transaction throughput (and therefore, large fees) in PoW
blockchains and then address and ameliorate each factor,
thus resulting in a truly scalable solution.

The primary tools underlying our solution for scala-

bility are as follows:

Latency-dependent Clustering of Network Nodes:
As noted across literature [3], network latency is one
of the biggest factors in the scalability of blockchain
systems. In our work, we translate this understanding
of network latency into a suitable hierarchical cluster-
ing, where nodes self-partition into a hierarchy of sub-
networks with which they share low-latency connections.
Each sub-network operates its own blockchain to validate
and update a partition of the overall application state.

Transaction-dependent Security: Currently, a vast
majority of blockchains (and a vast majority of PoW
blockchains) afford the same level of security—where
security refers to the amount of work required to succeed
in a double-spend attack—for all transactions, regardless
of the economic value of the transaction. However, in

S. Vishwanath is an advisor to Dominant Strategies and incubates

1at the time of writing, Ethereum has not yet attempted the transition

startups in the blockchain domain through ChainHub.

to Proof-of-Stake

 
 
 
 
 
 
most human-commerce centric interactions, low-value
transactions (and blocks incorporating them) are not
secured to the same level as high-value transactions. For
example, credit card transactions of low value often do
not require signatures, while higher value transactions go
through a more stringent signature veriﬁcation process.
Ultimately, even in the blockchain domain, we believe
that security should be transaction-value dependent, with
high-value blocks (and associated transactions) afforded
much higher security guarantees. Thus, the amount of
work applied to all transactions need not be the same
in the short-term, although we remark that eventually
all
transactions in BlockReduce are secured by the
maximum amount of work available to the system.

Merged Mining: Rather than performing PoW com-
putations on a single block header, miners simultane-
ously mine multiple blockchains using the same PoW
computations, and one PoW solution might correspond
to blocks in multiple blockchains. This has two effects
in BlockReduce. The ﬁrst is that all miners are mining
the root chain of the hierarchy, meaning the root chain
receives the maximum amount of work available in
the network. The second is that periodically blocks
(which we refer to as coincident blocks) will be found
which are shared between blockchains at different lev-
els of the hierarchy, which allows work to be shared
across the blockchains and enables cross-blockchain
state-transitions.

A. Proof-of-Work Blockchains

The goal of a PoW blockchain is to achieve consensus
on transaction sets to be committed to a public ledger
by performing work on blocks containing transaction
references. The ﬁrst published instance of Proof-of-Work
being applied to blockchains is Nakamoto’s famous
Bitcoin protocol [4], where Nakamoto combined PoW
with a block selection rule called the Longest Chain Rule
to achieve Nakamoto consensus on transactions. Bitcoin
was later proven to satisfy strong forms of consistency
and liveness in asynchronous networks with bounded
adversarial delays [5].

BlockReduce uses PoW to reach a similar form of
consensus on each blockchain in its hierarchy. In order to
accommodate for its hierarchical structure, BlockReduce
utilizes a variant of the Longest Chain Rule which we
refer to as the Hierarchical Longest Chain Rule. We
describe these aspects of the BlockReduce protocol in
more detail in Sections III-B and IV-C.

B. Proof-of-Work Efﬁciency

A signiﬁcant

limiter of transaction throughput

in
public blockchains is the amount of time it takes for
data to propagate within the peer-to-peer network after
blocks are mined. Long block propagation times limit

the efﬁciency of the Proof-of-Work algorithm, as a
node which has not yet received a new block must
either continue mining on a stale information set or
pause mining activities until the new block is received
and validated. However, an adversary mining a private
chain may not experience this propagation delay, lending
the adversary an advantage over honest miners in the
case of an attack. In order to minimize the advantage
experienced by the adversary, PoW blockchains must
have low block generation rates which consequently limit
transaction throughput.

In order to provide additional intuition about this phe-
nomenon, we deﬁne the PoW efﬁciency of a blockchain
as the fraction of PoW computations which are com-
puted on the canonical chain, i.e., the blocks which are
committed to the transaction ledger. In the ideal setting
in which all nodes follow the protocol and there are no
network delays on block propagation, the PoW efﬁciency
E = 1. If λ is the total rate of block generation by the
network, and the network delay ∆ is the time between
when a block is found and when it is received by all
nodes in the network, [6] computes the effective block
1+λ∆ , resulting in a PoW efﬁciency
generation rate to be
of E = 1
1+λ∆ .

λ

(1−β)

Furthermore, if a fraction β of nodes are adversarial
and are mining a private branch of the blockchain as part
of an attack, then the PoW efﬁciency of honest nodes,
1+(1−β)λ∆ , decreases as ∆ increases. On the other hand,
assuming the adversary experiences negligible network
delay with itself while mining a private chain (i.e.,
the adversary experiences effective network delay ∆ ≈
0), the adversary’s PoW efﬁciency is approximately 1.
Herein lies the problem. If ∆ is ﬁxed, then an adversary’s
relative advantage over honest nodes increases as the
block generation rate increases. Systems such as Bitcoin
suppress λ in order to reduce the impact of ∆ on the
PoW efﬁciency of honest nodes. This phenomenon is
discussed in various works [7], [8], and several solutions
have been presented which assume ∆ to be ﬁxed. In this
work, we partition the network in such a way that the ∆
experienced by each sub-network is lower than that of
the overall network, thereby allowing each sub-network
to operate a blockchain with a higher block generation
rate. Moreover, we achieve this while maintaining the
same PoW efﬁciency in all blockchains, which we
believe is critical to a truly scalable blockchain. We
utilize the Hierarchical Longest Chain Rule described
in IV-C to guarantee that each blockchain receives the
maximum amount of work available to the network,
thereby achieving high transaction throughput without
sacriﬁcing security or PoW efﬁciency.

C. Our Contributions

C. Layer 2 Protocols

We present BlockReduce, a PoW blockchain system
which enables high transaction throughput by utilizing
a hierarchy of merged mined blockchains operating in
parallel on non-overlapping partitions of the application
state. To the best of our knowledge, BlockReduce is the
ﬁrst protocol which promises superlinear scaling with
the number of parallel blochchains it operates while still
securing each blockchain with the maximum amount
of work available to the network. We introduce the
Hierarchical Longest Chain Rule as a block-selection
mechanism which allows each blockchain in the hierar-
chy to inherit the work of its parent and also enables
native cross-blockchain state transitions between any
state partitions in the hierarchy. Finally, we analyze
the performance of the protocol
to demonstrate the
superlinear scalability of BlockReduce.

II. RELATED WORK

There have been many proposals for scaling trans-
action throughput in blockchains. We provide a brief
summary of several types of approaches.

A. Parallel PoW Blockchains

Many protocols aim to achieve high transaction
throughput by operating several blockchains in parallel
in a manner conceptually similar to BlockReduce. The
PoW version of Parallel Chains [9] involves mining a
metablock containing candidate blocks for a number
of parallel chains which operate non-overlapping state
partitions. Notably, Parallel Chains does not support
cross-blockchain transactions and is therefore of more
limited use than BlockReduce. Chainweb [10] is another
protocol operating many parallel chains, where each
block header references the headers of other chains in or-
der to braid the chains together. Chainweb allows cross-
blockchain state transitions and also features a mecha-
nism by which chains inherit work from one another,
but can achieve only a linear increase in transaction
throughput with the number of parallel chains whereas
BlockReduce is able to achieve superlinear scaling.

There are multiple Layer 2 protocols (i.e., proto-
cols which operate independently and only periodically
interact with the blockchain) which have been devel-
oped in order to facilitate high transaction throughput.
These include Starkware, Polygon, and Lightning among
many others [13]. Although some such architectures can
achieve high transaction throughput, Layer 2 solutions
inevitably require alternate trust models from the core
blockchain protocol which may not be suited for all
use cases. BlockReduce scales as a Layer 1 protocol
and does not require an alternate trust model or any
additional assumptions to achieve scalability.

III. MODEL

In this section, we describe the network model which
we use for analysis of the BlockReduce protocol, the
merged mining technique used to mine BlockReduce,
and a transaction model in which transactions are ini-
tially secured with an amount of work commensurate to
their economic value.

A. Network Model

In this paper, we adopt a simple overlay-network
model to understand the interactions between nodes: that
of a d-regular graph on N network nodes. This model
arises from the standard set forth by Bitcoin, where the
protocol executed by each node attempts by default to
maintain a set of 8 peers, which approximates a d-regular
graph.

We assume a synchronous, round-based model for
block propagation. According to [14], with probability
1 − o(1), the number of synchronous rounds required
for data to broadcast via gossip in a random d-regular
network of N nodes is

(1 + o(1))(cid:0)

1
ln(2(1 − 1

d ))

−

1
d ln(1 − 1
d )

(cid:1) ln N.

(1)

We use this result to characterize the overall network
propagation delay ∆ (i.e., the amount of time it takes for
a single block to be propagated across the network) in
terms of the single-link propagation delay, δ, as follows.

B. Proof-of-Stake Protocols

∆ = δ(1 + o(1))(cid:0)

Many Proof-of-Stake protocols have been proposed
and implemented, such as Ouroboros Praos [11] and
Ethereum’s planned move to Proof-of-Stake, as a means
to enable high transaction throughput and low settlement
times. However, Proof-of-Stake protocols currently do
not afford the same security guarantees as PoW and
suffer from shortcomings such as the “nothing at stake”
problem and predictability on the next miner who is
eligible to mine [12].

1
ln(2(1 − 1

d ))

−

1
d ln(1 − 1
d )

(cid:1) ln N.

(2)
Adopting the shortened notation of [14], this gives us

the following bound.

∆ < δCd ln N.

(3)

Deﬁning ∆ in this way makes it clear that ∆ de-
creases as δ or N decrease. In Section IV we show
that ∆ is reduced in higher order blockchains within

the BlockReduce protocol, which allows for a higher
block generation rate while still maintaining high PoW
efﬁciency of honest nodes within those blockchains.

and 2. In this example, the hierarchy has three orders,
and networks of order 1 and 2 each have two child sub-
networks.

B. Merged Mining

Mining in BlockReduce is similar to mining in Bit-
coin or Ethereum, except that in BlockReduce, multi-
ple blocks are mined simultaneously using a technique
called merged mining [15] and the Longest Chain Rule
(LCR) used by Bitcoin is modiﬁed to accommodate the
hierarchical structure of BlockReduce.

BlockReduce miners use merged mining to simultane-
ously mine a blockchain in each level of the hierarchy—
where levels are referred to as orders—with the same
PoW computations. To accomplish this, miners con-
struct a block for each blockchain they are mining,
concatenate the block headers together, and perform
PoW computations on the resulting shared block header.
Blockchains closer to the root of the hierarchy have
higher PoW difﬁculties, and a block which meets the
difﬁculty requirement of a blockchain of order r also
meets the difﬁculty requirement of each blockchain of
order greater (i.e., further from the root) than r, as it
necessarily meets all lower difﬁculties. These blocks are
called coincident blocks because they are valid blocks
in multiple blockchains and serve to coincide those
blockchains via shared block references. In Section IV,
we show that by using the hierarchical longest chain rule,
coincident blocks impose a partial ordering on blocks
in different blockchains, which enables cross-blockchain
state transitions.

IV. A HIERARCHY OF BLOCKCHAINS

In this section, we describe the BlockReduce protocol
and show that all nodes operating a particular blockchain
are able to agree upon its state.

A. Notation

The BlockReduce protocol requires that nodes self-
partition into a hierarchy of sub-networks, where the
hierarchy is a tree consisting of R levels called orders.
Each sub-network is denoted N(cid:126)v, where (cid:126)v is the unique
path from the root to the speciﬁed node in the hierarchy
tree. The root of the hierarchy tree is of order 1 and the
leaves are of order R.

We adopt a functional notation when discussing rela-
tionships between sub-networks, blockchains, and state
partitions. We denote parent(N(cid:126)v) to be the parent sub-
network of N(cid:126)v in the hierarchy tree and order(N(cid:126)v) = |(cid:126)v|
to be the order of N(cid:126)v. We often overload this functional
notation with inputs B(cid:126)v, S(cid:126)v, or simply (cid:126)v, and each
of these usages has precisely the same meaning. An
example of a BlockReduce sub-network partitioning and
associated hierarchy structure is provided in Figures 1

Each miner must mine a blockchain of each order
corresponding to a path from root to leaf in the hierarchy
tree. For simplicity, we assume that all sub-networks
of the same order contain the same number of nodes
and that each mining node mines exactly one sub-
network per order, although in practice there may be sub-
networks with more miners than others and miners which
elect to mine more than one sub-network per order. Each
sub-network N(cid:126)v operates a blockchain B(cid:126)v to to achieve
consensus on a partition of the state, S(cid:126)v. Blockchains of
order r have block arrivals at a rate λr, block propagation
delay ∆r, and an average single-link propagation delay
δr.

B. Partitioning the Ledger State

We adopt a generic state model in which each trans-
action constitutes an update to the application state.
This could be used in the UTXO (Unspent Transaction
Output) model, where the application state is simply the
set of all UTXOs, or a more sophisticated smart contract
model, where the application state is the smart contract
state. State is partitioned between all blockchains to
prevent duplication, and each transaction must specify
an origin blockchain (cid:126)vo and a destination blockchain
(cid:126)vd. If the origin and destination of a transaction are the
same, the state transition occurs in the same way as a
traditional blockchain implementation. If the origin of a
transaction is different from its destination, for example
if an asset is being moved from the origin blockchain to
the destination blockchain, then the state update involves
removing the asset from the origin state and adding it to
the destination state. This leads to the following protocol
rule.

Protocol Rule 1. In order for a transaction with origin
(cid:126)vo to be valid, the state that it modiﬁes must be valid
with respect to S (cid:126)vo.

For example, if a user is attempting to move an asset
from (cid:126)vo to (cid:126)vd, then the transaction must have origin (cid:126)vo
and the user must demonstrate ownership of the asset in
S (cid:126)vo.

C. The Hierarchical Longest Chain Rule

BlockReduce utilizes a novel consensus rule to select
the canonical chain—i.e., the chain of blocks referencing
state updates to be applied—for each blockchain. In
Bitcoin and other more traditional systems, the Longest
Chain Rule (LCR) stipulates that the canonical chain is
the sequence of valid blocks with the most work (often
referred to as the longest chain or, more accurately, the
heaviest chain) [4]. BlockReduce follows a similar rule

Figure 1.

Illustration of topological network segregation: a) full network b) two sub-networks of order 2 c) four sub-networks of order 3.

canonical chain in BlockReduce.

Protocol Rule 3 (The Hierarchical Longest Chain Rule).
The canonical chain of the root blockchain B{1} is the
heaviest sequence of valid blocks in B{1}. The canonical
chain of any blockchain B(cid:126)v of order greater than 1
is the heaviest sequence of blocks which contains all
coincident blocks between B(cid:126)v and parent(B(cid:126)v) which are
present in the canonical chain of parent(B(cid:126)v), and no
coincident blocks between B(cid:126)v and parent(B(cid:126)v) which are
not present in the canonical chain of parent(B(cid:126)v).

In other words,

the canonical chain for the root
blockchain is selected via the standard LCR. For each
other blockchain B(cid:126)v of order greater than 1, the canon-
ical chain must include all coincident blocks that are
shared between B(cid:126)v and parent(B(cid:126)v) that are present in
the canonical chain of parent(B(cid:126)v). However, if there is
some coincident block between B(cid:126)v and parent(B(cid:126)v) that
is not in the canonical chain of parent(B(cid:126)v), then it cannot
be in the canonical chain of B(cid:126)v.

If an incoming block causes the canonical chain to
change, then the state updates dictated by blocks which
are no longer part of the canonical chain must be reverted
and the new state updates applied. This is why the
canonical chain must contain all coincident blocks that
are shared with the parent blockchain, as otherwise a
cross-blockchain state transition which has been applied
at both origin and destination could later be reverted
at the origin but not the destination, thus causing an
inconsistency in the overall network state.

D. Inter-Blockchain Ordering via Coincident Blocks

Within a single blockchain, all blocks in the canonical
chain are totally ordered according to their distance
from the genesis block. Between blockchains of different
orders, blocks are partially ordered due to the coincident
blocks which arise from merged mining.

Intuitively, coincident blocks serve as a shared points
in “time” between blockchains, and they allow nodes to

N{1}
(cid:8)
(cid:72)
(cid:72)(cid:72)(cid:72)

(cid:72)(cid:72)(cid:106)

(cid:8)(cid:8)(cid:8)

(cid:8)(cid:8)(cid:25)

N{1,1}

(cid:0)

(cid:64)

(cid:0)

(cid:0)(cid:9)

(cid:64)

(cid:64)(cid:82)

N{1,2}

(cid:0)

(cid:64)

(cid:0)

(cid:0)(cid:9)

(cid:64)

(cid:64)(cid:82)

N{1,1,1}

N{1,1,2}

N{1,2,1}

N{1,2,2}

Figure 2. Hierarchy tree with 3 orders, where each box is a sub-
network which operates a distinct blockchain.

but must also account for the existence of coincident
blocks within the hierarchy.

Before deﬁning the Hierarchical Longest Chain Rule
(HLCR), we ﬁrst deﬁne what conditions a block must
meet to be considered valid. While speciﬁc requirements
may vary between implementations, such as varying
block size, transaction and/or smart contract structure,
or block header composition, in general we can deﬁne a
valid block as follows.

Protocol Rule 2 (Valid Block). A block is considered
to be valid if it meets all protocol rules and all of its
predecessors of any order are also valid.

In other words, a valid block must conform to the rules
of the blockchain and must reference no prior blocks
of any order which deviate from those rules. Next, we
deﬁne the HLCR which miners use to determine the

agree upon which blocks came “before” the coincident
block and which blocks came “after.”

This property of coincident blocks allows all nodes in
both N(cid:126)v and parent(N(cid:126)v) to agree on the existence and
ordering of all blocks prior to the coincident block in
either blockchain. This, in turn, enables cross-blockchain
state transitions to occur, as nodes operating the desti-
nation blockchain can agree on precisely when the state
transition should be applied to the destination state.

E. Inherited Work via Coincident Blocks

Although in the short term, blocks containing trans-
actions of low economic value may be secured with a
fraction of the maximum work available to the network,
in the longer term this security level is not sufﬁcient.
If a block containing a cross-blockchain state transition
were to be removed from the canonical chain of B (cid:126)vo,
but the state transition for that transaction had already
been applied to S (cid:126)vd , then an inconsistency in the overall
network state could arise.

Intuitively, the HLCR prevents this type of inconsis-
tency by giving “inﬁnite weight” to coincident blocks in
context of the child blockchain—i.e., regardless of the
number of blocks in any number of forks in the child
blockchain, if one fork contains a coincident block in the
canonical chain of the parent blockchain, then that fork
will always be selected. Then in order for a coincident
block to be removed from the canonical chain of N(cid:126)v,
it must ﬁrst be removed from parent(N(cid:126)v). The result
is that N(cid:126)v inherits the work applied to parent(N(cid:126)v). In
other words, a modiﬁcation to the canonical chain of N(cid:126)v
can only occur if the coincident block is ﬁrst removed
from the canonical chain of parent(N(cid:126)v).

F. State Updates

In order to maintain a consistent state between nodes,
state updates to S(cid:126)v must be performed by all nodes in N(cid:126)v
in the same order. This is simple for transactions with
the same origin and destination, as the state updates can
be performed in the order that they are referenced by that
blockchain. For transactions with different origin and
destination, the state transition must be handled in two
steps. First, S (cid:126)vo is updated according to the transaction
(e.g., the removal of an asset from the origin state) as
soon as it is included in a block in the canonical chain
of B (cid:126)vo. S (cid:126)vd , however, cannot be updated immediately,
as there is initially no way for nodes operating B (cid:126)vd to
agree upon when the state transition should be applied.
Protocol Rule 4 describes the criteria which must be met
for a state transition to be applied to S (cid:126)vd , and Protocol
Rule 5 describes the order in which all state updates are
applied when a block is processed.

Protocol Rule 4. Let tx be a transaction with origin
(cid:126)vo and destination (cid:126)vd, and let (cid:126)va be the highest order

common ancestor between (cid:126)vo and (cid:126)vd. The state transi-
tion pertaining to S (cid:126)vo is applied as soon as the block
containing tx is a part of the canonical chain of B (cid:126)vo.
The state transition pertaining to S (cid:126)vd , however, is only
applied after a coincident block is found which is shared
by B (cid:126)vo and B (cid:126)va and, if order(B (cid:126)vd ) > order(B (cid:126)va ), a
subsequent coincident block is found which is shared
by B (cid:126)vd and B (cid:126)va .

This rule guarantees that a chain of block references is
established between B (cid:126)vo and B (cid:126)vd before S (cid:126)vd is updated.
Intuitively, we can think of cross-blockchain state transi-
tions as traveling “up” and “down” the hierarchy. Nodes
in N (cid:126)vd can verify that the block containing tx is in the
canonical chain of B (cid:126)vo because of the coincident block
between B (cid:126)vo and B (cid:126)va , and they can also agree upon the
existence of the coincident block between B (cid:126)vd and B (cid:126)va
and update S (cid:126)vd while processing that coincident block.

Protocol Rule 5. The state transitions for a given block
B in B(cid:126)v are applied to S(cid:126)v in the following order. First, if
B is a coincident block, all transactions with destination
(cid:126)v which are eligible to be applied to S(cid:126)v according to
Protocol Rule 4 are applied in order of highest origin
order to lowest origin order. Transactions with the same
origin order are applied in order of the blockchain index
that order, and transactions with the same origin
at
index are applied in chronological order according to
their inclusion in their origin blockchain. After that, all
transactions directly referenced by B are applied to S(cid:126)v
in the order in which they are referenced by B.

Protocol Rules 3, 4, and 5 guarantee that all nodes
in the same sub-network perform state transitions in the
same order, meaning any two nodes which agree on the
canonical chain will have consistent local state. This is
formalized by Theorem IV.1.

Theorem IV.1. For any given blockchain B(cid:126)v, any two
correct nodes in N(cid:126)v which agree on the canonical chain
of B(cid:126)v will agree on S(cid:126)v.

We prove Theorem IV.1 inductively, ﬁrst remarking
that any two correct nodes must agree upon the genesis
block and the associated state when the blockchain is
instantiated. We then show that for each block in the
canonical chain of B(cid:126)v, both nodes must apply the same
state updates to S(cid:126)v and in the same order, as to do
otherwise would require at least one of the nodes to
break a protocol rule.

Proof. We use induction to prove the statement. Let N1
and N2 be two correct nodes in N(cid:126)v which agree on the
canonical chain of B(cid:126)v. It sufﬁces to show that N1 and
N2 agree on S(cid:126)v at the genesis block, and that thereafter
both nodes perform identical updates to S(cid:126)v.

First, note that in any blockchain system, all nodes
agree on the genesis block and the initial state, and thus
all nodes in N(cid:126)v initially agree upon S(cid:126)v. By Protocol
Rule 3, each block in the canonical chain of B(cid:126)v must
be processed in the same order by N1 and N2. Then it
remains to show that for any block B in the canonical
chain of B(cid:126)v, N1 and N2 perform the same updates to
S(cid:126)v in the same order when processing B.

We prove this by contradiction. Assume that when
processing B, N1 applies an update deﬁned by some
transaction tx with origin (cid:126)vo and destination (cid:126)vd to S(cid:126)v
but N2 does not. This can only occur if N1 believes the
state update for tx should be applied to S(cid:126)v while N2
does not, as by Protocol Rule 5, given the same set of
state updates to apply, N1 and N2 would perform them
in the same order. By assumption, N1 is correct and
would only apply the state update for tx if (cid:126)vo and/or (cid:126)vd
is equal to (cid:126)v. Then we can examine the following cases.

1) (cid:126)vo = (cid:126)v. In this case, tx is directly referenced in B.
This leads to a contradiction, as N1 and N2 both
have the same block B and can verify its contents
using the block hash.

2) (cid:126)vd = (cid:126)v and (cid:126)v is an ancestor of (cid:126)vo. In this case, (cid:126)v is
the highest order common ancestor between (cid:126)v and
(cid:126)vo, meaning B must be a coincident block between
(cid:126)v and (cid:126)vo. We know that tx is in the canonical
chain of B (cid:126)vo prior to B. Then because B is in the
canonical chain of B(cid:126)v, by the HLCR, N1 and N2
must both agree on the canonical chain of B (cid:126)vo prior
to B, thus leading to a contradiction.

3) (cid:126)vd = (cid:126)v and (cid:126)vo is an ancestor of (cid:126)v. In this case, (cid:126)vo is
the highest order common ancestor between (cid:126)v and
(cid:126)vo, meaning the block containing tx is a coincident
block satisfying the ﬁrst condition in Protocol Rule
4, and B is a coincident block between (cid:126)v and (cid:126)vo.
By the HLCR, N1 and N2 must agree that B is in
the canonical chain of (cid:126)vo, as otherwise it could not
be part of the canonical chain of (cid:126)v. Then N1 and
N2 must also agree on the canonical chain of (cid:126)vo
prior to B, thus leading to a contradiction.

4) (cid:126)vd = (cid:126)v and (cid:126)v is not an ancestor of (cid:126)vo nor is (cid:126)vo an
ancestor of (cid:126)v. Let (cid:126)va be the highest order common
ancestor of (cid:126)v and (cid:126)vo. If N1 applies the state update
for tx, then a coincident block Bc between (cid:126)vo and
(cid:126)va must be in the canonical chain of (cid:126)va prior to B,
and B must be a coincident block between (cid:126)v and
(cid:126)va. By the HLCR, B is in the canonical chain of
(cid:126)va, and N1 and N2 must agree that Ba is in the
canonical chain of (cid:126)va. Additionally, if Ba is in the
canonical chain of (cid:126)va, then it must also be in the
canonical chain of (cid:126)vo, and N1 and N2 must agree
upon the canonical chain of (cid:126)vo prior to Ba. Again,
this leads to a contradiction.

Therefore if N1 applies the state update for some
transaction tx to S(cid:126)v, N2 must also do so and in the
same order.

The statement follows.

As a corollary of Theorem IV.1, all correct nodes in
N{1} which agree on the canonical chain of B{1} also
agree on S{1}, i.e., the root blockchain in BlockReduce
achieves similar guarantees to that of a single-blockchain
system.

V. PERFORMANCE

In this section we show that BlockReduce achieves
transaction throughput that scales superlinearly with the
number of blockchains in each order.

A. Decreased Propagation Delay via Network Partition-
ing

Sub-networks of order r > 1 (i.e., all but the root sub-
network) have a network delay ∆r which is strictly less
than ∆1, where ∆1 is analagous to the ∆ experienced
by a traditional blockchain operated by a full network
of N nodes. This is due to the decreased size of the
sub-networks and the ability for nodes to select the sub-
network with which they share low-latency peer connec-
tions in order to reduce the overall block propagation
time that they experience.

It is clear from Equation 3 that a smaller network
naturally has lower propagation delays than a larger
network. In order to enhance this intuition, if we assume
that there are q sub-networks of order r, then we can
bound ∆r as follows:

∆r < δrCd ln (cid:0) N
q

(cid:1)

< ∆1 − δrCd ln q

(4a)

(4b)

Then the propagation delay for any order will be
strictly increasing with the number of sub-networks in
that order.

Additionally, we remark that under the distribution of
node-to-node latencies in Bitcoin as measured by [16],
latency between nodes can vary signiﬁcantly from one
pair to the next. We assume that in the absence of a
protocol mechanism requiring nodes to join a particular
sub-network, each node will attempt to operate in the
sub-network with they share the lowest latency in order
to maximize their rewards. As a result, we argue that in
each sub-network of order greater than 1, the average
per-link propagation delay δr between nodes in order r
sub-networks will be smaller than that between nodes in
N{1}—i.e., δr < δ1 for all r > 1. While we do not need
to directly use this result in our proof, it nonetheless
further supports the claim in Theorem V.1.

Overall, the network propagation delay within each
sub-network will be much smaller than that of the
network as a whole (i.e., the network delay of a similar
system such as Bitcoin), and as a result the rate of block
generation can be much higher within each sub-network.

B. Aggregate Throughput

In this section, we show that within each order in
the hierarchy, the total transaction throughput increases
as the number of blockchains in that order increases
despite the PoW efﬁciency remaining ﬁxed between all
blockchains. Moreover, the increase is superlinear with
the number of blockchains in each order, as each ad-
ditional blockchain adds an additional network partition
and thus reduces the propagation delay experienced by
nodes in each sub-network. We state this property of
BlockReduce more formally in the following theorem.

Theorem V.1. The aggregate transaction throughput of
each order in the BlockReduce protocol scales super-
linearly with the number of blockchains in that order,
and all blockchains in the hierarchy have identical PoW
efﬁciency.

We prove this theorem by showing that the effective
block generation rate of an order r > 1 blockchain grows
as the number of order r blockchains increases.

Proof. Recall that λr is the total block generation rate
of a blockchain of order r, then the effective block
generation rate is λr
1+λr∆r , and the PoW efﬁciency
is E r =
1+λr∆r . It sufﬁces to show that if q is the
number of blockchains of order r, λr
E increases as q
increases.

E = λr

1

We hold the PoW efﬁciency ﬁxed between all
i.e.,
1+λr∆r Substituting the results from Equa-

the root blockchain,

to that of
1

blockchains
1
1+λ1∆1 =
tion 4, we get

1
1 + λ1∆1 >
which simpliﬁes to

1
1 + λr(∆1 − δrCd ln q)

,

(5)

λr >

λ1∆1
∆1 − δrCd ln q
Then the effective block generation rate—i.e., the rate
at which blocks are appended to the canonical chain—
for an order r blockchain with the same PoW efﬁciency
as that of the root blockchain is

(6)

.

λr
E >

λ1∆1
(∆1 − δrCd ln q)(1 + λ1∆1)

.

(7)

Clearly, the right hand size of this equation increases
with q, meaning λr
E does as well. Then because all
blocks are assumed to contain the same number of
transactions, the statement follows.

VI. DISCUSSION AND FUTURE WORK
BlockReduce is a PoW-based blockchain system
which achieves high transaction throughput through a
hierarchy of merged mined blockchains which each
operate a partition of the overall application state in
parallel. Critically, the full PoW available to the net-
work is applied to all blockchains in BlockReduce, and
cross-blockchain state transitions are enabled seamlessly
within the core protocol. In this section, we highlight
several discussion points and avenues for future work.

Self-selection of sub-network participation. Mining
nodes in BlockReduce are allowed to mine any vertical
slice of blockchains within the PoW hierarchy. How-
ever, because the vast majority of miners in any PoW
blockchain are economically motivated, most miners
will elect to mine the blockchains which grant them
the highest rewards. In this way, blockchains within
each order will be self-balancing as miners naturally
drift towards any available blockchains with reduced
competition. In the absence of competitive advantage in
mining power, miners will elect to mine the blockchains
with which they share the lowest latency connections in
order to minimize the probability that their blocks are
lost to network forks. We believe that this alignment of
incentives should result in the formation of low-latency
clusters of mining nodes which are able to achieve very
high PoW efﬁciency, although we leave an incentive-
based analysis to future work.

Further analysis of

the BlockReduce protocol. As
mentioned in the introduction, the core contribution of
this work is the speciﬁcation of the BlockReduce pro-
tocol. We provide a coarse analysis of the performance
of the BlockReduce protocol under a synchronous com-
munication model with ﬁxed network delays and do not
fully characterize the impact of protocol properties such
as self-optimizing sub-network partitioning. However,
we believe that both further performance analysis under
a more advanced network model and empirical testing
of the BlockReduce protocol will be interesting future
work.

Low-value transaction security and settlement time
tradeoffs. BlockReduce users have a high degree of
ﬂexibility when transacting, as they can control both
the short-term security and the settlement time of their
transactions by selecting which blockchain to transact
in. Higher order blockchains will have low settlement
times and low security in the short term, as the sub-
networks operating these blockchains will be lightweight
and the rates of block generation will be high. This
is ideal for transactions of low economic value, as the
consequence of a low-value transaction being removed
from the canonical chain is minor. Users desiring a
higher degree of security might elect to transact in lower
order blockchains in order to utilize a larger fraction of

[9] M. Fitzi, P. Gazi, A. Kiayias, and A. Russell, “Parallel Chains :
Improving Throughput and Latency of Blockchain Protocols via
Parallel Composition,” {IACR} Cryptology ePrint Archive, vol.
2018, p. 1119, 2018.

[10] W. Martino, M. Quaintance, and S. Popejoy, “Chainweb: A
proof-of-work parallel-chain architecture for massive through-
put,” Chainweb Whitepaper, vol. 19, 2018.

[11] A. Kiayias, A. Russell, B. David, and R. Oliynykov, “Ouroboros:
A provably secure proof-of-stake blockchain protocol,” in Annual
International Cryptology Conference. Springer, 2017, pp. 357–
388.

[12] J. Brown-Cohen, A. Narayanan, A. Psomas, and S. M. Weinberg,
“Formal barriers to longest-chain proof-of-stake protocols,” in
Proceedings of the 2019 ACM Conference on Economics and
Computation, 2019, pp. 459–473.

[13] C. Sguanci, R. Spatafora, and A. M. Vergani, “Layer 2 blockchain
scaling: a survey,” arXiv preprint arXiv:2107.10881, 2021.
[14] N. Fountoulakis and K. Panagiotou, “Rumor spreading on ran-
dom regular graphs and expanders,” Random Structures and
Algorithms, vol. 43, no. 2, pp. 201–220, 2013.

[15] X. Xu, I. Weber, M. Staples, L. Zhu, J. Bosch, L. Bass, C. Pau-
tasso, and P. Rimba, “A taxonomy of blockchain-based systems
for architecture design,” in 2017 IEEE international conference
on software architecture (ICSA).

IEEE, 2017, pp. 243–252.

[16] T. Neudecker, “Characterization of the Bitcoin Peer-to-Peer Net-

work (2015-2018),” vol. 2019, no. 1, 2019.

the PoW of the network despite the tradeoff of longer
settlement times. The precise characterization of this
tradeoff will be speciﬁc to a particular implementation,
and it is likely that any BlockReduce implementation
will provide a default wallet which is capable of selecting
the appropriate transaction location in an automated
fashion.

Expected hierarchy structure and future implementa-
tion. Although we have designed BlockReduce to sup-
port an arbitrary hierarchy tree, real-world hardware and
network infrastructure as well as timing requirements
of a functional blockchan network will limit both the
number of orders and the number of blockchains per
order that are realizable in practice. As the number
of blockchains in the BlockReduce hierarchy increases,
cross-blockchain state transitions become increasingly
delayed due to the decreasing relative frequency of co-
incident blocks linking each blockchain. For example, if
a blockchain B has 3 child blockchains, then an average
of 1 in every 3 blocks in B will be coincident with each
child blockchain. If this number increases to 100 child
blockchains, the expected time required for a coincident
block to be found with one particular child increases
dramatically. Implementation and empirical testing will
be required to determine the optimal conﬁguration for
any given use case and network topology.

REFERENCES

[1] E. Georgiadis, “How many transactions per second can bitcoin
really handle? theoretically.” IACR Cryptol. ePrint Arch., vol.
2019, p. 416, 2019.

[2] A. Chauhan, O. P. Malviya, M. Verma, and T. S. Mor,
“Blockchain and scalability,” in 2018 IEEE International Con-
ference on Software Quality, Reliability and Security Companion
(QRS-C).

IEEE, 2018, pp. 122–128.

[3] L. Wan, D. Eyers, and H. Zhang, “Evaluating the impact of
network latency on the safety of blockchain transactions,” in
2019 IEEE International Conference on Blockchain (Blockchain).
IEEE, 2019, pp. 194–201.

[4] S. Nakamoto, “Bitcoin: A Peer-to-Peer Electronic Cash System,”

2008.

Seeman,
protocol

Shelat,
asynchronous

and A.
in
in Computer Science

of
“Analysis
Pass, L.
[5] R.
in
networks,”
the
blockchain
(including subseries
Lecture Notes
Intelligence and Lecture Notes
Lecture Notes in Artiﬁcial
in Bioinformatics), vol. 10211 LNCS, 2016, pp. 643–
673. [Online]. Available: https://pdfs.semanticscholar.org/161c/
24b98ce3af2c0f8a5e96d5055a367b81801e.pdf

[6] R. Pass and E. Shi, “Thunderella: Blockchains with optimistic
instant conﬁrmation,” Lecture Notes in Computer Science (includ-
ing subseries Lecture Notes in Artiﬁcial Intelligence and Lecture
Notes in Bioinformatics), vol. 10821 LNCS, pp. 3–33, 2018.
[7] V. Bagaria, S. Kannan, D. Tse, G. Fanti, and P. Viswanath,
“Prism: Deconstructing the blockchain to approach physical
limits,” in Proceedings of the 2019 ACM SIGSAC Conference
on Computer and Communications Security, 2019, pp. 585–602.
[8] A. Dembo, S. Kannan, E. N. Tas, D. Tse, P. Viswanath, X. Wang,
and O. Zeitouni, “Everything is a race and nakamoto always
wins,” in Proceedings of the 2020 ACM SIGSAC Conference on
Computer and Communications Security, 2020, pp. 859–878.

