2
2
0
2

b
e
F
1
2

]

R
C
.
s
c
[

1
v
6
0
2
0
1
.
2
0
2
2
:
v
i
X
r
a

TENET: Towards Self-sovereign and Fair Multi-party Computation Ecology
Empowered by Decentralized TEE Network

Qian Ren§∗

Hong Lei†∗

Yingjun Wu§∗
Lei Wang‡

Yue Li∗
Bangdao Chen§∗

Han Liu∗

§SSC Holding Company Ltd.
∗Oxford-Hainan Blockchain Research Institute
†School of Computer Science and Cyberspace Security, Hainan University
‡Department of Computer Science and Engineering, Shanghai Jiao Tong University

Abstract
Recently, blockchain has been adopted across a increasing
range of domains, e.g., supply chain ﬁnance, digital govern-
ment. The conﬁdentiality of smart contracts has now become
a fundamental and crucial demand for practical applications.
However, while new privacy protection techniques are emerg-
ing, how to securely enable Multi-party Computation (MPC)
in conﬁdential smart contracts is understudied. State-of-the-
art solutions suffers on high on-chain cost, low ﬂexibility and
security thus can hardly reach general users.

This paper proposes TENET, a pluggable and conﬁgurable
conﬁdential smart contract framework. TENET identiﬁes the
pitfalls for supporting off-chain MPC-enabled conﬁdential
smart contracts by leveraging TEE network and proposes cor-
responding treats, e.g., anonymously negotiate MPC among
apriori-unknown participants, atomically and fairly distribute
the MPC outputs, and securely evaluate an MPC program
with a constant on-chain transactions. TENET manages to se-
cure an MPC by only 3 transactions. In our evaluation on both
examples and real-world applications involving 2 to 11 par-
ties, TENET cost 0.55-0.98X gas (0.91X on average) against
the state-of-the-art.

1 Introduction

While blockchains are rapidly developed and adopted in
privacy-sensitive domains, e.g., medicine and ﬁnance indus-
tries, the privacy issues of blockchains have now become one
of the top concerns for smart contracts, i.e., keeping trans-
action inputs and contract states as secrets to non-relevant
participants. In many of the practical applications, privacy is
an essential property to achieve, e.g., avoiding malicious arbi-
trage on cryptocurrency, protecting sensitive information in a
cooperative business. Unfortunately, despite the importance
of smart contract privacy, most of the existing blockchains are
designed without privacy by nature [19,32]. For example, min-
ers of Ethereum verify transactions in a block by re-executing
them with the exact input and states. Consequently, private
data is shared within the entire network.

Conﬁdential smart contract. To address the aforementioned
problem, researchers have proposed various conﬁdential
smart contract solutions. Traditionally, researchers aim to
achieve conﬁdentiality of sender’s private data and the ex-
ecution of the transaction by using cryptographic solu-
tions [5, 7, 14] or solutions based on trusted execution en-
vironment (TEE) [8, 23]. Recently, some new works extend
the privacy to multi-party scenarios, where they adopt Multi-
party Computation (MPC) [30, 31] or TEE [17, 26] to make
data of a party conﬁdential to other parties in a transaction.

Limitations. While MPC-based solutions suffers on low scal-
ability and performance (e.g., they use heavy cryptographic
techniques such as non-interactive zero-knowledge proofs or
general MPC), current TEE-based solutions also suffers from
various deﬁciencies: they do not support apriori-unknown par-
ties negotiating with others to join a MPC program; parties in
their system are not self-sovereign to their private data (i.e.,
TEE encrypts and holds parties’ private data thus parties can-
not access their private data without the help of TEE); do not
achieve stateless of TEE (i.e., TEE and parties have to long-
timely persisting the execution state or transaction-speciﬁc
data); do not achieve standard fairness of output distribution.

Our design. In this work, we propose TENET, a novel sys-
tem that leverages a decentralized TEE network to support
complex multi-party conﬁdential smart contracts on estab-
lished blockchains, such as Ethereum [32]. We emphasize
that TENET does not only address the deﬁciencies of current
solutions above, but is also high efﬁcient and available. It can
be easily integrated into legacy blockchain and hence is ready
to use today.

Contributions. Our main contributions are as follows:

• We design a novel conﬁdential smart contract framework,
TENET, which supports multi-party programs and is interop-
erable with existing blockchains, i.e. operating multi-party
private inputs from both on-chain and off-chain, and parties
in our framework are self-sovereign to their data, i.e., par-
ties can always access their data from blockchain without
the help of TEE.

1

 
 
 
 
 
 
Table 1: A Comparison of TENET with related works. The symbols (cid:53), (cid:109), (cid:119) and (cid:108) refer to non-related, not match, partial match and
full match respectively. "Self-sovereign" means whether party can access their private data without TEE. "Stateless" means whether the TEE
network needs to persist states of conﬁdential smart contracts. "Financial fairness" means that honest parties can always get collaterals in
present of adversary. "(Standard) Output fairness" means parties can get their outputs in almost the same time.

Approach

Adversary

Parties TEE Executors

Ekiden [8]
Conﬁde [18]
Bhavani [28]
Hawk [17]
Fastkitten [11]
LucidiTEE [26]
TENET

1∗
1∗
n
n
n
n
n

m − 1
(cid:98)m/3(cid:99)
m − 1 |m=n
(cid:53)
1∗
m − 1
m − 1

min(#TX) Self-sovereign Negotiation Conﬁdentiality Stateless

O(1)
O(1)
O(1)
O(n)
O(n)
O(n)
O(1)

(cid:109)
(cid:109)
(cid:53)
(cid:109)
(cid:109)
(cid:109)
(cid:108)

(cid:53)
(cid:53)
(cid:109)
(cid:109)
(cid:109)
(cid:119)
(cid:108)

(cid:108)
(cid:108)
(cid:108)
(cid:119)
(cid:108)
(cid:108)
(cid:108)

(cid:109)
(cid:109)
(cid:109)
(cid:108)
(cid:109)
(cid:119)
(cid:108)

Fairness

Financial Output

(cid:53)
(cid:53)
(cid:53)
(cid:108)
(cid:108)
(cid:53)
(cid:108)

(cid:53)
(cid:53)
(cid:108)
(cid:109)
(cid:109)
(cid:119)
(cid:108)

• We propose an protocol to support anonymous MPC nego-
tiation among apriori-unknown parities and standard fair
distribution of MPC outputs in presence of a byzantine ad-
versary who can corrupt all parties and all-but-one TEE
executors.

• We have applied TENET in several industrial applications.
TENET has managed to securely evaluate MPC programs
in O(1) transactions and lower gas cost against state-of-the-
art.

Organization. This paper is organized as follows. Section 2
introduces how TENET advances the related work. Section 3
shows the challenges and overview of TENET. Then, we
model the data-logic separation model of MPC-enabled con-
ﬁdential smart contract adopted by TENET in Section 4 and
how to securely evaluate an MPC program by TENET protocol
in Section 5. Section 6 illustrates how to enable our frame-
work on existing blockchains. Finally, we evaluate TENET
in Section 8, discuss the research impact, limitations and im-
provements in Section 9, and conclude in section 10.

2 Related Work

In this section, we focus on research efforts related to our work
from two lines separately, TEE-enforced conﬁdential smart
contract and MPC-enabled smart contracts. Table 1 shows the
difference between TENET and representative related works.
TEE-enforced conﬁdential smart contract. Ekiden [8, 27],
Conﬁde [18] and CCF [23] execute consensus algorithm
among TEE devices to consistently execute revealed private
transactions in TEE, thus conﬁding transaction parameters,
returns, and contract state. While Conﬁde [18] additionally
holds EVM and WASM in SGX to support more kinds of
contracts, CCF [23] supports users to run any typescript or
C++ based application. TENET differs with these approaches
in several key aspects. First, all these three approaches require
TEE to encrypt and manage private inputs and states of con-
tracts. Users therefore cannot access their own data without
the help of TEE. Instead, in TENET, all private data are con-

ﬁdentially persisted on blockchain making users access and
manage their data in a self-sovereign manner. Second, TENET
also achieves the statelessness of both the TEE network and
users by freeing them from persisting transaction-speciﬁc
keys and data. Finally, while both these three schemes de-
pend on a committee consisting of SGX to achieve consensus,
TENET does not require TEE devices to hold heavy consensus
algorithm among them and the TEE devices even have no in-
teraction in evaluating transactions, including MPC programs.

MPC-enabled smart contract. Related works combining
multi-party computation and smart contracts fall into two cat-
egories, MPC-based and TEE-based solutions. MPC-based
works like [22, 30, 31] allows m-round MPC with penalties
over Bitcoin, but relies on the claim-or-refund functional-
ity which requires complex and expensive transactions and
collaterals thus making these solutions impractical. TEE-
based solutions usually introduce the TEE as an trusted third
party. Speciﬁcally, Hawk [17] theoretically suggests a TEE-
based manager receiving private inputs from multiple par-
ties and output results to blockchain. FastKitten [11] com-
mits m-round MPC results on blockchain and additionally
achieves the collateral fairness when malicious parties or
operator occurs. Thuraisingham et al. [28] achieve standard
fairness of distributing MPC outputs by requiring each party
to hold a TEE device and cooperate with an public board, e.g.,
blockchain. TENET distinguishes from these work in multiple
aspects. In terms of security, while most of current works
require limited malicious subjects in the system, TENET en-
sure the security of the system under all malicious parties
and all-but-one malicious TEE executors. Moreover, while
LucidiTEE lacks collateral system to punish malicious parties
and FastKitten [11] adopts an improved challenge-response
protocol to punish both malicious parties and the unique TEE
operator therefore achieve ﬁnancial fairness, TENET achieve
ﬁnancial fairness in presence of multiple TEE executors. Fur-
thermore, TENET achieves the standard fairness in deliver-
ing MPC outputs. In terms of efﬁciency, current schemes
adopting TEE to enhance MPC require at least O(n) high
money-cost [30, 31] and time-consume transactions [11] for

2

collaterals and so on, thus suffering on high-cost. TENET only
requires O(1) transactions in normal cases.

3 TENET Design

In this section, we present the overview of our novel conﬁ-
dential smart contract framework TENET. We ﬁrst highlight
several key challenges towards a practical, self-sovereign, and
secure off-chain MPC-enabled conﬁdential smart contract
economy and our corresponding designs. Then, we give a
glance at the whole architecture and introduce the workﬂow
of TENET to help parties evaluate an MPC program.

3.1 Design challenges of TENET

Harmonizing TEE and blockchain for building an MPC-
enabled conﬁdential smart contract framework requires us
to solve the following main challenges.

3.1.1 Achieve self-sovereign data management of par-

ties

Previous works about TEE-blockchain systems rely on TEE
to persist or manage the private data of parties. Speciﬁcally,
Ekiden [8], Conﬁde [18] and LucidiTEE [26] store contracts’
secret data (e.g., code, inputs, states) by encrypting data with
keys only known by TEE. Consequently, a party even cannot
access its own private data without help of TEE. Besides that,
other works [11, 26] focus on supporting MPC function in
a one-time vision, i.e., enclaves are newly initialized for the
speciﬁc function. To achieve conﬁdentiality and security (e.g.,
fairness) under this setting, these works usually update states
in TEE, commit outputs on-chain, and deliver the ciphertext
of outputs and corresponding keys off-chain. These works
indicate that parties have to persist these keys all the time
in case they need to decrypt the on-chain ciphertext or re-
compute the ciphertext to prove the correspondence between
the ciphertext and the off-chain delivered plaintext. However,
considering a long-running TEE oracle network, it is a dis-
aster for both the network and parties participating quantity
of MPC programs to persist keys and data of each MPC pro-
gram. Our goal is to keep the autonomy of parties, i.e., parties
access their private data and specify the privacy policy of their
data in a self-sovereign manner, making TEE an on-demand
privacy policy enforcer.

Cdi := [Enckd

i

(di), Encpki(kd

i ), Pi]

In our design, parties’ private data are stored as a well-
designed cryptographic commitments and managed by a on-
chain data contract. Although private data of smart contracts
can be typed as string, uint, etc., without losing generality,
we construct the commitment of data di private to Pi as the
above structure, where kd
i refers to a one-time symmetric key

for encrypting the private data di, pki refers to the public key
of Pi, and Pi refers to the address of party Pi. We note that kd
i
is not only traditionally used for accumulating performance of
the public key encryption using pki, but also used for achiev-
ing standard fair distribution, which will be explained in detail
in Section 5. Obviously, in any time, parties can directly ac-
cess their private data di on blockchain by decrypting Cdi,
while that a TEE device can read di only when the party Pi
consciously reveals di, kd
to the TEE. In this way, TEE de-
i
vices become just oracles that are only in charge of trustfully
evaluating MPC instead of persisting and managing parties’
private data at the same time.

3.1.2 Allow anonymous negotiation among parties

Most of current works [11, 28] assume that the setting of an
MPC, such as involved parities and target function, has already
been known at the beginning of the protocol, thus the protocol
always starts from an speciﬁed setting. However, there are
deﬁnitely some scenarios where a party interested in joining
an MPC has no idea about the identities of other parties, e.g.,
a public auction where anonymous bidders independently
join an auction according to their interests and cannot a priori
know the identities or total number. This is what we called
anonymous negotiation. Even worse, since TENET introduces
multiple TEE Executors to improve availability of our system,
it also makes the anonymous negotiation non-trivial since dif-
ferent Executors against a single MPC proposal may settle in
different MPC settings. Speciﬁcally, considering several par-
ties compete to join an MPC proposal, these parties broadcast
their participation interest to all Executors and each Executor
adopts an deterministic rule such as "ﬁrst come ﬁrst selected"
to select parties. However, this intuitive method will lead to
inconsistency of both MPC proposal id and selected parties
among Executors. For example, when a party broadcast an
MPC proposal, assuming three parties p1, p2, p3 broadcast
their participation interests i1, i2, i3 to join the proposal and
each Executor independently generate an id for identifying
the proposal and selects two parties corresponding to the earli-
est received two interests. First, independently generating the
proposal id will duplicate the proposal thus not only against
its proposer’s wishes but also scattering the potential partici-
pants thus making it difﬁcult to gather required participants
for a single proposal. Second, since the messages can be ar-
bitrarily delayed, dropped or reordered by byzantine TENET
Executors, an enclave e1 of an Executor receiving i1, i2, i3 will
settle on i1, i2 while another enclave e2 receiving i2, i3, i1 will
settle on i2, i3, which leads to inconsistency. Although Lucidi-
TEE [26] mitigates this problem by requiring parties to join
a computation by publicly posting data binding transactions
on-chain, it leads to O(n) transactions, and also leaks parties’
identities during the negotiation.

In this paper, we propose an anonymous negotiation pro-
tocol Procanego to support apriori-unknown parties anony-

3

mously negotiating with others to reach a consensus of MPC
setting among both themselves and multiple Executors with-
out introducing a heavy consensus algorithm among these
Executors. The basic idea is to utilize the consensus of
blockchain. Speciﬁcally, a party broadcasts an MPC proposal
to start a negotiation protocol. Each Executor receiving the
proposal independently generates a deterministic id for the
proposal to avoid the duplication of proposal id. Then, any
party interested in the proposal can broadcast its signed in-
terest attaching the proposal id to join the proposal. When
the negotiation ﬁnishes, all Executors try to publish their set-
tled MPC settings on a blockchain. Although an adversary
can lead to inconsistency of settled parties among off-chain
Executors, only a unique proposal of these proposals will
be conﬁrmed on the blockchain. Therefore, by requiring all
Executors to proceed next steps according to the conﬁrmed
MPC proposal, we achieve a ﬁnal consistency among these
TENET Executors. Finally, our negotiation protocol not only
achieves anonymity of parties but also requires only a constant
1 transaction on-chain.

3.1.3 Achieve standard fairness of output distribution

In a TEE-Blockchain system, besides that the outputs of the
off-chain smart contracts are valid only when they are com-
mitted on the blockchain [8, 17], more security requirements
arises in multi-party scenarios. First, the revealing of out-
puts should be atomic with the conﬁrmation of the outputs’
commitments on-chain to avoid rewind attack [8], e.g., an
adversary corrupting multiple Executors can feed different
inputs to different Executors. If in a protocol the outputs are
revealed but have not been conﬁrmed, the adversary can se-
lectively publish one of its preferred outputs. Second, even
though the atomicity is preserved guaranteeing that all parties
ﬁnally receive their own conﬁrmed private data, different par-
ties receiving their corresponding data at different times will
also lead to attacks. e.g., a party knowing prior to other parties
that the MPC result will increase the value of a stock can get
unfair advantages in earning money from this information. To
solve this problem, Bhavani et al. [28] ﬁrst achieves standard
fairness, i.e., parties of MPC get their private data at the same
time but require each party to hold a TEE device interacting
with a blockchain. LucidiTEE [26] looses the requirements
of Bhavani [28] to that only some of parties hosts TEE de-
vices, however, just achieves ∆-fairness, i.e., parties get their
private data during a limited ∆ period, where the ∆ equals to
the time of generating Proof-of-publication of a key-releasing
transaction, which is at least exceeds the time to conﬁrm a
transaction on a blockchain.

In this paper, we achieve the standard fairness of MPC
outputs distribution without requiring parties to hold TEE
themselves. We assume that there are several TENET Execu-
tors independently holding their own TEE device to serve
all parties, and all TEE devices synchronize a common key

pair to form a network. To achieve standard fairness, we re-
quire each of these TEE devices to independently release
the one-time symmetric key of outputs’ commitments only
when it is veriﬁed that the outputs’ commitments have been
conﬁrmed on the blockchain. Therefore, since parties can
independently and directly communicate with each Executor,
these parties can get the released keys to decrypt their outputs’
commitments at the same time as long as at least one Executor
honestly proves to its TEE device that the commitments have
been conﬁrmed.

3.1.4 Resisting adversary with minimal transactions

To resist parties from aborting in the middle of the proto-
col, it’s common that current works adopt various challenge-
response mechanisms to punish parties departing the protocol.
However, these mechanisms [11] require parties to deposit
collaterals on-chain for evaluating an MPC program each
time, thus leading to at least O(n) transactions. This high
on-chain cost makes these solutions impractical.

In this paper, we adopt different mechanisms to resist mali-
cious parties and Executors respectively. For malicious parties,
we adopt a challenge-response mechanism similar with [11].
However, in our mechanism, each honest party is only re-
quired to globally deposit coins once then join any MPC
program unlimited times. For TENET Executors, we do not re-
quire Executors to deposit coins like [11] but require multiple
Executors to serve parties so that our protocol will proceed
when at least one Executor is honest. As result, we only re-
quire minimal 3 transactions in normal cases while achieving
byzantine adversary resistance, anonymous negotiation, and
standard fair distribution.

3.2 Architecture and workﬂow

Integrating all mentioned key designs, we propose a novel
TENET framework ATENET−BC to enable an MPC-enabled
conﬁdential smart contract on a blockchain. As is shown in
Figure 1, the ATENET−BC includes two components:
TENET Blockchain (BC). A blockchain with deployed
TENET contract (i.e., TC, as is shown in Algorithm 1). Essen-
tially, TC manages the conﬁg (e.g., public key and account
address) of the TENET Network, parties’ coins and public
keys, and life cycles of all MPC proposals.
TENET Network ( ¯E). A TENET Network ( ¯E) consists of mul-
tiple TENET Executors. Each Executor E holds a TEE device
E that runs the TENET enclave program (i.e., Algorithm 2)
and is able to evaluate MPC programs. All those TEE de-
vices synchronize with each other to hold a common account
(adrE , keyE ) and key pair (pkE , skE ).

We assume smart contracts are implemented based on Data-
logic separation model, which has been widely adopted in
both academic papers [7, 17, 26] and industrial smart con-
tracts [21]. We will elaborate it in detail in Section 4. Accord-

4

protocol independently. First, each E deterministically
generates an id for the proposal and broadcasts the signed
proposal with the id to all parties. If a party is interested
in or required by the proposal, it responds by broadcast-
ing an acknowledgment to ¯E where the acknowledgment
includes signed commitments of the party’s parameters
to the MPC proposal. Each E keeps collecting parties’
acknowledgments until the negotiation phase timeouts or
collected acknowledgments meet the settlement condition
of negotiation phase. Then, each E independently sends a
T Xp to BC1. T Xp publishes the settled MPC proposal with
parties’ identities and parameters’ commitments. There-
fore, we achieve the anonymity of parties since parties
cannot know identities of other parties until these TEE
devices settle the proposal. Besides, although different
E may settle at different parties or parameters’ commit-
ments, only one of these published T Xp will be conﬁrmed
on-chain thus ensuring the ﬁnal consistency. The T Xp also
deducts collaterals of all parties for the MPC proposal in
case one of them aborts the MPC after the negotiation
succeeds.

• (2) Execution phase: When T Xp has been conﬁrmed on
BC, each party involved in T Xp broadcasts their signed in-
puts (i.e., parameters and old states) to ¯E. Upon receiving
these inputs, each E ﬁrst veriﬁes Proof-of-Publication2
(PoP) [8, 11] of T Xp to ensure that T Xp has been con-
ﬁrmed on BC, which indicates that collaterals of parties
have been deducted3 and parties cannot change their pa-
rameters. Then, each E checks that collected parties’ in-
puts meeting their commitments in T Xp. In case a E does
not receive inputs from some parties, the E needs to de-
termine whether these parties failed to send inputs or its
E behaved maliciously (e.g., by dropping messages).
We resist malicious Executors and parties in different
ways. To resist malicious Executors, since we introduce
multiple Executors in our system, we do not punish spe-
ciﬁc E because we assume that there is at least one Execu-
tor honestly following the protocol so that the department
of some malicious Executors do not disturb the proceed-
ing of honest Executors in ¯E. Moreover, to avoid that
malicious Executors may drop parties’ inputs to cheat
its E to mistakenly punish some honest parties, we re-
quire a E to punish malicious parties only if its Executor
proves that these parties have publicly challenged but did
not respond their inputs. This proof is generated by per-
forming a improved challenge-response protocol via the
blockchain: one E publicly challenges these parties on
BC. Upon the challenge transaction T Xcha is conﬁrmed,

1Practically, a E can send T Xp as well as other transactions when it has

not seeing a T Xp with the same id sent to BC to avoid the redundancy

2A proof constructed for proving that a transaction has been conﬁrmed

on a blockchain. We use the same algorithm as [11].

3In other words, all parties have enough balance in their globally deposited

coins and indeed deducts collaterals required by the speciﬁc MPC.

Figure 1: The framework and overall workﬂow of TENET.
The TENET blockchain has deployed TENET contract for manag-
ing life cycles of MPC proposals. The TENET network consists of
multiple TENET Executors E. Each E holds a TEE device running a
TENET enclave program E. An MPC-enabled smart contract con-
sists of a data contract V on-chain (persisting data and verifying
state transition), a logic contract F (expressing business logic), and
a privacy policy P (expressing the privacy speciﬁcation of F ) and
binds F with the V .

ing to the model, each MPC-enabled smart contract includes
three parts: (i) a data contract V that is responsible for stor-
ing data and verifying state transition on-chain, (ii) a logic
contract F that holds the function logic of several MPC pro-
grams, and (iii) a privacy policy P that speciﬁes the privacy
requirements of each MPC program and binds the V and F .
After the TENET Network ¯E has been initialized, all parties
can verify the correct initialization of TEE devices and get
the common public key pkE of ¯E. We assume that the data
contract V has been deployed to the blockchain and the logic
contract F and P have been deployed to the TENET Network.
Figure 1 shows the workﬂow of TENET. All parties follow
a TENET protocol πTENET to interact with the BC and ¯E to
evaluate an MPC program. To quickly grasp the key process
without diving into complex symbols, we ﬁrst explain the
protocol in natural description. The protocol πTENET can be
divided into four phases, where a global setup phase happens
only once for all parties and other three phases happen in
valuating a MPC program each time. We will brieﬂy travel
through these phases and then introduce them in detail at 5.
• (0) Global setup phase: πTENET ﬁrst requires all parties
globally blocking their coins on BC before they joining
any MPC. Speciﬁcally, parties deposit their coins to the
network ¯E’s common address adrE . The collaterals of
each MPC will be deducted from these coins.

• (1.1 − 1.2) Negotiation phase: A party broadcasts an
MPC proposal to ¯E without knowing other parties’ identity
a priori. Each TEE E in ¯E starts a anonymous negotiation

5

DesignIdeaandWorkflowTheworkflowofCloak,adevelopmentframeworkofgeneral-purposeconfidentialsmartcontracte.g., Ethereum.Data ContractTENETBlockchainTENETNetwork#{Parties}Enclave…Executor!!"#"!LogicContract"Privacy Policy!1.11.2023.23.13.3$(&)TENETContractR/Wthe challenged parties need to respond publicly on BC by
posting a response transaction T Xres with the ciphertext
of their inputs. If all challenged parties respond, each E
can extract plaintext of their inputs and continue with the
protocol execution. If these parties did not respond, each
E forwards the respective blocks as a transcript to its E to
prove that these parties misbehaved, so that each E sends
a punish transaction T Xpns to refund collaterals deducted
by T Xp to all honest parties and stop the protocol. Other-
wise, if all parties’ inputs have been successfully collected,
E evaluate the MPC program to get outputs (i.e., return
values and new states).

• (3.1 − 3.3) Distribution phase: When the execution
phase ﬁnished, each E has get the outputs of the MPC
program, then it generates one-time symmetric keys to
compute the commitments of the MPC outputs, and sends
a T Xcom to publish the commitments of outputs on BC
but with symmetric keys encrypted by pkE , the network
¯E’s public key, instead of the keys’ ciphertext in normal
commitments (keys encrypted by pki, the party Pi’s pub-
lic key). In this way, although all parties can access their
incomplete outputs’ commitments in T Xcom, they cannot
get the symmetric keys to decrypt the outputs’ commit-
ments to reveal their corresponding return values and new
states. We stress that we encrypt the symmetric keys by
pkE and require all E read these keys from the conﬁrmed
T Xcom to avoid the inconsistency of these keys caused by
its independent generation.
When a T Xcom has been conﬁrmed on the blockchain,
which indicates that the new states and return values have
been committed, each E independently each E veriﬁes the
PoP of the T Xcom, and then sends T Xk to release the sym-
metric keys read from T Xcom. Since all parties can com-
municate with each Executor directly, ignoring the com-
munication latency, they can get the keys to decrypt their
conﬁrmed outputs’ commitments simultaneously. When
the T Xk has been conﬁrmed on-chain, both parties and
Executors do not need to persist all mentioned transaction-
speciﬁc commitments and keys. Since stepping to T Xk
indicates the honesty of all parties during the protocol,
this transaction also refunds their collaterals respectively.
Otherwise, in case E neither stops the MPC by T Xpns nor
completes the MPC by T Xk and leads to timeout, any party
can send T Xout to claim their collaterals back.

3.3 Adversary model

πTENET is followed by n parties and a TENET network consist-
ing of m Executors E to enforce the off-chain MPC program.
We uses TEE to ensure the conﬁdentiality and integrity of
πTENET. Although we prototype πTENET based on an TEE in-
stance, i.e., SGX, our design is TEE-agnostic. In this paper,
we consider a strong byzantine adversary who can not broken
the conﬁdentiality and integrity of TEE itself but are able to

corrupt all parties and all-but-one TENET Executors.

Exempliﬁed by SGX, we ﬁrst note that although recent re-
search showed some attacks against TEE, the conﬁdentiality
and integrity guarantees of TEE devices is still trustworthy.
Speciﬁcally, we assume that E has full control over the ma-
chine and consequently can execute arbitrary code with root
privileges. First, we consider memory-corruption vulnerabili-
ties [2] against TEE. While memory corruption vulnerabilities
can exist in the enclave code, a malicious E must exploit such
vulnerabilities through the API between the host process and
the enclave. For the enclave code, we assume a common
code-reuse defense such as control-ﬂow integrity (CFI) [1, 6],
or ﬁne-grained code randomization [12] to be in place and
active. Then, we consider architectural side-channel attacks
(e.g., based on caches [3]) that can can expose access patterns
from SGX enclaves (and therefore our TENET prototype).
However, the community has developed several software miti-
gations [15,24,25] and new hardware-based solutions [10,20]
against these side-channel attacks. A more serious Micro-
architectural side-channel attacks like Foreshadow [4] can
extract plaintext data and effectively undermine the attesta-
tion process TENET relies on, leaking secrets and enabling
the enclave to run a different application than agreed on by
the parties; however, the vulnerability enabling Foreshadow
was already patched by Intel [16]. Therefore, since existing
defenses already target SGX vulnerabilities and since TENET
’s design is TEE agnostic (i.e., it can also be implemented
using ARM TrustZone or next-generation TEEs), we consider
mitigating side-channel leakage as an orthogonal problem and
out of scope for this paper so that the conﬁdential and integrity
of TEE devices is still trustworthy. Therefore, users can trust
the TEE integrity attested by Intel Attestation Service.

Furthermore, we assume that the adversary can compro-
mise all parties and all-but-one E. On compromised parties or
E, the adversary can control the operating system and network
stack so that is able to schedule processes as well as reorder
and delay messages arbitrarily.

While parties need not to execute contracts themselves or
hold TEE, we assume honest parties only trust their own code
and platform, and all attested TEE devices.

4 Data-logic Separation Model

As is mentioned before, in TENET, while the data of smart
contracts are persisted on blockchain, contract logic is held in
TEE devices, which indicates a data-logic separation (DLS)
model, i.e., decoupling the contract data and logic. The DLS
empowers developers to update the transaction logic of con-
tracts without migrating legacy data, and therefore is widely
adopted in both academics and industry. Speciﬁcally, a DLS
typically split an contract to a data contract V and logic con-
tract F , where V persists contract storage and F holds trans-
action logic and interact with V to manipulate data. While in
normal scenarios both these two contracts are deployed on a

6

same blockchain, we improve interfaces and data structures
of the V in DLS and deploy the F , one transaction logic of
which is an MPC program, to our TENET Network ¯E.

4.1 Data contract

In TENET, a data contract V is deployed on BC for managing
contract storage including all parties’ private data. V persists
each party’s private data in the structure of commitments
elaborated in Section 3. Here we ignore the details of the data
contract but model it by three functions:
• Cs ← V .getStates( f ): get the current state commitments

of V read by f in execution.

• V .setStates( f ,Cs(cid:48)): set current state commitments to new
commitments Cs(cid:48) only when the transaction is sent by ¯E.
• {1/0} ← V .veri f y( f , ˆHCs ): verify that the hash of the
array of all parties’ current state commitments ( i.e.,
Hash([Csi|1..n])) matches its claimed value ˆHCs in the trans-
action, i.e., it’s a validate state transition from current states.

4.2 Logic contract

A logic contract F holds several transactions, some of which
are MPC programs. To evaluate each MPC program, TEE
devices E collect private parameters from multiple parties
and replace the state of F to current state of V , then evaluate
the MPC program of F based on the collected parameters
and current states to get MPC outputs, i.e., return values and
new states.

4.3 Privacy Policy

Since TEE devices E need to read states of V before eval-
uating any MPC program of F , TEE devices must aware
about the read and write sets of each MPC program of F . For
this reason, we ﬁrst add V .getStates (resp. V .setStates) to
expose interfaces for reading (resp. writing) states of V in
transaction granularity, then, inspired by [26], bind a privacy
policy P to notate privacy needs of F .

Veri f ier
Vaddr
Name
n
Party
P
Function P f

:= {0, 1}∗
:= [a − zA − z0 − 9]+
:= {0, 1}∗
:= {

Param Px := (n : P)| (cid:0)n : ρ?(cid:1)
Read Ps := (n : P)| (cid:0)n : ρ?(cid:1)
Write Ps(cid:48) := (n : P)| (cid:0)n : ρ?(cid:1)
Return Pr := (n : P)| (cid:0)n : ρ?(cid:1)

}

A privacy policy P is modeled as the above. The P of an F
can be splitted into two parts, contract-speciﬁc and function-
speciﬁc parts. For contract-speciﬁc part, the Veri f ier refers
to the address of its corresponding veriﬁer contract V on
blockchain. The Name refers to the name of managed state

variable in V . The Party refers to parties’ addresses. For
each function’s policy P f , there are four elements, Param,
Read, W rite and Return. The Param (Px) refers to transaction
parameter variables of the function f . The Read (Ps) refers
to states variables needed to be read in evaluating f . The
W rite (Ps(cid:48)) refers to states variables updated in evaluating f .
The Return (Pr) refers to return variables of f . Each variable
is denoted by the tuple (n : p), containing its name n and
the address of of its owner p (i.e., the party that the variable
private to). If the owner party of the variable is unknown
at the time of specifying the computation, we write (n : ρ?),
and the unknown party will be settled and revealed after the
anonymous negotiation protocol in Section 3 ﬁnished.

5 TENET Protocol

After the data contract V , logic contract F and privacy policy
P of an MPC-enabled contract having been deployed, πTENET
is used to evaluate MPC programs of F . In this section, we
illustrate how πTENET achieves anonymous negotiation and
standard fair distribution in evaluating an MPC program f .

5.1 TENET Protocol Details

As explained in Section 3, our protocol πTENET proceeds in
four phases. In global setup phase, all parties verify the in-
tegrity and correctness of TEE devices in TENET Network
¯E then deposit coins to ¯E’ common address adrE and regis-
ter their, the parties’, public keys pki on blockchain. Then,
evaluating each MPC program requires three phases. Dur-
ing a negotiation phase, all parties negotiate to join an MPC
and ﬁnally one E of ¯E commits settled MPC proposal with
parties’ inputs commitments and deducts their collaterals on-
chain. After that, an execution phase follows for collecting
plaintext inputs (i.e., parameters and old states) from parties
and executing MPC with inputs in enclave to get outputs.
When the execution ﬁnishes, the protocol enters a distribution
phase to commit outputs and release the decryption key of
outputs commitments when the output commitments have
been conﬁrmed on blockchain to complete the MPC and re-
fund collaterals. We stress that after synchronizing with other
devices to get the network common keys (skE , pkE ) and ac-
counts (adrE , keyE ). Each E proceeds πTENET to evaluate an
MPC program without cooperating with each other4 during
the protocol.

To explain the protocol steps in depth, we use the following
symbols to simplify the expression. As is shown in Figure 2,
given a blockchain BC, a party set ¯P, and a TENET Network ¯E,
where | ¯E| = m and | ¯P| = n. Since πTENET involves data from
different parties, we use di to refer to data related to Pi (e.g.,
xi, si, ks
i ), we use d to refer to an array [di|1..n] including all

4TENET Executors will only be responsible for relaying messages broad-

cast in the network during the protocol.

7

di from n parties (e.g., x, s, ks). For operation based on these
data, we similarly let Hdi refers to Hash(di) and Hd refers to
[Hash(di)|1..n] (e.g., HCx refers to [Hash(Cxi)|1..n]). However,
for Hash([di|1..n]), we refer it as ˆHd (e.g., ˆHCx , ˆHCs). Notably,
for common values among all parties (e.g., the unique P ,F ),
the operation on these value is normal (e.g., HP refers to
Hash(P )). The detailed interactions is displayed in Figure 2.
Algorithm 1 describes the TENET contract and Algorithm 2
describes the TENET enclave program E.

5.1.1 Global setup phase

All parties verifying that the TENET Network ¯E has been
correctly initialized are required to register their public keys
and deposit coins to the TENET contract TC on blockchain
before evaluating any MPC program off-chain. Speciﬁcally, as
shown in Figure 2, before using TENET, a party Pi is supposed
to globally register its public key pki and deposit some coins
with amount Q. We stress that each party only needs to do it
once.

5.1.2 Negotiation phase

A negotiation phase uses the anonymous negotiation protocol
(Procanego) to guide parties to anonymously reach a agree-
ment on an MPC proposal and commit their parameters xi
on-chain5. Procanego proceeds in two steps.

S1: One party who wants to call an MPC broadcasts an
MPC proposal p = (cid:104) f , q,tn(cid:105) to ¯E. f refers to the MPC pro-
gram in F to call. q refers to required collateral for punishing
malicious parties and q ≤ Q. tn means the required deadline of
ﬁnishing the negotiation phase. Then, each E independently
but deterministically computes hash of the MPC proposal p to
be the p’s id idp and broadcasts the signed (cid:104)idp, p(cid:105) to parties.
Since each parties communicates with all TEE devices E in
¯E in secure channels, each party thus has no idea of other
parties’ identities according to the broadcast messages in the
network.

S2: Receiving (cid:104)idp, p(cid:105), each Pi interested in the MPC au-
tonomously computes Cxi (its parameter xi’s commitment)
and broadcasts a signed acknowledgement ACKi = (cid:104)idp,Cxi(cid:105)
to ¯E before tn. Each E receiving ACKi knows that Pi is inter-
ested in the MPC proposal idp. Then, each E reads T X i
pk from
the blockchain BC to get pki that will be used to compute the
party Pi’s commitments in next steps. Each E keeps collecting
ACKi. Upon collected ACKi meet the settlement condition6 in
p, E constructs the settled proposal p(cid:48). p(cid:48) expands p with set-
tled parties’s addresses ¯P and their parameters’ commitments
Cx. Then, each E send a T Xp to try to conﬁrm its settled p(cid:48) on
blockchain before executing the MPC. Only when the T Xp
is released, other parties can know who are also interested

5Old state commitments has been stored as contract storage on-chain.
6Settlement condition of negotiation can be ﬂexible, e.g., all inputs re-
quired have been provided or the number of parties exceeds a speciﬁc number.

in the proposal. When a unique T Xp is conﬁrmed on the BC,
it also deducts q collateral of each party from their coins re-
spectively. Then, each E goes to execution phase. Otherwise,
if the settlement condition is still not satisﬁed and the time
exceeds tn, the negotiation of the p failed and each E stops
the protocol.

5.1.3 Execution phase

This phase is used for collecting plaintext inputs from parties
and executing the MPC to get outputs. It contains three steps.
S1: Upon one of these T Xp is conﬁrmed on BC, each E
veriﬁes the Proof-of-Publication [11] of the T Xp, PoPp. Then,
7 from
each E reads F . f -needed old state commitments Cs
BC. Meanwhile, each party Pi knowing they are involved in
the conﬁrmed T Xp broadcasts their inputs (i.e., parameters
xi and old states si) to ¯E. Each E in ¯E receiving Pi’s inputs
recomputes commitments of xi, si respectively to match them
with their commitments Cxi,Csi read from BC. If all involved
parties’ inputs are collected and matched, E goes to S3. Oth-
erwise, if a E ﬁnds that some parties’ inputs mismatches their
on-chain commitments, or have not receiving some parties’
inputs before te, E marks these parties as potentially mis-
behaved parties ¯PM and returns ¯PM to its host E. Then, E
calls challenge to sends T Xcha to challenge all parties in ¯PM
on-chain. Then, the E goes to S2.

S2: When T Xcha has been conﬁrmed on-chain, honest par-
ties in ¯PM are supposed to send a T Xres to publish ciphertext
of their inputs xi, si on BC. All published T Xres are required
to be conﬁrmed before block height τres otherwise will be re-
garded as invalid. Before the block height goes to τres, the E
waiting for challenge results reads published T Xres and veri-
ﬁes its PoPres. For a party Pi in ¯PM, if the E successfully reads
matched inputs from its responded T X i
res, the E removes Pi
from ¯PM. Otherwise, if PoPres shows that no T X i
res is pub-
lished or the inputs in T X i
res are still mismatched, the E keeps
Pi in ¯PM. After that, if ¯PM becomes empty, which means all
inputs are collected, E goes to S3. On the contrary, if ¯PM
is not empty, which means the misbehavior of parties left is
conﬁrmed, E marks these misbehaved parties as ¯P(cid:48)
M. Then, E
sends T Xpns. T Xpns calls BC.TC.punish to refund deducted
collaterals of all parties to only honest parties in average and
settle the MPC with ABORT.

S3: If all involved parties’ inputs are collected and matched,
a E replaces the state of logic contract F with old state s,
then execute f (s) to get MPC outputs, i.e., return values r and
new states s(cid:48).

5.1.4 Distribution phase

This phase aims to adopt an fair distribution protocol Procfadis
to atomically conﬁrm the MPC outputs’ commitments (i.e.,

7The old states that the called f read in execution. E reads f -needed old

states commitments from BC according to f ’s read set P f .Ps.

8

TENET Clients ( ¯P)

TENET Network ( ¯EE F ,P

)

TENET Blockchain (BCTC,V )

Global
setup
phase

send T X i

pk ← BC.TC.register(pki)

send T X i

col ← BC.TC.deposit(Q)

initialize p ← (cid:104) f , q,tn(cid:105)
broadcasts p

+

generateIDp

generates idp ← Hp
broadcasts (cid:104)idp, p(cid:105)

Negotiation
phase
(Procanego)

Execution
phase

generates kx
i
Cxi ← [Enckx
broadcasts ACKi ← (cid:104)idp,Cxi (cid:105)

(xi), Encpki (kx

i

i ), Pi]

broadcasts in ← (cid:104)xi, kx

i , si, ks
i (cid:105)

if Pj ∈ ¯PM is challenged
in ← (cid:104)xi, kx
i , si, ks
i (cid:105)
sends T Xres ← BC.TC.response(idp, EncpkE

(in))

gets T X i

pk and reads pki

p(cid:48) ← (cid:104)adrV , f , ¯P,Cx, q(cid:105)
sends T Xp ← BC.TC.propose(idp, p(cid:48), τres, τcom)

Cs ← BC.getStates(V , f ), read T Xp, PoPp

propose

execute

challenge

punish

if ¯PM ⊂ ¯P depart the protocol
send T Xcha ← BC.TC.challenge(idp, ¯PM)

checks PoPres and reads T Xres

M ⊂ ¯PM still depart

if ¯P(cid:48)
sends T Xpns ← BC.TC.punish(idp, ¯P(cid:48)

M, q)

(cid:88)

(cid:88)

evaluates f (s) based on s
get s(cid:48), r

Distribution
phase
(Procfadis)

commit

, kr

← [Enc

i ), 0, Pi]

i), Encpki (ks(cid:48)
(s(cid:48)
(ri), Encpki (kr
(ks, kr)

generates ks(cid:48)
C(cid:48)
ks(cid:48)
s(cid:48)
i
i
C(cid:48)
← [Enckr
ri
i
Ek ← EncpkE
ˆHCs ← Hash([HCsi
|1..n])
proo f ← (cid:104)HP , HF , ˆHCs (cid:105)
sends T Xcom ← BC.TC.commit(idp, proo f ,C(cid:48)

i ), 0, Pi]

s(cid:48) ,C(cid:48)

r, Ek)

reads PoPcom, Ek

(cid:88)

complete

sends T Xk ← BC.TC.complete(idp, [Encpki (ks

i )], [Encpki (kr

i )])

sends T Xout ← BC.TC.timeout(idp)

↑ S1

↑ S2

↑ S1

↑ S2

↑ S3

↑ S1

↑ S2

↑ S3

Figure 2: The TENET protocol πTENET. The ¯EE F ,P
means a TENET Network holding TEE devices E with deployed F ,P . BCTC,V
means the TENET Blockchain with deployed TENET contract TC and data contract V . Procanego refers to the anonymous negotiation protocol.
Procfadis refers to the fair distribution protocol. Double dashed arrows refer to reading from the blockchain and double arrows refer to sending
a transaction to the blockchain. Normal arrows mean off-chain communication in secure channels. All parties communicate with E in ¯E in
secure channels, i.e., messages broadcast by parties are signed and then encrypted by pkE of ¯E, and all messages broadcast by ¯E are also signed
by skE . Therefore, for simplicity, we omit to mark ciphertext in communications between ¯P and E, but will explicitly mark the ciphertext in
each transaction sent to the blockchain.

9

,Cri) on-chain and reveal the plaintext outputs (i.e., s(cid:48)
Cs(cid:48)
i, ri)
i
to corresponding parties respectively, meanwhile, ensuring
that parties receiving their plaintext outputs at the same time.
The Procanego also proceeds in three steps.

i, ri

ˆHCs

s(cid:48),C(cid:48)

s(cid:48),C(cid:48)

s(cid:48),C(cid:48)

S1: Each E generates symmetric keys ks(cid:48)

, kr to com-
putes commitments of s(cid:48)
,Cri, and
thus getting Cs(cid:48)
i
generates a proo f = (cid:104)HP , HF , ˆHCs (cid:105)
for proving the
MPC-caused state transition. Here the
refers to
hash of the whole array of old state commitment, i.e.,
]|1..n), similarly to ˆHCx . Then, E sends T Xcom =
Hash([HCsi
BC.TC.commit(idp, proo f ,C(cid:48)
r, Ek) to commit the outputs
on-chain. We note that the published C(cid:48)
r includes all el-
ements of normal Cs(cid:48),Cr except the ciphertext of ks, kr so
that parties with only C(cid:48)
r cannot decrypt them to get the
s(cid:48), r. Instead, since the generated ks(cid:48)
, kr varies from differ-
ent E, we require each E attach the its keys’ ciphertext
Ek ← EncpkE (ks(cid:48)
, kr) to its T Xcom so that when the T Xcom is
conﬁrmed, other E will decrypt the Ek to use the same keys
thus avoiding the inconsistency of these keys. Moreover, the
proo f in T Xcom proves the validity of state transition caused
by the MPC program f in following way: The signed T Xcom
means that an veriﬁed enclave E endorses that by enforc-
ing a privacy policy P (matching HP ), it evaluate the MPC
program { of logic contract F (matching HF ) based on old
state s (matching ˆHCs). Therefore, by trusting the integrity and
conﬁdentiality of E, if the V .veri f y( f , proo f . ˆHCs) called by
BC.TC.commit checks that HP , HF in proo f match recorded
HP , HF in V and the HCs in proo f matches the current state
commitments8 of V , V then accepts the state transition and
updates V ’s current state commitment with Cs(cid:48), which signals
the COMMIT of the MPC outputs.

s(cid:48),C(cid:48)

i )], [Encpki(kr

S2: When T Xcom has been conﬁrmed on-chain, each
E checks the PoPcom of T Xcom and read keys ks(cid:48)
, kr
from the T Xcom, then, sends an transaction T Xk =
BC.TC.complete(idp, [Encpki(ks
i )]) to complete
the ks(cid:48)
, kr to conﬁrmed C(cid:48)
r. The T Xk also refunds deducted
collaterals to each party and ﬁnish this MPC proposal. Here,
the atomicity and standard fairness of output distribution are
achieved as follows: In S1, each party Pi has received the in-
complete outputs’ commitments but cannot decrypt them with-
out corresponding ks(cid:48)
i . In S2, each E ﬁrst veriﬁes PoPcom to
ensure that MPC outputs have been committed on BC. Then,
each E independently sends T Xk to ﬁnish the protocol with
COMPETE. Since the time of sending T Xk to BC’s transaction
pool and the communication between parties and honest Ex-
ecutors can be ignored, parties will get the ks, kr from T Kk
at the same time, which ﬁnally achieves standard fairness
as long as at least one E honestly sends T Xk. Otherwise, if
T Xcom is not successfully conﬁrmed on the blockchain, T Xk
will consequently cannot be released to complete the protocol
before the block height τcom. Then, parties of the MPC go to

i , kr

8V reads f -related state commitments related according to T Xcom.Ps. We

ignore it for simplicity.

10

S3.

S3: If there is no E in ¯E successfully stops (by T Xpns)
or completes (by T Xk) the MPC proposal before the block
height τcom, any Pi can send a T Xout to refunds their collaterals.
T Xout also ﬁnishes the MPC with TIMEOUT. We note that this
scenario only happens when the T Xcom is not accepted by V
due to the mismatching of old state commitments’ hash so
that the subsequent T Xk cannot be released.

6 Enclave Facilities

6.1 Enable TENET on Existing Blockchain

To be interoperable with existing blockchains, TENET is de-
signed to depend on contract-based infrastructure to support
MPC-enabled conﬁdential smart contract. A service provider
of TENET should perform a one-time global initialization
of the target blockchain ﬁrst, then anyone can interact with
the blockchain and TENET Network to evaluate the MPC
program.

6.1.1

Initialize TENET blockchain

A service provider of TENET deploys a TENET contract TC
on the blockchain to get the TENET Blockchain, marked as
BC. TC is constructed by the conﬁg of ¯E, e.g., pkE and adrE ,
so that users can authenticate each E and build secure chan-
nel with all E of ¯E. Moreover, TC also allows users to call
TC.register to register their public key, so that each E can
get parties’ registered encryption keys pki on BC to encrypt
private data by their corresponding parties’ public keys respec-
tively. Moreover, TC provides several functions to manage the
life cycle of each MPC proposal, e.g., TC.complete, which
is called by T Xcom to verify the validity of state transition by
calling V .veri f y. The pseudocode of TC is shown in Algo-
rithm 1 and how TC interacts with ¯E and parties has been
illustrated in Figure 2.

6.1.2

Initialize TENET network

Anyone with a TEE device can instantiate an TEE device with
the TENET enclave program (as is shown in Algorithm 2)
to get an E and the one itself becomes a TENET Executor
E. Given that one becomes the ﬁrst E, the E of this ﬁrst E
generates the conﬁg (i.e., pkE , adrE ) of the TENET Network
¯E. Then, the enclaves of other E must be attested by one of
E in a speciﬁc ¯E to get the network ¯E’s conﬁg (pkE , skE )
and (adrE , keyE ), and join the ¯E. Therefore, any E can join
the ¯E and contribute to the liveliness and scalability of ¯E. We
stress that it’s easy to expand our key synchronization to a
more secure method, e.g., distributed key generation protocol,
which is out of scope of this paper.

Algorithm 1: TENET contract (TC)

Algorithm 2: TENET enclave program (E)

// Can be deployed to existing blockchains

1 Function constructor(pkE , adrE )

// called by TE N E T service provider
pkE , adrE ← pkE , adrE // for secure channel
Prpls ← []

2

3

4 Function register(pki)

// called by T Xpk
ParPKs[msg.sender] ← pki

5

6 Function deposit(Q)

// called by T Xcol
Coins[msg.sender] ← Coins[msg.sender] + Q

7
8 Function propose(idp, p(cid:48), τres, τcom)

// called by T Xp from TEE
require(Prpls[idp] = /0)
Prpls[idp].{V , f , ¯P,Cx, q, τres, τcom, hcp} ←
p(cid:48).{adrV , f , ¯P,Cx, q}, τres, τcom, BC.getHeight()
// deduct collaterals before execution
for Pi ∈ ¯P do

9

10

11

12

13

Coins[Pi] ← Coins[Pi] − Prpls[idp].q
require(Coins[Pi] ≥ 0)
Prpls[idp].status ← SETTLE
14
15 Function challenge(idp, ¯PM)

// called by T Xcha from TEE
for Pi ∈ ¯PM do

Prpls[idp]. ¯P[Pi].cha ← true

16

17

18 Function response(idp, EncpkE

(in))

// called by T Xres from parties
Prpls[idp]. ¯P[msg.sender].res ← EncpkE

(in)

20 Function punish(idp, ¯P(cid:48)

M)

// called by T Xpus from TEE
require(BC.getHeight() > Prpls[idp].hcp + τres)
require(Prpls[idp].status = SETTLE)
M |

| ¯P(cid:48)
|Prpls[idp]. ¯P− ¯P(cid:48)

M |

)

r f col = Prpls[idp].q ∗ (1 +
for Pi ∈ (Prpls[idp]. ¯P − ¯P(cid:48)

M) do

Coins[Pi] ← Coins[Pi] + r f col

Prpls[idp].status ← ABORT

26
27 Function commit(idp, proo f ,C(cid:48)

s(cid:48) ,C(cid:48)
r)
// called by T Xcom from TEE
require(Prpls[idp].status = SETTLE)
if V .verify(Prpls[idp]. f , proo f . ˆHCs ) then

30

32

31

s(cid:48) )

Prpls[idp].{Cr} ← {C(cid:48)
r}
V .setStates(Prpls[idp]. f ,C(cid:48)
Prpls[idp].status ← COMMIT
33 Function complete(idp, Encpki (ks(cid:48)
// called by T Xk from TEE
require(Prpls[idp].status = COMMIT)
for Pi ∈ Prpls[idp]. ¯P do
Prpls[idp].{Cs(cid:48)
i

36

34

35

{Encpki (ks(cid:48)

i ), Encpki (kr

.Encpki (ks(cid:48)
i )}

), Encpki (kr))

Coins[Pi] ← Coins[Pi] + Prpls[idp].q
V .setStates(Prpls[idp]. f , Prpls[idp].Cs(cid:48) )
Prpls[idp].status ← COMPLETE

i ), Cri .Encpki (kr

i )} ←

19

21

22

23

24

25

28

29

37

38

39

40 Function timeout(idp)

// called by T Xout from parties
require(BC.getHeight() > Prpls[idp].hcp + τcom)
require(Prpls[idp].status (cid:54)= COMPLETE)
for Pi ∈ Prpls[idp]. ¯P do

Coins[Pi] ← Coins[Pi] + Prpls[idp].q

Prpls[idp].status ← TIMEOUT

41

42

43

44

45

A E can be initialized in two ways: (i) initialized with a security
parameter κ to create a new TENET Network ¯E, or (ii) attest and
being attested by other E to synchronize the conﬁg of an existing
¯E. In both ways, the new E ﬁnally get a conﬁg
pkE , skE , adrE , keyE , τres, τcom, where τres, τcom are timeout
parameters of πTENET

// For deploying of F ,P . We ignore the idp

management

1 Function deploy(F ,P , adrV )
bind (cid:104)F ,P , adrV (cid:105)
2
return adrF

3

// For enforcing MPC programs

4 Function generateIDp(p)
5

p, idp, status ← p, Hash(p), GENERATEIDP
return (cid:104)idp, p(cid:105)

6

7 Function propose(ACK, T Xpk)
8

if status (cid:54)= GENERATEIDP or currentTime > p.tn or
MeetPolicy(ACK,P .P f . ¯P) (cid:54)= 1 then abort
p(cid:48), status ← (cid:104)adrV , p. f , ¯P, ACK.Cx, p.q(cid:105), SETTLE
return T Xp(idp, p(cid:48), τres, τcom)
11 Function execute(in, T Xp, PoPp,Cs)
12

10

9

if status (cid:54)= SETTLE or verifyPoP(bcp, T Xp, PoPp) (cid:54)= 1 then

abort
¯PM ← /0
for xi, kx

i , si, ks

i in in.{x, kx, s, ks}
(xi), EncT X i
newCxi = [Enckx
i ), Pi]
newCsi = [Encks
(si), EncT X i
i ), Pi]
if newCxi (cid:54)= T Xp.Cxi or newCsi (cid:54)= Csi then

(kx
(ks

pk.pki

pk.pki

i

i

¯PM ← ¯PM ∪ {Pi}

if | ¯PM| > 0 then
return ¯PM

bcp, status ← EXECUTE, PoPp.getLastBlock()
s(cid:48), r ← evaluate F . f (x) based on s
ks(cid:48)
C(cid:48)
s(cid:48)
i

i), 0, Pi], [Enckr

(ri), 0, Pi]

i

24

23

← [Enc

, kr ← Gen(1κ)
, C(cid:48)
ks(cid:48)
ri
i
goto commit()
25
26 Function challenge( ¯PM)
27

(s(cid:48)

if status (cid:54)= SETTLE then abort
if | ¯PM| > 0 then

return T Xcha(idp, ¯PM)

30 Function punish(T Xcha, T Xres, PoPres)
31

if status (cid:54)= SETTLE or verifyPoP(bcp, T Xcha, PoPcha) (cid:54)= 1

then abort
¯P(cid:48)
M ← /0
for Pi ∈ ¯PM do
xi, kx
i , si, ks
newCxi = [Enckx
newCsi = [Encks
if verifyPoP(bcp, T X i
or newCxi (cid:54)= T Xp.Cxi or newCsi (cid:54)= Csi then

res.{xi, kx
i , si, ks
i }
(xi), Encpki (kx
i ), Pi]
(si), Encpki (ks
i ), Pi]
res, PoPres) (cid:54)= 1

i ← T X i

i

i

if | ¯P(cid:48)

M ∪ {Pi}

¯P(cid:48)
M ← ¯P(cid:48)
M| > 0 then
status ← ABORT
return T Xpns(idp, ¯PM)

43 Function commit()
44

46

45

if status (cid:54)= EXECUTE then abort
proo f , status ← (cid:104)HF , HP , ˆHCs (cid:105), COMMIT
return T Xcom(idp, proo f ,Cs(cid:48) ,Cr)
47 Function complete(T Xcom, PoPcom)
48

if status (cid:54)= COMMIT or verifyPoP(bcp, T Xcom, PoPcom) (cid:54)= 1

then abort

49

50

11

status ← COMPLETE
return T Xk(idp, [Encpki (ks(cid:48)

i )|1..n], [Encpki (kr

i )|1..n])

13

14

15

16

17

18

19

20

21

22

28

29

32

33

34

35

36

37

38

39

40

41

42

7 System Security

In this section we present the underlying security considera-
tions of TENET.

7.1 Protocol Security

To guarantee security for πTENET, we achieve four security
properties. Intuitively, they can be explained as the following:
Conﬁdentiality. The private parameters, return values and
contract states are always kept private to their corresponding
parties during the whole protocol.
Anonymity. During the negotiation protocol, a set of apriori-
unknown parties will ﬁnally reach a consensus about an MPC
proposal without knowing each other’s identities.
Financial Fairness. At least one TENET Executor is honest,
then either (i) the protocol correctly completes execution of
MPC program or (ii) all honest parties knows that setup failed
and stay ﬁnancially neutral or (iii) all honest parties know the
protocol abort, stay ﬁnancially neutral, and malicious parties
must have been ﬁnancially punished or (iv) all honest parties
know the protocol timeout and stay ﬁnancially neutral.
Standard Output Fairness. At least one TENET Executor is
honest, then either (i) the new states and return values have
been committed on-chain and all parties know the plaintext
of return values and new states in almost the same time, or
(ii) the new states and return values can not be committed
on-chain and none of parties or TENET Executors can know
the plaintext of new states and return values.

. The protocol
Theorem 1 (Informal statement).
πTENET satisﬁes conﬁdentiality, anonymity, ﬁnancial
fairness, and standard output fairness

7.2 Architecture Security

TENET aims to enable conﬁdential smart contract with MPC
on any contract-enabled blockchain. Here, we analyse archi-
tecture security of TENET by considering its implementation.
An adversary can corrupt malicious parties of MPC, malicious
Executors, or a combination of both.

We note that parties of MPC are only required to send
and receive transactions from the blockchain and exchange
protocol messages with multiple TENET Executors in TENET
Network. Parties can implement the client by themselves
using diverse set of entirely different code bases in practice,
possibly using memory-safe languages such as Go and Rust.
Hence, we focus on the TENET Executors in the following.
To prevent malicious TENET Executors from departing the
protocol, related works [11] assume a unique Executor in-
centivized by money to adhere the protocol. These solutions
suffer low availability a lot because the system is fragile to
unexpected crash of the unique Executor. TENET involves

multiples TENET Executors to avoid single point failure and
furthermore achieves the consistency among these multiples
TENET Executors in TENET protocol. Thus, we assume that
the goal of a malicious TENET Executor is to exploit the
enclave program at runtime. Enclaves have a well-deﬁned in-
terface and any attack has to be launched using this interface.
A malicious TENET Executor can provide fake data through
these interfaces to try to exploit a memory-corruption vulnera-
bility in the low-level enclave code to launch (a) a code-reuse
attack, e.g., by manipulating enclave stack memory, or (b) a
data-only attack, e.g., to leak information about private data
of an MPC. For (a) we assume a standard code-reuse defense
such as control-ﬂow integrity or ﬁne-grained code randomiza-
tion. For (b), since parties communicate with TEE devices in
secure channels, and all private data are sent to blockchain in
ciphertext, TEE devices will resist data leakage. Although we
prototype TENET Executor in C++, we note that it’s easy to
tackle both attack vectors by using memory-safety languages,
such as Python and Rust.

8 Evaluation

System implementations. We express the P in JSON and
V ,F in Solidity smart contracts in version 0.8.10 [13]. We
use Ganache [29] as BC and the SGX [9] with TENET enclave
program as E.
Methodology and setup. To evaluate the effectiveness of
TENET, we propose 2 research questions.
• Q1: What’s the cost of setup and deployment for enabling

MPC on the blockchain by using TENET?

• Q2: What’s the cost of evaluating an MPC program by

using TENET?

The experiment is based on Ubuntu 18.04 with 32G memory
and 2.2GHz Intel(R) Xeon(R) Silver 4114 CPU. We apply
TENET to 6 contracts with 14 MPC programs. As is shown in
Table 2, the LOC of these contracts varies from tens to hun-
dreds. The involved parties of these 14 MPC programs varies
from 2 to 11. Although the gas cost of a speciﬁc transaction
is deterministic, it also varies from transaction arguments.
Therefore, we send each transaction 5 times with different
arguments to get the average.

Table 2: The LOC of contracts. #MPC refers to the number of
MPC programs; The #F , #V , and #P refer to LOC of the private
contract, data contract, and privacy policy respectively.

Name

#MPC #F #V #P

SupplyChain
Scores
ERC20Token
YunDou
Oracle
HTLC

1
1
3
3
2
4

39
95
55
105
60
200

37
120
118 213
240
37
433
58
307
48
526
90

12

8.1

Initialization and Setup Cost

9 Discussion

To answer Q1, we discuss the gas cost of deploying the TC
contract and each contract in Table 2. The result is shown in
Figure 3.
Gas cost of initialization. In global initialization phase,
TENET costs 4.5M gas to deploy the TC contract to enable
MPC programs in existing blockchains. This cost is only paid
by TENET service provider for once, thus is mostly irrelevant.
Gas cost of global setup. Each party pays 12.7k gas to
register(reg.) its public key and 4.2k gas to deposit(dep.)
its coins. Moreover, since each party only pays and does it
once, the gas cost of global setup phase is acceptable.

8.2 Transaction Cost

Gas cost of evaluating MPC programs. The right part of
Figure 3 shows the transaction costs of all 14 MPC pro-
grams in 6 contracts. In general, TENET reduces gas by 9.4%
against Fastkitten that requires n+1 transactions to secure an
MPC program. Speciﬁcally, for 6 MPC programs with only 2
parties, TENET costs 1.0-1.11X gas to Fastkitten. However,
for other 8 MPC programs (including all 5 MPC programs
with more than 2 parties), TENET costs only 0.55-0.98X gas
against Fastkitten. When the number of parties increases to
10 and 11, the cost of TENET signiﬁcantly decreases to 0.55X
and 0.58X respectively. Overall, we conclude that TENET
evaluates MPC programs in not only an securer adversary
model but also lower cost.
Off-chain cost of evaluating MPC programs. Normally, all
14 MPC programs complete in 3 blockchains interactions,
where the negotiation phase costs 0.21-0.58s, the execution
phase costs 0.39-1.15s, and the distribution phase costs 0.30-
0.77s. Most time 3-5s is spent on verifying the conﬁrmed
T Xp and T Xcom respectively.

Figure 3: The gas cost of TENET. "Fastkitten" refers to the
gas cost sum of n + 1 transactions required by evaluating an MPC
program by Fastkitten. Here we implement the protocol of Faskkitten
on Ethereum. "TXp", "TXcom" and "TXk" refers to gas cost of
T Xp, T Xcom, T Xk in πTENET respectively.

13

Expanding policy to meet general-purpose need. In cur-
rent syntax, the owner of private data is speciﬁed to a sin-
gle party’s address, limiting the owner to a speciﬁc account.
However, in the real-world, the owner could be a group or
committee. We can deﬁnitely expand the party in policy to an
predicates which corresponds to an complex access control
system. Finally, It’s also possible to allow a owner to transfer
his ownership to others, for which the TENET can match the
plaintext secret with on-chain ciphertext, encrypt the secret
with transferee’s public key and record the ownership transfer
event on-chain.
Expanding to multi-party privacy-preserved computa-
tion. Currently, the data is bound to the encryption commit-
ments stored in a on-chain data contract, which indicate small
size and simple structure of private data. However, the private
data in some promising scenarios (e.g., joint AI training) with
large volume or complex data structures are not suitable to be
stored on-chain. We note that TENET can replace the encryp-
tion commitments in policy to hash commitments, so that no
matter what’s the data structure or where the data is stored, it
can be identiﬁed and used as inputs to the MPC program. As
for more complex computation, developer could just bind the
code commitment (e.g., code hash) on-chain, so that the code
expressing complex computation logic (e.g., AI training) by
any language can be identiﬁed by the commitment and exe-
cuted in TEEs. Moreover, the 2rd generation (e.g., 2rd version
SGX) breaks the memory limitation of enclaves, which also
contributes to this tendency. In this way, although parties have
to persist the preimage data corresponding to commitments
of each transaction thus sacriﬁce some stateless, the anony-
mous negotiation and fair distribution protocol can be easily
adapted to off-chain big data scenarios.

10 Conclusion

In this paper, we have developed a novel framework, TENET,
to support off-chain MPC-enabled conﬁdential smart contract.
Comparing with current solutions, while parties and enclaves
in TENET system have no need to persist states or transaction-
speciﬁc data, TENET furthermore supports apriori-unknown
parties anonymously negotiate with others to join an MPC and
delivers the MPC outputs in a standard fair manner. Moreover,
by introducing an improved challenge-response mechanism,
TENET guarantee the availability and security of each MPC
program in presence of byzantine adversary, which is able
to corrupt all parties and all-but-one TEE executors. TENET
not only secures an MPC program by only 3 transactions in
adversary model. During our evaluation of TENET in both ex-
amples and real-world smart contracts, for all MPC programs
that involving 2 to 11 parties, TENET only cost 0.55-0.98 gas
(0.91 on average) against the state-of-the-art.

TCdep.reg.Sup.Sco.ERC.YunRan.HTLC2p3p2p3p2p3p2p11p2p10p2p2p2p2pDifferent Phases of Contracts0.0x104100.0x104200.0x104300.0x104400.0x104Gas CostinitializesetupdeployFastkittenTXpTXcomTXkReferences

[1] Martín Abadi, Mihai Budiu, Ulfar Erlingsson, and Jay
Ligatti. Control-ﬂow integrity principles, implementa-
tions, and applications. ACM Transactions on Informa-
tion and System Security (TISSEC), 13(1):1–40, 2009.

[2] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso
Frassetto, and Ahmad-Reza Sadeghi. The guard’s
dilemma: Efﬁcient Code-Reuse attacks against intel
SGX. In 27th USENIX Security Symposium (USENIX
Security 18), pages 1213–1227, Baltimore, MD, August
2018. USENIX Association.

[3] Ferdinand Brasser, Urs Müller, Alexandra Dmitrienko,
Kari Kostiainen, Srdjan Capkun, and Ahmad-Reza
Sadeghi. Software grand exposure: SGX cache attacks
are practical. In 11th USENIX Workshop on Offensive
Technologies (WOOT 17), Vancouver, BC, August 2017.
USENIX Association.

[4] Jo Van Bulck, Marina Minkin, Oﬁr Weisse, Daniel
Genkin, Baris Kasikci, Frank Piessens, Mark Silberstein,
Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx.
Foreshadow: Extracting the keys to the intel SGX king-
In 27th
dom with transient Out-of-Order execution.
USENIX Security Symposium (USENIX Security 18),
page 991–1008, Baltimore, MD, August 2018. USENIX
Association.

[5] Benedikt Bünz, Shashank Agrawal, Mahdi Zamani, and
Dan Boneh. Zether: Towards privacy in a smart contract
world. In Joseph Bonneau and Nadia Heninger, editors,
Financial Cryptography and Data Security, pages 423–
443, Cham, 2020. Springer International Publishing.

[6] Nathan Burow, Scott A Carr, Joseph Nash, Per Larsen,
Michael Franz, Stefan Brunthaler, and Mathias Payer.
Control-ﬂow integrity: Precision, security, and perfor-
mance. ACM Computing Surveys (CSUR), 50(1):1–33,
2017.

[7] Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang,
Jonathan Katz, Samuel Steffen, Benjamin Bichsel,
Mario Gersbach, Noa Melchior, Petar Tsankov, and Mar-
tin Vechev. zkay: Specifying and Enforcing Data Privacy
in Smart Contracts. pages 1759–1776, 2019.

[8] Raymond Cheng, Fan Zhang, Jernej Kos, Warren He,
Nicholas Hynes, Noah Johnson, Ari Juels, Andrew
Miller, and Dawn Song.
Ekiden: A Platform for
Conﬁdentiality-Preserving, Trustworthy, and Perfor-
mant Smart Contracts. 2019 IEEE European Symposium
on Security and Privacy (EuroS&P), 00:185–200, 2019.

[9] Victor Costan and Srinivas Devadas. Intel sgx explained.
IACR Cryptol. ePrint Arch., 2016(86):1–118, 2016.

[10] Victor Costan, Ilia Lebedev, and Srinivas Devadas. Sanc-
tum: Minimal hardware extensions for strong software
In 25th {USENIX} Security Symposium
isolation.
({USENIX} Security 16), pages 857–874, 2016.

[11] Poulami Das, Lisa Eckey, Tommaso Frassetto, David
Gens, Kristina Hostáková, Patrick Jauernig, Sebastian
Faust, and Ahmad-Reza Sadeghi. Fastkitten: Practi-
cal smart contracts on bitcoin. In 28th USENIX Secu-
rity Symposium (USENIX Security 19), pages 801–818,
Santa Clara, CA, August 2019. USENIX Association.

[12] Lucas Vincenzo Davi, Alexandra Dmitrienko, Stefan
Nürnberger, and Ahmad-Reza Sadeghi. Gadge me if
you can: secure and efﬁcient ad-hoc instruction-level
randomization for x86 and arm. In Proceedings of the
8th ACM SIGSAC symposium on Information, computer
and communications security, pages 299–310, 2013.

[13] ethereum. Solc 0.5.17, July 2021.

[14] Alex Gluchowski.

Zk rollup: scaling with zero-

knowledge proofs. 2019.

[15] Daniel Gruss, Julian Lettner, Felix Schuster, Olya Ohri-
menko, Istvan Haller, and Manuel Costa. Strong and
efﬁcient cache side-channel protection using hardware
transactional memory. In 26th {USENIX} Security Sym-
posium ({USENIX} Security 17), pages 217–233, 2017.

[16] Intel. Resources and response to side channel l1 terminal

fault, Dec 2021.

[17] Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen,
and Charalampos Papamanthou. Hawk: The Blockchain
Model of Cryptography and Privacy-Preserving Smart
Contracts. 2016 IEEE Symposium on Security and Pri-
vacy (SP), pages 839–858, 2016.

[18] David Maier, Rachel Pottinger, AnHai Doan, Wang-
Chiew Tan, Abdussalam Alawini, Hung Q Ngo, Ying
Yan, Changzheng Wei, Xuepeng Guo, Xuming Lu, Xi-
aofu Zheng, Qi Liu, Chenhui Zhou, Xuyang Song, Bo-
ran Zhao, Hui Zhang, and Guofei Jiang. Conﬁdentiality
Support over Financial Grade Consortium Blockchain.
pages 2227–2240, 2020.

[19] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic
cash system. Decentralized Business Review, page
21260, 2008.

[20] Job Noorman, Pieter Agten, Wilfried Daniels, Raoul
Strackx, Anthony Van Herrewege, Christophe Huygens,
Bart Preneel, Ingrid Verbauwhede, and Frank Piessens.
Sancus: Low-cost trustworthy extensible networked de-
vices with a zero-software trusted computing base. In
22nd {USENIX} Security Symposium ({USENIX} Secu-
rity 13), pages 479–498, 2013.

14

[21] OpenZeppelin. Upgrading smart contracts, Jan 2022.

[22] Indrajit Ray, Ninghui Li, Christopher Kruegel, Ranjit
Kumaresan, Tal Moran, and Iddo Bentov. How to Use
Bitcoin to Play Decentralized Poker. Proceedings of
the 22nd ACM SIGSAC Conference on Computer and
Communications Security, 2015.

[23] Mark Russinovich, Edward Ashton, Christine Avanes-
sians, Miguel Castro, Amaury Chamayou, Sylvan Cleb-
sch, and et al. Ccf: A framework for building conﬁ-
dential veriﬁable replicated services. Technical report,
Microsoft Research and Microsoft Azure, 2019.

[24] Jaebaek Seo, Byoungyoung Lee, Seong Min Kim, Ming-
Wei Shih, Insik Shin, Dongsu Han, and Taesoo Kim.
Sgx-shield: Enabling address space layout randomiza-
tion for sgx programs. In NDSS, 2017.

[25] Ming-Wei Shih, Sangho Lee, Taesoo Kim, and Marcus
Peinado. T-sgx: Eradicating controlled-channel attacks
against enclave programs. In NDSS, 2017.

[26] Rohit Sinha. Luciditee: A tee-blockchain system for
policy-compliant multiparty computation with fairness.
2020.

[27] Second State and Oasis Labs. Conﬁdential Ethereum

Smart Contracts. Technical report, 12 2020.

[28] Bhavani Thuraisingham, David Evans, Tal Malkin,
Dongyan Xu, Arka Rai Choudhuri, Matthew Green, Ab-
hishek Jain, Gabriel Kaptchuk, and Ian Miers. Fairness
in an Unfair World: Fair Multiparty Computation from
Public Bulletin Boards. Proceedings of the 2017 ACM
SIGSAC Conference on Computer and Communications
Security, pages 719–728, 2017.

[29] trufﬂesuite. Ganache, July 2021.

[30] Edgar Weippl, Stefan Katzenbeisser, Christopher
Kruegel, Andrew Myers, Shai Halevi, Ranjit Kumare-
san, and Iddo Bentov. Amortizing Secure Computation
with Penalties. Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security,
2016.

[31] Edgar Weippl, Stefan Katzenbeisser, Christopher
Kruegel, Andrew Myers, Shai Halevi, Ranjit Ku-
maresan, Vinod Vaikuntanathan, and Prashant Nalini
Improvements to Secure Computation
Vasudevan.
with Penalties. Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security,
pages 406–417, 2016.

[32] Gavin Wood et al. Ethereum: A secure decentralised
generalised transaction ledger. Ethereum project yellow
paper, 2014.

15

