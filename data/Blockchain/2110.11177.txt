Decentralised Trustworthy Collaborative Intrusion Detection System for IoT

Guntur Dharma Putra∗§, Volkan Dedeoglu†, Abhinav Pathak∗¶, Salil S. Kanhere∗§ and Raja Jurdak‡
∗UNSW, Sydney †CSIRO Data61, Brisbane ‡QUT, Brisbane §CSCRC, Australia ¶BITS, Pilani

1
2
0
2

t
c
O
1
2

]

R
C
.
s
c
[

1
v
7
7
1
1
1
.
0
1
1
2
:
v
i
X
r
a

Abstract—Intrusion Detection Systems (IDS) have been the
industry standard for securing IoT networks against known
attacks. To increase the capability of an IDS, researchers
proposed the concept of blockchain-based Collaborative-IDS
(CIDS), wherein blockchain acts as a decentralised platform
allowing collaboration between CIDS nodes to share intrusion
related information, such as intrusion alarms and detection
rules. However, proposals in blockchain-based CIDS overlook
the importance of continuous evaluation of the trustworthiness
of each node and generally work based on the assumption
that the nodes are always honest. In this paper, we propose a
decentralised CIDS that emphasises the importance of building
trust between CIDS nodes. In our proposed solution, each
CIDS node exchanges detection rules to help other nodes
detect new types of intrusion. Our architecture ofﬂoads the
trust computation to the blockchain and utilises a decentralised
storage to host the shared trustworthy detection rules, ensuring
scalability. Our implementation in a lab-scale testbed shows
that the our solution is feasible and performs within the
expected benchmarks of the Ethereum platform.

Index Terms—blockchain, IoT, intrusion detection system, col-
laborative, scalability, trust management

1. Introduction

Intrusion Detection Systems (IDS) have been widely
deployed as a means of securing IoT networks, with the
goal of detecting malicious activity. In general, IDS can
be categorised into two groups based on their underlying
mechanics: signature-based; and anomaly-based. Signature-
based IDS identiﬁes incoming attacks by matching the
network trafﬁc with known intrusion signatures or rules.
Anomaly-based techniques observe certain disparities in
network trafﬁc using machine learning approaches.

In recent years, an expansion of the attack surface has
been inevitable, partially due to the adoption of IoT devices
in diverse areas. This has consequently escalated the impor-
tance of defending the network from emerging threats [1].
Unfortunately, conventional IDS that work in isolation may
be easily compromised, since they are unaware of new at-
tacks which are not in their detection database. Researchers
have thus proposed utilising multiple IDS to work together,
referred to as Collaborative-IDS (CIDS), in which each IDS
node shares its expertise and experience, e.g., alarms and
attack signatures, to build collective knowledge of the recent
attacks and increase the detection accuracy [2].

the

use

have

explored

Researchers

of
recently
blockchain, the technology behind Bitcoin, to enhance the
performance of CIDS. For instance, blockchain is utilised to
provide a transparent layer for sharing detection signatures
[3]. The decentralised nature of blockchain also ensures
fault tolerance and removes the need of a fully trusted third
party in managing collaboration between CIDS nodes [4].
A peer-to-peer consensus algorithm in block generation is
employed to build a trusted database of CIDS detection
models [5].

However, proposals of blockchain-based CIDS overlook
the importance of continuous evaluation of each node’s
trustworthiness and generally work based on the assumption
that the nodes are always honest. In fact, a trusted node
may later be compromised and share untruthful detection
rules to contaminate the rule detection database which would
potentially expose the network to attacks [6]. To achieve
trustworthy and effective collaboration in CIDS, continuous
evaluation of trustworthiness of CIDS nodes is required,
which can be derived from their collaboration behaviour.
The shared detection rules database would grow signiﬁcantly
as the collaboration continues, making scalability another
key factor to consider. Additionally, there is a need for
secure and transparent trust mechanisms with the goal of
providing auditability.

In this paper, we propose a trustworthy CIDS archi-
tecture that continuously evaluates the trustworthiness of
the CIDS nodes by evaluating the quality of the detection
rules contributed by each IDS node. Each participating
CIDS node can update its knowledge with the trustworthy
detection rules to detect new attacks. We utilise a peer-to-
peer decentralised storage to maintain a copy of the shared
trustworthy detection rules, thus ensuring scalability. We
divide the participating nodes into three categories, namely
validator, contributor and regular nodes, each of which has
a different role in the system. We also design two smart
contracts, Trust and Reputation Management (TRM) and
Storage smart contract, to quantify each node’s trustwor-
thiness and manage the decentralised storage. Our architec-
ture ofﬂoads trust computation to the TRM smart contract
which reduces the computation load for each CIDS node.
We design a smart contract-based consensus algorithm to
achieve collaborative detection rule validation and avoid an
adversary from contributing deceptive detection rules. We
design our architecture as a blockchain agnostic platform
which can be implemented on any blockchain instantiation
that supports smart contracts. While we use signature-based
CIDS as an illustrative example, the trust management con-

 
 
 
 
 
 
cept can be generalised to other types of CIDS.

In summary, we make the following contributions:

• We propose a trustworthy CIDS architecture that
continuously evaluates contributions
from each
CIDS node to protect the network from invalid de-
tection rules. We present transparent and accountable
trust mechanisms that provide auditability.

• Our proposed CIDS architecture ofﬂoads the trust
computation and trustworthy detection rules to the
blockchain and the decentralised storage, thus reduc-
ing the load on each CIDS node.

• Our trust mechanism separates the trust score for
each contribution (rules) and overall trustworthiness
of the CIDS node. As such, each CIDS node can
conveniently infer the quality of the rules by looking
at both scores.

• We develop a proof-of-concept implementation of
our proposed architecture in a private Ethereum net-
work hosted on a lab-scale testbed. We evaluate our
architecture in terms of the evolution of trust scores,
smart contract latency and Ethereum gas consump-
tion. The results show that the our solution is feasible
and performs within the expected benchmarks of the
Ethereum platform.

The remainder of the paper is organised as follows.
We present our proposed architecture with its underlying
assumptions in Section 2. We outline the trust and reputation
system in Section 3, while the CIDS framework is discussed
in Section 4. We present the performance evaluation of our
solution in Section 5. The related works are discussed in
Section 6 and we conclude our work in Section 7.

2. Proposed Architecture and Assumptions

In this section, we describe our decentralised CIDS
architecture by elaborating the fundamental components and
outlining the threat model. Lastly, we explain the assump-
tions in the present study.

2.1. Architectural Overview

We present the overview of our proposed system in
Figure 1. We design our architecture to span across multiple
organisational networks, each of which typically comprises
multiple smart devices with varying computational and stor-
age capacity. In each organisation, we require at least a
single CIDS node which acts as a signature-based IDS node
that monitors the network for any attack occurrence. CIDS
nodes communicate with other CIDS nodes through the
TCP/IP protocol suite with an industry-standard encryption
mechanism to ensure security, e.g., Transport Layer Security
(TLS).

We model our system as C = (C, B, I), where C is a
set of collaborating CIDS nodes that share intrusion related
information, and B is the blockchain and I is the decen-
tralised storage network. In our model, each CIDS node is

TABLE 1. IMPORTANT NOTATIONS AND THEIR DESCRIPTION.

Notations
C, B, I
cv, cc, cr
kp and ks
ra,j
S e
a,j
ta,j and T m
a
Rdb and Rloc
SCtrm and SCstr
Ev
Eo
ra,j
ϕe
j
Mra,j
Zcca
Dc

ra,j

Description

CIDS, blockchain and dec. storage network
a validator, contributor and regular node
the public and secret key
an IDS rule from cca
validity score of ra,j from cve
the trust score of ra,j and cca
the global and local rules database
the TRM and storage smart contracts
new rule blockchain event

new validated rule blockchain event

validation result from cve
description of ra,j according to IDMEF [7]
a zip archive of Mra,j and ra,j
decision rule function

connected to both blockchain B and decentralised storage
network I for collaboration and storing shared detection
rules, which contain a pattern of malicious network attacks,
such as ﬁle hashes, malicious domains or particular byte
sequences. The blockchain network B is the main hub for
collaboration, through which each CIDS node exchanges
information via blockchain transactions. Each CIDS node
collaboratively builds a global trusted rules database Rdb
that contains a collection of detection rules contributed by
each CIDS node. Each CIDS node also keeps a local copy
of an IDS database Rloc ∈ Rdb. We summarise important
notations used in this paper in Table 1.

2.1.1. CIDS network. All CIDS nodes form the CIDS
network, which is connected to the other components of the
system, e.g., blockchain network B and decentralised storage
network I. We assume that all CIDS nodes are equipped with
sufﬁcient resources to run a blockchain client. Each CIDS
node holds a corresponding blockchain public-private key
pair {kp, ks} and is identiﬁable by the public key kp. We de-
ﬁne three types of IDS nodes, denoted C = (CV , CC, CR),
where CV , CC and CR correspond to validator, contributor
and regular nodes, respectively.

Validator nodes: Validator nodes, denoted CV =
{cv1, cv2, . . . , cvn}, are in charge of maintaining the CIDS
including registration of new CIDS nodes and
network,
validation of contributed detection rules from other nodes by
means of off-chain processes [3]. Validator nodes validate
detection rule ra,j submitted by other CIDS nodes via a
consensus algorithm, which assigns a trust score to each
rule. Validator nodes then append the validated rules to the
trusted rules database Rdb.

Contributor nodes: We deﬁne a contributor node
{cca|∀cc ∈ CC} as a CIDS node that contributes a detection
rule ra,j to the CIDS network C. Each cca has a trust score
Ta derived from the trustworthiness of its contributions.

Regular nodes: We refer to the rest of the CIDS nodes
in C as regular nodes, denoted CR = {cr1, cr2, . . . , crk}.

Figure 1. An overview of the proposed decentralised CIDS.

Regular nodes are only interested in using validated IDS
rules in Rdb to update their local rules database Rloc by
subscribing to the system for a notiﬁcation of newly vali-
dated ra,j in Rdb. A cr can conveniently examine the trust
scores of both rule ra,j and node cc to decide which rules
to be included into their Rloc based on a locally determined
threshold. A regular node is passive and consequently does
not get assigned a trust score.

2.1.2. Blockchain network. We design our architecture
to be blockchain agnostic, which supports any commod-
ity blockchain platform with a prerequisite of supporting
Turing-complete smart contract execution [8]. In this work,
we consider a single permissioned blockchain B, wherein
access is limited to certain known parties, which helps to
build the ﬁrst layer of defence. To avoid malicious actions,
registration of new CIDS node is handled by CV . In general,
blockchain B is used to track the contributions of each cc
and to store the metadata of the contributed detection rules.
Note that, we do not store the IDS rules on-chain but in the
decentralised storage layer.

We deploy two smart contracts onto blockchain B. First,
a Trust and Reputation Management (TRM) smart contract
SCtrm manages the contributions of all cc by quantifying
them via a transparent and veriﬁable TRM mechanism (see
Section 3). Second, a storage smart contract SCstr maintains
the hash and metadata of each ra,j to provide a connection
between the blockchain and the decentralised storage net-
work.

2.1.3. Decentralised storage network. We employ IPFS,
the InterPlanetary File System, as the decentralised storage
network [9]. We separate the data storage to prevent the
blockchain size from becoming too large and thus ensuring
scalability. The decentralised storage network is managed
by CV , which limits the access only to subscribed cr.

2.2. Threat Model and Assumptions

In our architecture, we assume that the adversaries are
able to launch a poisoning attack aimed to inject misleading

detection rules to the trusted database Rdb. The adversaries
can also compromise a maximum of (cid:96) validator nodes. How-
ever, we require that there are n available validator nodes
such that n = 3(cid:96) + 1 to tolerate (cid:96) faulty validator node(s),
i.e., 1/3 fault tolerance as in PFBT [10]. The adversaries
are also capable of performing trust and reputation attacks
as follows:

•

Self-promoting attacks: A malicious actor may try
to increase its own reputation score by submitting
and validating a detection rule by itself.

• Bad-mouthing attacks: A malicious node may at-
tempt to ruin the reputation of another node pro-
viding negative validation results regardless of the
quality of the contributed model.

• Ballot-stufﬁng attacks: A node may collude with
other nodes to deliberately increase their reputation
scores, for instance by submitting the same detection
rules multiple times.

• Whitewashing or newcomer attacks: A node at-
tempts to rejoin the network using a new identity
aiming to reset its previously recorded bad behaviour
and obtain a fresh reputation score.

We assume that our system inherits the assumptions of
a commodity blockchain platform, which include security
against peer-to-peer and consensus attacks, such as Sybil,
eclipse and 51% attacks [11]. We assume that each validator
holds a sufﬁcient local detection rules database to validate
the submitted detection rules and detect whether a submitted
rule is malicious. All CIDS nodes in our architecture, re-
gardless of their type, are bound to cryptographic primitives,
which prevents manipulation and duplication of blockchain
identities, i.e., public and private key pairs.

3. Trust and Reputation Management

We design the Trust and Reputation Management (TRM)
to evaluate the trustworthiness of each contributor node cc
in the network C and also to protect the network from any
corrupted or malicious detection rules. Each cc will obtain
a trust score after submitting a detection rule from which

   LegendInternet...SmartdevicesRegular linkValidatorNodeContributorNodeRegularNodeOfficenetworkSmart factorynetworkHomenetworkCIDS linkand

0 ≤ δinv

n
(cid:88)

e=q+1

Se

a,j <

δinv(n − q)
2

(4)

Then from (2), (3), and (4) we get the lower and upper
bounds for ta,j as

0 ≤ ta,j ≤ δval,
0 ≤ ta,j < δinv/2,

for δinv < 2δval
for δinv ≥ 2δval
Subsequently, the trustworthiness score T m

a of cca after
contributing m detection rules can be calculated based on
the quality of each contributed rule:

(5)

T m
a = (1 − γ)

m
(cid:88)

j=1

γ(m−j)ta,j

(6)

where 0 < γ ≤ 1 is the decaying constant to give more
weights to recent contributions relative to older ones. To
get the lower and upper bounds for T m
a , let us assume that
ta,j is constant. Then, from (6) we get

T m
a =

1 − γm
1 − γ

(1 − γ)ta,j

= (1 − γm)ta,j.

(7)

From (5) and (7), we get the lower and upper bounds of
T m
a

as

0 ≤ T m
0 ≤ T m

a ≤ (1 − γm)δval,
a < (1 − γm)δinv/2,

for δinv < 2δval
for δinv ≥ 2δval

(8)

We implement the trust calculation for both ta,j and
T m
in the SCtrm smart contract, using which each cv
a
can cooperate to calculate the score and collaboratively
determine valid rules. In addition, the SCtrm smart contract
also holds the computed trust scores. As the calculation
and storage are ofﬂoaded to blockchain B, regular nodes
cr can conveniently query blockchain B and examine ta,j
and T m
scores to infer the quality of the detection rules,
a
thus reducing the computation loads. We elaborate on how
the TRM mechanism is used in practice in Section 4.

4. Collaborative Intrusion Detection System

In this section, we describe the mechanism of our pro-
posed CIDS framework. We present the overview of the
underlying processes as a sequence diagram in Figure 3,
which displays the process from when cca submits ra,j until
the rule is validated and stored in the rules database. Refer
to Table 1 for a summary of the notations used in this paper.
We assume there is a set of n online validator nodes
CV = {cv1, cv2, . . . , cvn} to initialise the network C and
to deploy the smart contracts SCtrm and SCstr. As we
support less than 1/3 of the online cv to be byzantine
nodes, we require at least n = 4 online cv for PBFT
fault tolerance [10]. Note that the CIDS network C is a
private network, thereby all CIDS nodes should be known
in advance, although they are not necessarily trusted. We
presume that each new CIDS node is able to generate a

Figure 2. The trust relationship model.

the score is calculated. In general, the score is increased
when cc contributes valid detection rules and decreased
when submitting compromised rules. Intuitively, a high trust
score indicates a trustworthy contributor node, while a low
score indicates otherwise.

Figure 2 shows the trust relationship model in our pro-
posed TRM. Suppose a contributor node cca∈ CC submits
a detection rule ra,j. A validator node cve validates ra,j,
and based on its accuracy, gives a score S e
a,j ∈ [0.5, 1] to
indicate valid rules, or S e
a,j ∈ [0, 0.5) to indicate invalid
rules. As such, S e
functions as a vote from cve and
a,j
consequently we have n scores {S1
a,j, S2
a,j} for
each ra,j as there are n available validator nodes. We use
the following formula to calculate the aggregated trust value
of ra,j, denoted by ta,j:

a,j, . . . , Sn

ta,j =

1
n

n
(cid:88)

e=1

Se

a,jδe

(1)

where

δe =

(cid:40)

if S e
δval,
δinv, otherwise,

a,j ≥ 0.5

where δval and δinv are non-negative weights associated
with a valid and invalid rule, which can be determined via a
heuristic method. To favour trustworthy contributions over
malicious ones, we set δval < δinv ≤ 1 so that malicious
contributions are assigned a higher weight. We propose a
mechanism to collaboratively determine valid rules based
on the scores from each validator node, which is elaborated
in Section 4. A valid ra,j is appended to Rdb, while invalid
ra,j would not be included.

Without loss of generality, let us assume that the ﬁrst q

votes are valid and the rest are invalid, then we get

ta,j =

(cid:32)

1
n

δval

q
(cid:88)

e=1

Se

a,j + δinv

n
(cid:88)

(cid:33)

Se
a,j

e=q+1

(2)

Since S e
rules respectively, we get the following bounds

a,j ∈ [0.5, 1] and S e

a,j ∈ [0, 0.5) for valid and invalid

qδval
2

≤ δval

q
(cid:88)

e=1

Se

a,j ≤ qδval

(3)

ccacv1...submitsra,jcv2cvnta,jupdatesassigns1Sa,j2Sa,j nSa,jTa122234of Zcca, denoted H(Zcca ), required for ﬁle retrieval. cca is
then required to invoke transaction T xr to SCtrm:

T xr = [ H(Zcca ) (cid:107) timestamp (cid:107) Sigcca ]

(10)

is

on
key
for authentication. Subsequently, SCtrm triggers a
ra,j to notify all validator nodes that a

Sigcca
where
hash(H(Zcca )(cid:107)timestamp)
kscc
blockchain event Ev
new rule ra,j has been added to the queue for validation.

the
using

signature

signing

the

Using the hash address H(Zcca ), each validator node
cv retrieves and extracts Zcca from storage I for off-chain
validation [3]. Here, each cv compares ra,j against its local
database to conﬁrm whether ra,j performs as per Mra,j .
The validator also inspects if ra,j has been previously
submitted either by the same cca or another node to avoid
ballot-stufﬁng attack. Depending on the validation results, a
validator node cve may either approve or reject ra,j, along
with a score S e
a,j that indicates the quality of ra,j. To submit
the vote about the validity of ra,j, all validator nodes submit
T xj

c,e to SCtrm:
c,e = [ ϕe
where ϕe
j ∈ {1, −1} is the validation result to indicate a
valid (1) or invalid rule (−1) and Sigcve is the signature on
hash(ϕe
a,j(cid:107)timestamp) using signing key kscv , which
is used for authentication. We adapt a weighted majority
rule [12] to make a decision on the validity of ra,j. We
deﬁne a decision rule Dc : xj → {−1, 1} which receives
xj = (T xj
c,n) as an input and outputs a
decision {1, −1}, where 1 and −1 indicate valid and invalid
rules, respectively. We deﬁne Dc as follows:

a,j (cid:107) timestamp (cid:107) Sigcve ]

c,2, . . . , T xj

c,1, T xj

j (cid:107) S e

j(cid:107)S e

T xj

(11)

Dc(xj) :=

(cid:40)

1,

if 1/n (cid:80)n
−1, otherwise

e=1 Se

a,jϕe

j ≥ q ,

(12)

where q ∈ (0, 1] is the threshold of a valid rule, which can
be determined via a heuristic method.

SCtrm proceeds with the decision making process, once
all votes from all cv have been received, as described in
Algorithm 1. A valid ra,j would be appended to Rdb, while
an invalid ra,j would be ignored. SCtrm calculates the trust
score ta,j and T m
as deﬁned in (1) and (6), respectively.
a
Subsequently, SCtrm invokes T xf to SCstr:

T xf = [ H(Zcca ) (cid:107) ta,j (cid:107) timestamp ]

(13)

to include the newly approved ra,j to the rules database
Rdb. To notify all regular nodes about the new rule, SCstr
triggers a blockchain event Eo
ra,j . A regular node cr can
now retrieve Zcca from I using the address H(Zcca ). After
inspecting the score ta,j and metadata Mra,j , cr may opt to
include ra,j into its local IDS rules database Rloc for better
detection of new attacks.

Unlike typical consensus mechanisms where each device
sends messages to each other (broadcast message), in our
proposed mechanism, the participating nodes are only re-
quired to send a message to the smart contract, which acts as
an aggregator. Thus, our proposed mechanism would work

Figure 3. The workﬂow of the proposed CIDS platform.

public-private key pair {kp, ks}. A new CIDS node can join
C as a regular node by sending a request Reqcr over a secure
channel to any cv:

Reqcr = (cid:104)kp, attrcr, timestamp, Signcr(cid:105)

(9)

where kp is the node’s public key, attrcr is an attribute
which also includes its IP address and a unique identiﬁer,
while Signcr is the signature of the message. Once the
request is approved, the corresponding validator node will
give a response containing the details for IPFS connection
(e.g., the IP address and the hash address of the bootstrap
node) and the addresses of both SCtrm and SCstr, using
which the nodes can access the network rules database Rdb
and obtain updates when a new detection rule has been
added to Rdb.

SCtrm facilitates collaborative rule validation to deter-
mine whether a new detection rule should be included to
Rdb based on the votes from each cv. To submit a new
rule ra,j, a cca node is required to invoke a function on
SCtrm which then triggers a blockchain event to notify all
regulator nodes ∀cr ∈ CR about the newly submitted rule.
Note that this smart contract-based consensus mechanism is
not intended to replace the built-in consensus algorithm as
it serves a different purpose and runs on top of the built-in
consensus algorithm of the underlying blockchain platform.
Although the validator nodes are relatively trusted nodes in
C, we incorporate our rule validation consensus mechanism
to mitigate if some cv’s are compromised. Next, we explain
our proposed rule validation consensus mechanism.

Let cca be a contributor node that is about to contribute
a new detection rule ra,j to Rdb. Firstly, cca needs to
add a zip ﬁle Zcca = (cid:10)ra,j, Mra,j
(cid:11) to the decentralised
storage network I, where Mra,j is the description of ra,j. To
provide compliance and interoperability, we follow Intrusion
Detection Message Exchange Format (IDMEF) [7] as the
format of Mra,j . Subsequently, cca obtains the hash address

SCstrSCtrmccacv11ZccaH(Zcca)2Txr3cv2cvn...Era,jvEra,jvEra,jv4Txf5Blockchain BDec. storage I67Era,joH(Zcca)89Zccacr1cr2crkTxc,1jTxc,2jTxc,njEra,joEra,joAlgorithm 1 Consensus mechanism for rule validation.
Require: T xc, n, q and CR
Output: T xf or ∅

calculate ta,j
update T m
a
calculate Dc(xj)
if Dc(xj) == 1 then
return T xf

1: r count ← getState()
2: if r count == (n − 1) then
3:
4:
5:
6:
7:
8:
9:
10:
11: else
12:
13:
14: end if

saveT oState(r count++)
return ∅

return ∅

end if

else

(cid:46) from the blockchain
(cid:46) all validation received
(cid:46) as in (1)
(cid:46) as in (6)
(cid:46) as in (12)

(cid:46) ra,j is added to Rdb

(cid:46) ra,j is rejected

(cid:46) write to blockchain

on any blockchain instantiation that supports smart contracts
for on-chain logic execution.

5. Performance Evaluation

This section presents the performance evaluation of the
proposed CIDS architecture based on our proof of concept
(POC) implementation. We ﬁrst describe the details of the
POC that was implemented on a lab-scale private Ethereum
network. Then, we present the experimental results to show
the feasibility of our solution, which include trust evaluation
for honest and malicious nodes and the blockchain perfor-
mance with regards to latency and gas consumption.

5.1. Implementation Details

We opted for a private Ethereum blockchain as our POC
platform, as Ethereum natively supports smart contracts
written in a Turing complete programming language, Solid-
ity [8]. Ethereum utilises a decentralised environment named
Ethereum Virtual Machine (EVM), as a trusted and secure
platform for decentralised computation [14]. However, we
note that our proposed CIDS architecture can also be im-
plemented in any blockchain platform that offers support
for smart contracts, for instance Hyperledger Fabric and
Sawtooth.

We built a lab-scale testbed which comprises 15 nodes
of Raspberry Pi with different speciﬁcations (7 Raspberry
Pi 3 and 8 Raspberry Pi 4) and a Lenovo ThinkCentre mini
PC (8GB RAM, 2.9 GHz quad-core Intel Core i5 CPU) as
the platform to run our experiments. We selected Raspberry
Pi computers to imitate the different smart devices with
varying capacity, while we used the Lenovo ThinkCentre
as a more powerful node. To orchestrate the CIDS nodes,
we utilise Docker containers1 running on the testbed using
which we simulated a total of 16 nodes: 4 validator, 4
contributor, and 8 regular nodes. We built a private Ethereum

network with a single miner and a private IPFS network for
the decentralised storage. We utilise an open-source IDS,
Snort2, as the signature-based IDS platform, and geth as
the Ethereum client. We wrote a Python v3.8.10 and a bash
script to control and simulate interactions between CIDS
nodes with web3py v5.11 and py-solc v3.2.0 libraries as
the middleware for Ethereum connection and smart contracts
compilation, respectively. We implemented the smart con-
tracts, i.e., SCtrm and SCstr in Solidity v0.6.6 [8], which
offers built-in libraries for computation and veriﬁcation of
hashes efﬁciently.

5.2. Evaluation Results

The following subsections present the experimental re-
sults of our POC implementation. We compare our re-
sults against challenge-based trust mechanism as the base-
line [13], where a CIDS node sends challenge messages to
another CIDS node and waits for the responses (e.g., valid,
invalid, unsure), using which the trustworthiness level is
derived. To mimic similar characteristics with our proposal
(e.g., trust score range), we set the values of the baseline’s
parameters as: forgetting factor λ = 0.85, severity level
φ = 2 and initial trust score τ = 0.

5.2.1. Convergence of the trust score. We evaluate the
convergence of the trust score T m
a by varying the decaying
constant γ and plot the results in Figure 4. This experiment
simulates an honest cc which constantly contributes m = 55
valid detection rules. As we vary the value of γ from
0.9 to 0.8, different weights are allocated for the latest
and the previous ta,j values in calculating the ﬁnal T m
a .
However, as all contributions are valid, T m
converges to a
a
similar level as illustrated in Figure 4, regardless of the γ
value, which conﬁrms the theoretical upper bound of T m
a ,
described in (8). A subtle difference is that lower values of
γ would result in a gradual growth of T m
a , thereby γ can
be tuned according to the practical settings. Figure 4 also
shows a minor ﬂuctuation of T m
a depends on ta.i
values, which are weighted averages of different scores Se
a,j
from each validator cve. Relative to the baseline, our trust
evolution exhibits similar trend of positive interaction with
less ﬂuctuations.

a , as T m

5.2.2. Trust evolution of honest and malicious nodes.
We simulate three contributor nodes (cc1, cc2 and cc3) to
examine the evolution of T m
for different node behaviours
a
over m = 55 contributions. First, cc1 is an honest con-
tributor node that consistently contributes trustworthy rules.
Second, cc2 initially submits trustworthy rules up to m = 25
and turns malicious by contributing false rules afterwards.
Third, cc3 is a compromised node that constantly submits
poor detection rules for the entire simulation. We apply
δval = 0.85, δinv = 0.9, γ = 0.85 as the parameters
and plot the experimental results in Figure 5. While all
T m
continue to grow
a

initially begins at 0, T m

and T m

2

1

1. https://docs.docker.com/engine/

2. https://www.snort.org/

Figure 4. Convergence of T m
for an honest cc
with varying γ, δval = 0.85 and baseline [13].

a

Figure 5. Trust score comparison for an honest
and malicious cc (δval = 0.85, δinv = 0.9,
γ = 0.85).

Figure 6. Comparison of the latency and gas
consumption for rule conﬁrmation, validation
and submission.

(T xc), and 3) rule conﬁrmation (T xf ). We repeated the
experiments 30 times and plot the results in Figure 6. The
average execution latencies are relatively similar for all
transactions, which fall within the range of 3 and 5 seconds.
There is a relatively high variance of the latencies, as there
is no assurance of when the miner processes and appends
the transaction to the blockchain. T xf consumes the least
Gas, while T xc consumes the most Gas among these three
transactions, due to the different amount of required EVM
opcodes (cf. (13), (10), (11)).

Figure 7. Quantitative comparison of trust evolution with baseline [13].

6. Related Works

gradually in a similar rate and start to plateau approxi-
mately at T m
a = 0.75. On the other hand, T m
saturates
3
at approximately T m
a = 0.1, as the validators are assigning
very low Se
declines
signiﬁcantly and saturates at a similar score of T m
for
the rest of the experiment. We note that the scores are in
line with the theoretical bounds of T m
a , as described in (5)
and (8).

a,j scores (non-zero). At m > 25, T m
2

3

We plot the evolution of T m

a against the baseline in Fig-
ure 7. Similar to Figure 5, node cc2 initially acts honestly by
sending valid responses until 25-th interaction, resulting in
high trust scores, and turns malicious by sending invalid and
unsure responses for epoch time > 25. Our trust evolution
exhibits stable and gradual growth and decline when the
node acts honestly and maliciously, respectively. However,
the baseline suffers from undesired ﬂuctuations when the
node acts maliciously, i.e., epoch time > 25, as unsure
responses perturb the slope of the curve, cf. Section 3.B
of [13].

5.2.3. Latency and gas consumption. Ethereum requires
a fee for executing blockchain transactions, with Gas as
the unit of measurement. The Gas is calculated based on
the required EVM opcodes during the execution of smart
contract’s functions [8]. To examine the feasibility of our
blockchain implementation, we measure the gas consump-
tion and execution latency for the following smart con-
tract functions: 1) rule submission (T xr), 2) rule validation

There have been several proposals in the literature about
blockchain incorporation in CIDS. Li et al. proposed a
framework called CBSigIDS which aims to avoid insider
attacks, where malicious nodes can generate untruthful sig-
natures to contaminate the network [3]. Here, blockchain
is incorporated to provide a mechanism for sharing detec-
tion signatures between different IDS nodes in a veriﬁable
manner. CBSigIDS also implements trust computation to
evaluate the reputation levels of the IDS nodes by means
of a challenge-based trust mechanism, wherein the CIDS
nodes are required to send challenge messages to known
acquaintances to assess the trustworthiness level in detecting
known attacks. While the authors incorporated blockchain,
CBSigIDS does not utilise smart contracts to take full
advantage of blockchain.

In [13], blockchain is incorporated in a CIDS solution
to store and disseminate calculated trust scores with the
underlying evidence that justiﬁes the trust calculation. The
solution mainly aims to enhance the overall security by
recording misbehaving CIDS nodes. Similar to [3], the so-
lution employs a challenge-based trust evaluation. However,
the solution does not explore incentives and penalties as a
reward mechanism and no performance evaluation has been
undertaken.

Blockchain has also been proposed for building a CIDS
framework in Software Deﬁned Network (SDN) environ-
ment where SDN controllers also act as CIDS nodes [15].
The framework employs permissioned blockchain to guard
to manipulate detection
against adversaries that attempt

01020304050Epoch0.00.20.40.60.8Trust score=0.90=0.85=0.80Baseline01020304050m0.00.20.40.60.8TmaTm1(cc1)Tm2(cc2)Tm3(cc3)TxfTxrTxc01234567Latency (s)010 k20 k30 k40 k50 k60 k70 kGas consumptionLatencyGas consumption0102030405060epoch0.00.20.40.60.8Trust scoreOursBaselinesignatures by sharing untruthful detection signatures to the
participating SDN controllers. The authors proposed digi-
tal certiﬁcates to establish trust between SDN controllers
by designing a scheme called Certiﬁcate-Chain (C-Chain)
which is essentially a blockchain-based distributed Public
Key Infrastructure (PKI). However, the framework does not
quantitatively evaluate the SDN controllers’ trustworthiness.
In addition, the framework utilises IPFS as a storage medium
for detection signature ﬁles. However, the framework does
not impose penalties for fraudulent manipulations.

Alkadi et al. proposed a CIDS platform for cloud based
IoT networks, wherein blockchain facilitates immutable data
exchange between several cloud services [16]. In contrast to
signature-based methods, the platform combines blockchain
with a Deep Learning (DL) technique to provide a secure
CIDS with smart contracts in cloud based IoT networks. The
platform utilises a consortium blockchain with a Trusted Ex-
ecution Environment (TEE) for securely logging the trans-
actions between multiple cloud providers, while a Bidirec-
tional Long Short-Term Memory (BiLSTM) DL algorithm
is trained to detect anomalies in the network. However,
this DL platform does not incorporate trust management
for evaluating cloud providers (CIDS nodes) and does not
explore incentive mechanisms for the collaborations.

Another proposal

that uses DL for blockchain-based
CIDS is presented in [4]. The authors designed a col-
laboration framework where blockchain is employed to
consistently train and test detection models for anomaly-
based CIDS. The proposed blockchain-based CIDS aims to
achieve a lifetime learning framework, which is able to grad-
ually build a secure and co-maintained database of labelled
training set for classiﬁcation. The framework adopts Grow-
ing Hierarchical Self-Organising Map with probabilistic re-
labelling (GHSOM-pr) as the off-chain classiﬁer, which can
adapt to the dynamic nature of the co-maintained database.
While the framework introduces Data Coins (DCoins) as
incorporate
the incentives for collaboration,
smart contracts and include mechanisms for trustworthiness
evaluation.

it does not

It is worth noting that even though various techniques
have been proposed to secure CIDS networks, some issues
remain unsolved. For instance, current trust management
mechanisms for CIDS employ a challenge-based method
that was initially designed for Host-based IDS (HIDS) [2].
Challenge-based trust management requires each node to
calculate and store trust scores on the device itself, which
could be seen as redundant. While the scheme may work
well for medium sized networks, challenge-based techniques
would be impractical and raise scalability issues when the
number of CIDS nodes are relatively large.

7. Conclusion

In this paper, we proposed a trust framework to build
a trustworthy CIDS architecture that continuously evaluates
the trustworthiness of the CIDS nodes with regard to the
detection rules contributed by each IDS node. We used
signature-based CIDS as an illustrative example, while our

architecture is blockchain agnostic and could be imple-
mented on any blockchain platform that supports smart con-
tracts. We built a lab-scale testbed to evaluate our proposed
architecture in a private Ethereum network. Our experi-
mental results showed the feasibility of our concept and
that the performance falls within the expected benchmarks
of the Ethereum platform. For future work, we aim to
evaluate the economic model and game theory behind the
fees and incentives mechanism and conduct more extensive
evaluation of our architecture.

Acknowledgements

The authors acknowledge the support of the Commonwealth
of Australia and Cyber Security Cooperative Research Cen-
tre for this work.

References

[1] E. Anthi, L. Williams, M. Slowinska, G. Theodorakopoulos, and
P. Burnap, “A Supervised Intrusion Detection System for Smart Home
IoT Devices,” IEEE IoT Journal, vol. 6, no. 5, pp. 9042–9053, 2019.
[2] C. J. Fung, J. Zhang, I. Aib, and R. Boutaba, “Dirichlet-based trust
management for effective collaborative intrusion detection networks,”
IEEE TNSM, vol. 8, no. 2, pp. 79–91, 2011.

[3] W. Li, S. Tug, W. Meng, and Y. Wang, “Designing collaborative
blockchained signature-based intrusion detection in IoT environ-
ments,” Future Generation Computer Systems, vol. 96, 2019.
J. Liang and M. Ma, “Co-maintained database based on blockchain
for idss: A lifetime learning framework,” IEEE TNSM, vol. 18, no. 2,
pp. 1629–1645, 2021.

[4]

[5] T. Golomb, Y. Mirsky, and Y. Elovici, “CIoTA: Collaborative IoT
Anomaly Detection via Blockchain,” in Workshop on Decentralized
IoT Security and Standards (DISS) 2018, 2018.

[6] G. D. Putra, V. Dedeoglu, S. S. Kanhere, and R. Jurdak, “Towards
scalable and trustworthy decentralized collaborative intrusion detec-
tion system for iot,” in 5th IEEE/ACM IoTDI, 2020, pp. 256–257.

[8]

[7] H. Debar, D. Curry, and B. Feinstein, “The Intrusion Detection Mes-
sage Exchange Format (IDMEF),” Internet Requests for Comments,
RFC Editor, RFC 4765, March 2007.
Solidity, “Solidity - Solidity 0.6.6 documentation,” https://solidity.
readthedocs.io/en/v0.6.6/, 2020, [Online; accessed 4-June-2020].
[9]
J. Benet, “Ipfs - content addressed, versioned, p2p ﬁle system,” 2014.
[10] M. Castro, B. Liskov et al., “Practical byzantine fault tolerance,” in

OSDI, vol. 99, no. 1999, 1999, pp. 173–186.

[11] M. A. Ferrag, M. Derdour, M. Mukherjee, A. Derhab, L. Maglaras,
and H. Janicke, “Blockchain technologies for the internet of things:
Research issues and challenges,” IEEE IoT Journal, vol. 6, no. 2, pp.
2188–2204, 2019.

[12] S. Leonardos, D. Reijsbergen, and G. Piliouras, “Weighted voting on
the blockchain: Improving consensus in proof of stake protocols,”
International Journal of Network Management, vol. 30, no. 5, 2020.
[13] N. Kolokotronis, S. Brotsis, G. Germanos, C. Vassilakis, and S. Shi-
aeles, “On blockchain architectures for trust-based collaborative in-
trusion detection,” IEEE SERVICES 2019, pp. 21–28, 2019.

[14] G. Wood et al., “Ethereum: A secure decentralised generalised trans-
action ledger,” Ethereum project yellow paper, vol. 151, no. 2014,
pp. 1–32, 2014.

[15] W. Fan, Y. Park, S. Kumar, P. Ganta, X. Zhou, and S.-y. Chang,
“Blockchain-enabled Collaborative Intrusion Detection in Software
Deﬁned Networks,” in 19th IEEE TrustCom, 2020, pp. 967–974.
[16] O. Alkadi, N. Moustafa, B. Turnbull, and K.-K. R. Choo, “A Deep
Blockchain Framework-enabled Collaborative Intrusion Detection for
Protecting IoT and Cloud Networks,” IEEE IoT-J, vol. 4662, 2020.

