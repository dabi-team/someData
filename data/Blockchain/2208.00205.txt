BlockScope: Detecting and Investigating Propagated
Vulnerabilities in Forked Blockchain Projects

Xiao Yi1, Yuzhou Fang1, Daoyuan Wu1∗ and Lingxiao Jiang2
1The Chinese University of Hong Kong
2Singapore Management University
∗Corresponding author. Contact: dywu@ie.cuhk.edu.hk

2
2
0
2

l
u
J

0
3

]

R
C
.
s
c
[

1
v
5
0
2
0
0
.
8
0
2
2
:
v
i
X
r
a

Abstract—Due to the open-source nature of the blockchain
ecosystem, it is common for new blockchains to fork or partially
reuse the code of classic blockchains. For example, the popular
Dogecoin, Litecoin, Binance BSC, and Polygon are all variants
of Bitcoin/Ethereum. These “forked” blockchains thus could
encounter similar vulnerabilities that are propagated from Bit-
coin/Ethereum during forking or subsequently commit fetching.
In this paper, we conduct a systematic study of detecting and
investigating the propagated vulnerabilities in forked blockchain
projects. To facilitate this study, we propose BlockScope, a novel
tool that can effectively and efﬁciently detect multiple types of
cloned vulnerabilities given an input of existing Bitcoin/Ethereum
security patches. Speciﬁcally, BlockScope adopts similarity-based
code match and designs a new way of calculating code similarity
to cover all the syntax-wide variant (i.e., Type-1, Type-2, and
Type-3) clones. Moreover, BlockScope automatically extracts and
leverages the contexts of patch code to narrow down the search
scope and locate only potentially relevant code for comparison.

Our evaluation shows that BlockScope achieves good precision
and high recall both at 91.8% (1.8 times higher recall than
that in the state-of-the-art ReDeBug while with close precision).
BlockScope allows us to discover 101 previously unknown vul-
nerabilities in 13 out of the 16 forked projects of Bitcoin and
Ethereum, including 16 from Dogecoin, 6 from Litecoin, 1 from
Binance BSC, and 4 from Optimism. We have reported all the
vulnerabilities to their developers; 40 of them have been patched
or accepted, 66 were acknowledged or under pending, and only
4 were rejected. We further investigate the propagation and
patching processes of discovered vulnerabilities, and reveal three
types of vulnerability propagation from source to forked projects,
as well as the long delay (mostly over 200 days) for releasing
patches in Bitcoin forks (vs. ∼100 days for Ethereum forks).

I.

INTRODUCTION

Blockchain [62] and DeFi (Decentralized Finance) [72]
are emerging in recent years. A good development in the
blockchain ecosystem is that many projects are open-source.
This is particularly true for the public blockchains like Bitcoin
and Ethereum. As a result, new blockchains could fork or
partially reuse the code of classic blockchains to speed up
the development. Notably, Bitcoin is the one with most forked
projects — the popular Dogecoin, Litecoin, Dash, Zcash, and
Bitcoin Cash/SV are all variants of Bitcoin. In recent years,
Ethereum was also forked by a number of EVM (Ethereum
Virtual Machine)-compatible chains, such as Binance Smart
Chain (BSC), Polygon, Avalanche Contract Chain, and Opti-
mism (Ethereum’s Layer-2 rollup network).

However, “forked” blockchains could encounter similar
vulnerabilities that appeared in the code of Bitcoin and
Ethereum. Speciﬁcally, a vulnerability could be propagated

from Bitcoin/Ethereum to the forked projects during the initial
fork or subsequently when updated commits are fetched from
Bitcoin/Ethereum. In this paper, we aim to systematically
detect cloned vulnerabilities in forked blockchain projects and
investigate how they are propagated and patched.

To facilitate this study and future analysis, we propose
BlockScope, a novel tool that can not only automatically detect
vulnerable clones but also pinpoint the cases already ﬁxed and
their patching process information. To achieve effective and
efﬁcient detection on all the syntax-wide cloned vulnerabilities
(i.e., Type-1, Type-2, and Type-3 clones, as to be deﬁned in
Sec. II-C), BlockScope has two unique designs as compared to
typical code clone detection tools, e.g., [41], [44], [46], [52],
[63], [75]. First, we adopt similarity-based code match, instead
of the hash-based exact match in ReDeBug [41], VUDDY [46],
and MVP [75], so that BlockScope is more tolerant to the
code lines with no exact “abstracted” hashes. Moreover, we
design a new way of calculating code similarity to better
handle the code fragments with inserted/deleted/reordered code
lines. According to our evaluation with the state-of-the-art
ReDeBug tool, our new design greatly reduces false negatives
while only slightly increasing false positives for our problem.
Second, BlockScope automatically extracts and leverages patch
code contexts to locate only potentially relevant code for
comparison. This not only dramatically improves the running
performance for large projects, e.g., 15.4 times faster than
ReDeBug in analyzing Ethereum’s forked projects with more
lines of code (LOC), but also enhances the detection precision
because the context similarity is also being considered.

To evaluate BlockScope, we collect a dataset of 38 security
patches — 32 of them are directly from Bitcoin’s reposi-
tory because there were only four CVEs in the recent ﬁve
years, and the rest six are CVEs of Ethereum reported in
the last three years. With this input, we apply BlockScope
and ReDebug to test 11 most popular forked projects of
Bitcoin and 5 of Ethereum (identiﬁed from nearly the top 100
cryptocurrencies), with 4.2M C/C++ LOC and 3.5M Go LOC,
respectively. The evaluation shows that BlockScope detects
101 true vulnerabilities in all the 13 forked projects (three
projects, Qtum, Avalanche, and Polygon, does not contain
any of the tested vulnerabilities), whereas ReDeBug detects
only 57 vulnerabilities in 11 forked projects. By performing a
thorough code review of all the raw detection results, we ﬁnd
that BlockScope achieves good precision and high recall both
at 91.8%, whereas ReDeBug’s recall is only 51.8% despite its
precision at 95%. Among the 101 vulnerabilities automatically
detected by BlockScope, we are able to identify serious ones

 
 
 
 
 
 
from the top blockchains like Dogecoin, Litecoin, Bitcoin SV,
Binance BSC, and Optimism. This demonstrates the real-world
impact of our work1.

We further investigate how the discovered vulnerabilities2
are propagated from Bitcoin/Ethereum to their forked projects
and understand the patching processes of the 138 cases that
were already ﬁxed in forked projects before our detection.
Speciﬁcally, we reveal three types of vulnerability propagation
from Bitcoin/Ethereum to their forked projects, including the
cases directly forked in the beginning, fetched from vulnerable
commits, and infected with no explicitly vulnerable commits.
Besides vulnerability propagation, we additionally identify
three other propagation that caused false positives and neg-
atives in BlockScope; details in Sec. V-B. As for patch delays,
we ﬁnd that only DigiByte, among the six forked projects
of Bitcoin with enough patched cases, can catch up with
Bitcoin’s patch release schedule. The patch delays for the other
ﬁve are typically long, mostly over 200 days. Compared with
Bitcoin, the result for Ethereum’s forked projects is relatively
acceptable, with half of the patches released within 100 days.

Contributions. To sum up, we make the following major

contributions in this paper:

• (Methodology) We propose novel patch-based clone de-
tection for vulnerable code clones in forked projects, in
which we design (i) a context-based search with similarity
measurement to efﬁciently locate candidate code clones
and (ii) a new way of calculating the similarity between
two code fragments that is immune to Type-1/2/3 clones.
• (Detection) We apply this methodology to detect 101
previously unknown vulnerabilities in the forked projects
of Bitcoin and Ethereum with high precision and recall.
• (Investigation) We further conduct a deep investigation of
the vulnerability propagation and patching processes of
the discovered vulnerabilities, and reveal new ﬁndings.

Ethics. As an ethical research and one contribution of this
paper, we have spent signiﬁcant efforts reporting all the 110
vulnerabilities (including nine false negatives manually iden-
tiﬁed during the evaluation). The details are available in Sec.
IV-D and this anonymous link, https://tinyurl.com/block-scope.

Roadmap. The rest of this paper is organized as follows.
After explaining different blockchain projects and code clone
types in Sec. II, we ﬁrst propose the BlockScope tool in
Sec. III to effectively detect the propagated vulnerabilities
in the forked blockchains. We then evaluate the accuracy
and performance of BlockScope and leverage it to discover
previously unknown vulnerabilities in Sec. IV. We further
analyze how the discovered vulnerabilities are propagated from
Bitcoin and Ethereum to the forked projects and understand
their patching processes in Sec. V. Lastly, Sec. VI reviews the
related work and Sec. VII concludes the paper.

II. BACKGROUND

In this section, we ﬁrst introduce the background of Bit-
coin, Ethereum, and their popular forked projects in Sec. II-A
and Sec. II-B, and then provide the deﬁnition of different code
clone types in Sec. II-C.

1Binance acknowledged our vulnerability report with a bug bounty reward.
2Besides 101 automatically detected cases, we also analyzed 9 that were
false negatives in BlockScope but manually identiﬁed during the evaluation.

Fig. 1: Representative hard forks of Bitcoin.

TABLE I: The basic information of Bitcoin, Ethereum, and
their popular forked projects.

(a) Bitcoin and its forked projects (as of 7 September 2021).

#
1
6
11
12
33
55
59
75
79
80
83
100

#
2
5
14
17
78
199

Name
Bitcoin
Dogecoin
Bitcoin Cash
Litecoin
Bitcoin SV
Dash
Zcash
Bitcoin Gold
Horizen
Qtum
DigiByte
Ravencoin

Code
BTC
DOGE
BCH
LTC
BSV
DASH
ZEC
BTG
ZEN
QTUM
DGB
RVN

Market Cap
$749.70B
$42.55B
$12.02B
$11.88B
$3.24B
$1.79B
$1.64B
$1.04B
$935.27M
$923.88M
$868.91M
$693.34M

Repository
bitcoin/bitcoin
dogecoin/dogecoin
Bitcoin-ABC/bitcoin-abc
litecoin-project/litecoin
bitcoin-sv/bitcoin-sv
dashpay/dash
zcash/zcash
BTCGPU/BTCGPU
HorizenOfﬁcial/zen
qtumproject/qtum
digibyte/digibyte
RavenProject/Ravencoin

(b) Ethereum and its forked projects (as of 6 June 2022).

Name
Ethereum
Binance
Avalanche
Polygon
Celo
Optimism

Code
ETH
BNB
AVAX
MATIC
CELO
OP

Market Cap
$229.87B
$50.69B
$7.65B
$5.15B
$604.02M
$263.36M

Repository
ethereum/go-ethereum
bnb-chain/bsc
ava-labs/subnet-evm
maticnetwork/bor
celo-org/celo-blockchain
ethereum-optimism/optimism

Star
60.3K
13.6K
1.1K
4K
520
1.4K
4.5K
611
202
1.1K
361
932

Star
37.7K
1.6K
1.6K
400
382
1.2K

A. Bitcoin and its Forked Projects

Bitcoin (BTC) [56] is the ﬁrst cryptocurrency that in-
troduced the blockchain technology to the world. Bitcoin
leverages blockchain as a distributed ledger to guarantee
the consensus between different peers. Currently, Bitcoin is,
without doubt, the dominant cryptocurrency, whose market
capitalization takes around 40% of the whole market. Since
Bitcoin is open-sourced, it has nourished many blockchain
projects. Speciﬁcally, among the top 100 cryptocurrencies on
CoinMarketCap [14] as of 7 September 2021, we identiﬁed
that 11 projects directly fork or partially reuse the code of
Bitcoin. We list them in Table Ia and refer to them as Bitcoin’s
forked projects in this paper.

Most forked projects forked only the Bitcoin code, whereas
Bitcoin Cash (BCH), Bitcoin SV (BSV), and Bitcoin Gold
(BTG) also forked Bitcoin’s blockchain, i.e., copying its trans-
action history, as the basis for their own blockchain [39]. They
are known as the “hard forks” of Bitcoin, as each of them
creates a permanent fork of the original Bitcoin’s blockchain.
We present the relationship between Bitcoin and these three
projects in Fig. 1. As we can see, Bitcoin Cash is the earliest
fork, which aims to reduce the transaction fee and improve
the transaction speed of the original Bitcoin. Therefore, they
extend the maximum block size to 32MB, while the original
Bitcoin’s block size limit is 1MB. Bitcoin SV further extends
this limit to 128MB, which leads to another hard fork. Bitcoin
Gold, on the other hand, claims to solve the original Bitcoin’s

2

Block #491407Block #478558Block #1Genesis Block………………BTCBCHBSVBTGBlock #556766Block #478558…………Block #556766……Current BlockCurrent BlockCurrent BlockBlock #491407……Current Blockmonopolized mining problem. Speciﬁcally, they hope that by
enabling mining on commonly available GPUs instead of
specialized ASICs, it can democratize and decentralize the
mining.

Litecoin gets its name from “the light version of Bitcoin”.
Its goal is to provide faster transactions than Bitcoin. No-
tably, instead of using Bitcoin’s SHA-256, Litecoin adopts
Scrypt [22] as the hash function, which offers a less compute-
intensive but more memory-intensive mining process [32].
Dogecoin also leverages Scrypt as the hash function. Indeed, it
copies both Bitcoin’s and Litecoin’s code. Although Dogecoin
reached a market capitalization of over 40 billion USD, it was
initially created as a meme cryptocurrency with an unlimited
total supply [15]. DigiByte is another fork of Litecoin’s code.
Besides SHA-256 and Scrypt, it can work with three more
mining algorithms [24].

Dash is not only a cryptocurrency but also a decentralized
autonomous organization run by a subset of its users called
“masternodes”. Speciﬁcally, anyone with 1,000 Dash can be-
come a masternode in the Dash network and share the block
reward. Besides the standard node functions, the masternodes
can vote on proposals to improve the ecosystem and provide
two additional kinds of transactions, i.e., “InstantSend” and
“PrivateSend” for instant transactions and private transactions,
respectively [18].

Zcash and Horizen are designed to enhance the privacy
for their users. As the original Bitcoin is pseudo-anonymous, it
is possible to decipher the patterns and connections involved,
which may expose all information related to the sender and
the receiver [57]. To tackle this problem, Zcash applies Zero-
Knowledge proof algorithms (called zk-SNARKs) to “shield”
the transactions so that it will not disclose the information
about the coin holders. Similarly, Horizen (formerly known
as ZenCash) is a derivative of Zcash. On top of the zk-
SNARKs system, Horizen adopts a different funding model,
which shares the block reward among miners, developers, and
secure/super node operators, while Zcash just rewards miners
and developers [57].

Qtum is a hybrid blockchain that combines the charac-
teristics of Bitcoin and Ethereum. It introduces an Account
Abstraction Layer to integrate Bitcoin’s Unspent Transaction
Output model with the Ethereum Virtual Machine for smart
contracts to operate [68]. Besides, Qtum adopts Proof-of-
Stake (PoS) consensus mechanism instead of Bitcoin’s Proof-
of-Work (PoW) to simplify the mining process since PoW
it wastes enormous amounts of
is resource-intensive,
electricity on mining coins [36].

i.e.,

Ravencoin is unique in terms of that it was designed for
users to tokenize assets on-chain and transfer ownership via
blockchain transactions [33]. Such assets can be physical or
digital, including gold, in-game items, copyrights, etc [66].

B. Ethereum and its Forked Projects

largest cryptocurrency with a market capitalization of around
230 billion USD as of June 2022. As an open-sourced project,
Ethereum also nourished many blockchain projects. Speciﬁ-
cally, we analyzed all the projects listed on Blockscan [9] and
selected ﬁve of the most popular projects that directly fork
or partially reuse the code of Ethereum. Table Ib presents the
basic information of these forked projects as of 6 June 2022.

Binance is the largest cryptocurrency exchange in the
world. As of 27 July 2022, its 24-hour trading volume reaches
11.7 billion USD [12]. Originally, Binance developed Binance
Chain to provide a marketplace for trading cryptocurrency in
a decentralized manner, with BNB being the native token.
However, as Binance Chain is not EVM-compatible, users
cannot develop decentralized applications (DApps) using smart
contracts [10]. Binance initiated Binance Smart Chain (BSC)
with EVM compatibility to solve this problem. On February
15, 2022, Binance Chain and Binance Smart Chain united
into BNB Chain [17]. Currently, BNB Chain holds around 3.4
million transactions daily, with 2.0 million active wallets [13].

Avalanche aims to solve Ethereum’s issues regarding trans-
action fee, scalability, and programmability, by leveraging a
multi-chain approach [38]. Speciﬁcally, Avalanche combines
three separate blockchain networks, i.e., X-Chain: for issuing
digital assets, C-Chain: for converting Ethereum’s DApps to
Avalanche, and P-Chain: for validating the states of subnets.
Celo is also EVM-compatible. Notably, it provides a client
designed for mobile phone users. Moreover, while the trans-
action fee is paid with the native asset (ETH) on Ethereum,
Celo allows users to pay transaction fees with the native asset
(CELO) and stable coins (cUSD and cEUR) [34].

Polygon and Optimism are Ethereum’s layer-2 networks,
which also target on Ethereum’s scalability and transaction
fee issues. Layer-2 solutions refer to infrastructures or simple
protocols built on top of the Ethereum main chain [20],
i.e., layer-1. Typically, they handle off-chain transactions and
send only compact data to layer-1. Polygon is technically a
sidechain of Ethereum, as it uses its own consensus algorithms
and runs in parallel with the main chain. However, different
from sidechains, Optimism uses Optimistic Rollups [19] to
interact with the main chain and use smart contracts that reside
within Ethereum [23].

C. Deﬁnition of Code Clone Types

Due to the nature of open-source projects, it is common
for projects to reuse parts of code from others. However,
vulnerabilities are always reintroduced due to the casual code
reuses, namely code clones. While code clone detections
are widely studied among the famous open-source projects,
e.g., Linux Kernel, detections for cloned vulnerabilities in
the forked blockchain projects are much less explored. In
this study, it is essential to analyze the cloned code among
the forked blockchain projects. Therefore, we adopt the type
deﬁnitions of code clones from [54] as follows:

Ethereum [73] is the ﬁrst blockchain system with the
capability of constructing Turing-complete smart contracts,
which contain a set of pre-deﬁned rules and regulations for
self-execution. Ether (ETH) is the native cryptocurrency for
maintaining the operations on Ethereum, which is the second

• Type-1 clones refer to two identical code fragments with

variations in whitespaces, layouts, and comments.

• Type-2 clones include Type-1 clones and extend the
variations to identiﬁers, literals, and types, e.g., variable
renaming.

3

Fig. 2: The overall workﬂow of BlockScope and our study.

• Type-3 clones further extend these variations to syntac-
tically similar code with inserted, deleted, or updated
statements.

• Type-4 clones refer to semantically equivalent code frag-
ments but syntactically different, which is out of the scope
of this paper.

In this paper, we focus on the detection of Type-1, Type-2,
and Type-3 code clones. Detecting Type-4 code clones requires
code semantic learning or understanding, which is out of the
scope of typical clone detection tools including BlockScope.

III. BLOCKSCOPE

A. Design Choices and System Overview

To detect the propagated vulnerabilities from the existing
security patches of Bitcoin/Ethereum, we design BlockScope
as a patch-based code clone detection tool. This makes
BlockScope, by nature, more similar to security-oriented clone
detection tools (e.g., ReDeBug [41], VUDDY [46], MVP [75],
and VGraph [28]) rather than the traditional clone detection
tools (e.g., CCFinder [44], CPMiner [52], DECKARD [42],
and SourcererCC [63]) that do not differentiate vulnerable
and patched code inputs. Moreover, since we aim to test all
different blockchain projects, we design BlockScope to be
language-agnostic as similar to ReDeBug. As a result, we do
not perform “program analysis-alike” preprocessing, such as
variable/type/function abstraction in VUDDY, program slicing
in MVP, and code property graph [76] in VGraph, before the
similarity measurement between source and target code.

Besides the choices above, BlockScope offers two unique

designs that are also the major novelty of our methodology:

• Leveraging patch code contexts to search and locate only
potentially relevant code. Since our detection targets are
the propagated vulnerabilities in the forked projects, it is
reasonable to assume that they have similar contexts as the
original patch code in the source repositories. BlockScope
thus leverages the extracted patch code contexts to search
for potentially relevant code in the target repositories
and employs code similarity to ﬁnalize the contexts of
candidate code clones. This not only helps BlockScope
avoid the whole-repository analysis as in typical code
clone detection tools but also improves the precision
because the context similarity is also being considered.
• Adopting similarity-based code match for being more tol-
erant to variant code clones. To cover all the syntax-wide
Type-1, Type-2, and Type-3 clones, we adopt similarity-
based code match, instead of the hash-based exact code

match in ReDeBug [41], VUDDY [46], and MVP [75].
This allows BlockScope to be more tolerant to the code
lines with no exact “abstracted” hashes (i.e., Type-2
clones). Moreover, we design a new way of calculating
code similarity to better handle the code fragments with
inserted/deleted/reordered code lines (i.e., Type-3 clones).

Fig. 2 presents the overall workﬂow of BlockScope in ﬁve
major steps. Firstly, Sec. III-B describes how the Extractor
component or Extractor3 extracts the code contexts from
patches in the source repositories. Secondly, in Sec. III-C,
Searcher leverages the extracted patch contexts to search
for candidate contexts in the target repositories. Thirdly,
Fetcher in Sec. III-D retrieves the patch and candidate
code hunks in the source and target repositories, respec-
tively. Fourthly, Comparator in Sec. III-E employs a new
similarity-based code matching technique to determine the
propagated vulnerabilities from Fetcher’s outputs. Lastly,
for the vulnerabilities already patched, Calculator in Sec.
III-F measures their patch delays in the target repositories.

B. Extracting Patch Contexts from the Source Repositories

Given a security patch from the source project or code
repository (e.g., Bitcoin/Ethereum), BlockScope ﬁrst extracts
its code context. In this paper, we provide an Extractor
component to automatically extract the contexts of patch code
and use its output for system evaluation. In reality, BlockScope
also supports the manually crafted code contexts from security
experts for better accuracy. To distinguish the context of patch
code from that of target code, we call the former “patch
context” and the latter “candidate context”, as shown in Fig. 2.

Unlike ReDeBug that directly takes the entire part of the
nearby code lines (after normalization and tokenization) as
context, Extractor recognizes important variable and func-
tion names as the context keywords and uses these keywords
to search for candidate contexts in the target repositories (as
in Sec. III-C). As a result, we do not require each extracted
keyword to be precise because as long as one of the context
keywords can ﬁnd the correct candidate context, context sim-
ilarity measurement (in Sec. III-C) will automatically exclude
the search results of other incorrect context keywords.

We use the left patch code of Fig. 3 to illustrate the
process of extracting context keywords. After normalizing
and tokenizing each patch code line, Extractor uses the
following heuristics to automatically recognize at most one

3We describe different BlockScope components using their names, e.g.,

Extractor, hereafter.

4

17721773177417751776177717781779178017811782178317841785178617871788178917901791179217931794179517961797179817991800180118021803180418051806180718081809181018111812181318141815181618171818181918201821182218231824182518261827};// Protected by cs_mainstatic ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS];static int64_t nTimeCheck = 0;static int64_t nTimeForks = 0;static int64_t nTimeVerify = 0;static int64_t nTimeConnect = 0;static int64_t nTimeIndex = 0;static int64_t nTimeCallbacks = 0;static int64_t nTimeTotal = 0;bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,                  CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck){    AssertLockHeld(cs_main);    const Consensus::Params& consensus = Params().GetConsensus(pindex->nHeight);    int64_t nTimeStart = GetTimeMicros();    // Check it again in case a previous version let a bad block in    if (!CheckBlock(block, state, !fJustCheck, !fJustCheck))        return error("%s: Consensus::CheckBlock: %s", __func__, FormatStateMessage(state));    // verify that the view's current state corresponds to the previous block    uint256 hashPrevBlock = pindex->pprev == NULL ? uint256() : pindex->pprev->GetBlockHash();    assert(hashPrevBlock == view.GetBestBlock());    // Special case for the genesis block, skipping connection of its transactions    // (its coinbase is unspendable)    if (block.GetHash() == Params().GetConsensus(0).hashGenesisBlock) {        if (!fJustCheck)            view.SetBestBlock(pindex->GetBlockHash());        return true;    }    bool fScriptChecks = true;    if (!hashAssumeValid.IsNull()) {        // We've been configured with the hash of a block which has been externally verified to h        // A suitable default value is included with the software and updated from time to time.         //  relative to a piece of software is an objective fact these defaults can be easily rev        // This setting doesn't force the selection of any particular chain but makes validating         //  effectively caching the result of part of the verification.        BlockMap::const_iterator  it = mapBlockIndex.find(hashAssumeValid);        if (it != mapBlockIndex.end()) {            if (it->second->GetAncestor(pindex->nHeight) == pindex &&                pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&                pindexBestHeader->nChainWork >= UintToArith256(consensus.nMinimumChainWork)) {                // This block is a member of the assumed verified chain and an ancestor of the be                // The equivalent time check discourages hashpower from extorting the network via                //  into accepting an invalid block through telling users they must manually set                 //  Requiring a software change or burying the invalid block, regardless of the s                //  it hard to hide the implication of the demand.  This also avoids having relea                //  that are hardly doing any signature verification at all in testing without ha                //  artificially set the default assumed verified block further back.0e7c52d17751775177617761777177717781778177917791780178017811781178217821783178317841784178517851786178617871787178817881789178917901790179117911792179217931793179417941795179617971798179918001795180118021796180317971804179818051799180618001807180118081802180918031810180418111805181218061813180718141808181518091816181018171811181818121819181318201814182118151822181618231817182418181825     assert(pindex);     // pindex->phashBlock can be null if called by CreateNewBlock/TestBlockValidity     assert((pindex->phashBlock == nullptr) ||            (*pindex->phashBlock == block.GetHash()));     int64_t nTimeStart = GetTimeMicros();      // Check it again in case a previous version let a bad block in     // NOTE: We don't currently (re-)invoke ContextualCheckBlock() or     // ContextualCheckBlockHeader() here. This means that if we add a new     // consensus rule that is enforced in one of those two functions, then we     // may have let in a block that violates the rule prior to updating the     // software, and we would NOT be enforcing the rule here. Fully solving     // upgrade from one software version to the next after a consensus rule     // change is potentially tricky and issue-specific (see RewindBlockIndex()     // for one general approach that was used for BIP 141 deployment).     // Also, currently the rule against blocks more than 2 hours in the future     // is enforced in ContextualCheckBlockHeader(); we wouldn't want to     // re-enforce that rule here (at least until we make it impossible for     // GetAdjustedTime() to go backward).-    if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck))+    if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck))+        if (state.CorruptionPossible()) {+            // We don't write down blocks to disk if they may have been+            // corrupted, so this should be impossible unless we're having hardware+            // problems.+            return AbortNode(state, "Corrupt block found indicating potential hardware f+        }         return error("%s: Consensus::CheckBlock: %s", __func__, FormatStateMessage(state+    }       // verify that the view's current state corresponds to the previous block     uint256 hashPrevBlock = pindex->pprev == nullptr ? uint256() : pindex->pprev->GetBlo     assert(hashPrevBlock == view.GetBestBlock());      // Special case for the genesis block, skipping connection of its transactions     // (its coinbase is unspendable)     if (block.GetHash() == chainparams.GetConsensus().hashGenesisBlock) {         if (!fJustCheck)             view.SetBestBlock(pindex->GetBlockHash());         return true;     }      nBlocksTotal++;      bool fScriptChecks = true;     if (!hashAssumeValid.IsNull()) {         // We've been configured with the hash of a block which has been externally veri         // A suitable default value is included with the software and updated from time          //  relative to a piece of software is an objective fact these defaults can be e         // This setting doesn't force the selection of any particular chain but makes va         //  effectively caching the result of part of the verification.         BlockMap::const_iterator  it = mapBlockIndex.find(hashAssumeValid);Source RepoTarget RepoLocate Candidate Clones(Sec. III-C & III-D)Determine Patch Status(Sec. III-E & III-F) Detecting the Propagated Vulnerabilities (Sec. IV)Investigating the Discovered Vulnerabilities (Sec. V)BlockScopeSecurity PatchPatch ContextCandidateContextFetcherSearcherComparatorCalculatorPatch CodeCandidate CodeExtractorExtract Patch Context(Sec. III-B)Fig. 3: Illustrating BlockScope’s context-based search process for ﬁnding candidate contexts in a target repository.

context keyword per code line. Speciﬁcally, we consider the
tokens with both lower and upper case letters (including some
special characters like “.”) and select the longest one as the
most important variable or function name of one code line.
In this way, BlockScope automatically selects nine context
keywords, as highlighted in red color, from the patch code
context in Fig. 3. As mentioned above, we do not require
each extracted keyword to be precise, and according to our
evaluation in Sec. IV, this simple strategy of automatically
extracting context keywords works well for our problem.

C. Searching for Candidate Contexts in the Target Reposito-
ries

The Searcher component of BlockScope then uses the
extracted context keywords to search for candidate contexts in
the target repositories. The basic idea is to ﬁrst search for the
key statements in target code (via patch context keywords),
then recover the corresponding boundary of each potential
code context, and ﬁnally determine the candidate contexts via
the similarity measurement with the original patch context. To
illustrate this context-based search process, we use Bitcoin’s
patch of checking corrupted blocks and its vulnerable clone in
Dogecoin as a running example. As shown in Fig. 3, the left-
hand side is the patch code hunk (commit 0e7c52dc) from
Bitcoin, while the right-hand side shows the cloned version in
Dogecoin 4. It also illustrates the following three steps.

1) Searching for the key statements. The ﬁrst step is to
ﬁnd the key statements (ks) that are the code statements in the
target code with the searched context keywords. Speciﬁcally,
Searcher ﬁrst leverages git grep to search for all the
code statements that contain the patch context keyword(s)
in the target repositories, and then ﬁnalize the search result
by measuring the similarity between the searched ks with
the original ks. If the measured similarity is higher than
the threshold conﬁgured in BlockScope, we consider it one
potential candidate ks. To minimize the misses and avoid
causing false negatives to the subsequent steps, this step uses

4Note that we only keep the “meaningful” code statements, i.e., empty lines,

comments, and single brackets are removed.

a relatively low threshold (0.25) based on the Normalized
Levenshtein [48] metric, i.e., strsim() used in equation (1).
This is acceptable because among all the searched candidate
kss, we select
the one with the highest similarity as the
ﬁnal candidate ks. Speciﬁcally, given a patch context pc =
{(k1, s1), (k2, s2), ..., (km, sm)}, where (ki, si) represents the
extracted keyword ki of the code statement si, the search result
sri for ki is represented as sri = (ki, [s(cid:48)
in]), where
s(cid:48)
ij is the code statement that contains ki in the target reposi-
tory. We determine s(cid:48)
pq as the ﬁnal candidate ks according to
the equation (1). In the case of Fig. 3, Searcher selects line
5 and 9 (both with the highest similarity) of Dogecoin as the
ﬁnal candidate kss of the UP and DOWN contexts, respectively.

i2, ..., s(cid:48)

i1, s(cid:48)

p, q = arg max

1≤i≤m,1≤j≤n

strsim(si, s(cid:48)

ij)

(1)

Moreover, in the course of implementing the candidate
three automatic optimizations to
context search, we adopt
further improve BlockScope’s context search precision and
avoid unnecessary analysis in the subsequent steps. First,
it excludes the search result with comments and test code.
Second, it excludes the search result with the ﬁle type different
from the patch’s ﬁle type, e.g.,
the patch in Fig. 3 is a
C/C++ source code ﬁle, based on which BlockScope excludes
C/C++ header ﬁles and non-C/C++ source code ﬁles in the
search result. Third, BlockScope excludes the search result
with different statement types. For example, since line 5 in
Fig. 3 is an assignment statement, any search result does not
match the same statement type will be automatically discarded.

2) Determining the boundary of candidate contexts.
Once identiﬁed the candidate ks, the next step of Searcher
is to retrieve the code statements surrounding it and determine
their boundary. Speciﬁcally, we need to expand the one-line
candidate ks into the multi-line candidate context that has the
corresponding boundary as the original patch context. To do
so, we ﬁrst fetch the same number of nearby code statements
from target code as that, represented as C_LINES, in the
patch context. For example, in Fig. 3, if we set C_LINES=5,
Searcher fetches line 1 to 5 and line 7 to 11 for the

5

1AssertLockHeld(cs_main);2assert(pindex);3assert((pindex->phashBlock== nullptr) ||4(*pindex->phashBlock== block.GetHash()));5int64_t nTimeStart= GetTimeMicros();6-if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck))7+if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck)) {8+if (state.CorruptionPossible()) {9+return AbortNode(state, “Corrupt block found ...");10return error("%s: Consensus::CheckBlock: %s", __func__, ...);11uint256 hashPrevBlock= pindex->pprev== nullptr? uint256() : ...;12assert(hashPrevBlock== view.GetBestBlock());13if (block.GetHash() == chainparams.GetConsensus().hashGenesisBlock) {14if (!fJustCheck)1bool ConnectBlock(const CBlock& block, CValidationState& state, ...,2CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck)3AssertLockHeld(cs_main);4constConsensus::Params& consensus = Params().GetConsensus(pindex->nHeight);5int64_t nTimeStart= GetTimeMicros();6if (!CheckBlock(block, state, !fJustCheck, !fJustCheck))7return error("%s: Consensus::CheckBlock: %s", __func__, ...);8uint256 hashPrevBlock= pindex->pprev== NULL ? uint256() : ...;9assert(hashPrevBlock== view.GetBestBlock());10if (block.GetHash() == Params().GetConsensus(0).hashGenesisBlock) {11if (!fJustCheck)Source patch code hunk from BitcoinTarget candidate code hunk from DogecoinUPcontextDOWNcontextstart statement (ss)start statement (ss)end statement (es) & key statement (ks)end statement (es)key statement (ks)Leveragegit grep to find ksin target repoDeterminetheboundary ssand esby similaritycandidate UP and DOWN contexts in Dogecoin, respectively.
Then starting from the ks (i.e., line 5 and 9 of Dogecoin),
Searcher compares each code statement upwards and down-
wards with the start statement (ss) and end statement (es) in
the patch context, respectively. It then selects the ones with
the highest similarity and also exceeding the aforementioned
threshold (0.25) as the boundary ss and es in the candidate
context, e.g., line 3 and line 5 for Dogecoin’s UP context.

3) Finalizing the candidate contexts via similarity mea-
surement. It is worth noting that ss and es only deﬁne the
boundary of the candidate context, while the code statements in
between remain unchecked. As illustrated in the step 3 of Fig.
3, we thus further check whether the entire candidate context is
indeed similar to the patch context via the same multi-line code
similarity measurement that will be introduced in Sec. III-E. If
the measured similarity between the candidate context C and
the patch context P exceeds a threshold, we consider C as the
context of a candidate clone for further processing; otherwise,
we discard this candidate context.

D. Fetching Patch and Candidate Code Hunks from the Source
and Target Repositories

With the determined candidate context, we leverage
Fetcher to retrieve the patch code from the source repository
and the candidate code from the target repository, respectively.
Note that Fetcher is also used by the earlier Searcher
component to retrieve the context of a patch/candidate code
hunk. Speciﬁcally, a typical code hunk consists of three code
fragments, the UP context, the DOWN context, and the middle
patch/candidate code, as previously shown in Fig. 3.

For the patch code hunk, Fetcher directly fetches its
patch code from the commit history and selects the nearby
code statements upwards and downwards (with the line num-
ber speciﬁed by C_LINES) as the UP and DOWN contexts,
respectively. For the candidate code hunk, we fetch its code
statements according to the candidate context determined in
Sec. III-C and also the original patch context. Speciﬁcally,
if the original patch contains both UP and DOWN contexts,
we regard the code statements between the corresponding
candidate contexts as the candidate code. As a result, line 6
of Dogecoin is fetched as the candidate code in Fig. 3. If
the patch context contains only the UP context, we regard the
code statements below it as the candidate code. Similarly, if
the patch context contains only the DOWN context, we regard
the code statements above it as the candidate code. Note that
for the last two situations, the candidate code is fetched with
the same number of code statements as the patch code.

E. Measuring the Similarity between Patch and Candidate
Code

With the fetched patch and candidate code, Comparator
measures the similarity between their two code fragments
and also determine whether the target repository has ﬁxed
the vulnerability, if the candidate code is not vulnerable. As
mentioned in Sec. III-A, we need a new way of calculating
the code similarity that is immune to Type-1/2/3 clones.

We ﬁrst abstract the code similarity problem in this form:
given a source code fragment S with p code statements and a
target code fragment T with q code statements, respectively,

6

we need to design an appropriate measure to determine their
similarity. Intuitively, we can compute the similarity between
S and T by ﬁrst adding up the similarity of each pair of
code statements at the same position in S and T and then
normalizing it into [0, 1], i.e., 1
i=1 strsim(Si, Ti). While
p
this can handle Type-2 clones because of not using the hash-
based exact match per code line, it is still not applicable to
measuring Type-3 clones for two reasons. First, as Type-3
clones involve inserted/deleted statements, i.e., p (cid:54)= q, the extra
code statements will not be measured in this way. Second,
because of the inserted/deleted statements, the ordering of the
same code statement in S and T might be also different.

(cid:80)p

To solve the problems above, we determine two principles:
(i) all the code statements in S and T should be considered; and
(ii) the inﬂuence of the ordering issue should be adjustable. For
the ﬁrst principle, we identify the most similar code statement
in T for every code statement in S, i.e., for each code statement
Si ∈ S, we ﬁnd Tj ∈ T , s.t., j = arg maxk strsim(Si, Tk).
For the second principle, we ﬁrst deﬁne the index i and j as
the relative positions of the code statements in S and T if Si’s
most similar statement is Tj. The basic idea is that the greater
the difference between i and j is, the less similarity between
Si and Tj should be. Therefore, we introduce a parameter
r ∈ [0, 1], and r|i−j| to indicate the reward of the similarity
between Si and Tj. By multiplying this reward by the original
similarity, we can adjust the ordering issue’s inﬂuence on code
similarity. In this paper, we set 0.95 as the default value of r.
Once ﬁnishing the calculation of such similarity for every code
statement in S, we sum them up and normalize the result into
[0, 1], as shown in the following equation (2).

SIMILARITY(S, T ) =

1
p

p
(cid:88)

i=1

strsim(Si, Tj)r|i−j|

(2)

s.t., j = arg max
1≤k≤q

strsim(Si, Tk)

While the method above provides a new way of measuring
the similarity between two code fragments, we still need to
determine whether the target repository has applied a patch
or not. Speciﬁcally, given the candidate code C of the target
repository, we compare it with the patch code P. Note that
there are three types of P: (i) DEL-type: contains only the
deleted lines, i.e., P = [dp]; (ii) ADD-type: contains only the
added lines, i.e., P = [ap]; and (iii) CHA-type: contains both
deleted and added lines, i.e., P = [dp, ap]. We thus determine
the comparison logic as follows (where t is the threshold):

• For type (i), if SIMILARITY(C, dp) ≥ t, we determine
that C did not apply P; otherwise, we determine that C
has applied P.

• For type (ii), if SIMILARITY(C, ap) ≥ t, we determine
that C has applied P; otherwise, we determine that C did
not apply P.

• For

type (iii),

if SIMILARITY(C, dp) ≥ t and
SIMILARITY(C, ap) ≥ t and SIMILARITY(C, dp) ≥
SIMILARITY(C, ap), we determine that C did not ap-
ply P; otherwise,
if SIMILARITY(C, dp) ≥ t and
SIMILARITY(C, ap) ≥ t and SIMILARITY(C, dp) <
SIMILARITY(C, ap), we determine that C has applied
P.

}

}

TABLE II: An example of the output of git blame.
src/qt/bitcoin.cpp
201
202d853b
202
202d853b
203
202d853b
204
a2714a5c
205
797fef7b
206
a2714a5c
207
a2714a5c
208
a2714a5c
209
9096276e
210
71e0d908
211
9096276e

QApplication(qt_argc, const_cast<char **>(...)),
coreThread(nullptr),
m_node(node),
optionsModel(nullptr),

static int qt_argc = 1;
static const char* qt_argv = "qtum-qt";

BitcoinApplication::BitcoinApplication(...):

Moreover, as Searcher may return multiple candidate
contexts in the target repository, leading to multiple candidate
code, i.e., Ci ∈ [C1, C2, ..., Cn]. For each Ci, we calculate
si = SIMILARITY(Ci, P ), and determine its patch applying
status f vi ∈ {0, 1}, where f vi = 1 (= 0) indicates Ci has
(not) applied P. Here we introduce a factor confi to measure
the conﬁdence of f vi on Ci by confi = si − t, i.e., the greater
si exceeds t the more conﬁdent f vi is on Ci. Finally, we can
determine the status of P in the target repository by the most
conﬁdent f vi, i.e., i = arg maxj confj. If the target repository
did not apply P, we consider it a vulnerability; otherwise, we
consider the vulnerability ﬁxed.

F. Determining Patch Delays for the Vulnerabilities Already
Patched in the Target Repositories

For the vulnerabilities already patched in the target repos-
itories, we further leverage Calculator to automatically
measure their patch delays. We deﬁne the patch delay as
the interval between the patch’s commit date in the source
project and the patch’s release date in the target project because
eventually, the release date is the actual time when a patch is
available to the blockchain node operators and end users.

Upon receiving a candidate code that is determined as
ﬁxed, Calculator leverages git blame to retrieve the
commit
that patched the code. Table II illustrate an ex-
ample output of git blame, where it shows the commit
hash (SHA) and the line number for the code statements in
Qtum’s src/qt/bitcoin.cpp ﬁle. The code from line
204 to line 208 is actually Qtum’s patch for ﬁxing the
cloned CVE-2021-3401 [11] in its project. It was added
by two commits, a2714a5c69 and 797fef7bee, where
797fef7bee only modiﬁed line 205. Hence, we still need
is the true ﬁx. In the Qtum
to determine which commit
example, after checking both commits, we identify that line
205 in Table II was originally added by a2714a5c69 on
10 August 2019 as static const char* qt_argv =
"bitcoin-qt";, where "bitcoin-qt" is later replaced
by "qtum-qt" in 797fef7bee on 26 June 2020. As a
result, if multiple commits modify the candidate code, we
consider the earliest one is the true ﬁx commit.

Moreover, we need to scrape the release information from
GitHub because the local git repository does not contain
such information. By analyzing a commit’s GitHub webpage,
Calculator can retrieve all of its release versions and de-
termine the earliest date when the commit was ﬁrst released. In
the Qtum example, the patch commit a2714a5c69 was ﬁrst
released in the version mainnet-ignition-v0.19.0 on
22 February 2020, which was delayed from the original Bitcoin
commit by 197 days.

7

IV. DETECTING THE VULNERABILITIES PROPAGATED TO
FORKED PROJECTS

In this section, we aim to detect the vulnerabilities that
are propagated from Bitcoin and Ethereum to their forked
blockchain projects using BlockScope. To this end, we ﬁrst
benchmark the accuracy and performance of BlockScope (Sec.
IV-B) using an experimental setup introduced in Sec. IV-A. We
then present the detected vulnerabilities in Sec. IV-C. Finally,
we conduct ethical vulnerability reporting and summarize
vendors’ response/actions in Sec. IV-D.

A. Experimental Setup

To make sure that BlockScope’s vulnerability detection
results are reliable, we not only run BlockScope in our
experiment but also compare it with the open-source state-of-
the-art ReDeBug [41] using the same dataset and environment
below. Note that we also considered other clone detection tools
(e.g., [44], [46], [63], [75]) for more comparison but eventually
did not choose them for two reasons. First, MVP [75] was not
open-source and it does not support the Go language. While
VUDDY [46] released its signature generating scripts,
its
most important vulnerability search engine was not available.
Indeed, we contacted the VUDDY team and conﬁrmed that
their cloud version currently supports only one CVE in our
dataset. Second, CCFinder [44] and SourcererCC [63] are pure
code clone detection tools and are not able to perform patch-
based detection in our problem without adjustment.

Dataset. As illustrated in Fig. 2, BlockScope requires two
sets of input, the target blockchain code repositories and the
security patches of a reference blockchain (i.e., Bitcoin and
Ethereum in this paper). As a result, we collect these two
sets of data as our dataset. Speciﬁcally, for code repositories,
we select all the 11 forked projects of Bitcoin from the top
100 cryptocurrencies (based on the market capitalization on
CoinMarketCap) and ﬁve popular forked projects of Ethereum
(picked from Blockscan) as our target blockchains, as previ-
ously introduced in Sec. II. The total market capitalization
of these 16 blockchains was around 142 billion USD. To
build a reproducible dataset, we kept a local copy of the
latest version of code repositories at the time of our research
on 7 September 2021 and 6 June 2022 for Bitcoin forks
and Ethereum forks, respectively. On the other hand, for
security patches, an intuitive idea is to use the CVE (Common
Vulnerabilities and Exposures) information; however, we found
that there are only 12 CVEs about Bitcoin with explicit patch
code and eight of them are out of the recent ﬁve years. That
said, we could select only four to test if we just use the public
CVE information.

To address this problem, we select bug issues/pull requests
with notable security impacts (i.e., vulnerabilities) and their
patch commits (i.e., patches) directly from Bitcoin’s GitHub
repository according to three simple principles: (i) the patches
should be released within the recent ﬁve years since outdated
patches had been applied to Bitcoin before it gets forked;
(ii) the patches that cover different vulnerability types should
have a higher chance to be picked up so that we can evaluate
the generality of BlockScope; and (iii) the patches should be
applicable to most forked projects, i.e., not speciﬁc to one
particular Bitcoin component or one fork. As a result, we

TABLE III: The experimental result of BlockScope.

(a) The accuracy and performance comparison between BlockScope and ReDeBug.

(b) The ﬁxed cases detected by BlockScope.

Forked Project

LOC

Dogecoin
Bitcoin Cash
Litecoin
Bitcoin SV
Dash
Zcash
Bitcoin Gold
Horizen
Qtum
DigiByte
Ravencoin

Sum

Binance
Avalanche
Polygon
Celo
Optimism

Sum

326.9K
607.1K
423.3K
221.1K
380.3K
199.4K
381.7K
178.9K
569.0K
416.3K
504.2K
4.2M
(382.6K)*

565.3K
1070.1K
592.0K
631.0K
630.6K
3.5M
(697.8K)*

BlockScope
FP
1
1
-
2
-
2
-
1
1
-
1

TN
15
30
26
18
22
19
21
20
31
21
16

239

5
6
6
5
2

24

9

-
-
-
-
-

-

FN
-
-
-
1
1
2
1
2
-
1
1

9

-
-
-
-
-

-

TP
16
1
6
11
9
9
10
9
-
10
14

95

1
-
-
1
4

6

Time
7.6s
10.5s
8.3s
10.6s
13.9s
8.4s
8.8s
7.7s
12.0s
10.7s
11.4s
109.9s
(3.4s)(cid:5)
2.2s
2.5s
2.3s
2.7s
3.6s
13.3s
(2.2s)(cid:5)

ReDeBug
TN
15
31
26
19
21
21
21
21
32
21
17

FP
1
-
-
1
1
-
-
-
-
-
-

245

5
6
6
5
2

24

3

-
-
-
-
-

-

FN
9
1
1
10
3
10
1
10
-
1
5

51

1
-
-
-
1

2

TP
7
-
5
2
7
1
10
1
-
10
10

53

-
-
-
1
3

4

Time
12.5s
22.2s
16.4s
9.9s
17.7s
10.7s
17.4s
12.6s
33.5s
15.8s
20.9s
189.6s
(5.9s)(cid:5)
30.2s
55.2s
31.3s
44.5s
43.3s
204.5s
(34.1s)(cid:5)

Forked Project

Dogecoin
Bitcoin Cash
Litecoin
Bitcoin SV
Dash
Zcash
Bitcoin Gold
Horizen
Qtum
DigiByte
Ravencoin

Sum

Binance
Avalanche
Polygon
Celo
Optimism

Sum

# Fixed Cases

Detected
1
23
22
1
11
2
14
1
28
14
3

120

5
3
6
4
1

19

Truth
1
25
22
1
10
1
14
-
28
14
3

119

5
3
6
4
1

19

Err*
-
(2;-)
-
-
(-;1)
(-;1)
-
(-;1)
(1;1)
-
-

(3;4)

-
-
-
-
-

-

*: the numbers in (.) of these cells represent the average LOC per project.
(cid:5): the numbers in (.) of these cells represent the average processing time per patch.

* represents (the number of missed
cases; the number of mistake cases).

are able to select 32 patches of Bitcoin from June 2017 to
March 2020, including four CVEs. For Ethereum, since its
forks are relatively new, we select six CVEs of Ethereum
since November 2020 as the patches. These 38 patches involve
multiple vulnerability types, including denial-of-service, race
conditions, privacy leakage, and etc. While the number of
Bitcoin and Ethereum vulnerabilities here is not large, we have
to be selective to make sure they are actually vulnerabilities.
Indeed, Bitcoin and Ethereum have a limited number of vul-
nerabilities over the years. For example, the VUDDY dataset
included only 9 CVEs of Bitcoin, with 8 of them already before
2013 and only one after 2018. Moreover, we have 16 popular
forked projects of Bitcoin and Ethereum forked projects to test,
which multiplied the total test cases to 382 (32 × 11 + 6 × 5).

Environment and tool

conﬁguration. We evaluate
BlockScope and ReDeBug on the same virtual machine run-
ning Ubuntu 18.04 with 4GB memory conﬁgured, while the
host machine is a Macbook Pro with a 3.5GHz dual-core Intel
Core i7 CPU and 16GB memory. Note that ReDeBug needs
to set a n-gram parameter to adjust the number of lines for
context code. While the default is four, we tried from one to
ten and found that when n-gram=3, ReDeBug achieves its
best result when analyzing our dataset.

B. Accuracy and Performance

After running BlockScope and ReDeBug on the dataset in
Sec. IV-A (i.e., using 32 Bitcoin patches and six Ethereum
the 16 forked projects) and performing a
patches to test
thorough code review of all the raw detection results (including
the cases that have no any output), we are able to precisely
obtain the accuracy and performance data for both tools.
Overall, BlockScope detects 101 true vulnerabilities in 13
forked projects (Qtum, Avalanche, and Polygon do not contain
any vulnerability in our dataset as we manually checked),
whereas ReDeBug detects only 57 vulnerabilities in ten forked
projects, which makes BlockScope’s recall 1.8 times higher
than that in ReDeBug. For performance, BlockScope is also

TABLE IV: # of different vulnerability types in each project.

Forked Project

Dogecoin
Bitcoin Cash
Litecoin
Bitcoin SV
Dash
Zcash
Bitcoin Gold
Horizen
Qtum
DigiByte
Ravencoin
Sum

Type-1
B;R
(6;4)
(1;-)
(5;5)
(1;-)
(7;7)
(1;-)
(9;8)
-
-
(7;7)
(7;7)
(44;38)

T
6
1
5
1
7
1
9
-
-
7
7
44

Type-2

T
-
-
-
-
-
2
-
2
-
1
-
5

B;R
-
-
-
-
-
(1;-)
-
(2;-)
-
(1;-)
-
(4;-)

Type-3
B;R
(10;3)
-
(1;-)
(10;2)
(2;-)
(7;1)
(1;2)
(7;1)
-
(2;3)
(7;3)
(47;15)

T
10
-
1
11
3
8
2
9
-
3
8
55

Sum

B;R
(16;7)
(1;-)
(6;5)
(11;2)
(9;7)
(9;1)
(10;10)
(9;1)
-
(10;10)
(14;10)
(95;53)

T
16
1
6
12
10
11
11
11
-
11
15
104

-
-
-
1
4
5

-
-
-
(1;1)
(4;3)
(5;4)

Binance
Avalanche
Polygon
Celo
Optimism
Sum

-
-
-
-
-
-
T, B, and R represent: the total number of vulnerabilities of each
clone type, the number of vulnerabilities detected by BlockScope,
and the number of vulnerabilities detected by ReDeBug, respectively.

(1;-)
-
-
(1;1)
(4;3)
(6;4)

(1;-)
-
-
-
-
(1;-)

1
-
-
1
4
6

1
-
-
-
-
1

-
-
-
-
-
-

1.7 times faster than ReDeBug in analyzing Bitcoin’s forked
projects and even 15.4 times faster in analyzing Ethereum’s
forked projects with more code per project.

Table IIIa shows a breakdown of the detailed accuracy and
performance results of BlockScope and ReDeBug, where TP,
FN, TN, and FP represent true positive, false negative, true
negative, and false positive, respectively. According to this
table, we can calculate the precision via T P/(T P + F P )
and the recall via T P/(T P + F N ), respectively. We ﬁnd
that BlockScope achieves good precision and high recall both
at 91.8%. In contrast, while ReDeBug has only three false
positives in our dataset (mainly because it uses the exact
match per code line), its recall is as low as 51.8%. That said,
ReDeBug fails to detect many of the vulnerabilities covered by
BlockScope. Since we aim to perform a thorough investigation
of forked blockchains’ vulnerabilities, BlockScope achieves

8

the high recall we need while introducing a low false alarming
rate at only 8.18%. Moreover, among the 13 forked projects
with vulnerabilities (i.e., no Qtum, Avalanche, and Polygon),
BlockScope detects vulnerabilities in all of them, while ReDe-
Bug fully misses the results for two projects, Bitcoin Cash and
Binance. In particular, BlockScope successfully detects all the
vulnerabilities in Dogecoin, Bitcoin Cash, Litecoin, Binance,
Celo, and Optimism with zero false negative.

We further explore the reasons that cause BlockScope to
have a much better detection effectiveness than ReDeBug by
analyzing the detailed results of detecting different clone types.
This is because while ReDeBug claims that it can handle
Type-1 and Type-3 clones, the accuracy of each clone type
may vary. As shown in Table IV, among the 110 (TP + FN)
vulnerabilities in the forked projects of our dataset, 95.5%
of them are the Type-1 and Type-3 clones, with the number
of Type-3 clones slightly higher than that of Type-1 clones.
For these cases, ReDeBug achieves an accuracy of 85.7% for
Type-1 clones, but its detection rate for Type-2 and Type-3
clones drops to 0% and 26.8%, respectively. This explains
why ReDeBug performs better on six particular projects — the
number of Type-1 clones in those six projects (i.e., Litecoin,
Dash, Bitcoin Gold, DigiByte, Celo, and Optimism) is larger
than that of Type-3 clones. Indeed, if a forked project has
more Type-1 clones, it is more similar to the original project.
In contrast, BlockScope does not have this limitation. It is able
to detect all the Type-1 and Type-2 clones, and misses only
eight cases for the more complicated Type-3 clones, i.e., still
achieving a high rate of 85.7% for all the Type-3 clones.

For performance, BlockScope performs much faster on
all the projects than ReDeBug. In particular, BlockScope can
ﬁnish the analysis of 10 forked projects within ten seconds,
while ReDeBug just ﬁnishes only one project (i.e., Bitcoin SV)
within ten seconds. We further analyze whether the project’s
LOC affects the performance of BlockScope and ReDeBug.
For BlockScope, we notice that it takes almost the same time
(10.5s vs. 10.6s) to analyze Bitcoin Cash and Bitcoin SV,
even though the LOC of Bitcoin Cash is 2.7 times that of
Bitcoin SV (607K vs. 221.1K). In contrast, the processing
time of ReDeBug for the same two projects is 22.2s and 9.9s,
respectively. The difference of 2.2 times is close to the ratio of
those two projects’ LOC. This indicates that the project’s LOC
does not explicitly affect the processing time of BlockScope,
while it has a signiﬁcant effect on ReDeBug’s performance.

Indeed, when we compare the performance of BlockScope
between Bitcoin forks (with fewer LOC) and Ethereum forks
(with more LOC), we notice that BlockScope can ﬁnish the
analysis of Ethereum forks even faster. It suggests that for
BlockScope, the number of target patches (32 for Bitcoin
vs. 6 for BlockScope) has a more noticeable impact on its
performance than LOC. ReDeBug, on the other hand, is the
opposite, with LOC having much more impact than the number
of target patches on its performance. For example, for Qtum
and Binance that have almost the same LOC, the analysis
time of ReDeBug is also almost the same (33.5s vs. 30.2s).
As we mentioned earlier, typical code clone detection tools
like ReDeBug perform a whole-project analysis – so LOC
dominates the performance, while BlockScope leverages patch
code contexts to search and locate only potentially relevant
code for comparison – so LOC has a much limited effect.

C. Analysis of the Detected Vulnerabilities

Since BlockScope detects not only the cloned vulnera-
bilities but also whether a patch is applied, we perform an
analysis on both the detected vulnerabilities and the ﬁxed cases
in this subsection. For a deep investigation on the individual
vulnerability, we present it later in Sec. V.

As shown in Table IIIa, Bitcoin’s forked projects have
a total of 104 vulnerabilities. Among the 11 projects, only
Bitcoin Cash and Qtum have few vulnerabilities, while nine
projects have at least 10 vulnerabilities each out of the 32
patches investigated. In particular, Dogecoin and Ravencoin
did not patch around half of the total 32 vulnerabilities. On
the contrary, Ethereum’s forks present a better result, with
only Optimism having four vulnerabilities out of the six
patches investigated. The other four projects have at most one
vulnerability each, with Avalanche and Polygon fully patched.

For the result of ﬁxed cases, the forked projects of Bitcoin
and Ethereum have ﬁxed a total of 138 vulnerabilities (119
for Bitcoin and 19 for Ethereum). While Bitcoin’s 11 forked
projects have ﬁxed 119 vulnerabilities, ﬁve of them, Dogecoin,
Bitcoin SV, Zcash, Horizen, and Ravencoin, ﬁxed only six
vulnerabilities in total. Three projects, Qtum, Bitcoin Cash, and
Litecoin, contribute to 63% of all the ﬁxed cases. Similar to the
result above regarding the vulnerable cases, Ethereum’s forked
projects also perform better in the ﬁxed cases. While Optimism
ﬁxed only one vulnerability,
the other four projects have
ﬁxed at least half of the investigated patches. Indeed, when
comparing the ratio of the ﬁxed/vulnerable cases between
Bitcoin’s and Ethereum’s forked projects — 119/104 vs. 19/6,
we notice that Ethereum’s forks are more active in ﬁxing
propagated vulnerabilities. Another aspect for measuring the
project’s activeness on patching vulnerabilities is the patch
delay, which we provide a detailed analysis in Sec. V-C.

D. Vulnerability Reporting and Response

As an ethical research and one contribution of this paper,
we have spent signiﬁcant efforts reporting all the 110 discov-
ered vulnerabilities (including 101 TP automatically detected
by BlockScope and 9 FN manually identiﬁed by us during
evaluation) to the developers of the affected forked projects
via multiple channels. In Table V, we summarize the latest
developers’ response and actions to our vulnerability reports
as of 26 July 2022. Speciﬁcally, “Fixed” means that the vendor
has adopted our reports to ﬁx the issues, “Accepted” represents
that the developers accepted our reports and were exploring
appropriate patch migration, “ACK” suggests that the vendor
has acknowledged our reports but did not explicitly indicate to
ﬁx the issues, “Pending” means that we have not received any
response yet, and lastly, “Reject” means that the vendor has
denied and refused to ﬁx the vulnerabilities. We can see that
around 74 of our 110 vulnerability reports received positive
response, which demonstrates that the impact of our work. We
further classify developers’ response into three categories:

Positive/Active Response. Among the 13 forked projects
with vulnerabilities, around half of them responded to our
vulnerability report positively, namely Dogecoin, Ravencoin,
Dash, Bitcoin Gold, Litecoin, and Binance. Speciﬁcally, Do-
gecoin acknowledged all of our reports and quickly ﬁxed
11 serious vulnerabilities, while the others are scheduled or

9

TABLE V: Developers’ response to our vulnerability reports.

Forked Project
Dogecoin
Bitcoin Cash
Litecoin
Bitcoin SV
Dash
Zcash
Bitcoin Gold
Horizen
Qtum
DigiByte
Ravencoin
Sum

Binance
Avalanche
Polygon
Celo
Optimism
Sum

Fixed
11
-
2
-
1
-
7
-
-
-
9
30

-
-
-
-
-
-

Accepted
3
-
-
-
5
-
-
-
-
-
1
9

1
-
-
-
-
1

ACK
2
-
3
8
3
9
1
4
-
-
3
33

-
-
-
1
-
1

Pending
-
1
1
2
1
1
3
7
-
11
1
28

-
-
-
-
4
4

Reject
-
-
-
2
-
1
-
-
-
-
1
4

-
-
-
-
-
-

Sum
16
1
6
12
10
11
11
11
-
11
15
104

1
-
-
1
4
6

under the community discussion for appropriate patch migra-
tion. Meanwhile, Ravencoin accepted nearly all the reports.
The developers ﬁxed nine of them and acknowledged three
except one rejection and one pending due to the compatibility
consideration. Similarly,
the developers of Dash approved
nearly all the reports and informed us that they had ﬁxed ﬁve
vulnerabilities under the development branch, which will be
merged into a new release in the future. Bitcoin Gold also
ﬁxed seven vulnerabilities in one release after around four
months receiving our reports, with another one acknowledged
and three under pending, while Litecoin ﬁxed two of the
vulnerabilities and claimed that they had noticed the other
three. Lastly, Binance immediately acknowledged our report on
BSC and rewarded us a bug bounty with the promise of ﬁxing
it. During this reporting process, we found that developers are
more likely to ﬁx a vulnerability with authoritative proofs, es-
pecially those with CVE numbers. For instance, the Dogecoin
developers quickly released a new version of the Dogecoin
core after they ﬁxed CVE-2021-3401 and CVE-2019-15947.
However, for the other vulnerabilities with no CVE assigned,
they just acknowledged them and kept them on the to-do list.

Neutral Response. In this category, developers also ac-
cepted our reports but did not have intention to ﬁx any of them
yet. Speciﬁcally, Bitcoin SV’s developers quickly acknowl-
edged 8 of the 12 reports, and Zcash similarly acknowledged 9
of the 11 reports. However, both rejected a few (2 for Bitcoin
SV and 1 for Zcash) due to incompatibility, and we have
not received further updates from them. Meanwhile, Horizen
acknowledged four vulnerability reports with the other seven
still under pending, and Celo acknowledged the only report.

Negative/Inactive Response. Unfortunately, the response
from the rest of three projects is not active and worrisome.
Speciﬁcally, Bitcoin Cash, DigiByte, and Optimism did not
give response to any of our reports. The worst case is DigiByte
because it ignored 11 vulnerabilities, including some critical
ones like CVE-2021-3401 and CVE-2019-15947.

V.

INVESTIGATING THE PROPAGATION AND PATCHING
PROCESSES OF DISCOVERED VULNERABILITIES

In this section, we conduct a deep investigation of the
vulnerabilities discovered in Sec. IV. Speciﬁcally,
in Sec.
V-A, we aim to understand how these vulnerabilities are
propagated from Bitcoin and Ethereum to their forked projects.

(a) The fork type: vulnerabilities directly forked in the
beginning.

(b) The fetch type: vulnerabilities fetched from vulnerable
commits.

(c) The mixed type: vulnerabilities infected with no explicitly
vulnerable commits.

Fig. 4: Three types of the vulnerability propagation from
Bitcoin to its forked projects.

Furthermore, in Sec. V-B, we diagnose some other propagation
that caused our detection to fail (both FP and FN). Lastly,
we perform a patch delay analysis in Sec. V-C to understand
the patching processes of the cases that were already ﬁxed in
forked projects before our detection.

A. Revealing
Bitcoin/Ethereum to Their Forked Projects

Vulnerability

the

Propagation

from

To reveal how a vulnerability is propagated from Bitcoin
and Ethereum to the forked projects, we manually check all
the 110 vulnerabilities, including 104 from Bitcoin forks and
6 from Ethereum forks, respectively, and categorize them into
three types, as shown in Fig. 4. To simplify the description
in this section, we apply “Bitcoin” to represent both Bitcoin
and Ethereum, unless explicitly speciﬁed. The ﬁrst type, as
illustrated in Fig. 4a, refers to the vulnerabilities that were
introduced when the project was initially forked from Bitcoin.
For better understanding and simplicity, we call it the fork
type. The second type, as depicted in Fig. 4b, is similar to the
ﬁrst type except that it fetched and merged vulnerable commits
of Bitcoin afterwards. We call it the fetch type. The third
type, as shown in Fig. 4c, is an advanced version of the fetch
type. The major difference is that vulnerabilities of this type
were infected with no explicitly vulnerable commits of Bitcoin.
Typically, they are caused by the defective program design
or inappropriate functionality implementation that
involves
multiple code commits. We call this type the mixed type.
In total, we identify 41 fork-type, 25 fetch-type, and
44 mixed-type vulnerabilities, respectively. We conduct case
studies about these three types as follows.

Vulnerabilities directly forked in the beginning. In the
fork type, vulnerabilities were propagated into the forked
projects when they forked from Bitcoin. Many vulnerabil-
ities, such as CVE-2022-29177 and CVE-2021-41173 from
Ethereum, or CVE-2021-3401 from Bitcoin, are the classic
cloned vulnerability cases to explore fork-type vulnerabilities

10

BitcoinForkedVulnerabilityPatchGeneralMissedFlawand study their propagations. Take CVE-2021-3401 as an
example. This vulnerability ﬁrst appeared in Bitcoin, but we
found that it also affected three other forked projects (Dash,
Ravencoin, and Bitcoin Gold) since they were initially forked
from Bitcoin. As detailed in [31] and the patch code in [11],
it was caused by the misuse of the Qt-framework built-in ar-
guments. Speciﬁcally, Bitcoin and its forked projects leverage
the Qt-Framework [21] to design their own GUI programs.
However, Qt suffered from argument misinterpretation,
in
which attackers can inject dangerous built-in Qt arguments,
e.g., -platformpluginpath, into a normal Qt command
to load and execute their malicious plugin code remotely.

Vulnerabilities fetched from vulnerable commits. In
the fetch type, vulnerabilities were introduced when forked
projects fetch commits from Bitcoin to update their function-
alities without verifying whether a commit is vulnerable or
neglecting a patch from Bitcoin afterwards. Dogecoin and
DigiByte (forked from Bitcoin) were also affected by the
aforementioned CVE-2021-3401 yet
in this way, and Op-
timism (forked from Ethereum) were similarly affected by
the CVEs including CVE-2020-26265, CVE-2020-26264, and
CVE-2020-26260. Taking Dogecoin as example, it fetched
the vulnerable commit 202d853b [2] of CVE-2021-3401
from Bitcoin that sets inappropriate arguments in the class
BitcoinApplication, but failed to pose any security
check, causing a typical fetch vulnerability. This is different
from the fork vulnerabilities because Dogecoin fetched the
vulnerable code actively instead of passively including it.
Unfortunately, there are no speciﬁcation for the developers of
forked projects to use the upstream code so that it is easy to
skip the security patches and fetch a vulnerable commit only.

it

Vulnerabilities infected with no explicitly vulnerable
commits. Different from the fork and fetch vulnerabil-
ities,
is hard to locate the speciﬁc vulnerable commits
that introduced vulnerabilities in the mixed type. It usually
contains a few consecutive or discrete commits instead of
the speciﬁc one(s). Only when all the buggy commits were
included together, a vulnerability would then appear. Typically,
in the mixed type, the program would still run correctly at
the code level, but attackers can exploit the logical ﬂaws. For
instance, Bitcoin PR#16512 [8] ﬁxed a logical ﬂaw where the
joinpsbts function did not shufﬂe its inputs and outputs,
causing a privacy leak that attackers could easily identify
which outputs belong to which inputs. This vulnerability
was originated from the defect of the joinpsbts function
implementation, instead of a certain commit that made the
function vulnerable.

B. Diagnosing Some Other Propagation that Caused Our
Detection to Fail

During our

investigation of vulnerability propagation,
we also identiﬁed some other propagation that evaded
BlockScope’s detection (FN) or caused false positives (FN).
We carefully analyze all the 18 failed detection cases (9 FPs
and 9 FNs) that are listed in Table VI, and summarize them
into three types, FP-I, FP-II, and FN, as shown in Fig. 5.

FP-I: no clone, and thus no vulnerability. As shown
in Fig. 5a, the forked project sometimes keeps its outdated
code and does not clone the vulnerable commit. As a result,

(a) FP-I: no clone, and thus no vulnerability.

(b) FP-II: patch outdated.

(c) FN: target code outdated.

Fig. 5: Three types of propagation from Bitcoin to its forked
projects that caused BlockScope to fail in terms of FP and FN.

it has no need to fetch the patch commit either. However, for
certain vulnerabilities, there may have multiple ways to write a
security patch — some ﬁx the root cause while others close the
attack surface. Since BlockScope detects the vulnerable clone
based on the similarity measurement with one speciﬁc patch,
it is possible that it gives false alarming if the vulnerable code
could be avoided in other ways.

One notable example is CVE-2018-17145 [4], which
caused BlockScope to generate four same false positives, as
shown in Table VI. We conducted a deep analysis of this DoS
vulnerability. We found that the root cause is a susceptible
variable m_callbacks_pending, which was introduced in
Bitcoin at the commit 08096bbb [3] (but forked projects like
Dogecoin did not fetch this vulnerable commit). The size of
this variable would grow unlimitedly and run out of all the host
memory if attackers create ﬂooding transactions to execute an
interface function called Inventory(inv.hash). Unfor-
tunately, Bitcoin patched this vulnerability only by deleting
the unrestricted Inventory function. Since Dogecoin did
not clone both vulnerable and patch commits, BlockScope
identiﬁes the unrestricted Inventory function and thus
determines that the forked vulnerable is also vulnerable. While
the interface function is still
there was no victim
m_callbacks_pending variable in Dogecoin, making at-
tackers cannot exploit the Inventory function. There are a
total of seven false positives like this, as shown in Table VI.

there,

FP-II: patch outdated. An outdated patch means that the
forked projects had fetched a patch commit but neglected its
further update. As shown in Fig. 5b, suppose there was a
vulnerability in both Bitcoin and its forked project. Bitcoin
released two different version of the patch at the point A and
B, respectively. The ﬁrst patch is for instant ﬁxing while the
latter for the patch update. However, the forked project just
accepted the ﬁrst patch. When BlockScope applied the ﬁnal
patch (i.e., the second) to detect clones, it cannot not match
the target code and trigger a false positive.

For example, BlockScope generated a false positive for
Bitcoin PR#13808 when testing Bitcoin Cash. Bitcoin ﬁxed

11

BitcoinForkedVulnerabilityPatchGeneralMissedABABCAAATABLE VI: All the 18 failed detection in BlockScope.

SHA
beef7ec4
beef7ec4
beef7ec4
beef7ec4
d8318318
0e7c52dc
b8f80196
0e7c52dc
18f690ec
76f74811
37886d5e
37886d5e
e254ff5d
4433ed0f
effe81f7
effe81f7
e6c58d3b
e6c58d3b

Source
CVE-2018-17145
CVE-2018-17145
CVE-2018-17145
CVE-2018-17145
CVE-2019-15947
Bitcoin PR#12561
Bitcoin PR#14249
Bitcoin PR#12561
Bitcoin PR#13808
Bitcoin PR#10345
Bitcoin PR#11568
Bitcoin PR#11568
Bitcoin PR#13907
Bitcoin PR#15305
Bitcoin PR#15323
Bitcoin PR#15323
Bitcoin PR#15325
Bitcoin PR#15325

Project
Bitcoin SV
Dogecoin
Horizen
Zcash
Bitcoin SV
Zcash
Ravencoin
Qtum
Bitcoin Cash
Bitcoin SV
Horizen
Zcash
Zcash
Horizen
Dash
Ravencoin
Bitcoin Gold
DigiByte

Cause
No Clone
No Clone
No Clone
No Clone
No Clone
No Clone
No Clone
Outdated Patch
Outdated Patch
Outdated Target
Outdated Target
Outdated Target
Outdated Target
Outdated Target
Outdated Target
Outdated Target
Outdated Target
Outdated Target

FP/FN
FP-I
FP-I
FP-I
FP-I
FP-I
FP-I
FP-I
FP-II
FP-II
FN
FN
FN
FN
FN
FN
FN
FN
FN

this vulnerability by using the shuffle [5] function of
the C++ standard library, which is the ﬁrst patch. However,
Bitcoin later substituted the patch with the Shuffle [6]
function created in Bitcoin PR#14624. It is an updated patch
to ﬁx the issue in a more appropriate way. Since Bitcoin
Cash adopted the ﬁrst patch only and neglected the update,
it caused a FP of BlockScope. More speciﬁcally, it means
that Bitcoin Cash still uses the shuffle function of the C++
standard library. When BlockScope used the updated patch for
detection, it failed because BlockScope cannot match the patch
from PR#14624. Similarly, BlockScope failed in another FP-II
type vulnerability in Qtum from Bitcoin PR#12561.

FN: target code outdated. BlockScope could also en-
counter false negatives when the target code where the patch
applies to is outdated. In the example of Fig. 5c, point A
indicates an underlying vulnerability in a Bitcoin function.
This vulnerability is further inherited along with the devel-
opment of Bitcoin at point B, and Bitcoin creates a patch at
point C to ﬁx the vulnerability located at point B. A forked
project suffers from the same vulnerability because it includes
a copy of the vulnerable commit at point A. However, the
Bitcoin patch at point C can not be directly applied to the
vulnerability at point A due to the inconsistent code, causing
a FN. Speciﬁcally, BlockScope uses the patch code at point
C to search the potentially vulnerable code segments in a
forked project. If BlockScope cannot identify any related code
segments, it reports nothing and poses a false negative.

Taking Bitcoin PR#15305 as an example, it speciﬁes the
behavior of Bitcoin nodes to disconnect a block correctly
when the Bitcoin program hits exceptions. However, when
BlockScope applied the patch code of PR#15305 [7] to detect
clones in Bitcoin SV, nothing outputted and a false negative
appeared. This is because that Bitcoin SV keeps the outdated
code cloned from Bitcoin. Indeed, we checked the history of
the outdated code in Bitcoin SV and found that it was a copy of
an old version of Bitcoin code. This outdated code in Bitcoin
SV makes the Bitcoin patch cannot be directly applied. In
total, BlockScope made nine such false negatives due to the
outdated target code, as shown in Table VI.

C. Patch Delay Analysis

As previously mentioned in Sec. IV-C, we identiﬁed a total
of 138 cases (119 from Bitcoin forks and 19 from Ethereum

(a) For Bitcoin and its forked projects with enough
patched cases.

(b) For Ethereum and its forked projects as a whole.

Fig. 6: CDF plots of # the delay days per security patch.

i.e.,

forks) that were already ﬁxed before our detection. Among
the 11 forked projects of Bitcoin, ﬁve projects have only a
few ﬁxed cases — Dogecoin, Litecoin, and Zcash have one
ﬁxed case each, and Horizen even has no ﬁxed case. Therefore,
there is no enough data to analyze their patch delay. Moreover,
since we only investigated six patches for Ethereum’s forked
projects,
they do not have many ﬁxed cases, we put
them together as “Ethereum Forks”. Hence, we focus on the
“Ethereum Forks” and six Bitcoin’s forked projects with more
than ten ﬁxed cases each, i.e., Bitcoin Cash, Litecoin, Dash,
Bitcoin Gold, Qtum, and DigiByte. For each forked project,
we draw a CDF plot of its patch delay days, as shown in Fig. 6.
We also plot the CDF for Bitcoin’s and Ethereum’s patch delay
days, i.e., the intervals between the commit date and the release
date of the patch commit in the original projects, using the
black line as a reference.

According to the black line in Fig. 6a, Bitcoin released
all
the selected patches within 300 days, and 80% of its
patches were released within 200 days. The patch delay for
serious vulnerabilities is even quicker, e.g., within 110 days
for the four investigated CVEs. Unfortunately, only DigiByte
can catch up with Bitcoin’s release schedule, and Qtum’s
performance on patch delay is the second best, while the
remaining projects could release only less than 20% of the
patches within 200 days. Dash is particularly slow, with its
80% patches released after 800 days. In some extreme cases,
the release delay could even exceed 1,000 days, e.g., in Bitcoin
Cash and Dash.

12

020040060080010001200# Delay Days0.00.20.40.60.81.0CDFBitcoinBitcoin CashLitecoinBitcoin GoldQtumDigiByteDash020040060080010001200# Delay Days0.00.20.40.60.81.0CDFEthereumEthereum ForksThe result for Ethereum and its forked projects is much
more acceptable than Bitcoin’s forked projects. Note that we
exclude Avalanche for the patch delay analysis because three
of its ﬁxed cases were included when Avalanche was ﬁrst
initialized. As shown in Fig. 6b, for the investigated six CVEs,
Ethereum released all the patches within a short period, at most
22 days to be speciﬁc, and four patches were released within
four days. Moreover, Ethereum’s forked projects released all
the investigated patches within 500 days, with more than 80%
released within 200 days and half of the patches released
around 100 days. Polygon is among the best, as it has six ﬁxed
cases whereas all of them were released within 110 days.

VI. RELATED WORK

In this section, we review the related work on blockchain
vulnerability detection and clone-based vulnerability detection.

Blockchain vulnerability detection. Existing blockchain
vulnerability detection mainly focused on the security of
smart contracts. For instance, Oyente [53], Securify [71],
ZEUS [43], ETHBMC [35], eThor [64], SmarTest [67], and
SAILFISH [27] leveraged static analysis techniques, e.g.,
symbolic execution, to detect vulnerable smart contracts. On
the other hand, Sereum [60] aimed to dynamically detect
the reentrancy attacks [16] and protect the deployed smart
contracts. Similarly, TXSPECTOR [79] designed a generic
and ﬂexible framework for identifying attacking transactions in
Ethereum [73], and SODA [29] is another generic framework
for attack detection. Lastly, Perez et al. [58] studied the
possibility of exploiting the discovered smart contract vulnera-
bilities. Besides the research about smart contract vulnerability
detection, DEFIER [69] automatically investigated the attack
incidents of DApps (decentralized apps), which are built on the
top of smart contracts. Additionally, EVMPatch [61] proposed
a framework for instantly and automatically patching faulty
smart contracts. SolType [70] designed a reﬁnement
type
system for Solidity to prevent arithmetic over- and under-ﬂows.

However, only a few studies focused on the vulnerabilities
at
the system level. Notably, Kwon et al. [47], Zhang et
al. [80], and Yang et al. [77] investigated the consensus
reward ﬂaws and the consensus system bugs in the Bitcoin
network and Ethereum clients, respectively. Yi et al. [78]
systematically mined the existing vulnerabilities from four
representative blockchains, Bitcoin, Ethereum, Monero, and
Stellar, for security insights. Besides these works, three recent
studies focused on the Bitcoin patch delay analysis that is most
related to BlockScope’s Calculator component. Speciﬁ-
cally, CoinWatch [40] used four CVEs of Bitcoin to test and
analyze the delay of many old Bitcoin’s forked projects that
are no longer maintained. It used the Simian the clone detec-
tor [1], i.e., simple string match, to detect only Type-1 clones.
Similarly, Choi et al. [30] conducted a large-scale empirical
analysis on the code maintenance activities of Bitcoin forks,
with only limited information about security vulnerabilities.
Another technical report, GitWatch [26], tried to accurately
determine the patch commit delay from Bitcoin to its forked
projects. Since git lacks reliable commit timestamps due to
the rebase operation, it leveraged GitHub’s event API and
GitHub Archive to solve this problem. In contrast, BlockScope
focused on the patch release delay that does not require the
git commit timestamp, as explained in Sec. III-F.

Code clone-based vulnerability detection. Code clone
detection is an attractive research area of computer security, as
it has been shown that many bugs and vulnerabilities could be
cloned from one software to another [45]. Unlike the traditional
clone detection tools, such as CCFinder [44], CPMiner [52],
DECKARD [42], and SourcererCC [63], security-oriented
clone detection tools like ReDeBug [41], VUDDY [46],
MVP [75], and VGraph [28] considered both vulnerable and
patched code inputs. Speciﬁcally, ReDeBug [41] was among
the most representative works in this direction, and it has
been widely used because of its generality and public code.
Following ReDeBug, VUDDY [46] added variable/parame-
ter/type/function abstraction as a preprocessing and used the
generated ﬁngerprints for more scalable code clone detection.
Similarly, MVP [75] and VGraph [28] conducted more “pro-
gram analysis” in the form of program slicing [74] and code
property graph [76] before similarity measurement to improve
the detection accuracy. Compared with these three works,
BlockScope took a completely different path by proposing
more suitable candidate code search for our problem (as in
Sec. III-C) and improving the core technique on how to better
measure code similarity itself (as in Sec. III-E).

Recently, AI techniques have also been applied in clone-
related vulnerability detection. Speciﬁcally, CLCDSA [55]
utilized deep neural networks to detect cross-language code
clones. Gao et al. [37] detected code clones in smart con-
tracts by word embeddings. Ahmadiet et al. [25] leveraged
machine learning-based methods to detect functionally-similar
inconsistent code. DeepBugs [59], VulDeePecker [51], Devign
[82], SySeVR [50], and VulDeeLocator [49] utilized various
kinds of code features of known vulnerabilities to train deep
learning models to identify new vulnerabilities with similar
code features. Additionally, Serrano et al. [65] showed that
similar yet different patches could share the same semantic
and change patterns, while Zhang et al. [81] investigated the
patch delays from Android AOSP to the OEM systems.

VII. CONCLUSION

In this paper, we detected and investigated the vulnerabil-
ities propagated from Bitcoin and Ethereum to their forked
projects. To this end, we proposed BlockScope that lever-
aged novel context-based candidate search and a new way
of calculating code similarity to efﬁciently and effectively
identify Type-1/2/3 clones. BlockScope allowed us to discover
101 previously unknown vulnerabilities in 13 out of the 16
popular forked projects of Bitcoin and Ethereum, including 16
from Dogecoin, 6 from Litecoin, 1 from Binance, and 4 from
Optimism. Moreover, the evaluation showed that BlockScope
achieved good precision and high recall both at 91.8% (1.8
times higher recall than that in the state-of-the-art ReDeBug).
We further investigated the propagation and patching processes
of discovered vulnerabilities, and revealed three types of vul-
nerability propagation from Bitcoin/Ethereum to their forked
projects, as well as the long delay (mostly over 200 days) for
releasing patches in Bitcoin’s forked projects (vs. ∼100 days
for Ethereum forks). In the future, we will continue improving
BlockScope and expand its scope to none-blockchain domains,
e.g., different Linux distributions.

13

ACKNOWLEDGMENT

We would like to thank all the reviewers for their valuable
comments and constructive suggestions. This work was par-
tially supported by a direct grant (ref. no. 4055127) from The
Chinese University of Hong Kong.

REFERENCES

[1]

[2]

[3]

[4]

[5]

[6]

[7]

[8]

[9]
[10]

[11]

[12]

[13]
[14]
[15]

[16]

[17]

[18]

[19]

[20]

[21]
[22]
[23]

[24]

exchange,” https://coinmarketcap.com/exchanges/binance/,

“Simian - similarity analyser,” https://www.harukizaemon.com/simian/,
2013.
“Vulnerability Posing Commit for CVE-2021-3401,” https://github.com/
bitcoin/bitcoin/commit/202d853bb, 2014.
“Vulnerability Posing Commit for CVE-2018-17145,” https://github.
com/bitcoin/bitcoin/commit/08096bbb, 2017.
“Bitcoin Inventory Out-of-Memory Denial-of-Service attack,” https://
invdos.net/, 2018.
“Patch for Bitcoin PR#13080,” https://github.com/bitcoin/bitcoin/pull/
13808/commits/18f690ec, 2018.
“Patch for Bitcoin PR#14624,” https://github.com/bitcoin/bitcoin/pull/
14624/commits/3db746be, 2018.
“Patch for Bitcoin PR#15305,” https://github.com/bitcoin/bitcoin/pull/
15305/commits/4433ed0f, 2019.
“Patch for Bitcoin PR#16512,” https://github.com/bitcoin/bitcoin/pull/
16512/commits/6f405a1d, 2019.
“Blockscan,” https://blockscan.com, 2020.
“Binance Chain vs Binance Smart Chain,” https://coincodecap.com/
binance-chain-vs-binance-smart-chain, 2021.
“Patch for CVE-2021-3401,” https://github.com/bitcoin/bitcoin/pull/
16578/commits/a2714a5c, 2021.
“Binance
2022.
“BscScan,” https://bscscan.com/charts, 2022.
“CoinMarketCap,” https://coinmarketcap.com, 2022.
“Dogecoin vs. Bitcoin: Key differences,” https://cointelegraph.com/
dogecoin-for-beginners/dogecoin-vs-bitcoin-key-differences, 2022.
“Ethereum smart
contract best practices
//consensys.github.io/smart-contract-best-practices/known attacks/,
2022.
“Introducing BNB Chain: The evolution of binance smart chain,” https:
//www.binance.com/en/blog/ecosystem, 2022.
“Is Dash better
dash-vs-bitcoin, 2022.
“Optimistic Rollups,” https://ethereum.org/en/developers/docs/scaling/
optimistic-rollups/, 2022.
“Polygon vs Arbitrum vs Optimism: May the best Ethereum
layer
https://academy.youngplatform.com/en/blockchain/
ethereum-layer-2-polygon-vs-arbitrum-vs-optimism/, 2022.
“The Qt framework,” https://www.qt.io/, 2022.
“Scrypt,” https://en.wikipedia.org/wiki/Scrypt, 2022.
“Selecting layer 2: Polygon vs Arbitrum vs Optimism,” https://pixelplex.
io/blog/polygon-vs-arbitrum-vs-optimism-comparison/, 2022.
“What
services/what-is-digibyte-cryptocurrency/, 2022.

than Bitcoin,” https://cryptonews.com.au/guides/

cryptocurrency,” https://crypto-explained.com/

- Reentrancy,” https:

is DigiByte

2 win,”

[25] M. Ahmadi, R. M. Farkhani, R. Williams, and L. Lu, “Finding bugs
using your own code: Detecting functionally-similar yet inconsistent
code,” in Proc. USENIX Security, 2021.

[26] S. Andreina, L. Alluminio, G. A. Marson, and G. Karame, “Estimating
patch propagation times across (blockchain) forks,” CoRR arXiv, vol.
abs/2205.07478, 2022.

[27] P. Bose, D. Das, Y. Chen, Y. Feng, C. Kruegel, and G. Vigna, “SAIL-
FISH: Vetting smart contract state-inconsistency bugs in seconds,” in
Proc. IEEE Symposium on Security and Privacy, 2022.

[28] B. Bowman and H. H. Huang, “VGraph: A robust vulnerable code clone
detection system using code property triplets,” in Proc. IEEE EuroS&P,
2020.

14

[29] T. Chen, R. Cao, T. Li, X. Luo, G. Gu, Y. Zhang, Z. Liao, H. Zhu,
G. Chen, Z. He, Y. Tang, X. Lin, and X. Zhang, “SODA: A generic
online detection framework for smart contracts,” in Proc. ISOC NDSS,
2020.
J. Choi, W. Choi, W. Aiken, H. Kim, J. H. Huh, T. Kim, Y. Kim,
and R. Anderson, “Attack of the clones: Measuring the maintainability,
originality and security of Bitcoin ‘forks’ in the wild,” CoRR arXiv,
vol. abs/2201.08678, 2022.

[30]

[31] A. Chow, “URI argument injection vulnerability in Bitcoin Core 0.18
and earlier,” https://achow101.com/2021/02/0.18-uri-vuln, 2021.
[32] K. Dwyer, “Litecoin vs. Bitcoin,” https://coinmarketcap.com/alexandria/

article/litecoin-vs-bitcoin, 2021.

[33] B. Fenton and T. Black, “Ravencoin: A peer to peer electronic system

for the creation and transfer of assets,” https://ravencoin.org/, 2018.

[34] C. Foundation, “DeFi with Celo and Ethereum,” https://medium.com/

[35]

[36]

celoorg/deﬁ-with-celo-and-ethereum-f978d9dc547f, 2021.
J. Frank, C. Aschermann, and T. Holz, “ETHBMC: A bounded model
checker for smart contracts,” in Proc. USENIX Security, 2020.
J. Frankenﬁeld, “Qtum,” https://www.investopedia.com/terms/q/qtum.
asp, 2021.

[37] Z. Gao, L. Jiang, X. Xia, D. Lo, and J. Grundy, “Checking smart con-
tracts with structural code embedding,” IEEE Transactions on Software
Engineering, 2020.
Hamilton,

“Avalanche
what’s
difference?”
avalanche-avax-vs-ethereum-eth-everything-you-need-to-know/,
2022.

-
Ethereum
https://www.securities.io/

[38] D.

Vs.

the

[39] C. Hoffman, “What’s the difference between Bitcoin, Bitcoin Cash,
Bitcoin Gold, and others,” https://www.howtogeek.com/349263/, 2022.
[40] Q. Hum, W. J. Tan, S. Y. Tey, L. Lenus, I. Homoliak, Y. Lin, and J. Sun,
“CoinWatch: A clone-based approach for detecting vulnerabilities in
cryptocurrencies,” in Proc. IEEE Blockchain, 2020.
J. Jang, A. Agrawal, and D. Brumley, “ReDeBug: Finding unpatched
code clones in entire OS distributions,” in Proc. IEEE Symposium on
Security and Privacy, 2012.

[41]

[42] L. Jiang, G. Misherghi, Z. Su, and S. Glondu, “DECKARD: Scalable
and accurate tree-based detection of code clones,” in Proc. ACM ICSE,
2007.

[43] S. Kalra, S. Goel, M. Dhawan, and S. Sharma, “ZEUS: Analyzing safety

of smart contracts,” in Proc. ISOC NDSS, 2018.

[44] T. Kamiya, S. Kusumoto, and K. Inoue, “CCFinder: A multilinguistic
token-based code clone detection system for large scale source code,”
IEEE Transactions on Software Engineering, 2002.

[45] S. Kim and H. Lee, “Software systems at risk: An empirical study
of cloned vulnerabilities in practice,” Elsevier Computers & Security,
2018.

[46] S. Kim, S. Woo, H. Lee, and H. Oh, “VUDDY: A scalable approach for
vulnerable code clone discovery,” in Proc. IEEE Symposium on Security
and Privacy, 2017.

[47] Y. Kwon, D. Kim, Y. Son, E. Vasserman, and Y. Kim, “Be selﬁsh and
avoid dilemmas: Fork After Withholding (FAW) attacks on Bitcoin,” in
Proc. ACM CCS, 2017.

[48] Y. Li and B. Liu, “A normalized Levenshtein distance metric,” IEEE

Transactions On Pattern Analysis and Machine Intelligence, 2007.

[49] Z. Li, D. Zou, S. Xu, Z. Chen, Y. Zhu, and H. Jin, “VulDeeLocator: A
deep learning-based ﬁne-grained vulnerability detector,” IEEE Transac-
tions on Dependable and Secure Computing, 2021.

[50] Z. Li, D. Zou, S. Xu, H. Jin, Y. Zhu, and Z. Chen, “SySeVR: A
framework for using deep learning to detect software vulnerabilities,”
IEEE Transactions on Dependable and Secure Computing, 2021.
[51] Z. Li, D. Zou, S. Xu, X. Ou, H. Jin, S. Wang, Z. Deng, and Y. Zhong,
“VulDeePecker: A deep learning-based system for vulnerability detec-
tion,” in Proc. ISOC NDSS, 2018.

[52] Z. Li, S. Lu, S. Myagmar, and Y. Zhou, “CP-Miner: A tool for ﬁnding
copy-paste and related bugs in operating system code,” in Proc. USENIX
OSDI, 2004.

[53] L. Luu, D.-H. Chu, H. Olickel, P. Saxena, and A. Hobor, “Making smart

contracts smarter,” in Proc. ACM CCS, 2016.

[54] S. Mancoridis, “Code clone introduction,” https://courses.cs.vt.edu/

cs5704/spring16/handouts/5704-10-CodeClones.pdf, 2016.

under the sun: Understanding and discovering attacks on Ethereum
decentralized applications,” in Proc. Usenix Security, 2021.

[70] B. Tan, B. Mariano, S. K. Lahiri, I. Dillig, and Y. Feng, “SolType:
Reﬁnement types for arithmetic overﬂow in Solidity,” in Proc. ACM
POPL, 2022.

[71] P. Tsankov, A. Dan, D. Drachsler-Cohen, A. Gervais, F. B¨unzli, and
M. Vechev, “Securify: Practical security analysis of smart contracts,” in
Proc. ACM CCS, 2018.

[72] S. M. Werner, D. Perez, L. Gudgeon, A. Klages-Mundt, D. Harz, and
W. J. Knottenbelt, “SoK: Decentralized ﬁnance (DeFi),” CoRR arXiv,
vol. abs/2101.08778, 2021.

[73] G. Wood, “Ethereum: A secure decentralised generalised transaction

ledger,” Yellow paper, 2022.

[74] D. Wu, D. Gao, R. H. Deng, and R. K. C. Chang, “When program
analysis meets bytecode search: Targeted and efﬁcient inter-procedural
analysis of modern Android apps in BackDroid,” in Proc. IEEE DSN,
2021.

[75] Y. Xiao, B. Chen, C. Yu, Z. Xu, Z. Yuan, F. Li, B. Liu, Y. Liu, W. Huo,
W. Zou, and W. Shi, “MVP: Detecting vulnerabilities using patch-
enhanced vulnerability signatures,” in Proc. USENIX Security, 2020.

[76] F. Yamaguchi, N. Golde, D. Arp, and K. Rieck, “Modeling and
discovering vulnerabilities with code property graphs,” in Proc. IEEE
Symposium on Security and Privacy, 2014.

[77] Y. Yang, T. Kim, and B.-G. Chun, “Finding consensus bugs in Ethereum
via multi-transaction differential fuzzing,” in Proc. USENIX OSDI,
2021.

[78] X. Yi, D. Wu, L. Jiang, K. Zhang, and W. Zhang, “Diving into
blockchain’s weaknesses: An empirical study of blockchain system
vulnerabilities,” CoRR arXiv, vol. abs/2110.12162, 2021.

[79] M. Zhang, X. Zhang, Y. Zhang, and Z. Lin, “TxSpecTor: Uncovering
attacks in Ethereum from transactions,” in Proc. USENIX Security,
2020.

[80] R. Zhang and B. Preneel, “Lay down the common metrics: Evaluating
Proof-of-Work consensus protocols’ security,” in Proc. IEEE Sympo-
sium on Security and Privacy, 2019.

[81] Z. Zhang, H. Zhang, Z. Qian, and B. Lau, “An investigation of the

Android kernel patch ecosystem,” in Proc. USENIX Security, 2021.

[82] Y. Zhou, S. Liu, J. K. Siow, X. Du, and Y. Liu, “Devign: Effective vul-
nerability identiﬁcation by learning comprehensive program semantics
via graph neural networks,” in NeurIPS, 2019.

[55] K. W. Naﬁ, T. S. Kar, B. Roy, C. K. Roy, and K. A. Schneider,
“CLCDSA: Cross language code clone detection using syntactical
features and API documentation,” in Proc. ACM ASE, 2019.

[56] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” White

paper, 2008.
News,

“ZenCash

[57] C.
to
zencash-vs-zcash-all-you-need-to-know-300065c9d0d3, 2018.
[58] D. Perez and B. Livshits, “Smart contract vulnerabilities: Vulnerable

need
All
https://medium.com/@importprivkey/

know,”

Zcash:

you

vs.

does not imply exploited,” in Proc. USENIX Security, 2021.

[59] M. Pradel and K. Sen, “DeepBugs: A learning approach to name-based
bug detection,” Proc. ACM on Programming Languages, 2018.
[60] M. Rodler, W. Li, G. O. Karame, and L. Davi, “Sereum: Protecting
existing smart contracts against re-entrancy attacks,” in Proc. ISOC
NDSS, 2019.

[61] ——, “EVMPatch: Timely and automated patching of Ethereum smart

contracts,” in Proc. USENIX Security, 2021.

[62] M. Saad, J. Spaulding, L. Njilla, C. Kamhoua, S. Shetty, D. Nyang,
and A. Mohaisen, “Exploring the attack surface of blockchain: A
comprehensive survey,” IEEE Communications Surveys & Tutorials,
2020.

[63] H. Sajnani, V. Saini, J. Svajlenko, C. K. Roy, and C. V. Lopes,
“SourcererCC: Scaling code clone detection to big code,” in Proc. ACM
ICSE, 2016.

[64] C. Schneidewind, I. Grishchenko, M. Scherer, and M. Maffei, “eThor:
Practical and provably sound static analysis of Ethereum smart con-
tracts,” in Proc. ACM CCS, 2020.

[65] L. Serrano, V.-A. Nguyen, F. Thung, L. Jiang, D. Lo, J. Lawall, and
G. Muller, “SPINFER: Inferring semantic patches for the Linux kernel,”
in Proc. USENIX ATC, 2020.

[66] SFOX, “Ravencoin vs. Bitcoin: How to transfer truth,” https://www.
sfox.com/blog/ravencoin-vs-bitcoin-how-to-transfer-truth/, 2020.
[67] S. So, S. Hong, and H. Oh, “SmarTest: Effectively hunting vulnerable
transaction sequences in smart contracts through language model-guided
symbolic execution,” in Proc. USENIX Security, 2021.

[68] C.

Staff,

“Qtum (QTUM): A hybrid

Bitcoin
qtum-crypto-and-blockchain-evm, 2021.

Ethereum,”

and

blockchain merging
https://www.gemini.com/cryptopedia/

[69] L. Su, X. Shen, X. Du, X. Liao, X. Wang, L. Xing, and B. Liu, “Evil

15

