2
2
0
2

g
u
A
5

]

C
D
.
s
c
[

1
v
5
5
3
3
0
.
8
0
2
2
:
v
i
X
r
a

Blockchain in Dynamic Networks

Rachel Bricker, Mikhail Nesterenko, and Gokarna Sharma

Kent State University, Kent, OH, 44242, USA
rbricke2@kent.edu, mikhail@cs.kent.edu, and gsharma2@kent.edu

Abstract. We consider blockchain in dynamic networks. We deﬁne
the Blockchain Decision Problem. It requires miners that maintain the
blockchain to conﬁrm whether a particular block is accepted. We estab-
lish the necessary conditions for the existence of a solution. We, how-
ever, prove that the solution, even under these necessary conditions is,
in general, impossible. We then present two algorithms that solve the
Blockchain Decision Problem under either the knowledge of the maxi-
mum source pool propagation time or the knowledge of the source pool
membership. We evaluate the performance of the two algorithms.

Keywords: Dynamic Networks · Blockchain

1

Introduction

Blockchain is a means of organizing a decentralized public ledger. The lack of
centralized controller potentially makes the blockchain more resilient to network
failures and attacks. Blockchain is a popular architecture for a number of ap-
plications such as cryptocurrency [17,22], massive Internet-of-Things storage [2]
and electronic voting [9].

The major problem of maintaining this ledger is for the participants to
achieve consensus on its records despite faults or hostile environment. Classic
robust consensus algorithms [5,15] use cooperative message exchanges between
peer processes to arrive at a joint decision. However, such algorithms require that
each process is aware of all the other processes in the network. In a system with
ﬂexible membership, such requirement may be excessive. An alternative is com-
petitive consensus [17] where processes race to have records that they generated
added to the blockchain. This competition does not require ﬁxed membership
and provides defense against attacks and faults.

Ordinarily, the network underlying the blockchain is considered to be always
connected. However, as blockchain ﬁnds greater acceptance and new applica-
tions, this assumption may no longer be considered as a given. Instead, the
blockchain operation under less reliable communication conditions needs to be
examined.

A dynamic network assumes that a connection between any two processes
may appear and disappear at any moment. Therefore, the network connectiv-
ity graph changes arbitrarily from one point of the computation to the next.
This is the least restrictive network connectivity assumption. This paper studies
operation of blockchain in dynamic networks.

 
 
 
 
 
 
2

Rachel Bricker, Mikhail Nesterenko, and Gokarna Sharma

Related work. An area related to dynamic networks is population protocols,
where passive agents do not control their movement but may exchange informa-
tion as they encounter each other. See Michail et al. [16] for an introduction to
the topic. A system with arbitrary link failures was considered by Santoro and
Widmayer [20]. There are several papers that explore the model of link failures
in greater detail [1,6,8].

The network that dynamically changes in an arbitrary manner, possibly to
the detriment of the problem to be solved, was ﬁrst formally studied by O’Dell
and Wattenhofer [18]. This topic is explored in Kuhn et al. [13]. Several stud-
ies [4,10] investigate reliable broadcast in dynamic networks with Byzantine
faults. There is a large body of literature on cooperative consensus in dynamic
networks [3,14,21]. In particular, Winkler et al. [21] explored the concept of an
eventually stably communicating root component necessary for consensus. This
is similar to the concept of source communication pool that we introduce in this
paper.

There are some applied studies [7,12] that consider the operation of
blockchain that tolerates extensive delays or temporary disconnections. Hood
et al. [11] explored in detail the blockchain operation under network partition-
ing.

However, to the best of our knowledge, this paper is the ﬁrst to study

blockchain in dynamic networks.

Paper organization and contribution. In Section 2, we introduce the no-
tation and state the Blockchain Decision Problem for dynamic networks: every
network miner needs to conﬁrm the acceptance of each block. In Section 3, we
establish the conditions for blockchain and the dynamic network so that the
problem is at all solvable: there needs to be a single source pool of continuously
interacting miners that propagate the blocks they generate to the rest of the
network and none of the other miners may generate inﬁnitely many blocks and
propagate them back to the source pool. In Section 4, we prove that in general,
even if these conditions are met, the problem is impossible to solve. Intuitively,
miners may not determine when these outside blocks stop coming. In Section 5,
we present two algorithms that solve the problem with restrictions: KPT – if
maximum message propagation time is known to all miners, KSM – if source
pool membership is known to all miners. We evaluate the performance of the
two algorithms in Section 7. We conclude the paper by Section 8.

2 Notation, Deﬁnitions and Problem Statement

Network. A network N consists of a ﬁxed number of processes or miners. Each
miner has a unique identiﬁer which may or may not be known to the other min-
ers in the beginning. The network computation proceeds in synchronous rounds.
Miners communicate via message passing over uni-directional links connecting
the sender miner ms and receiver miner mr. This is denoted as ms → mr. The
network is dynamic as links may appear or disappear. More speciﬁcally, at the

Blockchain in Dynamic Networks

3

beginning of each round i, the receiver miner receives all messages sent to it dur-
ing the previous round, then carries out calculations and submits messages over
the links that exist in round i to be received in the next round. A computation
is a, possibly inﬁnite, sequence of such rounds.

To simplify the presentation, we ﬁrst assume that the communication is in-
stantaneous. That is, all the information sent over the link is received in the
same round. We also assume that arbitrary amount of information may be com-
municated in one message. We relax these assumptions later in the paper.

A journey in a computation is a sequence of miners and communication
links m1 → · · · → mi → mi+1 → mi+2 → · · · → mx such that each round i
of the computation, where link mi → mi+1 exists, precedes the round with link
mi+1 → mi+2. Journey time is the number of computation rounds between the
ﬁrst and last link in the journey. Note that journey time may be greater than
the total number of links in the journey since it may take more than one round
for each subsequent link in the journey to appear.

Fig. 1: Blockchain notation illustration. Block g is genesis. Block a is rejected because
it is an ancestor to only ﬁnitely many blocks. Alternatively, a belongs to ﬁnite branches
only. Block b is accepted since it is an ancestor to inﬁnitely many blocks. That is, b
belongs to inﬁnite branches. Block a is a cousin of block of b. In an inﬁnite blockchain,
b is accepted if all its cousin branches are ﬁnite.

Blockchain. The introduced terms are illustrated in Figure 1. Blockchain is a
tree of linked blocks. Each mined block is unique and can be distinguished from
the others. Further block contents is immaterial. A block may be linked to a
single parent block. A child is a block linked to a parent. Genesis is the root of
the tree and the only block without a parent. A leaf is the block with no children.
An ancestor of a block b is either a parent of b or, recursively, an ancestor of b.
A descendant of a block b is any block whose ancestor is b. The depth of a block
is the number of its ancestors.

A branch is the maximal sequence of blocks b1, · · · , bi, bi+1, · · · such that b1
is the genesis and for each i, bi is the parent of bi+1. By this deﬁnition, either a
branch is inﬁnite or it ends with a leaf. Given a block b that belongs to a branch,
all blocks preceding b in this branch are its ancestors and all blocks following b
are its descendants. The length of a ﬁnite branch is the depth of its leaf. The
length of an inﬁnite branch is inﬁnite.

A trunk of two branches is their longest shared preﬁx. Thus, the trunk of any
two branches is at least the genesis. A branch is a trunk of itself. The blocks of
the trunk belong to the branches that share this trunk. Consider a block b that
does not belong to the shared trunk of the two branches. Cousins of b are the

4

Rachel Bricker, Mikhail Nesterenko, and Gokarna Sharma

blocks that belong to these branches but neither descendants nor ancestors of b.
These blocks belong to a cousin branch.

Each miner in the network stores all the blockchain blocks known to it.
That is, miners maintain local copies of the blockchain. In the beginning of each
computation, each miner stores the same genesis. Due to the haphazard link
appearance in a dynamic network, local copies of the blockchain may be out of
sync.

In an arbitrary round, a miner m may generate or mine a new block b linked
to the longest branch of the local copy of the blockchain. If m has several branches
of the same length, the new block may be mined on any one of them. Multiple
processes may mine blocks in the same round. Once linked, the sender sends its
entire copy of the blockchain to the receiver. We discuss how to limit the amount
of transmitted information later in the paper. By this operation, the number of
children for any block, i.e. the arity of the blockchain, is at most |N |.

We place few assumptions on the relationship between the relative speed of
communication and block mining. However, we assume the following fairness:
throughout the computation, a miner either receives inﬁnitely many new blocks
or mines inﬁnite many blocks itself. A miner subject to this assumption is a fair
miner, it is an unfair miner otherwise.

The Blockchain Decision Problem. A block is accepted if it is the ancestor
of all but ﬁnitely many blocks. A block is rejected if it is the ancestor of ﬁnitely
many blocks.

In the attempt to agree on the common state of the blockchain, each miner
decides whether the block is accepted by outputting a conﬁrm decision. The
decision about block rejection is implied and is not required. To arrive at this
decision, the miners may store and exchange arbitrary information. We use the
term computation for block mining and blockchain maintenance as well as for
the operation of the algorithm that allows the miners to output decision about
the blocks of this blockchain. We formulate the decision problem as follows.

Deﬁnition 1 (The Blockchain Decision Problem BDP). A solution to
the Blockchain Decision Problem satisﬁes the following properties:
Decision: each miner eventually conﬁrms every accepted block;
Conﬁrmation Validity: each miner conﬁrms only accepted blocks.

3 Decisive Computations

Globally decisive computations. A computation is globally decisive if every
block of its blockchain is uniquely categorized: either accepted or rejected but
not both at once.

Lemma 1. The blockchain of a globally decisive computation has exactly one
inﬁnite branch.

To put the lemma another way: in a decisive computation, all branches except

for one are ﬁnite.

Blockchain in Dynamic Networks

5

Proof. The blockchains that do not conform to the conditions of the lemma
either have no inﬁnite branches or have more than one. If a blockchain does
not have inﬁnite branches at all, then it has a ﬁnite number of blocks. In this
case, every block b is the ancestor of ﬁnitely many blocks. That is, b is rejected.
However, b is also an ancestor of all but ﬁnitely many blocks. That is, b is also
simultaneously accepted. In a globally decisive computation, a block may be
either accepted or rejected but not both.

Let us consider the second case of a blockchain not conforming to the condi-
tions of the lemma: it has multiple inﬁnite branches. Let block b belong to one
such branch but not to the shared trunk of all the branches. Since b belongs to
an inﬁnite branch, it is an ancestor to an inﬁnite number of blocks. Therefore,
b is not rejected. However, there are inﬁnite number of blocks in the inﬁnite
cousin branches, i.e. the branches to which b does not belong. That is, b is not
an ancestor to an inﬁnite number of blocks. Hence, b is not accepted either.

That is, a blockchain with unique categorization of acceptance of rejection
has exactly one inﬁnite branch. A computation must have such a blockchain to
(cid:3)
be decisive. The lemma follows.

Mining pools. In a certain computation, a mining pool M is a maximal set of
miners such that each miner m ∈ M has an inﬁnite number of journeys to every
other miner in M . That is, each miner in a pool is reachable from every other
miner in this pool inﬁnitely often. If, for some miner m, there are no other miners
that are mutually reachable inﬁnitely often, then m forms a pool by itself.

A pool graph PG for a computation C is a static directed graph formed as
follows. Each node in PG corresponds to a mining pool in C. An edge from node
P1 ∈ PG to node P2 ∈ PG exists if there is an inﬁnite number of edges from
miners of pool P1 to the miners of the pool P2.

Let us observe that any pool graph PG is a DAG. Indeed, if there is cycle in
PG, then any miner m1 has an inﬁnite number of journeys to any other miner
m2 in this cycle. Since mining pools are maximal, these miners belong to the
same pool. If PG has a path from pool P1 to pool P2, then any miner m1 ∈ P1
has an inﬁnite number of journeys to any miner m2 ∈ P2. If it does not, then
the number of journeys between P1 and P2 is ﬁnite.

A node in a static graph is a source if it has no incoming edges. Since a DAG
has no cycles, it has at least one source. A source pool is a pool that corresponds
to a source in PG. An inﬁnite branch belongs to a pool if it contains a suﬃx of
blocks where every block is mined by a member of this pool.

Lemma 2. If the blockchain of a computation contains an inﬁnite branch, this
branch belongs to a single pool.

Proof. Assume that there is a computation C whose blockchain has an inﬁnite
branch BR that does not belong to a single pool. That is, branch BR contains
inﬁnitely many blocks mined by miners in at least two separate pools P1 and
P2. The pool graph PG of C contains no cycles. That means that there is a path
from one pool to the other but not back. Suppose, without loss of generality,

6

Rachel Bricker, Mikhail Nesterenko, and Gokarna Sharma

that there is no path from P1 to P2. This means that there is a ﬁnite number of
journeys from miners of P1 to P2 in C. Let round r be the last round of C that
contains the journey from P1 to P2. However, there are inﬁnitely many blocks
in BR that are mined by miners in P1 and in P2. Consider two blocks b1 and
b2 of BR mined after round r such that b1 is mined by miner m1 ∈ P1 and b2
by miner m2 ∈ P2. Moreover, b1 is the ancestor of b2. If this is the case, there
is a journey from m1 to m2 in C. However, we assumed that there are no such
journeys after round r in C. That is, our assumption is incorrect and C does not
(cid:3)
exist. This proves the lemma.

Locally decisive computations. A computation is locally decisive if it is glob-
ally decisive and each miner receives every accepted block.

Lemma 3. In a locally decisive computation, inﬁnite branches belong to a source
pool.

Proof. Assume that there is a locally decisive computation C whose blockchain
contains an inﬁnite branch BR that does not belong to source pools of C. Ac-
cording to Lemma 2, BR belongs to some pool P . Since the pool graph of C is
a DAG, it must have a source pool SP . A source pool has a ﬁnite number of
journeys from the miners outside itself.

Computation C is locally decisive. This means that all miners, including the
miners in SP , receive all blocks in BR. Yet, BR is inﬁnite. This means that
there are inﬁnitely many journeys from miners in P to the miners in SP . This
(cid:3)
means, contrary to our initial assumption, that SP is not a source pool.

Lemma 4. In a locally decisive computation, there is a single source pool.

Proof. Assume the opposite: there is a locally decisive computation C with at
least two source pools: SP1 and SP2. Since a locally decisive computation is
also a globally decisive computation, according to Lemma 1, C contains a single
inﬁnite branch. According to Lemma 2, this branch belongs to a single pool
and, according to Lemma 3, this pool is a source. That is, the inﬁnite branch
belongs to either SP1 or SP2. Let it be SP1. This means that miners of SP1
mine inﬁnitely many blocks that belong to the inﬁnite branch. Since C is globally
decisive, these blocks are accepted.

However, SP2 is also a source, this means that it has a ﬁnite number of
journeys from miners outside itself. Yet, since C is locally decisive, the miners in
SP2 need to receive the inﬁnite number of blocks mined in SP1. That is, there
are inﬁnite number of journeys from the miners of SP1 to the miners of SP2.
(cid:3)
That is, SP2 is not a source.

The following theorem summarizes the results proven in Lemmas 1, 2, 3 and 4.

Theorem 1. If a computation is globally and locally decisive, then it has exactly
one inﬁnite branch and one source pool. Moreover, this inﬁnite branch belongs
to this source pool.

Blockchain in Dynamic Networks

7

4

Impossibility

In a solution to the Blockchain Decision Problem, every miner is required to
conﬁrm each accepted block. Theorem 1 states necessary conditions for the pos-
sibility of the solution. Yet, even if these conditions are satisﬁed, a miner may
make a mistake. Indeed, assume a miner m determines that a certain block b
belongs to the longest branches of all processes in the source pool. Miner m
conﬁrms it. Yet, a non-source pool miner may later mine a longer cousin branch
to b, communicate it to the source pool forcing rejection of b. This makes m’s
conﬁrmation incorrect. Even though, by deﬁnition of the source pool, such links
from the outside happen only ﬁnitely many times, the time they stop is not
predictable. This makes the solution, in the general case, impossible. The below
theorem formalizes this intuition.

Theorem 2. There does not exist a solution to the Blockchain Decision Problem
even for globally and locally decisive computations.

Proof. Assume there is an algorithm A that solves BDP for globally and locally
decisive computations. Consider a globally and locally decisive computation Cx
which contains mining pools P1 and P2 such that P1 is the source pool.

Since Cx is globally and locally decisive, according to Theorem 1, it has
a single inﬁnite branch, a single source pool and the branch belongs to this
source pool. This means that there are inﬁnite number of blocks in the inﬁnite
branch. All these blocks are accepted. After some round r1 they must be mined
in P1. Let block b be one such block. Since the computation is locally decisive,
b has to reach miners in P2. The Decision Property of BDP requires that all
miners eventually conﬁrm accepted blocks. This means that miners of P2 have
to eventually conﬁrm b. Let r2 be the round where some miner m2 ∈ P2 conﬁrms
b in Cx.

Consider a computation Cy that has an extra pool P3. Communication in Cy
is as follows. Miners of pool P3 have no links to the outside miners until round
r2. Since the miners of P3 do not inﬂuence other miners, we construct Cy such
that up to the round r2, the actions of miners of P1 and of P2 are the same
as in Cx. This includes m2 conﬁrming block b. We construct the remainder of
Cy as follows. Miners of P3 have only outgoing links to miners of P1 and P2 for
the remainder of Cy. That is, P3 is a source. We construct Cy to be locally and
globally decisive. That is, we make P3 its own single inﬁnite branch.

By construction, miners of P1 never send messages to miners of P3. This
means that block b mined in P2 does not reach P3. Hence, b does not belong
to the inﬁnite branch. Therefore, b is rejected. However, miner m2 conﬁrms
it in Cx and, therefore, in Cy. This is contrary to the Conﬁrmation Validity
property of BDP, which stipulates that miners may conﬁrm only accepted blocks.
Thus, despite our initial assumption, algorithm A does not solve the Blockchain
(cid:3)
Decision Problem. Hence, the theorem.

8

Rachel Bricker, Mikhail Nesterenko, and Gokarna Sharma

5 Solutions

Previously, we considered completely formed inﬁnite blockchain trees. However,
to solve the Blockchain Decision Problem, individual miners have to make deci-
sions whether a particular block is accepted or rejected on the basis of a tree that
is not yet complete. Moreover, a miner may not be aware of some already mined
blocks due to propagation delays. To describe this uncertainty, we introduce
additional notation.

A branch BR is dead if all miners are mining on cousin branches longer than
BR. A branch is live otherwise. Notice that once a branch is dead, it may not
become live. Thus, a block belongs to dead branches only, it is rejected. In an
inﬁnite computation, a block is accepted if it belongs to all inﬁnite branches.
To put another way, a block is accepted if all its cousin branches are dead. The
algorithms in this section exploit the miners’ ability to detect dead branches to
conﬁrm accepted blocks.

Per Theorem 2, the solution to the Blockchain Decision Problem is impossible
if non-source-pool miners are able to send their mined blocks to the source pool.
We, therefore, consider the following restriction. A mining pool is initially closed
if its members do not have incoming edges from non-pool members. If source
pool is initially closed, to evaluate whether the branch is dead, it is suﬃcient to
consider blocks generated by source pool miners only.

Known propagation time. Let m be an arbitrary miner in the source pool.
Source pool propagation time P T is the time of the longest journey from m to
any other miner in the network. If P T is ﬁxed, it takes at most P T rounds
for a message sent by m to reach all miners. If P T is known, the solution to
BDP seems straightforward as dead branches eventually become shorter than
live ones. However, this solution is not immediate since, even with ﬁxed P T , the
length diﬀerence between live branches may be arbitrarily large. Indeed, a miner
may mine a number of blocks extending its branch length signiﬁcantly. However,
other miners may subsequently mine on their branches catching up and keeping
their branches live.

Instead, to detect a dead branch, the algorithm that solves BDP, relies on
the branch length diﬀerence over a certain period of time. We call this algorithm
KPT. Its code is shown in Figure 1. The algorithm operates as follows. Each
miner p maintains the local copy of the blockchain tree T and a set of per-block
labels L where it stores decisions whether the block is accepted or rejected. If
the decision is not reached, the block is unlabeled. Once block b is mined, it is
added to the tree T . If a link to some miner q appears, miner p sends its entire
blockchain to q.

The decisions are reached as follows. An unlabeled block b1 is labeled rejected
if for its every branch BR(b1) the following happens. There is a cousin block b2
such that the depth of b2 is greater than the length of this branch BR(b1) for
at least 2 · P T rounds. An unlabeled block b is accepted if all its cousins are
rejected. In the latter case, b is conﬁrmed.

Blockchain in Dynamic Networks

9

Algorithm 1: Known Source Pool Propagation Time Algorithm KPT.

1 Constants:
2 p
3 P T

// miner identifier
// source pool propagation time, integer

4 Variables:
5 T
6 L // set of tuples (cid:104)b, l(cid:105), where b ∈ T and l is either accept or reject

// blockchain tree, initially genesis

initially ∅, if b ∈ T and b (cid:54)∈ L, then b is unlabeled

7 Actions:
8 if mined block b then
add b to T
9

10 if available link to miner q then
11

send T to q

12 if receive Tq from miner q then
13

merge T and Tq

14 if exists unlabeled b1 such that for every BR(b1), there is a cousin bock b2 such

that depth(b2) > BR(b1) for at least 2 · P T rounds then

15

add (cid:104)b1, reject(cid:105) to L

16 if exists unlabeled b such that for its every cousin c: (cid:104)c, reject(cid:105) ∈ L then
17

add (cid:104)b, accept(cid:105) to L
conﬁrm b

18

Lemma 5. Let, at some round r, some miner m observe that there is a block b
whose depth is greater than the length of its cousin branch BR. If b’s depth is
still greater than the length of BR at round r + 2 · P T , then BR is dead.

Proof. Assume block b is mined by miner mb of the source pool in round rb.
Since the maximum source pool propagation time P T is ﬁxed, in round rb + P T
every miner receives b. If there is a branch BR that is shorter than the depth of
mb in round rb + P T , then every miner mc that mines on branch BR or shorter
branches, switches to a branch that contains b or a longer branch. That is, BR is
dead by rb + P T . Therefore, blocks may be mined on BR no longer than round
rb + P T . It takes any block at most P T rounds to propagate to all miners in the
network.

Let us consider an arbitrary miner m. Since b is mined in round rb, the earliest
round when m may receive b is also rb. That is, if some miner m observes that
there is a block whose depth is greater than some branch for 2 · P T rounds, then
(cid:3)
this branch is dead.

Theorem 3. Known Source Pool Propagation Time Algorithm KPT solves the
Blockchain Decision Problem with initially closed source pool.

Proof. Let us consider the Conﬁrmation Validity Property of BDP. According
to Lemma 5, If P T is known and if miner p observes that some block is deeper

10

Rachel Bricker, Mikhail Nesterenko, and Gokarna Sharma

than the height of a branch for longer than 2 · P T rounds, then this branch is
dead. If some block belongs to dead branches only, it is rejected. This is the
exact condition under which blocks are labeled rejected in KPT, see Line 14. If
all cousins are rejected, the block is accepted. This is how the is block is labeled
accepted and conﬁrmed in KPT, see Line 16. To put another way, KPT conﬁrms
only accepted blocks which satisﬁes the Conﬁrmation Validity Property of BDP.
Let us now discuss the Decision Property and show that every accepted block
is eventually conﬁrmed. Indeed, according to Lemma 5, a miner determines that
a branch is dead in at most 2 · P T rounds. A block is rejected once all branches
that it belongs to are dead. That is, a block rejection is determined in this many
rounds after the last branch of the block is dead.

A block is labeled accepted and then conﬁrmed after all its cousins are re-
jected. To put another way, a block is accepted after at most 2 · P T rounds of
the rejection of the last cousin block. This proves that all accepted blocks are
(cid:3)
eventually conﬁrmed and KPT satisﬁes the Decision Property of BDP.

Let us describe a couple of simple enhancements of KPT. Since miners never
make mistakes in their classiﬁcation of reject and accept, a miner may send its
label set L to help its neighbors make their decisions faster. Also, a miner may
determine dead branches quicker if each block is labeled with the round of its
mining. In this case, to ascertain that a certain branch BR is dead, it is suﬃcient
to check if there is a cousin block b2 such that BR does not outgrow b2 for P T
rounds.

Known source pool membership. Miner position in a blockchain tree is
the block on which it is currently mining. Note that the depth of a miner’s
position throughout the computation may only increase. Once it is observed
that all source pool miners moved to positions longer than a particular branch,
the source pool miners may not mine on this branch. That is, the branch is dead.
We state this formally in the following lemma.

Lemma 6. If some miner m observes that there is a branch BR such that the
depth of the position of every source pool miner is greater than the length of BR,
then BR is dead.

Determining source pool miner positions directly from mined blocks in the
blockchain is not always possible: some source pool miner, even if it is fair, may
never mine a block if it keeps receiving longer branches. Instead, the below algo-
rithm relies on miners directly reporting their positions. We call this algorithm
KSM. Its code is shown in Figure 2. Similar to KPT, it maintains the blockchain
tree T and a set of accept/reject labels per each block L. Besdies those, KSM also
maintains set P where it records the positions of all miners in the source pool.
Each miner sends its collected positions together with the blockchain along all
outgoing links. A block is rejected if all its branches are shorter than the known
positions of the source pool miners. Note that non-source pool miners may still
mine on the dead branches and extend them. However, since the source pool
is closed and the source pool miners never see these non-source pool generated

Blockchain in Dynamic Networks

11

Algorithm 2: Known Source Pool Membership Algorithm KSM.

1 Constants:
2 p
3 SM

// miner identifier
// set of ids of source pool miners

4 Variables:
5 T
6 P // set of tuples (cid:104)b, m(cid:105), where b ∈ T and m ∈ SM , initially ∅,

// blockchain tree, initially genesis

positions of source pool miners

7 L // set of tuples (cid:104)b, l(cid:105), where b ∈ T and l is either accept or reject
initially ∅, if b ∈ T and b (cid:54)∈ L, then b is unlabeled, block
labels

8 Actions:
9 if mined block b then
add b to T
10
if p ∈ SM then

11

12

update p’s entry in P to (cid:104)b, p(cid:105)

13 if available link to miner q then
14

send T, P to q

15 if receive Tq, Pq from miner q then
16

merge T and Tq, merge P and Pq
if p ∈ SM then

let b be the deepest block in T
update p’s entry in P to (cid:104)b, p(cid:105)

17

18

19

20 if exists unlabeled b1 such that for every BR(b1), for all m ∈ SM there exists

(cid:104)b2, m(cid:105) ∈ P such that depth(b2) > BR(b1) then

21

add (cid:104)b1, reject(cid:105) to L

22 if exists unlabeled b such that all cousins of b are reject then
23

add (cid:104)b, accept(cid:105) to L
conﬁrm b

24

blocks, they are never added to the live branches. The block labeling is sim-
ilar to KPT. Once the dead branches are determined and the rejected blocks
are labeled, the blocks whose cousins are dead are accepted and conﬁrmed. The
correctness argument is similar to that of KPT. It is stated in Theorem 4.

Theorem 4. Known Source Pool Membership Algorithm KSM solves the
Blockchain Decision Problem with initially closed source pool.

Observe that in KSM, all miners know the source pool membership. Thus, a
miner that is not in the source pool knows that all the blocks that it mines are
rejected. So this miner may either not mine its own blocks at all or discard them
as soon as they are mined.

12

Rachel Bricker, Mikhail Nesterenko, and Gokarna Sharma

6 Extensions and Optimizations
The algorithm presentation and discussion in the previous sections focused on
simplicity. However, there are optimizations that can be implemented to make
the algorithms more applicable and more generic. We are going to list them here.
In the previous section, we assumed that the pool is initially closed. However,
both algorithms could be modiﬁed to operate correctly if there is a known upper
bound when the source pool is closed. That is, all miners are aware of the round
number after which there are no incoming links for source pool miners from
non-source pool miners.

Also, we assumed that each miner is sending the entire copy of its blockchain.
This is unnecessary. First, with no modiﬁcations, both algorithms operate cor-
rectly even if each miner sends only its longest branch. That is, the branch that
it is currently mining on. However, further sending optimization is possible. Ob-
serve that the operation of the algorithms hinges on the miners communicating
inﬁnitely often. Thus, if a miner keeps track of the blocks it already sent, it is
suﬃcient to send only the oldest, i.e. the deepest unsent block over each link.
With this modiﬁcation, the two algorithms, KPT and KSM, transmit only log N
bytes in every message. That is, the two algorithms use constant size messages.
We assumed that link communication is instantaneous. However, the algo-
rithms remain correct even if a message in each link is delayed for arbitrary
time.

It is interesting to consider message loss. If there is fair message loss that
allows ultimate progress, the two algorithms operate correctly if each miner sends
the entire blockchain or the longest branch in every message. However, since
the feedback communication between receiver and sender is not guaranteed, we
suspect that constant message size algorithm for either known pool membership
or known propagation time does not exist.

7 Performance Evaluation

For our performance evaluation studies, we used QUANTAS abstract simula-
tor [19]. We generated dynamic topologies as follows. The maximum number of
potential neighbors mx ≤ |N | − 1 was ﬁxed. Each round, for every miner, the
number of actual neighbors was selected uniformly at random from 0 to mx; the
neighbor identiﬁers were also selected randomly. Miners generated blocks at the
rate of 2.5%.

In the ﬁrst experiment, we studied the dynamics of block acceptance as the
source pool membership changed. The results are shown in Figure 2. We ran
the computations for 300 rounds. In the ﬁrst 100 rounds, the neighbors were
selected from the whole network. That is, the complete network was the source
pool. In the second 100 rounds, (cid:98)25(cid:99)% of miners were selected to be the source
pool. Speciﬁcally, the source pool miners may connect to arbitrary neighbors, i.e.
they have no connection restrictions. The remaining miners may connect only
to non-source pool miners. In the remaining 100, the restrictions were lifted and
all miners formed the single source pool again.

In a particular state of the computation, some block is accepted if it is in
the longest branch of every miner. That is, every miner is mining on top of

Blockchain in Dynamic Networks

13

Fig. 2: Acceptance rate change as source
pool membership is modiﬁed: complete net-
work from rounds 0 to 99, 25% from 100 to
199, and complete network thereafter.

Fig. 3: Conﬁrmation time vs. maximum
neighborhood size.

this block. The acceptance rate is the ratio of accepted vs. generated blocks.
We ran experiments for the network size of 100, 250 and 500 miners. We did 10
experiments per network size and averaged our results.

The results indicate that, as the source pool size is restricted, the block
acceptance rate declines. This is due to the source pool neighbors not receiving
the blocks from non-source pool neighbors. The acceptance rate sharply rises
as the the source pool is enlarged to incorporate all miners and long chains of
blocks mined outside the source pool are propagated throughout the network.
The acceptance rate is lower in the networks of larger size. Indeed, as more
concurrent blocks are generated, fewer of them are accepted.

In the next experiment, we observed how the neighborhood size aﬀects the
time it takes our algorithms to conﬁrm the blocks. We implemented KSM and
KPT and measured their conﬁrmation time. The conﬁrmation time for a partic-
ular block is the number of rounds from the round when the block was generated
till the round when the last miner outputs the conﬁrmation decision. We counted
conﬁrmation time for accepted blocks only. We varied the maximum number of
neighbors mx and observed average conﬁrmation time for KSM and KPT. The
network size was 100, the source pool was ﬁxed at 75 miners.

Algorithm KPT, needs maximum propagation time PT to be known in ad-
vance. To determine PT we ran preliminary computations. For a ﬁxed mx, we
computed PT by running 100 computations with this mx and computing the
longest recorded propagation time. These preliminary computation lengths were
set between 10, 000 and 15, 000 rounds. Then, for measurement computations, to
collect suﬃciently many conﬁrmed blocks, we set computation lengths to 12 · P T
rounds. We ran 10 experiments per data point.

The results are shown in Figure 3. They indicate that, as the maximum
possible number of neighbors increases, the blocks are propagating faster and the
conﬁrmation time drops. Perhaps surprisingly, KSM performed better because
each miner can conﬁrm a block as soon as it receives the data from all the known
source pool miners, while, in KPT, a miner has to wait for twice the maximum

0%5%10%15%20%25%30%35% 0 50 100 150 200 250 300Average Acceptance RateRoundsNetwork Size100250500 4 8 16 32 64 128 256 512 1024 0 10 20 30 40 50 60 70 80 90 100Average Confirmation Time, roundsMax Number of NeighborsAlgorithmKSMKPT14

Rachel Bricker, Mikhail Nesterenko, and Gokarna Sharma

propagation time PT. This holds even though we ran preliminary computations
to select the shortest possible maximum propagation time PT.

Fig. 4: Acceptance Rate vs. maximum neigh-
borhood size.

Fig. 5: Conﬁrmation time vs. network size.

For the same experiment, we computed average acceptance rate. We show the
results in Figure 4. Algorithm KSM has lower conﬁrmation time and, therefore,
higher acceptance rate.

In the ﬁnal experiment, we observed the performance of the two algorithms
as the network scale changes. The number of source pool members is ﬁxed at
(cid:98)75(cid:99)% of the network size. The computation lengths were set to 12 · P T rounds.
We ran 10 computations per data point. The results are shown in Figure 5.
As the network scale increases, mx increases also. This increases the number of
potential journeys and decreases P T , which, in turn, decreases the conﬁrmation
time of KPT that depends on P T . KSM exhibits the opposite dynamics. With
larger scale, the number of source pool miners increases also. This makes KSM
run slightly slower as every miner has to wait to hear from a greater number of
source pool miners.

Our performance evaluation shows that KSM outperforms KPT under all
conditions. Therefore, KPT should be considered only when the source pool
membership is not available and KSM is not implementable.

8 Conclusion
In this paper, we studied the operation of blockchain in dynamic networks. We
explored how blockchain behaves at the boundaries of connectivity: where mes-
sage delay and miner participation is tenuous while connection and commu-
nication speeds vary greatly. We believe this contributes to the knowledge of
blockchain as a construct and helps engineers to design blockchain for high-
stress, uncertain communication environments.

References

1. Y. Afek and E. Gafni. Asynchrony from synchrony. In International Conference

on Distributed Computing and Networking, pages 225–239. Springer, 2013.

2. O. Alphand, M. Amoretti, T. Claeys, S. Dall’Asta, A. Duda, G. Ferrari,
F. Rousseau, B. Tourancheau, L. Veltri, and F. Zanichelli. Iotchain: A blockchain
security architecture for the internet of things. In WCNC, pages 1–6. IEEE, 2018.

15%20%25%30%35%40%45% 10 20 30 40 50 60 70 80 90 100Average Acceptance RateMax Number of NeighborsAlgorithmKSMKPT 4 8 16 32 64 128 256 512 1024 0 50 100 150 200 250 300Average Confirmation Time, roundsNetwork SizeAlgorithmKSMKPTBlockchain in Dynamic Networks

15

3. M. Biely, P. Robinson, and U. Schmid. Agreement in directed dynamic networks.
In International Colloquium on Structural Information and Communication Com-
plexity, pages 73–84. Springer, 2012.

4. S. Bonomi, G. Farina, and S. Tixeuil. Reliable broadcast in dynamic networks with
In International Symposium on Stabilizing,

locally bounded byzantine failures.
Safety, and Security of Distributed Systems, pages 170–185. Springer, 2018.

5. M. Castro and B. Liskov. Practical byzantine fault tolerance and proactive recov-

ery. ACM Trans. Comput. Syst., 20(4):398–461, Nov. 2002.

6. B. Charron-Bost and A. Schiper. The heard-of model: computing in distributed

systems with benign faults. Distributed Computing, 22(1):49–71, 2009.

7. X. Cong, L. Zi, and D.-Z. Du. Dtnb: A blockchain transaction framework with
discrete token negotiation for the delay tolerant network. IEEE Transactions on
Network Science and Engineering, 8(2):1584–1599, 2021.

8. E. Coulouma, E. Godard, and J. Peters. A characterization of oblivious message

adversaries for which consensus is solvable. TCS, 584:80–90, 2015.

9. P. Grontas and A. Pagourtzis. Blockchain, consensus, and cryptography in elec-

tronic voting. Homo Virtualis, 2(1):79–100, 2019.

10. R. Guerraoui, J. Komatovic, P. Kuznetsov, Y.-A. Pignolet, D.-A. Seredinschi, and
A. Tonkikh. Dynamic byzantine reliable broadcast. In 24th International Confer-
ence on Principles of Distributed Systems, 2021.

11. K. Hood, J. Oglio, M. Nesterenko, and G. Sharma. Partitionable asynchronous
cryptocurrency blockchain. In 2021 IEEE International Conference on Blockchain
and Cryptocurrency (ICBC), pages 1–9. IEEE, 2021.

12. Y. Hu, A. Manzoor, P. Ekparinya, M. Liyanage, K. Thilakarathna, G. Jourjon,
and A. Seneviratne. A delay-tolerant payment scheme based on the ethereum
blockchain. IEEE Access, 7:33159–33172, 2019.

13. F. Kuhn, N. Lynch, and R. Oshman. Distributed computation in dynamic net-
works. In Proceedings of the forty-second ACM symposium on Theory of computing,
pages 513–522, 2010.

14. F. Kuhn, Y. Moses, and R. Oshman. Coordinated consensus in dynamic networks.
In Proceedings of the 30th annual ACM SIGACT-SIGOPS symposium on Princi-
ples of distributed computing, pages 1–10, 2011.

15. L. Lamport, R. Shostak, and M. Pease. The byzantine generals problem. ACM

Trans. Program. Lang. Syst., 4(3):382–401, July 1982.

16. O. Michail, I. Chatzigiannakis, and P. Spirakis. New models for population proto-
cols. Synthesis Lectures on Distributed Computing Theory, 2(1):1–156, 2011.

17. S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system,”, 2008.
18. R. O’Dell and R. Wattenhofer.

Information dissemination in highly dynamic
graphs. In Proceedings of the 2005 joint workshop on Foundations of mobile com-
puting, pages 104–110, 2005.

19. J. Oglio, K. Hood, M. Nesterenko, and S. Tixeuil. Quantas: Quantitative
arXiv preprint

user-friendly adaptable networked things abstract simulator.
arXiv:2205.04930, 2022.

20. N. Santoro and P. Widmayer. Time is not a healer.

In Annual Symposium on

Theoretical Aspects of Computer Science, pages 304–313. Springer, 1989.

21. K. Winkler, M. Schwarz, and U. Schmid. Consensus in rooted dynamic networks

with short-lived stability. Distributed Computing, 32(5):443–458, 2019.

22. G. Wood. Ethereum: A secure decentralized generalized transaction ledger.

Ethereum project yellow paper, 151:1–32, 2014.

