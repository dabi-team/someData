1
2
0
2

g
u
A
4

]

B
D
.
s
c
[

2
v
2
9
5
1
1
.
7
0
1
2
:
v
i
X
r
a

Blockchain Transaction Processing

Suyash Gupta, Mohammad Sadoghi

Synonyms

Overview

• Blockchain Data Management
• Blockchain Consensus
• Cryptocurrency

Deﬁnitions

an

A blockchain
append-only
is
linked-list of blocks, which is main-
each participating node.
tained at
Each block records a set of transac-
tions and their associated metadata.
Blockchain transactions act on the
ledger data stored at each
identical
node. Blockchain was ﬁrst perceived
by Satoshi Nakamoto (Satoshi 2008)
as a peer-to-peer digital-commodity
(also known as crypto-currency) ex-
change system. Blockchains received
traction due to their inherent property of
immutability—once a block is accepted,
it cannot be reverted.

research across

In 2008, Satoshi Nakamoto (Satoshi
2008) introduced the design of an unan-
ticipated technology that revolutionized
the
the distributed
systems community. Nakamoto pre-
sented the design of a peer-to-peer
system,
digital-commodity exchange
which although employed by several
participants, prevents the use of a cen-
tralized design. Nakamoto envisioned a
system where the participants exchange
commodities among themselves in a
democratic, decentralized and trans-
parent manner while upholding their
right to privacy. Nakamoto visualized
this digital-commodity as a monetary
token that could be used by partici-
pants to provide or receive services.
This led to the birth of Bitcoin—a
cryptocurrency—and introduction of a
new design paradigm Blockchain.

A blockchain in its simplest form is
an append-only linked-list of blocks.

1

 
 
 
 
 
 
2

Suyash Gupta, Mohammad Sadoghi

at the execution layer and persisted in
the storage
the immutable ledger at
layer. Clients and servers also employ
necessary cryptographic constructs to
securely exchange messages among
each other.

The preceding discussion allows us
to summarize that a blockchain system
aims at providing a safe and resilient
storage for
In the suc-
transactions.
ceeding sections, we will discuss these
concepts in detail and will illustrate the
mechanisms pertaining to blockchain
transaction processing. We will also
study key principles required to order
transactions
and validate these client
and provide analysis of some existing
blockchain applications.

Key Research Findings

transactions

Each blockchain system can be visu-
alized as a secure representation of a
traditional database system (Nawab
2018). Similar to a database system,
each blockchain application also re-
ceives
from multiple
clients. In its vanilla form, a blockchain
transaction is a collection of read or
write operations. Clients issue these
transactions to the servers for processing
and exchange of digital-commodities.
in

a
each
blockchain application stores a full-
copy of the chain. Hence, without any
loss of generality, we can claim that
servers of a blockchain system are
replicas of each other. In speciﬁc, a
blockchain application lays down a
replicated design where each replica
participates in ordering and executing
the incoming client transaction.

general,

server

In

Fig. 1: Basic Blockchain Representations

Each block in this chain is linked to
the previous block in the chain Gupta
et al (2019a, 2020a). Blockchains are
often termed as immutable as modifying
an existing block requires modifying
all
the previous blocks in the chain.
Each block includes a set of transactions
and the associated meta-data. Figure 1
presents a schematic representation of a
blockchain. Blockchain systems guar-
antee decentralization as the full-copy
of the chain is maintained by several
participants1. Moreover, a block is only
accepted into the chain after all
the
participants have reached consensus on
the order and contents of the block. In
speciﬁc, admittance of a block to the
chain implies that the transactions iin the
block have been executed and veriﬁed.
Hence, blockchain helps in achieving
key properties such as democracy and
transparency.

A blockchain system can be de-
scribed as a collection of layers. At
the application layer, there are clients,
which send their transactions to a set of
severs to process. The communication
among the clients and servers take
place at the networking layer. Servers
the ordering layer to
participate at
assign a unique order to each incoming
client transaction in a Byzantine Fault-
Tolerant (henceforth referred to as BFT)
manner. Following a successful order-
ing, the client transaction is processed

1 In sharded blockchain systems, no shard may
have complete copy but data is still securely
replicated.

Blockchain Transaction Processing

3

it

Prior works have shown that

is
possible to make a replicated system
handle failures (Lamport 1998; Steen
and Tanenbaum 2017). In any replicated
system, replicas participate in a fault-
tolerant consensus protocol
to decide
the order to execute a client transaction.
Blockchain applications also adhere
to this philosophy. They employ a
BFT consensus protocol
to achieve
consensus under byzantine failures. But,
why do BFT protocols need to handle
byzantine failures? As a blockchain
system promotes democracy, it permits
display of
adversarial behavior by
malicious replicas during consensus. To
tackle such malicious activities, each
blockchain application relies on the
design and properties dictated by a BFT
consensus protocol.

Blockchain Topologies

that

renders

A key parameter
the
design of a blockchain system is its
underlying application. On the basis of
permissions available to a participating
node, a blockchain application can be
categorized blockchain as permissioned,
permissionless or hybrid (Pilkington
2015; Cachin and Vukolic 2017).
Although the blockchain community
agrees on the characteristics of a
permissionless or public blockchain
infrastructure, there is a lack of concise
deﬁnitions to explain other models.

On the basis of topology, we cate-
gorize a blockchain systems under four
heads: public, private, permissioned
and hybrid. Figure 2 presents a pic-
torial
the different
categories. In these ﬁgures, nodes that
lack any connections are disallowed

representation of

from participating in the management
of
the blockchain. Further, we use
circles to demarcate different zones of
operation; certain nodes are allowed to
lead the consensus (or create the next
block) while some nodes are allowed to
participate in the consensus protocol.
Public Blockchain systems,
2008)

such
as Bitcoin
and
(Satoshi
Ethereum (Wood 2015), allow any
node to participate in the consensus
process and propose the next valid block
for the chain. Hence, a public or per-
missionless blockchain system upholds
its democratic nature by providing each
node with equal probability2 of creating
the next block to be added to the chain.
Private Blockchain systems run at
the other extreme end of the spectrum.
These blockchain systems permit only
a speciﬁc set of nodes to be part of
the consensus protocol and restrict the
creation of next block to an even smaller
subset of nodes. Private blockchain de-
signs are attractive to large multi-sector
companies and banks, which may chose
to allow some of their customers to
participate in the consensus protocol,
while restricting creation of next block
to its employees.

Hybrid Blockchain systems attain
a middle ground between the two
extremes. Although these systems allow
any node to be part of the consensus
protocol, they restrict the task of propos-
ing and creating the next block to a
designated subset of replicas. For in-
stance, Ripple (Schwartz et al 2014)—a
cryptocurrency—supports a variant of
the hybrid model. In Ripple, only some
public institutions have the permissions

2 The equal probability of creating a block is
only guaranteed when all the nodes have ex-
actly same amount of resources, and each node
is working independently.

4

Suyash Gupta, Mohammad Sadoghi

(a) Public Blockchain.

(b) Hybrid Blockchain.

(c) Permissioned Blockchain.

(d) Private Blockchain.

Fig. 2: Topologies for Blockchain Systems.

to select the transactions that will be
part of the next block.

et

Amidst all

these topologies, per-
missioned blockchain systems have
successfully created a niche space for
their design (Androulaki et al 2018;
Gupta
al 2020c). Permissioned
blockchain applications allow any node
participate in the consensus protocol but
require the identities of all participants
to be known a priori. Although partici-
pants loose their privacy, permissioned
blockchain applications provide each
participant equal opportunity to propose
the next block. Notice that permissioned
blockchain applications place no other
special restrictions on the behavior of
a participant. Hyperledger Fabric (An-
droulaki et al 2018), Libra coin (Libra
2019) and RESILIENTDB (Gupta et al

2020c) are some of the state-of-the-art
permissioned blockchain applications
and fabrics.

Blockchain Transactional Flow

The initial block of any blockchain is
termed as the genesis block (Decker and
Wattenhofer 2013). Genesis block is
a special block that is numbered zero,
and is hard-coded in every blockchain
application. Each other block links to
some previously existing block. Hence,
a blockchain grows by appending new
blocks to the existing chain.

A transaction in a blockchain system
is identical to any distributed or OLTP
transaction (TPP Council 2010) that acts

Blockchain Transaction Processing

5

on some data. Traditional blockchain
applications (such as Bitcoin) consist
of transactions that represent an ex-
change of money between two entities
(or users). Each valid transaction is
recorded in a block, which can can con-
tain multiple transactions, for efﬁciency.
Immutability is achieved by leveraging
strong cryptographic properties such as
hashing (Katz and Lindell 2007).

Figure 3 illustrates the three main
required by any blockchain
phases
application to create a new block. The
client transmits a transactional request
to one of the participants. This partici-
pating node multicasts the client request
to all other nodes. We term this phase
as Transaction Dissemination. Once, all
the nodes have a copy of client request,
consensus protocol.
they initiate
The choice of underlying consensus
protocol affects the time complexity and
resource consumption. The winner of
the consensus phase proposes the next
block and transmits it to all other nodes.
This transmission process is equivalent
to adding an entry (block) to the global
distributed ledger.

a

Blockchain Consensus

At the core of any blockchain applica-
tion is a BFT consensus protocol which
states that given a client transaction,
the aim of this consensus protocol is
to ensure all
the non-faulty replicas
assign the same order to this trans-
action. Depending on the underlying
topology, we can broadly categorize
consensus protocols into two categories:
permissionless consensus protocols and
permissioned consensus protocols.

is

1982)

Achieving fault-tolerant distributed
consensus
an age-old problem.
Commit protocols such as Two-Phase
(Gray 1978), Three-Phase
Commit
Commit
and Easy-
(Skeen
Commit
(Gupta and Sadoghi 2018,
2020) help in reaching agreement
in a parti-
among the participants
tioned distributed databases
(Qadah
and Sadoghi 2018; Qadah et al 2020;
Sadoghi and Blanas 2019). However,
commit protocols can only handle node
failures and are unsafe under message
delay or loss.

Paxos (Lamport 1998) and View-
stamped Replication (Oki and Liskov
1988) allow a distributed system of
replicas to achieve consensus in the
presence of crash-faults. In a system
of n replicas, a system employing
Paxos for consensus can handle up to
n failures where n ≥ 2 f + 1. Notice
that these f failures need not be simple
replica crashes but can also take form
of message losses and delays. However,
crash-fault
tolerant protocols such as
Paxos and Viewstamped Replication
cannot handle any malicious behavior.

A byzantine-fault

tolerant protocol
aims at reaching consensus in a system
of n replicas where at most
f replicas
can act as byzantine and n ≥ 3 f + 1.
Traditional BFT protocols promote
a primary-backup model where one
replica is designated as the primary and
other replicas act as backups. It is the
task of the primary to initiate consensus
among all the backups. Notice that all
the above discussed protocols, such as
Two-Phase Commit, Paxos and so on,
follow the primary-backup model. The
key reason primary-backup model
is
preferred is because of its simplicity and
its ability to blame the primary for an
unsuccessful consensus.

6

Suyash Gupta, Mohammad Sadoghi

Fig. 3: Blockchain Flow: Three main phases in any blockchain application are represented. (a)
Client sends a transaction to one of the server, which it disseminates to all the other servers. (b)
Servers run the underlying consensus protocol, to determine the block creator. (c) New block is
created, and transmitted to each node, which also implies adding to global ledger.

Recent

applications
blockchain
present several new protocols for achiev-
ing consensus: Proof-of-Work (Jakob-
sson and Juels 1999; Satoshi 2008),
Proof-of-Stake (King and Nadal 2012)
and Proof-of-Authority (Parity Tech-
nologies 2018). Prior works have shown
that these consensus protocols provide
similar guarantees as traditional BFT
protocols (Garay et al 2015). Hence,
in the rest of this section, we illustrate
some of the state-of-the-art blockchain
protocols for both permissioned and
permissionless systems.

Permissioned Consensus

A decade prior to the inception of the
ﬁrst blockchain application, the problem
of achieving fault-tolerant distributed
consensus problem had already excited
practitioners and researchers (Lamport
1998; Oki and Liskov 1988; Castro
and Liskov 1999). Distributed systems
research community agreed that
a
byzantine-fault tolerant system can only
be considered correct if it is both safe

and live. A replicated system is called
as safe if all its replicas are consistent,
that is, have the same state. A replicated
system is termed as live if its replicas are
able to make progress, that is, process
incoming client requests.

that

A majority of existing BFT protocols
guarantee safety under asynchronous
environment,
is, messages can
loss, delayed or duplicated, and
get
up to f
replicas may act byzantine.
Further, any BFT protocol employs
cryptographic
to prevent
constructs
malicious replicas from impersonating
non-faulty replicas. As clients send
their transactions to other replicas, so
each client uses digital signatures to
sign its message (Menezes et al 1996;
Katz and Lindell 2007). For all other
messages, depending on the algorithmic
the system can employ either
steps,
asymmetric-key digital
signatures or
less-expensive symmetric-key message
authentication codes (Katz and Lindell
2007). Hence, we assume authenticated
communication: malicious replicas can
impersonate each other, but no replica
can impersonate a non-faulty replica.
Further, replicas will accept only those

Blockchain Transaction Processing

7

messages which are well-formed, that is,
have valid message authentication codes
or digital signatures (as applicable).

PBFT. Practical Byzantine Fault Tol-
erance (Castro and Liskov 1999) if often
considered as the ﬁrst protocol to present
a practical design for achieving byzan-
tine fault-tolerance in a distributed sys-
tem. PBFT follows the primary-backup
model where the primary replica initi-
ates the consensus among all the repli-
cas. It is the responsibility of the primary
to ensure all the backup replicas success-
fully order every incoming client trans-
action otherwise it risks replacement. If
the primary is non-malicious and the net-
work is reliable, PBFT guarantees con-
sensus in three phases.

PBFT protocol starts when a client C
wants a transaction to be executed and
sends a request m to the primary replica
P. The primary P checks if the client
signature is valid and if this is the case,
it creates a PRE-PREPARE message and
sends that message to all the backups.
This PRE-PREPARE message includes a
sequence number (an integer) and a hash
of the client request. The sequence num-
ber k states the order to execute the trans-
action while the hash acts as a digest,
which can be used in future communica-
tions as an alias for the client request3.

When a

replica R receives

a
PRE-PREPARE message from the pri-
mary P,
it performs the following
checks: (i) veriﬁes the client signature
on m, (ii) checks if P is the primary,
and (iii) ensures the sequence number
k has not already been used. If the
PRE-PREPARE message passes all the
checks, R agrees to support primary’s
this request and sends a
order

for

3 Client requests are often of the order of several
kilobytes and sending an hash instead optimizes
the communication.

PREPARE message to all the replicas.
When a replica R receives PREPARE
messages from 2 f replicas in support
of the request m sent by P, then R
marks the request as prepared. This
information gives R an assurance that
a majority of non-faulty replicas are
also agreeing to order this request at
sequence k. Next, R acknowledges the
prepared request by sending a COMMIT
message to all
the replicas. When a
replica R receives COMMIT messages
from 2 f + 1 replicas, then R achieves a
unique guarantee on the order of m, that
is, a majority of non-faulty replicas have
also prepared m. This allows replica R
to go ahead and execute the request m
as the k-th request. Finally, R sends the
result of executing m as a response to
the client C .

The client C needs f + 1 matching
responses from distinct replicas, to mark
its request m as complete. It is possible
that the client may not receive sufﬁcient
number of matching responses. To
handle such cases, the client initiates
a timer prior to sending its request. In
speciﬁc, each client waits on a timer
for receiving f + 1 identical responses.
timeouts while waiting
the client
If
f + 1 responses, then it forwards
for
its request m to all the replicas. When
a backup replica R receives a client
request m, it forwards that request to the
primary P and starts its timer. If P
fails to send a PRE-PREPARE message
corresponding to m, then R concludes
that P is byzantine and initiates pri-
mary replacement. Existing literature
terms this primary replacement process
as view-change because each primary
represents a view of the system. The
view-change protocol only starts when
f + 1 replicas are ready to
at
replace the primary. This condition is

least

8

Suyash Gupta, Mohammad Sadoghi

necessary as up to f replicas can be
byzantine and may even request replace-
ment of a non-faulty primary. Hence,
f + 1 replicas request
when at
replacement, remaining replicas assume
that
least one non-faulty
replica which has been affected.

there is at

least

For a successful view-change to take
place, a new primary has to be selected.
PBFT follows a simple principle: if the
replica with index i is the current pri-
mary, then replica with index j will be
the next primary, where j = (i + 1) mod
n. But, how does a replica concludes
that it is time for it to act as the new
primary. When any replica R receives
VIEW-CHANGE messages from 2 f + 1
distinct replicas that want to elect it as
the primary, then it initiates the process
of switching to next view. Notice that
the process of switching to next view re-
quires ensuring all the replicas have the
common state. Thus, the new primary
also needs to provide this information as
part of the NEW-VIEW message.

Zyzzyva. It is evident from PBFT’s
design that it requires three phases of
communication of which two necessitate
quadratic communication complexity.
Hence, there is a need for optimized
protocols, which can achieve the same
goals with much lesser communication
al
overheads. ZYZZYVA (Kotla
2007) presents a twin-path protocol that
achieves consensus in a single linear
phase if there are no failures. All the
replicas in the ZYZZYVA start in the
fast-path and switch to the slow-path
under failures. Note that a recent work
has illustrated that ZYZZYVA is unsafe
under failures (Abraham et al 2017).

et

In ZYZZYVA, when a non-primary
replica R receives a PRE-PREPARE
message from the primary P,
it as-
sumes that the primary is non-faulty and

agrees to execute this request. Such an
execution is termed as speculative as
the replica R is unaware of the state at
other replicas. In speciﬁc, a byzantine
primary could have equivocated and sent
different replicas distinct client requests.
Once the replica R executes the request,
it sends the reply to client C . The client
C marks the request complete if it
receives matching identical responses
from at least 3 f + 1 replicas.

A keen reader can easily notice that
the onus is on the client to ensure system
is safe. Further, when n = 3 f + 1, then
the client has to wait for responses from
all the replicas. Due to these restrictions,
ZYZZYVA’s fast-path works only if
there are no failures.
In ZYZZYVA,
the client waits on a timer while ex-
pecting 3 f + 1 responses. If the client
timeouts prior to receiving responses,
then it initiates the slow-path. In the
slow-path, client has to summarize the
state it received from different replicas
and needs to decide whether primary
replacement needs to be initiated or a
simple recovery protocol
is sufﬁcient
to ensure system remains live. Clearly,
the slow-path is no longer linear and
requires multiple phases. Moreover, if
the client is malicious, then the replicas
could be momentarily unsafe until
there is a good client. Another key
challenge with twin-path protocols is
ﬁnding the optimal timeout value. Prior
works have shown that ﬁnding a timeout
value can be hard and ZYZZYVA faces
severe reduction is throughput under
failures (Clement et al 2009a,b; Gupta
et al 2021a).

SBFT. The key aim behind the design
of SBFT (Golan Gueta et al 2019) is
to make a consensus protocol that can
guarantee safe consensus with linear
message complexity in periods of no

Blockchain Transaction Processing

9

failures. In fact, like ZYZZYVA, SBFT is
also a twin-path protocol. SBFT employs
threshold signatures to achieve linear
communication complexity.

Threshold signatures are based on
asymmetric cryptography. In speciﬁc,
each replica holds a distinct private key,
which it can use to create a signature
share. Next, one can produce a valid
threshold signature given at least t such
signature shares from distinct replicas
(the exact value of t is dependent on the
underlying consensus protocol).

At a closer look, it seems like SBFT
requires more phases than PBFT. This
occurs because SBFT linearizes each
phase of PBFT through use of threshold
signatures. In SBFT, when a replica R
receives a PRE-PREPARE message,
it
agrees to support from the primary’s
sequence by generating a threshold
share. The replica R sends this share
to a speciﬁc replica designated as the
collector. When a collector
receives
message from at least 3 f + 2c + 1 repli-
cas it generates a threshold signatures
and sends this signature to all the repli-
cas. When a replica receives a threshold
signature from the collector, it executes
the request to generate a response, cre-
ates a threshold share on this response
and sends these to a speciﬁc replica
designated as the executor. The executor
waits for f + 1 identical responses and
combines them into threshold signature.
Next, the executor sends this signature
to all the replicas and clients.

For SBFT’s fast path to work as
stated, either there should be no failures
or at least 3 f + 2c + 1 replicas should
participate in consensus where up to
c > 0 replicas can crash-fail (no byzan-
tine failures). Moreover, the primary can
act as both collector and executor but
SBFT suggests using distinct replicas in

fast path. If the collector timeouts wait-
ing for threshold shares from 3 f + c + 1
replicas, it switches to the slow path,
which requires two additional
linear
phases to complete consensus.

if

HotStuff.
In any primary-backup
BFT protocol,
the primary acts
malicious, then the protocols employ the
accompanying view-change algorithm
to detect and replace the malicious
primary. This view-change algorithm
leads to a momentary disruption in
system throughput until the resumption
of service.

HOTSTUFF (Yin et al 2019) proposes
eliminating the dependence of a BFT
consensus protocol from one primary by
replacing primary at the end of every
consensus. Although this rotating leader
design escapes the cost of a view-change
protocol, it enforces an implicit sequen-
tial paradigm. Each primary needs to
wait for its turn before it can propose a
new request.

In HOTSTUFF, in round i, the replica
with identiﬁer i mod n acts as the pri-
mary and proposes a request to all the
replicas. Each replica on receiving this
request, creates a threshold share and
sends to the replica R with identiﬁer
(i + 1) mod n. If R receives threshold
shares from 2 f + 1 replicas, then it com-
bines them into a threshold signature and
initiates the consensus for round i + 1
by broadcasting its proposal along with
the computed threshold signature. No-
tice that replicas have not executed the
request and replied to the client. HOT-
STUFF’s aim is to linearize the consen-
sus proposed by PBFT protocol, which
it does by splitting each phase of PBFT
into two using threshold signatures. To
reduce the communication, it chains the
phases. Hence, a replica executes the re-
quest for the i-th round once it receives

10

Suyash Gupta, Mohammad Sadoghi

a threshold signature from the primary
of (i + 3)-th round. Evidently, chaining
helps HOTSTUFF to some extent but it
does not eliminate its sequential nature.
This sequential nature forces HOTSTUFF
to loose out on an opportunity to process
messages out-of-order.

PoE. Proof-of-Execution (henceforth
referred to as POE) consensus protocol
aims at achieving consensus in three
linear phases without relying on any
twin-path model (Gupta et al 2021a).
Further, POE recognizes that no one
size ﬁts all systems (Singh et al 2008).
Hence,
its design is independent of
the choice of underlying cryptographic
signature scheme. This implies that the
POE protocol can employ both sym-
metric and asymmetric-cryptographic
signature schemes depending on the
application environment.

The design of POE is built on three
key insights. First, POE prevents use of
any twin-path paradigm as switching
from fast to slow-path requires depen-
dence on timeouts, which degrades
system performance. Second, POE
allows replicas to speculatively execute
the requests but
facilitates rollbacks
in case of inconsistencies. Final, POE
allows out-of-order processing, which
eliminates any bottlenecks associated
with sequential consensus protocols.

For the sake of brevity, we will de-
scribe POE built on top of threshold sig-
natures. In POE, the client C initiates
execution by sending its request m to the
primary P. To initiate replication and
execution of m as the k-th transaction,
the primary proposes m to all replicas by
broadcasting a PROPOSE message.

After a replica R receives a PROPOSE
message from P, it checks whether at
least 2 f other replicas also received the
same proposal from P. To perform this

check, each replica agrees to support the
ﬁrst k-th proposal it receives from the
primary by sending a SUPPORT message
that includes its unique threshold share
to the primary. The primary P waits for
2 f + 1 threshold shares, and on receiv-
ing such shares, it combines them into
a threshold signature and broadcasts as
a CERTIFY message. When a replica
R receives the CERTIFY message,
it
view-commits to m as the k-th transaction
in view v. After R view-commits to m,
R schedules speculative execution of
m. Consequently, m will be executed by
R after all preceding transactions are
executed. After execution, R informs
the client of the order of execution
and of any execution result. A client
considers its transaction successfully
identical
executed after
response messages from 2 f + 1 distinct
replicas.

receives

it

Aardvark. The design philosophy
behind Aardvark is distinct in compari-
son to existing BFT protocols (Clement
et al 2009b). It aims at building a
robust BFT protocol that can continue
in
performing under failures. Hence,
the failure-free cases, Aardvark attains
lower throughput than a majority of the
existing BFT protocols.
In Aardvark, prior

to sending its
request to the primary, the client signs
the request using both digital signatures
and message
codes.
This prevents malicious clients from
performing a denial-of-service attack
as it is expensive for client to sign each
message twice. Aardvark also employs
a point-to-point network rather
than
the multicast network for exchange of
messages among clients and replicas.
The key intuition behind such a choice
is to disallow a faulty client or replica
from blocking the complete network.

authentication

Blockchain Transaction Processing

11

Aardvark also periodically changes the
primary replica. Each replica tracks the
throughput of the current primary and
suggests replacing the primary when
there is a decrease in its throughput.
To perform such tracking, each replica
sets a timer and measures the rate of
primary’s responses.

RBFT. The key intuition behind the
design of RBFT is to facilitate detection
of clever malicious primaries (Aublin
et al 2013). RBFT extends Aardvark and
aims to detect those malicious primaries,
which cannot be detected by simple
timers suggested by Aardvark.

In Aardvark, a clever primary can
avoid detection by delaying messages
just slightly below the timeout threshold.
Such a primary can throttle the system
risking eviction.
throughput without
To tackle this challenge, RBFT insists
running f + 1 independent instances of
the Aardvark protocol on each replica.
One of these instances is designated as
the master while other instances act as
backups. Irrespective of the designation
of an instance, all the instances order all
the requests. However, only the master
instance executes the requests.

The key task of the backup instances
is to monitor the performance of the
master instance. If any backup instance
observes a degradation of the system
throughput at the master, it broadcasts a
message to elect a new primary. Further,
to guarantee at least one of the f + 1
instances is led by a non-faulty replica,
RBFT requires each instance to be led
by a distinct replica. In comparison to
both PBFT and Aardvark, RBFT requires
an additional phase, which is used to
propagate the client requests across all
the replicas.

RCC. Although RBFT successfully
utilizes redundancy to detect clever

it also wastes
malicious primaries,
requiring
excessive
by
bandwidth
the same
the instances to order
all
set of requests. Resilient Concurrent
Consensus (henceforth referred to as
RCC) paradigm resolves this issue by
parallelizing the consensus (Gupta et al
2019b, 2021b). In speciﬁc, RCC runs
at each replica multiple instances of a
primary-backup protocol.

The key challenge with the design
of primary-backup protocols is their re-
liance on the primary. This dependence
can severely affect the throughput and
scalability of these protocols. The pri-
mary replica not only receives all client
requests but is also responsible for en-
suring consensus is reached on the order
for these requests among all other repli-
cas. If the primary fails to ensure consen-
sus, then all remaining replicas need to
replace this primary. This replacement
process is necessary as, without it, non-
faulty replicas may never converge. Un-
fortunately, primary replacement is not
cheap, as it requires pausing consensus
on all outstanding requests until the pri-
mary is replaced.

RCC aims at making a BFT consen-
sus primary agnostic. To achieve such a
property, RCC advocates running z par-
allel instances at each replica. Further,
RCC ensures that each instance is man-
aged by a distinct replica. Using par-
allelization, RCC ensures that the non-
faulty replicas are always accepting and
ordering client requests, this indepen-
dent of any malicious behavior or attack.
We now present the design of RCC
paradigm that parallelizes the seminal
PBFT consensus protocol. For the sake
of explanation, we assume RCC works
in rounds. Each round of RCC includes
three stages: parallel consensus, uniﬁ-
cation, and execution. The notion of a

12

Suyash Gupta, Mohammad Sadoghi

round helps in generating a common or-
der and recovering from instance failures
but it does not prevent individual pri-
maries from working independently.

Prior to any round, RCC requires
each replica to prepare to run z instances
of PBFT protocol in parallel. A round
r begins when the primary of each in-
stance proposes a client request. Firstly,
in the parallel consensus stage, each
instance runs PBFT on its client request.
Secondly, in the uniﬁcation stage, the
replica waits for all its z instances to
complete replication (reach consensus
on their respective requests). If every in-
stance successfully replicates a request,
then a common order for execution of
these requests is determined. If one or
more instances are unable to replicate
requests, then the primaries for those
instances must be faulty and recovery
in the execution
is initiated. Finally,
stage, each replica executes all the client
requests in the common order.

GeoBFT. Existing BFT protocols do
not distinguish between the local and
global communication, which is a nec-
essary requirement to enable geo-scale
deployment of a blockchain system. To
resolve this challenge, Geo-Scale Byzan-
tine Fault-Tolerant consensus protocol
(henceforth referred to as GEOBFT) that
uses topological information to group all
replicas in a single region into a single
cluster (Gupta et al 2020b). Likewise,
GEOBFT assigns each client to a single
cluster. This clustering helps in attaining
high throughput and scalability in geo-
scale deployments. GEOBFT operates in
rounds, and in each round, every clus-
ter will be able to propose a single client
request for execution. Each round con-
sists of the three steps: local replication,
global sharing, and ordering and execu-
tion, which we further detail next.

At

transaction

the start of each round, each
cluster chooses a single transaction of a
local client. Next, each cluster locally
replicates its chosen transaction in a
Byzantine fault-tolerant manner using
PBFT. At the end of successful local
replication, PBFT guarantees that each
non-faulty replica can prove successful
local replication via a commit certiﬁcate.
Next, each cluster shares the locally-
replicated
along with
its commit certiﬁcate with all other
clusters. To minimize
inter-cluster
communication, we use a novel op-
timistic global sharing protocol. Our
optimistic global sharing protocol has a
global phase in which clusters exchange
locally-replicated transactions, followed
by a local phase in which clusters
any received transactions
distribute
locally among all local replicas. Finally,
after receiving all transactions that are
locally-replicated in other clusters, each
replica in each cluster can determin-
istically order all
these transactions
and proceed with their execution. After
execution, the replicas in each cluster
inform only local clients of the outcome
of the execution of their transactions
(e.g., conﬁrm execution or return any
execution results).

Permissionless Consensus

Permissionless applications inspired by
Nakamoto’s Bitcoin (Satoshi 2008) ad-
vocate a public blockchain system where
any replica can participate in the consen-
sus. Hence, the identity of a participat-
ing replica can be protected. This design
property requires the underlying consen-
sus protocol used to order the transac-
tions to expend the resources of a partic-

Blockchain Transaction Processing

13

ipant. In speciﬁc, each participant needs
to spend some of its resources if it wants
to propose the next block. If such a re-
source consumption is not enforced, then
a malicious participant can create multi-
ple pseudonymous identities and subvert
the system, also known as the Sybil at-
tack (Douceur 2002).

Proof-of-Work. Bitcoin relies on the
Proof-of-Work (henceforth referred to
as POW) protocol to achieve consensus
among a set of replica. POW protocol
builds on top of a simple intuition “What
is mathematically hard to compute but
easy to verify?” Hence, POW protocol
requires the computation to be expen-
sive,
it should deplete some
is,
resources of the prover.

that

In nature,

In POW protocol, the participating
nodes compete among themselves to
propose the next block by solving a
complex puzzle.
several
computationally hard problems exist,
such as Diophantine Equation, RSA
Factorization, One-way Hash Functions,
and so on. Among these hard problems,
following the Nakamoto’s vision, POW
protocol is associated with the computa-
tion of one-way hash functions such as
computation of a 256-bit SHA3 value.
When a node N successfully computes
this hash value, it disseminates this so-
lution to all other nodes for veriﬁcation.
Any node can verify this solution to
check N’s claim.

The main critic behind POW’s design
is that leads to excessive wastage of
energy. Permissionless applications that
employ POW consensus have to set
large targets to prevent Sybil attacks.
Further, POW’s design facilitates unfair
practices—higher
computational
capabilities a node has higher are its
chances of solving the complex puzzle.
Such a design promotes pooling of

the

resources where several nodes work
together to compute the hash. Moreover,
a node has to be given incentives to
participate in the POW consensus. If the
incentives are not sufﬁcient, then nodes
may decline creating the next block,
which in turn can either stall the system
or compromise its security.

Another issue with the POW consen-
sus protocol is that it can lead to tricky
situations where it is hard to determine
the next block in the chain. For instance,
two nodes N1 and N2 may solve the com-
plex puzzle at the same time. In such a
case, it is possible that one half of the
remaining participants may receive a so-
lution from N1 before N2 while the other
half receives solution from N2 before N1.
To handle this scenario, some form of
resolution mechanism is needed, which
would lead to wastage of resources of
either N1 or N2 as both of their blocks
cannot be appended to the chain. Notice
that any new block added to the chain in-
cludes the hash of the previous block.

Proof-of-Stake. In POW protocol,
miners have to deplete their computa-
tional resources in order to earn the right
to create the next block. Each miner
who controls a fraction s of the total
computational power, has a probability
nearly equal to s to create the next block.
Proof-of-Stake (henceforth referred
to as POS) presents a principle that
contrasts the resource usage philoso-
phy of POW. In a blockchain system
employing POS protocol, a replica
possessing a higher stake than the other
replicas gets a chance to create a new
block (Bentov et al 2016). In speciﬁc,
the probability a replica possessing
a fraction s of the total stakes in the
system creates the next block is s. The
key security rationale behind POS is that
replicas who have some stake involved

14

Suyash Gupta, Mohammad Sadoghi

in the system are also well-suited to
ensure its security.

PPCoin or PeerCoin (King and
Nadal 2012) is often regarded as the
ﬁrst implementation of POS. The key
motivation behind PPCoin’s design was
to implement a crypto-currency that
does not require participating replicas to
spend its resources in performing large
computations. Initial POS-based design
were based on the notion of coinage. In
speciﬁc, a replica’s ability to create the
next block is determined on its value
of coinage. Coinage is calculated on
the basis of number of days a replica
has held some coins or stake. To pre-
vent Sybil attacks, POS-based systems
require replicas to algorithm requires a
node to spend its coinage if it wants to
propose the next block.

Initial implementations of the POS
protocol
lacked the fairness criterion.
This is evident as the replica with the
highest stake gets the chance to propose
the next block. Although a high stake
replica looses its coinage once it creates
the next block, it may create the subse-
quent block if its stake is much larger in
value than that of the other replicas.

To resolve this issue, a chain-based
variant of POS algorithm has been pro-
posed. The chain-based POS protocol
employs a psuedo-random algorithm to
select a validator, which then creates a
new block and adds it to the existing
chain of blocks. The frequency of
selecting the validator is set to some
pre-deﬁned time interval. Another vari-
ant of POS algorithm follows BFT-style
consensus. In this design, the replicas
participate in a BFT protocol to select
the next valid block. Here, validators are
given right to propose the next block,
at random. The key difference between
these algorithms is the synchrony re-

inherently

quirement; chain-based POS algorithms
are
synchronous, while
BFT-style POS is partially synchronous.
Another key challenge for POS-based
designs is an attack by rational stake-
holders. A rational replica would always
aim at maximizing its proﬁt, an expected
behavior in a democracy in correspon-
dence with the Nash equilibrium Bentov
et al (2016). Rational replicas can affect
the security of POS, as in at attempt to
maximize their gains, they may partici-
pate in multiple chains.

A rational miner could get blocks
from distinct forks of the blockchain.
To maximize its returns, a miner would
attempt to propose the next block for
each such fork. As miners don’t lose
any actual resources (like computational
energy in POW), so they are free to
propose blocks on different chains.
This could lead to an ever-expanding
divergent network.

is

Proof-of-Authority. A variation of
POS algorithm to be employed in hybrid
blockchain topologies
termed as
Proof-of-Authority (henceforth referred
as POA) (Parity Technologies 2018).
The key idea is to designate a set of
nodes as the authorities or leaders. These
authorities are entrusted with the task
of creating new blocks and validating
the transactions. POA marks a block as
part of the blockchain if it is signed by
majority of the authorized nodes. The
incentive model in POA highlights that
it is in the interest of an authority node
to maintain its reputation. In case an
authority acts malicious, it can loose its
status and periodic incentives. Hence,
POA does not select nodes based on
their claimed stakes.

Proof-of-Space. A consensus al-
gorithm orthogonal
design
proposed by POW is proof-of-space

the

to

Blockchain Transaction Processing

15

or proof-of-capacity (henceforth re-
ferred as POC) (Ateniese et al 2014;
Dziembowski et al 2015).

POC expects nodes to provide a proof
that
they have sufﬁcient “storage” to
solve a computational problem. POC al-
gorithm targets computational problems
such as hard-to-pebble graphs (Dziem-
bowski et al 2015)
that need large
amount of memory storage to solve
the problem. In the POC algorithm,
the veriﬁer ﬁrst expects a prover to
commit to a labeling of the graph, and
then it queries the prover for random
locations in the committed graph. The
key intuition behind this approach is
that unless the prover has sufﬁcient
storage, it would not pass the veriﬁca-
tion. SpaceMint (Park et al 2015)—a
cryptocurrency—claims
POC-based
that POC based approaches are more
resource efﬁcient in comparison to POW
as storage consumes less energy.

Blockchain Systems

We now brieﬂy look at the design of
some of the state-of-the-art blockchain
applications and fabrics. The key aim
of this section is to illustrate the differ-
ent design practices adopted by existing
blockchain systems.

Bitcoin (Satoshi 2008) is regarded
as the ﬁrst ever blockchain application.
It is a cryptographically secure digital
currency designed with the aim of dis-
rupting the traditional institutionalized
monetary exchange. Bitcoin acts as the
token of transfer between two parties
undergoing a monetary transaction. The
underlying blockchain system is a net-
work of nodes (also known as miners)
transactions
that

take a set of client

and validate the same by demonstrating
a proof-of-work,
is generating a
that
block. The process of generating the
next block is non-trivial and requires
large computational resources. Hence,
the miners are given incentives (such as
Bitcoins) for dedicating their resources
and generating the block. Each miner
maintains locally an updated copy of the
complete blockchain and the associated
ledgers for every Bitcoin user.

To ensure Bitcoin system remains
fair towards all the machines, the dif-
ﬁculty of proof-of-work challenge is
periodically increased. Prior works have
illustrated that Bitcoin is vulnerable to
51% attack, which can lead to double
spending (Rosenfeld 2014). The in-
tensity of such attacks increases when
multiple forks of the longest chain are
created. To avoid these attacks, Bitcoin
developers suggest the clients to wait
for their block to be conﬁrmed before
they mark the Bitcoins as transferred.
This wait ensures that the speciﬁc block
is a little deep (nearly six blocks) in the
longest chain (Rosenfeld 2014). Bitcoin
critics also argue that its proof-of-work
consumes huge energy 4 and may not be
a viable solution for future.
Ethereum (Wood

is
blockchain framework that permits
to create their own applica-
users
tions (smart-contracts) on top of the
Ethereum Virtual Machine
(EVM).
Ethereum utilizes the notion of smart
development
facilitate
contracts
of new operations. It also supports a
digital cryptocurrency, ether, which is
used to incentivize the developers to
create correct applications. One of the
key advantage of Ethereum is that it

2015)

to

4 As per some claims one Bitcoin transaction
consumes power equivalent to that required by
1.5 American homes per day.

16

Suyash Gupta, Mohammad Sadoghi

supports a Turing complete language
to generate new applications on top
of EVM. At the time of writing this
article, Ethereum employs a variant of
POW protocol
to achieve consensus
among its miners. Ethereum makes
its miners solve challenges that were
intensive, but
not only computational
also memory intensive. This design
prevented existence of miners who
utilized specially designed hardware for
compute intensive applications.

In future, Ethereum Foundation aims
to switch to a variant of POS protocol
to reach consensus among its replicas.
is referred to
The modiﬁed protocol
as Casper (Buterin and Grifﬁth 2017).
Casper introduces the notion of ﬁnal-
ity, that is, it ensures that one chain
It also
becomes permanent
introduces the notion of accountability,
which penalizes any validator that at-
tempts the nothing-at-stake attack. The
penalty leveraged on such a validator is
equivalent to negating all his stakes.

in time.

Parity (Parity Technologies 2018)
is an application designed on top of
Ethereum. It provides an interface for
its users to interact with the Ethereum
blockchain. Parity allows its blockchain
community to use either Proof-of-Work
and Proof-of-Authority to reach consen-
sus in their applications. Hence, if some
users select POA consensus, then Parity
provides mechanisms for setting up the
authority nodes.

Ripple (Schwartz et al 2014) is con-
sidered as third largest cryptocurrency
after Bitcoin and Ethereum in terms
of market cap. It employs a consensus
algorithm which is a simple variant of
existing traditional BFT algorithms.
Ripple requires number of failures f to
be bounded as follows: ≤ (n − 1)/5 + 1,
where n represents the total number of

nodes. Ripple’s consensus algorithm
introduces the notion of a Uniﬁed Node
List (UNL), which is a subset of the
network. Each server communicates
with the nodes in its UNL for reaching a
consensus. The servers exchange the set
of transactions they received from the
clients and propose those transactions
to their respective UNL for vote. If a
transaction receives 80% of the votes,
it is marked permanent. Notice that if
the generated UNL groups are a clique
then forks of the longest chain could
co-exist. Hence, UNLs are created in
a manner that they share some set of
nodes. Another noteworthy observation
about Ripple protocol is that each client
needs to select a set of validators or
unique nodes that
they trust. These
validators utilize the ripple consensus
algorithm to verify the transactions.
Hyperledger (Cachin 2016)

is a
suite of resources aimed at modeling
industry standard blockchain applica-
tions. It provides a series of Application
Programming Interfaces (APIs) for de-
velopers to create their own non-public
blockchain applications. Hyperledger
provides implementations of blockchain
systems that uses RBFT and other vari-
ants of the PBFT consensus algorithm.
It also facilitates use and development
of smart contracts. It is important to
understand that the design philosophy of
Hyperledger leans towards blockchain
applications that require existence of
non-public networks, and so, they do
not need a compute intensive consensus.
ResilientDB (Gupta et al 2020c;
Rahnama et al 2020) is a state-of-the-art
permissioned blockchain fabric, which
is designed with the aim of
foster-
ing academic and industry research.
RESILIENTDB also acts as a reliable
test-bed to implement and evaluate

Blockchain Transaction Processing

17

Fig. 4: Architecture of RESILIENTDB.

blockchain

enterprise-grade
applica-
tions5. RESILIENTDB evolved from
the ExpoDB platform (Sadoghi 2017;
Gupta and Sadoghi 2018) which is
an experimental research platform to
design and test emerging database tech-
nologies, agreement and concurrency
control protocols.

In Figure 4, we illustrate the overall
architecture of RESILIENTDB, which
lays down an efﬁcient client-server
architecture. At the application layer,
we allow multiple clients to co-exist,
each of which creates its own requests.
For this purpose, they can either em-
ploy an existing benchmark suite or
design a Smart Contract suiting to
the active application. Next, clients
and replicas use the transport
layer
to exchange messages across the net-
work. RESILIENTDB also provides a
storage layer where all
the metadata
corresponding to a request and the
blockchain is stored. At each replica,
there is an execution layer where the
underlying consensus protocol
is run
on the client request, and the request is
ordered and executed. During ordering,

5

RESILIENTDB

at
is
https://resilientdb.com and code is available at
https://github.com/resilientdb.

open-sourced

Fig. 5: Two permissioned applications
employing distinct BFT protocols (80K
clients per experiment).

the secure layer provides support for
cryptographic constructs.

RESILIENTDB is written entirely in
C++ and provides a graphical user inter-
face to ease user interaction with the sys-
tem. Further, it also provide a Docker-
ized deployment that allows any user to
experience and test the RESILIENTDB
fabric (comprising of multiple replicas
and clients) on its local machine.

The key motivation behind RE-
SILIENTDB’s design was to show that a
system-centric permissioned blockchain
fabric can outperform a protocol-centric
blockchain fabric even if the former
is made to employ a slow consensus

HASHINGTOOLKITSIGNINGTOOLKITSECURE LAYERSTORAGE LAYERBLOCKCHAINMETADATATHREADSBFT CONSENSUSEXECUTION LAYERNETWORKQUEUES481632Number of Replicas406080100120140160Throughput (KTxns/s)ResilientDBZyzzyva18

Suyash Gupta, Mohammad Sadoghi

protocol. To prove this claim, we refer to
Figure 5, which compares the through-
put achieved by two permissioned
fabrics. In this ﬁgure, RESILIENTDB
employs the slow PBFT protocol while
the other fabric adopts the practices sug-
gested in the paper BFTSmart (Bessani
et al 2014) and employs the single-phase
linear ZYZZYVA protocol. Despite this
disadvantageous choice of consensus
protocol, RESILIENTDB achieves a
throughput of 175K transactions per
second, scales up to 32 replicas, and
attains up to 79% more throughput.

Future Directions for Research

Although blockchain technology is just
a decade old, it gained majority of its
momentum in the last ﬁve years. This
allows us to render different elements
of the blockchain systems and achieve
higher performance and throughput.
Some of
the plausible directions to
develop efﬁcient blockchain systems
reducing the communication
are:
messages, (ii) deﬁning efﬁcient block
structure, (iii) improving the consensus
algorithm, and (iv) designing secure
light-weight cryptographic functions

(i)

Statistical

and machine

learning
approaches have presented interesting
solutions to automate key processes
such as Face Recognition (Zhao et al
2003), Image classiﬁcation (Krizhevsky
et al 2012), Speech Recognition (Graves
et al 2013) and so on. The tools can be
leveraged to facilitate easy and efﬁcient
consensus. The intuition behind this
approach is to allow learning algorithms
to select nodes, which are ﬁt to act as
a block creator and prune the rest from
the list of possible creators. The key

observation behind such a design is that
the nodes selected by the algorithm are
predicted to be non-malicious. Machine
learning techniques can play an impor-
tant role in eliminating the human bias
and inexperience. To learn which nodes
can act as block creators, a feature set,
representative of the nodes, needs to be
deﬁned. Some interesting features can
be: geographical distance, cost of com-
munication,
computational
available
resources, available memory storage
and so on. These features would help in
generating the dataset that would help
to train and test the underlying machine
learning model. This model would be
ran against new nodes that wish to join
the associated blockchain application.

temporal

The programming languages and
software engineering communities have
developed several works that provide
semantic guarantees to a language or an
application (Wilcox et al 2015; Leroy
2009; Kumar et al 2014). These works
have tried to formally verify (Keller
1976; Leroy 2009) the system using the
principles of programming languages
and techniques such as ﬁnite state
automata,
logic and model
checking (Grumberg and Long 1994;
Baier and Katoen 2008). We believe
similar analysis can be performed in the
context of blockchain applications. The-
orem provers (such as Z3 (De Moura
and Bjørner 2008)) and proof assis-
tants (such as COQ (Bertot 2006))
could prove useful to deﬁne a certiﬁed
blockchain
application. A certiﬁed
blockchain application can help in stat-
ing theoretical bounds on the resources
required to generate a block. Similarly,
some of the blockchain consensus has
been shown to suffer from Denial of Ser-
vice attacks (Bonneau et al 2015), and a
formally veriﬁed blockchain application

Blockchain Transaction Processing

19

can help realize such guarantees, if the
underlying application provides such a
claim.

References

Abraham I, Gueta G, Malkhi D, Alvisi L, Kotla
R, Martin J (2017) Revisiting fast practical
byzantine fault tolerance. URL https://
arxiv.org/abs/1712.01367

Androulaki E, Barger A, Bortnikov V, Cachin
C, Christidis K, Caro AD, Enyeart D, Ferris
C, Laventman G, Manevich Y, Muralidha-
ran S, Murthy C, Nguyen B, Sethi M, Singh
G, Smith K, Sorniotti A, Stathakopoulou
C, Vukolic M, Cocco SW, Yellick J (2018)
Hyperledger fabric: A distributed operating
system for permissioned blockchains. CoRR
abs/1801.10228, URL http://arxiv.
org/abs/1801.10228

Ateniese G, Bonacina I, Faonio A, Galesi N
(2014) Proofs of space: When space is of the
essence. In: Abdalla M, De Prisco R (eds)
Security and Cryptography for Networks,
Springer International Publishing, pp 538–
557

Aublin PL, Mokhtar SB, Qu´ema V (2013)
RBFT: Redundant Byzantine Fault Toler-
ance. In: Proceedings of the 2013 IEEE 33rd
International Conference on Distributed
Computing Systems, IEEE Computer Soci-
ety, ICDCS ’13, pp 297–306

Baier C, Katoen JP (2008) Principles of Model
Checking (Representation and Mind Series).
The MIT Press

Bentov I, Gabizon A, Mizrahi A (2016) Cryp-
tocurrencies without proof of work. In:
Clark J, Meiklejohn S, Ryan PY, Wallach D,
Brenner M, Rohloff K (eds) Financial Cryp-
tography and Data Security, Springer Berlin
Heidelberg, Berlin, Heidelberg, pp 142–157
Bertot Y (2006) Coq in a Hurry. CoRR
abs/cs/0603118, URL http://arxiv.
org/abs/cs/0603118, cs/0603118
Bessani A, Sousa J, Alchieri EEP (2014) State
machine replication for the masses with bft-
smart. In: DSN

Bonneau J, Miller A, Clark J, Narayanan A,
Kroll JA, Felten EW (2015) SoK: Research
Perspectives and Challenges for Bitcoin and

Cryptocurrencies. In: Proceedings of the
2015 IEEE Symposium on Security and Pri-
vacy, IEEE Computer Society, Washington,
DC, USA, SP ’15, pp 104–121

Buterin V, Grifﬁth V (2017) Casper the Friendly
Finality Gadget. CoRR abs/1710.09437,
http://arxiv.org/abs/
URL
1710.09437, 1710.09437

Cachin C (2016) Architecture of the Hyper-
ledger blockchain fabric. In: Workshop on
Distributed Cryptocurrencies and Consen-
sus Ledgers, DCCL 2016

Cachin C, Vukolic M (2017) Blockchain
Consensus Protocols in the Wild. CoRR
abs/1707.01873

Castro M, Liskov B (1999) Practical byzantine
fault tolerance. In: Proceedings of the Third
Symposium on Operating Systems Design
and Implementation, USENIX Association,
Berkeley, CA, USA, OSDI ’99, pp 173–186
Clement A, Kapritsos M, Lee S, Wang Y, Alvisi
L, Dahlin M, Riche T (2009a) Upright clus-
ter services. In: Proceedings of the ACM
SIGOPS 22nd Symposium on Operating
Systems Principles, ACM, SOSP, pp 277–
290, DOI 10.1145/1629575.1629602

Clement A, Wong E, Alvisi L, Dahlin M,
Marchetti M (2009b) Making byzantine
tolerant systems tolerate byzantine
fault
faults. In: Proceedings of the 6th USENIX
Symposium on Networked Systems Design
and Implementation, USENIX Association,
NSDI, pp 153–168

De Moura L, Bjørner N (2008) Z3: An Efﬁ-
cient SMT Solver, Springer Berlin Heidel-
berg, Berlin, Heidelberg, pp 337–340

Decker C, Wattenhofer R (2013) Information
Propagation in the Bitcoin Network. In: 13th
IEEE International Conference on Peer-to-
Peer Computing (P2P), Trento, Italy

Douceur JJ (2002) The sybil attack. In: Pro-
ceedings of 1st International Workshop on
Peer-to-Peer Systems (IPTPS)

Dziembowski S, Faust S, Kolmogorov V,
Pietrzak K (2015) Proofs of space. In: Ad-
vances in Cryptology – CRYPTO 2015,
Springer Berlin Heidelberg, pp 585–605
Garay J, Kiayias A, Leonardos N (2015) The
Bitcoin Backbone Protocol: Analysis and
Applications, Springer Berlin Heidelberg,
Berlin, Heidelberg, pp 281–310

Golan Gueta G, Abraham I, Grossman S,
Malkhi D, Pinkas B, Reiter M, Seredin-
schi D, Tamir O, Tomescu A (2019) Sbft:

20

Suyash Gupta, Mohammad Sadoghi

A scalable and decentralized trust infras-
tructure. In: 49th Annual IEEE/IFIP Interna-
tional Conference on Dependable Systems
and Networks (DSN), pp 568–580

Speech
Recurrent

Graves A, Mohamed A, Hinton GE
with
Networks.
http:

(2013)
Deep
CoRR abs/1303.5778, URL
//arxiv.org/abs/1303.5778,
1303.5778

Recognition
Neural

Gray J (1978) Notes on Data Base Operating
Systems. In: Operating Systems, An Ad-
vanced Course, Springer-Verlag, pp 393–
481

Grumberg O, Long DE (1994) Model Checking
and Modular Veriﬁcation. ACM Trans Pro-
gram Lang Syst 16(3):843–871

Gupta S, Sadoghi M (2018) EasyCommit: A
Non-blocking Two-phase Commit Protocol.
In: Proceedings of the 21st International
Conference on Extending Database Tech-
nology, Open Proceedings, EDBT

Gupta S, Sadoghi M (2020) Efﬁcient and non-
blocking agreement protocols. Distributed
Parallel Databases 38(2):287–333, DOI 10.
1007/s10619-019-07267-w

Gupta S, Hellings J, Rahnama S, Sadoghi M
(2019a) An in-depth look of BFT consen-
sus in blockchain: Challenges and oppor-
tunities. In: Proceedings of the 20th In-
ternational Middleware Conference Tutori-
als, ACM, pp 6–10, DOI 10.1145/3366625.
3369437

Gupta S, Hellings J, Sadoghi M (2019b)
Brief announcement: Revisiting consensus
protocols through wait-free parallelization.
In: 33rd International Symposium on Dis-
tributed Computing (DISC 2019), vol 146,
pp 44:1–44:3, DOI 10.4230/LIPIcs.DISC.
2019.44

Gupta S, Hellings J, Rahnama S, Sadoghi M
(2020a) Building high throughput permis-
sioned blockchain fabrics: Challenges and
opportunities. Proc VLDB Endow 13(12)
Gupta S, Rahnama S, Hellings J, Sadoghi M
(2020b) Resilientdb: Global scale resilient
blockchain fabric. PVLDB 13(6):868–883
Gupta S, Rahnama S, Sadoghi M (2020c)
Permissioned blockchain through the look-
ing glass: Architectural and implementation
lessons learned. To appear in the Proceed-
ings of 40th International Conference on
Distributed Computing Systems (ICDCS)

Gupta S, Hellings J, Rahnama S, Sadoghi M
(2021a) Proof-of-Execution: Reaching con-
sensus through fault-tolerant speculation.
In: Proceedings of the 24th International
Conference on Extending Database Tech-
nology

Gupta S, Hellings J, Sadoghi M (2021b) RCC:
Resilient Concurrent Consensus for High-
Throughput Secure Transaction Processing.
In: 37th IEEE International Conference on
Data Engineering (ICDE), URL http:
//arxiv.org/abs/1911.00837,
1911.00837

Jakobsson M, Juels A (1999) Proofs of Work
and Bread Pudding Protocols. In: Proceed-
ings of the IFIP TC6/TC11 Joint Work-
ing Conference on Secure Information Net-
works: Communications and Multimedia
Security, Kluwer, B.V., CMS ’99, pp 258–
272

Katz J, Lindell Y (2007) Introduction to Mod-
ern Cryptography. Chapman & Hall/CRC
Keller RM (1976) Formal veriﬁcation of par-
allel programs. Commun ACM 19(7):371–
384

King S, Nadal S (2012) PPCoin: Peer-to-Peer

Crypto-Currency with Proof-of-Stake

Kotla R, Alvisi L, Dahlin M, Clement A, Wong
E (2007) Zyzzyva: Speculative Byzantine
Fault Tolerance. In: Proceedings of Twenty-
ﬁrst ACM SIGOPS Symposium on Operat-
ing Systems Principles, ACM, New York,
NY, USA, SOSP ’07, pp 45–58, DOI 10.
1145/1294261.1294267

Krizhevsky A, Sutskever I, Hinton GE (2012)
Imagenet classiﬁcation with deep convolu-
tional neural networks. In: Proceedings of
the 25th International Conference on Neural
Information Processing Systems - Volume 1,
Curran Associates Inc., NIPS’12, pp 1097–
1105

Kumar R, Myreen MO, Norrish M, Owens S
(2014) CakeML: A Veriﬁed Implementation
of ML. In: Proceedings of the 41st ACM
SIGPLAN-SIGACT Symposium on Prin-
ciples of Programming Languages, ACM,
New York, NY, USA, POPL ’14, pp 179–
191

Lamport L (1998) The Part-time Parliament.
ACM Trans Comput Syst 16(2):133–169
Leroy X (2009) A Formally Veriﬁed Compiler
Back-end. J Autom Reason 43(4):363–446
Libra (2019) An introduction to libra. Libra As-

sociation Members

Blockchain Transaction Processing

21

Sadoghi M, Blanas S (2019) Transaction
Processing on Modern Hardware. Syn-
thesis Lectures on Data Management,
10.2200/
Morgan & Claypool, DOI
S00896ED1V01Y201901DTM058

Satoshi N (2008) Bitcoin: A peer-to-peer
electronic cash system. URL http://
bitcoin.org/bitcoin.pdf

Schwartz D, Youngs N, Britto A (2014) The
Ripple Protocol Consensus Algorithm. URL
https://www.ripple.com/

Singh A, Das T, Maniatis P, Druschel P, Roscoe
T (2008) BFT Protocols under Fire. In:
NSDI

Skeen D (1982) A Quorum-Based Commit Pro-

tocol. Tech. rep.

Steen Mv, Tanenbaum AS (2017) Distributed

Systems

TPP Council (2010) TPC Benchmark C (Revi-

sion 5.11)

Wilcox JR, Woos D, Panchekha P, Tatlock Z,
Wang X, Ernst MD, Anderson T (2015)
Verdi: A Framework for Implementing and
Formally Verifying Distributed Systems. In:
Proceedings of the 36th ACM SIGPLAN
Conference on Programming Language De-
sign and Implementation, ACM, New York,
NY, USA, PLDI ’15, pp 357–368

Wood G (2015) Ethereum: A secure decen-
tralised generalised transaction ledger. URL
http://gavwood.com/paper.pdf
Yin M, Malkhi D, Reiter MK, Gueta GG,
Abraham I (2019) HotStuff: BFT consensus
with linearity and responsiveness. In: Pro-
ceedings of the 2019 ACM Symposium on
Principles of Distributed Computing, ACM,
PODC, pp 347–356, DOI 10.1145/3293611.
3331591

Zhao W, Chellappa R, Phillips PJ, Rosenfeld
A (2003) Face Recognition: A Literature
Survey. ACM Comput Surv 35(4):399–458,
DOI 10.1145/954339.954342

Menezes AJ, Vanstone SA, Oorschot PCV
(1996) Handbook of Applied Cryptography,
1st edn. CRC Press, Inc.

Nawab F (2018) Geo-Scale Transaction Pro-
cessing, Springer International Publishing,
pp 1–7. DOI 10.1007/978-3-319-63962-8
180-1, URL https://doi.org/10.
1007/978-3-319-63962-8_180-1
Oki BM, Liskov BH (1988) Viewstamped
Replication: A New Primary Copy Method
to Support Highly-Available Distributed
Systems. In: Proceedings of the Seventh An-
nual ACM Symposium on Principles of Dis-
tributed Computing, ACM, New York, NY,
USA, PODC ’88, pp 8–17
Technologies

Parity
Ethereum Blockchain. URL https:
//www.parity.io/

(2018)

Parity

Park S, Kwon A, Fuchsbauer G, Gaˇzi P,
Alwen J, Pietrzak K (2015) SpaceMint:
A Cryptocurrency Based on Proofs of
Space. https://eprint.iacr.org/
2015/528

Pilkington M (2015) Blockchain Technol-
ogy: Principles and Applications. In: Re-
search Handbook on Digital Transforma-
tions, SSRN

Qadah T, Gupta S, Sadoghi M (2020) Q-store:
Distributed, multi-partition transactions via
queue-oriented execution and communica-
tion. In: Proceedings of the 23nd Interna-
tional Conference on Extending Database
Technology, EDBT, 2020, OpenProceed-
ings.org, pp 73–84, DOI 10.5441/002/edbt.
2020.08

Qadah TM, Sadoghi M (2018) QueCC: A
queue-oriented, control-free concurrency ar-
chitecture. In: Proceedings of the 19th In-
ternational Middleware Conference, ACM,
Middleware, pp 13–25, DOI 10.1145/
3274808.3274810

Rahnama S, Gupta S, Qadah TM, Hellings J,
Sadoghi M (2020) Scalable, resilient, and
conﬁgurable permissioned blockchain fab-
ric. Proc VLDB Endow 13(12)

Rosenfeld M (2014) Analysis of hashrate-based
double spending. CoRR abs/1402.2009,
http://arxiv.org/abs/
URL
1402.2009, 1402.2009

Sadoghi M (2017) Expodb: An exploratory data
science platform. In: Proceedings of the
Eighth Biennial Conference on Innovative
Data Systems Research, CIDR

