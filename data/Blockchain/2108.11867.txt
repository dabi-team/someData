1
2
0
2

g
u
A
9
2

]
L
P
.
s
c
[

2
v
7
6
8
1
1
.
8
0
1
2
:
v
i
X
r
a

A Typed Programmatic Interface to Contracts
on the Blockchain

Thi Thu Ha Doan[0000−0001−7524−4497] and Peter Thiemann[0000−0002−9000−1239]

University of Freiburg, Germany
{doanha,thiemann}@informatik.uni-freiburg.de

Abstract. Smart contract applications on the blockchain can only reach
their full potential if they integrate seamlessly with traditional software
systems via a programmatic interface. This interface should provide for
originating and invoking contracts as well as observing the state of the
blockchain. We propose a typed API for this purpose and establish some
properties of the combined system. Speciﬁcally, we provide an execution
model that enables us to prove type-safe interaction between programs
and the blockchain. We establish further properties of the model that
give rise to requirements on the API. A prototype of the interface is
implemented in OCaml for the Tezos blockchain.

Keywords: smart contracts · embedded domain speciﬁc languages ·
types.

1

Introduction

First generation blockchains were primarily geared towards supporting cryp-
tocurrencies. Bitcoin is the most prominent system of this kind [14]. Although
Bitcoin already features a rudimentary programming language called Script,
second generation blockchains like Ethereum [5] feature Turing-complete pro-
gramming facilities, called smart contracts. They provide robust trustworthy
distributed computing facilities even though the programs run on a peer-to-peer
network with untrusted participants. Each peer in the network runs the same
program and uses cryptographic methods to check the results among the other
peers and to create a persistent ledger of all transactions, the blockchain, thus
ensuring the integrity of the results. Third generation blockchains, like Tezos
[8], are adaptable to new requirements without breaking participating peers (no
“soft forks” required and “hard forks” can be avoided).

The strength of programs on the blockchain is also their weakness. They are
fully deterministic in that they can only depend on data that is ultimately stored
on the chain including the parameters of a contract invocation. Moreover, the
code, the data, as well as all transactions are public. These properties make it
hard to react to external stimuli like time triggers or events like a price exceeding
a threshold unless these stimuli get translated to contract invocations.

Arguably, smart contracts are more useful if they can be integrated with
traditional software systems and thus triggered from outside the blockchain.

 
 
 
 
 
 
2

Ha Doan, P. Thiemann

Oracles [13,6] provide an approach for contracts to obtain outside information.
A contract registers a request and a callback with an oracle. The oracle invokes
the callback as soon as an answer is available.

There are other usecases for connecting a contract with traditional software.
One example is automating procedures like managing an auction, bidding in
an auction, optimizing fees, or initiating delivery of goods to a customer. While
some of these procedures are amenable to implementation as contracts, we might
want to save the fee of running them on the blockchain. In particular, for actions
that happen strictly within a single domain of trust, it is not worth running them
on the blockchain. For example, automated bidding runs on behalf of a single
peer.

Building such automation requires a programmatic interface to implement
the interactions. Current blockchains mostly provide RPC interfaces, such as
the Ethereum JSON-RPC API [7] and the Tezos RPC API [8], but they require
cumbersome manipulation of string data in JSON format and do not provide
static guarantees (except that the response to a well-formed JSON input is also
a well-formed JSON output). To improve on this situation we present a typed
API for invoking contracts from OCaml programs. Our typed API supports the
implementation of application programs and oracles that safely interact with
smart contracts on the blockchain. Moreover, our approach provides a type-safe
facility to communicate with contracts where data is automatically marshalled
between OCaml and the blockchain. This interface is a step towards a seamless
integration of contracts into traditional programs.

Contributions

– A typed API for originating and invoking contracts as well as querying the

state of the blockchain.

– An operational semantics for functional programs running alongside smart

contracts in a blockchain.

– Established various properties of the combined system with proofs in up-

coming techreport.

– An implementation of a low-level OCaml-API to the Tezos blockchain, which

corresponds to the operational semantics.1

There is an extended version of the paper with further proofs.2

2 Motivation

Suppose you want to implement a bidding strategy for an auction that is de-
ployed on the blockchain as a smart contract. Your bidding strategy may start
at a certain amount and increase the bid until a limit is reached. Of course, you

1 Available at https://github.com/tezos-project/Tezos-Ocaml-API.
2 Available at https://arxiv.org/abs/2108.11867.

A Typed Programmatic Interface to Contracts on the Blockchain

3

parameter ( or ( unit %c l o s e )

storage ( pair bool

( unit %b i d ) ) ; # b i d i n t r a n s f e r
# b i d d i n g a l l o w e d
# c o n t r a c t owner
# h i g h e s t b i d d e r ’ s a d d r e s s

( pair address

address

) ) ;

Listing 1.1. Header of the auction contract

# l e t a u c t i o n = Cl . m a k e c o n t r a c t h a s h a u c t i o n h a s h
˜ p a r a m e t e r : ( Ct . Or ( Ct . Unit , Ct . Unit ) )
#
#
˜ s t o r a g e : ( Ct . P a i r
v a l a u c t i o n :

( Ct . Bool , Ct . P a i r

( Ct . Addr , Ct . Addr ) ) ) ) ; ;

( ( u n i t , u n i t ) E i t h e r . t ,

b o o l ∗ ( Cl . Addr . t ∗ Cl . Addr . t ) ) Cl . c o n t r a c t

Listing 1.2. Getting the auction handle

only want to increase your bid if someone else placed a higher bid. So you want
to write a program to implement this strategy.

This task cannot be implemented as a smart contract without cooperation
of the auction contract because it reacts on external triggers. Bidding requires
watching the current highest bid of the contract and react if another bidder
places a higher bid. The auction contract could anticipate the need for such
observations by allowing bidders to register callbacks that are invoked when a
higher bid arrives. However, we cannot assume such cooperation of the auction
contract nor would we be willing to pay the the fee for running that callback.

For concreteness, Listing 1.1 shows the header of an auction contract in
Michelson [12]. The parameter clause speciﬁes the contract’s parameter type. It is a
sum type (indicated by or) and each alternative constitutes an entrypoint, named
%close and %bid. The caller selects the entrypoint by injecting the argument into
the left or right summand. Both entrypoints take a unit parameter. The %bid
entrypoint considers the transferred tokens as the bid. The storage clause declares
the state of the contract, which is a nested pair type indicating whether bidding
is allowed (bool), the address of the contract owner (to prohibit unauthorized
calls to %close), and the bidder’s address. The highest bid corresponds to the
token balance of the contract.

We only outline the implementation of the entrypoints. The %close entrypoint
ﬁrst checks its sender’s address against the owner’s address in the store. Then it
transfers the funds to the owner, closes the contract by clearing the bidding ﬂag,
and leaves it to the owner to deliver the goods.3 The %bid entrypoint immediately
returns each bid that is not higher than the existing highest bid. Otherwise, it
keeps the funds transferred, returns the previous highest bid to its owner, and
stores the current bidder as the new highest bidder.

We present a program that implements strategic bidding by interacting with
the blockchain. The bidding strategy cannot be implemented as a smart contract.

3 For simplicity we elide safeguarding by a third-party oracle.

4

Ha Doan, P. Thiemann

l e t rec p o l l

l i m i t

s t e p =

l e t ( b i d d i n g ,
l e t h i g h b i d = Cl . g e t b a l a n c e a u c t i o n ;
i f b i d d i n g && h i g h b i d < l i m i t then

(

, h i g h e s t b i d d e r ) ) = Cl . g e t s t o r a g e a u c t i o n ;

( i f h i g h e s t b i d d e r <> m y a d d r e s s then

(∗ e n t r y p o i n t %b i d ∗)

try

Cl . c a l l c o n t r a c t a u c t i o n

( r i g h t

( min ( h i g h b i d + s t e p ,

l i m i t ) ) )

with
| Cl . FAILWITH message −> p o l l

l i m i t

s t e p ;

Time . s l e e p ( 5 ∗ 6 0 ) ;
p o l l

s t e p )

l i m i t

Listing 1.3. Bidding strategy

In Listing 1.2, we use the library function Cl.make contract from hash to obtain
a typed handle for the contract.4 The function takes the hash of the contract
along with representations of the types of the parameter and the storage (from
module Ct). It checks the validity of the hash and the types with the blockchain
and returns a typed handle, which is indexed with OCaml types corresponding
to parameter and storage type.

The implementation of the bidding strategy in Listing 1.3 ﬁrst checks the
state of the contract to ﬁnd the current highest bid. As long as bidding is allowed
and the current bid is below our limit, we update our bid by a given amount
step, and then keep watching the state of the contract by polling it every ﬁve
minutes.

The functions get storage and get balance obtains the storage and current bal-
ance, respectively, of a contract from the blockchain. They never fail. Function
call contract takes a typed handle and a parameter of suitable type. It indicates
failure by raising an exception. If failure is caused by the FAILWITH instruc-
tion in the contract, then the corresponding Cl.FAILWITH exception is raised,
which carries a string corresponding to the argument of the instruction. In our
particular example, the auction may fail with signaling the message ”closed” or
”bid too low”. Our code ignores this message for simplicity.

This code is idealized in several respects. Originating or running a contract
requires proposing a fee to the blockchain, which may or may not be accepted.
Starting a contract may also time out for a variety of reasons. So just invoking a
contract with a ﬁxed fee does not guarantee the contract’s execution. Even if the
invocation is locally accepted, it still takes a couple of cycles before we can be sure
the invocation is globally accepted and incorporated in the blockchain. Hence,
after starting the invocation, we have to observe the fate of this invocation.
If it does not get incorporated, then we need to analyze the reason and react
accordingly. For example, if the invocation was rejected because of an insuﬃcient
fee, we might want to restart with an increased fee. Or we might decide to wait
until the invocation goes through without increasing the fee.

4 Cl is the module containing the contract library.

A Typed Programmatic Interface to Contracts on the Blockchain

5

Hence, we would implement a scheme similar to the bidding strategy: start
with a low fee and increase (or wait) until the contract is accepted or a fee cap is
reached. On the other hand, an observer function like get state always succeeds.
The low-level interface that we propose in this paper requires the programmer
to be explicit about fees, waiting, and polling the state of contract invocations.

In summary, a useful smart-contract-API has facilities to

– query the current state of the blockchain (e.g., fees in the current block),
– query storage and balance of a contract (to obtain the current highest bid),
– originate contracts, invoke contracts, and initiate transfers. Hence, the API

has to run on behalf of some account (by holding its private key).

These facilities are supported by the (untyped) RPC interface of the Tezos
blockchain, which is the basis of our implementation.

3 Execution Model

The context of our work is the Tezos blockchain [8,2]. Tezos is a self-amending
blockchain that improves several aspects compared to established blockchains.
Tezos proposes an original consensus algorithm, Liquid Proof of Stake, that
applies not only to the state of its ledger, like Bitcoin [14] or Ethereum [5], but
also to upgrades of the protocol and the software.

Tezos supports two types of accounts: implicit accounts, which are associated
with a pair of private/public keys, and smart contracts, which are programmable
accounts created by an origination operation. The address of a smart contract
is a unique public hash that depends on the creation operation. No key pair
is associated with a smart contract. An implicit account is maintained on the
blockchain with its public key and balance. A smart contract account is stored
with its script, storage, and balance. A contract script maps a pair of a parameter
and a storage, which have ﬁxed and monomorphic types, to a pair of a list of
internal operations and an updated storage. An account can perform three kinds
of transactions: (1) transfer tokens to an implicit account, (2) invoke a smart
contract, or (3) originate a new smart contract. A contract origination speciﬁes
the script of the contract and the initial contents of the contract storage, while a
contract invocation must provide input data. Each transaction contains a fee to
be paid either by payment to a baker or by destruction (burning). A transaction
is injected into the blockchain network via a node, which then validates the
transaction before submitting it to the network. A transaction may be rejected by
the node for a number of reasons. After validation, the transaction is injected into
a mempool, which contains all pending transactions before they can be included
in a block. A pending transaction may simply disappear from the mempool,
for example, a transaction times out when 60 blocks have passed and it can no
longer be included in a block. When a transaction is included in the blockchain,
the aﬀected accounts are updated according to the transaction result.

The execution model consists of functional (OCaml) programs that interact
with an abstraction of the Tezos blockchain [8]. As the blockchain is realized by

6

Ha Doan, P. Thiemann

a peer-to-peer network of independent nodes, interaction happens through local
nodes that receive requests to originate and invoke contracts from programs
that run on a particular node. We model the blockchain itself as a separate,
abstract global entity that represents the current consensual state of the system.
Our model does not express low-level details, but relies on nondeterminism to
describe the possible behaviors of the system. In particular, we do not formalize
the execution of the smart contracts themselves, we rather consider them as
black boxes and probe their observable behavior. Tezos’s smart contract language
Michelson and its properties have been formalized elsewhere [4].

We write ∅ for the empty set and e :: s to decompose a set nondeterminis-
tically into an element e and a set s. We generally use lowercase boldface for
metavariables ranging over values of a certain syntactic category, e.g., puk for
public keys, and the capitalized name for the corresponding type as well as for
the set of these values (as in Puk).

3.1 Local Node

A local node runs on behalf of authorities, which are called accounts in Tezos.
An account is represented by a key pair (cid:104)pak, puk(cid:105), where pak is a private key
and puk the corresponding public key in a public key encryption scheme.

The local node oﬀers operations to transfer tokens from one account to an-

other, to invoke a contract, and to originate a contract on the blockchain.

op ::= transfer nt from puk to addr arg p fee fee

| originate contract transferring nt from puk running code init s fee fee

In the transfer, which also serves as contract invocation, nt is the amount of
tokens transferred, puk is the public key of the sender, addr is either a public
key for an implicit account (in case of a simple transfer) or a public hash for
a smart contract (for an invocation), p is the argument passed to the smart
contract, which is empty for a simple transfer, and fee is the amount of tokens
for the transaction fee. In originate, code is the script of a smart contract and s
is the initial value of the contract’s storage. Each operation returns an operation
hash oph, on which we can query the status of the operation.

The local node oﬀers several ways to query the current state of the blockchain.

Some query operators are deﬁned by the following grammar:

qop ::= balance | status | storage | contract | . . .

We obtain the balance associated with an implicit account or a contract by its
public key or public hash, respectively; the status of a submitted operation by
its operation hash; the stored value of a contract by its public hash; and the
public hash of a contract by the operation hash of its originating transaction.

The domain-speciﬁc types come with diﬀerent guarantees. Values of type Puh
and Puk as well as Addr are not necessarily valid, as there might be no contract
associated with a hash / no account associated with a public key. In contrast,

A Typed Programmatic Interface to Contracts on the Blockchain

7

c ::= i | ﬁx | oph | puh | puk | code | nt | () | False | True

st ::= pending | included(i) | timeout

err ::= xPrg | xBal | xCount | xFee | xPub | xPuh | xArg | xInit

e ::= c | st | err | x | λx.e | ee | e + e | e = e | e and e | e or e | not e

| (e, e) | nil

| cons e e | left e | right e | some e | none | match e with pat → e . . .

| raise e | try e except e | (e : T ⇒ U )

| qop e | transfer e from e to e arg e fee e

| originate contract transferring e from e running e init e fee e

pat ::= x | (pat, pat) | nil | cons pat pat | left pat | right pat | some pat | none

| False | True | st | err

T, U ::= Puh | Puk | Addr | Cont T U | Code T U | Oph T U | Status | Exc | Tz

| (cid:62) | Int | Unit | Bool | Str | T → U | Pair T U | List T | Or T U | Option T

Fig. 1. Syntax of expressions, e, and types, T

a value of type Cont T is a public hash that is veriﬁed to be associated with a
contract with parameter type T . Operation hashes oph are only returned from
blockchain operations. As the surface language neither contains literals of type
Oph nor are there casts into that type, all values of Oph are valid.

Deﬁnition 1. The state of a node is a pair N = [e, A], where e is a set of
programs and A ⊆ Pak × Puk is a set of implicit accounts.

Queries and operations are started by closed expressions of type unit that run
on the local node. Each program can send transactions on behalf of any account
on the local node. Figure 1 deﬁnes the syntax of lambda calculus with sum,
product, list, and option types, exceptions and ﬁxpoint. Pattern matching is the
only means to decompose values, cf. pat. The execution model envisions oﬀ-chain
programs interacting with smart contracts on the blockchain. The programs are
deﬁned using expression scripts. The oﬀ-chain scripts run on behalf of a single
entity.

Domain-speciﬁc primitive types and constants c support blockchain interac-
tion, as well as several exceptional values collected in err. There is syntax to
initiate transfers and to originate contracts as well as for the queries. Finally,
there is a type cast (e : T ⇒ U ), which we describe after discussing types. An
implementation provides all of these types and operations via a library API.

Types (also in Figure 1) comprise some base types as well as functions, pairs,
lists, sums, and option types. These types are chosen to match with built-in types
of Michelson. There are domain speciﬁc types of public hashes Puh and public
keys Puk subsumed by a type of addresses Addr. Cont T U is the type of a con-
tract with parameter type T and storage type U . Code T U indicates a Michelson
program with parameter type T and storage type U . Tezos tokens have type Tz.

8

Ha Doan, P. Thiemann

E ::= [ ] | sc[v E e] | raise E | try E except e | match E with pat → e . . .

v ::= c | st | err | λx.e | (v, v) | nil | cons v v | left v | right v | some v | none

Fig. 2. Evaluation contexts and values

The type Oph T U signiﬁes operation hashes returned by blockchain operations.
The parameters of the hash carry the types when originating a contract. Oth-
erwise, they are set to the irrelevant type (cid:62). We take the liberty of omitting
irrelevant type parameters, that is, we write Oph for Oph (cid:62) (cid:62). Querying the
status of an operation returns a value of type Status. Exceptions have type Exc.
Figure 2 deﬁnes evaluation contexts EC and values v. Here sc ranges over
the remaining syntactic constructors, which are treated uniformly: evaluation
proceeds from left to right. Values are standard for call-by-value lambda calculus.
Type casts are only applicable to certain pairs of types governed by a relation
<:, which could also serve as a subtyping relation. It is given by the axioms
Puh <: Addr, Puk <: Addr, and Cont T U <: Puh. A cast from T to U is only
allowed if T <: U (upcast) or U <: T (downcast). Upcasts always succeed, but
downcasts may fail at run time. In particular, public hashes and public keys
can both stand for addresses. Moreover, a smart contract with parameter type
T is represented by its public hash at run time. The corresponding downcast
must check whether the public hash is valid and has the expected parameter
and storage type.

Figure 3 presents selected typing rules for expressions. We rely on an ex-
ternal typing judgment (cid:96)C code : T for the contract language, which we leave
unspeciﬁed, and (cid:96)V s : T for serialized values as stored on the blockchain. The
latter judgment states s is a string parseable as a value of type T .

3.2 Global Structures

Our execution model abstracts from the particulars of the blockchain imple-
mentation, like the peer-to-peer structure or the distributed consensus protocol.
Hence, we represent the blockchain by a few global entities: managers, contrac-
tors, and a pool of operations.

A manager keeps track of a single implicit account. Managers are represented
by a partial map M : Puk (cid:44)→ Bal × Cnt. If M(puk) = (cid:104)bal, cnt(cid:105) is deﬁned, then
puk is the public key of an account, bal is its balance and cnt is its counter
whose form is a value-ﬂag pair (n, b) ∈ N × Bool, where n is the value of the
counter and b is its ﬂag. The counter is used internally to serialize transactions.
A contractor manages a single smart contract. Contractors are represented
by a partial map C : Puh (cid:44)→ Code × t × Bal × Storage. If C(puh) = (cid:104)code,
t, bal, storage(cid:105) is deﬁned, then puh is the public hash of a contract, code is its
code, t is the time when it was accepted, bal is its current balance, and storage
is its current storage. The hash puh is self-verifying as it is calculated from the
ﬁxed components code and t. All time stamps will be diﬀerent in our model.

A Typed Programmatic Interface to Contracts on the Blockchain

9

Γ (cid:96) i : Int

Γ (cid:96) oph : Oph T U

Γ (cid:96) puh : Puh

Γ (cid:96) puk : Puk

(cid:96)C code : Pair Tp Ts
Γ (cid:96) code : Code Tp Ts

Γ (cid:96) nt : Tz

Γ (cid:96) () : Unit

Γ (cid:96) False : Bool

Γ (cid:96) True : Bool

Γ (cid:96) pending : Status

Γ (cid:96) timeout : Status

Γ (cid:96) e : Int

Γ (cid:96) included(e) : Status

Γ (cid:96) err : Exc

Γ (cid:96) x : Γ (x)

Γ, x : T (cid:48) (cid:96) e : T
Γ (cid:96) λx.e : T (cid:48) → T

Γ (cid:96) e : T (cid:48) → T

Γ (cid:96) e(cid:48) : T (cid:48)

Γ (cid:96) e e(cid:48) : T

Γ (cid:96) e(cid:48) : T (cid:48)
Γ (cid:96) e : T
Γ (cid:96) (e, e(cid:48)) : Pair T T (cid:48)

Γ (cid:96) e : Exc

Γ (cid:96) raise e : T

Γ (cid:96) e : T

Γ (cid:96) e(cid:48) : Exc → T

Γ (cid:96) e : T

T <: U ∨ U <: T

Γ (cid:96) try e except e(cid:48) : T

Γ (cid:96) (e : T ⇒ U ) : U

Fig. 3. Typing rules for expressions (excerpt)

Γ (cid:96) e1 : Tz

Γ (cid:96) e2 : Puk

Γ (cid:96) e3 : Puk
Γ (cid:96) transfer e1 from e2 to e3 arg e4 fee e5 : Oph (cid:62) (cid:62)

Γ (cid:96) e4 : Unit

Γ (cid:96) e5 : Tz

Γ (cid:96) e1 : Tz

Γ (cid:96) e4 : Tp
Γ (cid:96) e3 : Cont Tp Ts
Γ (cid:96) e2 : Puk
Γ (cid:96) transfer e1 from e2 to e3 arg e4 fee e5 : Oph (cid:62) (cid:62)

Γ (cid:96) e5 : Tz

Γ (cid:96) e1 : Tz
Γ (cid:96) e5 : Tz
Γ (cid:96) e3 : Code Tp Ts
Γ (cid:96) originate contract transferring e1 from e2 running e3 init e4 fee e5 : Oph Tp Ts

Γ (cid:96) e2 : Puk

Γ (cid:96) e4 : Ts

Γ (cid:96) e : Addr

Γ (cid:96) e : Oph T U

Γ (cid:96) balance e : Tz

Γ (cid:96) status e : Status

Γ (cid:96) e : Cont Tp Ts
Γ (cid:96) storage e : Ts

Γ (cid:96) e : Oph T U

T (cid:54)= (cid:62)

U (cid:54)= (cid:62)

Γ (cid:96) contract e : Cont T U

Fig. 4. Typing rules for blockchain operations and queries

10

Ha Doan, P. Thiemann

When an operation is started on a node, it enters a pool as a pending oper-
ation. A pending operation is either dismissed after some time or promoted to
an included operation, which has become a permanent part of the blockchain.

The pool is a partial map P = Oph (cid:44)→ Op × Time × Status where

Status = pending + included Time + timeout

such that if P(oph) = (cid:104)op, t, st(cid:105) is deﬁned, then oph is the public hash of the
operation, op is the operation, t is the time when the operation was injected, and
st is either pending, included t(cid:48), or timeout. A pool P is well-formed if, for all
oph, P(oph) = (cid:104)op, t, included t(cid:48)(cid:105) implies t(cid:48) ≥ t and oph = genOpHash(op, t).
A pending operation is represented by oph (cid:55)→ (cid:104)op, t, pending(cid:105). Once the op-
eration is accepted, it changes its status to included: oph (cid:55)→ (cid:104)op, t, included t(cid:48)(cid:105),
where t(cid:48) ≥ t is when the operation was included in the blockchain. The op-
eration may also be dropped at any time, which is represented by oph (cid:55)→
(cid:104)op, t, timeout(cid:105). There are several causes for dropping, primarily timeout or
overﬂow of the pending pool which is limited in size in the implementation.

In summary, the state of a blockchain is a tuple B = [P, M, C, t] where P is
a pool of operations, M is a map of managers, C is a map of contractors, and t
is the current time.

We often use the dot notation to project a component from a tuple. For

instance, we write B.M to access the managers component.

A blockchain conﬁguration has the form B[N1, . . . , Nn], for some n > 0,
where B is a blockchain and the Ni are local nodes, for 1 ≤ i ≤ n. In a well-
formed conﬁguration, the accounts on the local nodes are all diﬀerent and each
local account has a manager in B:

1. for all 1 ≤ i < j ≤ n, Ni.A ∩ Nj.A = ∅;
2. for all 1 ≤ i ≤ n, ∀a ∈ Ni.A =⇒ a.puk ∈ dom(B.M).

4 Operational Semantics

The operational semantics is deﬁned by several kinds of transitions:

1. −→E single-step evaluation of an expression in a local node,
2. −→N internal transitions of a node,
3. −→B transitions of the blockchain state,
4. −→ blockchain system transitions.

Evaluation of expressions is standard for call-by-value lambda calculus de-
ﬁned using evaluation contexts E[]. Figure 5 shows some of the reduction rules.
The internal transitions of a node are just evaluation of expressions.

Node-Eval

e −→E e(cid:48)
[E[e] :: e, A] −→N [E[e(cid:48)] :: e, A]

A Typed Programmatic Interface to Contracts on the Blockchain

11

E[(λx.e)v] −→E E[e[v/x]]

E[try v except e] −→E E[v]

T <: U
E[(v : T ⇒ U )] −→E E[v]

try /∈ F[]
E[try F[raise v] except e] −→E E[e v]

Fig. 5. Select expression reduction rules (pattern matching omitted)

Node-Inject

(cid:104)pak, puk(cid:105) ∈ A
chkCount(M, puk)
oph = genOpHash(op, t)

chkBal(M, puk, nt, fee)
chkPuh(C, puh)
op = transfer nt from puk to puh arg p fee fee

chkArg(C, puh, p)
chkFee(C, puh, p, fee)

[E[op] :: e, A](cid:107)[P, M, C, t] −→ [E[oph] :: e, A](cid:107)[oph (cid:55)→ (cid:104)op, t, pending(cid:105) :: P,
updCount(M, puk, True), C, t]

Node-Reject

¬ chkBal(B.M, op.puk, op.nt, op.fee)

[E[op] :: e, A](cid:107)B −→ [E[raise xBal] :: e, A](cid:107)B

Block-Accept

op = transfer nt from puk to puh arg p fee fee

t − ˆt ≤ 60

[oph (cid:55)→ (cid:104)op, ˆt, pending(cid:105) :: P, M, C, t] −→B [oph (cid:55)→ (cid:104)op, ˆt, included t(cid:105) :: P,
updSucc(M, puk, nt, fee), updConstr(C, puh, nt, p), t + 1]

Block-Timeout

t − ˆt > 60
[oph (cid:55)→ (cid:104)op, ˆt, pending(cid:105) :: P, M, C, t] −→B [oph (cid:55)→ (cid:104)op, ˆt, timeout(cid:105) :: P,
updCount(M, op.puk, False), C, t]

Fig. 6. Lifecycle transitions of a transaction

The remaining transitions aﬀect a local node in the context of the blockchain.
To this end, any local node may be selected.

Config-System

N(cid:107)B −→ N(cid:48)(cid:107)B(cid:48)
B[N :: N] −→ B(cid:48)[N(cid:48) :: N]

Config-Node

N −→N N(cid:48)
B[N :: N] −→ B[N(cid:48) :: N]

Config-Block
B −→B B(cid:48)
B[N] −→ B(cid:48)[N]

Figure 6 shows the transitions to start and ﬁnalize a contract invocation.
Node-Inject aﬀects a local node and the blockchain. It nondeterminstically se-
lects a program that wants to do a transfer operation. It checks whether the
sender of the transfer is a valid local account, whether the balance is suﬃcient
to pay the fee and the transferred amount, whether there is an active transition
for this sender (chkCount), whether the public hash is associated with a smart
contract on the blockchain, whether the type of the input parameter matchs
with the smart contract’s parameter type (chkArg), and whether the fee is suf-

12

Ha Doan, P. Thiemann

Contract-Yes

(cid:96)C code : Pair T U

B.C(puh) = (cid:104)code, ˜t, nt(cid:48), s(cid:48)(cid:105)

[E[(puh : Puh ⇒ Cont T )] :: e, A](cid:107)B −→ [E[puh] :: e, A](cid:107)B

Contract-No

B.C(puh) = (cid:104)code, ˜t, nt(cid:48), s(cid:48)(cid:105) ⇒ (cid:96)C code : Pair T (cid:48) U ∧ T (cid:54)= T (cid:48)
[E[(puh : Puh ⇒ Cont T )] :: e, A](cid:107)B −→ [E[raise xPrg] :: e, A](cid:107)B

Fig. 7. Cast reductions (excerpt)

ﬁcient. If these conditions are fulﬁlled, the transition forges an operation hash
and returns it to the local node. The pending operation enters the pool and the
sender’s counter is set to indicate an ongoing transition.

We give just one example Node-Reject of the numerous transitions that
cover the cases where one of the premises of Node-Inject is not fulﬁlled. Each
of them raises an exception that describes which condition was violated.

Acceptance or rejection of a pending operation happens on the blockchain in-
dependent of any local node. In our model, these transitions are nondeterministic
so that acceptance can happen any time in the next 60 cycles Block-Accept.
Afterwards, a pending operation can only time out Block-Timeout. If the trans-
action is accepted, then the sender’s counter is reset, the balances of sender is
adjusted (updSucc), the smart contract’s storage and balance are updated (up-
dConstr), and the time stamp increases.

Whereas Node-Inject and Block-Accept are particular to the transfer oper-
ation, the timeout transition applies to all operations. It just changes the state of
the operation and resets the sender’s counter, thus rolling back the transaction.

4.1 Cast Reductions

Figure 7 contains the most interesting example of cast reductions, from a public
hash to a typed contract. These reductions force the local node to obtain infor-
mation from the blockchain. The cast succeeds on puh (‘CONTRACT-YES’), if
there is a contractor for puh such that the stored code has the parameter type
expected by the cast. The cast fails (‘CONTRACT-NO’), if puh is invalid or if
the types do not match.

4.2 Smart Contracts

The invocation of smart contracts is similar to a transfer, so we elide the details.
Figure 8 contains the transition Block-Originate to originate a smart contract.
The basic scheme is similar to the transfer. The preconditions for the operation
are checked, but there are extra preconditions for origination: the program must
be well-formed and typed, the initial storage value must match its type. The
operation ends up in the pool in pending status.

A Typed Programmatic Interface to Contracts on the Blockchain

13

Block-Originate

chkBal(M, puk, nt, fee)

chkCount(M, puk)

chkPrg(code)

(cid:104)pak, puk(cid:105) ∈ A

chkFee(code, s, nt, fee)

chkInit(code, s)
op = originate contract transferring nt from puk running code init s fee fee

oph = genOpHash(op, t)

[E[op] :: e, A](cid:107)[P, M, C, t] −→ [E[oph] :: e, A](cid:107)[oph (cid:55)→ (cid:104)op, t, pending(cid:105) :: P,
updCount(M, puk, True), C, t]

Block-Originate-Accept
op = originate contract transferring nt from puk running code init s fee fee

puh = genHash(code, t)

t − ˆt ≤ 60

[oph (cid:55)→ (cid:104)op, ˆt, pending(cid:105) :: P, M, C, t] −→B [oph (cid:55)→ (cid:104)op, ˆt, included t(cid:105) :: P,
updSucc(M, puk, nt, fee),puh (cid:55)→ (cid:104)code, t, nt, s(cid:105) :: C, t + 1]

Block-Accept-Query
op = originate contract transferring nt from puk running code init s fee fee

P(oph) = (cid:104)op, ˆt, included ˜t(cid:105)

puh = genHash(code, ˜t)

[E[contract oph] :: e, A](cid:107)[P, M, C, t] −→ [E[puh] :: e, A](cid:107)[P, M, C, t]

Fig. 8. Smart contract origination

Query-Balance-Implicit

B.M(puk) = (cid:104)bal, cnt(cid:105)

[E[balance puk] :: e, A](cid:107)B −→ [E[bal] :: e, A](cid:107)B

Query-Balance-Fail

puk /∈ dom(B.M)

[E[balance puk] :: e, A](cid:107)B −→ [E[raise xPub] :: e, A](cid:107)B

Fig. 9. Example queries

Acceptance of origination is slightly diﬀerent as for transfers as shown in
Block-Accept. We calculate the public hash puh of the contract from the code
and the current time stamp and create a new contractor at that address.

We obtain the handle of the contract through a query, once the contract is
accepted on the blockchain in Block-Accept-Query. The query’s argument is
the operation hash, which is used to obtain the code and the time stamp of its
acceptance. From this information, we can re-calculate the public hash.

4.3 Queries

We conclude with two example transitions for a simple query in Figure 9. To
obtain the balance of an implicit account puk, we obtain the account info from
the manager and extract the balance (Query-Balance-Implicit). If the account

14

Ha Doan, P. Thiemann

is unknown, then we raise an exception (Query-Balance-Fail). Other queries
are implemented analogously.

5 Properties

Having deﬁned our execution model, we proceed to prove properties of the
combined systems that ensure type-safe interaction between programs and the
blockchain.

5.1 Properties of blockchain state transitions

One interesting property we wish to prove is that the execution of a program
that starts with valid references to accounts, operations, and contracts is not
corrupted by a transition.

Proposition 1. The following properties are preserved by a step on a well-
formed conﬁguration [e, A](cid:107)B:

– for all oph in e, oph ∈ dom(B.P),
– for all puk in e, puk ∈ dom(B.M),
– for all puh in e, puh ∈ dom(B.C).

Proposition 2. If [P, M, C, t] −→B [P(cid:48), M(cid:48), C(cid:48), t(cid:48)], then

1. t ≤ t(cid:48)
2. dom(P) ⊆ dom(P(cid:48))
3. invariant for the pool: if P(oph) = (cid:104)op, ˆt, st(cid:105), then oph = genOpHash(op, ˆt).
4. for all oph ∈ dom(P ), if P(oph) = (cid:104)op, ˆt, st(cid:105), then either

– P(cid:48)(oph) = P(oph); or
– st = pending and P(cid:48)(oph) = (cid:104)op, ˆt, timeout(cid:105); or
– st = pending, t − ˆt ≤ 60, P(cid:48)(oph) = (cid:104)op, ˆt, included t(cid:105), and t(cid:48) = t + 1.

5. for all oph ∈ dom(P ) and P(oph) = (cid:104)op, ˆt, st(cid:105),

– if st = pending and M(op.puk) = (cid:104)bal, cnt(cid:105) then cnt.b = True and

bal ≥ op.nt + op.fee;

– if st = included ˆt, then ˆt < t(cid:48).

6. dom(M) ⊆ dom(M(cid:48))
7. for all puk ∈ dom(M)

if M(puk) = (cid:104)bal, cnt(cid:105), then M(cid:48)(puk) = (cid:104)bal(cid:48), cnt(cid:48)(cid:105) and

– if cnt.b = True and cnt(cid:48).b = False, then cnt.n(cid:48) ∈ {cnt.n, cnt.n + 1},
– otherwise cnt.n = cnt(cid:48).n
– If cnt.n = cnt(cid:48).n, then bal = bal(cid:48).

8. dom(C) ⊆ dom(C(cid:48))

– for all puh ∈ dom(C), C(puh).code = C(cid:48)(puh).code

9. invariant for contractors: for all puh ∈ dom(C),

C(puh) = (cid:104)code, ˜t, bal, storage(cid:105) implies that puh = genHash(code, ˜t).

A Typed Programmatic Interface to Contracts on the Blockchain

15

Establishing items 4 and 7 relies on the preimage resistance of the various hash
functions used to calculate operation hashes and public hashes: we always feed
a fresh timestamp into the hash functions for operations and code. Items 2–5
describe an invariant and the lifecycle of operations. Items 6 and 7 describe the
lifecycle of a transfer and items 8 and 9 describe invariants for contractors. The
invariants establish the self-verifying property common of blockchain entities.

The proofs of these properties refer to all transitions with the detailed spec-
iﬁcations of the related functions, such as chkCount and updSucc. Due to page
limitations, not all transitions and their associated functions are presented in
this paper, so the full proofs will be provided in an upcoming technical report.
In this paper, we only provide the proofs for Proposition 2 at items 4 and 7.

Proof (4). After feeding into a node, the status of the operation is pending
according to the transition Node-Inject. This operation could either be accepted
by the blockchain on the condition that the elapsed time is less than 60 (t − ˆt ≤
60), and then its status is included t (the transition Block-Accept) or it is timed
out with the timeout status (Block-Timeout). When an operation is accepted
or timed out, its status is never changed. Therefore, if P(oph) = (cid:104)op, ˆt, st(cid:105), then
there are three cases:

(1) if the operation’s status remains the same as st (still in pending, included
or timeout), then we have P(cid:48)(oph) = (cid:104)op, ˆt, st(cid:105). This means P(cid:48)(oph) =
P(oph);

(2) if the operation’s status is pending (st = pending), and then the operation
is timed out, then we have P(cid:48)(oph) = (cid:104)op, ˆt, timeout(cid:105) according to the
transition Block-Timeout;

(3) if the operation’s status is pending, the time condition is satisﬁed, and then
the operation is accepted, then we have P(cid:48)(oph) = (cid:104)op, ˆt, included t(cid:105) and
t(cid:48) = t + 1 because the timestamp is incremented by one according to the
transition Block-Accept.

From (1), (2) and (3), the item 4 of Proposition 2 is proved.

Proof (7). To prove this point, let us consider the two related functions. The
function updCount(M, puk, b) updates the ﬂag of the counter of the account
associated with the public key puk. Its speciﬁcation is as follows:

updCount(puk (cid:55)→ (cid:104)bal, (n, ˆb)(cid:105), b) = puk (cid:55)→ (cid:104)bal, (n, b)(cid:105)

The function updSucc(M, puk, nt, fee) updates the balance and the counter
of the account associated with the public key puk. Its speciﬁcation is as follows:

updSucc(puk (cid:55)→ (cid:104)bal, (n, True)(cid:105), nt, fee) = puk (cid:55)→ (cid:104)bal − nt − fee, (n +
1, False)(cid:105)

if M(puk) = (cid:104)bal, cnt(cid:105), then M(cid:48)(puk) = (cid:104)bal(cid:48), cnt(cid:48)(cid:105) and we have:

16

Ha Doan, P. Thiemann

(1) cnt.b = True means that the operation is injected and its status is pending
at the time t according to the transition Node-Inject. After that, there are
only two cases where the counter’s ﬂag is reset to False. If the operation is
accepted, the counter’s ﬂag is reset (cnt(cid:48).b = False) according to the tran-
sition Block-Accept and the counter’s value is incremented by 1 according
to the speciﬁcation of the function updSucc (cnt.n(cid:48) = cnt.n + 1). In another
case, if the operation is timed out, the counter’s ﬂag is also reset to False,
but the value of the counter remains the same (cnt.n(cid:48) = cnt) according to
the transition Block-timeout. That is, if cnt.b = True and cnt(cid:48).b = False,
then cnt.n(cid:48) ∈ {cnt.n, cnt.n + 1};

(2) otherwise, if the operation is still pending, the counter’s value remains the

same. This means cnt.n = cnt(cid:48).n;

(3) and then cnt.n = cnt(cid:48).n means that the operation is either still pending or
it has timed out. Therefore, the balance of the account remains the same
because the balance is only changed when the operation is accepted. This
means bal = bal(cid:48).

From (1), (2) and (3), the item 7 of Proposition 2 is proved.

5.2 Typing related properties

To describe the typing of contracts we maintain an environment ∆ ::= · | puh :
T, ∆ that associates a public hash with a type. We deﬁne typing for blockchains,
local nodes, and conﬁgurations.

dom(∆) = dom(B.C)

(∀puh ∈ dom(∆))

∆(puh) = Pair Tp Ts

(cid:96)C B.C(puh).code : Pair Tp Ts

(cid:96)V B.C(puh).storage : Ts

∆ (cid:96) B

The type for a hash is a pair type, which coincides with the type of the code
stored at that hash. The storage at that hash has the type expected by the code.

· (cid:96) ei : Unit
(cid:96) [e, A] ok

∆ (cid:96) B

(cid:96) Ni ok

∆ (cid:96) B[N]

Lemma 1 (Preservation). If B[N] −→ B(cid:48)[N(cid:48)] and ∆ (cid:96) B[N], then there is
some ∆(cid:48) ⊇ ∆ such that ∆(cid:48) (cid:96) B(cid:48)[N(cid:48)].

This lemma includes the standard preservation for the lambda calculus part.

Lemma 2 (Progress). If ∆ (cid:96) B[N], then either all expressions in all nodes
(cid:48)
are unit values or there is a conﬁguration B(cid:48)[N

] such that B[N] −→ B(cid:48)[N

].

(cid:48)

The consistency lemma says that all committed transactions respect the typing.

Lemma 3 (Consistency). Consider a blockchain state with ∆ (cid:96) [P, M, C, t].

For all oph ∈ dom(P), if P(oph) = (cid:104)op, ˆt, st(cid:105)

A Typed Programmatic Interface to Contracts on the Blockchain

17

– if op = transfer nt from puk to puk(cid:48) arg () fee fee, then

puk, puk(cid:48) ∈ dom(M);

– if op = transfer nt from puk to puh arg p fee fee, then

• puk ∈ dom(M) and puh ∈ dom(C),
• (cid:96)V p : Tp where ∆(puh) = Pair Tp Ts;

– if op = originate contract transferring nt from puk running code init s fee fee

and st = included t(cid:48), then

• puk ∈ dom(M) and puh = genHash(code, t(cid:48)) ∈ dom(C),
• ∆(puh) = Pair Tp Ts, (cid:96)C code : Pair Tp Ts and (cid:96)V s : Ts.

Proof. Consider the proof of the second item of Lemma 3, which speciﬁes the
property on type for a smart contract invocation. A smart contract call op has
the form transfer nt from puk to puh arg p fee fee. If P(oph) = (cid:104)op, ˆt, st(cid:105),
then the operation op is injected into the node. According to the transition
Node-Inject for a smart contract invocation, the public key is valid and the
public hash must be associated with a smart contract on the blockchain. This
means puk ∈ dom(M) and puh ∈ dom(C). Moreover, the chkArg function
checks whether the type of the input parameter p matches the parameter type
of the smart contract. If the casted type of the smart contract is ∆(puh) =
Pair Tp Ts, then the type of the parameter must be Tp. This means (cid:96)V p : Tp.
Therefore, this item is proved.

6 Related Work

The inability to access external data sources limits the potential of smart con-
tracts. Oracles [13,6,3] can help overcome this limitation by providing a bridge
between the outside sources and the blockchain network. A blockchain oracle is
used to provide external data for smart contracts. When the external data is
available, an oracle invokes a smart contract with that information. The invo-
cation can conveniently be made through a programmatic interface. There has
been extensive research on providing oracle solutions for blockchain. Adler et al
[11] propose a framework to explain blockchain oracles and various key aspects
of oracles. This framework aims to provide developers with a guide for incorpo-
rating oracles into blockchain-based applications. The main problems with using
a blockchain oracle are the untrusted data provided maliciously or inaccurately
[1]. Ma at el [10] propose an oracle equipped with veriﬁcation and disputation
mechanisms. Similarly, Lo et al [9] provide a framework for performing reliability
analysis of various blockchain oracle platforms.

Current blockchains such as Ethereum [5] and Tezos [8] often oﬀer RPC APIs
and use loosely structured data, such as a JSON-based format that is diﬃcult
for a programmatic program to handle. As a result, there is increasing work
to provide better programmatic interfaces to blockchains. Web3.js [15] provides
an Ethereum JavaScript API and oﬀers Java Script users a convenient interface
to interact with the Etherum blockchain. Later, Web3.py [16], derived from
Web3.js, is developed to provide a Python library for interacting with Ethereum.
Our typed API not only supports for programmatic programs, but also provides
veriﬁable interaction with the Tezos smart contract platform.

18

Ha Doan, P. Thiemann

7 Conclusion

We present a ﬁrst step towards a typed API for smart contracts on the Tezos
blockchain. Our formalization enables us to establish basic properties of the in-
teraction between ordinary programs and smart contracts. We see ample scope
for future work to provide a higher-level interface that exploits the similari-
ties between blockchain programming and concurrent programs. The next step
will be to formalize the typing-related results. The formalization could connect
with the Mi-Cho-Coq formalization of Michelson contracts [4]. In the end, we
would like to state and prove properties of a system that contains OCaml code
(multi-threaded or distributed) connected to Michelson contracts on the Tezos
blockchain via the typed API.

References

1. Al-Breiki, H., Rehman, M.H.U., Salah, K., Svetinovic, D.: Trustworthy blockchain
oracles: Review, comparison, and open research challenges. IEEE Access 8, 85675–
85685 (2020)

2. Allombert, V., Bourgoin, M., Tesson, J.: Introduction to the Tezos blockchain.
In: 2019 International Conference on High Performance Computing Simulation
(HPCS). pp. 1–10 (2019). https://doi.org/10.1109/HPCS48598.2019.9188227

3. Beniiche, A.: A study of blockchain oracles (2020)
4. Bernardo, B., Cauderlier, R., Hu, Z., Pesin, B., Tesson, J.: Mi-Cho-Coq, a frame-
work for certifying Tezos smart contracts. In: Formal Methods. FM 2019 Inter-
national Workshops, Revised Selected Papers, Part I. Lecture Notes in Computer
Science, vol. 12232, pp. 368–379. Springer (2019). https://doi.org/10.1007/978-3-
030-54994-7 28, https://doi.org/10.1007/978-3-030-54994-7_28

5. Buterin, V.: A next-generation smart contract and decentralized application plat-

form (2013), https://ethereum.org/en/whitepaper/

6. Caldarelli, G.: Understanding the blockchain oracle problem: A call for action.

Information 11(11) (2020)

7. Ethereum JSON-RPC API (2021), https://ethereum.org/en/developers/docs/

apis/json-rpc/

8. Goodman, L.: Tezos-a self-amending crypto-ledger (2014), https://www.tezos.

com/static/papers/white-paper.pdf

9. Lo, S.K., Xu, X., Staples, M., Yao, L.: Reliability analysis for blockchain oracles.

Computers & Electrical Engineering 83, 106582 (2020)

10. Ma, L., Kaneko, K., Sharma, S., Sakurai, K.: Reliable decentralized oracle with
mechanisms for veriﬁcation and disputation. In: 2019 Seventh International Sym-
posium on Computing and Networking Workshops (CANDARW). pp. 346–352
(2019)

11. Mammadzada, K., Iqbal, M., Milani, F., Garc´ıa-Ba˜nuelos, L., Matuleviˇcius, R.:
Blockchain Oracles: A Framework for Blockchain-Based Applications, pp. 19–34.
Springer Verlag (09 2020)

12. Michelson: The language of smart contracts in Tezos, https://tezos.gitlab.io/

alpha/michelson.html

13. M¨uhlberger, R., Bachhofner, S., Castell´o Ferrer, E., Di Ciccio, C., Weber, I.,
W¨ohrer, M., Zdun, U.: Foundational oracle patterns: Connecting blockchain to

A Typed Programmatic Interface to Contracts on the Blockchain

19

the oﬀ-chain world. Business Process Management: Blockchain and Robotic Pro-
cess Automation Forum p. 35–51 (2020)

14. Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system (2008), https://

www.tezos.com/static/papers/white-paper.pdf

15. Vogelsteller, F., Kotewicz, M., Wilcke, J., Oance, M.: web3.js - Ethereum

JavaScript API, https://web3js.readthedocs.io/en/v1.3.4/

16. Vogelsteller, F., Kotewicz, M., Wilcke, J., Oance, M.: web3.py - a Python library
for interacting with Ethereum, https://web3py.readthedocs.io/en/stable/

20

Ha Doan, P. Thiemann

A Type Soundness

Lemma 4 (Canonical forms). Given a set of local accounts A, a blockchain
B, and a typed value · (cid:96) v : T .

– If T = Puh, then v = puh and puh ∈ dom(B.C).
– If T = Puk, then v = puk and ∃pak such that (pak, puk) ∈ A.
– If T = Addr, then v is puh or puk.
– If T = Cont Tp Ts, then v = puh and puh ∈ dom(B.C) and B.C(puh) =
(code, t, bal, storage) such that (cid:96)C code : Pair Tp Ts and (cid:96)V storage : Ts.

– If T = Code T U , then v = code and (cid:96)C code : Pair T U .
– If T = Oph T U , then v = oph and oph ∈ dom(B.P) and B.P(oph) =
(cid:104)op, t, st(cid:105) where T = U = (cid:62) if op is a transfer and T = Tp (cid:54)= (cid:62), U = Ts (cid:54)= (cid:62)
if op = originate contract transferring nt from puk running code init s fee fee
and (cid:96)C code : Pair Tp Ts.

– If T = Status, then v ∈ {pending, included(i), timeout}.
– If T = Exc, then v ∈ {xPrg, xBal, xCount, xFee, xPub, xPuh, xArg, xInit}.
– If T = Tz, then v = nt, a token amount.
– If T = (cid:62), then v can be any syntactic value.
– If T = Int, then v = i.
– If T = Unit, then v = ().
– If T = Bool, then v ∈ {True, False}.
– If T = Str, then v = s, a string.
– If T = T → U , then v = λx.e.
– If T = Pair T U , then v = (v(cid:48), v(cid:48)(cid:48)) where · (cid:96) v(cid:48) : T and · (cid:96) v(cid:48)(cid:48) : U in context

A and B.

– If T = List T , then either v = nil or v = cons v(cid:48) v(cid:48)(cid:48) where · (cid:96) v(cid:48) : T and

· (cid:96) v(cid:48)(cid:48) : List T in context A and B.

– If T = Or T U , then either v = left v(cid:48) where · (cid:96) v(cid:48) : T or v = right v(cid:48)(cid:48) where

· (cid:96) v(cid:48)(cid:48) : U in context A and B.

– If T = Option T , then v = none or v = some v(cid:48) where · (cid:96) v(cid:48) : T in context

A and B.

Lemma 5 (Subterm replacement). If · (cid:96) E[e] : T , · (cid:96) e : T (cid:48), and · (cid:96) e(cid:48) : T (cid:48),
then · (cid:96) E[e(cid:48)] : T .

Proof. Induction on evaluation context E making use of the fact that an evalu-
ation context does not bind variables.

Lemma 6 (Preservation for expressions). If · (cid:96) e : T and e −→E e(cid:48), then
· (cid:96) e(cid:48) : T .

Proof. Standard result: type preservation for simply typed lambda calculus with
pairs, sums, and exceptions. Uses Lemma 5 for reductions in evaluation context.
See, for instance, Types in Programming Languages by Benjamin Pierce.

Lemma 7 (Preservation). If B[N] −→ B(cid:48)[N(cid:48)] and ∆ (cid:96) B[N], then there is
some ∆(cid:48) ⊇ ∆ such that ∆(cid:48) (cid:96) B(cid:48)[N(cid:48)].

A Typed Programmatic Interface to Contracts on the Blockchain

21

(cid:48)
Proof. The proof is by induction on the reduction relation B[N] −→ B(cid:48)[N
] and
inversion of the typing judgments. We only consider the exemplary reductions
shown in the paper. We mark all components that belong to the reductum with
(cid:48) as in N(cid:48).

From ∆ (cid:96) B[N] we obtain

From (1) we obtain

and ∀puh ∈ dom(∆)

∆ (cid:96) B
(cid:96) Ni ok

dom(∆) = dom(B.C)

∆(puh) = Pair Tp Ts
(cid:96)C B.C(puh).code : Pair Tp Ts
(cid:96)V B.C(puh).storage : Ts

From (2) we obtain, if Ni = [ei, Ai],

· (cid:96) eij : Unit

Config-Node

Reduction

N0 −→N N(cid:48)
0
B[N0 :: N] −→ B[N(cid:48)

.

0 :: N]

Node-Eval

(1)

(2)

(3)

(4)

(5)

(6)

(7)

.

The only possible reduction here is

e −→E e(cid:48)
[E[e] :: e, A] −→N [E[e(cid:48)] :: e, A]

From (7), we know that · (cid:96) e : Unit. By Lemma 6, · (cid:96) e(cid:48) : Unit, the types of
0 = [E[e(cid:48)] :: e, A] ok. None of the other nodes

the e are not aﬀected, hence (cid:96) N(cid:48)
changed, neither did B, so that ∆ (cid:96) B[N(cid:48)

0 :: N].

22

Ha Doan, P. Thiemann

Config-System

Reduction

N(cid:107)B −→ N(cid:48)(cid:107)B(cid:48)
B[N :: N] −→ B(cid:48)[N(cid:48) :: N]
We need to consider the cases for −→.

.

Node-Inject

chkBal(M, puk, nt, fee)

(cid:104)pak, puk(cid:105) ∈ A
chkArg(C, puh, p)

chkCount(M, puk)

chkPuh(C, puh)

chkFee(C, puh, p, fee)

oph = genOpHash(op, t)

op = transfer nt from puk to puh arg p fee fee
[E[op] :: e, A](cid:107)[P, M, C, t] −→
[E[oph] :: e, A](cid:107)[oph (cid:55)→ (cid:104)op, t, pending(cid:105) :: P, updCount(M, puk, True), C, t]

.

Subcase

Here N = [E[op] :: e, A]. We ﬁrst check type preservation for the expression
part. There are two typing rules for the transfer op, but only the one for con-
tract invocation applies as the other one requires · (cid:96) puh : Puk, which does not
hold.

For a contract invocation (specialized to empty environment)

· (cid:96) puk : Puk

· (cid:96) nt : Tz
· (cid:96) puh : Cont Tp Ts

· (cid:96) p : Tp

· (cid:96) fee : Tz

· (cid:96) transfer nt from puk to puh arg p fee fee : Oph (cid:62) (cid:62)

(8)

The canoncical forms lemma 4 is parameterized over the accounts A of the local
node and the current contractors B.C. Hence, we know that the arguments are
legal, which is also checked by the rule.

The reduct returns an operation hash oph at type Oph (cid:62) (cid:62), which places

no restrictions on the context of oph.

Moreover, ∆(cid:48) = ∆ and C(cid:48) = C as no new contract is originated.
We conclude with Lemma 5 and reapplying Config-System.

Contract-Yes

Subcase

(cid:96)C code : Pair T U

B.C(puh) = (cid:104)code, ˜t, nt(cid:48), s(cid:48)(cid:105)

[E[(puh : Puh ⇒ Cont T )] :: e, A](cid:107)B −→ [E[puh] :: e, A](cid:107)B

.

Immediate using Lemma 4 and Lemma 5.

Contract-No

Subcase

B.C(puh) = (cid:104)code, ˜t, nt(cid:48), s(cid:48)(cid:105) ⇒ (cid:96)C code : Pair T (cid:48) U ∧ T (cid:54)= T (cid:48)
[E[(puh : Puh ⇒ Cont T )] :: e, A](cid:107)B −→ [E[raise xPrg] :: e, A](cid:107)B
The typing rule for raise can return any type. Hence, this is immediate by

.

Lemma 5.

Block-Originate

chkBal(M, puk, nt, fee)

chkCount(M, puk)

chkPrg(code)

(cid:104)pak, puk(cid:105) ∈ A

Subcase

chkFee(code, s, nt, fee)

chkInit(code, s)
op = originate contract transferring nt from puk running code init s fee fee
[E[op] :: e, A](cid:107)[P, M, C, t] −→
[E[oph] :: e, A](cid:107)[oph (cid:55)→ (cid:104)op, t, pending(cid:105) :: P, updCount(M, puk, True), C, t]

oph = genOpHash(op, t)

.

A Typed Programmatic Interface to Contracts on the Blockchain

23

Suppose that (cid:96)C code : Pair Tp Ts. Then · (cid:96) op : Oph Tp Ts. But this is
the type of the oph in the reductum as it points to op in P. Hence, the result
is immediate by Lemma 5.

Query-Balance-Implicit

Subcase

B.M(puk) = (cid:104)bal, cnt(cid:105)
[E[balance puk] :: e, A](cid:107)B −→ [E[bal] :: e, A](cid:107)B

.

The reduction replaces balance puk of type Tz by bal of the same type.

Hence, the result is immediate by Lemma 5.

Query-Balance-Fail

Subcase

puk /∈ dom(B.M)
[E[balance puk] :: e, A](cid:107)B −→ [E[raise xPub] :: e, A](cid:107)B

.

Immediate by Lemma 5 because raise can have any type.

24

Ha Doan, P. Thiemann

Reduction

Config-Block
B −→B B(cid:48)
B[N] −→ B(cid:48)[N]

.

We need to considere cases for −→B.

Block-Accept

Subcase

op = transfer nt from puk to puh arg p fee fee

t − ˆt ≤ 60

[oph (cid:55)→ (cid:104)op, ˆt, pending(cid:105) :: P, M, C, t] −→B [oph (cid:55)→ (cid:104)op, ˆt, included t(cid:105) :: P,
updSucc(M, puk, nt, fee), updConstr(C, puh, nt, p), t + 1]

.

No typing-related properties are aﬀected.

Subcase

Block-Originate-Accept
op = originate contract transferring nt from puk running code init s fee fee

puh = genHash(code, t)

t − ˆt ≤ 60

[oph (cid:55)→ (cid:104)op, ˆt, pending(cid:105) :: P, M, C, t] −→B
[oph (cid:55)→ (cid:104)op, ˆt, included t(cid:105) :: P, updSucc(M, puk, nt, fee),
puh (cid:55)→ (cid:104)code, t, nt, s(cid:105) :: C, t + 1]

.

This reduction extends C with a new entry for puh. To preserve typing, we
need to extend ∆ with the binding puh : Pair Tp Ts where (cid:96)C code : Pair Tp Ts.
The generated code pointer is obtained with a query operation via the operation
hash oph, which is also connected to the parameter and storage types.

Block-Timeout

Subcase

t − ˆt > 60
[oph (cid:55)→ (cid:104)op, ˆt, pending(cid:105) :: P, M, C, t] −→B
[oph (cid:55)→ (cid:104)op, ˆt, timeout(cid:105) :: P, updCount(M, op.puk, False), C, t]

.

No typing-related properties are aﬀected.

A Typed Programmatic Interface to Contracts on the Blockchain

25

Lemma 8 (Progress for expressions). If · (cid:96) e : T , then either

– e is a value,
– e −→E e(cid:48), or
– e = E[e(cid:48)] is a blockchain operation in an evaluation context:

• e(cid:48) = transfer nt from puk to puh arg p fee fee;
• e(cid:48) = originate contract transferring nt from puk running code init s fee fee;
• e(cid:48) = qop v;
• e(cid:48) = (v : T ⇒ U ) where U <: T .

Proof. Standard result: progress for simply type lambda calculus with pairs,
sums, and exceptions. Upcasts are resolved by identity reductions. The blockchain
operations including downcasts are not handled by the −→E relation.

Lemma 9 (Progress). If ∆ (cid:96) B[N], then either all expressions in all nodes
(cid:48)
are unit values or there is a conﬁguration B(cid:48)[N

] such that B[N] −→ B(cid:48)[N

].

(cid:48)

Proof. From ∆ (cid:96) B[N] we obtain

From (9) we obtain

and ∀puh ∈ dom(∆)

∆ (cid:96) B
(cid:96) Ni ok

dom(∆) = dom(B.C)

∆(puh) = Pair Tp Ts
(cid:96)C B.C(puh).code : Pair Tp Ts
(cid:96)V B.C(puh).storage : Ts

From (10) we obtain, if Ni = [ei, Ai],

· (cid:96) eij : Unit

For each such eij, Lemma 8 yields that either

– eij is a value; as it has type Unit, we obtain eij = () by Lemma 4;
– eij −→E e(cid:48)
– eij = E[e] where e is a blockchain operation.

ij, in which case the whole system makes a step; or

(9)

(10)

(11)

(12)

(13)

(14)

(15)

Subcase e = transfer nt from puk to puh arg p fee fee. In this case, the

Node-Inject reduction is in principle enabled:
Node-Inject

chkBal(M, puk, nt, fee)

(cid:104)pak, puk(cid:105) ∈ A
chkArg(C, puh, p)

chkCount(M, puk)

chkPuh(C, puh)

chkFee(C, puh, p, fee)

oph = genOpHash(op, t)

op = transfer nt from puk to puh arg p fee fee
[E[op] :: e, A](cid:107)[P, M, C, t] −→
[E[oph] :: e, A](cid:107)[oph (cid:55)→ (cid:104)op, t, pending(cid:105) :: P, updCount(M, puk, True), C, t]

26

Ha Doan, P. Thiemann

Thanks to the canonical forms Lemma 4, we know that (cid:104)pak, puk(cid:105) ∈ A, chkArg(C, puh, p)
holds, and chkPuh(C, puh) holds. If one of the remaining checks fails, then one
of the Node-Reject transitions throws an exception, so the conﬁguration steps
in every case.

Subcase e = originate contract transferring nt from puk running code init s fee fee.

In this case, the Block-Originate reduction is in principle enabled:

Block-Originate

chkBal(M, puk, nt, fee)

chkCount(M, puk)

chkPrg(code)

(cid:104)pak, puk(cid:105) ∈ A

chkFee(code, s, nt, fee)

chkInit(code, s)
op = originate contract transferring nt from puk running code init s fee fee
[E[op] :: e, A](cid:107)[P, M, C, t] −→
[E[oph] :: e, A](cid:107)[oph (cid:55)→ (cid:104)op, t, pending(cid:105) :: P, updCount(M, puk, True), C, t]

oph = genOpHash(op, t)

Thanks to the canonical forms Lemma 4, we know that (cid:104)pak, puk(cid:105) ∈ A, chkPrg(code)
holds, and chkInit(code, s) holds. If one of the remaining checks fails, then one
of the Node-Reject transitions throws an exception, so the conﬁguration steps
in every case.

Subcase e = qop v. If e = balance v, then inversion tells us that · (cid:96)
v : Addr and by canonical forms (Lemma 4), it must be that v has the form
puk or puh. In any case, the value is a meaningful address for the man-
ager M. Depending on whether the address is in use, one of the reductions
Query-Balance-Implicit or Query-Balance-Fail can execute. There are fur-
ther analogous reductions handling the case where v = puh and we ask for the
balance of a smart contract.

Most queries behave like balance ·, except getting a contract handle from an

operation hash:

Subcase e = contract v. This query is somewhat special as it is handled with
reduction Block-Accept-Query. By inversion and canonical forms (Lemma 4)
we know that v = oph is a valid operation hash of type Cont T U where T (cid:54)= (cid:62)
and U (cid:54)= (cid:62).

However, this reduction is conditional on the state of the transaction; it
requires the new contract to have status included. If the contract has status
timeout, then the query raises and exception, analogous to the Query-Balance-Fail
reduction. If the contract has status pending, then the expression is blocked, but
the system can make a step using Block-Originate-Accept that changes the
status from pending to included. Alternatively, Block-Timeout can make a step
to change the status to timeout. In any case, the system as a whole can make a
reduction.

Subcase e = (v : T ⇒ U ) where U <: T . As an example, we consider
the reductions Contract-Yes and Contract-No, where a cast is applied to a

A Typed Programmatic Interface to Contracts on the Blockchain

27

value of type Puh. By canonical forms, we know that the value has the form
puh ∈ dom(B.C). The code pointed to by this hash is checked at run time and
results either in a puh at suitable contract type (-Yes reduction) or in raising
an exception (-No reduction).

