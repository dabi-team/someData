2
2
0
2

y
a
M
8
1

]

R
C
.
s
c
[

3
v
2
3
3
2
1
.
1
1
1
2
:
v
i
X
r
a

Longest Chain Consensus Under Bandwidth Constraint

Joachim Neu
jneu@stanford.edu

Srivatsan Sridhar
svatsan@stanford.edu

Lei Yang
leiy@csail.mit.edu

David Tse
dntse@stanford.edu

Mohammad Alizadeh
alizadeh@csail.mit.edu

ABSTRACT
Spamming attacks are a serious concern for consensus protocols,
as witnessed by recent outages of a major blockchain, Solana. They
cause congestion and excessive message delays in a real network
due to its bandwidth constraints. In contrast, longest chain (LC), an
important family of consensus protocols, has previously only been
proven secure assuming an idealized network model in which all
messages are delivered within bounded delay. This model-reality
mismatch is further aggravated for Proof-of-Stake (PoS) LC where
the adversary can spam the network with equivocating blocks.
Hence, we extend the network model to capture bandwidth con-
straints, under which nodes now need to choose carefully which
blocks to spend their limited download budget on. To illustrate this
point, we show that ‚Äòdownload along the longest header chain‚Äô, a
natural download rule for Proof-of-Work (PoW) LC, is insecure for
PoS LC. We propose a simple rule ‚Äòdownload towards the freshest
block‚Äô, formalize two common heuristics ‚Äònot downloading equiv-
ocations‚Äô and ‚Äòblocklisting‚Äô, and prove in a unified framework that
PoS LC with any one of these download rules is secure in bandwidth-
constrained networks. In experiments, we validate our claims and
showcase the behavior of these download rules under attack. By
composing multiple instances of a PoS LC protocol with a suitable
download rule in parallel, we obtain a PoS consensus protocol that
achieves a constant fraction of the network‚Äôs throughput limit even
under worst-case adversarial strategies.

1 INTRODUCTION

Consensus. In the state machine replication (SMR) formulation
of the consensus problem, a group of nodes aim to order transac-
tions received from the environment into a common ledger. For
this purpose, nodes exchange messages and perform computations
as prescribed by the consensus protocol. Consensus is made non-
trivial by an adversary who has some control over message delays,
controls a certain fraction of nodes, and can cause them to deviate
from the protocol in an arbitrary (Byzantine) manner in a concerted
effort to disturb consensus. Secure consensus is achieved if the re-
sulting transaction ledgers across different honest nodes and points
in time are consistent so that it is meaningful to speak of the single
common ledger (which is safe), and if that ledger is live in the sense
that every transaction gets assigned a position in the ledger soon
after it is input to honest nodes for the first time.

Nakamoto‚Äôs Longest Chain Protocol. In the seminal Bitcoin white-
paper [41], Satoshi Nakamoto describes the longest chain (LC) con-
sensus protocol. In this protocol, honest nodes broadcast blocks to
each other. A block contains a list of transactions, a nonce, and a
reference to a parent block, resulting in chains of blocks up to a root

JN, SS and LY contributed equally and are listed alphabetically.

1

genesis block that is common knowledge. A block is valid if a cryp-
tographic hash of it is smaller than a certain fixed threshold, and if
the transactions it contains have been legitimized by the owners of
the affected assets and are consistent with respect to transactions
preceding it as ordered in the same block and its ancestor blocks.
Every node adds valid blocks it receives to its local copy of the block
tree. Nodes also aim to produce new blocks. For this purpose they
bundle recently received transactions together with a reference to
the block at the tip of the longest chain in their local block tree and
use brute force search to determine a nonce such that the resulting
block is valid (i.e., the hash inequality is satisfied). Newfound valid
blocks are broadcast to other nodes, completing the process. Each
node outputs as ledger the transactions as ordered in the prefix of
the block that is ùëò-deep in the longest chain of its local block tree.
Besides being remarkably simple, Nakamoto‚Äôs LC consensus pro-
tocol has two outstanding properties. First, it enables consensus in
a permissionless setting by using proof-of-work (PoW) puzzles as a
Sybil resistance mechanism [21, 33]. The bottleneck to block pro-
duction is finding nonces which lead to valid blocks which satisfy
the hash inequality, and as long as the majority of hash power at
every point in time is controlled by honest nodes, honest nodes
output a secure ledger [25, 44]. Second, the LC can tolerate dynamic
participation in the sense that the ledger remains secure even as
the total hash power participating in the protocol as well as its
distribution among participants varies over time.

Proof-of-Stake Longest Chain. A drawback of Nakamoto‚Äôs PoW
LC is the high electricity consumption and as a result a tendency for
centralization of nodes at places of relatively low electricity cost. To
overcome the drawbacks of PoW LC while retaining its advantages,
protocols such as Ouroboros [4, 17, 35] and Sleepy Consensus [16,
45] preserve the operating principle of the LC but replace PoW
with proof-of-stake (PoS) lotteries, where a party is assigned random
block production opportunities in proportion to the amount of stake
it holds in the system, effectively substituting ‚Äòone CPU, one vote‚Äô
by ‚Äòone coin, one vote‚Äô. For this purpose, nodes use synchronized
clocks to count time slots of a predetermined duration. For every
time slot, nodes evaluate a block production lottery associated
with their cryptographic identity. For instance in [4, 17], nodes get
to produce a new valid block if the output of a verifiable random
function (VRF) is below a threshold proportional to the node‚Äôs stake.

Proof-of-Stake Longest Chain Under Bandwidth Constraint. While
PoS LC behaves in some aspects similar to PoW LC, it differs drasti-
cally in others. For instance, in PoS, block production opportunities
can be ‚Äòreused‚Äô in the sense that when a node is eligible to produce
a block in a certain time slot, it can in fact create many equivocating
but equally valid blocks for the same time slot, each potentially
with a different set of transactions and/or attached to a different

 
 
 
 
 
 
]
s
[
y
a
l
e
d
k
c
o
l
b
t
s
r
o
W

15

10

5

0

1

2

3

4

5

6

Blocks in slot

Figure 1: Time taken (10-th percentile, mean, 90-th per-
centile) for all nodes to download all blocks mined in a
slot, when different number of new blocks are produced
and broadcast in a slot. The delay increases as the number
of blocks is increased, showing that network delay is not
independent of network load. We use Cardano‚Äôs Ouroboros
implementation. Details of the experimental setup are given
in Appendix B.1.

parent block. This problem arises because block production ‚Äòlottery
tickets‚Äô in PoS can not depend on the proposed block‚Äôs transactions.
Otherwise an adversary could increase its chances to produce a
block by trying various sets of transactions (grinding). Similarly,
the PoS lotteries can not depend on the parent block, as the adver-
sary could extend several chains at once to increase their chance
of block production (nothing-at-stake attack [5]). In PoW however,
each block production opportunity corresponds to a unique block
(a combination of transaction set, parent block, and nonce), thus
the rate of block production opportunities simultaneously bounds
the rate at which new valid blocks can be created.

Previous analysis [17, 20, 45] shows that this difference is im-
material in the synchronous network model where the message
propagation delay between honest nodes is controlled by the ad-
versary, but below a known upper bound Œî. Under such a network
model, PoS LC and PoW LC behave the same in terms of secu-
rity, transaction throughput and confirmation latency. This model,
however, is over-idealized in that it assumes a fixed delay upper
bound for every single message, even when many messages are
transmitted simultaneously (which may be under normal execution
or due to adversarial actions). The model does not capture notions
of capacity and congestion which have a significant impact on the
behavior of real networks. In fact, an increase in network delay
with increasing network load (via increased block size) has been
demonstrated previously for Bitcoin [19]. Similarly, increasing the
network load (via increasing the number of blocks per slot) leads to
increased network delay in our experiments (see Figure 1) with Car-
dano‚Äôs Ouroboros implementation‚Äîa PoS protocol. Once we enrich
the network model to capture such phenomena, the difference in
the behavior of PoW LC and PoS LC with respect to reuse of block
production opportunities strikes. The possibility of producing (infin-
itely) many equivocating valid blocks per block production oppor-
tunity opens up new adversarial strategies in which the adversary
aims to exhaust limited network resources with useless spam in an
attempt to disturb consensus. This protrudes in another experiment
(see Figure 2) where nodes run PoS LC with our implementation of
Cardano‚Äôs block download logic as per [30]. Adversarial spamming
(through block equivocations) causes significant network traffic at

2

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

n
i
a
h
c
t
s
e
n
o
H

]
1
‚àí
s
[
e
t
a
r
h
t
w
o
r
g

0.04

0.02

0

No attack

Attack, Longest Attack, Freshest

Figure 2: The honest chain growth rate in three scenarios:
without spamming attack; under attack while downloading
the longest header chain first (priority rule in Cardano‚Äôs
block download logic); under attack while downloading the
freshest block first (introduced in this work). Details of the
experimental setup are given in Section 5.2. For a trace of the
chain growth in the same experiment, see Figure 5.

the victim nodes, leaving insufficient bandwidth for the victims to
download honest blocks. As a result, block production on the honest
chain stalls, and the victim node can be easily fooled by a longer
chain from the adversary, potentially resulting in a safety violation.

Modelling Bandwidth Constraints. We model a bandwidth con-
strained network as follows. Recall that blocks in Nakamoto con-
sensus consist of a list of transactions as block content, and the
information pertaining to the PoS/PoW lottery and the block tree
structure (reference to parent block) as block header. Since a block‚Äôs
header is small compared to its content, we assume that block head-
ers propagate with a known delay upper bound Œîh between honest
nodes. At any point after obtaining a block header, a node can
request the corresponding block content from the network. Since
a block‚Äôs content is large, every honest node can only download
a limited number of blocks‚Äô contents per time slot. This model is
inspired by the peer-to-peer network designs used for blockchain
protocols. For instance, in the Cardano network [14, 15], each node
advertises its block header chain to its peers, which in turn decide
based on the block headers which block contents to fetch. Without
a carefully designed download rule for the protocol to determine
which blocks honest nodes should spend their scarce bandwidth
on, we will see that consensus cannot be achieved with PoS LC.

The ‚ÄòDownload Along The Longest Header Chain‚Äô Rule. Given that
in LC, honest nodes extend the longest chain, a natural download
rule is ‚Äòdownload along the longest header chain‚Äô, i.e., based on the
block tree structure obtained from block headers, a node identifies
the longest (header) chain, and prioritizes downloading the blocks
along that chain. Indeed, Bitcoin does exactly that [1]. Cardano‚Äôs
Ouroboros implementation also follows this paradigm in broad
strokes [14, 15, 18] for chain selection [32] and block downloads
[31]. As long as the block production rate is low relative to the
download bandwidth, this (and other rules that ensure that nodes
download a block at most once) work well for PoW LC, simply
because the number of distinct blocks is limited by the number of
block production opportunities.

Unfortunately, as illustrated in Figure 3, this download rule fails
for PoS LC in that the resulting protocol is not secure, even if the
block production rate is low and the adversary controls a small
minority of the stake. The reason is that the adversary can use

Longest Chain Consensus Under Bandwidth Constraint

Time slots

ùë°0

ùë°

ùë° ‚Ä≤

ùë°1

ùë°2

ùëè (1)
‚úò
ùëè (2)
‚úò
.
.
.

ùêµ (1)

ùêµ (2)

.
.
.

ùëè0

Adversarial equivocations luring
honest nodes away from down-
loading honest blocks (‚úò: blocks
with invalid content)

ùëè1

Last valid block
downloaded by
all honest nodes

Honest blocks are
never downloaded
because of shorter
header chain

ùëè2

.
.
.

Figure 3: In PoS LC with ‚Äòdownload along the longest header
chain‚Äô rule, an adversary can stall consensus indefinitely
if it has two consecutive block production opportunities
ùë° < ùë° ‚Ä≤ at which it creates infinitely many equivocating chains
ùëè0 ‚Üê ùëè (ùëñ) ‚Üê ùêµ (ùëñ) where ùëè (ùëñ) have invalid content. The blocks
of later honest block production opportunities ... > ùë°2 > ùë°1 >
ùë° ‚Ä≤ > ùë° are never downloaded by other honest nodes, because
they prioritize the longer adversarial header chains, wasting
their bandwidth downloading each ùëè (ùëñ) only to discard it
immediately thereafter because of invalid content.

consecutive adversarial block production opportunities (at ùë° and
ùë° ‚Ä≤ in Figure 3) to produce infinitely many equivocating chains
(ùëè0 ‚Üê ùëè (ùëñ) ‚Üê ùêµ (ùëñ) in Figure 3). To avoid honest nodes building
on these equivocating chains, the adversary fills ùëè (ùëñ) with invalid
content, which honest nodes can only detect after they have already
wasted their scarce bandwidth to download it. As a result, honest
nodes produce blocks off ùëè0 in their block production opportunities
(ùëè1, ùëè2, ... at ùë°1 < ùë°2 < ... in Figure 3), but these are never down-
loaded by other honest nodes because the adversarial header chains
are longer and thus of higher download priority. This is clearly an
attack on liveness but it also implies an attack on safety because the
adversary could now build a chain longer than the honest parties
(who are stalled) even though the adversary owns very little stake.
The impact of this attack is seen in our experiments with a PoS LC
node implementing this download rule (Figure 2).

The above attack suggests that securing PoS LC under bandwidth
constraints requires a carefully designed download rule. In practice,
protocols follow various heuristics to attempt to mitigate spam-
ming/equivocation attacks. However, a rigorous analysis is usually
missing. Our goal in this work is to identify simple download rules
that can be proven secure in the bandwidth constrained model.

In the attack in Figure 3, we observe that even though new honest
blocks are being proposed, the download rule prioritizes older adver-
sarial equivocating blocks. If honest nodes downloaded the ‚Äòfresher‚Äô
blocks proposed in more recent time slots ùë°1, ùë°2, ... instead, then
this attack would not succeed. This intuition extends beyond the
specific attack of Figure 3. We would like that whenever an honest
node proposes a block, other honest nodes download that block and
its prefix ‚Äòsoon‚Äô. This way, honest nodes have a chance to produce
blocks extending it, and to align their block production efforts to-
ward a particular chain. This is arguably the key to LC security and

3

central to prior security analysis [20, 45] on which we build. This
insight naturally motivates the following simple download rule.

The ‚ÄòDownload Towards The Freshest Block‚Äô Rule. We propose a
simple download rule for PoS LC, ‚Äòdownload towards the freshest
block‚Äô, i.e., in every time slot an honest node identifies the block
proposed in the most recent time slot based on the header infor-
mation, and downloads any missing blocks in its prefix, including
that freshest block. Thus, when an honest node proposes a block,
within the same time slot, other honest nodes prioritize download-
ing that block and its prefix. The length of the prefix cannot be too
long since valid chains cannot contain equivocations. By making
the time slot long enough to allow downloading the whole prefix,
this rule directly satisfies our desired property that honest nodes
download honestly proposed blocks ‚Äòsoon‚Äô (within the same time
slot). This property is the key step in prior security analysis, thus
allowing us to use prior techniques to prove the security of PoS LC
with this download rule. In particular, this download rule avoids the
attack of Figure 3 and the honest chain‚Äôs growth rate remains unaf-
fected by this spamming attack (Figure 2). Importantly, note that the
freshest block rule is only a download priority rule. Honest nodes
still propose blocks extending their longest valid downloaded chain.

Other Download Rules. More generally, we identify other down-
load rules with the property that whenever an honest block is pro-
posed, all honest nodes download that block and its prefix ‚Äòsoon‚Äô.
Thus, we develop a unified framework to prove security of PoS LC
with any download rule with this property. We consider the fol-
lowing two commonly proposed heuristics against equivocations,
formalize them and give a rigorous proof of security.
(1) ‚ÄòEquivocation avoidance‚Äô: We modify ‚Äòdownload along the longest
header chain‚Äô such that an honest node refrains from download-
ing a chain whose tip is an equivocating block header (i.e., it has
seen another block header from the same slot and validator). A
rule of this kind can be seen used in PoS Ethereum [2].

(2) ‚ÄòBlocklisting‚Äô: An honest node avoids downloading any chain
whose tip is proposed by a validator that has equivocated be-
fore (in its view of block headers). Note that this notion of
blocklisting only affects the download priority rule. It does not
invalidate a block, as doing so independently at each node risks
introducing split views, and doing so consistently would require
consensus in the first place.

Due to the simplicity and efficiency of the ‚Äòdownload towards the
freshest block‚Äô rule, and because it directly satisfies the key prop-
erty that enables our security proofs, we use this rule as a running
example to illustrate our model and the analysis. We then extend
this analysis to the other two rules.

Our Contributions. By means of experiments and a concrete at-
tack strategy, we show that the bounded delay model fails to capture
network congestion and spamming attacks. We show that using
suitable download rules, we can provably secure PoS LC in net-
works with bandwidth constraint in which the adversary can (inter
alia) spam the network with equivocating blocks at an arbitrary
rate, withhold blocks, and release blocks with invalid content that
honest nodes discard after downloading. We identify a key property
of a download rule that enables it to secure PoS LC. We use this to
develop a unified framework to prove the security of PoS LC with

any download rule that satisfies this property. We propose a simple
rule ‚Äòdownload towards the freshest block‚Äô that satisfies this prop-
erty. We also formalize heuristics in the form of the ‚Äòequivocation
avoidance‚Äô and ‚Äòblocklisting‚Äô rules for which we provide a rigorous
security proof using our framework. We show that parallel composi-
tion of multiple instances of PoS LC with a secure download rule (in-
spired by [24]) yields a consensus protocol that achieves a constant
fraction of the network‚Äôs throughput limit even in the worst case.

Related Work. Network-level attacks on Bitcoin have been stud-
ied in [3, 11]. Eclipse attacks on peer-to-peer networks, where an
adversary uses several IP addresses to occupy all connections main-
tained by a victim node and thus cut said node off from the network,
have been studied in [28, 49‚Äì51] and in the context of Bitcoin in [12].
The authors of [13] show that if one can connect with consensus
validators that are pseudo-randomly chosen every few slots based
on their stake, then one can secure PoS LC against Sybil attacks and
eclipse attacks on the network layer. These earlier works share their
focus on network topology, an important aspect not captured by the
bounded delay network model. Our work instead focuses on band-
width constraints, an orthogonal feature of real networks not cap-
tured by the bounded delay model. However, our works share the
philosophy of co-designing consensus and network layer protocols.
The impact of spamming was seen recently in the temporary
shutdown of a PoS protocol Solana [53] on multiple occasions in
2021-2022 [39, 40, 46]. These shutdowns were reportedly due to an
increase in the transaction load in the network, and the ‚Äúlack of
prioritization of network-critical messaging caused the network to
start forking‚Äù [39]. These incidents indicate that messages that are
critical for consensus among honest nodes (e.g., blocks) must be
appropriately prioritized during periods of congestion. Consensus-
critical blocks are easily prioritized at the network level over less
critical transaction requests, as the two are different kinds. Thus,
this work focuses instead on the design of a download rule with
which the consensus protocol assists the network in prioritizing
consensus-critical blocks over similarly looking spam blocks.

In practice, implementations show awareness of and attempt
to mitigate equivocation-based spamming attacks using various
heuristics. However, their efficacy and side effects are often not fully
understood. For instance, Cardano‚Äôs Ouroboros implementation
disconnects from peers once they propagate invalid or equivocating
blocks [14, 15, 18]. However, an adversary can boost the impact of
its attack by creating more Sybil network peers (recall that there
is no relation between consensus validators and peers in the un-
derlying communication network), so that disconnected peers are
likely replaced by new adversarial peers, ready to waste more of
the honest node‚Äôs resources [49‚Äì51].

Slashing is routinely proposed as a solution to mitigate spam-
ming with equivocations, as such attacks can be attributed to spe-
cific validators [7, 8, 43, 48]. Typical crypto-economic guarantees
are of the form ‚Äúif human intervention is needed to recover from
a safety attack, then 33% of stake is slashable‚Äú [9, 43, 48]. However,
the attack in Figure 3 only requires two consecutive block produc-
tion opportunities, which can be obtained by an adversary with
a very small fraction of stake. Hence in this case, slashing would
impose a very small penalty for an attack that violates security
and potentially incurs large costs due to human intervention and

4

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

other losses. Instead, we take the approach of preventing attacks
in the first place by using download rules that are proven secure.
Once security is proven, slashing can be employed as an additional
measure to disincentivize equivocation-based spamming.

The need for careful modelling of bandwidth constraints in the
context of high throughput protocols was identified in [6, 24]. Ear-
lier works [6, 19, 52] note that the network delay increases with the
message size (i.e., block size in this case). In this model, it is assumed
that as long as the network load is less than the bandwidth, every
message is downloaded within a given delay bound which depends
on the message size but is independent of total network load.

In the PoS context, [24] captures congestion due to increased
network load by modelling the inbox of each node as a queue. Each
message undergoes a propagation delay before being added to the
recipient‚Äôs inbox queue. The recipient can retrieve messages from
their queue at a rate limited by their bandwidth, resulting in a queu-
ing delay. However, the security result [24, Theorem 1] still assumes
a bounded (propagation+queuing) delay. This assumption is only
shown to hold under honest executions when the adversary does
not corrupt any nodes and does not send or delay any messages
[24, Theorem 3], and therefore the security claim does not hold for
all adversarial strategies. In particular, this excludes adversaries
that can spam the network using equivocating blocks and cause
attacks such as in Figure 3. The model we use is a variant of that
in [24] with the difference that nodes can inspect a small segment
(block header) at the beginning of every message in their queue and
decide based on that which message (block content) to prioritize for
download (subject to the bandwidth constraint). This modification
allows us to prove security against a general adversary, even with
unbounded equivocations.

Although our work is the first to prove PoS LC secure under band-
width constraints, our analysis builds on tools from several years
of security analysis for LC protocols [5, 17, 20, 25, 27, 44, 45, 47],
particularly the concept of pivots [45] (cf. Nakamoto blocks [20]).

Outline. We state the PoS LC protocol augmented with a down-
load rule and introduce our formal model for bandwidth constrained
networks in Section 2. In Section 3, we provide a high-level descrip-
tion of our unified framework for proving security of PoS LC with
different download rules under bandwidth constraints. In Section 4,
we show the key steps towards this unified proof, and analyze
the ‚Äòdownload towards the freshest block‚Äô rule. We present exper-
imental evidence for the robustness and superior performance of
the ‚Äòfreshest block‚Äô rule in Section 5. We formalize and analyze the
‚Äòequivocation avoidance‚Äô and ‚Äòblocklisting‚Äô rules in Section 6. Finally,
we sketch in Section 7 how to use PoS LC with a suitable download
rule as a building block to obtain a consensus protocol with a con-
stant fraction of the network‚Äôs throughput limit in the worst case.

2 PROTOCOL AND MODEL

Model Main Features. For ease of exposition, we assume a static
set of ùëÅ active nodes, each with a cryptographic identity corre-
sponding to one unit of stake. Our analysis can be extended to
the setting of heterogeneous and dynamic stake using tools from
[16, 17]. Nodes‚Äô cryptographic identities are common knowledge.
We are interested in the large system regime ùëÅ ‚Üí ‚àû. A static
adversary A chooses a set of nodes (up to a fraction ùõΩ of all nodes,

Longest Chain Consensus Under Bandwidth Constraint

Algorithm 1 Idealized PoS LC consensus protocol Œ†ùúå,ùúè,ùëáconf with
a download rule (helper functions: Appendix A.1, F
:
Algorithm 3, Z: Appendix A.2)

ùúå
headertree

1: on init(genesisHeaderChain, genesisTxs)
2:

‚ä≤ Initialize header tree hT, longest downloaded chain dC, and

mapping from block headers to contents (lists of transactions) blkTxs
hT, dC ‚Üê {genesisHeaderChain}, genesisHeaderChain
blkTxs[dC ] ‚Üê genesisTxs ‚ä≤ Unset entries of blkTxs are unknown
‚ä≤ Called by Z or A
.verify( C) ‚ä≤ Validate header chain (Algorithm 3)
assert F
hT ‚Üê hT ‚à™ prefixChainsOf ( C) ‚ä≤ Add C and its prefixes to hT
Z.broadcastHeaderChain( C)

3:
4:
5: on receivedHeaderChain( C)
ùúå
6:
headertree
7:
8:
9: on receivedContent( C, txs)
10:

‚ä≤ Called by Z or A
‚ä≤ Defer processing the content until we received the corresponding

header chain ùê∂, and its prefixes‚Äô contents are downloaded and valid

defer until C ‚àà hT
defer until ‚àÄC‚Ä≤ ‚â∫ C : blkTxs[ C‚Ä≤] ‚àâ {unknown, invalid}
assert C.txsHash = Hash(txs)
if txsAreSemanticallyValidWrtPrefixesOf ( C, txs)

blkTxs[ C ] ‚Üê txs
Z.uploadContent( C, txs)

else

blkTxs[ C ] ‚Üê invalid

11:
12:
13:
14:
15:
16:
17:
18:

‚ä≤ Update the longest downloaded chain among downloaded valid chains
19:
T‚Ä≤ ‚Üê hT \ { C‚Ä≤ ‚àà hT | blkTxs[ C‚Ä≤] ‚àà {unknown, invalid} }
20:
21:
dC ‚Üê arg maxC‚ààT‚Ä≤ | C |
22: on scheduleContentDownload()
23:
24:
25:

‚ä≤ Pick next block to download according to download rule (cf. Algs. 2, 4)
if C ‚â† ‚ä• with C ‚Üê downloadRule(hT, blkTxs)

Z.reqestContent( C)

‚ä≤ receivedContent will be triggered by Z on successful download
‚ä≤ PoS LC protocol main loop

26:
27: for time slots ùë° ‚Üê 1, ...,ùëáh of duration ùúè
28:
29:
30:
31:
32:

ùúå
headertree
Z.uploadContent( C‚Ä≤, txs)
Z.broadcastHeaderChain( C‚Ä≤)

txs ‚Üê Z.receivePendingTxsSemanticallyValidWrt(dC)
‚ä≤ Produce and disseminate a new block if eligible, see Alg. 3
if C‚Ä≤ ‚â† ‚ä• with C‚Ä≤ ‚Üê F

.extend(ùë°, dC, txs)

33:
34:
35:

36:

‚ä≤ Download block contents (starting after Œîh time into the slot)
while end of current time slot ùë° not reached

scheduleContentDownload()

Z.outputLedger(dC ‚åàùëáconf )

‚ä≤ Ledger of node ùëñ at time ùë° : LOGùë°
ùëñ

where ùõΩ is common knowledge) to corrupt before the randomness
of the protocol is drawn and the execution commences. Uncor-
rupted honest nodes follow the protocol as specified at all times,
corrupted adversarial nodes deviate from the protocol in an arbi-
trary Byzantine manner coordinated by the adversary in an attempt
to inhibit consensus. For simplicity, we have assumed that all nodes
are always awake. Our analysis builds on techniques from [45] and
the refined machinery therein can be used to extend our analysis
to the setting of asleep/awake honest nodes.

Protocol Main Features. Pseudocode of an idealized PoS LC Na-
kamoto consensus protocol parameterized by a download rule is
provided in Algorithm 1 (cf. [45, Figure 3]). The ‚Äòdownload towards
the freshest block‚Äô rule is given in Algorithm 2. Implementation
details of the block production lottery and the handling of the

Algorithm 2 ‚ÄòFreshest block‚Äô download rule

1: function downloadFreshestBlock(hT, blkTxs)
‚ä≤ Ignore chains with invalid content in any block
2:
T ‚Üê { C ‚àà hT | ‚àÄC‚Ä≤ ‚™Ø C : blkTxs[ C‚Ä≤] ‚â† invalid}
3:
‚ä≤ Find the chain ending in the freshest block (i.e., from most recent slot)
4:
C ‚Üê arg maxC‚Ä≤‚ààT C‚Ä≤.time
5:
‚ä≤ Find the first not downloaded block on that chain (if non-existent: ‚ä•)
6:
C ‚Üê arg minC‚Ä≤‚™ØC : blkTxs[C‚Ä≤ ]=unknown | C‚Ä≤ |
7:
return C
8:

Algorithm 3 Idealized functionality F
lottery and header block chain structure (cf. Appendix A.1)

: block production

ùúå
headertree

ùëÅ ‚Üê numNodes
T ‚Üê {genesisHeaderChain}

1: on init(genesisHeaderChain, numNodes)
2:
3:
4: on isLeader(ùëÉ, ùë° ) from A (only for adversarial ùëÉ ) or F
5:

‚ä≤ Abstraction of proof-of-stake lottery: each node is chosen leader in

‚ä≤ Global set of valid header chains

ùúå
headertree

each slot with probability ùúå/ùëÅ independent of other nodes and slots

6:

7:

if lottery [ùëÉ, ùë° ] = ‚ä•
$
‚Üê (true with probability ùúå/ùëÅ , else false)
lottery [ùëÉ, ùë° ]
return lottery [ùëÉ, ùë° ]

8:
9: on extend(ùë° ‚Ä≤, C, txs) from node ùëÉ (possibly adversarial) at time slot ùë°
‚ä≤ New header chain is valid if parent chain C is valid, ùëÉ is leader for
10:

slot ùë° ‚Ä≤, and ùë° ‚Ä≤ is later than the tip of C and is not in the future
if ( C ‚àà T) ‚àß isLeader(ùëÉ, ùë° ‚Ä≤) ‚àß ( C.time < ùë° ‚Ä≤ ‚â§ ùë° )

‚ä≤ Produce a new block header extending C
C‚Ä≤ ‚Üê C ‚à• newBlock(time : ùë° ‚Ä≤, node : ùëÉ, txsHash : Hash(txs))
T ‚Üê T ‚à™ { C‚Ä≤ }
return C‚Ä≤

‚ä≤ Register new header chain in header tree

11:
12:
13:
14:
15:
return ‚ä•
16:
17: on verify( C)
18:

return C ‚àà T ‚ä≤ Header chain is valid if previously added to header tree

ùúå
headertree

ùúå
headertree

blockchain data structure are abstracted away in the idealized func-
tionality F
provided in Algorithm 3 (cf. [45, Figure 2]).
An index of the helper functions used in the pseudocode is provided
in Appendix A.1. With specific implementations of F
, a
variety of PoS LC protocols can be modelled such as protocols from
the Ouroboros family [4, 17, 35] and the Sleepy Consensus [16, 45]
family. A more formal description of the environment Z (idealized
functionality modeling the network) is given in Appendix A.1. In the
main loop of the PoS LC protocol (Algorithm 1, lines 27ff.) the node
attempts in every time slot (which is of duration ùúè) to produce a new
block containing transactions txs and to extend the longest down-
loaded chain (denoted dC) in the node‚Äôs local view. If successful,
the block content txs and the resulting new block header chain C‚Ä≤
are provided to the environment Z for dissemination to all nodes.

Dissemination of Block Headers and Contents. The network model
and dissemination of headers and contents is illustrated in Figure 4.
Block header chains broadcast via Z.broadcastHeaderChain are
delivered by the environment Z to every node with a delay deter-
mined by A, up to a delay upper bound Œîh that is common knowl-
edge. Once an honest node receives a new valid header chain (Algo-
rithm 1, lines 5ff.), the node adds it to its local header tree hT . Block
content uploaded via Z.uploadContent is kept by Z in an ideal-
ized repository. In every time slot, honest nodes use a download rule

5

Header
Broadcasting

Participants

Content
Repository

Delay ‚â§ Œîh

2

txs2

1

txs2

Req. C2

5

4
txs2 Req. C2

Bandwidth

txs2

txs2

3

Header Content

C1
C2
.
.
.

txs1
txs2
.
.
.

Figure 4: In our model, block headers are propagated with a
known delay upper bound Œîh, while block content is subject
to a bandwidth constraint. 1 An honest node produces a
new valid block, consisting of header and content. 2 Block
headers are broadcast (Z.broadcastHeaderChain) and
arrive at honest nodes (Œ†ùúå,ùúè,ùëáconf .receivedHeaderChain)
within at most Œîh delay. 3 Block content is submitted to
an idealized ‚Äòrepository‚Äô (Z.uploadContent). A hash of
the corresponding block content is included in the block
header.
4 Upon request (Z.reqestContent), the con-
tent of a certain block is obtained from the ‚Äòrepository‚Äô
(Œ†ùúå,ùúè,ùëáconf .receivedContent), subject to a constraint on the
rate of downloaded block contents. 5 An adversary can push
block headers and block content to honest nodes indepen-
dent of delay and bandwidth constraints. See Appendix A.2
for details on Z.

to select block headers for which they wish to request the content
(Algorithm 1, line 22). Honest nodes can request the content for a
particular header via Z.reqestContent. If available, the content
requested from the repository will be delivered by Z to the honest
node by triggering the callback receivedContent (Algorithm 1,
lines 9ff.). We set the slot duration as ùúè = Œîh + ùêæ
ùê∂ such that all honest
nodes receive block headers proposed at the start of the current slot,
and thereafter Z delivers at most ùêæ block contents requested from
the repository to each honest node per time slot, thereby constrain-
ing the bandwidth to ùê∂ blocks per second.1 Upon verifying that the
content matches the hash in the block header and that the txs are
valid with respect to the ledger determined by the block‚Äôs prefix,
the node adds txs to its local view. Otherwise, the block is marked
as invalid, to prevent downloading it or any of its descendants in
the future. Finally, the node updates its longest downloaded chain.

‚ÄòDownload Towards The Freshest Block‚Äô Rule. Motivated by the
earlier arguments in Section 1, we introduce the ‚Äòdownload towards
the freshest block‚Äô download rule (Algorithm 2). In this download
rule, first the header tree hT is pruned by invalid blocks and their
descendants. Then, the first unknown block in the prefix of the
freshest block is requested. Ties are broken by the adversary.

Adversarial Strategies And Powers. Adversarial strategies and
powers include but are not limited to: reusing block production

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

ùúå
headertree

opportunities to produce multiple blocks (equivocations, by calling
.extend multiple times, each with a different txs or a
F
different parent chain C); extending any chain using past block
production opportunities as long as the purported block production
time slots along any chain are strictly increasing; releasing block
headers late or selectively to honest nodes; proactively pushing
block headers or block content to honest nodes irrespective of de-
lay or bandwidth constraints (by triggering the node‚Äôs respective
receivedHeaderChain or receivedContent callback); withhold-
ing the content of blocks; including invalid txs in blocks; breaking
ties in chain selection and the download rule.

Reality Check. Note that in practice the prioritization of blocks
according to some download rule does not have to take place only at
the endpoints of the network or be limited to block content. Rather,
it can also be applied to block headers and by intermediary nodes
of the underlying communication or peer-to-peer gossip overlay
network as they forward blocks. This effectively shifts the down-
load rule from the edge into the network. Honest participants focus
their resources on what the scheduling logic determines as ‚Äòhigh
importance‚Äô traffic, and save it from being drowned out by adversar-
ial spam. The result is that headers of the blocks which might be of
interest to an honest node based on the prioritization stipulated by
the download rule will be made available to that honest node by the
network within reasonable delay despite adversarial interference.
Because of this, we believe that our model leads to protocols that can
fare well under bandwidth constraints and spamming in practice.
in real-
world protocols, depending on the desired properties. The block
production lottery (Algorithm 3, line 7) is typically implemented
by checking whether the output of a random function is below a
certain threshold. Against static adversaries, a collision resistant
hash function suffices [45]; against adaptive adversaries, a verifiable
random function (VRF) is used [35]. Although the ideal functional-
ity F
relies on the knowledge of ùëÅ to tune the threshold
ùúå/ùëÅ , in PoS realizations such as in [17] the factor 1/ùëÅ is replaced
by the fraction of the total stake owned by the node as per the con-
firmed segment of the blockchain.2 The binding between a block
and the production opportunity it stems from (Algorithm 3, line 9)
is established using digital signatures.

Various constructions are used to realize F

ùúå
headertree

ùúå
headertree

The idealized repository maintained by Z is just a way to ab-
stract block dissemination in a peer-to-peer gossip network. In
reality, each node requests their peers for the block content (us-
ing information from the block header), and honest peers respond
with the content. Correspondingly, the idealized repository indexes
block content by the block header, and delivers it upon request, if
available. Note that block content associated with a particular block
header may be unavailable when requested by some honest node
at one point in time (e.g., if the adversary did not make it available),
but available when requested by another honest node at a later time
(e.g., if the adversary made it available in the meantime). Thus, the
block header does not ensure data availability or consistency among
honest nodes‚Äô download attempts, unlike in stronger primitives
such as verifiable information dispersal [10, 29, 42, 54]. By modelling
the network as an idealized repository, we abstract out details such

1Unlike [24], we do not model the upload bandwidth because honest nodes only send
very few messages in our protocol.

2In our simplified model, each node owns one unit of stake, which is the same as 1/ùëÅ
fraction of the total stake where ùëÅ is the number of nodes.

6

Longest Chain Consensus Under Bandwidth Constraint

as the network topology and data availability that are orthogonal
to the issue being considered here: the bandwidth constraint.

3 HIGH LEVEL SECURITY ARGUMENT
Our proofs follow the techniques of [45] and [20]. The key differ-
ence between these techniques and our proof is that the former
assume that the block propagation delay is always bounded by a
constant Œî. In our case, we first prove that under ‚Äòsuitable‚Äô down-
load rules and protocol parameters, with overwhelming probability,
a large fraction of honestly proposed blocks are downloaded by all
honest nodes within bounded delay.

To this effect, we consider uniquely successful time slots, in which
there is exactly one honest block proposal (any other slots with
block proposals are called adversarial). For a given download rule
and protocol execution, we define a property MaxDLùêæ (shorthand
for Maximum Download) by which under all adversarial strategies
and throughout the execution, the block proposed in a uniquely
successful slot is downloaded by all honest nodes within the first ùêæ
blocks downloaded since the beginning of that slot (Definition 2). If
the time slot is long enough to allow downloading ùêæ blocks, then the
block proposed in any uniquely successful slot will be downloaded
by all honest nodes before the end of the same time slot. Then, each
block proposed in a uniquely successful slot increases the minimum
length of all honest nodes‚Äô longest downloaded chains. (Lemma 1).
This is the key stepping stone of earlier security proofs of LC [20, 45].
We then employ techniques of [45] to prove that PoS LC with the
right parameters and a download rule such that MaxDLùêæ holds
with overwhelming probability is secure (Theorem 1). This gives a
general framework where in order to prove security of PoS LC with
a specific download rule, one only needs to show that the download
rule satisfies MaxDLùêæ with overwhelming probability.

The property MaxDLùêæ suggests a natural download rule. In a
uniquely successful slot, the block proposed in that slot can be
identified as the unique freshest block. Thus, downloading towards
the freshest block allows an honest node to download the block
proposed in that slot most straightforwardly. If the prefix of the
freshest block contains less than ùêæ blocks that have not been down-
loaded yet, then MaxDLùêæ will be satisfied. Thus, for a suitably
chosen ùêæ, the block proposed in a uniquely successful slot will be
downloaded within the same time slot with overwhelming prob-
ability (Lemmas 2, 3). In Section 6, we apply a similar analysis to
two other download rules, ‚Äòequivocation avoidance‚Äô and ‚Äòblocklist-
ing‚Äô, to show that they too satisfy MaxDLùêæ with overwhelming
probability for suitable ùêæ (Lemmas 4, 5).

In Corollary 1, we identify the parameter values under which the
protocol Œ†ùúå,ùúè,ùëáconf with the freshest block download rule is secure
for a given desired resilience ùõΩ (similarly for ‚Äòequivocation avoid-
ance‚Äô and ‚Äòblocklisting‚Äô in Corollary 2). For the rate of uniquely
successful slots to exceed the rate of adversarial slots, we require
that the rate of block production per slot, ùúå, be bounded as a func-
tion of ùõΩ, so that most slots with honest block proposals are also
uniquely successful slots. A similar constraint exists in the synchro-
nous model [17, 20, 45] where the product of the block production
rate and network delay Œî is bounded by a function of ùõΩ. Next, we
require that the per slot bandwidth ùêæ = Œ©(ùúÖ) (where ùúÖ is the se-
curity parameter) so that MaxDLùêæ is satisfied with overwhelming

probability. This implies that the time slot ùúè = Œîh + ùêæ
ùê∂ = Œ©(ùúÖ). This
is similar to [24] where under a bandwidth constrained model, the
probabilistic delay bound increases with the security parameter.
Finally, the confirmation time ùëáconf = Œ©(ùúÖ2) slots, similar to that
in the synchronous model [45].

4 SECURITY PROOF
4.1 Definitions
The PoS LC protocol Œ†ùúå,ùúè,ùëáconf has three parameters. The length of
each time slot is ùúè seconds, the average number of nodes eligible to
propose a block per time slot is ùúå, and the confirmation latency is
ùëáconf slots. The network has the following additional parameters.
Each honest node has a download bandwidth of ùê∂ block contents per
second (for convenience, we fix the size of the block content). Hence-
forth, we fix ùúè = Œîh + ùêæ
ùê∂ such that each honest node can download
the content of ùêæ blocks in one time slot after receiving the headers
proposed in that slot. The adversary controls ùõΩ fraction of the stake.
We denote by ùúÖ the security parameter. An event ùê∏ùúÖ will be said
to occur with overwhelming probability if Pr [ùê∏ùúÖ ] ‚â• 1 ‚àí negl(ùúÖ).
Here, a function ùëì (ùúÖ) is said to be negligible or negl(ùúÖ) if for all
ùëõ > 0, there exists ùúÖ‚àó
ùëõ such that for all ùúÖ > ùúÖ‚àó

ùëõ, ùëì (ùúÖ) < 1
ùúÖùëõ .

Define the random variables ùêªùë° and ùê¥ùë° for ùë° = 1, 2, ... to be the
number of honest and adversarial nodes eligible to propose a block
in slot ùë°, respectively. We consider the regime where the number
of nodes ùëÅ ‚Üí ‚àû and each of them holds an equal fraction of the
total stake. In this setting, by the Poisson approximation to a bi-
i.i.d.
nomial random variable, we have ùêªùë°
‚àº Poisson((1 ‚àí ùõΩ)ùúå) and
i.i.d.
‚àº Poisson(ùõΩùúå), all independent of each other. An execution
ùê¥ùë°
Eùúå,ùõΩ,ùëáh of time horizon ùëáh is defined as the sequence {ùêªùë° , ùê¥ùë° }ùë° ‚â§ùëáh
.
Denote by dCùëñ (ùë°) the longest fully downloaded chain of an hon-
est node ùëñ at the end of slot ùë°. Let |ùëè | denote the height of a block ùëè.
We will also use the same notation |C| to denote the length of a chain
C. Define ùêøùëñ (ùë°) = |dCùëñ (ùë°)| and ùêømin (ùë°) = minùëñ ùêøùëñ (ùë°). At the end of
each slot, honest node ùëñ outputs the ledger LOGùë°
ùëñ = dCùëñ (ùë°) ‚åàùëáconf ,
which consists of a list of transactions as ordered in all blocks in
dCùëñ (ùë°) with time slot up to ùë° ‚àí ùëáconf .

For a given execution of a consensus protocol, we define the

following two properties:

‚Ä¢ Safety: For all adversarial strategies, for all time slots ùë°, ùë° ‚Ä≤ and

honest nodes ùëñ, ùëó, LOGùë°

ùëñ ‚™Ø LOGùë° ‚Ä≤

ùëó or LOGùë° ‚Ä≤

ùëó ‚™Ø LOGùë°
ùëñ .

‚Ä¢ Liveness with parameter ùëálive: For all adversarial strategies, if a
transaction tx is received by all honest nodes before slot ùë°, then
for all honest nodes ùëñ and slots ùë° ‚Ä≤ ‚â• ùë° + ùëálive, tx ‚àà LOGùë° ‚Ä≤
ùëñ .

A consensus protocol is secure over a time horizon ùëáh with parame-
ter ùëálive if it satisfies safety and liveness with parameter ùëálive with
overwhelming probability over executions of time horizon ùëáh.

Definition 1. A slot ùë° is called successful if ùê¥ùë° + ùêªùë° > 0, uniquely
successful if ùê¥ùë° = 0 and ùêªùë° = 1, and adversarial if it is successful
but not uniquely successful. Define the predicates Unique(ùë°) as
true iff slot ùë° is uniquely successful and Adv(ùë°) as true iff slot ùë° is
adversarial.

For ùë† > ùëü , denote by B (ùëü, ùë†], U (ùëü, ùë†] and A (ùëü, ùë†], the number of
successful, uniquely successful, and adversarial slots in the interval

7

(ùëü, ùë†] respectively.

U (ùëü, ùë†] ‚âú

ùë†
‚àëÔ∏Å

ùë° =ùëü +1

1{Unique(ùë°)} , A (ùëü, ùë†] ‚âú

ùë†
‚àëÔ∏Å

ùë° =ùëü +1

1{Adv(ùë°)} (1)

and B (ùëü, ùë†] = U (ùëü, ùë†] +A (ùëü, ùë†]. When ùëü = ùë†, then (ùëü, ùë†] = ‚àÖ and thus
B (ùëü, ùë†] = U (ùëü, ùë†] = A (ùëü, ùë†] = 0. We define the following constants:
ùëù ‚âú Pr [ùê¥ùë° + ùêªùë° > 0] = 1 ‚àí ùëí‚àíùúå,
(2)
ùëùU ‚âú Pr [Unique(ùë°)] = (1 ‚àí ùõΩ)ùúåùëí‚àíùúå,
ùëùA ‚âú Pr [Adv(ùë°)]

(4)
Definition 2. For a given download rule D, execution Eùúå,ùõΩ,ùëáh and
ùëü < ùë† ‚â§ ùëáh, MaxDLùêæ,(ùëü,ùë† ] (Eùúå,ùõΩ,ùëáh, D) holds iff for all adversarial
strategies, for all uniquely successful slots in (ùëü, ùë†], the block pro-
posed in that slot is downloaded by all honest nodes within the
first ùêæ blocks downloaded in that slot.

= ùëù ‚àí ùëùU

(3)

We abbreviate MaxDLùêæ,(0,ùëáh ] (Eùúå,ùõΩ,ùëáh, D) as MaxDLùêæ (Eùúå,ùõΩ,ùëáh, D).

The inputs Eùúå,ùõΩ,ùëáh and D to predicates are omitted where obvious.

4.2 General Proof Overview
Lemma 1. Let a download rule D, an execution Eùúå,ùõΩ,ùëáh and ùë°0 <
ùë† ‚â§ ùëáh be such that MaxDLùêæ,(ùë°0,ùë† ] (Eùúå,ùõΩ,ùëáh, D) holds. Let ùë°1, ..., ùë°ùëö
be the uniquely successful slots in (ùë°0, ùë†]. Then,
(1) For all ùëó ‚â• 1, |ùëè ùëó | > |ùëè ùëó‚àí1|, where ùëè ùëó is the block proposed in ùë° ùëó .
(2) For all 0 ‚â§ ùëó ‚â§ ùëö and ùë° ùëó ‚â§ ùë° ‚â§ ùë†,

ùêømin (ùë°) ‚àí ùêømin (ùë° ùëó ) ‚â• U (cid:0)ùë° ùëó , ùë° (cid:3)

(5)

Proof. Part (1) is easily seen by the fact that honest nodes pro-
pose on their longest valid downloaded chain, ùëè ùëó‚àí1 is downloaded
before ùëè ùëó is proposed, and is valid because it was proposed by an
honest node. Now, fix a ùëó such that 0 ‚â§ ùëó ‚â§ ùëö. If ùëó = ùëö, then
U (ùë°ùëö, ùë°] = 0 and ùêømin (ùë°) ‚â• ùêømin (ùë°ùëö) for all ùë°ùëö ‚â§ ùë° ‚â§ ùë† because
ùêømin is non-decreasing. For ùëó < ùëö, since honest nodes propose
on their longest downloaded chain, |ùëè ùëó+1| ‚â• ùêømin (ùë° ùëó+1 ‚àí 1) + 1 ‚â•
ùêømin (ùë° ùëó ) + 1. From part (1) and that the blocks from uniquely suc-
cessful slots in (ùë° ùëó , ùë°] are downloaded before the end of their re-
spective slots, we conclude that ùêømin (ùë°) ‚â• |ùëè ùëó+1| + U (cid:0)ùë° ùëó , ùë° (cid:3) ‚àí 1 ‚â•
ùêømin (ùë° ùëó ) + U (cid:0)ùë° ùëó , ùë° (cid:3).
‚ñ°
Theorem 1. For all ùêæ ‚àà N and download rules D such that

(cid:104)

Pr

Eùúå,ùõΩ,ùëáh : ¬¨MaxDLùêæ (Eùúå,ùõΩ,ùëáh, D)

(cid:105)

‚â§ negl(ùúÖ),

(6)

if (1 ‚àí ùõΩ)ùúåùëí‚àíùúå = 1‚àíùëí‚àíùúå
ùê∂ and
ùëáconf = Œ© (cid:0)(ùúÖ + lnùëáh)2(cid:1), then the protocol Œ†ùúå,ùúè,ùëáconf with download
rule D is secure with ùëálive = Œ© (cid:0)(ùúÖ + lnùëáh)2(cid:1).

(1 + ùúñ1) for some ùúñ1 ‚àà (0, 1), ùúè = Œîh + ùêæ

2

Theorem 1 is proved in Appendix D.1 using techniques similar

to [45].

4.3 ‚ÄòDownload Towards the Freshest Block‚Äô Rule
Definition 3. For an execution Eùúå,ùõΩ,ùëáh , ShortPrefixesùêæ (Eùúå,ùõΩ,ùëáh )
holds iff

‚àÄùë° ‚â§ ùëáh :

max
ùëü <ùë° : Unique(ùëü )‚àß( A(ùëü,ùë° ] ‚â•U(ùëü,ùë° ])

A (ùëü, ùë°] < ùêæ .

(7)

Lemma 2. For an execution Eùúå,ùõΩ,ùëáh and the freshest block download
rule Dfresh (Algorithm 2),

ShortPrefixesùêæ (Eùúå,ùõΩ,ùëáh ) =‚áí MaxDLùêæ (Eùúå,ùõΩ,ùëáh, Dfresh)

(8)

8

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

Proof. Let ùë°1, ..., ùë°ùëö be the uniquely successful slots in (0,ùëáh].
Let ùëè ùëó be the block from ùë° ùëó for some 1 ‚â§ ùëó ‚â§ ùëö. The header of ùëè ùëó
is received by all honest nodes within Œîh time after the beginning
of slot ùë° ùëó . Due to the downloading rule, during slot ùë° ùëó all honest
nodes download the chain containing ùëè ùëó . Furthermore, since ùëè ùëó
is an honest block and honest nodes only propose on their down-
loaded chain, the prefix of ùëè ùëó can be downloaded (i.e., does not
contain invalid or missing blocks). Thus, we only need to show that
the prefix of ùëè ùëó contains at most ùêæ blocks whose contents have not
been downloaded.

For induction, assume that MaxDLùêæ,(0,ùë° ùëó ‚àí1] holds. Using this,
we will show that MaxDLùêæ,(0,ùë° ùëó +1‚àí1] holds. For the base case, this
is true for ùëó = 1 since ùë°1 is the first uniquely successful slot by
definition. Note that the block ùëè ùëó , being honest, is proposed on the
tip of dCùëñ (ùë° ùëó ‚àí 1) for some ùëñ. Let ùëü ùëó be the last unique time slot
such that the block ùëè ‚Ä≤
ùëó from that time slot is in dCùëñ (ùë° ùëó ‚àí 1). Clearly,
ùëü ùëó ‚â§ ùë° ùëó ‚àí 1. Then,

|dCùëñ (ùë° ùëó ‚àí 1)| ‚â§ |ùëè ‚Ä≤

ùëó | + A (cid:0)ùëü ùëó , ùë° ùëó ‚àí 1(cid:3)
(9)
ùëó are from adversarial slots by definition of ùëü ùëó .

since blocks after ùëè ‚Ä≤
From MaxDLùêæ,(0,ùë° ùëó ‚àí1] and part (1) of Lemma 1,
ùëó | + U (cid:0)ùëü ùëó , ùë° ùëó ‚àí 1(cid:3) .
|ùëè ùëó‚àí1| ‚â• |ùëè ‚Ä≤

(10)

Since ùëè ùëó‚àí1 is downloaded by the end of slot ùë° ùëó‚àí1 and ùë° ùëó ‚àí 1 ‚â• ùë° ùëó‚àí1,
|dCùëñ (ùë° ùëó ‚àí 1)| ‚â• |ùëè ùëó‚àí1|, and this would imply from (9) and (10) that
A (cid:0)ùëü ùëó , ùë° ùëó ‚àí 1(cid:3) ‚â• U (cid:0)ùëü ùëó , ùë° ùëó ‚àí 1(cid:3). Note that time slots of blocks in a
valid chain must be strictly increasing. Since ùëè ‚Ä≤
ùëó is already down-
loaded, the number of blocks in dCùëñ (ùë° ùëó ‚àí 1) whose content is not
downloaded is at most A (cid:0)ùëü ùëó , ùë° ùëó ‚àí 1(cid:3). Since ùëè ùëó extends dCùëñ (ùë° ùëó ‚àí 1),
the number of block contents to be downloaded including the pre-
fix of ùëè ùëó is at most A (cid:0)ùëü ùëó , ùë° ùëó ‚àí 1(cid:3) + 1. As per ShortPrefixesùêæ , this
is at most ùêæ (note that ùëü ùëó ‚â§ ùë° ùëó ‚àí 1). Therefore, ùëè ùëó is downloaded
within one slot. Since there are no more uniquely successful slots
in (ùë° ùëó , ùë° ùëó+1), this completes the induction step by showing that
MaxDLùêæ,(0,ùë° ùëó +1‚àí1] . For ùëó = ùëö, we would conclude with MaxDLùêæ
‚ñ°
as required.
Lemma 3. If (1 ‚àí ùõΩ)ùúåùëí‚àíùúå = 1‚àíùëí‚àíùúå
ùêæ = ùëùAùëá (1 + ùúñ2) for some ùúñ2 > 0 where ùëá =
Eùúå,ùõΩ,ùëáh : ¬¨ShortPrefixesùêæ (Eùúå,ùõΩ,ùëáh )

(1 + ùúñ1) for some ùúñ1 ‚àà (0, 1) and
Œ© (ùúÖ+lnùëáh)
ùõº2ùëù
‚â§ negl(ùúÖ),

, then

(11)

Pr

2

(cid:104)

(cid:105)

where ùõº2 = min

(cid:110) ùúñ 2
1
36

, ùúñ 2
2
ùúñ2+2

(cid:111).

ùëùA
ùëù

Corollary 1. The protocol Œ†ùúå,ùúè,ùëáconf with the freshest block down-
load rule and parameters ùúå such that (1 ‚àí ùõΩ)ùúåùëí‚àíùúå = 1‚àíùëí‚àíùúå
(1 + ùúñ1),
ùúè = Œ©(ùúÖ + lnùëáh), ùëáconf = Œ© (cid:0)(ùúÖ + lnùëáh)2(cid:1) is secure with ùëálive =
Œ© (cid:0)(ùúÖ + lnùëáh)2(cid:1).

2

Lemma 3 is proved in Appendix D.4 and Corollary 1 is obtained
ùê∂ and ùêæ as per Lemma 3.

by setting ùúè = Œîh + ùêæ

5 EXPERIMENTS
5.1 Implementation Details
We implemented our PoS LC node in 800 lines of Golang.3 For all
of our experiments, the slot duration ùúè is set to 1 second, and the

3The source code is available at: https://github.com/yangl1996/synclc-sim

Longest Chain Consensus Under Bandwidth Constraint

total block production rate is 0.06 blocks/s. There is no transaction
processing. Instead, nodes fill blocks with random bytes up to a
size limit (100 KB in our experiments).

Our implementation has a fully-featured network stack modelled
after Cardano‚Äôs node software [14, 15]. Similar to Cardano, block
propagation involves two subsystems: chain sync, and block fetch.
The chain sync subsystem allows a node to advertise the header
chain of the longest chain it has downloaded and validated, and to
track the header chains advertised by peers. Because the header only
takes a tiny fraction of space in a block, the bandwidth consumed
by the chain sync subsystem is negligible. In all of our experiments,
chain sync only consumed up to 1.2% of the available bandwidth.
The block fetch subsystem periodically examines the header
chains learned from peers through chain sync, and sends requests
to download block bodies according to a download rule. We im-
plement the two download rules discussed in Section 1: ‚Äòdownload
along the longest header chain‚Äô, and ‚Äòdownload towards the freshest
block‚Äô. Similar to Cardano, our block fetch logic limits the maximum
number of peers to concurrently download from, an important pa-
rameter which we call the in-flight cap. This ensures the limited
network bandwidth is never spread too thin across too many con-
current downloads. Finally, chain sync and block fetch share the
same TCP connection for each pair of peers. To avoid head-of-line
blocking, we multiplex the two subsystems so that chain sync is
never impaired by block fetch traffic.

To simulate bandwidth constraints, we build our testbed using
Mininet [37]. Each blockchain node runs in a Mininet virtual host
with its own network interface, and is connected to a central switch
through a link with limited bandwidth and artificial propagation de-
lay. Specifically, we limit the bandwidth of honest nodes to 20 Mbps,
and adversarial nodes to 1 Gbps. We set the round-trip time be-
tween any pair of nodes to 100 ms. The testbed runs on a worksta-
tion with two Intel Xeon E5-2623 v3 CPUs and 32 GB of RAM.

5.2 Demonstration of the Spamming Attack
In this experiment, we show that the widely-adopted ‚Äòdownload
along the longest chain‚Äô rule is vulnerable to adversarial spamming,
and the ‚Äòdownload towards the freshest block‚Äô rule mitigates this
attack. There are 20 honest nodes connected in a full mesh topology.
Honest nodes equally split 67% of the total stake, so each honest
node has a block production rate of 0.002 block/s. The adversary
controls 33% of the stake (0.02 block/s), and sets up 5 attacking
nodes. Each attacking node connects to all honest nodes. The ad-
versary uses the attacking nodes to monitor the longest chains
announced by honest nodes, and tries to mine equivocating spam
chains (cf. Figure 3). When successful, the adversary announces
them and hopes honest nodes download these spam chains.

Figure 5 shows the time series of honest chain growth over an
hour when the in-flight cap is set to 2. Note that honest chain
growth stalls after 400 seconds when nodes download the longest
chain. Since there are 5 attacking nodes, once the adversary gets a
longer chain by luck, each honest user will use all of its 2 in-flight
slots to download spam chains (from 2 of the 5 attacking nodes),
leaving no room for honest blocks. Before any honest node finishes
downloading a spam block, the adversary will have advertised an-
other equivocating chain, keeping the honest nodes busy. Although

h
t
g
n
e
l

n
i
a
h
c
l
a
c
o
L

150

100

50

0

0

Download freshest block
Attack on freshest block

Download longest chain
Attack on longest chain

500

1,000

1,500

2,000

2,500

3,000

3,500

Time [s]

Figure 5: Traces of honest chain growth under spamming
attack (cf. Figure 3) when using different download rules
and an in-flight cap of 2. Each curve represents one honest
node. Shaded areas represent time periods when nodes
are suffering from the attack and are downloading invalid
blocks. PoS LC downloading longest chain stalls. PoS LC
downloading freshest blocks is robust.

Download freshest block
Number of adversarial nodes

Download longest chain
Honest block production rate

n
i
a
h
c
t
s
e
n
o
H

]
1
‚àí
s
[
e
t
a
r
h
t
w
o
r
g

0.04

0.02

0

2

3

4

5

6

7

Max number of concurrent chain downloads (in-flight cap)

Figure 6: Honest chain growth rate under spamming attack
(cf. Figure 3) while allowing concurrent block downloads
from different number of peers. With in-flight cap below the
number of adversarial peers, PoS LC downloading longest
chain shows performance degradation; PoS LC downloading
freshest block is robust.

Freshest block, 10 attackers
Freshest chain, 5 attackers

Longest chain, 10 attackers
Longest chain, 5 attackers

s
k
c
o
l
b
f
o
n
o
i
t
c
a
r
F

1

0.5

0

0

2

4

6
Propagation delay [s]

8

10

12

Figure 7: Empirical cumulative density function of block
propagation delay under different download rules, facing
different number of attackers, and an infinite in-flight cap.

honest nodes can still mine blocks, they cannot download blocks
from each other, so each honest node effectively mines on its own
fork. The resulting heavy forking causes the honest chains to grow
slower than the adversary mining rate, and the adversary maintains
the lead in chain length and sustains this attack (red-shaded areas
in Figure 5) until the experiment ends.

9

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

In comparison, honest chain growth is unaffected when nodes
download towards the freshest block. Note that although the adver-
sary is still able to trick honest nodes into downloading spam blocks
(blue-shaded areas in Figure 5), the adversary cannot sustain the
attack: when a new honest block is produced, the chain containing
that fresh block will be prioritized. Before the adversary manages
to produce a fresher block, all honest nodes will have caught up on
the correct chain. Further experiments in Appendix B.2 show that
honest chain growth is unaffected with even larger block sizes.

]
s
p
b
M

[
c
ffi
a
r
t
d
a
o
l
n
w
o
D

20

15

10

5

0

Download freshest block
Attack on freshest block

Download longest chain
Attack on longest chain

0

100

200

300

400

500

Time [s]

5.3 Impact of the In-Flight Cap
We now extend the previous experiment by varying the in-flight
cap between 2 and 7, and demonstrate the relationship between
the in-flight cap and the number of attacking nodes. Figure 6 shows
the results. When the in-flight cap is equal to or smaller than the
number of attacking nodes, downloading the longest chain is not
secure. This may remind readers of the eclipse attack [12, 28, 49‚Äì
51]: the adversary is in fact eclipsing the honest nodes in the block
fetch subsystem by occupying all its in-flight slots. Meanwhile,
downloading the freshest chain is always secure regardless of the
in-flight cap, because a fresh honest block can break such eclipse.
Figure 6 seems to suggest that downloading the longest chain is
secure when the in-flight cap is larger than the number of attackers.
Is it true? Should we then increase the in-flight cap to infinity? We
point out that the in-flight cap ensures each in-flight download
gets a sufficiently large share of the available bandwidth to com-
plete in a reasonable amount of time. This is critical in ensuring
low propagation delay for honest blocks. As an extreme example,
assume that there are a large number of attacking nodes and an
infinite in-flight cap. Although a node will always start download-
ing an honest block as soon as it receives the announcement, the
bandwidth allocated to download this block will be extremely small
due to the competing downloads of adversarial blocks, effectively
halting the download. As a result, a finite in-flight cap is necessary,
and the attacker can always attack the ‚Äòdownload along the longest
chain‚Äô rule by outnumbering the in-flight cap.

To demonstrate this effect, we remove the in-flight cap, increase
the number of attacking nodes to 10, and measure the block propa-
gation time. The results in Figure 7 show that the propagation time
under both rules increases. This is because when the attack is active,
there are more competing flows downloading spam blocks, leaving
less bandwidth for honest blocks. Still, the chain growth rate is
unharmed when downloading the freshest chain, at 0.041 block/s.
This is because nodes can break away from the spam chain as soon
as a new honest block is produced, regardless how bad the prop-
agation time is under active spam. In comparison, the propagation
delay when downloading the longest chain becomes much worse.
In fact, the higher delay causes the chain growth rate to drop to
0.035 block/s. In conclusion, removing or increasing the in-flight
cap does not save the ‚Äòdownload along the longest chain‚Äô rule, but
impacts the block propagation delay of the ‚Äòdownload towards the
freshest block‚Äô rule only slightly so that security is unaffected.

5.4 Bandwidth Consumption
Besides block bodies, a blockchain node needs to receive other types
of traffic in real time, such as unconfirmed transactions, requests

10

Figure 8: Traces of download traffic over a 500-second period
at one of the victim nodes when using different download
rules and in-flight cap of 4. Shaded areas represent time
periods when the node is suffering from the attack and
downloading invalid blocks.

from clients, and remote control data. A practical download rule
must not consume all the available bandwidth at a node at all time.
As explained in Section 5.2, under the ‚Äòdownload towards the fresh-
est block‚Äô rule, an honest node breaks free from the spam chains
when an honest block is mined. That is, spamming stops when
there is a time slot with only one honest block proposed. Intuition
suggests that as long as the overall mining rate is not too high, such
event should happen frequently. Indeed, the ingress traffic traces
in Figure 8 show that periods of high network utilization only last
for tens of seconds when downloading the freshest block, quickly
succeeded by long windows of low utilization. In comparison, when
downloading the longest chain, the period of high utilization lasts
until the end of the experiment, leaving no room for honest blocks
or other traffic.

6 OTHER DOWNLOAD RULES
6.1 Equivocation Avoidance
We formalize a common heuristic to deal with equivocations, namely
downloading only one out of many equivocations in Algorithm 4.
In every time slot when a node wishes to download blocks, it filters
the tree consisting of block headers it has received by retaining
only one leaf in the tree for each block production opportunity
(determined by the proposing node and the time slot of each block).
We strengthen the adversary by allowing it to decide, per honest
node and time slot, which among multiple equivocating headers
would be retained. After removing equivocations, invalid chains,
and chains that are already downloaded from the header tree, the
node selects the longest header chain, and downloads the content
for the first missing block in this chain.

Here, we have illustrated equivocation avoidance as a modifica-
tion to the longest header chain download rule. By doing so, we
show that while the longest header chain download rule was in-
secure by itself, it can be made secure by ‚Äòavoiding equivocations‚Äô.
However, equivocation avoidance could also be added to the fresh-
est block rule to make it more efficient. Our analysis below suggests
that the freshest block rule by itself is already more efficient than
the longest header chain rule with equivocation avoidance because
the latter requires downloading a much larger number of blocks
within one time slot (see Corollaries 1, 2), leading to longer time
slots and poorer bandwidth utilization.

Longest Chain Consensus Under Bandwidth Constraint

Algorithm 4 ‚ÄòEquivocation avoidance‚Äô download rule; replaces
downloadRule in Algorithm 1 (cf. Appendix A.1)

Œ© ( 1
ùúÖ )

Œ© ( 1
ùúÖ )

1: on Œîh time into each time slot ùë°
2:

‚ä≤ Before beginning block content downloads for time slot ùë° , filter current
header tree to keep at most one leaf per block production opportunity, i.e.,
per (node, time) pair (equivocation avoidance; ties broken adversarially)
hT‚àó ‚Üê oneLeafPerProductionOpportunity(Œ†ùúå,ùúè,ùëáconf .hT)

3:
4: function avoidEquivocations(hT, blkTxs)
5:
6:
7:
8:
9:
10:
11:
12:
13:

‚ä≤ Ignore chains with invalid content in any block
T‚Ä≤ ‚Üê { C ‚àà hT‚àó | ‚àÄC‚Ä≤ ‚™Ø C : blkTxs[ C‚Ä≤] ‚â† invalid}
‚ä≤ Ignore downloaded chains
T‚Ä≤ ‚Üê { C ‚àà T‚Ä≤ | blkTxs[ C ] = unknown}
‚ä≤ Select the longest chain
C ‚Üê arg maxC‚Ä≤‚ààT‚Ä≤ | C‚Ä≤ |
‚ä≤ Find the first not downloaded block on that chain (if non-existent: ‚ä•)
C‚Ä≤ ‚Üê arg minC‚Ä≤‚Ä≤‚™ØC : blkTxs[C‚Ä≤‚Ä≤ ]=unknown | C‚Ä≤‚Ä≤ |
return C‚Ä≤

6.2 Analysis
We use the general framework developed in Section 4 to prove
security of PoS LC under the equivocation avoidance download
rule. Recall that we only need to prove that MaxDLùêæ (Definition 2)
holds with overwhelming probability.

In a uniquely successful slot, honest nodes may not immediately
download towards the block from that slot. This is because there
could be other chains in a node‚Äôs header tree that are longer (recall
that Algorithm 4 prioritizes the longest header chain after removing
equivocations and invalid prefixes). However, we can bound the
number of blocks that will be downloaded before downloading the
block from the uniquely successful slot. With equivocation avoid-
ance, honest nodes retain only one leaf in their header tree per
block production opportunity. So, honest nodes download at most
one chain per block production opportunity. Since block production
opportunities are bounded, we will show in Lemma 4 that there can
not be too many longer chains in the honest node‚Äôs header tree.

Define for slots ùë† ‚â§ ùë°,
ùëäùë†,ùë° ‚âú

max
ùëü <ùë† : Unique(ùëü )‚àß( A(ùëü,ùë† ] ‚â•U(ùëü,ùë° ])
Definition 4. For an execution Eùúå,ùõΩ,ùëáh , FewLongChainsùêæ (Eùúå,ùõΩ,ùëáh )
holds iff

A (ùëü, ùë†] .

(12)

‚àÄùë° ‚â§ ùëáh : ùëäùë° ‚àí1,ùë° ‚àí1 +

‚àëÔ∏Å

ùë† ‚â§ùë°

ùê¥ùë†ùëäùë†,ùë° < ùêæ .

(13)

Lemma 4. For an execution Eùúå,ùõΩ,ùëáh and the longest header chain
download rule with equivocation avoidance Dlhc‚àíea (Algorithm 4),
FewLongChainsùêæ (Eùúå,ùõΩ,ùëáh ) =‚áí MaxDLùêæ (Eùúå,ùõΩ,ùëáh, Dlhc‚àíea) (14)
Lemma 5.
(1 + ùúñ1) for some ùúñ1 ‚àà (0, 1)
2
and ùêæ = ùëùAùëáb (1 + ùõΩùúåùëáb (1 + ùúñ3))(1 + ùúñ2) for some ùúñ2, ùúñ3 > 0 where
ùëáb =

If (1 ‚àí ùõΩ)ùúåùëí‚àíùúå = 1‚àíùëí‚àíùúå

Œ© (ùúÖ+lnùëáh)
ùõº3ùëù
(cid:104)
Eùúå,ùõΩ,ùëáh : ¬¨FewLongChainsùêæ (Eùúå,ùõΩ,ùëáh )

(cid:105)

‚â§ negl(ùúÖ)

(15)

, then

Pr

whereùõº3 = max

ùúñ 2
ùõΩùúå
ùëù , ùëùU (1‚àíùúñ3)
ùëùA
3
(ùúñ3+2)ùëù
Lemma 4 is proved in Appendix D.5 and Lemma 5 in Appen-

, ùúñ 2
2
ùúñ2+2

ùëùU
2ùëù ,

(cid:16) ùëùU
1‚àíùëùU

(cid:110) ùúñ 2
1
36

, ùúñ 2

ln

(cid:17)

ùëù

3

(cid:111).

dix D.6. Then, we obtain the following corollary of Theorem 1.

11

Passively following Œ†ùúå,ùúè,ùëáconf

Actively participating in Œ†ùúå,ùúè,ùëáconf

(a)

(b)

‚â§

(cid:17)

(cid:16) 1+ùëù
2

Œ© ( 1
ùúÖ )

Parallel composition of Œ†ùúå,ùúè,ùëáconf

...

(c)

Primary chain

Secondary chains

Figure 9: Worst-case throughput and bandwidth consump-
tion, as a fraction of the total bandwidth. Green portions rep-
resent bandwidth consumption that contributes to through-
put, while red portions represent bandwidth consumption
that is caused by the adversary and may not contribute to
throughput (e.g., empty/invalid blocks, spamming).

Corollary 2. The protocol Œ†ùúå,ùúè,ùëáconf with the equivocation avoidance
download rule and parameters ùúå such that (1 ‚àí ùõΩ)ùúåùëí‚àíùúå = 1‚àíùëí‚àíùúå
(1 +
ùúñ1),ùúè = Œ© (cid:0)(ùúÖ + lnùëáh)2(cid:1) andùëáconf = Œ© (cid:0)(ùúÖ + lnùëáh)2(cid:1), is secure with
ùëálive = Œ© (cid:0)(ùúÖ + lnùëáh)2(cid:1).

2

6.3 Blocklisting
Another common heuristic to deal with equivocations is ‚Äòblock-
listing‚Äô the proposer of equivocating blocks. Blocklisting can be
implemented at the level of the download rule as follows: an honest
node never downloads a chain whose tip is proposed by a party for
which the node has seen two block headers with the same time slot
(an equivocation). Blocklisting is a decision that is taken unilater-
ally by each honest node and may be taken at different points of
time by different nodes.

Note that this is only a stricter version of the equivocation avoid-
ance rule described in Section 6.1 because in any given time slot,
a block that is rejected in the equivocation avoidance rule will also
be rejected in the blocklisting rule. Moreover, any chain whose tip
is proposed by an honest node will not be discarded under this rule.
Therefore, for any execution Eùúå,ùõΩ,ùëáh and the blocklisting rule Dblist
MaxDLùêæ (Eùúå,ùõΩ,ùëáh, Dlhc‚àíea) =‚áí MaxDLùêæ (Eùúå,ùõΩ,ùëáh, Dblist). (16)
Therefore, security of PoS LC with the ‚Äòblocklisting‚Äô rule is implied
by security of PoS LC with ‚Äòequivocation avoidance‚Äô rule and the
same parameters.

7 HIGH THROUGHPUT

UNDER BANDWIDTH CONSTRAINT

In what follows, we use the freshest block download rule as our
running example, but the results carry over analogously to other
download rules analyzed using our unified framework, such as
those in Section 6. From Corollary 1, we parameterize Œ†ùúå,ùúè,ùëáconf
with the freshest block download rule with ùúè = Œ©(ùúÖ) for security,
so the protocol gets slower as the security parameter increases. A
similar slowdown is also observed in the analysis in [24]. Thus, the
throughput of Œ†ùúå,ùúè,ùëáconf decreases with increasing security param-
eter. Indeed, we show in Section 7.2 that the worst-case throughput
of Œ†ùúå,ùúè,ùëáconf is lower bounded by 2ùëùU‚àíùëù

.

ùúè

= 1

Œ© (ùúÖ)

ùë° ‚àí ùëáconf

ùë°

Primary Chain

...

...

Time

Œ†ùúå,ùúè,ùëáconf

1

Œ†ùúå,ùúè,ùëáconf

2

3

Œ†ùúå,ùúè,ùëáconf
...

Œ†ùúå,ùúè,ùëáconf
ùëö

Secondary Chains

Follow secondary chains‚Äô
confirmed blocks

Follow primary chain‚Äôs
freshest blocks

Figure 10: In the parallel chains construction using Œ†ùúå,ùúè,ùëáconf ,
each node is assigned one primary chain; the other (ùëö ‚àí 1)
chains are secondary. Nodes participate actively in their
primary chain using, for example, the freshest block down-
load rule, and follow their secondary chains passively by
downloading confirmed blocks only.

The slow block production rate also means that passively follow-
ing the confirmed blocks of a chain only requires downloading up to
ùëù
blocks per second because the secure protocol Œ†ùúå,ùúè,ùëáconf
ùúè = 1
Œ© (ùúÖ)
has already achieved consensus on these blocks (see Figure 9(a)).
In fact, the ratio between throughput and the bandwidth required
to download the confirmed blocks is the chain quality (fraction
of honest blocks in the chain). This fraction, 2ùëùU‚àíùëù
> 0 is inde-
pendent of the security parameter ùúÖ. This suggests to invoke the
idea of Parallel Chains [23, 24]: fill the available bandwidth using
multiple instances of the slow LC protocol in parallel and combine
the transactions of all instances into a single ledger. By increas-
ing the number of chains, one can compensate for the decreasing
throughput of the individual chains as ùúÖ is increased.

ùëù

However, following the confirmed chains alone is not enough to
achieve consensus on all these chains. Note that the bandwidth con-
sumption of a node actively participating in Œ†ùúå,ùúè,ùëáconf may be higher
than what is required to download only the confirmed chain, due
to spamming attacks. By spending this additional bandwidth, the
nodes actively participating in Œ†ùúå,ùúè,ùëáconf make the protocol secure,
which is what allows other nodes to passively follow and download
the confirmed chain with little bandwidth consumption. However,
even under spamming attacks, we show in Section 7.2 that the worst-
case bandwidth consumption is only a little more than half the avail-
able bandwidth ùê∂ (shown in Figure 9(b)). This leaves nearly half the
bandwidth available for a node participating in Œ†ùúå,ùúè,ùëáconf to down-
load the confirmed portions of other parallel chains. This still allows
us to increase the number of parallel chains to occupy the remaining
bandwidth (shown in Figure 9(c)). So, we modify the parallel chains
construction from [23, 24] as described in the following section.

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

7.1 Parallel Chains Construction
The protocol consists of ùëö parallel instances of Œ†ùúå,ùúè,ùëáconf (see Fig-
ure 10). For simplicity, assume that at genesis (and after the adver-
sary has chosen which nodes to corrupt), stakeholders are randomly
partitioned into ùëö equally sized sets, and the nodes of each set get
assigned a particular instance of Œ†ùúå,ùúè,ùëáconf as their primary chain.
Nodes are responsible for maintaining consensus on their primary
chain. For this purpose, they download blocks as per a secure down-
load rule and propose blocks on their primary chain as described in
Œ†ùúå,ùúè,ùëáconf . The remaining (ùëö‚àí1) instances of Œ†ùúå,ùúè,ùëáconf that are not
a node‚Äôs primary chain are considered its secondary chains. Nodes
do not participate actively in consensus building on their secondary
chains, but only download the confirmed blocks from those chains,
as determined by the ùëáconf -deep LC confirmation rule based on the
block headers. Transactions from the confirmed portion of all the
chains are first ordered by their time slots and then by the index
of the protocol instance they appear in, to then be merged into a
single output ledger. Moreover, every transaction can be included
only in a single Œ†ùúå,ùúè,ùëáconf instance determined, e.g., based on the
transaction‚Äôs hash or sender address, so as to avoid duplicating
transactions across different Œ†ùúå,ùúè,ùëáconf instances. See Appendix C
for pseudocode for the above parallel chains construction.

Each instance of Œ†ùúå,ùúè,ùëáconf is secure if at most ùõΩ fraction of nodes
for whom this instance is the primary chain are corrupt, and the
parameters ùúå, ùúè,ùëáconf satisfy the constraints in Theorem 1. Note
that if the number of stakeholders assigned to each primary chain
is large, then the adversarial power in each instance of Œ†ùúå,ùúè,ùëáconf
is very likely close to the overall adversarial power, rendering the
construction secure against non-adaptive adversaries that corrupt
at most ùõΩ fraction of the nodes. See Appendix E for a more detailed
security analysis.

7.2 Throughput and Bandwidth Consumption
To quantify the throughput of Œ†ùúå,ùúè,ùëáconf , we first note that the
longest chain in any honest node‚Äôs view grows at least at the rate of
uniquely successful slots, ùëùU blocks per slot (Lemma 1). Moreover,
we can lower bound the chain quality, i.e., the fraction of blocks
in the blockchain in any honest node‚Äôs view, which are proposed
by honest nodes. All blocks proposed by honest nodes will contain
distinct and valid transactions. Therefore, the chain quality along
with the chain growth rate give a lower bound on the throughput.

Lemma 6. (Throughput) There exists a constant ùëá1 such that for any
honest node ùëñ and time slots ùë°1, ùë°2 ‚â• ùë°1 + ùëá with ùëá ‚â• ùëá1, dCùëñ (ùë°2) \
dCùëñ (ùë°1) contains at least ùúÉùëá (1 ‚àí ùúñ4) blocks proposed by honest nodes,
with probability at least 1 ‚àí exp(‚àíùõº4ùëá ), where ùúÉ = 2ùëùU ‚àí ùëù.

From Lemma 6, the throughput of each chain is at least TP1 = ùúÉ
ùúè
blocks per second.4 Note that this lower bound holds under the
worst-case adversary strategy.

Next, we calculate the bandwidth consumption of passively fol-
lowing the confirmed blocks of a secondary chain. Due to the se-
curity of Œ†ùúå,ùúè,ùëáconf run by the nodes for whom the corresponding

4For simplicity, we consider a constant number of transactions in each block. Hence,
this directly translates to throughput in transactions per second.

12

Longest Chain Consensus Under Bandwidth Constraint

chain is primary, the confirmed chain contains only valid avail-
able blocks and can be downloaded by spending little bandwidth
without any interference from spamming blocks.

Lemma 7. (Passive Bandwidth Consumption) There exists a constant
ùëá2 such that for any honest nodes ùëñ, ùëñ ‚Ä≤ and time slots ùë°1, ùë°2 ‚â• ùë°1 +ùëá such
ùë°2
ùë°1
that ùëá ‚â• ùëá2, LOG
contains at most ùúôpùëá (1 + ùúñ5) blocks,
ùëñ‚Ä≤ \ LOG
ùëñ
with probability at least 1 ‚àí exp(‚àíùõº5ùëá ), where ùúôp = ùëù.

Finally, we analyze the worst-case bandwidth consumption of
active nodes in Œ†ùúå,ùúè,ùëáconf . As per the freshest block download rule
(see Algorithm 2, lines 6ff.), once all blocks proposed in the most re-
cent non-empty time slot have been downloaded, the downloading
node stays idle (because then C = ‚ä• in Algorithm 1, line 6). Since
in every uniquely successful slot, each node downloads the freshest
block within one slot (Lemma 2), the node thereafter remains idle
until the next block proposal. This gives a simple lower bound on
the worst-case fraction of time a node‚Äôs bandwidth consumption is
idle. (See Figure 8 for a matching observation in our experiments.)

Lemma 8. (Active Bandwidth Consumption) There exists a constant
ùëá3 such that for any honest node ùëñ and time slots ùë°1, ùë°2 ‚â• ùë°1 + ùëá with
ùëá ‚â• ùëá3, nodeùëñ does not download any blocks for at leastùúôidleùëáùúè (1‚àíùúñ6)
time during the interval of time slots (ùë°1, ùë°2], with probability at least
ùëùU (1‚àíùëù)
1 ‚àí exp(‚àíùõº6ùëá ), where ùúôidle =
ùëù

‚â• 1‚àíùëù
2

.

Lemmas 6, 7 and 8 are proved in Appendix D.7. Lemma 8 implies
that a bandwidth of at least ùúôidle ¬∑ ùê∂ remains unutilized by each
node‚Äôs primary chain. From Lemma 7, each node needs to download
on average ùúôp blocks per slot, or ùúôp
ùúè blocks per second, to follow
the confirmed blocks of one of the secondary chains. This allows
ùúôidle
each node to follow ùëö ‚àí 1 =
ùê∂ùúè number of secondary chains.
ùúôp
Therefore the ùëö parallel chains have an aggregate throughput of

TPùëö = ùëö TP1 =

=

(cid:18)

1 +

ùúôidle
ùúôp
(1 ‚àí ùëù)ùúñ1
2

ùê∂ùúè

(cid:19) ùúÉ
ùúè

‚â•

(1 ‚àí ùëù)(2ùëùU ‚àí ùëù)
2ùëù

ùê∂

ùê∂ blocks per second

(17)

using ùëùU = 1
ùëù (1 + ùúñ1) from Theorem 1. Therefore, the aggregate
2
throughput of the parallel chains remains within a constant fraction
of the optimal throughput which is the bandwidth of ùê∂ blocks per
second. This is true even if the number of secondary chains is param-
eterized so that the protocol produces an average load of only a cer-
tain fraction of the bandwidth left over by the primary chain, so as to
bound queuing delays due to fluctuations in bandwidth utilization.
Notice that the throughput and passive bandwidth consump-
tion of the protocol do not change with the download rule. With
‚Äòequivocation avoidance‚Äô and ‚Äòblocklisting‚Äô, by doubling ùêæ such that
MaxDLùêæ/2 holds (thereby roughly doubling the time slot duration),
and ensuring that honest nodes do not download more than ùêæ/2
blocks in any slot, the active bandwidth utilization is explicitly
bounded by half the available bandwidth. Thus, the parallel chains
construction with these download rules also behaves similarly.

The worst-case throughput of a single chain and that of the paral-
lel construction are limited by the chain quality factor ùúñ1 = 2ùëùU‚àíùëù
due to the possibility of selfish mining attacks [22]. Using the Con-
flux inclusion rule from [38] (which is also employed in [24]), this
factor can be improved to ùëùU
ùëù (which does not vanish as we push the

ùëù

13

resilience ùõΩ closer to 1/2). In this rule, each block includes pointers
to blocks that are not in its prefix, in order to include them in the
ledger. To adapt this rule to bandwidth constrained networks, we
modified it to ensure that only one block from each block produc-
tion opportunity is pointed to and the number of pointers in each
block is limited yet enough to include honest blocks. The details
of this construction are in Appendix F.

Finally, in a comparison with [24], both works show a parallel
chains construction that achieves throughput up to a constant frac-
tion of the network capacity. However, our work proves this under
worst-case adversarial strategies (including, inter alia, equivocation-
based spamming), while [24] proves security only for adversaries
that do not aggravate network congestion so much that a delay
upper bound is violated. On the other hand, the security of our
construction requires static corruption and honest majority among
nodes in each chain (as each nodes performs consensus on one
chain), whereas [24] works under a global honest majority assump-
tion (as each node participates in all chains).

ACKNOWLEDGMENT
We thank Dan Boneh and Ertem Nusret Tas for fruitful discussions.
JN is supported by the Protocol Labs PhD Fellowship, a gift from
Ethereum Foundation, and the Reed-Hodgson Stanford Graduate
Fellowship.

REFERENCES
[1] 2020. Bitcoin Developer Guide ‚Äì P2P Network ‚Äì Initial Block Download ‚Äì Headers-
First. https://developer.bitcoin.org/devguide/p2p_network.html#headers-first
[2] 2021. Ethereum 2.0 networking specification. https://github.com/ethereum/eth2.0-

specs/blob/dev/specs/phase0/p2p-interface.md

[3] Maria Apostolaki, Aviv Zohar, and Laurent Vanbever. 2017. Hijacking Bitcoin:
Routing Attacks on Cryptocurrencies. In 2017 IEEE Symposium on Security and
Privacy (SP). 375‚Äì392. https://doi.org/10.1109/SP.2017.29

[4] Christian Badertscher, Peter Ga≈æi, Aggelos Kiayias, Alexander Russell, and Vassilis
Zikas. 2018. Ouroboros Genesis: Composable proof-of-stake blockchains with
dynamic availability. In Conference on Computer and Communications Security
(CCS ‚Äô18). ACM, 913‚Äì930.

[5] Vivek Bagaria, Amir Dembo, Sreeram Kannan, Sewoong Oh, David Tse, Pramod
Viswanath, Xuechao Wang, and Ofer Zeitouni. 2019. Proof-of-Stake Longest
Chain Protocols: Security vs Predictability. arXiv preprint arXiv:1910.02218 (2019).
[6] Vivek Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and Pramod Viswanath.
2019. Prism: Deconstructing the Blockchain to Approach Physical Limits. In
Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications
Security (CCS ‚Äô19). ACM, 585‚Äì602.

[7] Vitalik Buterin. 2014. Proof of Stake: How I Learned to Love Weak Subjectivity.
Retrieved 2022-05-05 from https://blog.ethereum.org/2014/11/25/proof-stake-
learned-love-weak-subjectivity/

[8] Vitalik Buterin and Virgil Griffith. 2017. Casper the Friendly Finality Gadget.
CoRR abs/1710.09437 (2017). arXiv:1710.09437 http://arxiv.org/abs/1710.09437
[9] Vitalik Buterin, Diego Hernandez, Thor Kamphefner, Khiem Pham, Zhi Qiao,
Danny Ryan, Juhyeok Sin, Ying Wang, and Yan X. Zhang. 2020. Combin-
ing GHOST and Casper.
arXiv:2003.03052
https://arxiv.org/abs/2003.03052

CoRR abs/2003.03052 (2020).

[10] C. Cachin and S. Tessaro. 2005. Asynchronous verifiable information dispersal.
In 24th IEEE Symposium on Reliable Distributed Systems (SRDS‚Äô05). 191‚Äì201.
https://doi.org/10.1109/RELDIS.2005.9

[11] Tong Cao, Jiangshan Yu, J√©r√©mie Decouchant, and Paulo Esteves-Verissimo.
(2018).

2018. Revisiting Network-Level Attacks on Blockchain Network.
https://orbilu.uni.lu/bitstream/10993/38142/1/bcrb18-cao.pdf

[12] Miguel Castro, Peter Druschel, Ayalvadi Ganesh, Antony Rowstron,
Secure Routing for Structured Peer-to-Peer
SIGOPS Oper. Syst. Rev. 36, SI (Dec. 2003), 299‚Äì314.

and Dan S. Wallach. 2003.
Overlay Networks.
https://doi.org/10.1145/844128.844156

[13] Sandro Coretti, Aggelos Kiayias, Cristopher Moore, and Alexander Russell. 2022.
The Generals‚Äô Scuttlebutt: Byzantine-Resilient Gossip Protocols. Cryptology
ePrint Archive, Report 2022/541. https://ia.cr/2022/541.

[14] Duncan Coutts, Neil David, Marcin Szamotulski, and Peter Thompson. 2020.
Introduction to the design of the Data Diffusion and Networking for Cardano Shelley.

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

Technical Report. IOHK. Version 1.9.

[15] Duncan Coutts, Alex Vieth, Neil Davies, Marcin Szamotulski, Karl Knutsson, Marc
Fontaine, and Armando Santos. 2021. The Shelley Networking Protocol. Technical
Report. IOHK. Version 1.2.0, Revision 49.

[16] Phil Daian, Rafael Pass, and Elaine Shi. 2019. Snow White: Robustly Reconfigurable
Consensus and Applications to Provably Secure Proof of Stake. In Financial
Cryptography and Data Security (FC ‚Äô19). Springer, 23‚Äì41.

[17] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. 2018.
Ouroboros Praos: An Adaptively-Secure, Semi-synchronous Proof-of-Stake
Blockchain. In EUROCRYPT 2018. Springer, 66‚Äì98.

[18] Edsko de Vries, Thomas Winant, and Duncan Coutts. 2020. The Cardano
Consensus and Storage Layer. https://github.com/input-output-hk/ouroboros-
network/tree/master/ouroboros-consensus/docs/report

[42] Kamilla Nazirkhanova, Joachim Neu, and David Tse. 2021. Information Dispersal

with Provable Retrievability for Rollups. CoRR abs/2111.12323 (2021).

[43] Joachim Neu, Ertem Nusret Tas, and David Tse. 2021.

The Availability-
Accountability Dilemma and its Resolution via Accountability Gadgets. CoRR
abs/2105.06075 (2021). arXiv:2105.06075 https://arxiv.org/abs/2105.06075
[44] R Pass, L Seeman, and A Shelat. 2017. Analysis of the blockchain protocol in
asynchronous networks. In Annual International Conference on the Theory and
Applications of Cryptographic Techniques.

[45] Rafael Pass and Elaine Shi. 2017. The Sleepy Model of Consensus. In ASIACRYPT

2017. Springer, 380‚Äì409.

[46] Brian Quarmby. 2022. Solana hit with another network incident causing degraded
performance. Retrieved 2021-05-04 from https://cointelegraph.com/news/solana-
hit-with-another-network-incident-causing-degraded-performance

[19] Christian Decker and Roger Wattenhofer. 2013. Information propagation in the

[47] Ling Ren. 2019. Analysis of Nakamoto Consensus. IACR Cryptol. ePrint Arch.

Bitcoin network. In P2P. IEEE, 1‚Äì10.

(2019), 943.

[20] Amir Dembo, Sreeram Kannan, Ertem Nusret Tas, David Tse, Pramod Viswanath,
Xuechao Wang, and Ofer Zeitouni. 2020. Everything is a Race and Nakamoto
Always Wins. In Conference on Computer and Communications Security (CCS ‚Äô20).
ACM, 859‚Äì878.

[21] Cynthia Dwork and Moni Naor. 1992. Pricing via Processing or Combatting Junk
Mail. In CRYPTO (Lecture Notes in Computer Science, Vol. 740). Springer, 139‚Äì147.
[22] Ittay Eyal and Emin G√ºn Sirer. 2018. Majority is not enough: Bitcoin mining is

vulnerable. Commun. ACM 61, 7 (2018), 95‚Äì102.

[23] Matthias Fitzi, Peter Ga≈æi, Aggelos Kiayias, and Alexander Russell. 2018. Parallel
Chains: Improving Throughput and Latency of Blockchain Protocols via Parallel
Composition. Cryptology ePrint Archive, Report 1119.

[24] Matthias Fitzi, Peter Ga≈æi, Aggelos Kiayias, and Alexander Russell. 2020.
Proof-of-Stake Blockchain Protocols with Near-Optimal Throughput. Cryptology
ePrint Archive, Report 2020/037. https://eprint.iacr.org/2020/037.

[25] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. 2015. The Bitcoin backbone
protocol: Analysis and applications. In EUROCRYPT 2015. Springer, 281‚Äì310.

[26] Peter Gazi, Aggelos Kiayias, and Dionysis Zindros. 2019.

Proof-of-Stake

Sidechains. In IEEE Symposium on Security and Privacy. IEEE, 139‚Äì156.

[27] Peter Ga≈æi, Aggelos Kiayias, and Alexander Russell. 2020. Tight Consistency

Bounds for Bitcoin. (2020). https://eprint.iacr.org/2020/661.

[28] Ethan Heilman, Alison Kendler, Aviv Zohar, and Sharon Goldberg. 2015.
Eclipse Attacks on Bitcoin‚Äôs Peer-to-Peer Network. In 24th USENIX Security
Symposium (USENIX Security 15). USENIX Association, Washington, D.C.,
129‚Äì144.
https://www.usenix.org/conference/usenixsecurity15/technical-
sessions/presentation/heilman

[29] James Hendricks, Gregory R. Ganger, and Michael K. Reiter. 2007. Verifying

distributed erasure-coded data. In PODC. ACM, 139‚Äì146.

[30] IOHK. 2020. input-output-hk/ouroboros-network. https://github.com/input-output-
hk/ouroboros-network/blob/master/ouroboros-network/src/Ouroboros/
Network

[31] IOHK. 2020. input-output-hk/ouroboros-network. https://github.com/input-output-
hk/ouroboros-network/blob/master/ouroboros-network/src/Ouroboros/
Network/BlockFetch/Decision.hs#L162

[32] IOHK. 2021.

input-output-hk/ouroboros-network.

https://github.com/input-

output-hk/ouroboros-network/blob/master/ouroboros-consensus-
shelley/src/Ouroboros/Consensus/Shelley/Protocol.hs#L281

[33] Markus Jakobsson and Ari Juels. 1999. Proofs of Work and Bread Pudding Pro-
tocols. In Communications and Multimedia Security (IFIP Conference Proceedings,
Vol. 152). Kluwer, 258‚Äì272.

[34] Kostis Karantias, Aggelos Kiayias, and Dionysis Zindros. 2020. Proof-of-Burn. In
Financial Cryptography (Lecture Notes in Computer Science, Vol. 12059). Springer,
523‚Äì540.

[35] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017.
Ouroboros: A provably secure proof-of-stake blockchain protocol. In CRYPTO
2017. Springer, 357‚Äì388.

[36] Aggelos Kiayias and Dionysis Zindros. 2019. Proof-of-Work Sidechains. In
Financial Cryptography Workshops (Lecture Notes in Computer Science, Vol. 11599).
Springer, 21‚Äì34.

[37] Bob Lantz, Brandon Heller, and Nick McKeown. 2010. A network in a laptop:

rapid prototyping for software-defined networks. In HotNets. ACM, 19.

[38] Chenxing Li, Peilun Li, Wei Xu, Fan Long, and Andrew Chi-chih Yao. 2018. Scaling
Nakamoto Consensus to Thousands of Transactions per Second. arXiv preprint
arXiv:1805.03870 (2018).
[39] Michael McSweeney. 2021.

Solana experiences transaction stoppage as
Retrieved 2021-11-21 from

developers report ‚Äòintermittent instability‚Äô.
https://www.theblockcrypto.com/linked/117624/solana-experiences-
transaction-stoppage-as-developers-report-intermittent-instability

[40] Mike Millard. 2022. Solana restarted after seven-hour outage caused by surge
of transactions. Retrieved 2022-05-04 from https://www.theblockcrypto.com/
linked/144639/solana-restarted-after-seven-hour-outage-caused-by-surge-of-
transactions

[41] Satoshi Nakamoto. 2008. Bitcoin: A Peer-to-Peer Electronic Cash System.

https://bitcoin.org/bitcoin.pdf.

14

[48] Peiyao Sheng, Gerui Wang, Kartik Nayak, Sreeram Kannan, and Pramod

Viswanath. 2021. BFT Protocol Forensics. In CCS. ACM, 1722‚Äì1743.

[49] Atul Singh, Miguel Castro, Peter Druschel, and Antony Rowstron. 2004.
Defending against Eclipse Attacks on Overlay Networks. In Proceedings of
the 11th Workshop on ACM SIGOPS European Workshop (Leuven, Belgium)
(EW 11). Association for Computing Machinery, New York, NY, USA, 21‚Äìes.
https://doi.org/10.1145/1133572.1133613

[50] Atul Singh, Tsuen-Wan Ngan, Peter Druschel, and Dan S. Wallach. 2006. Eclipse
Attacks on Overlay Networks: Threats and Defenses. In INFOCOM. IEEE.
[51] Emil Sit and Robert Morris. 2002. Security Considerations for Peer-to-Peer Dis-
tributed Hash Tables. In Peer-to-Peer Systems, Peter Druschel, Frans Kaashoek, and
Antony Rowstron (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 261‚Äì269.
Secure high-rate transaction
processing in bitcoin. In International Conference on Financial Cryptography and
Data Security. Springer, 507‚Äì527.

[52] Yonatan Sompolinsky and Aviv Zohar. 2015.

[53] Anatoly Yakovenko. 2018. Solana: A new architecture for a high performance
Retrieved 2021-11-21 from https://solana.com/solana-

blockchain v0.8.13.
whitepaper.pdf

[54] Lei Yang, Seo Jin Park, Mohammad Alizadeh, Sreeram Kannan, and David Tse.
2022. DispersedLedger: High-Throughput Byzantine Consensus on Variable
Bandwidth Networks. In 19th USENIX Symposium on Networked Systems Design
and Implementation (NSDI 22). USENIX Association, Renton, WA, 493‚Äì512.
https://www.usenix.org/conference/nsdi22/presentation/yang

A REFERENCE ALGORITHMS
A.1 Helper Functions for Algorithms 1, 3, 4
‚Ä¢ Hash(txs):

Cryptographic hash function to produce a binding commitment
to txs (modelled as a random oracle)

‚Ä¢ C‚Ä≤ ‚™Ø C:

Relation describing that C‚Ä≤ is a prefix of C

‚Ä¢ C‚à•C‚Ä≤:

Concatenation of C and C‚Ä≤

‚Ä¢ prefixChainsOf (C):
Set of prefixes of C
‚Ä¢ longestChain(T ):

Determine longest chain among set T of chains. Ties are broken
by the adversary.

‚Ä¢ C ‚åàùëáconf :

Prefix of chain C consisting of all blocks with time slots up to
ùëáconf less than the current time slot

‚Ä¢ txsAreSemanticallyValidWrtPrefixesOf (C, txs):

Verifies for each transaction in txs that the transaction is semanti-
cally valid with respect to and properly authorized by the owner
of the underlying assets as determined by the transaction‚Äôs prefix
in the ledger resulting from appending txs to the transactions as
ordered in C (assumes that content of all blocks in C is known
to the node)

‚Ä¢ newBlock(time : ùë°, node : ùëÉ, txsHash : Hash(txs)):

Produces a new block header with the given parameters

‚Ä¢ oneLeafPerProductionOpportunity(hT ):

Longest Chain Consensus Under Bandwidth Constraint

Filter header tree hT to keep at most one leaf per block produc-
tion opportunity, i.e., per (node, time) pair (equivocation avoid-
ance; ties broken adversarially)

A.2 Environment Z
The environment Z initializes ùëÅ nodes and lets A corrupt up
to ùõΩùëÅ nodes at the beginning of the execution. Corrupted nodes
are controlled by the adversary. Honest nodes run Œ†ùúå,ùúè,ùëáconf . The
environment maintains a mapping blkTxs from block headers to
the block content (transactions). This mapping is referred to as
the ‚Äòidealized repository‚Äô in Section 2. Z also maintains for each
node a queue of pending block headers to be delivered after a delay
determined by the adversary (at most Œîh). Honest nodes and the
adversary interact with Z via the following functions:

‚Ä¢ Z.broadcastHeaderChain(C):

If called by an honest node, Z sends header chain C to A. Then,
for each honest node ùëÉ, on receiving deliver(C, ùëÉ) from A, or
when Œîh time has passed since C was handed to Z for broad-
casting, Z triggers ùëÉ .receivedHeaderChain(C).

‚Ä¢ Z.uploadContent(C, txs):

Z stores a mapping from the header chain C to the content txs
of its last block by setting blkTxs[C] = txs. Z only stores the
content txs if Hash(txs) = C.txsHash.

‚Ä¢ Z.reqestContent(C):

If blkTxs[C] is set, then let txs = blkTxs[C] (if not, Z ignores
the request). On receiving this call from an honest node ùëÉ in a
time slot ùë°, if Z has triggered ùëÉ .receivedContent(.) less than
ùêæ times in slot ùë°, then Z triggers ùëÉ .receivedContent(C, txs).
On receiving this call from A, Z sends (C, txs) to A.
‚Ä¢ Z.receivePendingTxsSemanticallyValidWrt(C):

Z generates a set of pending transactions that are not included
in the block contents of but semantically valid (see Appendix A.1)
with respect to C, and returns them.

‚Ä¢ Z.outputLedger(C):

On receiving this call from a node ùëÉ, Z records C as ùëÉ‚Äôs ledger
to be externalized. This constitutes LOGùë°
ùëñ , for which consistency
and liveness are required for a secure consensus protocol.

B SUPPLEMENTAL

EXPERIMENTAL MATERIAL

B.1 Experimental Setup Details for Figure 1
For this experiment, we start 17 Cardano nodes in 17 AWS data
centers across the globe and connect them into a fully-connected
graph. We point out that the Cardano block fetch logic includes an
optimization to only download blocks that have larger heights than
the locally-adopted longest chain. As a result, a node may not even-
tually download every block whose header it sees. To demonstrate
network congestion in the absence of a suitable download rule,
we modify the code to disable this optimization and ensure that
every node eventually downloads all blocks. To show congestion,
we configure a variable number (ùëÅ ) of nodes to all mine blocks at
the beginning of the same slot, and report the time for all 17 nodes
to download all ùëÅ blocks.

n

i
a
h
c
t
s
e
n
o
H

]
1
‚àí
s
[
e
t
a
r
h
t
w
o
r
g

0.04

0.02

0

2

4

6

8

10
Block size [KB]

12

14

16

Figure 11: Honest chain growth rate under spamming attack
when using different block sizes and the download freshest
block rule. Despite the increasing network load (through the
increasing block size), there is no performance deterioration
when downloading the freshest block.

B.2 Chain Growth with Larger Blocks
In this experiment, we look at the robustness of the ‚Äòdownload
towards the freshest block‚Äô rule when we increase the block size.
The topology is the same as previous experiments, but the in-flight
cap is fixed to 1. Figure 11 shows that this rule maintains the chain
growth rate, despite the increasing network load.

ùúå,ùëö
parallel

C PARALLEL CHAINS PSEUDOCODE
Algorithm 5 gives pseudocode for the parallel chains construction
using our PoS LC protocol parameterized with a download rule.
Note the following main differences with respect to Algorithm 1.
Upon initialization, each node is assigned a primary protocol in-
stance index by the functionality F
. Each node maintains a
separate header tree and downloaded chain for each index. While
scheduling content downloads, primary instance blocks get the
highest priority, with the same download rule that parameterizes
Œ†ùúå,ùúè,ùëáconf . If there are no blocks left to be downloaded in the pri-
mary instance, the node picks among the confirmed longest chains
of all secondary instances, the block with the oldest time slot with
unknown content. Downloading the block with the oldest time slot
allows the node to construct the ledger quickly, although this pri-
ority rule does not play a critical role in the consensus security. In
line 25, the ledger is constructed by ordering the confirmed blocks
of all the instances first by their time slots and then by the index
ùúå,ùëö
of the protocol instance they appear in. The functionality F
parallel
(Algorithm 6) assigns the primary chain index for each node by
uniformly and randomly partitioning the set of nodes across the ùëö
chains. This can be approximated in instantiations by each node se-
lecting as its primary chain index a hash of its public key modulo ùëö.
Rather than by the transaction hash, another way to shard trans-
actions is by distributing all accounts uniformly among the protocol
instances, and requiring transactions in a particular instance to
have both the source and destination accounts in the same instance.
Transactions with the source and destination accounts in different
instances would be split into two transactions, one which burns the
funds in the source account and subsequently another one which
recreates funds in the destination account (while showing a receipt
of burn in the source chain), each transaction in its respective proto-
col instance (see [26, 34, 36] and references therein for background
on this technique). Such a solution allows validation of each trans-
action with respect to its prefix within the same instance at the time

15

Algorithm 5 Parallel Chains PoS LC consensus protocol
Œ†ùúå,ùúè,ùëáconf,ùëö
: Algo-
(helper functions: Appendix C.1, F
rithm 6, Œ†ùúå,ùúè,ùëáconf : Algorithm 1)

ùúå,ùëö
parallel

pc

Œ†idx ‚Üê new Œ†ùúå,ùúè,ùëáconf
Œ†idx.init(genesisHeaderChain, genesisTxs)

‚ä≤ Initialize ùëö instances of Œ†ùúå,ùúè,ùëáconf

1: on init(genesisHeaderChain, genesisTxs)
.primaryChainIndex()
2:

ùúå,ùëö
pri ‚Üê F
parallel
for idx = 1, ..., ùëö

3:
4:
5:
6: on receivedHeaderChain(idx, C)
Œ†idx.receivedHeaderChain( C)
7:
8: on receivedContent(idx, C, txs)
Œ†idx.receivedContent( C, txs)
9:
10: on scheduleContentDownload()
11:
12:
13:

‚ä≤ Called when download idle
Œ†pri.scheduleContentDownload() ‚ä≤ First priority for primary
if no content requested by Œ†pri

‚ä≤ Download first missing block along the confirmed portion of the

longest header chains in the secondary instances.

14:

S ‚Üê {longestChain(Œ†idx.hT) ‚åàùëáconf

{1, ..., ùëö } \ {pri} }

|

idx

‚àà

C ‚Üê arg minC‚Ä≤‚Ä≤‚™ØC‚Ä≤‚ààS : blkTxs[C‚Ä≤‚Ä≤ ]=unknown C‚Ä≤‚Ä≤.time
Z.reqestContent( C)

15:
16:
17: for time slots ùë° ‚Üê 1, ...,ùëáh of duration ùúè
18:
19:
20:
21:

‚ä≤ Only include valid txs whose accounts belong to the primary chain
txs ‚Üê Z.receivePendingTxsSemanticallyValidWrt(Œ†pri.dC)
‚ä≤ Check eligibility to produce a new block, and if so do so, see Algorithm 6
if C‚Ä≤ ‚â† ‚ä• with C‚Ä≤ ‚Üê F

.extend(pri, ùë°, Œ†pri.dC, txs)

ùúå,ùëö
parallel

Z.uploadContent(pri, C‚Ä≤, txs)
Z.broadcastHeaderChain(pri, C‚Ä≤)
while end of current time slot ùë° not reached

scheduleContentDownload()

‚ä≤ Find the maximum time slot of all downloaded and confirmed chains
tmax ‚Üê max{ùë° | Œ†idx.dC ‚åàùëáconf .time ‚â• ùë°, idx ‚àà {1, ..., ùëö } }
‚ä≤ Arrange confirmed and downloaded chains in increasing order of

time slots, then chain index

LOG ‚Üê sortBySlotThenIndex( { C | C ‚™Ø Œ†idx.dC ‚åàùëáconf ,

C.time ‚â§ tmax, idx ‚àà {1, ..., ùëö } })
Z.outputLedger(LOG)

22:
23:

24:
25:

26:
27:
28:

29:

30:

of block production (Algorithm 5 line 19), a property sometimes
referred to as predictable validity. An important consequence of this
is that there is no ‚Äúledger sanitization‚Äù procedure required while
constructing the ledger out of the confirmed blocks. In other words,
transactions once added to the chain cannot be invalidated in the
ledger because they were validated with respect to their past state
while proposing and forwarding the block. Thus, every transaction
contributes to throughput.

C.1 Additional Helper Functions

for Algorithm 5 (see also Appendix A.1)

‚Ä¢ sortBySlotThenIndex(S):

Arranges the chains in the set S in increasing order of time slots
of their tip. Chains with the same time slot from different pro-
tocol instances are arranged in increasing order of the index of
their protocol instance.

‚Ä¢ longestChain(T ):

Computes the longest chain in the tree T , i.e. computes arg maxC ‚ààT |C|.

‚Ä¢ Z.receivePendingTxsSemanticallyValidWrt(C):

16

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

Algorithm 6 Idealized functionality F
(see also F

: Algorithm 3)

ùúå
headertree

ùúå,ùëö
parallel

for parallel chains

1: on init(genesisHeaderChain, numParties)
2:
3:
4:
5:

P1, ..., Pùëö ‚Üê random equi-partition of {1, ..., numParties}
for idx = 1, ..., ùëö
for ùëÉ ‚àà Pidx

pri[ùëÉ ] ‚Üê idx
ùúå
headertree

‚ä≤ Initializeùëö instances of F

return pri[ùëÉ ]

Fidx ‚Üê new F
Fidx.init(genesisHeaderChain, numParties/ùëö)

6:
7:
8: on primaryChainIndex() from party ùëÉ
9:
10: on extend(idx, ùë° ‚Ä≤, C, txs) from party ùëÉ at time slot ùë°
11:
12:
13:

if pri[ùëÉ ] ‚â† idx
return ‚ä•

return Fidx.extend(ùë° ‚Ä≤, C, txs)

ùúå
headertree

Same as in the case of a single chain, but only includes transac-
tions for which the source account is defined in the same chain C.

D PROOF DETAILS
D.1 Proof of Theorem 1
Definition 5. A pivot is a slot ùë° such that

‚àÄ(ùëü, ùë†] ‚àã ùë° :

(U (ùëü, ùë†] > A (ùëü, ùë†]) ‚à® (A (ùëü, ùë†] = 0) .

(18)

The predicate Pivot(ùë°) is true iff ùë° is a pivot. A slot ùë° is a unique
pivot slot iff Pivot(ùë°) ‚àß Unique(ùë°).
Definition 6. For an execution Eùúå,ùõΩ,ùëáh , FreqPivotsùõæ (Eùúå,ùõΩ,ùëáh ) holds
iff

‚àÄùë° ‚â§ ùëáh ‚àí ùõæ : ‚àÉùë° ‚Ä≤ ‚àà (ùë°, ùë° + ùõæ] : Pivot(ùë° ‚Ä≤) ‚àß Unique(ùë° ‚Ä≤).
Lemma 9. For all ùêæ, ùõæ ‚àà N, ùúå ‚àà R+, executions Eùúå,ùõΩ,ùëáh and download
rules D such that

(19)

FreqPivotsùõæ (Eùúå,ùõΩ,ùëáh ) ‚àß MaxDLùêæ (Eùúå,ùõΩ,ùëáh, D)

(20)

holds, if ùúè = Œîh + ùêæ
ùê∂ and ùëáconf = ùõæ, then the protocol Œ†ùúå,ùúè,ùëáconf
with download rule D satisfies safety and liveness with ùëálive = 2ùõæ in
Eùúå,ùõΩ,ùëáh .

Lemma 10.
Œ© ( (ùúÖ+lnùëáh) 2)
ùõº1ùëù

If ùëùU = 1
2
, then

ùëù (1 + ùúñ1) for some ùúñ1 ‚àà (0, 1) and ùõæ =

(cid:104)

Pr

Eùúå,ùõΩ,ùëáh : ¬¨FreqPivotsùõæ (Eùúå,ùõΩ,ùëáh )

(cid:105)

‚â§ negl(ùúÖ)

(21)

where ùõº1 is a constant that depends on ùúñ1 and ùúå.

Lemma 9 is proved in Appendix D.2 and Lemma 10 in Appen-

dix D.3.

Proof of Theorem 1. Using Lemma 9, safety and liveness hold

except with probability

(cid:104)

Pr

Eùúå,ùõΩ,ùëáh : ¬¨FreqPivotsùõæ (Eùúå,ùõΩ,ùëáh ) ‚à® ¬¨MaxDLùêæ (Eùúå,ùõΩ,ùëáh, D)

(cid:105)

. (22)

This probability is negligible as per a union bound with Lemma 10
and the assumption about the download rule.

‚ñ°

Longest Chain Consensus Under Bandwidth Constraint

Time

ùëü

ùë° ‚àó

ùëè‚àó

‚Ñé‚Ä≤
1

ùë†

C‚Ä≤

Figure 12: An illustration of one example of the blocks and
time slots defined in the proof of Lemma 11. The block ùëè‚àó is
proposed in the unique pivot slot ùë° ‚àó. At the end of slot ùë† ‚â• ùë° ‚àó,
the chain C‚Ä≤ ‚àå ùëè‚àó is the longest chain in some node‚Äôs view. The
last block from a uniquely successful slot in C‚Ä≤ is ‚Ñé‚Ä≤
proposed
1
in the slot ùëü < ùë° ‚àó. Red (
) blocks are proposed
) and gray (
by adversarial and honest nodes, respectively. A red dashed
link (
) indicates that the block is withheld and released
later. Note that in this example, A (ùëü, ùë†] = 4 > 3 = U (ùëü, ùë†],
which is in contradiction to Pivot(ùë° ‚àó).

D.2 Proof of Lemma 9
Lemma 11. Suppose that for a download rule D and execution
Eùúå,ùõΩ,ùëáh , MaxDLùêæ (Eùúå,ùõΩ,ùëáh, D) holds. Let ùë° ‚àó be a time slot such that
Pivot(ùë° ‚àó) ‚àß Unique(ùë° ‚àó). Let ùëè‚àó be the block proposed in slot ùë° ‚àó. Then
ùëè‚àó ‚àà dCùëñ (ùë°) for all ùëñ and all ùë° ‚â• ùë° ‚àó.

Proof. For contradiction, suppose that ùë† ‚â• ùë° ‚àó is the first slot
such that ùëè‚àó ‚àâ dCùëñ (ùë†) for some ùëñ. Let C‚Ä≤ = dCùëñ (ùë†) such that ùëè‚àó ‚àâ C‚Ä≤.
Let ‚Ñé‚Ä≤ be the last block corresponding to a uniquely successful slot
on C‚Ä≤. Let ‚Ñé‚Ä≤ be proposed in the slot ùëü . Clearly, ùëü ‚â§ ùë†.

The block ‚Ñé‚Ä≤ extends dCùëñ‚Ä≤ (ùëü ‚àí 1) for some ùëñ ‚Ä≤ since honest nodes
propose blocks on their longest downloaded chain. Since ‚Ñé‚Ä≤ ‚àà C‚Ä≤
and ùëè‚àó ‚àâ C‚Ä≤, this means that ùëè‚àó ‚àâ dCùëñ‚Ä≤ (ùëü ‚àí 1). If ùëü > ùë° ‚àó, this is a
contradiction because we assumed that ùë† is the first slot such that
ùë† ‚â• ùë° ‚àó and ùëè‚àó ‚àâ dCùëñ (ùë†) for some ùëñ. Since Unique(ùë° ‚àó), ùëü ‚â† ùë° ‚àó. So, we
conclude that ùëü < ùë° ‚àó. All blocks in C‚Ä≤ extending ‚Ñé‚Ä≤ are from success-
ful slots that are not uniquely successful, i.e., they are adversarial
slots. So,

Proof of Lemma 9. Let ùëáconf = ùõæ. First, we prove safety by con-
tradiction. Suppose that for some honest nodes ùëñ, ùëó and ùë° ‚Ä≤ ‚â• ùë°
that dCùëñ (ùë°) ‚åàùëáconf ‚™ØÃ∏ dCùëó (ùë° ‚Ä≤) ‚åàùëáconf . We can assume that ùë° ‚â• ùõæ be-
cause otherwise dCùëñ (ùë°) ‚åàùëáconf = ‚àÖ and therefore dCùëñ (ùë°) ‚åàùëáconf ‚™Ø
dCùëó (ùë° ‚Ä≤) ‚åàùëáconf for all ùë° ‚Ä≤.

Consider all the uniquely successful slots ùë°1, ..., ùë°ùëö ‚àà (ùë° ‚àí ùõæ, ùë°]
with block ùëè ùëó proposed in slot ùë° ùëó . Suppose that ùëè ùëó ‚àà dCùëñ (ùë°) and
ùëè ùëó ‚àà dCùëó (ùë° ‚Ä≤). Then dCùëñ (ùë°) and dCùëó (ùë° ‚Ä≤) match up to ùëè ùëó . Since ùë° ùëó >
ùë° ‚àíùõæ, dCùëñ (ùë°) ‚åàùëáconf ‚™Ø dCùëó (ùë° ‚Ä≤). Also, ùë° ‚Ä≤ ‚â• ùë°, therefore dCùëñ (ùë°) ‚åàùëáconf ‚™Ø
dCùëó (ùë° ‚Ä≤) ‚åàùëáconf which is a contradiction to our assumption. There-
fore, for each ùëó = 1, ..., ùëö, either ùëè ùëó ‚àâ dCùëñ (ùë°) or ùëè ùëó ‚àâ dCùëó (ùë° ‚Ä≤).
This means that for all ùëó = 1, ..., ùëö, ùëè ùëó is not a great block. Due to
ShortPrefixesùêæ and Lemma 11, this also means that there are no
unique pivot slots in the interval (ùë° ‚àí ùõæ, ùë°], which is a contradiction
to FreqPivotsùõæ .

We next prove liveness. Assume a transaction tx is received by
all honest nodes before time ùë°. We know that there exists a unique
pivot slot ùë° ‚àó in the interval (ùë°, ùë° + ùõæ]. The honest block ùëè‚àó from ùë° ‚àó
or its prefix must contain tx since tx is seen by all honest nodes
at time ùë° < ùë° ‚àó. Moreover, ùëè‚àó is also a great block, i.e., ùëè‚àó ‚àà dCùëñ (ùë° ‚Ä≤)
for all honest nodes ùëñ and ùë° ‚Ä≤ ‚â• ùë° ‚àó. Therefore, tx ‚àà LOGùë° ‚Ä≤
for all
ùëñ
ùë° ‚Ä≤ ‚â• ùë° ‚àó + ùëáconf , which is at most ùë° + 2ùõæ.
‚ñ°

D.3 Proof of Lemma 10

D.3.1 Preliminaries.
Definition 7 (Pivot condition). The predicate PivotCondition(ùëü,ùë† ]
holds iff U (ùëü, ùë†] > A (ùëü, ùë†].

Note that Pivot(ùë°) holds iff ‚àÄ(ùëü, ùë†] ‚àã ùë°, PivotCondition(ùëü,ùë† ] ‚à®

(A (ùëü, ùë†] = 0) holds.

Definition 8 (Weak Pivot). Time slot ùë° satisfies WeakPivotùë§ (ùë°) iff
(26)
‚àÄ(ùëü, ùë†] ‚àã ùë°, ùë† ‚àí ùëü < ùë§ : PivotCondition(ùëü,ùë† ] ‚à® (A (ùëü, ùë†] = 0) .
Proposition 1. If ùëùU = 1
2
‚àÄ(ùëü, ùë†] : Pr (cid:2)¬¨PivotCondition(ùëü,ùë† ]
with ùõº ‚Ä≤

ùëù (1 + ùúñ1) for some ùúñ1 ‚àà (0, 1),

(cid:3) ‚â§ 2 exp (cid:0)‚àíùõº ‚Ä≤
1

ùëù (ùë† ‚àí ùëü )(cid:1) ,

and ùúÇ = 1/36.

(27)

1 = ùúÇùúñ2
1

|C‚Ä≤| ‚â§ |‚Ñé‚Ä≤| + A (ùëü, ùë†]

(23)

Proof. By a simple Chernoff bound for ùúñ > 0,

From Lemma 1,

ùêømin (ùë†) ‚â• ùêømin (ùëü ) + U (ùëü, ùë†] .
Note that ùêømin (ùë†) ‚â§ ùêøùëñ (ùë†) ‚àÄùëñ and |C‚Ä≤| = ùêøùëñ (ùë†) for some ùëñ. Also note
that ‚Ñé‚Ä≤ is from a uniquely successful slot ùëü and MaxDLùêæ holds, so
ùêømin (ùëü ) ‚â• |‚Ñé‚Ä≤|. Using the above observations with (23) and (24),
we get

(24)

Pr [B (ùëü, ùë†] ‚â• ùëù (ùë† ‚àí ùëü )(1 + ùúñ)] ‚â§ exp

Also, by a Chernoff bound for ùúñ ‚àà (0, 1),

(cid:18)

‚àí

ùúñ2ùëù (ùë† ‚àí ùëü )
2 + ùúñ

(cid:19)

.

(28)

Pr [U (ùëü, ùë†] ‚â§ ùëùU (ùë† ‚àí ùëü )(1 ‚àí ùúñ)] ‚â§ exp

By choosing ùúñ such that 1+ùúñ

(cid:18)

ùúñ2ùëùU (ùë† ‚àí ùëü )
2
1‚àíùúñ = 1 + ùúñ1, we obtain that

‚àí

(cid:19)

(29)

U (ùëü, ùë†] ‚â§ A (ùëü, ùë†]

(25)

U (ùëü, ùë†] > ùëùU (ùë† ‚àí ùëü )(1 ‚àí ùúñ)

where ùëü < ùë° ‚àó and ùë† ‚â• ùë° ‚àó. Since Pivot(ùë° ‚àó), this is a contradiction. ‚ñ°

Lemma 11 shows that the block from every unique pivot slot
stays in all honest nodes‚Äô downloaded longest chains thereafter.
Therefore, under FreqPivotsùõæ , every interval of ùõæ slots brings at
least one such block. To conclude with the proof of Lemma 9, one
needs to show that the occurrence of such blocks leads to safety
and liveness. This is done in Lemma 9.

=

=

1
2
1
2

ùëù (1 + ùúñ1)(ùë† ‚àí ùëü )(1 ‚àí ùúñ)
ùëù (ùë† ‚àí ùëü )(1 + ùúñ) > 1
2

B (ùëü, ùë†]

=‚áí U (ùëü, ùë†] > A (ùëü, ùë†] ,

except with probability

exp

(cid:18)

‚àí

ùúñ2ùëù (ùë† ‚àí ùëü )
2 + ùúñ

(cid:19)

+ exp

(cid:18)

‚àí

ùúñ2ùëùU (ùë† ‚àí ùëü )
2

(cid:19)

(30)

17

From 1+ùúñ
1‚àíùúñ = 1 + ùúñ1, we get ùúñ =
this probability is bounded by

ùúñ1
ùúñ1+2 ‚â•

ùúñ1
3

. Further using ùëùU > ùëù

2

,

2 exp

(cid:32) ùúñ2
1

(cid:33)

ùëù (ùë† ‚àí ùëü )
36

(31)

‚ñ°

Proposition 2.
ùëáh and ùë§ > 2 ln(
ùõº ‚Ä≤
1

If ùëùU = 1
2
‚àö
2ùëáh)
,
ùëù

ùëù (1 + ùúñ1), then for an execution horizon

Pr (cid:2)‚àÉ(ùëü, ùë†], ùë† ‚àí ùëü ‚â• ùë§ : ¬¨PivotCondition(ùëü,ùë† ]
h exp (cid:0)‚àíùõº ‚Ä≤

‚â§ 2ùëá 2

ùëùùë§ (cid:1) .

1

(cid:3)

(32)

Proof. Using a union bound and Proposition 1,

Pr (cid:2)‚àÉ(ùëü, ùë†], ùë† ‚àí ùëü ‚â• ùë§ : ¬¨PivotCondition(ùëü,ùë† ]
Pr (cid:2)¬¨PivotCondition(ùëü,ùë† ]

‚àëÔ∏Å

(cid:3)

‚â§

(ùëü,ùë† ],ùë†‚àíùëü ‚â•ùë§

‚â§ 2ùëá 2

h exp(‚àíùõº ‚Ä≤

1

ùëùùë§).

(cid:3)

‚ñ°

Proposition 3. If ùëùU = 1
2
2ùëáh)
ùë§ > 2 ln(
ùõº ‚Ä≤
ùëù
1

‚àö

,

ùëù (1 + ùúñ1), then for a time horizon ùëáh and

Pr [‚àÉùë° : WeakPivotùë§ (ùë°) ‚àß ¬¨Pivot(ùë°)]

‚â§ 2ùëá 2

h exp(‚àíùõº ‚Ä≤

1

ùëùùë§).

(33)

2ùëáh)
Proof. If some ùë° is a weak pivot (with ùë§ ‚â• 2 ln(
ùõº ‚Ä≤
ùëù
1
not a pivot, then ‚àÉ(ùëü, ùë†] ‚àã ùë° with ùë† ‚àí ùëü ‚â• ùë§ such that
¬¨PivotCondition(ùëü,ùë† ] . But the probability for this is bounded ac-
‚ñ°
cordingly by Proposition 2.

) and ùë° is

‚àö

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

‚â§

‚â§

‚â§

=

=

‚â§

‚â§

2ùë£
‚àëÔ∏Å

(2(ùë¢ ‚àí ùë£) ‚àí 1)2ùëí‚àíùõº ‚Ä≤

1

ùëùùë¢ +

ùë§‚àí1
‚àëÔ∏Å

ùë¢=2ùë£+1

ùë¢2ùëí‚àíùõº ‚Ä≤

1

ùëùùë¢

ùë¢=ùë£+1
ùë£
‚àëÔ∏Å

2(2ùëó ‚àí 1)ùëí‚àíùõº ‚Ä≤

1

ùëù (ùë£+ùëó) +

ùëò=1
ùë£
‚àëÔ∏Å

2(2ùëó ‚àí 1)ùëí‚àíùõº ‚Ä≤

1

ùëù (ùë£+ùëó) +

ùë§‚àí1
‚àëÔ∏Å

ùë¢=2ùë£+1
‚àû
‚àëÔ∏Å

2ùë¢ùëí‚àíùõº ‚Ä≤

1

ùëùùë¢

2ùë¢ùëí‚àíùõº ‚Ä≤

1

ùëùùë¢

ùëò=1
2ùëí‚àíùõº ‚Ä≤

1

ùëù (ùë£+1) (1 ‚àí (2ùë£ + 1)ùëí‚àíùõº ‚Ä≤

ùë¢=2ùë£+1
ùëùùë£)

1

ùëùùë£)

1

+

+

1

1

4ùëí‚àíùõº ‚Ä≤

1 ‚àí ùëí‚àíùõº ‚Ä≤
ùëù
ùëù (ùë£+2) (1 ‚àí ùëí‚àíùõº ‚Ä≤
(1 ‚àí ùëí‚àíùõº ‚Ä≤
2(2ùë£ + 1)ùëí‚àíùõº ‚Ä≤
1 ‚àí ùëí‚àíùõº ‚Ä≤
ùëù (ùë£+1)

ùëù )2
1
ùëù (2ùë£+1)

ùëù
4ùëí‚àíùõº ‚Ä≤

1

1

1

1

ùëù +
(cid:32)

1
ùëù (ùë£+1)

2ùëí‚àíùõº ‚Ä≤
1 ‚àí ùëí‚àíùõº ‚Ä≤
2ùëí‚àíùõº ‚Ä≤
1 ‚àí ùëí‚àíùõº ‚Ä≤
2ùëí‚àíùõº ‚Ä≤

1

1

1 +

ùëù

1

1

(1 ‚àí ùëí‚àíùõº ‚Ä≤

ùëùùë£ (1 + ùëí‚àíùõº ‚Ä≤
ùëù )2
(cid:18)

1

ùëù (2ùë£+2)
ùëù )2
ùëù (2ùë£+2)

1

1

+

2ùëí‚àíùõº ‚Ä≤
(1 ‚àí ùëí‚àíùõº ‚Ä≤
ùëù (ùë£+2) ‚àí 2ùëí‚àíùõº ‚Ä≤
(1 ‚àí ùëí‚àíùõº ‚Ä≤
ùëù )2
(cid:33)
ùëù

1

1

1

2ùëí‚àíùõº ‚Ä≤
1 ‚àí ùëí‚àíùõº ‚Ä≤
ùëù )

1

ùëù

(37)

4(1+ùëí‚àíùõº‚Ä≤
We may choose ùë£ = 1
, so that Pr [¬¨ùê∏2] ‚â§ 1
(1‚àíùëí‚àíùõº‚Ä≤
ùõº ‚Ä≤
2
1
It is easy to see that Pr [ùê∏2 | ùê∏1 ‚à© {Unique(ùë°)}] ‚â• Pr [ùê∏2 | ùê∏1] ‚â•

ùëù )
1
ùëù ) 2

ùëù ln

.

1

(cid:19)

Pr [ùê∏2].
Pr [WeakPivotùë§ (ùë°) | Unique(ùë°)] ‚â• Pr [ùê∏1 ‚à© ùê∏2 | Unique(ùë°)]

‚â• Pr [ùê∏1 | Unique(ùë°)] Pr [ùê∏2]

‚â•

1
2

(1 ‚àí ùëùA)2ùë£‚àí1.

‚ñ°

ùëù (1 + ùúñ1), then for horizon ùëáh and ùë§ >

Proposition 4. If ùëùU = 1
2

ùëù (1 + ùúñ1), then for time horizon ùëáh,

for the given choice of ùë£.

‚àÄùë° :

Pr [WeakPivotùë§ (ùë°) | Unique(ùë°)] ‚â• ùëù1
(cid:18)

where ùëù1 = 1

2 (1 ‚àí ùëùA)2ùë£‚àí1 > 0 and ùë§

2

> ùë£ = 1
ùõº ‚Ä≤
1

ùëù ln

(34)

4(1+ùëí‚àíùõº‚Ä≤
(1‚àíùëí‚àíùõº‚Ä≤

ùëù )
1
ùëù ) 2

1

(cid:19)

.

Proposition 5.
(cid:18)
4(1+ùëí‚àíùõº‚Ä≤
(1‚àíùëí‚àíùõº‚Ä≤

2
ùëù ln
ùõº ‚Ä≤
1

If ùëùU = 1
2
ùëù )
1
,
ùëù ) 2

(cid:19)

1

Proof. For ùë£ < ùë§/2 to be determined later, consider the events
(35)

ùê∏1 ‚âú {A (ùë° ‚àí ùë£, ùë° + ùë£] = 0},
ùê∏2 ‚âú {‚àÄ(ùëü, ùë†] ‚àã ùë°, ùë† ‚àí ùëü < ùë§, (ùëü, ùë†] ‚àâ (ùë° ‚àí ùë£, ùë° + ùë£] :

PivotCondition(ùëü,ùë† ] }.

(36)

Note that, ùê∏1 ‚à© ùê∏2 ‚äÜ {WeakPivotùë§ (ùë°)} and Pr [ùê∏1 | Unique(ùë°)] =
(1 ‚àí ùëùA)2ùë£‚àí1.

For bounding Pr [¬¨ùê∏2], we will use a union bound by carefully
counting the number of intervals (ùëü, ùë†] ‚àã ùë° such that ùë† ‚àí ùëü < ùë§
and (ùëü, ùë†] ‚àâ (ùë° ‚àí ùë£, ùë° + ùë£]. Let ùë¢ = ùë† ‚àí ùëü . For ùë¢ ‚â§ ùë£, note that
(ùëü, ùë†] ‚àã ùë° implies that (ùëü, ùë†] ‚àà (ùë° ‚àí ùë£, ùë° + ùë£]. One can check that for
ùë£ + 1 ‚â§ ùë¢ ‚â§ 2ùë£, there are 2(ùë¢ ‚àí ùë£) ‚àí 1 intervals (ùëü, ùë†] ‚àã ùë° such that
(ùëü, ùë†] ‚àâ (ùë° ‚àí ùë£, ùë° + ùë£]. For 2ùë£ + 1 ‚â§ ùë¢ < ùë§, all intervals (ùëü, ùë†] ‚àã ùë°
are such that (ùëü, ùë†] ‚àâ (ùë° ‚àí ùë£, ùë° + ùë£], and there are ùë¢ such intervals.
Therefore, from Proposition 1 and a union bound,

Pr [¬¨ùê∏2] ‚â§

ùë§‚àí1
‚àëÔ∏Å

ùë¢=ùë£+1

‚àëÔ∏Å

(ùëü,ùë† ] ‚àãùë° :
ùë†‚àíùëü =ùë¢‚àß
(ùëü,ùë† ]‚àâ(ùë° ‚àíùë£,ùë° +ùë£ ]

Pr [¬¨PivotCondition(ùëü, ùë†]]

‚àÄùë° : Pr (cid:2)‚àÉùë° ‚Ä≤ ‚àà (ùë°, ùë° + ùõæ] : WeakPivotùë§ (ùë° ‚Ä≤) ‚àß Unique(ùë° ‚Ä≤)(cid:3)

‚â• 1 ‚àí exp(‚àíùõº ‚Ä≤‚Ä≤
1

ùõæ/ùë§),

with ùõº ‚Ä≤‚Ä≤

1 =

ùëù1ùëùU
2

.

(38)

Proof. Let ùëò be the largest integer such that ùõæ ‚â• 2ùë§ùëò. For

ùëñ = 0, ..., (ùëò ‚àí 1), define ùë°ùëñ = ùë° + (2ùëñ + 1)ùë§ and

ùê∏ùëñ ‚âú {WeakPivotùë§ (ùë°ùëñ ) ‚àß Unique(ùë°ùëñ )}
ùê∏ ‚âú {‚àÉùë° ‚Ä≤ ‚àà (ùë°, ùë° + ùõæ] : WeakPivotùë§ (ùë° ‚Ä≤) ‚àß Unique(ùë° ‚Ä≤)}.

(39)

(40)

Thus, we have (cid:208)ùëò‚àí1
ùëñ=0

pendent. Hence,

ùê∏ùëñ ‚äÜ ùê∏, and by construction ùê∏ùëñ are inde-

Pr [ùê∏] ‚â• Pr

(cid:34)ùëò‚àí1
(cid:216)

(cid:35)

ùê∏ùëñ

= 1 ‚àí Pr

(cid:34)ùëò‚àí1
(cid:217)

(cid:35)

¬¨ùê∏ùëñ

ùëñ=0

ùëñ=0
‚â• 1 ‚àí (1 ‚àí ùëù1ùëùU)ùëò
‚â• 1 ‚àí exp(‚àíùëù1ùëùUùëò)
= 1 ‚àí exp(‚àíùëù1ùëùUùõæ/2ùë§),

where we have used Proposition 4.

18

(41)

‚ñ°

Longest Chain Consensus Under Bandwidth Constraint

Proposition 6.
(cid:18)
4(1+ùëí‚àíùõº‚Ä≤
(1‚àíùëí‚àíùõº‚Ä≤

2
ùëù ln
ùõº ‚Ä≤
1

If ùëùU = 1
2
ùëù )
and ùõæ > ùë§ ln(ùëáh)
1
ùëù ) 2

ùõº ‚Ä≤‚Ä≤
1

(cid:19)

1

,

ùëù (1 + ùúñ1), then for horizon ùëáh, ùë§ >

Pr (cid:2)‚àÄùë° : ‚àÉùë° ‚Ä≤ ‚àà (ùë°, ùë° + ùõæ] : WeakPivotùë§ (ùë° ‚Ä≤) ‚àß Unique(ùë° ‚Ä≤)(cid:3)

‚â• 1 ‚àí ùëáh exp(‚àíùõº ‚Ä≤‚Ä≤
1

ùõæ/ùë§).

(42)

Proof. By a union bound over all ùëáh possible time slots, and
‚ñ°

using Proposition 5.

D.3.2 Proof of Lemma 10.

Proof. Finally, to prove Lemma 10, let
ùê∏1 ‚âú {‚àÄùë° : ‚àÉùë° ‚Ä≤ ‚àà (ùë°, ùë° + ùõæ] : WeakPivotùë§ (ùë° ‚Ä≤) ‚àß Unique(ùë° ‚Ä≤)}
ùê∏2 ‚âú {‚àÄùë° : WeakPivotùë§ (ùë°) ‚áí Pivot(ùë°)}
ùê∏ ‚âú {‚àÄùë° : ‚àÉùë° ‚Ä≤ ‚àà (ùë°, ùë° + ùõæ] : Pivot(ùë° ‚Ä≤) ‚àß Unique(ùë° ‚Ä≤)}.

Note that ùê∏1 ‚à© ùê∏2 ‚äÜ ùê∏. Then we apply a union bound on the
probabilities from Propositions 6 and 3.

1

1

ùëù

‚àö

ùëí‚àíùõº ‚Ä≤

Pr [¬¨ùê∏] ‚â§ Pr [¬¨ùê∏1] + Pr [¬¨ùê∏2] ‚â§ 2ùëá 2
h

Let ùúÖ ‚Ä≤ = ùúÖ + lnùëáh. Pick ùë§ such that ùë§ = 2 ln(

ùëùùë§ + ùëáhùëí‚àíùõº ‚Ä≤‚Ä≤
2ùëáh)+Œ© (ùúÖ)
. This
ùõº ‚Ä≤
1
ùëùùë§ corresponding to having
ensures that the probability 2ùëá 2
h
more adversarial than honest slots in some interval of size at least
ùë§, is negl(ùúÖ).

ùõæ /ùë§ .(43)

ùëí‚àíùõº ‚Ä≤

Finally, we pick ùõæ so that the probability ùëáhùëí‚àíùõº ‚Ä≤‚Ä≤

ùõæ /ùë§ correspond-
ing to not finding a pivot slot in some interval of ùõæ slots, is negl(ùúÖ).
Therefore we get ùõæ ‚â• ln(ùëáh)+Œ© (ùúÖ)
ùë§. Combining these, we have
. Choose ùõº1 = ùõº ‚Ä≤
1

Œ© ( (ln(ùëáh)+ùúÖ) 2)
ùõº ‚Ä≤‚Ä≤
ùõº ‚Ä≤
1
1

ùõº ‚Ä≤‚Ä≤
1

ùõæ ‚â•

ùõº ‚Ä≤‚Ä≤
1

‚ñ°

ùëù

1

1

D.4 Proof of Lemma 3

Proof. Define the event ùêπùë° as

max
ùëü <ùë° : Unique(ùëü )‚àß( A(ùëü,ùë° ] ‚â•U(ùëü,ùë° ])

A (ùëü, ùë°] ‚â• ùêæ .

(44)

This event can be equivalently expressed as

‚àÉùëü < ùë° : Unique(ùëü ) ‚àß (A (ùëü, ùë°] ‚â• U (ùëü, ùë°]) ‚àß (A (ùëü, ùë°] ‚â• ùêæ).
The event {¬¨ShortPrefixesùêæ } can be expressed as (cid:208)ùë° ‚â§ùëáh

(45)

ùêπùë° .

Then for some fixed ùëá ,

Pr [ùêπùë° ] ‚â§ Pr

(cid:34)ùë° ‚àí1
(cid:216)

ùëü =0

{A (ùëü, ùë°] ‚â• U (ùëü, ùë°] ‚àß A (ùëü, ùë°] ‚â• ùêæ }

(cid:35)

Pr [A (ùëü, ùë°] ‚â• U (ùëü, ùë°]] +

ùë° ‚àí1
‚àëÔ∏Å

Pr [A (ùëü, ùë°] ‚â• ùêæ]

ùë° ‚àíùëá
‚àëÔ∏Å

ùëü =0
‚àû
‚àëÔ∏Å

‚â§

‚â§

2 exp (cid:0)‚àíùõº ‚Ä≤
1

ùëùùëò(cid:1) + ùëá exp

=

ùëò=ùëá
2 exp(‚àíùõº ‚Ä≤
1
1 ‚àí exp(‚àíùõº ‚Ä≤
1
‚â§ 2ùëá exp (‚àíùõº2ùëùùëá ) ,

ùëùùëá )
ùëù)

(cid:32)

‚àí

+ ùëá exp

(cid:32)

‚àí

ùëü =ùë° ‚àíùëá
ùúñ2
2
2 + ùúñ2
ùúñ2
2
2 + ùúñ2

ùëùùê¥ùëá

(cid:33)

ùëùùê¥ùëá

(cid:33)

2

1‚àíexp(‚àíùõº ‚Ä≤
1

ùëùA
for ùëá ‚â•
ùëù
union bound over the execution horizon ùëáh, we get
Pr [¬¨ShortPrefixesùêæ ] ‚â§ 2ùëáhùëá exp(‚àíùõº2ùëùùëá ) ‚â§ 2ùëá 2

and ùõº2 = min

, ùúñ 2
2
ùúñ2+2

ùëù)

(cid:110)
ùõº ‚Ä≤
1

(46)
(cid:111). By using a

h exp(‚àíùõº2ùëùùëá ) (47)
19

We then set ùëá = 2 ln(

‚àö

2ùëáh)+Œ© (ùúÖ)
ùõº2ùëù

to make this probability negl(ùúÖ).
‚ñ°

D.5 Proof of Lemma 4

Proof. Let ùë°1, ..., ùë°ùëö be the uniquely successful slots in (0,ùëáh].

Let ùëè ùëó be the block from slot ùë° ùëó for some 1 ‚â§ ùëó ‚â§ ùëö.

For induction, assume that MaxDLùêæ,(0,ùë° ùëó ‚àí1] holds. Using this,
we will show that MaxDLùêæ,(0,ùë° ùëó +1‚àí1] holds. For the base case, this
is true for ùëó = 1 since ùë°1 is the first uniquely successful slot by
definition. Suppose that there is a chain C‚Ä≤ in the header tree of
an honest node in slot ùë° ùëó such that |C‚Ä≤| ‚â• |ùëè ùëó |. Note that the tip
of C‚Ä≤ can not be a unique block because unique blocks have in-
creasing heights as per Lemma 1. Therefore the tip of C‚Ä≤ is from an
adversarial slot. Consider such a chain C‚Ä≤ ending in a block from
an adversarial slot ùë† ùëó ‚â§ ùë° ùëó . Let ùëü ùëó be the last uniquely successful
slot such that the block ùëè ‚Ä≤

ùëó from that slot is in C‚Ä≤. Then,

|C‚Ä≤| ‚â§ |ùëè ‚Ä≤

ùëó | + A (cid:0)ùëü ùëó , ùë† ùëó (cid:3) .

(48)

From the assumption of MaxDLùêæ,(0,ùë° ùëó ‚àí1] and part (1) of Lemma 1,
(49)

|ùëè ùëó | ‚â• |ùëè ‚Ä≤

ùëó | + U (cid:0)ùëü ùëó , ùë° ùëó (cid:3) .

Since |C‚Ä≤| ‚â• |ùëè ùëó |, this would mean that A (cid:0)ùëü ùëó , ùë† ùëó (cid:3) ‚â• U (cid:0)ùëü ùëó , ùë† ùëó (cid:3). As
a block from a uniquely successful slot, ùëè ‚Ä≤
ùëó was downloaded by all
honest nodes within slot ùëü ùëó . Therefore, there are at most A (cid:0)ùëü ùëó , ùë† ùëó (cid:3)
blocks on the chain C‚Ä≤ that are yet to be downloaded. Therefore
the number of blocks to be downloaded by each honest node on C‚Ä≤
is at most

max
ùëü ùëó <ùë† ùëó : Unique(ùëü ùëó )‚àß( A(ùëü ùëó ,ùë† ùëó ] ‚â•U(ùëü ùëó ,ùë° ùëó ])

A (cid:0)ùëü ùëó , ùë† ùëó (cid:3) = ùëäùë† ùëó ,ùë° ùëó .

(50)

Next, we count the number of such chains C‚Ä≤ with distinct block
production opportunities at the tip. Due to the equivocation avoid-
ance policy, the adversary can make honest nodes download at
most one chain per adversarial block production opportunity in
slots ùë† ùëó ‚â§ ùë° ùëó . The total number of blocks to be downloaded in all
these chains combined is (cid:205)ùë† ùëó <ùë° ùëó

ùê¥ùë† ùëóùëäùë† ùëó ,ùë° ùëó .

Finally, from the proof of Lemma 2, we note that the prefix of ùëè ùëó
has at most ùëäùë° ùëó ‚àí1,ùë° ùëó ‚àí1 blocks that need to be downloaded by any
honest node. Therefore, the total number of blocks that any honest
node needs to download before downloading ùëè ùëó is at most

ùëäùë° ùëó ‚àí1,ùë° ùëó ‚àí1 +

‚àëÔ∏Å

ùë† ùëó ‚â§ùë° ùëó

ùê¥ùëü ùëóùëäùë† ùëó ,ùë° ùëó .

(51)

From the definition of FewLongChainsùêæ , this is less than ùêæ. There-
fore, every honest node can download ùëè ùëó within the time slot ùë° ùëó . This
completes the induction step by showing that MaxDLùêæ,(0,ùë° ùëó +1‚àí1] .
‚ñ°
For ùëó = ùëö, we conclude with MaxDLùêæ as required.

D.6 Proof of Lemma 5

Proof. From Lemma 3, we already know that for ùëÅ = ùëùAùëá (1 +
, 2 ln(

(cid:111), we have

2ùëáh)

‚àö

(cid:110)

2

ùúñ2) and ùëá > max

1‚àíexp(‚àíùõº ‚Ä≤
1

ùëù)
Pr (cid:2)¬¨(‚àÄùë° ‚â§ ùëáh : ùëäùë°,ùë° < ùëÅ )(cid:3) ‚â§ 2ùëá 2
h

ùõº2ùëù

ùëí‚àíùõº2ùëùùëá .

(52)

It is easy to see that for any given sample path (i.e. realization of
Eùúå,ùõΩ,ùëáh ) and any ùë† ‚â§ ùë°, ùëäùë†,ùë° ‚â§ ùëäùë°,ùë° . Next, we can show that there

exists some ùëáb such that ùëäùë†,ùë° = 0 for all ùë† < ùë° ‚àí ùëáb and for all ùë°, so
that we have the following with overwhelming probability:

ùëäùë° ‚àí1,ùë° ‚àí1 +

‚àëÔ∏Å

ùë† ‚â§ùë°

ùê¥ùë†ùëäùë†,ùë° ‚â§ ùëÅ + ùëÅùëábùõΩùúå (1 + ùúñ).

(53)

(cid:16)

This is because in any ùëáb slots, there are at most ùëábùõΩùúå (1 + ùúñ) ad-
versarial block production opportunities with probability at least
(cid:17) (through a Chernoff bound and union bound).
1‚àíùëáh exp

‚àí

ùúñ 2ùõΩùúåùëáb
ùúñ+2

To show that ùëäùë†,ùë° = 0 for all ùë† < ùë° ‚àí ùëáb for a fixed ùë°,
Pr (cid:2)‚àÉùë† < ùë° ‚àí ùëáb : ùëäùë†,ùë° > 0(cid:3)
‚â§Pr [‚àÉùë† < ùë° ‚àí ùëáb, ‚àÉùëü < ùë† : A (ùëü, ùë†] ‚â• U (ùëü, ùë°]]
(56)
‚â§Pr [‚àÉùëü < ùë° ‚àí ùëáb : A (ùëü, ùë° ‚àí ùëáb] ‚â• U (ùëü, ùë°]]
‚â§Pr [‚àÉùëü < ùë° ‚àí ùëáb : A (ùëü, ùë° ‚àí ùëáb] ‚â• U (ùëü, ùë° ‚àí ùëáb] + U (ùë° ‚àí ùëáb, ùë°]] (57)
(58)
‚â§Pr [‚àÉùëü < ùë° ‚àí ùëáb : A (ùëü, ùë° ‚àí ùëáb] ‚â• U (ùëü, ùë° ‚àí ùëáb] + ùêø]

(54)

(55)

+ Pr [U (ùë° ‚àí ùëáb, ùë°] < ùêø]

(59)

where we choose ùêø = ùëùUùëáb (1 ‚àí ùúñ). The second term is bounded by
a Chernoff bound

Pr [U (ùë° ‚àí ùëáb, ùë°] < ùêø] ‚â§exp

(cid:18)

‚àí

ùúñ2ùëùUùëáb
2

(cid:19)

.

(60)

For calculating the first term, let

ùëãùëõ = ùêø + U (ùë° ‚àí ùëáb ‚àí ùëõ, ùë° ‚àí ùëáb] ‚àí A (ùë° ‚àí ùëáb ‚àí ùëõ, ùë° ‚àí ùëáb]
for ùëõ ‚â• 0 be a random walk. Let ùëùùëô = Pr [‚àÉùëõ : ùëãùëõ ‚â§ 0 | ùëã0 = ùëô], i.e.
the probability that the random walk ever hits 0 after starting from
ùëô. We can observe that ùëù1 = 1 ‚àí ùëùU + ùëùUùëù2. We can also note that
due to the translation invariance of the random walk,
ùëù2 = Pr [‚àÉùëõ : ùëãùëõ ‚â§ 1 | ùëã0 = 2] Pr (cid:2)‚àÉùëõ > ùëõ1 : ùëãùëõ1 ‚â§ 0 | ùëãùëõ1 = 1(cid:3)

= Pr [‚àÉùëõ : ùëãùëõ ‚â§ 0 | ùëã0 = 1]2 = ùëù2
1

.

Therefore, we obtain ùëù1 = 1‚àíùëùU
ùëùU
Finally, we note using the same logic as above that ùëùùêø = ùëùùêø
(cid:16) 1‚àíùëùU
ùëùU
Therefore, we have

by solving ùëù1 = 1 ‚àí ùëùU + ùëùUùëù2
1
1 =
which is the required probability in the first term in (58).

(cid:17)ùêø

.

Pr (cid:2)‚àÉùë† ‚â§ ùë° ‚àí ùëáb : ùëäùë†,ùë° > 0(cid:3) ‚â§

(cid:19)ùëùUùëáb (1‚àíùúñ)

(cid:18) 1 ‚àí ùëùU
ùëùU

+ exp

(cid:19)

(cid:18)

‚àí

ùúñ2ùëùUùëáb
2

Finally, by a union bound over the required probabilities, we have
for ùêæ = ùëùAùëá (1 + ùõΩùúåùëáb (1 + ùúñ))(1 + ùúñ2),
(cid:18) 1 ‚àí ùëùU
ùëùU
ùúñ2ùõΩùúåùëáb
ùúñ + 2

Pr [¬¨FewLongChainsùêæ ] ‚â§ ùëáh

ùúñ2ùëùUùëáb
2

(cid:19)ùëùUùëáb (1‚àíùúñ)

+ ùëáh exp

+ùëáh exp

+ 2ùëá 2

‚àí

‚àí

(cid:18)

(cid:18)

(cid:19)

(cid:19)

(62)

h exp(‚àíùõº2ùëùùëá ) (63)
(64)

‚â§ 5ùëá 2

h exp(‚àíùõº3ùëùùëáb).
Here, we choose ùëáb = ùëá and
(cid:26)
ùëùU (1 ‚àí ùúñ)
ùõº2,
ùëù

ùõº3 = max

ln

(cid:18) ùëùU
1 ‚àí ùëùU

(cid:19)

,

ùúñ2ùëùU
2ùëù

,

ùúñ2ùõΩùúå
(ùúñ + 2)ùëù

(cid:27)

.(65)

Finally, we set ùëáb = 2 ln(

ability is negligible.

‚àö

5ùëáh)+Œ© (ùúÖ)
ùõº3ùëù

so that the required prob-

‚ñ°

20

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

ùëùU

U

1 ‚àí ùëù
ùëùU

ùëùA

I

ùëùU

ùëùA

1 ‚àí ùëù

A

1 ‚àí ùëùU

Figure 13: An upper bound on the bandwidth utilization
of our protocol can be calculated from the stationary
distribution of this Markov chain

D.7 Proofs for

Throughput and Bandwidth Consumption

D.7.1 Proof of Lemma 6.

Proof. Due to Lemma 1, in any interval of slots (ùë°1, ùë°2], the
downloaded longest chain of every honest node grows by at least
U (ùë°1, ùë°2] (even though all blocks on the chain may not be honest).
Therefore, corresponding to the interval (ùë°1, ùë°2] with ùë°2 ‚â• ùë°1 + ùëá ,
at least ùëùUùëá (1 ‚àí ùúñ) blocks are added to every node‚Äôs downloaded
longest chain with probability

Pr [U (ùë°1, ùë°2] ‚â• ùëùUùëá (1 ‚àí ùúñ)]

‚â• Pr [U (ùë°1, ùë°2] ‚â• ùëùU (ùë°2 ‚àí ùë°1)(1 ‚àí ùúñ)] ‚â• 1 ‚àí exp

(cid:19)

ùëùUùëá

(cid:18) ùúñ2
2

. (66)

Now let ùëÅ = ùëùUùëá (1 ‚àí ùúñ). Consider any ùëÅ consecutive blocks in a
valid blockchain. Let ùë° ‚Ä≤
and ùë° ‚Ä≤
be the time slots corresponding to
1
2
the first and last blocks respectively in this set, and let ùëá ‚Ä≤ = ùë° ‚Ä≤
2 ‚àí ùë° ‚Ä≤
.
1
ùëÅ
From the above probability bound, we have ùëá ‚Ä≤ ‚â§ ùëá =
.
ùëùU (1‚àíùúñ)
2+ùúñ‚Ä≤ ùëùAùëá ‚Ä≤(cid:17), there are at
‚àí ùúñ‚Ä≤2
Also, with probability at least 1 ‚àí exp
most ùëùAùëá ‚Ä≤(1 + ùúñ ‚Ä≤) adversarial slots in (ùë° ‚Ä≤
, ùë° ‚Ä≤
2], hence there are at
1
most ùëùAùëá ‚Ä≤(1 + ùúñ ‚Ä≤) adversarial blocks in the ùëÅ consecutive blocks.
Therefore, corresponding to every interval (ùë°1, ùë°2], there are at
least ùëùUùëá (1 ‚àí ùúñ) ‚àí ùëùAùëá (1 + ùúñ ‚Ä≤) = (ùëùU ‚àí ùëùA)ùëá (1 ‚àí ùúñ4) honest
blocks in any node‚Äôs downloaded longest chain with probability
at least 1 ‚àí exp(‚àíùõº4ùëá ) for some constant ùõº4. Finally, we note that
‚ñ°
ùúÉ = ùëùU ‚àí ùëùA = 2ùëùU ‚àí ùëù.

(cid:16)

(61)

D.7.2 Proof of Lemma 7.

Proof. Consider time slots ùë°1 and ùë°2 ‚â• ùë°1 + ùëá . Due to the safety
ùë°1
ùë°2
of Œ†ùúå,ùúè,ùëáconf , we know that LOG
ùëñ‚Ä≤ for any honest nodes
ùëñ ‚™Ø LOG
ùë°1
ùëñ must have a time slot ùë° ‚Ä≤
ùëñ, ùëñ ‚Ä≤. The last block in LOG
1 ‚â• ùë°1 ‚àí 2ùëáconf
because between ùë°1 ‚àí 2ùëáconf and ùë°1 ‚àí ùëáconf , there is at least one
ùë°1
unique pivot slot which contributes a block to LOG
. Therefore
ùëñ
ùë°2
ùë°1
ùëñ contains only blocks with time slots in the interval
ùëñ‚Ä≤ \ LOG
LOG
2] where ùë° ‚Ä≤
(ùë° ‚Ä≤
, ùë° ‚Ä≤
2 = ùë°2 ‚àí ùëáconf . Note that blocks in the confirmed
1
chain must have increasing time slots, so their number is limited by
(cid:3). The average
the number of slots with block proposal, i.e. B (cid:0)ùë° ‚Ä≤
, ùë° ‚Ä≤
1
2
number of slots with block proposal in the interval (ùë° ‚Ä≤
2] is ùëù (ùë° ‚Ä≤
, ùë° ‚Ä≤
2 ‚àí
1
ùë° ‚Ä≤
1) ‚â§ ùëù (ùë°2 ‚àí ùë°1 + ùëáconf ) = ùëù (ùëá + ùëáconf ). Then by a Chernoff bound,
(67)

(cid:3) > ùëùùëá (1 + ùúñ5)(cid:3) ‚â§ exp (‚àíùõº5ùëá )
for sufficiently large ùëá > ùëáconf and some constant ùõº5.

Pr (cid:2)B (cid:0)ùë° ‚Ä≤
1

, ùë° ‚Ä≤
2

‚ñ°

Longest Chain Consensus Under Bandwidth Constraint

D.7.3 Proof of Lemma 8.

Proof. Consider the Markov chain shown in Figure 13 with
three states‚ÄîU corresponding to a uniquely successful slot, I cor-
responding to a slot without a block proposal such that the most
recent block proposal was a uniquely successful slot, and A corre-
sponding to adversarial slots or slots without block proposals such
that the most recent block proposal was an adversarial slot.

ùúãI =

ùúãU = ùëùU,

The stationary distribution of this Markov chain is
ùëùA
ùëù

ùëùU (1 ‚àí ùëù)
ùëù
Note that in time slots corresponding to the I (idle) state, there
are no fresh blocks to be downloaded because the most recent block
proposal was a unique honest block which was downloaded within
1 slot. Therefore, on average, in ùúôidle fraction of time slots, every
honest node‚Äôs bandwidth remains idle, where

ùúãA =

(68)

,

.

ùúôidle ‚â• ùúãI =

ùëùU (1 ‚àí ùëù)
ùëù

(1 ‚àí ùëù)(1 + ùúñ1)

=

‚â•

1
2
(cid:18) 1 ‚àí ùëù
2

(cid:19)

.

(69)

(For ùúñ1, see the proof of Theorem 1.) Finally, by a Chernoff bound,
the probability that for a given ùë°1, ùë°2, there are at least ùúôidleùëá (1 ‚àí
ùúñ6) slots in the I state in the interval (ùë°1, ùë°2] is at least 1‚àíexp

‚àí

(cid:16)

ùúñ 2
6
2

ùúôidleùëá
‚ñ°

E SECURITY OF PARALLEL CHAINS
The below security theorem holds for any download rule which
satisfies the requirement in Theorem 1, and in addition leaves a frac-
tion ùúôidle ‚àà (0, 1) of the total bandwidth unutilized (cf. Lemma 8).
The latter requirement can be easily achieved for any download rule
for any desired ùúôidle ‚àà (0, 1) by increasing the time slot duration
by a factor of
and only downloading blocks in the first ùúôidle
fraction of the time slot.

1
ùúôidle

Also note that the below theorem holds under a static corruption
adversary (i.e., the adversary decides which nodes to corrupt before
the randomness of the protocol is drawn).

Theorem 2. For all ùêæ ‚àà N and download rules D such that

(cid:104)

Pr

Eùúå,ùõΩ,ùëáh : ¬¨MaxDLùêæ (Eùúå,ùõΩ,ùëáh, D)

(cid:105)

‚â§ negl(ùúÖ),

(70)

2

if (1‚àí ùõΩ)ùúåùëí‚àíùúå = 1‚àíùëí‚àíùúå
(1+ùúñ1) for some ùúñ1 ‚àà (0, 1), ùúè = Œ©(ùúÖ +lnùëáh),
ùëáconf = Œ©((ùúÖ + lnùëáh)2), Lemma 8 holds for some ùúôidle ‚àà (0, 1), and
with the
ùëö = 1 +
download rule D is secure with parameter ùëálive = Œ©((ùúÖ + lnùëáh)2).

ùê∂ùúè (1 ‚àí ùúñ7), then the protocol Œ†ùúå,ùúè,ùëáconf,ùëö

ùúôidle
ùúôp

pc

Proof. Consider a particular protocol instance Œ†idx. Define
dCùëñ,idx to be the longest downloaded chain of node ùëñ for proto-
col instance Œ†idx. From Theorem 1, for the given ùúå, ùúè and ùëáconf = ùõæ,
each protocol instance Œ†idx satisfies safety and liveness with re-
spect to the ledger defined by dCùëñ,idx (ùë°) ‚åàùëáconf and for nodes ùëñ for
which Œ†idx is the primary chain, expect with probability negl(ùúÖ).
By a union bound, safety and liveness for each protocol instance
holds over ùëö = poly(ùúÖ) protocol instances as well.

21

(cid:17).

Due to safety of Œ†idx, dCùëñ,idx (ùë°) ‚åàùëáconf ‚™Ø dCùëó,idx (ùë° ‚Ä≤) ‚åàùëáconf or
dCùëó,idx (ùë° ‚Ä≤) ‚åàùëáconf ‚™Ø dCùëñ,idx (ùë°) ‚åàùëáconf for all time slots ùë°, ùë° ‚Ä≤ and all
honest nodes ùëñ, ùëó for which Œ†idx is the primary chain. However,
this holds even if Œ†idx is not the primary chain for node ùëñ or ùëó
because such nodes receive all block headers, determine the longest
header chain based on them, and then download its confirmed
prefix. More concretely, an adversary that pushes an inconsistent
longest header chain to a node ùëó for which Œ†idx is a secondary
chain, can also do so with headers and contents for a node ùëó ‚Ä≤ for
which Œ†idx is the primary chain, thus causing a safety violation,
which contradicts the earlier observation. Since all nodes have con-
sistent confirmed chains (i.e. dCùëñ,idx (ùë°) ‚åàùëáconf ‚™Ø dCùëó,idx (ùë° ‚Ä≤) ‚åàùëáconf or
dCùëó,idx (ùë° ‚Ä≤) ‚åàùëáconf ‚™Ø dCùëñ,idx (ùë°) ‚åàùëáconf ) for each protocol instance and
the combined ledger is derived by ordering the blocks in all con-
firmed chains deterministically by their time slot, this implies safety
of Œ†ùúå,ùúè,ùëáconf,ùëö
ùëó ‚™Ø
pc
LOGùë°
ùëñ ).

(i.e., ‚àÄ honest ùëñ, ùëó : ‚àÄùë°, ùë° ‚Ä≤ : LOGùë°

ùëñ ‚™Ø LOGùë° ‚Ä≤

ùëó ‚à®LOGùë° ‚Ä≤

To show liveness, we first show that confirmed secondary chain
blocks are downloaded with bounded delay. From Lemma 8, in
any interval of Àúùëá slots, the bandwidth of each node is not re-
quested for downloads related to the primary chain but available
to download secondary chain blocks in at least ùúôidle Àúùëá (1 ‚àí ùúñ5)
slots. Further, from Lemma 7, in any interval of Àúùëá slots, the con-
firmed secondary chains grow by at most ùúôp Àúùëá (1 + ùúñ6) blocks.
These events happen with probability at least 1 ‚àí negl(ùúÖ) over
a time horizon ùëáh with Àúùëá = Œ©(ùúÖ + lnùëáh). By a union bound
over ùëö = poly(ùúÖ) number of chains, these hold with at least
1 ‚àí negl(ùúÖ) probability over all chains. Therefore, in Àúùëá slots, all
confirmed blocks in ùëö ‚àí 1 secondary chains can be downloaded,
where ùëö ‚àí 1 =

ùúôidle
ùúôp
Finally, note that liveness of each protocol instance guarantees
liveness of the parallel chains construction. As per the transaction
distribution rule described in Appendix C, each transaction belongs
to a particular protocol instance. By the liveness of each protocol in-
stance, any transaction input to all honest nodes in time slot ùë°, is in-
cluded in dCùëñ (ùë°) ‚åàùëáconf for ùë° ‚Ä≤ ‚â• ùë° +ùõæ +ùëáconf (see Proof of Lemma 9 in
Appendix D.2) and all nodes ùëñ for which the corresponding protocol
instance is primary. Moreover, all honest nodes download confirmed
secondary chains within Àúùëá delay. Therefore, Œ†ùúå,ùúè,ùëáconf,ùëö
satisfies
liveness with total latency ùõæ + ùëáconf + Àúùëá = Œ©((ùúÖ + lnùëáh)2).
‚ñ°

ùê∂ùúè (1 ‚àí ùúñ7) for some ùúñ7.

ùúôidle Àúùëá (1‚àíùúñ5)
ùúôp Àúùëá (1+ùúñ6)

ùê∂ùúè =

pc

F CONFLUX INCLUSION RULE
In order to prevent the throughput from vanishing as the resilience
ùõΩ approaches 1/2, we incorporate a modified version of the block
inclusion rule from Conflux [38] (also used in [23]). In addition to
the hash of the parent block, the header of a block ùëè also contains
references to (hashes of) at most ùëÖ blocks which have time slots
earlier than ùëè and are neither in the prefix nor are referenced by any
blocks in the prefix of ùëè. Moreover, in each chain, at most one block
from each time slot may be referred. An honest block producer
chooses to include the ùëÖ newest (by time slot) fully downloaded
blocks in their view that satisfy the above criteria. The parameter ùëÖ
is to be determined below. Blocks containing references that do not
follow the above criteria will be considered invalid. The consensus
protocol still uses the longest chain rule.

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

Therefore, the lemma holds under ùëá4 = ùõæ and the conditions from
‚ñ°
Lemma 10.

F.3 Parallel Chains Throughput
We still have honest nodes idle (not downloading any blocks) in at
least ùúôidle ‚â• 1‚àíùëù
fraction of slots. The average bandwidth required
to download a confirmed chain still remains at ùëù blocks per slot.
Therefore, we can increase the total throughput by constructing
ùëö = 1 +

parallel chains resulting in aggregate throughput

2

ùúôidleùê∂
ùúôp/ùúè

ùê∂ùúè

(cid:19) ùúÉinc
ùúè

TPùëö =

‚â•

‚â•

(cid:18)

1 +

ùúôidle
ùúôp
(1 ‚àí ùëù)ùëùU
2ùëù
(1 ‚àí ùëù)
4

ùê∂

(for the ‚Äòfreshest block‚Äô rule)

ùê∂ blocks per second.

(73)

This is a constant fraction of the capacity ùê∂ which does not vanish
as ùõΩ ‚Üí 1/2.

Note that downloading and validating a block now requires (in
addition to downloading the block itself) downloading the content
of all blocks in its prefix and all blocks referenced by blocks in the
prefix. Unlike [23], we do not consider the reference links to be
transitive as this would blow up the number of referred blocks
to be downloaded. The output ledger of a node ùëñ in slot ùë° (i.e.
LOGùë°
ùëñ ) will be formed by considering its truncated longest chain (i.e.
dCùëñ (ùë°) ‚åàùëáconf ) and inserting blocks referred by a block ùëè between
the parent of ùëè and ùëè, in increasing order of their time slot. This
may result in some transactions becoming invalid due to conflicting
transactions appearing before them in the ledger. Such transactions
would be removed (sanitized) while obtaining the ledger.

ùê∂ (previously Œîh + ùêæ

F.1 Security
For security of the inclusive protocol, it is enough to set the time
slot size to be ùúè = Œîh + ùêæùëÖ
ùê∂ ) where ùêæ is set
according to Theorem 1 (we do the analysis below for the fresh-
est block download rule, but it can be done for the equivocation
avoidance download rule as well). Since each block contains at
most ùëÖ references, the number of blocks to be downloaded in the
prefix of any honest freshest block increases at most by a factor of
ùëÖ. By setting the slot size as above, we ensure that the honest block
proposed in every uniquely successful slot is downloaded (along
with its prefix and references therein) within the same slot.

F.2 Single Chain Throughput
If ùëÖ = ùõæùëù (1 ‚àí ùúñ7), there exists a constant ùëá4 such that
Lemma 12.
for any honest node ùëñ and time slots ùë°1, ùë°2 ‚â• ùë°1 + ùëá , ùë° ‚â• ùë°2 + ùëáconf
with ùëá ‚â• ùëá4, LOGùë°
ùëñ contains at least ùúÉincùëá (1 ‚àí ùúñ8) blocks proposed by
honest nodes in slots (ùë°1, ùë°2], with probability at least 1 ‚àí exp(‚àíùõº4ùëá ),
where ùúÉinc = ùëùU.

instance of the inclusive protocol is at least ùúÉinc
ùúè

Lemma 12 indicates that the average throughput of a single
blocks per second.
To prove Lemma 12, we only need to show that every honest
block from a uniquely successful slot is included in the longest chain
of every node either directly on the chain or through a reference.
This will be achieved by setting ùëÖ to be large enough so that in any
interval of slots with ùëÖ block production opportunities, at least one
honest block is included in the longest chain. Then such an honest
block would include references to the ùëÖ most recent blocks which
would collectively include (at least) all honest blocks from uniquely
successful slots.

Proof. From the security analysis (Lemma 10), we have that
(cid:104)
‚â• 1 ‚àí negl(ùúÖ) where FreqPivotsùõæ is the event

FreqPivotsùõæ

(cid:105)

Pr

‚àÄùë° : ‚àÉùë° ‚Ä≤ ‚àà (ùë°, ùë° + ùõæ] : Pivot(ùë° ‚Ä≤) ‚àß Unique(ùë° ‚Ä≤).

(71)

Moreover, we have shown in Lemma 9 that the honest block pro-
posed in a unique pivot slot remains in the longest downloaded
chain of every honest node. This satisfies our requirement. Thus,
we need to set ùëÖ = ùõæùëù (1 + ùúñ7) so that there are at most ùëÖ uniquely
successful slots between two pivot slots, i.e.

‚àÄùë° : Pr [U (ùë°, ùë° + ùõæ] > ùëÖ] ‚â• 1 ‚àí exp

(cid:32)

ùúñ2
7
ùúñ7 + 2

(cid:33)

ùõæùëù

.

(72)

22

