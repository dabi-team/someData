2
2
0
2

y
a
M
8
1

]

R
C
.
s
c
[

3
v
2
3
3
2
1
.
1
1
1
2
:
v
i
X
r
a

Longest Chain Consensus Under Bandwidth Constraint

Joachim Neu
jneu@stanford.edu

Srivatsan Sridhar
svatsan@stanford.edu

Lei Yang
leiy@csail.mit.edu

David Tse
dntse@stanford.edu

Mohammad Alizadeh
alizadeh@csail.mit.edu

ABSTRACT
Spamming attacks are a serious concern for consensus protocols,
as witnessed by recent outages of a major blockchain, Solana. They
cause congestion and excessive message delays in a real network
due to its bandwidth constraints. In contrast, longest chain (LC), an
important family of consensus protocols, has previously only been
proven secure assuming an idealized network model in which all
messages are delivered within bounded delay. This model-reality
mismatch is further aggravated for Proof-of-Stake (PoS) LC where
the adversary can spam the network with equivocating blocks.
Hence, we extend the network model to capture bandwidth con-
straints, under which nodes now need to choose carefully which
blocks to spend their limited download budget on. To illustrate this
point, we show that â€˜download along the longest header chainâ€™, a
natural download rule for Proof-of-Work (PoW) LC, is insecure for
PoS LC. We propose a simple rule â€˜download towards the freshest
blockâ€™, formalize two common heuristics â€˜not downloading equiv-
ocationsâ€™ and â€˜blocklistingâ€™, and prove in a unified framework that
PoS LC with any one of these download rules is secure in bandwidth-
constrained networks. In experiments, we validate our claims and
showcase the behavior of these download rules under attack. By
composing multiple instances of a PoS LC protocol with a suitable
download rule in parallel, we obtain a PoS consensus protocol that
achieves a constant fraction of the networkâ€™s throughput limit even
under worst-case adversarial strategies.

1 INTRODUCTION

Consensus. In the state machine replication (SMR) formulation
of the consensus problem, a group of nodes aim to order transac-
tions received from the environment into a common ledger. For
this purpose, nodes exchange messages and perform computations
as prescribed by the consensus protocol. Consensus is made non-
trivial by an adversary who has some control over message delays,
controls a certain fraction of nodes, and can cause them to deviate
from the protocol in an arbitrary (Byzantine) manner in a concerted
effort to disturb consensus. Secure consensus is achieved if the re-
sulting transaction ledgers across different honest nodes and points
in time are consistent so that it is meaningful to speak of the single
common ledger (which is safe), and if that ledger is live in the sense
that every transaction gets assigned a position in the ledger soon
after it is input to honest nodes for the first time.

Nakamotoâ€™s Longest Chain Protocol. In the seminal Bitcoin white-
paper [41], Satoshi Nakamoto describes the longest chain (LC) con-
sensus protocol. In this protocol, honest nodes broadcast blocks to
each other. A block contains a list of transactions, a nonce, and a
reference to a parent block, resulting in chains of blocks up to a root

JN, SS and LY contributed equally and are listed alphabetically.

1

genesis block that is common knowledge. A block is valid if a cryp-
tographic hash of it is smaller than a certain fixed threshold, and if
the transactions it contains have been legitimized by the owners of
the affected assets and are consistent with respect to transactions
preceding it as ordered in the same block and its ancestor blocks.
Every node adds valid blocks it receives to its local copy of the block
tree. Nodes also aim to produce new blocks. For this purpose they
bundle recently received transactions together with a reference to
the block at the tip of the longest chain in their local block tree and
use brute force search to determine a nonce such that the resulting
block is valid (i.e., the hash inequality is satisfied). Newfound valid
blocks are broadcast to other nodes, completing the process. Each
node outputs as ledger the transactions as ordered in the prefix of
the block that is ğ‘˜-deep in the longest chain of its local block tree.
Besides being remarkably simple, Nakamotoâ€™s LC consensus pro-
tocol has two outstanding properties. First, it enables consensus in
a permissionless setting by using proof-of-work (PoW) puzzles as a
Sybil resistance mechanism [21, 33]. The bottleneck to block pro-
duction is finding nonces which lead to valid blocks which satisfy
the hash inequality, and as long as the majority of hash power at
every point in time is controlled by honest nodes, honest nodes
output a secure ledger [25, 44]. Second, the LC can tolerate dynamic
participation in the sense that the ledger remains secure even as
the total hash power participating in the protocol as well as its
distribution among participants varies over time.

Proof-of-Stake Longest Chain. A drawback of Nakamotoâ€™s PoW
LC is the high electricity consumption and as a result a tendency for
centralization of nodes at places of relatively low electricity cost. To
overcome the drawbacks of PoW LC while retaining its advantages,
protocols such as Ouroboros [4, 17, 35] and Sleepy Consensus [16,
45] preserve the operating principle of the LC but replace PoW
with proof-of-stake (PoS) lotteries, where a party is assigned random
block production opportunities in proportion to the amount of stake
it holds in the system, effectively substituting â€˜one CPU, one voteâ€™
by â€˜one coin, one voteâ€™. For this purpose, nodes use synchronized
clocks to count time slots of a predetermined duration. For every
time slot, nodes evaluate a block production lottery associated
with their cryptographic identity. For instance in [4, 17], nodes get
to produce a new valid block if the output of a verifiable random
function (VRF) is below a threshold proportional to the nodeâ€™s stake.

Proof-of-Stake Longest Chain Under Bandwidth Constraint. While
PoS LC behaves in some aspects similar to PoW LC, it differs drasti-
cally in others. For instance, in PoS, block production opportunities
can be â€˜reusedâ€™ in the sense that when a node is eligible to produce
a block in a certain time slot, it can in fact create many equivocating
but equally valid blocks for the same time slot, each potentially
with a different set of transactions and/or attached to a different

 
 
 
 
 
 
]
s
[
y
a
l
e
d
k
c
o
l
b
t
s
r
o
W

15

10

5

0

1

2

3

4

5

6

Blocks in slot

Figure 1: Time taken (10-th percentile, mean, 90-th per-
centile) for all nodes to download all blocks mined in a
slot, when different number of new blocks are produced
and broadcast in a slot. The delay increases as the number
of blocks is increased, showing that network delay is not
independent of network load. We use Cardanoâ€™s Ouroboros
implementation. Details of the experimental setup are given
in Appendix B.1.

parent block. This problem arises because block production â€˜lottery
ticketsâ€™ in PoS can not depend on the proposed blockâ€™s transactions.
Otherwise an adversary could increase its chances to produce a
block by trying various sets of transactions (grinding). Similarly,
the PoS lotteries can not depend on the parent block, as the adver-
sary could extend several chains at once to increase their chance
of block production (nothing-at-stake attack [5]). In PoW however,
each block production opportunity corresponds to a unique block
(a combination of transaction set, parent block, and nonce), thus
the rate of block production opportunities simultaneously bounds
the rate at which new valid blocks can be created.

Previous analysis [17, 20, 45] shows that this difference is im-
material in the synchronous network model where the message
propagation delay between honest nodes is controlled by the ad-
versary, but below a known upper bound Î”. Under such a network
model, PoS LC and PoW LC behave the same in terms of secu-
rity, transaction throughput and confirmation latency. This model,
however, is over-idealized in that it assumes a fixed delay upper
bound for every single message, even when many messages are
transmitted simultaneously (which may be under normal execution
or due to adversarial actions). The model does not capture notions
of capacity and congestion which have a significant impact on the
behavior of real networks. In fact, an increase in network delay
with increasing network load (via increased block size) has been
demonstrated previously for Bitcoin [19]. Similarly, increasing the
network load (via increasing the number of blocks per slot) leads to
increased network delay in our experiments (see Figure 1) with Car-
danoâ€™s Ouroboros implementationâ€”a PoS protocol. Once we enrich
the network model to capture such phenomena, the difference in
the behavior of PoW LC and PoS LC with respect to reuse of block
production opportunities strikes. The possibility of producing (infin-
itely) many equivocating valid blocks per block production oppor-
tunity opens up new adversarial strategies in which the adversary
aims to exhaust limited network resources with useless spam in an
attempt to disturb consensus. This protrudes in another experiment
(see Figure 2) where nodes run PoS LC with our implementation of
Cardanoâ€™s block download logic as per [30]. Adversarial spamming
(through block equivocations) causes significant network traffic at

2

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

n
i
a
h
c
t
s
e
n
o
H

]
1
âˆ’
s
[
e
t
a
r
h
t
w
o
r
g

0.04

0.02

0

No attack

Attack, Longest Attack, Freshest

Figure 2: The honest chain growth rate in three scenarios:
without spamming attack; under attack while downloading
the longest header chain first (priority rule in Cardanoâ€™s
block download logic); under attack while downloading the
freshest block first (introduced in this work). Details of the
experimental setup are given in Section 5.2. For a trace of the
chain growth in the same experiment, see Figure 5.

the victim nodes, leaving insufficient bandwidth for the victims to
download honest blocks. As a result, block production on the honest
chain stalls, and the victim node can be easily fooled by a longer
chain from the adversary, potentially resulting in a safety violation.

Modelling Bandwidth Constraints. We model a bandwidth con-
strained network as follows. Recall that blocks in Nakamoto con-
sensus consist of a list of transactions as block content, and the
information pertaining to the PoS/PoW lottery and the block tree
structure (reference to parent block) as block header. Since a blockâ€™s
header is small compared to its content, we assume that block head-
ers propagate with a known delay upper bound Î”h between honest
nodes. At any point after obtaining a block header, a node can
request the corresponding block content from the network. Since
a blockâ€™s content is large, every honest node can only download
a limited number of blocksâ€™ contents per time slot. This model is
inspired by the peer-to-peer network designs used for blockchain
protocols. For instance, in the Cardano network [14, 15], each node
advertises its block header chain to its peers, which in turn decide
based on the block headers which block contents to fetch. Without
a carefully designed download rule for the protocol to determine
which blocks honest nodes should spend their scarce bandwidth
on, we will see that consensus cannot be achieved with PoS LC.

The â€˜Download Along The Longest Header Chainâ€™ Rule. Given that
in LC, honest nodes extend the longest chain, a natural download
rule is â€˜download along the longest header chainâ€™, i.e., based on the
block tree structure obtained from block headers, a node identifies
the longest (header) chain, and prioritizes downloading the blocks
along that chain. Indeed, Bitcoin does exactly that [1]. Cardanoâ€™s
Ouroboros implementation also follows this paradigm in broad
strokes [14, 15, 18] for chain selection [32] and block downloads
[31]. As long as the block production rate is low relative to the
download bandwidth, this (and other rules that ensure that nodes
download a block at most once) work well for PoW LC, simply
because the number of distinct blocks is limited by the number of
block production opportunities.

Unfortunately, as illustrated in Figure 3, this download rule fails
for PoS LC in that the resulting protocol is not secure, even if the
block production rate is low and the adversary controls a small
minority of the stake. The reason is that the adversary can use

Longest Chain Consensus Under Bandwidth Constraint

Time slots

ğ‘¡0

ğ‘¡

ğ‘¡ â€²

ğ‘¡1

ğ‘¡2

ğ‘ (1)
âœ˜
ğ‘ (2)
âœ˜
.
.
.

ğµ (1)

ğµ (2)

.
.
.

ğ‘0

Adversarial equivocations luring
honest nodes away from down-
loading honest blocks (âœ˜: blocks
with invalid content)

ğ‘1

Last valid block
downloaded by
all honest nodes

Honest blocks are
never downloaded
because of shorter
header chain

ğ‘2

.
.
.

Figure 3: In PoS LC with â€˜download along the longest header
chainâ€™ rule, an adversary can stall consensus indefinitely
if it has two consecutive block production opportunities
ğ‘¡ < ğ‘¡ â€² at which it creates infinitely many equivocating chains
ğ‘0 â† ğ‘ (ğ‘–) â† ğµ (ğ‘–) where ğ‘ (ğ‘–) have invalid content. The blocks
of later honest block production opportunities ... > ğ‘¡2 > ğ‘¡1 >
ğ‘¡ â€² > ğ‘¡ are never downloaded by other honest nodes, because
they prioritize the longer adversarial header chains, wasting
their bandwidth downloading each ğ‘ (ğ‘–) only to discard it
immediately thereafter because of invalid content.

consecutive adversarial block production opportunities (at ğ‘¡ and
ğ‘¡ â€² in Figure 3) to produce infinitely many equivocating chains
(ğ‘0 â† ğ‘ (ğ‘–) â† ğµ (ğ‘–) in Figure 3). To avoid honest nodes building
on these equivocating chains, the adversary fills ğ‘ (ğ‘–) with invalid
content, which honest nodes can only detect after they have already
wasted their scarce bandwidth to download it. As a result, honest
nodes produce blocks off ğ‘0 in their block production opportunities
(ğ‘1, ğ‘2, ... at ğ‘¡1 < ğ‘¡2 < ... in Figure 3), but these are never down-
loaded by other honest nodes because the adversarial header chains
are longer and thus of higher download priority. This is clearly an
attack on liveness but it also implies an attack on safety because the
adversary could now build a chain longer than the honest parties
(who are stalled) even though the adversary owns very little stake.
The impact of this attack is seen in our experiments with a PoS LC
node implementing this download rule (Figure 2).

The above attack suggests that securing PoS LC under bandwidth
constraints requires a carefully designed download rule. In practice,
protocols follow various heuristics to attempt to mitigate spam-
ming/equivocation attacks. However, a rigorous analysis is usually
missing. Our goal in this work is to identify simple download rules
that can be proven secure in the bandwidth constrained model.

In the attack in Figure 3, we observe that even though new honest
blocks are being proposed, the download rule prioritizes older adver-
sarial equivocating blocks. If honest nodes downloaded the â€˜fresherâ€™
blocks proposed in more recent time slots ğ‘¡1, ğ‘¡2, ... instead, then
this attack would not succeed. This intuition extends beyond the
specific attack of Figure 3. We would like that whenever an honest
node proposes a block, other honest nodes download that block and
its prefix â€˜soonâ€™. This way, honest nodes have a chance to produce
blocks extending it, and to align their block production efforts to-
ward a particular chain. This is arguably the key to LC security and

3

central to prior security analysis [20, 45] on which we build. This
insight naturally motivates the following simple download rule.

The â€˜Download Towards The Freshest Blockâ€™ Rule. We propose a
simple download rule for PoS LC, â€˜download towards the freshest
blockâ€™, i.e., in every time slot an honest node identifies the block
proposed in the most recent time slot based on the header infor-
mation, and downloads any missing blocks in its prefix, including
that freshest block. Thus, when an honest node proposes a block,
within the same time slot, other honest nodes prioritize download-
ing that block and its prefix. The length of the prefix cannot be too
long since valid chains cannot contain equivocations. By making
the time slot long enough to allow downloading the whole prefix,
this rule directly satisfies our desired property that honest nodes
download honestly proposed blocks â€˜soonâ€™ (within the same time
slot). This property is the key step in prior security analysis, thus
allowing us to use prior techniques to prove the security of PoS LC
with this download rule. In particular, this download rule avoids the
attack of Figure 3 and the honest chainâ€™s growth rate remains unaf-
fected by this spamming attack (Figure 2). Importantly, note that the
freshest block rule is only a download priority rule. Honest nodes
still propose blocks extending their longest valid downloaded chain.

Other Download Rules. More generally, we identify other down-
load rules with the property that whenever an honest block is pro-
posed, all honest nodes download that block and its prefix â€˜soonâ€™.
Thus, we develop a unified framework to prove security of PoS LC
with any download rule with this property. We consider the fol-
lowing two commonly proposed heuristics against equivocations,
formalize them and give a rigorous proof of security.
(1) â€˜Equivocation avoidanceâ€™: We modify â€˜download along the longest
header chainâ€™ such that an honest node refrains from download-
ing a chain whose tip is an equivocating block header (i.e., it has
seen another block header from the same slot and validator). A
rule of this kind can be seen used in PoS Ethereum [2].

(2) â€˜Blocklistingâ€™: An honest node avoids downloading any chain
whose tip is proposed by a validator that has equivocated be-
fore (in its view of block headers). Note that this notion of
blocklisting only affects the download priority rule. It does not
invalidate a block, as doing so independently at each node risks
introducing split views, and doing so consistently would require
consensus in the first place.

Due to the simplicity and efficiency of the â€˜download towards the
freshest blockâ€™ rule, and because it directly satisfies the key prop-
erty that enables our security proofs, we use this rule as a running
example to illustrate our model and the analysis. We then extend
this analysis to the other two rules.

Our Contributions. By means of experiments and a concrete at-
tack strategy, we show that the bounded delay model fails to capture
network congestion and spamming attacks. We show that using
suitable download rules, we can provably secure PoS LC in net-
works with bandwidth constraint in which the adversary can (inter
alia) spam the network with equivocating blocks at an arbitrary
rate, withhold blocks, and release blocks with invalid content that
honest nodes discard after downloading. We identify a key property
of a download rule that enables it to secure PoS LC. We use this to
develop a unified framework to prove the security of PoS LC with

any download rule that satisfies this property. We propose a simple
rule â€˜download towards the freshest blockâ€™ that satisfies this prop-
erty. We also formalize heuristics in the form of the â€˜equivocation
avoidanceâ€™ and â€˜blocklistingâ€™ rules for which we provide a rigorous
security proof using our framework. We show that parallel composi-
tion of multiple instances of PoS LC with a secure download rule (in-
spired by [24]) yields a consensus protocol that achieves a constant
fraction of the networkâ€™s throughput limit even in the worst case.

Related Work. Network-level attacks on Bitcoin have been stud-
ied in [3, 11]. Eclipse attacks on peer-to-peer networks, where an
adversary uses several IP addresses to occupy all connections main-
tained by a victim node and thus cut said node off from the network,
have been studied in [28, 49â€“51] and in the context of Bitcoin in [12].
The authors of [13] show that if one can connect with consensus
validators that are pseudo-randomly chosen every few slots based
on their stake, then one can secure PoS LC against Sybil attacks and
eclipse attacks on the network layer. These earlier works share their
focus on network topology, an important aspect not captured by the
bounded delay network model. Our work instead focuses on band-
width constraints, an orthogonal feature of real networks not cap-
tured by the bounded delay model. However, our works share the
philosophy of co-designing consensus and network layer protocols.
The impact of spamming was seen recently in the temporary
shutdown of a PoS protocol Solana [53] on multiple occasions in
2021-2022 [39, 40, 46]. These shutdowns were reportedly due to an
increase in the transaction load in the network, and the â€œlack of
prioritization of network-critical messaging caused the network to
start forkingâ€ [39]. These incidents indicate that messages that are
critical for consensus among honest nodes (e.g., blocks) must be
appropriately prioritized during periods of congestion. Consensus-
critical blocks are easily prioritized at the network level over less
critical transaction requests, as the two are different kinds. Thus,
this work focuses instead on the design of a download rule with
which the consensus protocol assists the network in prioritizing
consensus-critical blocks over similarly looking spam blocks.

In practice, implementations show awareness of and attempt
to mitigate equivocation-based spamming attacks using various
heuristics. However, their efficacy and side effects are often not fully
understood. For instance, Cardanoâ€™s Ouroboros implementation
disconnects from peers once they propagate invalid or equivocating
blocks [14, 15, 18]. However, an adversary can boost the impact of
its attack by creating more Sybil network peers (recall that there
is no relation between consensus validators and peers in the un-
derlying communication network), so that disconnected peers are
likely replaced by new adversarial peers, ready to waste more of
the honest nodeâ€™s resources [49â€“51].

Slashing is routinely proposed as a solution to mitigate spam-
ming with equivocations, as such attacks can be attributed to spe-
cific validators [7, 8, 43, 48]. Typical crypto-economic guarantees
are of the form â€œif human intervention is needed to recover from
a safety attack, then 33% of stake is slashableâ€œ [9, 43, 48]. However,
the attack in Figure 3 only requires two consecutive block produc-
tion opportunities, which can be obtained by an adversary with
a very small fraction of stake. Hence in this case, slashing would
impose a very small penalty for an attack that violates security
and potentially incurs large costs due to human intervention and

4

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

other losses. Instead, we take the approach of preventing attacks
in the first place by using download rules that are proven secure.
Once security is proven, slashing can be employed as an additional
measure to disincentivize equivocation-based spamming.

The need for careful modelling of bandwidth constraints in the
context of high throughput protocols was identified in [6, 24]. Ear-
lier works [6, 19, 52] note that the network delay increases with the
message size (i.e., block size in this case). In this model, it is assumed
that as long as the network load is less than the bandwidth, every
message is downloaded within a given delay bound which depends
on the message size but is independent of total network load.

In the PoS context, [24] captures congestion due to increased
network load by modelling the inbox of each node as a queue. Each
message undergoes a propagation delay before being added to the
recipientâ€™s inbox queue. The recipient can retrieve messages from
their queue at a rate limited by their bandwidth, resulting in a queu-
ing delay. However, the security result [24, Theorem 1] still assumes
a bounded (propagation+queuing) delay. This assumption is only
shown to hold under honest executions when the adversary does
not corrupt any nodes and does not send or delay any messages
[24, Theorem 3], and therefore the security claim does not hold for
all adversarial strategies. In particular, this excludes adversaries
that can spam the network using equivocating blocks and cause
attacks such as in Figure 3. The model we use is a variant of that
in [24] with the difference that nodes can inspect a small segment
(block header) at the beginning of every message in their queue and
decide based on that which message (block content) to prioritize for
download (subject to the bandwidth constraint). This modification
allows us to prove security against a general adversary, even with
unbounded equivocations.

Although our work is the first to prove PoS LC secure under band-
width constraints, our analysis builds on tools from several years
of security analysis for LC protocols [5, 17, 20, 25, 27, 44, 45, 47],
particularly the concept of pivots [45] (cf. Nakamoto blocks [20]).

Outline. We state the PoS LC protocol augmented with a down-
load rule and introduce our formal model for bandwidth constrained
networks in Section 2. In Section 3, we provide a high-level descrip-
tion of our unified framework for proving security of PoS LC with
different download rules under bandwidth constraints. In Section 4,
we show the key steps towards this unified proof, and analyze
the â€˜download towards the freshest blockâ€™ rule. We present exper-
imental evidence for the robustness and superior performance of
the â€˜freshest blockâ€™ rule in Section 5. We formalize and analyze the
â€˜equivocation avoidanceâ€™ and â€˜blocklistingâ€™ rules in Section 6. Finally,
we sketch in Section 7 how to use PoS LC with a suitable download
rule as a building block to obtain a consensus protocol with a con-
stant fraction of the networkâ€™s throughput limit in the worst case.

2 PROTOCOL AND MODEL

Model Main Features. For ease of exposition, we assume a static
set of ğ‘ active nodes, each with a cryptographic identity corre-
sponding to one unit of stake. Our analysis can be extended to
the setting of heterogeneous and dynamic stake using tools from
[16, 17]. Nodesâ€™ cryptographic identities are common knowledge.
We are interested in the large system regime ğ‘ â†’ âˆ. A static
adversary A chooses a set of nodes (up to a fraction ğ›½ of all nodes,

Longest Chain Consensus Under Bandwidth Constraint

Algorithm 1 Idealized PoS LC consensus protocol Î ğœŒ,ğœ,ğ‘‡conf with
a download rule (helper functions: Appendix A.1, F
:
Algorithm 3, Z: Appendix A.2)

ğœŒ
headertree

1: on init(genesisHeaderChain, genesisTxs)
2:

âŠ² Initialize header tree hT, longest downloaded chain dC, and

mapping from block headers to contents (lists of transactions) blkTxs
hT, dC â† {genesisHeaderChain}, genesisHeaderChain
blkTxs[dC ] â† genesisTxs âŠ² Unset entries of blkTxs are unknown
âŠ² Called by Z or A
.verify( C) âŠ² Validate header chain (Algorithm 3)
assert F
hT â† hT âˆª prefixChainsOf ( C) âŠ² Add C and its prefixes to hT
Z.broadcastHeaderChain( C)

3:
4:
5: on receivedHeaderChain( C)
ğœŒ
6:
headertree
7:
8:
9: on receivedContent( C, txs)
10:

âŠ² Called by Z or A
âŠ² Defer processing the content until we received the corresponding

header chain ğ¶, and its prefixesâ€™ contents are downloaded and valid

defer until C âˆˆ hT
defer until âˆ€Câ€² â‰º C : blkTxs[ Câ€²] âˆ‰ {unknown, invalid}
assert C.txsHash = Hash(txs)
if txsAreSemanticallyValidWrtPrefixesOf ( C, txs)

blkTxs[ C ] â† txs
Z.uploadContent( C, txs)

else

blkTxs[ C ] â† invalid

11:
12:
13:
14:
15:
16:
17:
18:

âŠ² Update the longest downloaded chain among downloaded valid chains
19:
Tâ€² â† hT \ { Câ€² âˆˆ hT | blkTxs[ Câ€²] âˆˆ {unknown, invalid} }
20:
21:
dC â† arg maxCâˆˆTâ€² | C |
22: on scheduleContentDownload()
23:
24:
25:

âŠ² Pick next block to download according to download rule (cf. Algs. 2, 4)
if C â‰  âŠ¥ with C â† downloadRule(hT, blkTxs)

Z.reqestContent( C)

âŠ² receivedContent will be triggered by Z on successful download
âŠ² PoS LC protocol main loop

26:
27: for time slots ğ‘¡ â† 1, ...,ğ‘‡h of duration ğœ
28:
29:
30:
31:
32:

ğœŒ
headertree
Z.uploadContent( Câ€², txs)
Z.broadcastHeaderChain( Câ€²)

txs â† Z.receivePendingTxsSemanticallyValidWrt(dC)
âŠ² Produce and disseminate a new block if eligible, see Alg. 3
if Câ€² â‰  âŠ¥ with Câ€² â† F

.extend(ğ‘¡, dC, txs)

33:
34:
35:

36:

âŠ² Download block contents (starting after Î”h time into the slot)
while end of current time slot ğ‘¡ not reached

scheduleContentDownload()

Z.outputLedger(dC âŒˆğ‘‡conf )

âŠ² Ledger of node ğ‘– at time ğ‘¡ : LOGğ‘¡
ğ‘–

where ğ›½ is common knowledge) to corrupt before the randomness
of the protocol is drawn and the execution commences. Uncor-
rupted honest nodes follow the protocol as specified at all times,
corrupted adversarial nodes deviate from the protocol in an arbi-
trary Byzantine manner coordinated by the adversary in an attempt
to inhibit consensus. For simplicity, we have assumed that all nodes
are always awake. Our analysis builds on techniques from [45] and
the refined machinery therein can be used to extend our analysis
to the setting of asleep/awake honest nodes.

Protocol Main Features. Pseudocode of an idealized PoS LC Na-
kamoto consensus protocol parameterized by a download rule is
provided in Algorithm 1 (cf. [45, Figure 3]). The â€˜download towards
the freshest blockâ€™ rule is given in Algorithm 2. Implementation
details of the block production lottery and the handling of the

Algorithm 2 â€˜Freshest blockâ€™ download rule

1: function downloadFreshestBlock(hT, blkTxs)
âŠ² Ignore chains with invalid content in any block
2:
T â† { C âˆˆ hT | âˆ€Câ€² âª¯ C : blkTxs[ Câ€²] â‰  invalid}
3:
âŠ² Find the chain ending in the freshest block (i.e., from most recent slot)
4:
C â† arg maxCâ€²âˆˆT Câ€².time
5:
âŠ² Find the first not downloaded block on that chain (if non-existent: âŠ¥)
6:
C â† arg minCâ€²âª¯C : blkTxs[Câ€² ]=unknown | Câ€² |
7:
return C
8:

Algorithm 3 Idealized functionality F
lottery and header block chain structure (cf. Appendix A.1)

: block production

ğœŒ
headertree

ğ‘ â† numNodes
T â† {genesisHeaderChain}

1: on init(genesisHeaderChain, numNodes)
2:
3:
4: on isLeader(ğ‘ƒ, ğ‘¡ ) from A (only for adversarial ğ‘ƒ ) or F
5:

âŠ² Abstraction of proof-of-stake lottery: each node is chosen leader in

âŠ² Global set of valid header chains

ğœŒ
headertree

each slot with probability ğœŒ/ğ‘ independent of other nodes and slots

6:

7:

if lottery [ğ‘ƒ, ğ‘¡ ] = âŠ¥
$
â† (true with probability ğœŒ/ğ‘ , else false)
lottery [ğ‘ƒ, ğ‘¡ ]
return lottery [ğ‘ƒ, ğ‘¡ ]

8:
9: on extend(ğ‘¡ â€², C, txs) from node ğ‘ƒ (possibly adversarial) at time slot ğ‘¡
âŠ² New header chain is valid if parent chain C is valid, ğ‘ƒ is leader for
10:

slot ğ‘¡ â€², and ğ‘¡ â€² is later than the tip of C and is not in the future
if ( C âˆˆ T) âˆ§ isLeader(ğ‘ƒ, ğ‘¡ â€²) âˆ§ ( C.time < ğ‘¡ â€² â‰¤ ğ‘¡ )

âŠ² Produce a new block header extending C
Câ€² â† C âˆ¥ newBlock(time : ğ‘¡ â€², node : ğ‘ƒ, txsHash : Hash(txs))
T â† T âˆª { Câ€² }
return Câ€²

âŠ² Register new header chain in header tree

11:
12:
13:
14:
15:
return âŠ¥
16:
17: on verify( C)
18:

return C âˆˆ T âŠ² Header chain is valid if previously added to header tree

ğœŒ
headertree

ğœŒ
headertree

blockchain data structure are abstracted away in the idealized func-
tionality F
provided in Algorithm 3 (cf. [45, Figure 2]).
An index of the helper functions used in the pseudocode is provided
in Appendix A.1. With specific implementations of F
, a
variety of PoS LC protocols can be modelled such as protocols from
the Ouroboros family [4, 17, 35] and the Sleepy Consensus [16, 45]
family. A more formal description of the environment Z (idealized
functionality modeling the network) is given in Appendix A.1. In the
main loop of the PoS LC protocol (Algorithm 1, lines 27ff.) the node
attempts in every time slot (which is of duration ğœ) to produce a new
block containing transactions txs and to extend the longest down-
loaded chain (denoted dC) in the nodeâ€™s local view. If successful,
the block content txs and the resulting new block header chain Câ€²
are provided to the environment Z for dissemination to all nodes.

Dissemination of Block Headers and Contents. The network model
and dissemination of headers and contents is illustrated in Figure 4.
Block header chains broadcast via Z.broadcastHeaderChain are
delivered by the environment Z to every node with a delay deter-
mined by A, up to a delay upper bound Î”h that is common knowl-
edge. Once an honest node receives a new valid header chain (Algo-
rithm 1, lines 5ff.), the node adds it to its local header tree hT . Block
content uploaded via Z.uploadContent is kept by Z in an ideal-
ized repository. In every time slot, honest nodes use a download rule

5

Header
Broadcasting

Participants

Content
Repository

Delay â‰¤ Î”h

2

txs2

1

txs2

Req. C2

5

4
txs2 Req. C2

Bandwidth

txs2

txs2

3

Header Content

C1
C2
.
.
.

txs1
txs2
.
.
.

Figure 4: In our model, block headers are propagated with a
known delay upper bound Î”h, while block content is subject
to a bandwidth constraint. 1 An honest node produces a
new valid block, consisting of header and content. 2 Block
headers are broadcast (Z.broadcastHeaderChain) and
arrive at honest nodes (Î ğœŒ,ğœ,ğ‘‡conf .receivedHeaderChain)
within at most Î”h delay. 3 Block content is submitted to
an idealized â€˜repositoryâ€™ (Z.uploadContent). A hash of
the corresponding block content is included in the block
header.
4 Upon request (Z.reqestContent), the con-
tent of a certain block is obtained from the â€˜repositoryâ€™
(Î ğœŒ,ğœ,ğ‘‡conf .receivedContent), subject to a constraint on the
rate of downloaded block contents. 5 An adversary can push
block headers and block content to honest nodes indepen-
dent of delay and bandwidth constraints. See Appendix A.2
for details on Z.

to select block headers for which they wish to request the content
(Algorithm 1, line 22). Honest nodes can request the content for a
particular header via Z.reqestContent. If available, the content
requested from the repository will be delivered by Z to the honest
node by triggering the callback receivedContent (Algorithm 1,
lines 9ff.). We set the slot duration as ğœ = Î”h + ğ¾
ğ¶ such that all honest
nodes receive block headers proposed at the start of the current slot,
and thereafter Z delivers at most ğ¾ block contents requested from
the repository to each honest node per time slot, thereby constrain-
ing the bandwidth to ğ¶ blocks per second.1 Upon verifying that the
content matches the hash in the block header and that the txs are
valid with respect to the ledger determined by the blockâ€™s prefix,
the node adds txs to its local view. Otherwise, the block is marked
as invalid, to prevent downloading it or any of its descendants in
the future. Finally, the node updates its longest downloaded chain.

â€˜Download Towards The Freshest Blockâ€™ Rule. Motivated by the
earlier arguments in Section 1, we introduce the â€˜download towards
the freshest blockâ€™ download rule (Algorithm 2). In this download
rule, first the header tree hT is pruned by invalid blocks and their
descendants. Then, the first unknown block in the prefix of the
freshest block is requested. Ties are broken by the adversary.

Adversarial Strategies And Powers. Adversarial strategies and
powers include but are not limited to: reusing block production

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

ğœŒ
headertree

opportunities to produce multiple blocks (equivocations, by calling
.extend multiple times, each with a different txs or a
F
different parent chain C); extending any chain using past block
production opportunities as long as the purported block production
time slots along any chain are strictly increasing; releasing block
headers late or selectively to honest nodes; proactively pushing
block headers or block content to honest nodes irrespective of de-
lay or bandwidth constraints (by triggering the nodeâ€™s respective
receivedHeaderChain or receivedContent callback); withhold-
ing the content of blocks; including invalid txs in blocks; breaking
ties in chain selection and the download rule.

Reality Check. Note that in practice the prioritization of blocks
according to some download rule does not have to take place only at
the endpoints of the network or be limited to block content. Rather,
it can also be applied to block headers and by intermediary nodes
of the underlying communication or peer-to-peer gossip overlay
network as they forward blocks. This effectively shifts the down-
load rule from the edge into the network. Honest participants focus
their resources on what the scheduling logic determines as â€˜high
importanceâ€™ traffic, and save it from being drowned out by adversar-
ial spam. The result is that headers of the blocks which might be of
interest to an honest node based on the prioritization stipulated by
the download rule will be made available to that honest node by the
network within reasonable delay despite adversarial interference.
Because of this, we believe that our model leads to protocols that can
fare well under bandwidth constraints and spamming in practice.
in real-
world protocols, depending on the desired properties. The block
production lottery (Algorithm 3, line 7) is typically implemented
by checking whether the output of a random function is below a
certain threshold. Against static adversaries, a collision resistant
hash function suffices [45]; against adaptive adversaries, a verifiable
random function (VRF) is used [35]. Although the ideal functional-
ity F
relies on the knowledge of ğ‘ to tune the threshold
ğœŒ/ğ‘ , in PoS realizations such as in [17] the factor 1/ğ‘ is replaced
by the fraction of the total stake owned by the node as per the con-
firmed segment of the blockchain.2 The binding between a block
and the production opportunity it stems from (Algorithm 3, line 9)
is established using digital signatures.

Various constructions are used to realize F

ğœŒ
headertree

ğœŒ
headertree

The idealized repository maintained by Z is just a way to ab-
stract block dissemination in a peer-to-peer gossip network. In
reality, each node requests their peers for the block content (us-
ing information from the block header), and honest peers respond
with the content. Correspondingly, the idealized repository indexes
block content by the block header, and delivers it upon request, if
available. Note that block content associated with a particular block
header may be unavailable when requested by some honest node
at one point in time (e.g., if the adversary did not make it available),
but available when requested by another honest node at a later time
(e.g., if the adversary made it available in the meantime). Thus, the
block header does not ensure data availability or consistency among
honest nodesâ€™ download attempts, unlike in stronger primitives
such as verifiable information dispersal [10, 29, 42, 54]. By modelling
the network as an idealized repository, we abstract out details such

1Unlike [24], we do not model the upload bandwidth because honest nodes only send
very few messages in our protocol.

2In our simplified model, each node owns one unit of stake, which is the same as 1/ğ‘
fraction of the total stake where ğ‘ is the number of nodes.

6

Longest Chain Consensus Under Bandwidth Constraint

as the network topology and data availability that are orthogonal
to the issue being considered here: the bandwidth constraint.

3 HIGH LEVEL SECURITY ARGUMENT
Our proofs follow the techniques of [45] and [20]. The key differ-
ence between these techniques and our proof is that the former
assume that the block propagation delay is always bounded by a
constant Î”. In our case, we first prove that under â€˜suitableâ€™ down-
load rules and protocol parameters, with overwhelming probability,
a large fraction of honestly proposed blocks are downloaded by all
honest nodes within bounded delay.

To this effect, we consider uniquely successful time slots, in which
there is exactly one honest block proposal (any other slots with
block proposals are called adversarial). For a given download rule
and protocol execution, we define a property MaxDLğ¾ (shorthand
for Maximum Download) by which under all adversarial strategies
and throughout the execution, the block proposed in a uniquely
successful slot is downloaded by all honest nodes within the first ğ¾
blocks downloaded since the beginning of that slot (Definition 2). If
the time slot is long enough to allow downloading ğ¾ blocks, then the
block proposed in any uniquely successful slot will be downloaded
by all honest nodes before the end of the same time slot. Then, each
block proposed in a uniquely successful slot increases the minimum
length of all honest nodesâ€™ longest downloaded chains. (Lemma 1).
This is the key stepping stone of earlier security proofs of LC [20, 45].
We then employ techniques of [45] to prove that PoS LC with the
right parameters and a download rule such that MaxDLğ¾ holds
with overwhelming probability is secure (Theorem 1). This gives a
general framework where in order to prove security of PoS LC with
a specific download rule, one only needs to show that the download
rule satisfies MaxDLğ¾ with overwhelming probability.

The property MaxDLğ¾ suggests a natural download rule. In a
uniquely successful slot, the block proposed in that slot can be
identified as the unique freshest block. Thus, downloading towards
the freshest block allows an honest node to download the block
proposed in that slot most straightforwardly. If the prefix of the
freshest block contains less than ğ¾ blocks that have not been down-
loaded yet, then MaxDLğ¾ will be satisfied. Thus, for a suitably
chosen ğ¾, the block proposed in a uniquely successful slot will be
downloaded within the same time slot with overwhelming prob-
ability (Lemmas 2, 3). In Section 6, we apply a similar analysis to
two other download rules, â€˜equivocation avoidanceâ€™ and â€˜blocklist-
ingâ€™, to show that they too satisfy MaxDLğ¾ with overwhelming
probability for suitable ğ¾ (Lemmas 4, 5).

In Corollary 1, we identify the parameter values under which the
protocol Î ğœŒ,ğœ,ğ‘‡conf with the freshest block download rule is secure
for a given desired resilience ğ›½ (similarly for â€˜equivocation avoid-
anceâ€™ and â€˜blocklistingâ€™ in Corollary 2). For the rate of uniquely
successful slots to exceed the rate of adversarial slots, we require
that the rate of block production per slot, ğœŒ, be bounded as a func-
tion of ğ›½, so that most slots with honest block proposals are also
uniquely successful slots. A similar constraint exists in the synchro-
nous model [17, 20, 45] where the product of the block production
rate and network delay Î” is bounded by a function of ğ›½. Next, we
require that the per slot bandwidth ğ¾ = Î©(ğœ…) (where ğœ… is the se-
curity parameter) so that MaxDLğ¾ is satisfied with overwhelming

probability. This implies that the time slot ğœ = Î”h + ğ¾
ğ¶ = Î©(ğœ…). This
is similar to [24] where under a bandwidth constrained model, the
probabilistic delay bound increases with the security parameter.
Finally, the confirmation time ğ‘‡conf = Î©(ğœ…2) slots, similar to that
in the synchronous model [45].

4 SECURITY PROOF
4.1 Definitions
The PoS LC protocol Î ğœŒ,ğœ,ğ‘‡conf has three parameters. The length of
each time slot is ğœ seconds, the average number of nodes eligible to
propose a block per time slot is ğœŒ, and the confirmation latency is
ğ‘‡conf slots. The network has the following additional parameters.
Each honest node has a download bandwidth of ğ¶ block contents per
second (for convenience, we fix the size of the block content). Hence-
forth, we fix ğœ = Î”h + ğ¾
ğ¶ such that each honest node can download
the content of ğ¾ blocks in one time slot after receiving the headers
proposed in that slot. The adversary controls ğ›½ fraction of the stake.
We denote by ğœ… the security parameter. An event ğ¸ğœ… will be said
to occur with overwhelming probability if Pr [ğ¸ğœ… ] â‰¥ 1 âˆ’ negl(ğœ…).
Here, a function ğ‘“ (ğœ…) is said to be negligible or negl(ğœ…) if for all
ğ‘› > 0, there exists ğœ…âˆ—
ğ‘› such that for all ğœ… > ğœ…âˆ—

ğ‘›, ğ‘“ (ğœ…) < 1
ğœ…ğ‘› .

Define the random variables ğ»ğ‘¡ and ğ´ğ‘¡ for ğ‘¡ = 1, 2, ... to be the
number of honest and adversarial nodes eligible to propose a block
in slot ğ‘¡, respectively. We consider the regime where the number
of nodes ğ‘ â†’ âˆ and each of them holds an equal fraction of the
total stake. In this setting, by the Poisson approximation to a bi-
i.i.d.
nomial random variable, we have ğ»ğ‘¡
âˆ¼ Poisson((1 âˆ’ ğ›½)ğœŒ) and
i.i.d.
âˆ¼ Poisson(ğ›½ğœŒ), all independent of each other. An execution
ğ´ğ‘¡
EğœŒ,ğ›½,ğ‘‡h of time horizon ğ‘‡h is defined as the sequence {ğ»ğ‘¡ , ğ´ğ‘¡ }ğ‘¡ â‰¤ğ‘‡h
.
Denote by dCğ‘– (ğ‘¡) the longest fully downloaded chain of an hon-
est node ğ‘– at the end of slot ğ‘¡. Let |ğ‘ | denote the height of a block ğ‘.
We will also use the same notation |C| to denote the length of a chain
C. Define ğ¿ğ‘– (ğ‘¡) = |dCğ‘– (ğ‘¡)| and ğ¿min (ğ‘¡) = minğ‘– ğ¿ğ‘– (ğ‘¡). At the end of
each slot, honest node ğ‘– outputs the ledger LOGğ‘¡
ğ‘– = dCğ‘– (ğ‘¡) âŒˆğ‘‡conf ,
which consists of a list of transactions as ordered in all blocks in
dCğ‘– (ğ‘¡) with time slot up to ğ‘¡ âˆ’ ğ‘‡conf .

For a given execution of a consensus protocol, we define the

following two properties:

â€¢ Safety: For all adversarial strategies, for all time slots ğ‘¡, ğ‘¡ â€² and

honest nodes ğ‘–, ğ‘—, LOGğ‘¡

ğ‘– âª¯ LOGğ‘¡ â€²

ğ‘— or LOGğ‘¡ â€²

ğ‘— âª¯ LOGğ‘¡
ğ‘– .

â€¢ Liveness with parameter ğ‘‡live: For all adversarial strategies, if a
transaction tx is received by all honest nodes before slot ğ‘¡, then
for all honest nodes ğ‘– and slots ğ‘¡ â€² â‰¥ ğ‘¡ + ğ‘‡live, tx âˆˆ LOGğ‘¡ â€²
ğ‘– .

A consensus protocol is secure over a time horizon ğ‘‡h with parame-
ter ğ‘‡live if it satisfies safety and liveness with parameter ğ‘‡live with
overwhelming probability over executions of time horizon ğ‘‡h.

Definition 1. A slot ğ‘¡ is called successful if ğ´ğ‘¡ + ğ»ğ‘¡ > 0, uniquely
successful if ğ´ğ‘¡ = 0 and ğ»ğ‘¡ = 1, and adversarial if it is successful
but not uniquely successful. Define the predicates Unique(ğ‘¡) as
true iff slot ğ‘¡ is uniquely successful and Adv(ğ‘¡) as true iff slot ğ‘¡ is
adversarial.

For ğ‘  > ğ‘Ÿ , denote by B (ğ‘Ÿ, ğ‘ ], U (ğ‘Ÿ, ğ‘ ] and A (ğ‘Ÿ, ğ‘ ], the number of
successful, uniquely successful, and adversarial slots in the interval

7

(ğ‘Ÿ, ğ‘ ] respectively.

U (ğ‘Ÿ, ğ‘ ] â‰œ

ğ‘ 
âˆ‘ï¸

ğ‘¡ =ğ‘Ÿ +1

1{Unique(ğ‘¡)} , A (ğ‘Ÿ, ğ‘ ] â‰œ

ğ‘ 
âˆ‘ï¸

ğ‘¡ =ğ‘Ÿ +1

1{Adv(ğ‘¡)} (1)

and B (ğ‘Ÿ, ğ‘ ] = U (ğ‘Ÿ, ğ‘ ] +A (ğ‘Ÿ, ğ‘ ]. When ğ‘Ÿ = ğ‘ , then (ğ‘Ÿ, ğ‘ ] = âˆ… and thus
B (ğ‘Ÿ, ğ‘ ] = U (ğ‘Ÿ, ğ‘ ] = A (ğ‘Ÿ, ğ‘ ] = 0. We define the following constants:
ğ‘ â‰œ Pr [ğ´ğ‘¡ + ğ»ğ‘¡ > 0] = 1 âˆ’ ğ‘’âˆ’ğœŒ,
(2)
ğ‘U â‰œ Pr [Unique(ğ‘¡)] = (1 âˆ’ ğ›½)ğœŒğ‘’âˆ’ğœŒ,
ğ‘A â‰œ Pr [Adv(ğ‘¡)]

(4)
Definition 2. For a given download rule D, execution EğœŒ,ğ›½,ğ‘‡h and
ğ‘Ÿ < ğ‘  â‰¤ ğ‘‡h, MaxDLğ¾,(ğ‘Ÿ,ğ‘  ] (EğœŒ,ğ›½,ğ‘‡h, D) holds iff for all adversarial
strategies, for all uniquely successful slots in (ğ‘Ÿ, ğ‘ ], the block pro-
posed in that slot is downloaded by all honest nodes within the
first ğ¾ blocks downloaded in that slot.

= ğ‘ âˆ’ ğ‘U

(3)

We abbreviate MaxDLğ¾,(0,ğ‘‡h ] (EğœŒ,ğ›½,ğ‘‡h, D) as MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, D).

The inputs EğœŒ,ğ›½,ğ‘‡h and D to predicates are omitted where obvious.

4.2 General Proof Overview
Lemma 1. Let a download rule D, an execution EğœŒ,ğ›½,ğ‘‡h and ğ‘¡0 <
ğ‘  â‰¤ ğ‘‡h be such that MaxDLğ¾,(ğ‘¡0,ğ‘  ] (EğœŒ,ğ›½,ğ‘‡h, D) holds. Let ğ‘¡1, ..., ğ‘¡ğ‘š
be the uniquely successful slots in (ğ‘¡0, ğ‘ ]. Then,
(1) For all ğ‘— â‰¥ 1, |ğ‘ ğ‘— | > |ğ‘ ğ‘—âˆ’1|, where ğ‘ ğ‘— is the block proposed in ğ‘¡ ğ‘— .
(2) For all 0 â‰¤ ğ‘— â‰¤ ğ‘š and ğ‘¡ ğ‘— â‰¤ ğ‘¡ â‰¤ ğ‘ ,

ğ¿min (ğ‘¡) âˆ’ ğ¿min (ğ‘¡ ğ‘— ) â‰¥ U (cid:0)ğ‘¡ ğ‘— , ğ‘¡ (cid:3)

(5)

Proof. Part (1) is easily seen by the fact that honest nodes pro-
pose on their longest valid downloaded chain, ğ‘ ğ‘—âˆ’1 is downloaded
before ğ‘ ğ‘— is proposed, and is valid because it was proposed by an
honest node. Now, fix a ğ‘— such that 0 â‰¤ ğ‘— â‰¤ ğ‘š. If ğ‘— = ğ‘š, then
U (ğ‘¡ğ‘š, ğ‘¡] = 0 and ğ¿min (ğ‘¡) â‰¥ ğ¿min (ğ‘¡ğ‘š) for all ğ‘¡ğ‘š â‰¤ ğ‘¡ â‰¤ ğ‘  because
ğ¿min is non-decreasing. For ğ‘— < ğ‘š, since honest nodes propose
on their longest downloaded chain, |ğ‘ ğ‘—+1| â‰¥ ğ¿min (ğ‘¡ ğ‘—+1 âˆ’ 1) + 1 â‰¥
ğ¿min (ğ‘¡ ğ‘— ) + 1. From part (1) and that the blocks from uniquely suc-
cessful slots in (ğ‘¡ ğ‘— , ğ‘¡] are downloaded before the end of their re-
spective slots, we conclude that ğ¿min (ğ‘¡) â‰¥ |ğ‘ ğ‘—+1| + U (cid:0)ğ‘¡ ğ‘— , ğ‘¡ (cid:3) âˆ’ 1 â‰¥
ğ¿min (ğ‘¡ ğ‘— ) + U (cid:0)ğ‘¡ ğ‘— , ğ‘¡ (cid:3).
â–¡
Theorem 1. For all ğ¾ âˆˆ N and download rules D such that

(cid:104)

Pr

EğœŒ,ğ›½,ğ‘‡h : Â¬MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, D)

(cid:105)

â‰¤ negl(ğœ…),

(6)

if (1 âˆ’ ğ›½)ğœŒğ‘’âˆ’ğœŒ = 1âˆ’ğ‘’âˆ’ğœŒ
ğ¶ and
ğ‘‡conf = Î© (cid:0)(ğœ… + lnğ‘‡h)2(cid:1), then the protocol Î ğœŒ,ğœ,ğ‘‡conf with download
rule D is secure with ğ‘‡live = Î© (cid:0)(ğœ… + lnğ‘‡h)2(cid:1).

(1 + ğœ–1) for some ğœ–1 âˆˆ (0, 1), ğœ = Î”h + ğ¾

2

Theorem 1 is proved in Appendix D.1 using techniques similar

to [45].

4.3 â€˜Download Towards the Freshest Blockâ€™ Rule
Definition 3. For an execution EğœŒ,ğ›½,ğ‘‡h , ShortPrefixesğ¾ (EğœŒ,ğ›½,ğ‘‡h )
holds iff

âˆ€ğ‘¡ â‰¤ ğ‘‡h :

max
ğ‘Ÿ <ğ‘¡ : Unique(ğ‘Ÿ )âˆ§( A(ğ‘Ÿ,ğ‘¡ ] â‰¥U(ğ‘Ÿ,ğ‘¡ ])

A (ğ‘Ÿ, ğ‘¡] < ğ¾ .

(7)

Lemma 2. For an execution EğœŒ,ğ›½,ğ‘‡h and the freshest block download
rule Dfresh (Algorithm 2),

ShortPrefixesğ¾ (EğœŒ,ğ›½,ğ‘‡h ) =â‡’ MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, Dfresh)

(8)

8

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

Proof. Let ğ‘¡1, ..., ğ‘¡ğ‘š be the uniquely successful slots in (0,ğ‘‡h].
Let ğ‘ ğ‘— be the block from ğ‘¡ ğ‘— for some 1 â‰¤ ğ‘— â‰¤ ğ‘š. The header of ğ‘ ğ‘—
is received by all honest nodes within Î”h time after the beginning
of slot ğ‘¡ ğ‘— . Due to the downloading rule, during slot ğ‘¡ ğ‘— all honest
nodes download the chain containing ğ‘ ğ‘— . Furthermore, since ğ‘ ğ‘—
is an honest block and honest nodes only propose on their down-
loaded chain, the prefix of ğ‘ ğ‘— can be downloaded (i.e., does not
contain invalid or missing blocks). Thus, we only need to show that
the prefix of ğ‘ ğ‘— contains at most ğ¾ blocks whose contents have not
been downloaded.

For induction, assume that MaxDLğ¾,(0,ğ‘¡ ğ‘— âˆ’1] holds. Using this,
we will show that MaxDLğ¾,(0,ğ‘¡ ğ‘— +1âˆ’1] holds. For the base case, this
is true for ğ‘— = 1 since ğ‘¡1 is the first uniquely successful slot by
definition. Note that the block ğ‘ ğ‘— , being honest, is proposed on the
tip of dCğ‘– (ğ‘¡ ğ‘— âˆ’ 1) for some ğ‘–. Let ğ‘Ÿ ğ‘— be the last unique time slot
such that the block ğ‘ â€²
ğ‘— from that time slot is in dCğ‘– (ğ‘¡ ğ‘— âˆ’ 1). Clearly,
ğ‘Ÿ ğ‘— â‰¤ ğ‘¡ ğ‘— âˆ’ 1. Then,

|dCğ‘– (ğ‘¡ ğ‘— âˆ’ 1)| â‰¤ |ğ‘ â€²

ğ‘— | + A (cid:0)ğ‘Ÿ ğ‘— , ğ‘¡ ğ‘— âˆ’ 1(cid:3)
(9)
ğ‘— are from adversarial slots by definition of ğ‘Ÿ ğ‘— .

since blocks after ğ‘ â€²
From MaxDLğ¾,(0,ğ‘¡ ğ‘— âˆ’1] and part (1) of Lemma 1,
ğ‘— | + U (cid:0)ğ‘Ÿ ğ‘— , ğ‘¡ ğ‘— âˆ’ 1(cid:3) .
|ğ‘ ğ‘—âˆ’1| â‰¥ |ğ‘ â€²

(10)

Since ğ‘ ğ‘—âˆ’1 is downloaded by the end of slot ğ‘¡ ğ‘—âˆ’1 and ğ‘¡ ğ‘— âˆ’ 1 â‰¥ ğ‘¡ ğ‘—âˆ’1,
|dCğ‘– (ğ‘¡ ğ‘— âˆ’ 1)| â‰¥ |ğ‘ ğ‘—âˆ’1|, and this would imply from (9) and (10) that
A (cid:0)ğ‘Ÿ ğ‘— , ğ‘¡ ğ‘— âˆ’ 1(cid:3) â‰¥ U (cid:0)ğ‘Ÿ ğ‘— , ğ‘¡ ğ‘— âˆ’ 1(cid:3). Note that time slots of blocks in a
valid chain must be strictly increasing. Since ğ‘ â€²
ğ‘— is already down-
loaded, the number of blocks in dCğ‘– (ğ‘¡ ğ‘— âˆ’ 1) whose content is not
downloaded is at most A (cid:0)ğ‘Ÿ ğ‘— , ğ‘¡ ğ‘— âˆ’ 1(cid:3). Since ğ‘ ğ‘— extends dCğ‘– (ğ‘¡ ğ‘— âˆ’ 1),
the number of block contents to be downloaded including the pre-
fix of ğ‘ ğ‘— is at most A (cid:0)ğ‘Ÿ ğ‘— , ğ‘¡ ğ‘— âˆ’ 1(cid:3) + 1. As per ShortPrefixesğ¾ , this
is at most ğ¾ (note that ğ‘Ÿ ğ‘— â‰¤ ğ‘¡ ğ‘— âˆ’ 1). Therefore, ğ‘ ğ‘— is downloaded
within one slot. Since there are no more uniquely successful slots
in (ğ‘¡ ğ‘— , ğ‘¡ ğ‘—+1), this completes the induction step by showing that
MaxDLğ¾,(0,ğ‘¡ ğ‘— +1âˆ’1] . For ğ‘— = ğ‘š, we would conclude with MaxDLğ¾
â–¡
as required.
Lemma 3. If (1 âˆ’ ğ›½)ğœŒğ‘’âˆ’ğœŒ = 1âˆ’ğ‘’âˆ’ğœŒ
ğ¾ = ğ‘Ağ‘‡ (1 + ğœ–2) for some ğœ–2 > 0 where ğ‘‡ =
EğœŒ,ğ›½,ğ‘‡h : Â¬ShortPrefixesğ¾ (EğœŒ,ğ›½,ğ‘‡h )

(1 + ğœ–1) for some ğœ–1 âˆˆ (0, 1) and
Î© (ğœ…+lnğ‘‡h)
ğ›¼2ğ‘
â‰¤ negl(ğœ…),

, then

(11)

Pr

2

(cid:104)

(cid:105)

where ğ›¼2 = min

(cid:110) ğœ– 2
1
36

, ğœ– 2
2
ğœ–2+2

(cid:111).

ğ‘A
ğ‘

Corollary 1. The protocol Î ğœŒ,ğœ,ğ‘‡conf with the freshest block down-
load rule and parameters ğœŒ such that (1 âˆ’ ğ›½)ğœŒğ‘’âˆ’ğœŒ = 1âˆ’ğ‘’âˆ’ğœŒ
(1 + ğœ–1),
ğœ = Î©(ğœ… + lnğ‘‡h), ğ‘‡conf = Î© (cid:0)(ğœ… + lnğ‘‡h)2(cid:1) is secure with ğ‘‡live =
Î© (cid:0)(ğœ… + lnğ‘‡h)2(cid:1).

2

Lemma 3 is proved in Appendix D.4 and Corollary 1 is obtained
ğ¶ and ğ¾ as per Lemma 3.

by setting ğœ = Î”h + ğ¾

5 EXPERIMENTS
5.1 Implementation Details
We implemented our PoS LC node in 800 lines of Golang.3 For all
of our experiments, the slot duration ğœ is set to 1 second, and the

3The source code is available at: https://github.com/yangl1996/synclc-sim

Longest Chain Consensus Under Bandwidth Constraint

total block production rate is 0.06 blocks/s. There is no transaction
processing. Instead, nodes fill blocks with random bytes up to a
size limit (100 KB in our experiments).

Our implementation has a fully-featured network stack modelled
after Cardanoâ€™s node software [14, 15]. Similar to Cardano, block
propagation involves two subsystems: chain sync, and block fetch.
The chain sync subsystem allows a node to advertise the header
chain of the longest chain it has downloaded and validated, and to
track the header chains advertised by peers. Because the header only
takes a tiny fraction of space in a block, the bandwidth consumed
by the chain sync subsystem is negligible. In all of our experiments,
chain sync only consumed up to 1.2% of the available bandwidth.
The block fetch subsystem periodically examines the header
chains learned from peers through chain sync, and sends requests
to download block bodies according to a download rule. We im-
plement the two download rules discussed in Section 1: â€˜download
along the longest header chainâ€™, and â€˜download towards the freshest
blockâ€™. Similar to Cardano, our block fetch logic limits the maximum
number of peers to concurrently download from, an important pa-
rameter which we call the in-flight cap. This ensures the limited
network bandwidth is never spread too thin across too many con-
current downloads. Finally, chain sync and block fetch share the
same TCP connection for each pair of peers. To avoid head-of-line
blocking, we multiplex the two subsystems so that chain sync is
never impaired by block fetch traffic.

To simulate bandwidth constraints, we build our testbed using
Mininet [37]. Each blockchain node runs in a Mininet virtual host
with its own network interface, and is connected to a central switch
through a link with limited bandwidth and artificial propagation de-
lay. Specifically, we limit the bandwidth of honest nodes to 20 Mbps,
and adversarial nodes to 1 Gbps. We set the round-trip time be-
tween any pair of nodes to 100 ms. The testbed runs on a worksta-
tion with two Intel Xeon E5-2623 v3 CPUs and 32 GB of RAM.

5.2 Demonstration of the Spamming Attack
In this experiment, we show that the widely-adopted â€˜download
along the longest chainâ€™ rule is vulnerable to adversarial spamming,
and the â€˜download towards the freshest blockâ€™ rule mitigates this
attack. There are 20 honest nodes connected in a full mesh topology.
Honest nodes equally split 67% of the total stake, so each honest
node has a block production rate of 0.002 block/s. The adversary
controls 33% of the stake (0.02 block/s), and sets up 5 attacking
nodes. Each attacking node connects to all honest nodes. The ad-
versary uses the attacking nodes to monitor the longest chains
announced by honest nodes, and tries to mine equivocating spam
chains (cf. Figure 3). When successful, the adversary announces
them and hopes honest nodes download these spam chains.

Figure 5 shows the time series of honest chain growth over an
hour when the in-flight cap is set to 2. Note that honest chain
growth stalls after 400 seconds when nodes download the longest
chain. Since there are 5 attacking nodes, once the adversary gets a
longer chain by luck, each honest user will use all of its 2 in-flight
slots to download spam chains (from 2 of the 5 attacking nodes),
leaving no room for honest blocks. Before any honest node finishes
downloading a spam block, the adversary will have advertised an-
other equivocating chain, keeping the honest nodes busy. Although

h
t
g
n
e
l

n
i
a
h
c
l
a
c
o
L

150

100

50

0

0

Download freshest block
Attack on freshest block

Download longest chain
Attack on longest chain

500

1,000

1,500

2,000

2,500

3,000

3,500

Time [s]

Figure 5: Traces of honest chain growth under spamming
attack (cf. Figure 3) when using different download rules
and an in-flight cap of 2. Each curve represents one honest
node. Shaded areas represent time periods when nodes
are suffering from the attack and are downloading invalid
blocks. PoS LC downloading longest chain stalls. PoS LC
downloading freshest blocks is robust.

Download freshest block
Number of adversarial nodes

Download longest chain
Honest block production rate

n
i
a
h
c
t
s
e
n
o
H

]
1
âˆ’
s
[
e
t
a
r
h
t
w
o
r
g

0.04

0.02

0

2

3

4

5

6

7

Max number of concurrent chain downloads (in-flight cap)

Figure 6: Honest chain growth rate under spamming attack
(cf. Figure 3) while allowing concurrent block downloads
from different number of peers. With in-flight cap below the
number of adversarial peers, PoS LC downloading longest
chain shows performance degradation; PoS LC downloading
freshest block is robust.

Freshest block, 10 attackers
Freshest chain, 5 attackers

Longest chain, 10 attackers
Longest chain, 5 attackers

s
k
c
o
l
b
f
o
n
o
i
t
c
a
r
F

1

0.5

0

0

2

4

6
Propagation delay [s]

8

10

12

Figure 7: Empirical cumulative density function of block
propagation delay under different download rules, facing
different number of attackers, and an infinite in-flight cap.

honest nodes can still mine blocks, they cannot download blocks
from each other, so each honest node effectively mines on its own
fork. The resulting heavy forking causes the honest chains to grow
slower than the adversary mining rate, and the adversary maintains
the lead in chain length and sustains this attack (red-shaded areas
in Figure 5) until the experiment ends.

9

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

In comparison, honest chain growth is unaffected when nodes
download towards the freshest block. Note that although the adver-
sary is still able to trick honest nodes into downloading spam blocks
(blue-shaded areas in Figure 5), the adversary cannot sustain the
attack: when a new honest block is produced, the chain containing
that fresh block will be prioritized. Before the adversary manages
to produce a fresher block, all honest nodes will have caught up on
the correct chain. Further experiments in Appendix B.2 show that
honest chain growth is unaffected with even larger block sizes.

]
s
p
b
M

[
c
ffi
a
r
t
d
a
o
l
n
w
o
D

20

15

10

5

0

Download freshest block
Attack on freshest block

Download longest chain
Attack on longest chain

0

100

200

300

400

500

Time [s]

5.3 Impact of the In-Flight Cap
We now extend the previous experiment by varying the in-flight
cap between 2 and 7, and demonstrate the relationship between
the in-flight cap and the number of attacking nodes. Figure 6 shows
the results. When the in-flight cap is equal to or smaller than the
number of attacking nodes, downloading the longest chain is not
secure. This may remind readers of the eclipse attack [12, 28, 49â€“
51]: the adversary is in fact eclipsing the honest nodes in the block
fetch subsystem by occupying all its in-flight slots. Meanwhile,
downloading the freshest chain is always secure regardless of the
in-flight cap, because a fresh honest block can break such eclipse.
Figure 6 seems to suggest that downloading the longest chain is
secure when the in-flight cap is larger than the number of attackers.
Is it true? Should we then increase the in-flight cap to infinity? We
point out that the in-flight cap ensures each in-flight download
gets a sufficiently large share of the available bandwidth to com-
plete in a reasonable amount of time. This is critical in ensuring
low propagation delay for honest blocks. As an extreme example,
assume that there are a large number of attacking nodes and an
infinite in-flight cap. Although a node will always start download-
ing an honest block as soon as it receives the announcement, the
bandwidth allocated to download this block will be extremely small
due to the competing downloads of adversarial blocks, effectively
halting the download. As a result, a finite in-flight cap is necessary,
and the attacker can always attack the â€˜download along the longest
chainâ€™ rule by outnumbering the in-flight cap.

To demonstrate this effect, we remove the in-flight cap, increase
the number of attacking nodes to 10, and measure the block propa-
gation time. The results in Figure 7 show that the propagation time
under both rules increases. This is because when the attack is active,
there are more competing flows downloading spam blocks, leaving
less bandwidth for honest blocks. Still, the chain growth rate is
unharmed when downloading the freshest chain, at 0.041 block/s.
This is because nodes can break away from the spam chain as soon
as a new honest block is produced, regardless how bad the prop-
agation time is under active spam. In comparison, the propagation
delay when downloading the longest chain becomes much worse.
In fact, the higher delay causes the chain growth rate to drop to
0.035 block/s. In conclusion, removing or increasing the in-flight
cap does not save the â€˜download along the longest chainâ€™ rule, but
impacts the block propagation delay of the â€˜download towards the
freshest blockâ€™ rule only slightly so that security is unaffected.

5.4 Bandwidth Consumption
Besides block bodies, a blockchain node needs to receive other types
of traffic in real time, such as unconfirmed transactions, requests

10

Figure 8: Traces of download traffic over a 500-second period
at one of the victim nodes when using different download
rules and in-flight cap of 4. Shaded areas represent time
periods when the node is suffering from the attack and
downloading invalid blocks.

from clients, and remote control data. A practical download rule
must not consume all the available bandwidth at a node at all time.
As explained in Section 5.2, under the â€˜download towards the fresh-
est blockâ€™ rule, an honest node breaks free from the spam chains
when an honest block is mined. That is, spamming stops when
there is a time slot with only one honest block proposed. Intuition
suggests that as long as the overall mining rate is not too high, such
event should happen frequently. Indeed, the ingress traffic traces
in Figure 8 show that periods of high network utilization only last
for tens of seconds when downloading the freshest block, quickly
succeeded by long windows of low utilization. In comparison, when
downloading the longest chain, the period of high utilization lasts
until the end of the experiment, leaving no room for honest blocks
or other traffic.

6 OTHER DOWNLOAD RULES
6.1 Equivocation Avoidance
We formalize a common heuristic to deal with equivocations, namely
downloading only one out of many equivocations in Algorithm 4.
In every time slot when a node wishes to download blocks, it filters
the tree consisting of block headers it has received by retaining
only one leaf in the tree for each block production opportunity
(determined by the proposing node and the time slot of each block).
We strengthen the adversary by allowing it to decide, per honest
node and time slot, which among multiple equivocating headers
would be retained. After removing equivocations, invalid chains,
and chains that are already downloaded from the header tree, the
node selects the longest header chain, and downloads the content
for the first missing block in this chain.

Here, we have illustrated equivocation avoidance as a modifica-
tion to the longest header chain download rule. By doing so, we
show that while the longest header chain download rule was in-
secure by itself, it can be made secure by â€˜avoiding equivocationsâ€™.
However, equivocation avoidance could also be added to the fresh-
est block rule to make it more efficient. Our analysis below suggests
that the freshest block rule by itself is already more efficient than
the longest header chain rule with equivocation avoidance because
the latter requires downloading a much larger number of blocks
within one time slot (see Corollaries 1, 2), leading to longer time
slots and poorer bandwidth utilization.

Longest Chain Consensus Under Bandwidth Constraint

Algorithm 4 â€˜Equivocation avoidanceâ€™ download rule; replaces
downloadRule in Algorithm 1 (cf. Appendix A.1)

Î© ( 1
ğœ… )

Î© ( 1
ğœ… )

1: on Î”h time into each time slot ğ‘¡
2:

âŠ² Before beginning block content downloads for time slot ğ‘¡ , filter current
header tree to keep at most one leaf per block production opportunity, i.e.,
per (node, time) pair (equivocation avoidance; ties broken adversarially)
hTâˆ— â† oneLeafPerProductionOpportunity(Î ğœŒ,ğœ,ğ‘‡conf .hT)

3:
4: function avoidEquivocations(hT, blkTxs)
5:
6:
7:
8:
9:
10:
11:
12:
13:

âŠ² Ignore chains with invalid content in any block
Tâ€² â† { C âˆˆ hTâˆ— | âˆ€Câ€² âª¯ C : blkTxs[ Câ€²] â‰  invalid}
âŠ² Ignore downloaded chains
Tâ€² â† { C âˆˆ Tâ€² | blkTxs[ C ] = unknown}
âŠ² Select the longest chain
C â† arg maxCâ€²âˆˆTâ€² | Câ€² |
âŠ² Find the first not downloaded block on that chain (if non-existent: âŠ¥)
Câ€² â† arg minCâ€²â€²âª¯C : blkTxs[Câ€²â€² ]=unknown | Câ€²â€² |
return Câ€²

6.2 Analysis
We use the general framework developed in Section 4 to prove
security of PoS LC under the equivocation avoidance download
rule. Recall that we only need to prove that MaxDLğ¾ (Definition 2)
holds with overwhelming probability.

In a uniquely successful slot, honest nodes may not immediately
download towards the block from that slot. This is because there
could be other chains in a nodeâ€™s header tree that are longer (recall
that Algorithm 4 prioritizes the longest header chain after removing
equivocations and invalid prefixes). However, we can bound the
number of blocks that will be downloaded before downloading the
block from the uniquely successful slot. With equivocation avoid-
ance, honest nodes retain only one leaf in their header tree per
block production opportunity. So, honest nodes download at most
one chain per block production opportunity. Since block production
opportunities are bounded, we will show in Lemma 4 that there can
not be too many longer chains in the honest nodeâ€™s header tree.

Define for slots ğ‘  â‰¤ ğ‘¡,
ğ‘Šğ‘ ,ğ‘¡ â‰œ

max
ğ‘Ÿ <ğ‘  : Unique(ğ‘Ÿ )âˆ§( A(ğ‘Ÿ,ğ‘  ] â‰¥U(ğ‘Ÿ,ğ‘¡ ])
Definition 4. For an execution EğœŒ,ğ›½,ğ‘‡h , FewLongChainsğ¾ (EğœŒ,ğ›½,ğ‘‡h )
holds iff

A (ğ‘Ÿ, ğ‘ ] .

(12)

âˆ€ğ‘¡ â‰¤ ğ‘‡h : ğ‘Šğ‘¡ âˆ’1,ğ‘¡ âˆ’1 +

âˆ‘ï¸

ğ‘  â‰¤ğ‘¡

ğ´ğ‘ ğ‘Šğ‘ ,ğ‘¡ < ğ¾ .

(13)

Lemma 4. For an execution EğœŒ,ğ›½,ğ‘‡h and the longest header chain
download rule with equivocation avoidance Dlhcâˆ’ea (Algorithm 4),
FewLongChainsğ¾ (EğœŒ,ğ›½,ğ‘‡h ) =â‡’ MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, Dlhcâˆ’ea) (14)
Lemma 5.
(1 + ğœ–1) for some ğœ–1 âˆˆ (0, 1)
2
and ğ¾ = ğ‘Ağ‘‡b (1 + ğ›½ğœŒğ‘‡b (1 + ğœ–3))(1 + ğœ–2) for some ğœ–2, ğœ–3 > 0 where
ğ‘‡b =

If (1 âˆ’ ğ›½)ğœŒğ‘’âˆ’ğœŒ = 1âˆ’ğ‘’âˆ’ğœŒ

Î© (ğœ…+lnğ‘‡h)
ğ›¼3ğ‘
(cid:104)
EğœŒ,ğ›½,ğ‘‡h : Â¬FewLongChainsğ¾ (EğœŒ,ğ›½,ğ‘‡h )

(cid:105)

â‰¤ negl(ğœ…)

(15)

, then

Pr

whereğ›¼3 = max

ğœ– 2
ğ›½ğœŒ
ğ‘ , ğ‘U (1âˆ’ğœ–3)
ğ‘A
3
(ğœ–3+2)ğ‘
Lemma 4 is proved in Appendix D.5 and Lemma 5 in Appen-

, ğœ– 2
2
ğœ–2+2

ğ‘U
2ğ‘ ,

(cid:16) ğ‘U
1âˆ’ğ‘U

(cid:110) ğœ– 2
1
36

, ğœ– 2

ln

(cid:17)

ğ‘

3

(cid:111).

dix D.6. Then, we obtain the following corollary of Theorem 1.

11

Passively following Î ğœŒ,ğœ,ğ‘‡conf

Actively participating in Î ğœŒ,ğœ,ğ‘‡conf

(a)

(b)

â‰¤

(cid:17)

(cid:16) 1+ğ‘
2

Î© ( 1
ğœ… )

Parallel composition of Î ğœŒ,ğœ,ğ‘‡conf

...

(c)

Primary chain

Secondary chains

Figure 9: Worst-case throughput and bandwidth consump-
tion, as a fraction of the total bandwidth. Green portions rep-
resent bandwidth consumption that contributes to through-
put, while red portions represent bandwidth consumption
that is caused by the adversary and may not contribute to
throughput (e.g., empty/invalid blocks, spamming).

Corollary 2. The protocol Î ğœŒ,ğœ,ğ‘‡conf with the equivocation avoidance
download rule and parameters ğœŒ such that (1 âˆ’ ğ›½)ğœŒğ‘’âˆ’ğœŒ = 1âˆ’ğ‘’âˆ’ğœŒ
(1 +
ğœ–1),ğœ = Î© (cid:0)(ğœ… + lnğ‘‡h)2(cid:1) andğ‘‡conf = Î© (cid:0)(ğœ… + lnğ‘‡h)2(cid:1), is secure with
ğ‘‡live = Î© (cid:0)(ğœ… + lnğ‘‡h)2(cid:1).

2

6.3 Blocklisting
Another common heuristic to deal with equivocations is â€˜block-
listingâ€™ the proposer of equivocating blocks. Blocklisting can be
implemented at the level of the download rule as follows: an honest
node never downloads a chain whose tip is proposed by a party for
which the node has seen two block headers with the same time slot
(an equivocation). Blocklisting is a decision that is taken unilater-
ally by each honest node and may be taken at different points of
time by different nodes.

Note that this is only a stricter version of the equivocation avoid-
ance rule described in Section 6.1 because in any given time slot,
a block that is rejected in the equivocation avoidance rule will also
be rejected in the blocklisting rule. Moreover, any chain whose tip
is proposed by an honest node will not be discarded under this rule.
Therefore, for any execution EğœŒ,ğ›½,ğ‘‡h and the blocklisting rule Dblist
MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, Dlhcâˆ’ea) =â‡’ MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, Dblist). (16)
Therefore, security of PoS LC with the â€˜blocklistingâ€™ rule is implied
by security of PoS LC with â€˜equivocation avoidanceâ€™ rule and the
same parameters.

7 HIGH THROUGHPUT

UNDER BANDWIDTH CONSTRAINT

In what follows, we use the freshest block download rule as our
running example, but the results carry over analogously to other
download rules analyzed using our unified framework, such as
those in Section 6. From Corollary 1, we parameterize Î ğœŒ,ğœ,ğ‘‡conf
with the freshest block download rule with ğœ = Î©(ğœ…) for security,
so the protocol gets slower as the security parameter increases. A
similar slowdown is also observed in the analysis in [24]. Thus, the
throughput of Î ğœŒ,ğœ,ğ‘‡conf decreases with increasing security param-
eter. Indeed, we show in Section 7.2 that the worst-case throughput
of Î ğœŒ,ğœ,ğ‘‡conf is lower bounded by 2ğ‘Uâˆ’ğ‘

.

ğœ

= 1

Î© (ğœ…)

ğ‘¡ âˆ’ ğ‘‡conf

ğ‘¡

Primary Chain

...

...

Time

Î ğœŒ,ğœ,ğ‘‡conf

1

Î ğœŒ,ğœ,ğ‘‡conf

2

3

Î ğœŒ,ğœ,ğ‘‡conf
...

Î ğœŒ,ğœ,ğ‘‡conf
ğ‘š

Secondary Chains

Follow secondary chainsâ€™
confirmed blocks

Follow primary chainâ€™s
freshest blocks

Figure 10: In the parallel chains construction using Î ğœŒ,ğœ,ğ‘‡conf ,
each node is assigned one primary chain; the other (ğ‘š âˆ’ 1)
chains are secondary. Nodes participate actively in their
primary chain using, for example, the freshest block down-
load rule, and follow their secondary chains passively by
downloading confirmed blocks only.

The slow block production rate also means that passively follow-
ing the confirmed blocks of a chain only requires downloading up to
ğ‘
blocks per second because the secure protocol Î ğœŒ,ğœ,ğ‘‡conf
ğœ = 1
Î© (ğœ…)
has already achieved consensus on these blocks (see Figure 9(a)).
In fact, the ratio between throughput and the bandwidth required
to download the confirmed blocks is the chain quality (fraction
of honest blocks in the chain). This fraction, 2ğ‘Uâˆ’ğ‘
> 0 is inde-
pendent of the security parameter ğœ…. This suggests to invoke the
idea of Parallel Chains [23, 24]: fill the available bandwidth using
multiple instances of the slow LC protocol in parallel and combine
the transactions of all instances into a single ledger. By increas-
ing the number of chains, one can compensate for the decreasing
throughput of the individual chains as ğœ… is increased.

ğ‘

However, following the confirmed chains alone is not enough to
achieve consensus on all these chains. Note that the bandwidth con-
sumption of a node actively participating in Î ğœŒ,ğœ,ğ‘‡conf may be higher
than what is required to download only the confirmed chain, due
to spamming attacks. By spending this additional bandwidth, the
nodes actively participating in Î ğœŒ,ğœ,ğ‘‡conf make the protocol secure,
which is what allows other nodes to passively follow and download
the confirmed chain with little bandwidth consumption. However,
even under spamming attacks, we show in Section 7.2 that the worst-
case bandwidth consumption is only a little more than half the avail-
able bandwidth ğ¶ (shown in Figure 9(b)). This leaves nearly half the
bandwidth available for a node participating in Î ğœŒ,ğœ,ğ‘‡conf to down-
load the confirmed portions of other parallel chains. This still allows
us to increase the number of parallel chains to occupy the remaining
bandwidth (shown in Figure 9(c)). So, we modify the parallel chains
construction from [23, 24] as described in the following section.

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

7.1 Parallel Chains Construction
The protocol consists of ğ‘š parallel instances of Î ğœŒ,ğœ,ğ‘‡conf (see Fig-
ure 10). For simplicity, assume that at genesis (and after the adver-
sary has chosen which nodes to corrupt), stakeholders are randomly
partitioned into ğ‘š equally sized sets, and the nodes of each set get
assigned a particular instance of Î ğœŒ,ğœ,ğ‘‡conf as their primary chain.
Nodes are responsible for maintaining consensus on their primary
chain. For this purpose, they download blocks as per a secure down-
load rule and propose blocks on their primary chain as described in
Î ğœŒ,ğœ,ğ‘‡conf . The remaining (ğ‘šâˆ’1) instances of Î ğœŒ,ğœ,ğ‘‡conf that are not
a nodeâ€™s primary chain are considered its secondary chains. Nodes
do not participate actively in consensus building on their secondary
chains, but only download the confirmed blocks from those chains,
as determined by the ğ‘‡conf -deep LC confirmation rule based on the
block headers. Transactions from the confirmed portion of all the
chains are first ordered by their time slots and then by the index
of the protocol instance they appear in, to then be merged into a
single output ledger. Moreover, every transaction can be included
only in a single Î ğœŒ,ğœ,ğ‘‡conf instance determined, e.g., based on the
transactionâ€™s hash or sender address, so as to avoid duplicating
transactions across different Î ğœŒ,ğœ,ğ‘‡conf instances. See Appendix C
for pseudocode for the above parallel chains construction.

Each instance of Î ğœŒ,ğœ,ğ‘‡conf is secure if at most ğ›½ fraction of nodes
for whom this instance is the primary chain are corrupt, and the
parameters ğœŒ, ğœ,ğ‘‡conf satisfy the constraints in Theorem 1. Note
that if the number of stakeholders assigned to each primary chain
is large, then the adversarial power in each instance of Î ğœŒ,ğœ,ğ‘‡conf
is very likely close to the overall adversarial power, rendering the
construction secure against non-adaptive adversaries that corrupt
at most ğ›½ fraction of the nodes. See Appendix E for a more detailed
security analysis.

7.2 Throughput and Bandwidth Consumption
To quantify the throughput of Î ğœŒ,ğœ,ğ‘‡conf , we first note that the
longest chain in any honest nodeâ€™s view grows at least at the rate of
uniquely successful slots, ğ‘U blocks per slot (Lemma 1). Moreover,
we can lower bound the chain quality, i.e., the fraction of blocks
in the blockchain in any honest nodeâ€™s view, which are proposed
by honest nodes. All blocks proposed by honest nodes will contain
distinct and valid transactions. Therefore, the chain quality along
with the chain growth rate give a lower bound on the throughput.

Lemma 6. (Throughput) There exists a constant ğ‘‡1 such that for any
honest node ğ‘– and time slots ğ‘¡1, ğ‘¡2 â‰¥ ğ‘¡1 + ğ‘‡ with ğ‘‡ â‰¥ ğ‘‡1, dCğ‘– (ğ‘¡2) \
dCğ‘– (ğ‘¡1) contains at least ğœƒğ‘‡ (1 âˆ’ ğœ–4) blocks proposed by honest nodes,
with probability at least 1 âˆ’ exp(âˆ’ğ›¼4ğ‘‡ ), where ğœƒ = 2ğ‘U âˆ’ ğ‘.

From Lemma 6, the throughput of each chain is at least TP1 = ğœƒ
ğœ
blocks per second.4 Note that this lower bound holds under the
worst-case adversary strategy.

Next, we calculate the bandwidth consumption of passively fol-
lowing the confirmed blocks of a secondary chain. Due to the se-
curity of Î ğœŒ,ğœ,ğ‘‡conf run by the nodes for whom the corresponding

4For simplicity, we consider a constant number of transactions in each block. Hence,
this directly translates to throughput in transactions per second.

12

Longest Chain Consensus Under Bandwidth Constraint

chain is primary, the confirmed chain contains only valid avail-
able blocks and can be downloaded by spending little bandwidth
without any interference from spamming blocks.

Lemma 7. (Passive Bandwidth Consumption) There exists a constant
ğ‘‡2 such that for any honest nodes ğ‘–, ğ‘– â€² and time slots ğ‘¡1, ğ‘¡2 â‰¥ ğ‘¡1 +ğ‘‡ such
ğ‘¡2
ğ‘¡1
that ğ‘‡ â‰¥ ğ‘‡2, LOG
contains at most ğœ™pğ‘‡ (1 + ğœ–5) blocks,
ğ‘–â€² \ LOG
ğ‘–
with probability at least 1 âˆ’ exp(âˆ’ğ›¼5ğ‘‡ ), where ğœ™p = ğ‘.

Finally, we analyze the worst-case bandwidth consumption of
active nodes in Î ğœŒ,ğœ,ğ‘‡conf . As per the freshest block download rule
(see Algorithm 2, lines 6ff.), once all blocks proposed in the most re-
cent non-empty time slot have been downloaded, the downloading
node stays idle (because then C = âŠ¥ in Algorithm 1, line 6). Since
in every uniquely successful slot, each node downloads the freshest
block within one slot (Lemma 2), the node thereafter remains idle
until the next block proposal. This gives a simple lower bound on
the worst-case fraction of time a nodeâ€™s bandwidth consumption is
idle. (See Figure 8 for a matching observation in our experiments.)

Lemma 8. (Active Bandwidth Consumption) There exists a constant
ğ‘‡3 such that for any honest node ğ‘– and time slots ğ‘¡1, ğ‘¡2 â‰¥ ğ‘¡1 + ğ‘‡ with
ğ‘‡ â‰¥ ğ‘‡3, nodeğ‘– does not download any blocks for at leastğœ™idleğ‘‡ğœ (1âˆ’ğœ–6)
time during the interval of time slots (ğ‘¡1, ğ‘¡2], with probability at least
ğ‘U (1âˆ’ğ‘)
1 âˆ’ exp(âˆ’ğ›¼6ğ‘‡ ), where ğœ™idle =
ğ‘

â‰¥ 1âˆ’ğ‘
2

.

Lemmas 6, 7 and 8 are proved in Appendix D.7. Lemma 8 implies
that a bandwidth of at least ğœ™idle Â· ğ¶ remains unutilized by each
nodeâ€™s primary chain. From Lemma 7, each node needs to download
on average ğœ™p blocks per slot, or ğœ™p
ğœ blocks per second, to follow
the confirmed blocks of one of the secondary chains. This allows
ğœ™idle
each node to follow ğ‘š âˆ’ 1 =
ğ¶ğœ number of secondary chains.
ğœ™p
Therefore the ğ‘š parallel chains have an aggregate throughput of

TPğ‘š = ğ‘š TP1 =

=

(cid:18)

1 +

ğœ™idle
ğœ™p
(1 âˆ’ ğ‘)ğœ–1
2

ğ¶ğœ

(cid:19) ğœƒ
ğœ

â‰¥

(1 âˆ’ ğ‘)(2ğ‘U âˆ’ ğ‘)
2ğ‘

ğ¶

ğ¶ blocks per second

(17)

using ğ‘U = 1
ğ‘ (1 + ğœ–1) from Theorem 1. Therefore, the aggregate
2
throughput of the parallel chains remains within a constant fraction
of the optimal throughput which is the bandwidth of ğ¶ blocks per
second. This is true even if the number of secondary chains is param-
eterized so that the protocol produces an average load of only a cer-
tain fraction of the bandwidth left over by the primary chain, so as to
bound queuing delays due to fluctuations in bandwidth utilization.
Notice that the throughput and passive bandwidth consump-
tion of the protocol do not change with the download rule. With
â€˜equivocation avoidanceâ€™ and â€˜blocklistingâ€™, by doubling ğ¾ such that
MaxDLğ¾/2 holds (thereby roughly doubling the time slot duration),
and ensuring that honest nodes do not download more than ğ¾/2
blocks in any slot, the active bandwidth utilization is explicitly
bounded by half the available bandwidth. Thus, the parallel chains
construction with these download rules also behaves similarly.

The worst-case throughput of a single chain and that of the paral-
lel construction are limited by the chain quality factor ğœ–1 = 2ğ‘Uâˆ’ğ‘
due to the possibility of selfish mining attacks [22]. Using the Con-
flux inclusion rule from [38] (which is also employed in [24]), this
factor can be improved to ğ‘U
ğ‘ (which does not vanish as we push the

ğ‘

13

resilience ğ›½ closer to 1/2). In this rule, each block includes pointers
to blocks that are not in its prefix, in order to include them in the
ledger. To adapt this rule to bandwidth constrained networks, we
modified it to ensure that only one block from each block produc-
tion opportunity is pointed to and the number of pointers in each
block is limited yet enough to include honest blocks. The details
of this construction are in Appendix F.

Finally, in a comparison with [24], both works show a parallel
chains construction that achieves throughput up to a constant frac-
tion of the network capacity. However, our work proves this under
worst-case adversarial strategies (including, inter alia, equivocation-
based spamming), while [24] proves security only for adversaries
that do not aggravate network congestion so much that a delay
upper bound is violated. On the other hand, the security of our
construction requires static corruption and honest majority among
nodes in each chain (as each nodes performs consensus on one
chain), whereas [24] works under a global honest majority assump-
tion (as each node participates in all chains).

ACKNOWLEDGMENT
We thank Dan Boneh and Ertem Nusret Tas for fruitful discussions.
JN is supported by the Protocol Labs PhD Fellowship, a gift from
Ethereum Foundation, and the Reed-Hodgson Stanford Graduate
Fellowship.

REFERENCES
[1] 2020. Bitcoin Developer Guide â€“ P2P Network â€“ Initial Block Download â€“ Headers-
First. https://developer.bitcoin.org/devguide/p2p_network.html#headers-first
[2] 2021. Ethereum 2.0 networking specification. https://github.com/ethereum/eth2.0-

specs/blob/dev/specs/phase0/p2p-interface.md

[3] Maria Apostolaki, Aviv Zohar, and Laurent Vanbever. 2017. Hijacking Bitcoin:
Routing Attacks on Cryptocurrencies. In 2017 IEEE Symposium on Security and
Privacy (SP). 375â€“392. https://doi.org/10.1109/SP.2017.29

[4] Christian Badertscher, Peter GaÅ¾i, Aggelos Kiayias, Alexander Russell, and Vassilis
Zikas. 2018. Ouroboros Genesis: Composable proof-of-stake blockchains with
dynamic availability. In Conference on Computer and Communications Security
(CCS â€™18). ACM, 913â€“930.

[5] Vivek Bagaria, Amir Dembo, Sreeram Kannan, Sewoong Oh, David Tse, Pramod
Viswanath, Xuechao Wang, and Ofer Zeitouni. 2019. Proof-of-Stake Longest
Chain Protocols: Security vs Predictability. arXiv preprint arXiv:1910.02218 (2019).
[6] Vivek Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and Pramod Viswanath.
2019. Prism: Deconstructing the Blockchain to Approach Physical Limits. In
Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications
Security (CCS â€™19). ACM, 585â€“602.

[7] Vitalik Buterin. 2014. Proof of Stake: How I Learned to Love Weak Subjectivity.
Retrieved 2022-05-05 from https://blog.ethereum.org/2014/11/25/proof-stake-
learned-love-weak-subjectivity/

[8] Vitalik Buterin and Virgil Griffith. 2017. Casper the Friendly Finality Gadget.
CoRR abs/1710.09437 (2017). arXiv:1710.09437 http://arxiv.org/abs/1710.09437
[9] Vitalik Buterin, Diego Hernandez, Thor Kamphefner, Khiem Pham, Zhi Qiao,
Danny Ryan, Juhyeok Sin, Ying Wang, and Yan X. Zhang. 2020. Combin-
ing GHOST and Casper.
arXiv:2003.03052
https://arxiv.org/abs/2003.03052

CoRR abs/2003.03052 (2020).

[10] C. Cachin and S. Tessaro. 2005. Asynchronous verifiable information dispersal.
In 24th IEEE Symposium on Reliable Distributed Systems (SRDSâ€™05). 191â€“201.
https://doi.org/10.1109/RELDIS.2005.9

[11] Tong Cao, Jiangshan Yu, JÃ©rÃ©mie Decouchant, and Paulo Esteves-Verissimo.
(2018).

2018. Revisiting Network-Level Attacks on Blockchain Network.
https://orbilu.uni.lu/bitstream/10993/38142/1/bcrb18-cao.pdf

[12] Miguel Castro, Peter Druschel, Ayalvadi Ganesh, Antony Rowstron,
Secure Routing for Structured Peer-to-Peer
SIGOPS Oper. Syst. Rev. 36, SI (Dec. 2003), 299â€“314.

and Dan S. Wallach. 2003.
Overlay Networks.
https://doi.org/10.1145/844128.844156

[13] Sandro Coretti, Aggelos Kiayias, Cristopher Moore, and Alexander Russell. 2022.
The Generalsâ€™ Scuttlebutt: Byzantine-Resilient Gossip Protocols. Cryptology
ePrint Archive, Report 2022/541. https://ia.cr/2022/541.

[14] Duncan Coutts, Neil David, Marcin Szamotulski, and Peter Thompson. 2020.
Introduction to the design of the Data Diffusion and Networking for Cardano Shelley.

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

Technical Report. IOHK. Version 1.9.

[15] Duncan Coutts, Alex Vieth, Neil Davies, Marcin Szamotulski, Karl Knutsson, Marc
Fontaine, and Armando Santos. 2021. The Shelley Networking Protocol. Technical
Report. IOHK. Version 1.2.0, Revision 49.

[16] Phil Daian, Rafael Pass, and Elaine Shi. 2019. Snow White: Robustly Reconfigurable
Consensus and Applications to Provably Secure Proof of Stake. In Financial
Cryptography and Data Security (FC â€™19). Springer, 23â€“41.

[17] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. 2018.
Ouroboros Praos: An Adaptively-Secure, Semi-synchronous Proof-of-Stake
Blockchain. In EUROCRYPT 2018. Springer, 66â€“98.

[18] Edsko de Vries, Thomas Winant, and Duncan Coutts. 2020. The Cardano
Consensus and Storage Layer. https://github.com/input-output-hk/ouroboros-
network/tree/master/ouroboros-consensus/docs/report

[42] Kamilla Nazirkhanova, Joachim Neu, and David Tse. 2021. Information Dispersal

with Provable Retrievability for Rollups. CoRR abs/2111.12323 (2021).

[43] Joachim Neu, Ertem Nusret Tas, and David Tse. 2021.

The Availability-
Accountability Dilemma and its Resolution via Accountability Gadgets. CoRR
abs/2105.06075 (2021). arXiv:2105.06075 https://arxiv.org/abs/2105.06075
[44] R Pass, L Seeman, and A Shelat. 2017. Analysis of the blockchain protocol in
asynchronous networks. In Annual International Conference on the Theory and
Applications of Cryptographic Techniques.

[45] Rafael Pass and Elaine Shi. 2017. The Sleepy Model of Consensus. In ASIACRYPT

2017. Springer, 380â€“409.

[46] Brian Quarmby. 2022. Solana hit with another network incident causing degraded
performance. Retrieved 2021-05-04 from https://cointelegraph.com/news/solana-
hit-with-another-network-incident-causing-degraded-performance

[19] Christian Decker and Roger Wattenhofer. 2013. Information propagation in the

[47] Ling Ren. 2019. Analysis of Nakamoto Consensus. IACR Cryptol. ePrint Arch.

Bitcoin network. In P2P. IEEE, 1â€“10.

(2019), 943.

[20] Amir Dembo, Sreeram Kannan, Ertem Nusret Tas, David Tse, Pramod Viswanath,
Xuechao Wang, and Ofer Zeitouni. 2020. Everything is a Race and Nakamoto
Always Wins. In Conference on Computer and Communications Security (CCS â€™20).
ACM, 859â€“878.

[21] Cynthia Dwork and Moni Naor. 1992. Pricing via Processing or Combatting Junk
Mail. In CRYPTO (Lecture Notes in Computer Science, Vol. 740). Springer, 139â€“147.
[22] Ittay Eyal and Emin GÃ¼n Sirer. 2018. Majority is not enough: Bitcoin mining is

vulnerable. Commun. ACM 61, 7 (2018), 95â€“102.

[23] Matthias Fitzi, Peter GaÅ¾i, Aggelos Kiayias, and Alexander Russell. 2018. Parallel
Chains: Improving Throughput and Latency of Blockchain Protocols via Parallel
Composition. Cryptology ePrint Archive, Report 1119.

[24] Matthias Fitzi, Peter GaÅ¾i, Aggelos Kiayias, and Alexander Russell. 2020.
Proof-of-Stake Blockchain Protocols with Near-Optimal Throughput. Cryptology
ePrint Archive, Report 2020/037. https://eprint.iacr.org/2020/037.

[25] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. 2015. The Bitcoin backbone
protocol: Analysis and applications. In EUROCRYPT 2015. Springer, 281â€“310.

[26] Peter Gazi, Aggelos Kiayias, and Dionysis Zindros. 2019.

Proof-of-Stake

Sidechains. In IEEE Symposium on Security and Privacy. IEEE, 139â€“156.

[27] Peter GaÅ¾i, Aggelos Kiayias, and Alexander Russell. 2020. Tight Consistency

Bounds for Bitcoin. (2020). https://eprint.iacr.org/2020/661.

[28] Ethan Heilman, Alison Kendler, Aviv Zohar, and Sharon Goldberg. 2015.
Eclipse Attacks on Bitcoinâ€™s Peer-to-Peer Network. In 24th USENIX Security
Symposium (USENIX Security 15). USENIX Association, Washington, D.C.,
129â€“144.
https://www.usenix.org/conference/usenixsecurity15/technical-
sessions/presentation/heilman

[29] James Hendricks, Gregory R. Ganger, and Michael K. Reiter. 2007. Verifying

distributed erasure-coded data. In PODC. ACM, 139â€“146.

[30] IOHK. 2020. input-output-hk/ouroboros-network. https://github.com/input-output-
hk/ouroboros-network/blob/master/ouroboros-network/src/Ouroboros/
Network

[31] IOHK. 2020. input-output-hk/ouroboros-network. https://github.com/input-output-
hk/ouroboros-network/blob/master/ouroboros-network/src/Ouroboros/
Network/BlockFetch/Decision.hs#L162

[32] IOHK. 2021.

input-output-hk/ouroboros-network.

https://github.com/input-

output-hk/ouroboros-network/blob/master/ouroboros-consensus-
shelley/src/Ouroboros/Consensus/Shelley/Protocol.hs#L281

[33] Markus Jakobsson and Ari Juels. 1999. Proofs of Work and Bread Pudding Pro-
tocols. In Communications and Multimedia Security (IFIP Conference Proceedings,
Vol. 152). Kluwer, 258â€“272.

[34] Kostis Karantias, Aggelos Kiayias, and Dionysis Zindros. 2020. Proof-of-Burn. In
Financial Cryptography (Lecture Notes in Computer Science, Vol. 12059). Springer,
523â€“540.

[35] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017.
Ouroboros: A provably secure proof-of-stake blockchain protocol. In CRYPTO
2017. Springer, 357â€“388.

[36] Aggelos Kiayias and Dionysis Zindros. 2019. Proof-of-Work Sidechains. In
Financial Cryptography Workshops (Lecture Notes in Computer Science, Vol. 11599).
Springer, 21â€“34.

[37] Bob Lantz, Brandon Heller, and Nick McKeown. 2010. A network in a laptop:

rapid prototyping for software-defined networks. In HotNets. ACM, 19.

[38] Chenxing Li, Peilun Li, Wei Xu, Fan Long, and Andrew Chi-chih Yao. 2018. Scaling
Nakamoto Consensus to Thousands of Transactions per Second. arXiv preprint
arXiv:1805.03870 (2018).
[39] Michael McSweeney. 2021.

Solana experiences transaction stoppage as
Retrieved 2021-11-21 from

developers report â€˜intermittent instabilityâ€™.
https://www.theblockcrypto.com/linked/117624/solana-experiences-
transaction-stoppage-as-developers-report-intermittent-instability

[40] Mike Millard. 2022. Solana restarted after seven-hour outage caused by surge
of transactions. Retrieved 2022-05-04 from https://www.theblockcrypto.com/
linked/144639/solana-restarted-after-seven-hour-outage-caused-by-surge-of-
transactions

[41] Satoshi Nakamoto. 2008. Bitcoin: A Peer-to-Peer Electronic Cash System.

https://bitcoin.org/bitcoin.pdf.

14

[48] Peiyao Sheng, Gerui Wang, Kartik Nayak, Sreeram Kannan, and Pramod

Viswanath. 2021. BFT Protocol Forensics. In CCS. ACM, 1722â€“1743.

[49] Atul Singh, Miguel Castro, Peter Druschel, and Antony Rowstron. 2004.
Defending against Eclipse Attacks on Overlay Networks. In Proceedings of
the 11th Workshop on ACM SIGOPS European Workshop (Leuven, Belgium)
(EW 11). Association for Computing Machinery, New York, NY, USA, 21â€“es.
https://doi.org/10.1145/1133572.1133613

[50] Atul Singh, Tsuen-Wan Ngan, Peter Druschel, and Dan S. Wallach. 2006. Eclipse
Attacks on Overlay Networks: Threats and Defenses. In INFOCOM. IEEE.
[51] Emil Sit and Robert Morris. 2002. Security Considerations for Peer-to-Peer Dis-
tributed Hash Tables. In Peer-to-Peer Systems, Peter Druschel, Frans Kaashoek, and
Antony Rowstron (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 261â€“269.
Secure high-rate transaction
processing in bitcoin. In International Conference on Financial Cryptography and
Data Security. Springer, 507â€“527.

[52] Yonatan Sompolinsky and Aviv Zohar. 2015.

[53] Anatoly Yakovenko. 2018. Solana: A new architecture for a high performance
Retrieved 2021-11-21 from https://solana.com/solana-

blockchain v0.8.13.
whitepaper.pdf

[54] Lei Yang, Seo Jin Park, Mohammad Alizadeh, Sreeram Kannan, and David Tse.
2022. DispersedLedger: High-Throughput Byzantine Consensus on Variable
Bandwidth Networks. In 19th USENIX Symposium on Networked Systems Design
and Implementation (NSDI 22). USENIX Association, Renton, WA, 493â€“512.
https://www.usenix.org/conference/nsdi22/presentation/yang

A REFERENCE ALGORITHMS
A.1 Helper Functions for Algorithms 1, 3, 4
â€¢ Hash(txs):

Cryptographic hash function to produce a binding commitment
to txs (modelled as a random oracle)

â€¢ Câ€² âª¯ C:

Relation describing that Câ€² is a prefix of C

â€¢ Câˆ¥Câ€²:

Concatenation of C and Câ€²

â€¢ prefixChainsOf (C):
Set of prefixes of C
â€¢ longestChain(T ):

Determine longest chain among set T of chains. Ties are broken
by the adversary.

â€¢ C âŒˆğ‘‡conf :

Prefix of chain C consisting of all blocks with time slots up to
ğ‘‡conf less than the current time slot

â€¢ txsAreSemanticallyValidWrtPrefixesOf (C, txs):

Verifies for each transaction in txs that the transaction is semanti-
cally valid with respect to and properly authorized by the owner
of the underlying assets as determined by the transactionâ€™s prefix
in the ledger resulting from appending txs to the transactions as
ordered in C (assumes that content of all blocks in C is known
to the node)

â€¢ newBlock(time : ğ‘¡, node : ğ‘ƒ, txsHash : Hash(txs)):

Produces a new block header with the given parameters

â€¢ oneLeafPerProductionOpportunity(hT ):

Longest Chain Consensus Under Bandwidth Constraint

Filter header tree hT to keep at most one leaf per block produc-
tion opportunity, i.e., per (node, time) pair (equivocation avoid-
ance; ties broken adversarially)

A.2 Environment Z
The environment Z initializes ğ‘ nodes and lets A corrupt up
to ğ›½ğ‘ nodes at the beginning of the execution. Corrupted nodes
are controlled by the adversary. Honest nodes run Î ğœŒ,ğœ,ğ‘‡conf . The
environment maintains a mapping blkTxs from block headers to
the block content (transactions). This mapping is referred to as
the â€˜idealized repositoryâ€™ in Section 2. Z also maintains for each
node a queue of pending block headers to be delivered after a delay
determined by the adversary (at most Î”h). Honest nodes and the
adversary interact with Z via the following functions:

â€¢ Z.broadcastHeaderChain(C):

If called by an honest node, Z sends header chain C to A. Then,
for each honest node ğ‘ƒ, on receiving deliver(C, ğ‘ƒ) from A, or
when Î”h time has passed since C was handed to Z for broad-
casting, Z triggers ğ‘ƒ .receivedHeaderChain(C).

â€¢ Z.uploadContent(C, txs):

Z stores a mapping from the header chain C to the content txs
of its last block by setting blkTxs[C] = txs. Z only stores the
content txs if Hash(txs) = C.txsHash.

â€¢ Z.reqestContent(C):

If blkTxs[C] is set, then let txs = blkTxs[C] (if not, Z ignores
the request). On receiving this call from an honest node ğ‘ƒ in a
time slot ğ‘¡, if Z has triggered ğ‘ƒ .receivedContent(.) less than
ğ¾ times in slot ğ‘¡, then Z triggers ğ‘ƒ .receivedContent(C, txs).
On receiving this call from A, Z sends (C, txs) to A.
â€¢ Z.receivePendingTxsSemanticallyValidWrt(C):

Z generates a set of pending transactions that are not included
in the block contents of but semantically valid (see Appendix A.1)
with respect to C, and returns them.

â€¢ Z.outputLedger(C):

On receiving this call from a node ğ‘ƒ, Z records C as ğ‘ƒâ€™s ledger
to be externalized. This constitutes LOGğ‘¡
ğ‘– , for which consistency
and liveness are required for a secure consensus protocol.

B SUPPLEMENTAL

EXPERIMENTAL MATERIAL

B.1 Experimental Setup Details for Figure 1
For this experiment, we start 17 Cardano nodes in 17 AWS data
centers across the globe and connect them into a fully-connected
graph. We point out that the Cardano block fetch logic includes an
optimization to only download blocks that have larger heights than
the locally-adopted longest chain. As a result, a node may not even-
tually download every block whose header it sees. To demonstrate
network congestion in the absence of a suitable download rule,
we modify the code to disable this optimization and ensure that
every node eventually downloads all blocks. To show congestion,
we configure a variable number (ğ‘ ) of nodes to all mine blocks at
the beginning of the same slot, and report the time for all 17 nodes
to download all ğ‘ blocks.

n

i
a
h
c
t
s
e
n
o
H

]
1
âˆ’
s
[
e
t
a
r
h
t
w
o
r
g

0.04

0.02

0

2

4

6

8

10
Block size [KB]

12

14

16

Figure 11: Honest chain growth rate under spamming attack
when using different block sizes and the download freshest
block rule. Despite the increasing network load (through the
increasing block size), there is no performance deterioration
when downloading the freshest block.

B.2 Chain Growth with Larger Blocks
In this experiment, we look at the robustness of the â€˜download
towards the freshest blockâ€™ rule when we increase the block size.
The topology is the same as previous experiments, but the in-flight
cap is fixed to 1. Figure 11 shows that this rule maintains the chain
growth rate, despite the increasing network load.

ğœŒ,ğ‘š
parallel

C PARALLEL CHAINS PSEUDOCODE
Algorithm 5 gives pseudocode for the parallel chains construction
using our PoS LC protocol parameterized with a download rule.
Note the following main differences with respect to Algorithm 1.
Upon initialization, each node is assigned a primary protocol in-
stance index by the functionality F
. Each node maintains a
separate header tree and downloaded chain for each index. While
scheduling content downloads, primary instance blocks get the
highest priority, with the same download rule that parameterizes
Î ğœŒ,ğœ,ğ‘‡conf . If there are no blocks left to be downloaded in the pri-
mary instance, the node picks among the confirmed longest chains
of all secondary instances, the block with the oldest time slot with
unknown content. Downloading the block with the oldest time slot
allows the node to construct the ledger quickly, although this pri-
ority rule does not play a critical role in the consensus security. In
line 25, the ledger is constructed by ordering the confirmed blocks
of all the instances first by their time slots and then by the index
ğœŒ,ğ‘š
of the protocol instance they appear in. The functionality F
parallel
(Algorithm 6) assigns the primary chain index for each node by
uniformly and randomly partitioning the set of nodes across the ğ‘š
chains. This can be approximated in instantiations by each node se-
lecting as its primary chain index a hash of its public key modulo ğ‘š.
Rather than by the transaction hash, another way to shard trans-
actions is by distributing all accounts uniformly among the protocol
instances, and requiring transactions in a particular instance to
have both the source and destination accounts in the same instance.
Transactions with the source and destination accounts in different
instances would be split into two transactions, one which burns the
funds in the source account and subsequently another one which
recreates funds in the destination account (while showing a receipt
of burn in the source chain), each transaction in its respective proto-
col instance (see [26, 34, 36] and references therein for background
on this technique). Such a solution allows validation of each trans-
action with respect to its prefix within the same instance at the time

15

Algorithm 5 Parallel Chains PoS LC consensus protocol
Î ğœŒ,ğœ,ğ‘‡conf,ğ‘š
: Algo-
(helper functions: Appendix C.1, F
rithm 6, Î ğœŒ,ğœ,ğ‘‡conf : Algorithm 1)

ğœŒ,ğ‘š
parallel

pc

Î idx â† new Î ğœŒ,ğœ,ğ‘‡conf
Î idx.init(genesisHeaderChain, genesisTxs)

âŠ² Initialize ğ‘š instances of Î ğœŒ,ğœ,ğ‘‡conf

1: on init(genesisHeaderChain, genesisTxs)
.primaryChainIndex()
2:

ğœŒ,ğ‘š
pri â† F
parallel
for idx = 1, ..., ğ‘š

3:
4:
5:
6: on receivedHeaderChain(idx, C)
Î idx.receivedHeaderChain( C)
7:
8: on receivedContent(idx, C, txs)
Î idx.receivedContent( C, txs)
9:
10: on scheduleContentDownload()
11:
12:
13:

âŠ² Called when download idle
Î pri.scheduleContentDownload() âŠ² First priority for primary
if no content requested by Î pri

âŠ² Download first missing block along the confirmed portion of the

longest header chains in the secondary instances.

14:

S â† {longestChain(Î idx.hT) âŒˆğ‘‡conf

{1, ..., ğ‘š } \ {pri} }

|

idx

âˆˆ

C â† arg minCâ€²â€²âª¯Câ€²âˆˆS : blkTxs[Câ€²â€² ]=unknown Câ€²â€².time
Z.reqestContent( C)

15:
16:
17: for time slots ğ‘¡ â† 1, ...,ğ‘‡h of duration ğœ
18:
19:
20:
21:

âŠ² Only include valid txs whose accounts belong to the primary chain
txs â† Z.receivePendingTxsSemanticallyValidWrt(Î pri.dC)
âŠ² Check eligibility to produce a new block, and if so do so, see Algorithm 6
if Câ€² â‰  âŠ¥ with Câ€² â† F

.extend(pri, ğ‘¡, Î pri.dC, txs)

ğœŒ,ğ‘š
parallel

Z.uploadContent(pri, Câ€², txs)
Z.broadcastHeaderChain(pri, Câ€²)
while end of current time slot ğ‘¡ not reached

scheduleContentDownload()

âŠ² Find the maximum time slot of all downloaded and confirmed chains
tmax â† max{ğ‘¡ | Î idx.dC âŒˆğ‘‡conf .time â‰¥ ğ‘¡, idx âˆˆ {1, ..., ğ‘š } }
âŠ² Arrange confirmed and downloaded chains in increasing order of

time slots, then chain index

LOG â† sortBySlotThenIndex( { C | C âª¯ Î idx.dC âŒˆğ‘‡conf ,

C.time â‰¤ tmax, idx âˆˆ {1, ..., ğ‘š } })
Z.outputLedger(LOG)

22:
23:

24:
25:

26:
27:
28:

29:

30:

of block production (Algorithm 5 line 19), a property sometimes
referred to as predictable validity. An important consequence of this
is that there is no â€œledger sanitizationâ€ procedure required while
constructing the ledger out of the confirmed blocks. In other words,
transactions once added to the chain cannot be invalidated in the
ledger because they were validated with respect to their past state
while proposing and forwarding the block. Thus, every transaction
contributes to throughput.

C.1 Additional Helper Functions

for Algorithm 5 (see also Appendix A.1)

â€¢ sortBySlotThenIndex(S):

Arranges the chains in the set S in increasing order of time slots
of their tip. Chains with the same time slot from different pro-
tocol instances are arranged in increasing order of the index of
their protocol instance.

â€¢ longestChain(T ):

Computes the longest chain in the tree T , i.e. computes arg maxC âˆˆT |C|.

â€¢ Z.receivePendingTxsSemanticallyValidWrt(C):

16

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

Algorithm 6 Idealized functionality F
(see also F

: Algorithm 3)

ğœŒ
headertree

ğœŒ,ğ‘š
parallel

for parallel chains

1: on init(genesisHeaderChain, numParties)
2:
3:
4:
5:

P1, ..., Pğ‘š â† random equi-partition of {1, ..., numParties}
for idx = 1, ..., ğ‘š
for ğ‘ƒ âˆˆ Pidx

pri[ğ‘ƒ ] â† idx
ğœŒ
headertree

âŠ² Initializeğ‘š instances of F

return pri[ğ‘ƒ ]

Fidx â† new F
Fidx.init(genesisHeaderChain, numParties/ğ‘š)

6:
7:
8: on primaryChainIndex() from party ğ‘ƒ
9:
10: on extend(idx, ğ‘¡ â€², C, txs) from party ğ‘ƒ at time slot ğ‘¡
11:
12:
13:

if pri[ğ‘ƒ ] â‰  idx
return âŠ¥

return Fidx.extend(ğ‘¡ â€², C, txs)

ğœŒ
headertree

Same as in the case of a single chain, but only includes transac-
tions for which the source account is defined in the same chain C.

D PROOF DETAILS
D.1 Proof of Theorem 1
Definition 5. A pivot is a slot ğ‘¡ such that

âˆ€(ğ‘Ÿ, ğ‘ ] âˆ‹ ğ‘¡ :

(U (ğ‘Ÿ, ğ‘ ] > A (ğ‘Ÿ, ğ‘ ]) âˆ¨ (A (ğ‘Ÿ, ğ‘ ] = 0) .

(18)

The predicate Pivot(ğ‘¡) is true iff ğ‘¡ is a pivot. A slot ğ‘¡ is a unique
pivot slot iff Pivot(ğ‘¡) âˆ§ Unique(ğ‘¡).
Definition 6. For an execution EğœŒ,ğ›½,ğ‘‡h , FreqPivotsğ›¾ (EğœŒ,ğ›½,ğ‘‡h ) holds
iff

âˆ€ğ‘¡ â‰¤ ğ‘‡h âˆ’ ğ›¾ : âˆƒğ‘¡ â€² âˆˆ (ğ‘¡, ğ‘¡ + ğ›¾] : Pivot(ğ‘¡ â€²) âˆ§ Unique(ğ‘¡ â€²).
Lemma 9. For all ğ¾, ğ›¾ âˆˆ N, ğœŒ âˆˆ R+, executions EğœŒ,ğ›½,ğ‘‡h and download
rules D such that

(19)

FreqPivotsğ›¾ (EğœŒ,ğ›½,ğ‘‡h ) âˆ§ MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, D)

(20)

holds, if ğœ = Î”h + ğ¾
ğ¶ and ğ‘‡conf = ğ›¾, then the protocol Î ğœŒ,ğœ,ğ‘‡conf
with download rule D satisfies safety and liveness with ğ‘‡live = 2ğ›¾ in
EğœŒ,ğ›½,ğ‘‡h .

Lemma 10.
Î© ( (ğœ…+lnğ‘‡h) 2)
ğ›¼1ğ‘

If ğ‘U = 1
2
, then

ğ‘ (1 + ğœ–1) for some ğœ–1 âˆˆ (0, 1) and ğ›¾ =

(cid:104)

Pr

EğœŒ,ğ›½,ğ‘‡h : Â¬FreqPivotsğ›¾ (EğœŒ,ğ›½,ğ‘‡h )

(cid:105)

â‰¤ negl(ğœ…)

(21)

where ğ›¼1 is a constant that depends on ğœ–1 and ğœŒ.

Lemma 9 is proved in Appendix D.2 and Lemma 10 in Appen-

dix D.3.

Proof of Theorem 1. Using Lemma 9, safety and liveness hold

except with probability

(cid:104)

Pr

EğœŒ,ğ›½,ğ‘‡h : Â¬FreqPivotsğ›¾ (EğœŒ,ğ›½,ğ‘‡h ) âˆ¨ Â¬MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, D)

(cid:105)

. (22)

This probability is negligible as per a union bound with Lemma 10
and the assumption about the download rule.

â–¡

Longest Chain Consensus Under Bandwidth Constraint

Time

ğ‘Ÿ

ğ‘¡ âˆ—

ğ‘âˆ—

â„â€²
1

ğ‘ 

Câ€²

Figure 12: An illustration of one example of the blocks and
time slots defined in the proof of Lemma 11. The block ğ‘âˆ— is
proposed in the unique pivot slot ğ‘¡ âˆ—. At the end of slot ğ‘  â‰¥ ğ‘¡ âˆ—,
the chain Câ€² âˆŒ ğ‘âˆ— is the longest chain in some nodeâ€™s view. The
last block from a uniquely successful slot in Câ€² is â„â€²
proposed
1
in the slot ğ‘Ÿ < ğ‘¡ âˆ—. Red (
) blocks are proposed
) and gray (
by adversarial and honest nodes, respectively. A red dashed
link (
) indicates that the block is withheld and released
later. Note that in this example, A (ğ‘Ÿ, ğ‘ ] = 4 > 3 = U (ğ‘Ÿ, ğ‘ ],
which is in contradiction to Pivot(ğ‘¡ âˆ—).

D.2 Proof of Lemma 9
Lemma 11. Suppose that for a download rule D and execution
EğœŒ,ğ›½,ğ‘‡h , MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, D) holds. Let ğ‘¡ âˆ— be a time slot such that
Pivot(ğ‘¡ âˆ—) âˆ§ Unique(ğ‘¡ âˆ—). Let ğ‘âˆ— be the block proposed in slot ğ‘¡ âˆ—. Then
ğ‘âˆ— âˆˆ dCğ‘– (ğ‘¡) for all ğ‘– and all ğ‘¡ â‰¥ ğ‘¡ âˆ—.

Proof. For contradiction, suppose that ğ‘  â‰¥ ğ‘¡ âˆ— is the first slot
such that ğ‘âˆ— âˆ‰ dCğ‘– (ğ‘ ) for some ğ‘–. Let Câ€² = dCğ‘– (ğ‘ ) such that ğ‘âˆ— âˆ‰ Câ€².
Let â„â€² be the last block corresponding to a uniquely successful slot
on Câ€². Let â„â€² be proposed in the slot ğ‘Ÿ . Clearly, ğ‘Ÿ â‰¤ ğ‘ .

The block â„â€² extends dCğ‘–â€² (ğ‘Ÿ âˆ’ 1) for some ğ‘– â€² since honest nodes
propose blocks on their longest downloaded chain. Since â„â€² âˆˆ Câ€²
and ğ‘âˆ— âˆ‰ Câ€², this means that ğ‘âˆ— âˆ‰ dCğ‘–â€² (ğ‘Ÿ âˆ’ 1). If ğ‘Ÿ > ğ‘¡ âˆ—, this is a
contradiction because we assumed that ğ‘  is the first slot such that
ğ‘  â‰¥ ğ‘¡ âˆ— and ğ‘âˆ— âˆ‰ dCğ‘– (ğ‘ ) for some ğ‘–. Since Unique(ğ‘¡ âˆ—), ğ‘Ÿ â‰  ğ‘¡ âˆ—. So, we
conclude that ğ‘Ÿ < ğ‘¡ âˆ—. All blocks in Câ€² extending â„â€² are from success-
ful slots that are not uniquely successful, i.e., they are adversarial
slots. So,

Proof of Lemma 9. Let ğ‘‡conf = ğ›¾. First, we prove safety by con-
tradiction. Suppose that for some honest nodes ğ‘–, ğ‘— and ğ‘¡ â€² â‰¥ ğ‘¡
that dCğ‘– (ğ‘¡) âŒˆğ‘‡conf âª¯Ì¸ dCğ‘— (ğ‘¡ â€²) âŒˆğ‘‡conf . We can assume that ğ‘¡ â‰¥ ğ›¾ be-
cause otherwise dCğ‘– (ğ‘¡) âŒˆğ‘‡conf = âˆ… and therefore dCğ‘– (ğ‘¡) âŒˆğ‘‡conf âª¯
dCğ‘— (ğ‘¡ â€²) âŒˆğ‘‡conf for all ğ‘¡ â€².

Consider all the uniquely successful slots ğ‘¡1, ..., ğ‘¡ğ‘š âˆˆ (ğ‘¡ âˆ’ ğ›¾, ğ‘¡]
with block ğ‘ ğ‘— proposed in slot ğ‘¡ ğ‘— . Suppose that ğ‘ ğ‘— âˆˆ dCğ‘– (ğ‘¡) and
ğ‘ ğ‘— âˆˆ dCğ‘— (ğ‘¡ â€²). Then dCğ‘– (ğ‘¡) and dCğ‘— (ğ‘¡ â€²) match up to ğ‘ ğ‘— . Since ğ‘¡ ğ‘— >
ğ‘¡ âˆ’ğ›¾, dCğ‘– (ğ‘¡) âŒˆğ‘‡conf âª¯ dCğ‘— (ğ‘¡ â€²). Also, ğ‘¡ â€² â‰¥ ğ‘¡, therefore dCğ‘– (ğ‘¡) âŒˆğ‘‡conf âª¯
dCğ‘— (ğ‘¡ â€²) âŒˆğ‘‡conf which is a contradiction to our assumption. There-
fore, for each ğ‘— = 1, ..., ğ‘š, either ğ‘ ğ‘— âˆ‰ dCğ‘– (ğ‘¡) or ğ‘ ğ‘— âˆ‰ dCğ‘— (ğ‘¡ â€²).
This means that for all ğ‘— = 1, ..., ğ‘š, ğ‘ ğ‘— is not a great block. Due to
ShortPrefixesğ¾ and Lemma 11, this also means that there are no
unique pivot slots in the interval (ğ‘¡ âˆ’ ğ›¾, ğ‘¡], which is a contradiction
to FreqPivotsğ›¾ .

We next prove liveness. Assume a transaction tx is received by
all honest nodes before time ğ‘¡. We know that there exists a unique
pivot slot ğ‘¡ âˆ— in the interval (ğ‘¡, ğ‘¡ + ğ›¾]. The honest block ğ‘âˆ— from ğ‘¡ âˆ—
or its prefix must contain tx since tx is seen by all honest nodes
at time ğ‘¡ < ğ‘¡ âˆ—. Moreover, ğ‘âˆ— is also a great block, i.e., ğ‘âˆ— âˆˆ dCğ‘– (ğ‘¡ â€²)
for all honest nodes ğ‘– and ğ‘¡ â€² â‰¥ ğ‘¡ âˆ—. Therefore, tx âˆˆ LOGğ‘¡ â€²
for all
ğ‘–
ğ‘¡ â€² â‰¥ ğ‘¡ âˆ— + ğ‘‡conf , which is at most ğ‘¡ + 2ğ›¾.
â–¡

D.3 Proof of Lemma 10

D.3.1 Preliminaries.
Definition 7 (Pivot condition). The predicate PivotCondition(ğ‘Ÿ,ğ‘  ]
holds iff U (ğ‘Ÿ, ğ‘ ] > A (ğ‘Ÿ, ğ‘ ].

Note that Pivot(ğ‘¡) holds iff âˆ€(ğ‘Ÿ, ğ‘ ] âˆ‹ ğ‘¡, PivotCondition(ğ‘Ÿ,ğ‘  ] âˆ¨

(A (ğ‘Ÿ, ğ‘ ] = 0) holds.

Definition 8 (Weak Pivot). Time slot ğ‘¡ satisfies WeakPivotğ‘¤ (ğ‘¡) iff
(26)
âˆ€(ğ‘Ÿ, ğ‘ ] âˆ‹ ğ‘¡, ğ‘  âˆ’ ğ‘Ÿ < ğ‘¤ : PivotCondition(ğ‘Ÿ,ğ‘  ] âˆ¨ (A (ğ‘Ÿ, ğ‘ ] = 0) .
Proposition 1. If ğ‘U = 1
2
âˆ€(ğ‘Ÿ, ğ‘ ] : Pr (cid:2)Â¬PivotCondition(ğ‘Ÿ,ğ‘  ]
with ğ›¼ â€²

ğ‘ (1 + ğœ–1) for some ğœ–1 âˆˆ (0, 1),

(cid:3) â‰¤ 2 exp (cid:0)âˆ’ğ›¼ â€²
1

ğ‘ (ğ‘  âˆ’ ğ‘Ÿ )(cid:1) ,

and ğœ‚ = 1/36.

(27)

1 = ğœ‚ğœ–2
1

|Câ€²| â‰¤ |â„â€²| + A (ğ‘Ÿ, ğ‘ ]

(23)

Proof. By a simple Chernoff bound for ğœ– > 0,

From Lemma 1,

ğ¿min (ğ‘ ) â‰¥ ğ¿min (ğ‘Ÿ ) + U (ğ‘Ÿ, ğ‘ ] .
Note that ğ¿min (ğ‘ ) â‰¤ ğ¿ğ‘– (ğ‘ ) âˆ€ğ‘– and |Câ€²| = ğ¿ğ‘– (ğ‘ ) for some ğ‘–. Also note
that â„â€² is from a uniquely successful slot ğ‘Ÿ and MaxDLğ¾ holds, so
ğ¿min (ğ‘Ÿ ) â‰¥ |â„â€²|. Using the above observations with (23) and (24),
we get

(24)

Pr [B (ğ‘Ÿ, ğ‘ ] â‰¥ ğ‘ (ğ‘  âˆ’ ğ‘Ÿ )(1 + ğœ–)] â‰¤ exp

Also, by a Chernoff bound for ğœ– âˆˆ (0, 1),

(cid:18)

âˆ’

ğœ–2ğ‘ (ğ‘  âˆ’ ğ‘Ÿ )
2 + ğœ–

(cid:19)

.

(28)

Pr [U (ğ‘Ÿ, ğ‘ ] â‰¤ ğ‘U (ğ‘  âˆ’ ğ‘Ÿ )(1 âˆ’ ğœ–)] â‰¤ exp

By choosing ğœ– such that 1+ğœ–

(cid:18)

ğœ–2ğ‘U (ğ‘  âˆ’ ğ‘Ÿ )
2
1âˆ’ğœ– = 1 + ğœ–1, we obtain that

âˆ’

(cid:19)

(29)

U (ğ‘Ÿ, ğ‘ ] â‰¤ A (ğ‘Ÿ, ğ‘ ]

(25)

U (ğ‘Ÿ, ğ‘ ] > ğ‘U (ğ‘  âˆ’ ğ‘Ÿ )(1 âˆ’ ğœ–)

where ğ‘Ÿ < ğ‘¡ âˆ— and ğ‘  â‰¥ ğ‘¡ âˆ—. Since Pivot(ğ‘¡ âˆ—), this is a contradiction. â–¡

Lemma 11 shows that the block from every unique pivot slot
stays in all honest nodesâ€™ downloaded longest chains thereafter.
Therefore, under FreqPivotsğ›¾ , every interval of ğ›¾ slots brings at
least one such block. To conclude with the proof of Lemma 9, one
needs to show that the occurrence of such blocks leads to safety
and liveness. This is done in Lemma 9.

=

=

1
2
1
2

ğ‘ (1 + ğœ–1)(ğ‘  âˆ’ ğ‘Ÿ )(1 âˆ’ ğœ–)
ğ‘ (ğ‘  âˆ’ ğ‘Ÿ )(1 + ğœ–) > 1
2

B (ğ‘Ÿ, ğ‘ ]

=â‡’ U (ğ‘Ÿ, ğ‘ ] > A (ğ‘Ÿ, ğ‘ ] ,

except with probability

exp

(cid:18)

âˆ’

ğœ–2ğ‘ (ğ‘  âˆ’ ğ‘Ÿ )
2 + ğœ–

(cid:19)

+ exp

(cid:18)

âˆ’

ğœ–2ğ‘U (ğ‘  âˆ’ ğ‘Ÿ )
2

(cid:19)

(30)

17

From 1+ğœ–
1âˆ’ğœ– = 1 + ğœ–1, we get ğœ– =
this probability is bounded by

ğœ–1
ğœ–1+2 â‰¥

ğœ–1
3

. Further using ğ‘U > ğ‘

2

,

2 exp

(cid:32) ğœ–2
1

(cid:33)

ğ‘ (ğ‘  âˆ’ ğ‘Ÿ )
36

(31)

â–¡

Proposition 2.
ğ‘‡h and ğ‘¤ > 2 ln(
ğ›¼ â€²
1

If ğ‘U = 1
2
âˆš
2ğ‘‡h)
,
ğ‘

ğ‘ (1 + ğœ–1), then for an execution horizon

Pr (cid:2)âˆƒ(ğ‘Ÿ, ğ‘ ], ğ‘  âˆ’ ğ‘Ÿ â‰¥ ğ‘¤ : Â¬PivotCondition(ğ‘Ÿ,ğ‘  ]
h exp (cid:0)âˆ’ğ›¼ â€²

â‰¤ 2ğ‘‡ 2

ğ‘ğ‘¤ (cid:1) .

1

(cid:3)

(32)

Proof. Using a union bound and Proposition 1,

Pr (cid:2)âˆƒ(ğ‘Ÿ, ğ‘ ], ğ‘  âˆ’ ğ‘Ÿ â‰¥ ğ‘¤ : Â¬PivotCondition(ğ‘Ÿ,ğ‘  ]
Pr (cid:2)Â¬PivotCondition(ğ‘Ÿ,ğ‘  ]

âˆ‘ï¸

(cid:3)

â‰¤

(ğ‘Ÿ,ğ‘  ],ğ‘ âˆ’ğ‘Ÿ â‰¥ğ‘¤

â‰¤ 2ğ‘‡ 2

h exp(âˆ’ğ›¼ â€²

1

ğ‘ğ‘¤).

(cid:3)

â–¡

Proposition 3. If ğ‘U = 1
2
2ğ‘‡h)
ğ‘¤ > 2 ln(
ğ›¼ â€²
ğ‘
1

âˆš

,

ğ‘ (1 + ğœ–1), then for a time horizon ğ‘‡h and

Pr [âˆƒğ‘¡ : WeakPivotğ‘¤ (ğ‘¡) âˆ§ Â¬Pivot(ğ‘¡)]

â‰¤ 2ğ‘‡ 2

h exp(âˆ’ğ›¼ â€²

1

ğ‘ğ‘¤).

(33)

2ğ‘‡h)
Proof. If some ğ‘¡ is a weak pivot (with ğ‘¤ â‰¥ 2 ln(
ğ›¼ â€²
ğ‘
1
not a pivot, then âˆƒ(ğ‘Ÿ, ğ‘ ] âˆ‹ ğ‘¡ with ğ‘  âˆ’ ğ‘Ÿ â‰¥ ğ‘¤ such that
Â¬PivotCondition(ğ‘Ÿ,ğ‘  ] . But the probability for this is bounded ac-
â–¡
cordingly by Proposition 2.

) and ğ‘¡ is

âˆš

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

â‰¤

â‰¤

â‰¤

=

=

â‰¤

â‰¤

2ğ‘£
âˆ‘ï¸

(2(ğ‘¢ âˆ’ ğ‘£) âˆ’ 1)2ğ‘’âˆ’ğ›¼ â€²

1

ğ‘ğ‘¢ +

ğ‘¤âˆ’1
âˆ‘ï¸

ğ‘¢=2ğ‘£+1

ğ‘¢2ğ‘’âˆ’ğ›¼ â€²

1

ğ‘ğ‘¢

ğ‘¢=ğ‘£+1
ğ‘£
âˆ‘ï¸

2(2ğ‘— âˆ’ 1)ğ‘’âˆ’ğ›¼ â€²

1

ğ‘ (ğ‘£+ğ‘—) +

ğ‘˜=1
ğ‘£
âˆ‘ï¸

2(2ğ‘— âˆ’ 1)ğ‘’âˆ’ğ›¼ â€²

1

ğ‘ (ğ‘£+ğ‘—) +

ğ‘¤âˆ’1
âˆ‘ï¸

ğ‘¢=2ğ‘£+1
âˆ
âˆ‘ï¸

2ğ‘¢ğ‘’âˆ’ğ›¼ â€²

1

ğ‘ğ‘¢

2ğ‘¢ğ‘’âˆ’ğ›¼ â€²

1

ğ‘ğ‘¢

ğ‘˜=1
2ğ‘’âˆ’ğ›¼ â€²

1

ğ‘ (ğ‘£+1) (1 âˆ’ (2ğ‘£ + 1)ğ‘’âˆ’ğ›¼ â€²

ğ‘¢=2ğ‘£+1
ğ‘ğ‘£)

1

ğ‘ğ‘£)

1

+

+

1

1

4ğ‘’âˆ’ğ›¼ â€²

1 âˆ’ ğ‘’âˆ’ğ›¼ â€²
ğ‘
ğ‘ (ğ‘£+2) (1 âˆ’ ğ‘’âˆ’ğ›¼ â€²
(1 âˆ’ ğ‘’âˆ’ğ›¼ â€²
2(2ğ‘£ + 1)ğ‘’âˆ’ğ›¼ â€²
1 âˆ’ ğ‘’âˆ’ğ›¼ â€²
ğ‘ (ğ‘£+1)

ğ‘ )2
1
ğ‘ (2ğ‘£+1)

ğ‘
4ğ‘’âˆ’ğ›¼ â€²

1

1

1

1

ğ‘ +
(cid:32)

1
ğ‘ (ğ‘£+1)

2ğ‘’âˆ’ğ›¼ â€²
1 âˆ’ ğ‘’âˆ’ğ›¼ â€²
2ğ‘’âˆ’ğ›¼ â€²
1 âˆ’ ğ‘’âˆ’ğ›¼ â€²
2ğ‘’âˆ’ğ›¼ â€²

1

1

1 +

ğ‘

1

1

(1 âˆ’ ğ‘’âˆ’ğ›¼ â€²

ğ‘ğ‘£ (1 + ğ‘’âˆ’ğ›¼ â€²
ğ‘ )2
(cid:18)

1

ğ‘ (2ğ‘£+2)
ğ‘ )2
ğ‘ (2ğ‘£+2)

1

1

+

2ğ‘’âˆ’ğ›¼ â€²
(1 âˆ’ ğ‘’âˆ’ğ›¼ â€²
ğ‘ (ğ‘£+2) âˆ’ 2ğ‘’âˆ’ğ›¼ â€²
(1 âˆ’ ğ‘’âˆ’ğ›¼ â€²
ğ‘ )2
(cid:33)
ğ‘

1

1

1

2ğ‘’âˆ’ğ›¼ â€²
1 âˆ’ ğ‘’âˆ’ğ›¼ â€²
ğ‘ )

1

ğ‘

(37)

4(1+ğ‘’âˆ’ğ›¼â€²
We may choose ğ‘£ = 1
, so that Pr [Â¬ğ¸2] â‰¤ 1
(1âˆ’ğ‘’âˆ’ğ›¼â€²
ğ›¼ â€²
2
1
It is easy to see that Pr [ğ¸2 | ğ¸1 âˆ© {Unique(ğ‘¡)}] â‰¥ Pr [ğ¸2 | ğ¸1] â‰¥

ğ‘ )
1
ğ‘ ) 2

ğ‘ ln

.

1

(cid:19)

Pr [ğ¸2].
Pr [WeakPivotğ‘¤ (ğ‘¡) | Unique(ğ‘¡)] â‰¥ Pr [ğ¸1 âˆ© ğ¸2 | Unique(ğ‘¡)]

â‰¥ Pr [ğ¸1 | Unique(ğ‘¡)] Pr [ğ¸2]

â‰¥

1
2

(1 âˆ’ ğ‘A)2ğ‘£âˆ’1.

â–¡

ğ‘ (1 + ğœ–1), then for horizon ğ‘‡h and ğ‘¤ >

Proposition 4. If ğ‘U = 1
2

ğ‘ (1 + ğœ–1), then for time horizon ğ‘‡h,

for the given choice of ğ‘£.

âˆ€ğ‘¡ :

Pr [WeakPivotğ‘¤ (ğ‘¡) | Unique(ğ‘¡)] â‰¥ ğ‘1
(cid:18)

where ğ‘1 = 1

2 (1 âˆ’ ğ‘A)2ğ‘£âˆ’1 > 0 and ğ‘¤

2

> ğ‘£ = 1
ğ›¼ â€²
1

ğ‘ ln

(34)

4(1+ğ‘’âˆ’ğ›¼â€²
(1âˆ’ğ‘’âˆ’ğ›¼â€²

ğ‘ )
1
ğ‘ ) 2

1

(cid:19)

.

Proposition 5.
(cid:18)
4(1+ğ‘’âˆ’ğ›¼â€²
(1âˆ’ğ‘’âˆ’ğ›¼â€²

2
ğ‘ ln
ğ›¼ â€²
1

If ğ‘U = 1
2
ğ‘ )
1
,
ğ‘ ) 2

(cid:19)

1

Proof. For ğ‘£ < ğ‘¤/2 to be determined later, consider the events
(35)

ğ¸1 â‰œ {A (ğ‘¡ âˆ’ ğ‘£, ğ‘¡ + ğ‘£] = 0},
ğ¸2 â‰œ {âˆ€(ğ‘Ÿ, ğ‘ ] âˆ‹ ğ‘¡, ğ‘  âˆ’ ğ‘Ÿ < ğ‘¤, (ğ‘Ÿ, ğ‘ ] âˆ‰ (ğ‘¡ âˆ’ ğ‘£, ğ‘¡ + ğ‘£] :

PivotCondition(ğ‘Ÿ,ğ‘  ] }.

(36)

Note that, ğ¸1 âˆ© ğ¸2 âŠ† {WeakPivotğ‘¤ (ğ‘¡)} and Pr [ğ¸1 | Unique(ğ‘¡)] =
(1 âˆ’ ğ‘A)2ğ‘£âˆ’1.

For bounding Pr [Â¬ğ¸2], we will use a union bound by carefully
counting the number of intervals (ğ‘Ÿ, ğ‘ ] âˆ‹ ğ‘¡ such that ğ‘  âˆ’ ğ‘Ÿ < ğ‘¤
and (ğ‘Ÿ, ğ‘ ] âˆ‰ (ğ‘¡ âˆ’ ğ‘£, ğ‘¡ + ğ‘£]. Let ğ‘¢ = ğ‘  âˆ’ ğ‘Ÿ . For ğ‘¢ â‰¤ ğ‘£, note that
(ğ‘Ÿ, ğ‘ ] âˆ‹ ğ‘¡ implies that (ğ‘Ÿ, ğ‘ ] âˆˆ (ğ‘¡ âˆ’ ğ‘£, ğ‘¡ + ğ‘£]. One can check that for
ğ‘£ + 1 â‰¤ ğ‘¢ â‰¤ 2ğ‘£, there are 2(ğ‘¢ âˆ’ ğ‘£) âˆ’ 1 intervals (ğ‘Ÿ, ğ‘ ] âˆ‹ ğ‘¡ such that
(ğ‘Ÿ, ğ‘ ] âˆ‰ (ğ‘¡ âˆ’ ğ‘£, ğ‘¡ + ğ‘£]. For 2ğ‘£ + 1 â‰¤ ğ‘¢ < ğ‘¤, all intervals (ğ‘Ÿ, ğ‘ ] âˆ‹ ğ‘¡
are such that (ğ‘Ÿ, ğ‘ ] âˆ‰ (ğ‘¡ âˆ’ ğ‘£, ğ‘¡ + ğ‘£], and there are ğ‘¢ such intervals.
Therefore, from Proposition 1 and a union bound,

Pr [Â¬ğ¸2] â‰¤

ğ‘¤âˆ’1
âˆ‘ï¸

ğ‘¢=ğ‘£+1

âˆ‘ï¸

(ğ‘Ÿ,ğ‘  ] âˆ‹ğ‘¡ :
ğ‘ âˆ’ğ‘Ÿ =ğ‘¢âˆ§
(ğ‘Ÿ,ğ‘  ]âˆ‰(ğ‘¡ âˆ’ğ‘£,ğ‘¡ +ğ‘£ ]

Pr [Â¬PivotCondition(ğ‘Ÿ, ğ‘ ]]

âˆ€ğ‘¡ : Pr (cid:2)âˆƒğ‘¡ â€² âˆˆ (ğ‘¡, ğ‘¡ + ğ›¾] : WeakPivotğ‘¤ (ğ‘¡ â€²) âˆ§ Unique(ğ‘¡ â€²)(cid:3)

â‰¥ 1 âˆ’ exp(âˆ’ğ›¼ â€²â€²
1

ğ›¾/ğ‘¤),

with ğ›¼ â€²â€²

1 =

ğ‘1ğ‘U
2

.

(38)

Proof. Let ğ‘˜ be the largest integer such that ğ›¾ â‰¥ 2ğ‘¤ğ‘˜. For

ğ‘– = 0, ..., (ğ‘˜ âˆ’ 1), define ğ‘¡ğ‘– = ğ‘¡ + (2ğ‘– + 1)ğ‘¤ and

ğ¸ğ‘– â‰œ {WeakPivotğ‘¤ (ğ‘¡ğ‘– ) âˆ§ Unique(ğ‘¡ğ‘– )}
ğ¸ â‰œ {âˆƒğ‘¡ â€² âˆˆ (ğ‘¡, ğ‘¡ + ğ›¾] : WeakPivotğ‘¤ (ğ‘¡ â€²) âˆ§ Unique(ğ‘¡ â€²)}.

(39)

(40)

Thus, we have (cid:208)ğ‘˜âˆ’1
ğ‘–=0

pendent. Hence,

ğ¸ğ‘– âŠ† ğ¸, and by construction ğ¸ğ‘– are inde-

Pr [ğ¸] â‰¥ Pr

(cid:34)ğ‘˜âˆ’1
(cid:216)

(cid:35)

ğ¸ğ‘–

= 1 âˆ’ Pr

(cid:34)ğ‘˜âˆ’1
(cid:217)

(cid:35)

Â¬ğ¸ğ‘–

ğ‘–=0

ğ‘–=0
â‰¥ 1 âˆ’ (1 âˆ’ ğ‘1ğ‘U)ğ‘˜
â‰¥ 1 âˆ’ exp(âˆ’ğ‘1ğ‘Uğ‘˜)
= 1 âˆ’ exp(âˆ’ğ‘1ğ‘Uğ›¾/2ğ‘¤),

where we have used Proposition 4.

18

(41)

â–¡

Longest Chain Consensus Under Bandwidth Constraint

Proposition 6.
(cid:18)
4(1+ğ‘’âˆ’ğ›¼â€²
(1âˆ’ğ‘’âˆ’ğ›¼â€²

2
ğ‘ ln
ğ›¼ â€²
1

If ğ‘U = 1
2
ğ‘ )
and ğ›¾ > ğ‘¤ ln(ğ‘‡h)
1
ğ‘ ) 2

ğ›¼ â€²â€²
1

(cid:19)

1

,

ğ‘ (1 + ğœ–1), then for horizon ğ‘‡h, ğ‘¤ >

Pr (cid:2)âˆ€ğ‘¡ : âˆƒğ‘¡ â€² âˆˆ (ğ‘¡, ğ‘¡ + ğ›¾] : WeakPivotğ‘¤ (ğ‘¡ â€²) âˆ§ Unique(ğ‘¡ â€²)(cid:3)

â‰¥ 1 âˆ’ ğ‘‡h exp(âˆ’ğ›¼ â€²â€²
1

ğ›¾/ğ‘¤).

(42)

Proof. By a union bound over all ğ‘‡h possible time slots, and
â–¡

using Proposition 5.

D.3.2 Proof of Lemma 10.

Proof. Finally, to prove Lemma 10, let
ğ¸1 â‰œ {âˆ€ğ‘¡ : âˆƒğ‘¡ â€² âˆˆ (ğ‘¡, ğ‘¡ + ğ›¾] : WeakPivotğ‘¤ (ğ‘¡ â€²) âˆ§ Unique(ğ‘¡ â€²)}
ğ¸2 â‰œ {âˆ€ğ‘¡ : WeakPivotğ‘¤ (ğ‘¡) â‡’ Pivot(ğ‘¡)}
ğ¸ â‰œ {âˆ€ğ‘¡ : âˆƒğ‘¡ â€² âˆˆ (ğ‘¡, ğ‘¡ + ğ›¾] : Pivot(ğ‘¡ â€²) âˆ§ Unique(ğ‘¡ â€²)}.

Note that ğ¸1 âˆ© ğ¸2 âŠ† ğ¸. Then we apply a union bound on the
probabilities from Propositions 6 and 3.

1

1

ğ‘

âˆš

ğ‘’âˆ’ğ›¼ â€²

Pr [Â¬ğ¸] â‰¤ Pr [Â¬ğ¸1] + Pr [Â¬ğ¸2] â‰¤ 2ğ‘‡ 2
h

Let ğœ… â€² = ğœ… + lnğ‘‡h. Pick ğ‘¤ such that ğ‘¤ = 2 ln(

ğ‘ğ‘¤ + ğ‘‡hğ‘’âˆ’ğ›¼ â€²â€²
2ğ‘‡h)+Î© (ğœ…)
. This
ğ›¼ â€²
1
ğ‘ğ‘¤ corresponding to having
ensures that the probability 2ğ‘‡ 2
h
more adversarial than honest slots in some interval of size at least
ğ‘¤, is negl(ğœ…).

ğ›¾ /ğ‘¤ .(43)

ğ‘’âˆ’ğ›¼ â€²

Finally, we pick ğ›¾ so that the probability ğ‘‡hğ‘’âˆ’ğ›¼ â€²â€²

ğ›¾ /ğ‘¤ correspond-
ing to not finding a pivot slot in some interval of ğ›¾ slots, is negl(ğœ…).
Therefore we get ğ›¾ â‰¥ ln(ğ‘‡h)+Î© (ğœ…)
ğ‘¤. Combining these, we have
. Choose ğ›¼1 = ğ›¼ â€²
1

Î© ( (ln(ğ‘‡h)+ğœ…) 2)
ğ›¼ â€²â€²
ğ›¼ â€²
1
1

ğ›¼ â€²â€²
1

ğ›¾ â‰¥

ğ›¼ â€²â€²
1

â–¡

ğ‘

1

1

D.4 Proof of Lemma 3

Proof. Define the event ğ¹ğ‘¡ as

max
ğ‘Ÿ <ğ‘¡ : Unique(ğ‘Ÿ )âˆ§( A(ğ‘Ÿ,ğ‘¡ ] â‰¥U(ğ‘Ÿ,ğ‘¡ ])

A (ğ‘Ÿ, ğ‘¡] â‰¥ ğ¾ .

(44)

This event can be equivalently expressed as

âˆƒğ‘Ÿ < ğ‘¡ : Unique(ğ‘Ÿ ) âˆ§ (A (ğ‘Ÿ, ğ‘¡] â‰¥ U (ğ‘Ÿ, ğ‘¡]) âˆ§ (A (ğ‘Ÿ, ğ‘¡] â‰¥ ğ¾).
The event {Â¬ShortPrefixesğ¾ } can be expressed as (cid:208)ğ‘¡ â‰¤ğ‘‡h

(45)

ğ¹ğ‘¡ .

Then for some fixed ğ‘‡ ,

Pr [ğ¹ğ‘¡ ] â‰¤ Pr

(cid:34)ğ‘¡ âˆ’1
(cid:216)

ğ‘Ÿ =0

{A (ğ‘Ÿ, ğ‘¡] â‰¥ U (ğ‘Ÿ, ğ‘¡] âˆ§ A (ğ‘Ÿ, ğ‘¡] â‰¥ ğ¾ }

(cid:35)

Pr [A (ğ‘Ÿ, ğ‘¡] â‰¥ U (ğ‘Ÿ, ğ‘¡]] +

ğ‘¡ âˆ’1
âˆ‘ï¸

Pr [A (ğ‘Ÿ, ğ‘¡] â‰¥ ğ¾]

ğ‘¡ âˆ’ğ‘‡
âˆ‘ï¸

ğ‘Ÿ =0
âˆ
âˆ‘ï¸

â‰¤

â‰¤

2 exp (cid:0)âˆ’ğ›¼ â€²
1

ğ‘ğ‘˜(cid:1) + ğ‘‡ exp

=

ğ‘˜=ğ‘‡
2 exp(âˆ’ğ›¼ â€²
1
1 âˆ’ exp(âˆ’ğ›¼ â€²
1
â‰¤ 2ğ‘‡ exp (âˆ’ğ›¼2ğ‘ğ‘‡ ) ,

ğ‘ğ‘‡ )
ğ‘)

(cid:32)

âˆ’

+ ğ‘‡ exp

(cid:32)

âˆ’

ğ‘Ÿ =ğ‘¡ âˆ’ğ‘‡
ğœ–2
2
2 + ğœ–2
ğœ–2
2
2 + ğœ–2

ğ‘ğ´ğ‘‡

(cid:33)

ğ‘ğ´ğ‘‡

(cid:33)

2

1âˆ’exp(âˆ’ğ›¼ â€²
1

ğ‘A
for ğ‘‡ â‰¥
ğ‘
union bound over the execution horizon ğ‘‡h, we get
Pr [Â¬ShortPrefixesğ¾ ] â‰¤ 2ğ‘‡hğ‘‡ exp(âˆ’ğ›¼2ğ‘ğ‘‡ ) â‰¤ 2ğ‘‡ 2

and ğ›¼2 = min

, ğœ– 2
2
ğœ–2+2

ğ‘)

(cid:110)
ğ›¼ â€²
1

(46)
(cid:111). By using a

h exp(âˆ’ğ›¼2ğ‘ğ‘‡ ) (47)
19

We then set ğ‘‡ = 2 ln(

âˆš

2ğ‘‡h)+Î© (ğœ…)
ğ›¼2ğ‘

to make this probability negl(ğœ…).
â–¡

D.5 Proof of Lemma 4

Proof. Let ğ‘¡1, ..., ğ‘¡ğ‘š be the uniquely successful slots in (0,ğ‘‡h].

Let ğ‘ ğ‘— be the block from slot ğ‘¡ ğ‘— for some 1 â‰¤ ğ‘— â‰¤ ğ‘š.

For induction, assume that MaxDLğ¾,(0,ğ‘¡ ğ‘— âˆ’1] holds. Using this,
we will show that MaxDLğ¾,(0,ğ‘¡ ğ‘— +1âˆ’1] holds. For the base case, this
is true for ğ‘— = 1 since ğ‘¡1 is the first uniquely successful slot by
definition. Suppose that there is a chain Câ€² in the header tree of
an honest node in slot ğ‘¡ ğ‘— such that |Câ€²| â‰¥ |ğ‘ ğ‘— |. Note that the tip
of Câ€² can not be a unique block because unique blocks have in-
creasing heights as per Lemma 1. Therefore the tip of Câ€² is from an
adversarial slot. Consider such a chain Câ€² ending in a block from
an adversarial slot ğ‘  ğ‘— â‰¤ ğ‘¡ ğ‘— . Let ğ‘Ÿ ğ‘— be the last uniquely successful
slot such that the block ğ‘ â€²

ğ‘— from that slot is in Câ€². Then,

|Câ€²| â‰¤ |ğ‘ â€²

ğ‘— | + A (cid:0)ğ‘Ÿ ğ‘— , ğ‘  ğ‘— (cid:3) .

(48)

From the assumption of MaxDLğ¾,(0,ğ‘¡ ğ‘— âˆ’1] and part (1) of Lemma 1,
(49)

|ğ‘ ğ‘— | â‰¥ |ğ‘ â€²

ğ‘— | + U (cid:0)ğ‘Ÿ ğ‘— , ğ‘¡ ğ‘— (cid:3) .

Since |Câ€²| â‰¥ |ğ‘ ğ‘— |, this would mean that A (cid:0)ğ‘Ÿ ğ‘— , ğ‘  ğ‘— (cid:3) â‰¥ U (cid:0)ğ‘Ÿ ğ‘— , ğ‘  ğ‘— (cid:3). As
a block from a uniquely successful slot, ğ‘ â€²
ğ‘— was downloaded by all
honest nodes within slot ğ‘Ÿ ğ‘— . Therefore, there are at most A (cid:0)ğ‘Ÿ ğ‘— , ğ‘  ğ‘— (cid:3)
blocks on the chain Câ€² that are yet to be downloaded. Therefore
the number of blocks to be downloaded by each honest node on Câ€²
is at most

max
ğ‘Ÿ ğ‘— <ğ‘  ğ‘— : Unique(ğ‘Ÿ ğ‘— )âˆ§( A(ğ‘Ÿ ğ‘— ,ğ‘  ğ‘— ] â‰¥U(ğ‘Ÿ ğ‘— ,ğ‘¡ ğ‘— ])

A (cid:0)ğ‘Ÿ ğ‘— , ğ‘  ğ‘— (cid:3) = ğ‘Šğ‘  ğ‘— ,ğ‘¡ ğ‘— .

(50)

Next, we count the number of such chains Câ€² with distinct block
production opportunities at the tip. Due to the equivocation avoid-
ance policy, the adversary can make honest nodes download at
most one chain per adversarial block production opportunity in
slots ğ‘  ğ‘— â‰¤ ğ‘¡ ğ‘— . The total number of blocks to be downloaded in all
these chains combined is (cid:205)ğ‘  ğ‘— <ğ‘¡ ğ‘—

ğ´ğ‘  ğ‘—ğ‘Šğ‘  ğ‘— ,ğ‘¡ ğ‘— .

Finally, from the proof of Lemma 2, we note that the prefix of ğ‘ ğ‘—
has at most ğ‘Šğ‘¡ ğ‘— âˆ’1,ğ‘¡ ğ‘— âˆ’1 blocks that need to be downloaded by any
honest node. Therefore, the total number of blocks that any honest
node needs to download before downloading ğ‘ ğ‘— is at most

ğ‘Šğ‘¡ ğ‘— âˆ’1,ğ‘¡ ğ‘— âˆ’1 +

âˆ‘ï¸

ğ‘  ğ‘— â‰¤ğ‘¡ ğ‘—

ğ´ğ‘Ÿ ğ‘—ğ‘Šğ‘  ğ‘— ,ğ‘¡ ğ‘— .

(51)

From the definition of FewLongChainsğ¾ , this is less than ğ¾. There-
fore, every honest node can download ğ‘ ğ‘— within the time slot ğ‘¡ ğ‘— . This
completes the induction step by showing that MaxDLğ¾,(0,ğ‘¡ ğ‘— +1âˆ’1] .
â–¡
For ğ‘— = ğ‘š, we conclude with MaxDLğ¾ as required.

D.6 Proof of Lemma 5

Proof. From Lemma 3, we already know that for ğ‘ = ğ‘Ağ‘‡ (1 +
, 2 ln(

(cid:111), we have

2ğ‘‡h)

âˆš

(cid:110)

2

ğœ–2) and ğ‘‡ > max

1âˆ’exp(âˆ’ğ›¼ â€²
1

ğ‘)
Pr (cid:2)Â¬(âˆ€ğ‘¡ â‰¤ ğ‘‡h : ğ‘Šğ‘¡,ğ‘¡ < ğ‘ )(cid:3) â‰¤ 2ğ‘‡ 2
h

ğ›¼2ğ‘

ğ‘’âˆ’ğ›¼2ğ‘ğ‘‡ .

(52)

It is easy to see that for any given sample path (i.e. realization of
EğœŒ,ğ›½,ğ‘‡h ) and any ğ‘  â‰¤ ğ‘¡, ğ‘Šğ‘ ,ğ‘¡ â‰¤ ğ‘Šğ‘¡,ğ‘¡ . Next, we can show that there

exists some ğ‘‡b such that ğ‘Šğ‘ ,ğ‘¡ = 0 for all ğ‘  < ğ‘¡ âˆ’ ğ‘‡b and for all ğ‘¡, so
that we have the following with overwhelming probability:

ğ‘Šğ‘¡ âˆ’1,ğ‘¡ âˆ’1 +

âˆ‘ï¸

ğ‘  â‰¤ğ‘¡

ğ´ğ‘ ğ‘Šğ‘ ,ğ‘¡ â‰¤ ğ‘ + ğ‘ğ‘‡bğ›½ğœŒ (1 + ğœ–).

(53)

(cid:16)

This is because in any ğ‘‡b slots, there are at most ğ‘‡bğ›½ğœŒ (1 + ğœ–) ad-
versarial block production opportunities with probability at least
(cid:17) (through a Chernoff bound and union bound).
1âˆ’ğ‘‡h exp

âˆ’

ğœ– 2ğ›½ğœŒğ‘‡b
ğœ–+2

To show that ğ‘Šğ‘ ,ğ‘¡ = 0 for all ğ‘  < ğ‘¡ âˆ’ ğ‘‡b for a fixed ğ‘¡,
Pr (cid:2)âˆƒğ‘  < ğ‘¡ âˆ’ ğ‘‡b : ğ‘Šğ‘ ,ğ‘¡ > 0(cid:3)
â‰¤Pr [âˆƒğ‘  < ğ‘¡ âˆ’ ğ‘‡b, âˆƒğ‘Ÿ < ğ‘  : A (ğ‘Ÿ, ğ‘ ] â‰¥ U (ğ‘Ÿ, ğ‘¡]]
(56)
â‰¤Pr [âˆƒğ‘Ÿ < ğ‘¡ âˆ’ ğ‘‡b : A (ğ‘Ÿ, ğ‘¡ âˆ’ ğ‘‡b] â‰¥ U (ğ‘Ÿ, ğ‘¡]]
â‰¤Pr [âˆƒğ‘Ÿ < ğ‘¡ âˆ’ ğ‘‡b : A (ğ‘Ÿ, ğ‘¡ âˆ’ ğ‘‡b] â‰¥ U (ğ‘Ÿ, ğ‘¡ âˆ’ ğ‘‡b] + U (ğ‘¡ âˆ’ ğ‘‡b, ğ‘¡]] (57)
(58)
â‰¤Pr [âˆƒğ‘Ÿ < ğ‘¡ âˆ’ ğ‘‡b : A (ğ‘Ÿ, ğ‘¡ âˆ’ ğ‘‡b] â‰¥ U (ğ‘Ÿ, ğ‘¡ âˆ’ ğ‘‡b] + ğ¿]

(54)

(55)

+ Pr [U (ğ‘¡ âˆ’ ğ‘‡b, ğ‘¡] < ğ¿]

(59)

where we choose ğ¿ = ğ‘Uğ‘‡b (1 âˆ’ ğœ–). The second term is bounded by
a Chernoff bound

Pr [U (ğ‘¡ âˆ’ ğ‘‡b, ğ‘¡] < ğ¿] â‰¤exp

(cid:18)

âˆ’

ğœ–2ğ‘Uğ‘‡b
2

(cid:19)

.

(60)

For calculating the first term, let

ğ‘‹ğ‘› = ğ¿ + U (ğ‘¡ âˆ’ ğ‘‡b âˆ’ ğ‘›, ğ‘¡ âˆ’ ğ‘‡b] âˆ’ A (ğ‘¡ âˆ’ ğ‘‡b âˆ’ ğ‘›, ğ‘¡ âˆ’ ğ‘‡b]
for ğ‘› â‰¥ 0 be a random walk. Let ğ‘ğ‘™ = Pr [âˆƒğ‘› : ğ‘‹ğ‘› â‰¤ 0 | ğ‘‹0 = ğ‘™], i.e.
the probability that the random walk ever hits 0 after starting from
ğ‘™. We can observe that ğ‘1 = 1 âˆ’ ğ‘U + ğ‘Uğ‘2. We can also note that
due to the translation invariance of the random walk,
ğ‘2 = Pr [âˆƒğ‘› : ğ‘‹ğ‘› â‰¤ 1 | ğ‘‹0 = 2] Pr (cid:2)âˆƒğ‘› > ğ‘›1 : ğ‘‹ğ‘›1 â‰¤ 0 | ğ‘‹ğ‘›1 = 1(cid:3)

= Pr [âˆƒğ‘› : ğ‘‹ğ‘› â‰¤ 0 | ğ‘‹0 = 1]2 = ğ‘2
1

.

Therefore, we obtain ğ‘1 = 1âˆ’ğ‘U
ğ‘U
Finally, we note using the same logic as above that ğ‘ğ¿ = ğ‘ğ¿
(cid:16) 1âˆ’ğ‘U
ğ‘U
Therefore, we have

by solving ğ‘1 = 1 âˆ’ ğ‘U + ğ‘Uğ‘2
1
1 =
which is the required probability in the first term in (58).

(cid:17)ğ¿

.

Pr (cid:2)âˆƒğ‘  â‰¤ ğ‘¡ âˆ’ ğ‘‡b : ğ‘Šğ‘ ,ğ‘¡ > 0(cid:3) â‰¤

(cid:19)ğ‘Uğ‘‡b (1âˆ’ğœ–)

(cid:18) 1 âˆ’ ğ‘U
ğ‘U

+ exp

(cid:19)

(cid:18)

âˆ’

ğœ–2ğ‘Uğ‘‡b
2

Finally, by a union bound over the required probabilities, we have
for ğ¾ = ğ‘Ağ‘‡ (1 + ğ›½ğœŒğ‘‡b (1 + ğœ–))(1 + ğœ–2),
(cid:18) 1 âˆ’ ğ‘U
ğ‘U
ğœ–2ğ›½ğœŒğ‘‡b
ğœ– + 2

Pr [Â¬FewLongChainsğ¾ ] â‰¤ ğ‘‡h

ğœ–2ğ‘Uğ‘‡b
2

(cid:19)ğ‘Uğ‘‡b (1âˆ’ğœ–)

+ ğ‘‡h exp

+ğ‘‡h exp

+ 2ğ‘‡ 2

âˆ’

âˆ’

(cid:18)

(cid:18)

(cid:19)

(cid:19)

(62)

h exp(âˆ’ğ›¼2ğ‘ğ‘‡ ) (63)
(64)

â‰¤ 5ğ‘‡ 2

h exp(âˆ’ğ›¼3ğ‘ğ‘‡b).
Here, we choose ğ‘‡b = ğ‘‡ and
(cid:26)
ğ‘U (1 âˆ’ ğœ–)
ğ›¼2,
ğ‘

ğ›¼3 = max

ln

(cid:18) ğ‘U
1 âˆ’ ğ‘U

(cid:19)

,

ğœ–2ğ‘U
2ğ‘

,

ğœ–2ğ›½ğœŒ
(ğœ– + 2)ğ‘

(cid:27)

.(65)

Finally, we set ğ‘‡b = 2 ln(

ability is negligible.

âˆš

5ğ‘‡h)+Î© (ğœ…)
ğ›¼3ğ‘

so that the required prob-

â–¡

20

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

ğ‘U

U

1 âˆ’ ğ‘
ğ‘U

ğ‘A

I

ğ‘U

ğ‘A

1 âˆ’ ğ‘

A

1 âˆ’ ğ‘U

Figure 13: An upper bound on the bandwidth utilization
of our protocol can be calculated from the stationary
distribution of this Markov chain

D.7 Proofs for

Throughput and Bandwidth Consumption

D.7.1 Proof of Lemma 6.

Proof. Due to Lemma 1, in any interval of slots (ğ‘¡1, ğ‘¡2], the
downloaded longest chain of every honest node grows by at least
U (ğ‘¡1, ğ‘¡2] (even though all blocks on the chain may not be honest).
Therefore, corresponding to the interval (ğ‘¡1, ğ‘¡2] with ğ‘¡2 â‰¥ ğ‘¡1 + ğ‘‡ ,
at least ğ‘Uğ‘‡ (1 âˆ’ ğœ–) blocks are added to every nodeâ€™s downloaded
longest chain with probability

Pr [U (ğ‘¡1, ğ‘¡2] â‰¥ ğ‘Uğ‘‡ (1 âˆ’ ğœ–)]

â‰¥ Pr [U (ğ‘¡1, ğ‘¡2] â‰¥ ğ‘U (ğ‘¡2 âˆ’ ğ‘¡1)(1 âˆ’ ğœ–)] â‰¥ 1 âˆ’ exp

(cid:19)

ğ‘Uğ‘‡

(cid:18) ğœ–2
2

. (66)

Now let ğ‘ = ğ‘Uğ‘‡ (1 âˆ’ ğœ–). Consider any ğ‘ consecutive blocks in a
valid blockchain. Let ğ‘¡ â€²
and ğ‘¡ â€²
be the time slots corresponding to
1
2
the first and last blocks respectively in this set, and let ğ‘‡ â€² = ğ‘¡ â€²
2 âˆ’ ğ‘¡ â€²
.
1
ğ‘
From the above probability bound, we have ğ‘‡ â€² â‰¤ ğ‘‡ =
.
ğ‘U (1âˆ’ğœ–)
2+ğœ–â€² ğ‘Ağ‘‡ â€²(cid:17), there are at
âˆ’ ğœ–â€²2
Also, with probability at least 1 âˆ’ exp
most ğ‘Ağ‘‡ â€²(1 + ğœ– â€²) adversarial slots in (ğ‘¡ â€²
, ğ‘¡ â€²
2], hence there are at
1
most ğ‘Ağ‘‡ â€²(1 + ğœ– â€²) adversarial blocks in the ğ‘ consecutive blocks.
Therefore, corresponding to every interval (ğ‘¡1, ğ‘¡2], there are at
least ğ‘Uğ‘‡ (1 âˆ’ ğœ–) âˆ’ ğ‘Ağ‘‡ (1 + ğœ– â€²) = (ğ‘U âˆ’ ğ‘A)ğ‘‡ (1 âˆ’ ğœ–4) honest
blocks in any nodeâ€™s downloaded longest chain with probability
at least 1 âˆ’ exp(âˆ’ğ›¼4ğ‘‡ ) for some constant ğ›¼4. Finally, we note that
â–¡
ğœƒ = ğ‘U âˆ’ ğ‘A = 2ğ‘U âˆ’ ğ‘.

(cid:16)

(61)

D.7.2 Proof of Lemma 7.

Proof. Consider time slots ğ‘¡1 and ğ‘¡2 â‰¥ ğ‘¡1 + ğ‘‡ . Due to the safety
ğ‘¡1
ğ‘¡2
of Î ğœŒ,ğœ,ğ‘‡conf , we know that LOG
ğ‘–â€² for any honest nodes
ğ‘– âª¯ LOG
ğ‘¡1
ğ‘– must have a time slot ğ‘¡ â€²
ğ‘–, ğ‘– â€². The last block in LOG
1 â‰¥ ğ‘¡1 âˆ’ 2ğ‘‡conf
because between ğ‘¡1 âˆ’ 2ğ‘‡conf and ğ‘¡1 âˆ’ ğ‘‡conf , there is at least one
ğ‘¡1
unique pivot slot which contributes a block to LOG
. Therefore
ğ‘–
ğ‘¡2
ğ‘¡1
ğ‘– contains only blocks with time slots in the interval
ğ‘–â€² \ LOG
LOG
2] where ğ‘¡ â€²
(ğ‘¡ â€²
, ğ‘¡ â€²
2 = ğ‘¡2 âˆ’ ğ‘‡conf . Note that blocks in the confirmed
1
chain must have increasing time slots, so their number is limited by
(cid:3). The average
the number of slots with block proposal, i.e. B (cid:0)ğ‘¡ â€²
, ğ‘¡ â€²
1
2
number of slots with block proposal in the interval (ğ‘¡ â€²
2] is ğ‘ (ğ‘¡ â€²
, ğ‘¡ â€²
2 âˆ’
1
ğ‘¡ â€²
1) â‰¤ ğ‘ (ğ‘¡2 âˆ’ ğ‘¡1 + ğ‘‡conf ) = ğ‘ (ğ‘‡ + ğ‘‡conf ). Then by a Chernoff bound,
(67)

(cid:3) > ğ‘ğ‘‡ (1 + ğœ–5)(cid:3) â‰¤ exp (âˆ’ğ›¼5ğ‘‡ )
for sufficiently large ğ‘‡ > ğ‘‡conf and some constant ğ›¼5.

Pr (cid:2)B (cid:0)ğ‘¡ â€²
1

, ğ‘¡ â€²
2

â–¡

Longest Chain Consensus Under Bandwidth Constraint

D.7.3 Proof of Lemma 8.

Proof. Consider the Markov chain shown in Figure 13 with
three statesâ€”U corresponding to a uniquely successful slot, I cor-
responding to a slot without a block proposal such that the most
recent block proposal was a uniquely successful slot, and A corre-
sponding to adversarial slots or slots without block proposals such
that the most recent block proposal was an adversarial slot.

ğœ‹I =

ğœ‹U = ğ‘U,

The stationary distribution of this Markov chain is
ğ‘A
ğ‘

ğ‘U (1 âˆ’ ğ‘)
ğ‘
Note that in time slots corresponding to the I (idle) state, there
are no fresh blocks to be downloaded because the most recent block
proposal was a unique honest block which was downloaded within
1 slot. Therefore, on average, in ğœ™idle fraction of time slots, every
honest nodeâ€™s bandwidth remains idle, where

ğœ‹A =

(68)

,

.

ğœ™idle â‰¥ ğœ‹I =

ğ‘U (1 âˆ’ ğ‘)
ğ‘

(1 âˆ’ ğ‘)(1 + ğœ–1)

=

â‰¥

1
2
(cid:18) 1 âˆ’ ğ‘
2

(cid:19)

.

(69)

(For ğœ–1, see the proof of Theorem 1.) Finally, by a Chernoff bound,
the probability that for a given ğ‘¡1, ğ‘¡2, there are at least ğœ™idleğ‘‡ (1 âˆ’
ğœ–6) slots in the I state in the interval (ğ‘¡1, ğ‘¡2] is at least 1âˆ’exp

âˆ’

(cid:16)

ğœ– 2
6
2

ğœ™idleğ‘‡
â–¡

E SECURITY OF PARALLEL CHAINS
The below security theorem holds for any download rule which
satisfies the requirement in Theorem 1, and in addition leaves a frac-
tion ğœ™idle âˆˆ (0, 1) of the total bandwidth unutilized (cf. Lemma 8).
The latter requirement can be easily achieved for any download rule
for any desired ğœ™idle âˆˆ (0, 1) by increasing the time slot duration
by a factor of
and only downloading blocks in the first ğœ™idle
fraction of the time slot.

1
ğœ™idle

Also note that the below theorem holds under a static corruption
adversary (i.e., the adversary decides which nodes to corrupt before
the randomness of the protocol is drawn).

Theorem 2. For all ğ¾ âˆˆ N and download rules D such that

(cid:104)

Pr

EğœŒ,ğ›½,ğ‘‡h : Â¬MaxDLğ¾ (EğœŒ,ğ›½,ğ‘‡h, D)

(cid:105)

â‰¤ negl(ğœ…),

(70)

2

if (1âˆ’ ğ›½)ğœŒğ‘’âˆ’ğœŒ = 1âˆ’ğ‘’âˆ’ğœŒ
(1+ğœ–1) for some ğœ–1 âˆˆ (0, 1), ğœ = Î©(ğœ… +lnğ‘‡h),
ğ‘‡conf = Î©((ğœ… + lnğ‘‡h)2), Lemma 8 holds for some ğœ™idle âˆˆ (0, 1), and
with the
ğ‘š = 1 +
download rule D is secure with parameter ğ‘‡live = Î©((ğœ… + lnğ‘‡h)2).

ğ¶ğœ (1 âˆ’ ğœ–7), then the protocol Î ğœŒ,ğœ,ğ‘‡conf,ğ‘š

ğœ™idle
ğœ™p

pc

Proof. Consider a particular protocol instance Î idx. Define
dCğ‘–,idx to be the longest downloaded chain of node ğ‘– for proto-
col instance Î idx. From Theorem 1, for the given ğœŒ, ğœ and ğ‘‡conf = ğ›¾,
each protocol instance Î idx satisfies safety and liveness with re-
spect to the ledger defined by dCğ‘–,idx (ğ‘¡) âŒˆğ‘‡conf and for nodes ğ‘– for
which Î idx is the primary chain, expect with probability negl(ğœ…).
By a union bound, safety and liveness for each protocol instance
holds over ğ‘š = poly(ğœ…) protocol instances as well.

21

(cid:17).

Due to safety of Î idx, dCğ‘–,idx (ğ‘¡) âŒˆğ‘‡conf âª¯ dCğ‘—,idx (ğ‘¡ â€²) âŒˆğ‘‡conf or
dCğ‘—,idx (ğ‘¡ â€²) âŒˆğ‘‡conf âª¯ dCğ‘–,idx (ğ‘¡) âŒˆğ‘‡conf for all time slots ğ‘¡, ğ‘¡ â€² and all
honest nodes ğ‘–, ğ‘— for which Î idx is the primary chain. However,
this holds even if Î idx is not the primary chain for node ğ‘– or ğ‘—
because such nodes receive all block headers, determine the longest
header chain based on them, and then download its confirmed
prefix. More concretely, an adversary that pushes an inconsistent
longest header chain to a node ğ‘— for which Î idx is a secondary
chain, can also do so with headers and contents for a node ğ‘— â€² for
which Î idx is the primary chain, thus causing a safety violation,
which contradicts the earlier observation. Since all nodes have con-
sistent confirmed chains (i.e. dCğ‘–,idx (ğ‘¡) âŒˆğ‘‡conf âª¯ dCğ‘—,idx (ğ‘¡ â€²) âŒˆğ‘‡conf or
dCğ‘—,idx (ğ‘¡ â€²) âŒˆğ‘‡conf âª¯ dCğ‘–,idx (ğ‘¡) âŒˆğ‘‡conf ) for each protocol instance and
the combined ledger is derived by ordering the blocks in all con-
firmed chains deterministically by their time slot, this implies safety
of Î ğœŒ,ğœ,ğ‘‡conf,ğ‘š
ğ‘— âª¯
pc
LOGğ‘¡
ğ‘– ).

(i.e., âˆ€ honest ğ‘–, ğ‘— : âˆ€ğ‘¡, ğ‘¡ â€² : LOGğ‘¡

ğ‘– âª¯ LOGğ‘¡ â€²

ğ‘— âˆ¨LOGğ‘¡ â€²

To show liveness, we first show that confirmed secondary chain
blocks are downloaded with bounded delay. From Lemma 8, in
any interval of Ëœğ‘‡ slots, the bandwidth of each node is not re-
quested for downloads related to the primary chain but available
to download secondary chain blocks in at least ğœ™idle Ëœğ‘‡ (1 âˆ’ ğœ–5)
slots. Further, from Lemma 7, in any interval of Ëœğ‘‡ slots, the con-
firmed secondary chains grow by at most ğœ™p Ëœğ‘‡ (1 + ğœ–6) blocks.
These events happen with probability at least 1 âˆ’ negl(ğœ…) over
a time horizon ğ‘‡h with Ëœğ‘‡ = Î©(ğœ… + lnğ‘‡h). By a union bound
over ğ‘š = poly(ğœ…) number of chains, these hold with at least
1 âˆ’ negl(ğœ…) probability over all chains. Therefore, in Ëœğ‘‡ slots, all
confirmed blocks in ğ‘š âˆ’ 1 secondary chains can be downloaded,
where ğ‘š âˆ’ 1 =

ğœ™idle
ğœ™p
Finally, note that liveness of each protocol instance guarantees
liveness of the parallel chains construction. As per the transaction
distribution rule described in Appendix C, each transaction belongs
to a particular protocol instance. By the liveness of each protocol in-
stance, any transaction input to all honest nodes in time slot ğ‘¡, is in-
cluded in dCğ‘– (ğ‘¡) âŒˆğ‘‡conf for ğ‘¡ â€² â‰¥ ğ‘¡ +ğ›¾ +ğ‘‡conf (see Proof of Lemma 9 in
Appendix D.2) and all nodes ğ‘– for which the corresponding protocol
instance is primary. Moreover, all honest nodes download confirmed
secondary chains within Ëœğ‘‡ delay. Therefore, Î ğœŒ,ğœ,ğ‘‡conf,ğ‘š
satisfies
liveness with total latency ğ›¾ + ğ‘‡conf + Ëœğ‘‡ = Î©((ğœ… + lnğ‘‡h)2).
â–¡

ğ¶ğœ (1 âˆ’ ğœ–7) for some ğœ–7.

ğœ™idle Ëœğ‘‡ (1âˆ’ğœ–5)
ğœ™p Ëœğ‘‡ (1+ğœ–6)

ğ¶ğœ =

pc

F CONFLUX INCLUSION RULE
In order to prevent the throughput from vanishing as the resilience
ğ›½ approaches 1/2, we incorporate a modified version of the block
inclusion rule from Conflux [38] (also used in [23]). In addition to
the hash of the parent block, the header of a block ğ‘ also contains
references to (hashes of) at most ğ‘… blocks which have time slots
earlier than ğ‘ and are neither in the prefix nor are referenced by any
blocks in the prefix of ğ‘. Moreover, in each chain, at most one block
from each time slot may be referred. An honest block producer
chooses to include the ğ‘… newest (by time slot) fully downloaded
blocks in their view that satisfy the above criteria. The parameter ğ‘…
is to be determined below. Blocks containing references that do not
follow the above criteria will be considered invalid. The consensus
protocol still uses the longest chain rule.

Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh

Therefore, the lemma holds under ğ‘‡4 = ğ›¾ and the conditions from
â–¡
Lemma 10.

F.3 Parallel Chains Throughput
We still have honest nodes idle (not downloading any blocks) in at
least ğœ™idle â‰¥ 1âˆ’ğ‘
fraction of slots. The average bandwidth required
to download a confirmed chain still remains at ğ‘ blocks per slot.
Therefore, we can increase the total throughput by constructing
ğ‘š = 1 +

parallel chains resulting in aggregate throughput

2

ğœ™idleğ¶
ğœ™p/ğœ

ğ¶ğœ

(cid:19) ğœƒinc
ğœ

TPğ‘š =

â‰¥

â‰¥

(cid:18)

1 +

ğœ™idle
ğœ™p
(1 âˆ’ ğ‘)ğ‘U
2ğ‘
(1 âˆ’ ğ‘)
4

ğ¶

(for the â€˜freshest blockâ€™ rule)

ğ¶ blocks per second.

(73)

This is a constant fraction of the capacity ğ¶ which does not vanish
as ğ›½ â†’ 1/2.

Note that downloading and validating a block now requires (in
addition to downloading the block itself) downloading the content
of all blocks in its prefix and all blocks referenced by blocks in the
prefix. Unlike [23], we do not consider the reference links to be
transitive as this would blow up the number of referred blocks
to be downloaded. The output ledger of a node ğ‘– in slot ğ‘¡ (i.e.
LOGğ‘¡
ğ‘– ) will be formed by considering its truncated longest chain (i.e.
dCğ‘– (ğ‘¡) âŒˆğ‘‡conf ) and inserting blocks referred by a block ğ‘ between
the parent of ğ‘ and ğ‘, in increasing order of their time slot. This
may result in some transactions becoming invalid due to conflicting
transactions appearing before them in the ledger. Such transactions
would be removed (sanitized) while obtaining the ledger.

ğ¶ (previously Î”h + ğ¾

F.1 Security
For security of the inclusive protocol, it is enough to set the time
slot size to be ğœ = Î”h + ğ¾ğ‘…
ğ¶ ) where ğ¾ is set
according to Theorem 1 (we do the analysis below for the fresh-
est block download rule, but it can be done for the equivocation
avoidance download rule as well). Since each block contains at
most ğ‘… references, the number of blocks to be downloaded in the
prefix of any honest freshest block increases at most by a factor of
ğ‘…. By setting the slot size as above, we ensure that the honest block
proposed in every uniquely successful slot is downloaded (along
with its prefix and references therein) within the same slot.

F.2 Single Chain Throughput
If ğ‘… = ğ›¾ğ‘ (1 âˆ’ ğœ–7), there exists a constant ğ‘‡4 such that
Lemma 12.
for any honest node ğ‘– and time slots ğ‘¡1, ğ‘¡2 â‰¥ ğ‘¡1 + ğ‘‡ , ğ‘¡ â‰¥ ğ‘¡2 + ğ‘‡conf
with ğ‘‡ â‰¥ ğ‘‡4, LOGğ‘¡
ğ‘– contains at least ğœƒincğ‘‡ (1 âˆ’ ğœ–8) blocks proposed by
honest nodes in slots (ğ‘¡1, ğ‘¡2], with probability at least 1 âˆ’ exp(âˆ’ğ›¼4ğ‘‡ ),
where ğœƒinc = ğ‘U.

instance of the inclusive protocol is at least ğœƒinc
ğœ

Lemma 12 indicates that the average throughput of a single
blocks per second.
To prove Lemma 12, we only need to show that every honest
block from a uniquely successful slot is included in the longest chain
of every node either directly on the chain or through a reference.
This will be achieved by setting ğ‘… to be large enough so that in any
interval of slots with ğ‘… block production opportunities, at least one
honest block is included in the longest chain. Then such an honest
block would include references to the ğ‘… most recent blocks which
would collectively include (at least) all honest blocks from uniquely
successful slots.

Proof. From the security analysis (Lemma 10), we have that
(cid:104)
â‰¥ 1 âˆ’ negl(ğœ…) where FreqPivotsğ›¾ is the event

FreqPivotsğ›¾

(cid:105)

Pr

âˆ€ğ‘¡ : âˆƒğ‘¡ â€² âˆˆ (ğ‘¡, ğ‘¡ + ğ›¾] : Pivot(ğ‘¡ â€²) âˆ§ Unique(ğ‘¡ â€²).

(71)

Moreover, we have shown in Lemma 9 that the honest block pro-
posed in a unique pivot slot remains in the longest downloaded
chain of every honest node. This satisfies our requirement. Thus,
we need to set ğ‘… = ğ›¾ğ‘ (1 + ğœ–7) so that there are at most ğ‘… uniquely
successful slots between two pivot slots, i.e.

âˆ€ğ‘¡ : Pr [U (ğ‘¡, ğ‘¡ + ğ›¾] > ğ‘…] â‰¥ 1 âˆ’ exp

(cid:32)

ğœ–2
7
ğœ–7 + 2

(cid:33)

ğ›¾ğ‘

.

(72)

22

