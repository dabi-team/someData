2
2
0
2

l
u
J

8
2

]

C
D
.
s
c
[

1
v
1
1
0
4
1
.
7
0
2
2
:
v
i
X
r
a

Marvel DC: A Blockchain-Based Decentralized and
Incentive-Compatible Distributed Computing Protocol(cid:63)

Conor McMenamina,b, Vanesa Dazaa,c

aDepartment of Information and Communication Technologies, Universitat Pompeu Fabra,
Barcelona, Spain
bNOKIA Bell Labs, Nozay, France
cCYBERCAT - Center for Cybersecurity Research of Catalonia

1. Abstract

Decentralized computation outsourcing should allow anyone to access the

large amounts of computational power that exists in the Internet of Things.

Unfortunately, when trusted third parties are removed to achieve this decen-

tralization, ensuring an outsourced computation is performed correctly remains

a signiﬁcant challenge. In this paper, we provide a solution to this problem.

We outline Marvel DC, a fully decentralized blockchain-based distributed-

computing protocol which formally guarantees that computers are strictly incen-

tivized to correctly perform requested computations. Furthermore, Marvel DC

utilizes a reputation management protocol to ensure that, for any minority of

computers not performing calculations correctly, these computers are identiﬁed

and selected for computations with diminishing probability. We then outline

Privacy Marvel DC, a privacy-enhanced version of Marvel DC which decouples

results from the computers which computed them, making the protocol suitable

for computations such as Federated Learning, where results can reveal sensitive

information about that computer that computed them. We provide an imple-

mentation of Marvel DC and analyses of both protocols, demonstrating that

(cid:63)This document is part of a project that has received funding from the European Union’s

Horizon 2020 research and innovation programme under grant agreement number 814284

Email addresses: conor.mcmenamin@upf.edu (Conor McMenamin),

vanesa.daza@upf.edu (Vanesa Daza)

Preprint submitted to Journal of Information Sciences

July 29, 2022

 
 
 
 
 
 
they are not only the ﬁrst protocols to provide the aforementioned formal guar-

antees, but are also practical, competitive with prior attempts in the ﬁeld, and

ready to deploy.

Keywords: Distributed Computing, Decentralization, Blockchain, Incen-

tives

2. Introduction

The distributing of computation among computers has beckoned a never-

before-seen level of computing power available to average users with access to

as little as a smart phone and an average internet connection. Distributed

computations (DCs) have typically been outsourced directly to one of the few

centralized Big Tech. providers such as Amazon Web Services, or Google Cloud.

Unfortunately, centralized services like these have many drawbacks. Monopoly

of resources, centralized trust, restricted access for certain clients, and in the

case of Federated Learning (FL), lack of diverse data-sets make these central-

ized services unﬁt for many users and purposes. Full decentralization solves all

of these issues. Unfortunately, decentralizing distributed-computing protocols

brings many new challenges that are largely protected against in the centralized

setting. A signiﬁcant issue in many existing decentralized DC implementations

[16, 1, 20, 19, 13, 27, 26, 25] is the accurate rewarding of computers to incen-

tivize rational computers, computers who try to maximize their utility (e.g.

in cryptocurrency tokens), to correctly perform outsourced computations. In

decentralized settings such as blockchain protocols, players only follow an ac-

tion(s) if that action(s) is(are) strong incentive compatible, resulting in strictly

higher payoﬀs than the alternatives. One method to combat this is, for a given

computation, to use zero-knowledge (ZK) tools to prove that a computer per-

formed the actions as prescribed by the requester [24]. Although theoretically

any computation can be encoded in this way, the practicality of requiring re-

questers, typically with low computing power by the nature of outsourcing, to

encode their computation as a ZK-circuit to allow for the proving of correct

2

computation is an open question. Furthermore, the pre-computation work re-

quired by requesters in [24] is itself intensive (3-40 minutes using 16 virtual CPU

cores, and 64 GB RAM), and not appropriate for computationally-restricted re-

questers, defeating a signiﬁcant purpose of DC protocols.

In this paper, we

address all of these issues.

2.1. Our Contribution

We present Marvel DC, a generic (can be adapted to any computational

problem outputting results in Euclidean space) blockchain-based decentralized

DC protocol which addresses the many gaps that exist in outsourcing compu-

tations without the use of a trusted third-party (TTP). Namely, Marvel DC

provides for the ﬁrst time in literature a decentralized DC protocol which en-

sures rational computers are strongly incentivized to follow the protocol. This

is a signiﬁcant advancement in a ﬁeld where existing claims of incentive compat-

ibility do not account for computers trying to maximize their tokens, with no

viable solution, to the best of our knowledge, for the distributing of tokenized

rewards in a distributed and decentralized manner.

Furthermore, Marvel DC utilizes reputations to isolate correctly-performing

computers when selecting computers for computations. This allows Marvel DC

to eﬃciently remove adversarial computers from the protocol. As these repu-

tations are maintained on the blockchain itself, through careful construction

(Section 5.2) this reputation protocol neither aﬀects the decentralisation or

strong incentive compatibility of the protocol. When using a ﬁxed number

of computers per computation, our protocol shares all of the beneﬁts of [8]. Our

description of Marvel DC can be adapted to run on any smart-contract enabled

blockchain, and as such, can make use of the vast existing communities which

exist on such blockchains. This is a further improvement on protocols which

require the recruitment and constant participation of an independent network

of computers. In a blockchain, where computers form a subset of users, com-

puters can be dormant until required to perform a computation. By deploying

on an existing blockchain, any player in that blockchain can also participate in

3

Marvel DC as a computer and/or requester. We summarize the main contribu-

tions of Marvel DC as follows:

• Strong incentive compatibility in expectation.

In Section 5, we

describe how to program rewards such that it is strong incentive compati-

ble in expectation for every rational player (requesters, computers and/or

block-producers) in the blockchain system to follow the protocol.

• Handling of symmetric/asymmetric utilities. By tokenising the pro-

tocol rewards, we are able to handle both symmetric (rational computers

and requesters only want to produce good results) and asymmetric (ratio-

nal computers want to be compensated ﬁnancially) utilities.

• Decentralization. Encoding Marvel DC in a generic manner for any to-

kenized smart-contract enabled blockchain, all players in such a blockchain

system are able to participate in Marvel DC. Furthermore, all of the tools

used in Marvel DC are already in use in smart-contract enabled decen-

tralized systems such as Ethereum 1 and Harmony 2 (our smart-contract

encoding [10] is written in Solidity [10], a programming language inter-

pretable by both blockchains ), demonstrating our encoding can utilize

the decentralisation of such blockchain ecosystems.

On top of these main contributions, Marvel DC also retains additional de-

sirable properties that should be present in any DC protocol:

• Fair selection. Our protocol uses a decentralized pseudorandom function

(such as a veriﬁable on-chain oracles3, or those used in [5]) to provide a

random seed used to select computers based on reputation. This removes

the possibility of reputation-based manipulation by clusters of colluding

computers who may try to prioritize the selection of computers in the

colluding cluster, as is allowed in existing works [8, 7, 24].

1https://ethereum.org/en/
2https://www.harmony.one/
3https://docs.chain.link/docs/chainlink-vrf/

4

• Proper management of new peers. All new computers entering Marvel DC

are given the same initial reputation, which eventually becomes signiﬁ-

cantly lower than the average reputation of active honestly-behaving com-

puters.

• Low communication complexity & cost. By utilising a blockchain,

computers participating in Marvel DC are only required to monitor the

blockchain for computation requests, and respond when they themselves

are selected to participate in the computation. Furthermore, by utilising

cost-eﬀective blockchains such as Harmony, the costs for participation in

Marvel DC are fractions of a US dollar, as shown in Section 7.

Given these properties of Marvel DC, we then outline a series of privacy-

enhancing amendments, culminating in Privacy Marvel DC, a protocol in which

results cannot be linked to the computer which provided the result, except with

signiﬁcant additional cost to the player who causes the revelation. Privacy

Marvel DC retains all of the decentralisation and incentive compatibility guar-

antees of Marvel DC, while also adding a layer of privacy which makes it appro-

priate for sensitive computations where knowing a certain computer computed

a particular result can be used to infer private/unwanted information about the

computer. This is particularly interesting in the case of FL, where computers

are asked to use private data set.

To do this, we make use of existing ZK set-membership tools (described in

Section 4.2). These tools are used in protocols such as Zerocoin [22] and Tornado

Cash4, with the latter of which currently deployed and in use on the Ethereum

blockchain. Computers encrypt results, and publish them anonymously to the

blockchain through a network of relayers: blockchain participants who are in-

centivized to submit transactions on behalf of other players (explained in detail

in Section 4.3). The set of good and bad results are published as in Marvel DC,

and as results are not attached to the computer that sent them, computers prove

4https://tornado.cash/

5

membership among the set of computers submitting good/bad results using the

aforementioned ZK set-membership tools.

Although our privacy techniques are not novel outside of DC, and in fact

reduce privacy compared to DC protocols like [24], the combination of decen-

tralisation, proven strong incentive compatibility and the ability to apply one

smart-contract instance of Privacy Marvel DC to any computational problem

with output in Euclidean space (summarized in Table 1) stands as an additional

novel contribution.

3. Related Work

Protocol

[16, 1, 20, 19, 13, 27, 26]

Tokenized
Rewards
(cid:55)

Strong Incentive
Compatible
(cid:55)

Toyoda et al. [25]

Ruckel et al. [24]

Marvel DC

(cid:51)

(cid:51)

(cid:51)

(cid:55)

(cid:51)

(cid:51)

Computation-Independent

(cid:51)

(cid:51)

(cid:55)*
(cid:51)

Diminishing Adversarial
Selection Prob.
(cid:51)/ (cid:55)
(cid:55)

(cid:55)

(cid:51)

Table 1: Comparison of incentive-aware FL protocol designs. *Computation-independence
refers to the ability of a particular smart-contract encoding to be re-used for many computa-
tions. The ZK circuit-encodings of [24] must be generated anew for each type of computation,
placing signiﬁcant upfront costs on computation requesters.

There are many intertwined areas of research regarding the decentralized

outsourcing of computations to distributed sets of potentially untrusted peers.

Strong advancements have been made with respect to single computer outsourc-

ing, with [28, 17, 9] providing variations of such pairwise protocols.

These 2-player protocols involve several rounds of communication between

the requester and computer. However, none discuss the problem of computer

selection or rewarding in the presence of many competing computers. This

limits their scope for outsourcing computations where the participation of many

computers is required, such as in FL.

Blockchain-based DC protocols [16, 1, 20, 19, 13, 27, 26] have been well-

studied also. Unfortunately, all of these papers consider a blockchain or dis-

tributed system in which all parties share one utility, that is, the ability to

6

use/beneﬁt from a well-trained shared model, which gives correct behaviour

by deﬁnition. Such an assumption makes these protocols and their resulting

analyses inappropriate in the presence of untrusted peers and/or asymmetric

utilities.

In [25], a protocol and general framework for incentive mechanism design,

within FL protocols where players measure utility tokenomically, are proposed.

Computer registration and reward distribution must all be performed by players

within the system. Computer registration is performed by an “administrator”,

which prevents decentralization and encourages collusion. Furthermore, com-

putation rewards are distributed based on votes of players within the system.

The incentive compatibility of this choice is not considered, and is non-trivial

to implement. In Marvel DC, rewards are distributed deterministically as part

of the smart-contract execution on requester inputs. We prove that rational re-

questers always submit messages correctly to the blockchain, and thus, correct

rewarding is strong incentive compatible. Moreover, [25] has no mechanism to

identify Byzantine computers and diminish/remove their ability to participate

in the protocol. In Marvel DC, this is achieved using reputations.

Recently, an extensive survey of existing attempts to construct privacy-

preserving FL protocols[18] was published. Of the investigated works, the

most promising for achieving an incentive-compatible decentralized protocol

is [24].

In [24], ZK-proofs are used in the computing stage to prove that

a computation was performed correctly.

In a decentralized setting however,

this raises many challenges, as each type of computation requires its own ZK

circuit-generation/trusted set-up to generate the target function. In contrast,

Marvel DC can be implemented using existing, blockchain-deployed ZK-tools

and generalised rewarding functions. Moreover, as acknowledged by the au-

thors of [24], although their methodology ensures models were trained correctly,

it does not guarantee the models were trained on appropriate data. A proposed

solution is using “certiﬁed sensors”, equivalent to TTPs, a non-viable solution

in a decentralized setting. As the rewarding functions in Marvel DC reward

players based on the relative quality of the results, and not just based on the

7

fact that a series of computations has been performed correctly, independent of

the data on which the computations are being performed, we are able to avoid

this issue.

4. Preliminaries

4.1. Blockchains

In this paper, we are interested in a distributed set of n players {P1, ..., Pn}

interacting with one and other inside a blockchain protocol. These players send

and receive stake among one another, along with the functionality to encode

programs to run within the blockchain protocol in the form of smart contracts.

A foundational assumption for the functioning of blockchain protocols is that a

majority of players in the protocol act rationally, following the protocol if they

are incentivized to do so. The non-rational players are known as Byzantine,

and are modelled as deviating from the protocol either maliciously or randomly,

and being controlled by a single adversary. This player model is known as

the ByRa model [21], which we use in this paper. The ByRa model is a nec-

essary improvement on the legacy BAR model [15] for the true consideration

of incentives in distributed systems, removing any dependencies on altruistic,

honest-by-default players which cannot be assumed to exist in incentive-driven

protocols like blockchain/DC protocols.

Deﬁnition 4.1. The ByRa model consists of Byzantine and Rational players.

A player is:

• Byzantine if they deviate arbitrarily from a recommended protocol with

unknown utility function. Byzantine players are chosen and controlled by

an adversary A.

• Rational if they choose the strategy which maximizes their utility assum-

ing all other players are rational.

It is the aim of this paper to construct a DC protocol that ensures rational

players always follow the protocol, a property known as strong incentive com-

patibility in expectation. In this paper, rational players utility is measured in

8

blockchain-based tokens. Based on similar assumptions to [14], the blockchain

protocol acts conceptually as a public ledger managed by a TTP. In reality, it is

the following of the blockchain protocol by some majority of players using the

blockchain that replicates this TTP. The protocol provides availability and cor-

rectness of the programs being run through the protocol, but does not provide

privacy. That is, any player can observe the current state of all programs being

run on the blockchain, and can verify that this state has been reached through

the correct running of these programs. However, player inputs to these programs

must be committed publicly to the blockchain before they can be passed to the

smart contract, and as such, it will be an important requirement of designing

a protocol involving smart contract interaction, through transactions, that the

blockchain will accept these transactions in a timely fashion.

In our system,

this is achieved using incentivization.

4.2. Zero-Knowledge Primitives

The aim of this section is to outline existing non-interactive zero-knowledge

(NIZK) tools for set membership, such as those stemming from papers like [22, 2,

11, 3, 12], which are used in our privacy-enhanced DC protocol. We deﬁne these

tools generically, allowing for the adoption of any secure NIZK set-membership

protocol into Marvel DC, as we only require a common functionality that is

shared by all of them.

In the rest of the paper, we let ∗ denote any value. Computers privately

generate two bit strings, the serial number S and randomness r, with S, r ∈

{0, 1}O(κ) for some security parameter κ. Computers then commit to these

values by generating a commitment com ← fcom(S, r) where fcom(∗) is some

cryptographically-secure commitment function (such as a Pedersen Commit-

ment [23]). This com is then published to the blockchain, with the set of all

commitments denoted by Com. With this in mind, we now deﬁne the key func-

tions that allow us to reason about the NIZK proving of the membership of

some commitment com in Com:

• Verify(π): For a ZK proof π, returns 1 if and only if π is a valid proof of

9

knowledge.

• MemVerify(Com, com) : Returns 1 if and only if com ∈ Com.

• NIZKPoK{(com, r) : MemVerify(Com, com) = 1 & com = fcom(S, r)

} → π: Returns a NIZK proof of knowledge of a commitment com and ran-

domness r which satisﬁes MemVerify(Com, com)=1 and com = fcom(S, r).

The variables (com, r) are assumed to be known only by the prover, while

all other variables and functions are know by the veriﬁer. Speciﬁcally,

this function depends on the serial number S being revealed. This reve-

lation identiﬁes to a veriﬁer when a proof has previously been provided

for a particular, albeit unknown, commitment as the prover must repro-

duce S. This is used in conjunction with an escrow to enforce the correct

participation of computers in our privacy-enhanced DC protocol.

• NIZKSoK(m){(com, r) : MemVerify(Com, com) = 1 & com = fcom(S, r)

} → π: for an arbitrary message m, this function returns an NIZK proof

which proves that the person who chose m can also produce NIZKPoK{

(com, r) : MemVerify(Com, com) = 1 & com = fcom(S, r) }. As such,

NIZKSoK(m) acts as a signature of knowledge on m, as coined in [22].

In this paper, we assume the public NIZK parameters are set-up in a trusted

manner5.

4.3. Relayers

A fundamental requirement for transaction submission in blockchains is the

payment of some transaction fee to simultaneously incentivize block producers

to include the transaction, and to prevent denial-of-service/spamming attacks.

However, this allows for the linking of player transactions, balances, and their

associated transaction patterns. To counteract this, we utilize the concept of

5Such as a Perpetual Powers of Tau ceremony, as used in Zcash https://zkproof.org/

2021/06/30/setup-ceremonies/

10

transaction relayers 6.

When a computer wishes to submit a transaction anonymously to the block-

chain, the computer publishes a proof of membership to the relayer mempool, as

well as the desired transaction and a signature-of-knowledge cryptographically

binding the membership proof to the transaction, preventing tampering. As the

relayer can verify the proof of membership, the relayer can also be sure that

if the transaction is sent to certain smart-contracts (such as those used in our

DC protocols), the relayer will receive a fee. As such, a model in which players

submit transactions to relayers, who then in turn submit those transactions to

the blockchain for a guaranteed fee is a straightforward extension of a model in

which players submit transactions directly to the blockchain themselves. Fur-

thermore, if the transaction contains a proof of membership that is NIZK and

the message is broadcast anonymously (using the onion routing (Tor) protocol7

for example), the relayer can only infer that the player sending the transaction

is a member of a particular set.

5. Constructing a Strong Incentive Compatible DC Protocol

For the sake of comprehensibility, we ﬁrst describe an idealized protocol for

the distribution of computation between a set of computers. We then demon-

strate how to instantiate such a protocol using existing blockchain technology.

In this description, we consider a requester who has a computation calc whose

calculation the requester wishes to outsource to some subset of available com-

puters C. Furthermore, the requester is aware of a threshold nψ such that for

any random sample of nψ computers without replacement from C, a majority

of those computers are rational.

We consider the output of all computations in this paper as a point in l-

dimensional space. To reason about the goodness of a computation result, for

6Ox https://0x.org/docs/guides/v3-specification, Open Gas Station Network https:
//docs.opengsn.org/, Rockside https://rockside.io/, Biconomy https://www.biconomy.
io/

7https://www.torproject.org/

11

every computation we assume the existence of a deterministic function which

takes the set of computation responses, and given a majority of correctly com-

puted results, outputs a target value τ , which is computed correctly with prob-

ability 1 − (cid:15), for some (cid:15) < 0.5. For deterministic calculations, the mode is such a

function. In FL where results are model gradients, the Krum function [4] is such

an aggregation function. We let dist(x, y) be the Euclidean distance function.
For x, y ∈ Rl, dist(x, y) = (cid:112)(x1 − y1)2 + ... + (xl − yl)2.

Consider the set of computation results {result1, ..., resultncomp }. We require

for any pair (result+, result−), with result+ a correctly computed result and

result− an incorrectly computed result the following holds for any σ > 0:

P (dist(result+, τ ) < σ) > P (dist(result−, τ ) < σ).

(1)

Given this, for any subset of computation results taken in ascending order using

the function dist, the expected number of these computations being correctly

computed is greater than those being incorrectly computed. With respect to

deterministic computations, letting τ be the median or mode, all correctly com-

puted results will be distance 0 to τ . For non-deterministic computations, it is

less clear. The function used to compute τ must be chosen such that Equation

1 holds.

Now, consider the following DC protocol run by a trusted third party (TTP)

who enforces the correct participation of all rational players. The proceeding

sections then replace this TTP, in order to achieve full decentralization, through

the use of a smart contract-enabled blockchain and a strong incentive compatible

protocol (Marvel DC, described in Section 6) to be run therein.

Idealized distributed computing protocol. Requesters repeatedly enter

the system with independent functions for computation. A requester wishing

to avail of the distributed computation of some function calc submits calc to

the TTP, as well as some number of computers ncomp > nψ. The TTP then

selects ncomp from the set of available computers C. The computers respond to

the TTP with their computation of calc, who then sends all of the computation

results to the requester.

12

In a distributed setting, such TTPs do not exist. Therefore, to enforce

the correct participation of rational players we need to utilize a mixture of

cryptography and incentivisation. With this in mind, we ﬁrst describe how to

generically construct a reward mechanism such that rational players are strongly

incentivized to follow the protocol. We then outline a reputation management

protocol which maintains this incentivisation, while reducing the probability

that incorrectly performing computers are selected for computation.

5.1. Reward Mechanism

In this section, we provide a theoretical lower-bound on the per-computer

reward required to strongly incentivize the correct participation of rational com-

puters in our DC protocol. We describe this reward generically in terms of a

cost to compute a particular computation, fees required to post a transaction

to the blockchain, and the probability of being rewarded for good and bad com-

putations. We also describe an escrow amount to be deposited by the requester

when submitting the computation, which is received back after correctly com-

puting the set of computers to reward. Running computations such as sorting

arrays or encryption/decryption on-chain is expensive, so we initially give the

requester the opportunity to correctly submit the set of computers to reward.

Computers have an opportunity to contest this by depositing a bounty on-chain,

triggering the on-chain veriﬁcation of the reward set. Note that veriﬁcation is

much cheaper than computation, but with respect to Privacy Marvel DC, this

reveals some private information, which is why veriﬁcation does not take place

automatically. If the contest is valid, the requester loses the escrow. Otherwise,

the computer loses the bounty. This is described in more detail in Section 6.

For a given computation calc, we assume an accurate a-priori lower-bound

on the cost to compute a particular computation calc of cost(calc). This lower-

bound is known by all players in the system (in reality this value can be enforced

by the protocol smart-contract). Given that the payment of Fee(tx) per transac-

tion guarantees timely inclusion in the blockchain, rational computers perform

13

the calculation of calc if and only if:

E(Reward(calc)) > cost(calc) + 2Fee(tx).

(2)

To more accurately describe Reward(calc), we introduce 0 ≤ ω, γ ≤ 1 with

the probability of good computations being rewarded being ω, and the proba-

bility of bad computations being rewarded being γ, such that WLOG ω > γ.

This gives an expected payoﬀ of ωReward(calc) − (cost(calc) + 2Fee(tx)) > 0 for

following the protocol, and an expected payoﬀ of γReward(calc) − 2Fee(tx) for

submitting a result but not performing the computation. Therefore, we require:

ωReward(calc) − cost(calc) − γReward(calc) > 0

(3)

This reduces to Reward(calc) > cost(calc)

ω−γ

. The exact values of ω and γ de-

pend on the computation, number of computers to be rewarded and the chosen

target function. Exact values for ω and γ are diﬃcult to predict a-priori. For

deterministic computations ω ≈ 1, whereas for non-deterministic computations

such as FL, ω will be smaller. Lower-bounding the possible value of ω − γ (al-

though greater than 0) and using this value to compute Reward(calc) ensures

rational players follow the protocol.

Additionally, in a smart-contract blockchain, actions must be triggered by

one or more players by sending transactions to the blockchain. In Marvel DC,

the distribution of rewards is initially controlled by the requester (if the requester

fails to trigger correct reward distribution, computers can eventually initiate the

rewarding mechanism). To ensure a rational requester correctly submits the set

of good computations to be rewarded, any positive escrow amount escrowreq >

Fee(tx) suﬃces to strongly incentivize the requester. This can be seen as the

payoﬀ for submitting the correct set is escrowreq − Fee(tx) > 0, while the payoﬀ

for not submitting the set is 0. However, in the case of potential collusion of

up to k computers, setting escrowreq ≥ k · Reward(calc) + Fee(tx) guarantees

that the requester correctly submits the set of good computations. If k is set

too small by the protocol/smart contract, not submitting the reward set, and

14

rewarding all players may be positive expectancy for the requester. Setting k

equal to ncomp conservatively achieves this. With this lower bound on escrowreq,

rational requesters always submit the correct set of good computations to the

blockchain.

5.2. Reputation Management Protocol

In the previous section, we identiﬁed that all rational players in the sys-

tem follow the protocol given no changes to reputation. However, the use of

a reputation-based selection process prioritizes good computers over bad com-

puters, meaning both short- and long-term beneﬁts for correctly behaving com-

puters. Therefore, using reputation-based computer selection is desirable. In

this section we describe a reputation management protocol that maintains the

incentive compatibility of a DC protocol with an incentive compatible reward

mechanism.

We consider computations for which a rating mechanism rates results as

either “good” or “bad” exists. Correctly performed computations are rated

good with probability ω, while incorrectly computations are rated good with

probability γ. We construct a function from this rating mechanism, rate(),

which assigns good calculations a score of 1, and bad calculations a score of 0.

For a player Pi taking part in computations for calc1, calc2, ..., calck, Pi’s base
reputation is baseRepi = (cid:80)k

j=1 rate(calcj).

Let initRep > 0 be the starting reputation for computers registering in the

system. For a given computation, Pi is selected as computer for a computation in
block at height H in the blockchain in direct proportion to baseRepH−1
1) as a fraction of (cid:80)n
1) from baseRepH−1

j=1 baseRepH−1
to normalize the base reputations for selection probability

− n · (initRep − 1). We subtract (initRep-

(initRep−

j

i

i

purposes, and so there is no beneﬁt for computers rejoining, particularly in the

case where base reputations are increasing over time. With this in mind, the

number of computations a player Pi is selected for is directly proportional to:

probSelectH

i =

baseRepH−1
j=1 baseRepH−1

j

i

(cid:80)n

− (initRep − 1)

− n · (initRep − 1)

.

(4)

15

Consider a player Pi who includes a good computation as block proposer

for a computer. This increases that computers base reputation, and thus that

computers probSelect. This has long-term stake implications, as discussed at

the beginning of Section 5.2. Although the computation result is encrypted,

the expected change in probSelect for an included computer is positive, which

negatively aﬀects the probSelect of the block proposer. Therefore, we need to re-

ward the proposer with an increase in base reputation to counteract the increase

in the computers expected increase in base reputation. Let ErepChange > 0 be

the expected change in base reputation for a computer whose computation gets

included on the blockchain.

For Pi a proposer of a block that includes k transactions containing compu-

tation results, we need the following equality to hold:

baseRepH

i = baseRepH−1

i +

k · ErepChange

(cid:0)

baseRepH−1
j(cid:54)=i baseRepH−1

j

i

(cid:80)

− (initRep − 1)

− (n − 1) · (initRep − 1)

(cid:1).

(5)

This means we need to add k · ErepChange

(cid:0)

baseRepH−1
j(cid:54)=1 baseRepH−1

−(initRep−1)
i
j −(n−1)·(initRep−1)

(cid:1)

(cid:80)

to baseRepH−1

i

in order to ensure the proposer is impartial, with respect to

reputation and computer selection probability, to adding transactions containing

computation results to the blockchain.

For transactions from the requester ﬁnalising the rewards, we simply have

to replace ErepChange with the actual mean change in reputation in Equation 5,

and the rest of the numbers stay the same.

6. Marvel DC

The goal of this section is to take the ideal DC functionality of Section 5, and

implement it as a set of algorithms encoded as smart-contracts that can be run

by a decentralized (without a TTP) set of players with access to a blockchain.

We call this protocol Marvel DC. In Section 5, we identiﬁed values for computer

rewards, reputations changes and computer/requester escrows which ensure the

16

participation of rational players if they can be enforced.

In this section, we

describe how all of these values can be enforced using a blockchain, and as such,

that it is possible to implement the idealized DC protocol in a fully decentralized

manner.

6.1. Algorithmic Overview

We outline the Marvel DC protocol as a set of pseudo-code smart contracts

encodings provided in Algorithms 1 and 2. These contracts are labelled: Regis-

ter, Request, Response and Finalize. A Solidity implementation of Marvel DC

has also been made publicly available on Github [10].

A Marvel DC instance can spawn an indeﬁnite number of computation in-

stances, each initialized by calling the Request contract, and lasting at least

T blocks, where T is the number of blocks required for players to observe an

event on-chain, send a transaction and have that transaction committed on-

chain given at least Fee(tx) is paid. We provide here the intuition to these

encodings, including a graphic representation of the protocol ﬂow in Figure 1.

A privacy-enhancing implementation of Marvel DC is then described in Section

6.3.

Each player Pi owns (has exclusive access to) a set of token balances bali

which are stored as a globally accessible variable on the blockchain. For a token

B, bali(B) is the amount of token B that Pi owns. Players in the underlying

blockchain protocol can enter Marvel DC as computers by calling the Register

contract, which for a given computer deposits an escrow escrowcomp (line 10),

granting that computer a reputation of initRep (line 12).

Computation request instances are initialized by calling the Request con-

tract, which speciﬁes the computation details calc, the number of computers

to be selected for the computation ncomp, a deterministic function fτ for se-

lecting the target result τ from the set of results, the number of computers

to reward nreward, and the per-computer reward Rewardi received by a com-

puter if included in the set of computers to reward. The requester deposits

nreward · Rewardi + escrowreq. The compEncKey is the public key corresponding

17

Figure 1: Marvel DC information and token ﬂow. B : indicates the transfer of tokens.

18

to the temporary public/private key pair (compEncKey, compDecKey). This is

a key pair generated by the requester speciﬁcally for calc. A randomness bea-

con is called (line 16), which provides a pseudo-random seed for selecting ncomp

computers to participate in the computation in direct proportion to computer

reputations (line 5), with these computers listed in the set calc.I.

Computers selected for a particular computation calc, identiﬁed in calc.I,

can then submit results for calc to the blockchain by calling the Response con-

tract for up to T blocks after the computation is requested. These results should

be encrypted using calc.compEncKey (line 3). These encrypted results are de-

crypted in the Finalize phase (line 3) for rewarding purposes. This encryption

ensures no other computer can use another computer’s result, and therefore

must themselves perform the computation. Given a valid response is recorded,

the block producer corresponding to the response is added to calc.proposers (line

25). This is used later to update reputations, in line with the analysis of Section

5.2.

Then, either after T blocks from when the computation calc was requested,

or when all computers in calc.I have responded, the requester of calc can com-

plete the request by calling the Finalize contract. Calling the Finalize contract

requires the requester to provide the decryption key calc.compDecKey corre-

sponding to calc.compEncKey. If these keys match up, the requester receives

back her escrow escrowreq. The contract then uses compDecKey to decrypt the

computer responses, and identify which computers are to be rewarded (line 1).

This is done by applying the pre-speciﬁed target function to the computation

results, and computing a target value τ (line 4). The computers corresponding

to the calc.nreward results closest to τ using Euclidean distance are selected

as the computers to reward, Igood (line 5). The computers in calc.Igood each

receive calc.Rewardi. Finally, all registered computers in calc.proposers receive

reputation increases of avgRepChange (line 12), while computers in calc.Igood

each receive an increase in reputation of 1 (line 16).

19

Algorithm 1 Marvel DC smart contract pseudocode
1: C ← []
2: initRep ← getInitialRep()
3: Reps ← [initRep for i ∈ C]
4: T ← getFinalizeDeadline()
(cid:46) Globally-deﬁned ﬁnalize deadline
5: escrowcomp, escrowreq ← getEscrows() (cid:46) Globally-deﬁned escrow amounts, in line with Section

(cid:46) Set of active computers

5

6: nψ ← getMinNumComputersPerComputation()

(cid:46) Set nψ in-line with requirements from

Section 5

7: tFunctions ← getTargetFunctions() (cid:46) Deﬁne allowable target functions. In reality, this can be

updated during the protocol

8: Register
9: upon (cid:104)REGISTER(cid:105) from P with P /∈ C and P.balance > escrowcomp do (cid:46) add computer to

the system

10:
11:
12:

P.transfer(escrowcomp, contract)
C.append(P)
Reps.append(initRep)

13: Request
14: upon

(cid:46) Registration cost to prevent Sybil attacks

(cid:104)REQUEST, calc, ncomp, nreward, compEncKey, Rewardi, fτ (cid:105) from requester with ncomp >
nψ and requester.balance > ((nreward, ·Rewardi) + escrowreq) and fτ ∈ tFunctions do

requester.transfer((nreward, ·Rewardi) + escrowreq, contract) (cid:46) Transfer total reward plus

requester escrow to contract

(cid:46) Select computers for computation

I ← selectComputers(genRandom(), ncomp)
responses ← []
proposers ← []
start ← Blockchain.height
step ← computing

(cid:46) Array of the players who recorded each (cid:104)RESPONSE, ∗(cid:105) transaction
(cid:46) Record current height of blockchain

15:

16:
17:
18:
19:
20:

21: Response
22: upon tx ← (cid:104)RESPONSE, calc, result(cid:105) from c ∈ I

with calc.step = computing and Blockchain.height < calc.start + T do

calc.responses.append(result) (cid:46) result should be the computer c’s result of computing calc,

encrypted using calc.compEncKey
if tx.blockP roposer ∈ C then

calc.proposers.append(tx.blockP roposer)

23:

24:
25:

26: Finalize
27: upon tx ← (cid:104)FINALIZE, calc, compDecKey(cid:105) from calc.requester

with valid(compDecKey, calc.compEncKey)
and (cid:0)(calc.step = computing and Blockchain.height < calc.start + T
and len(calc.responses) = calc.ncomp) or (calc.step = computing
and Blockchain.height ≥ calc.start + T )(cid:1) do

28:
29:
30:
31:
32:
33:

34:
35:

calc.transfer(escrow, calc.requester)
calc.proposers.append(calc.requester)
if tx.blockP roposer ∈ C then

calc.proposers.append(tx.blockP roposer)

(cid:46) Returns the escrow to the requester
(cid:46) Required for SINCE of requester
(cid:46) Required for SINCE of proposers

calc.step ← ﬁnalized
Igood, Ibad ← rateComputations(calc, calc.nreward, compDecKey, calc.fτ )

(cid:46) Function
which deterministically evaluates the goodness of returned computations, returning the indices
of good and bad computers

calc.transfer(calc.Rewardi, Igood)
updateReputations(Igood, Ibad, calc)

20

Algorithm 2 Computer Selection Protocol
1: function genProbSelect()
2:
minRep ← min(Reps)
denominator ← (cid:80)(Reps) − len(Reps) · (minRep − 1)
3:
return [(cid:0)(i − (minRep − 1))/denominator(cid:1) for i ∈ Reps]
4:

Section 5.2

(cid:46) Probability formula from

ctr ← 0
I ← []
probSelect ← genProbSelect(Reps)
randomSeed ← SHA(randomSeed)
while ctr < ncomp do

5: function selectComputers(randomSeed, ncomp)
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:

i ← 0
sumReps ← probSelect[i]
while randomSeed > sumReps do

if not(i ∈ I) then
I.append(i)
ctr ← ctr + 1

randomSeed ← SHA(randomSeed)

sumReps ← sumReps + (probSelect[i + +] ∗ (2256))

Algorithm 3 Reputation Management
1: function rateComputations(calc, nreward, compDecKey, fτ )
2:
3:
4:
5:
6:

Igood ← []
results ← decrypt(calc.responses, compDecKey)
τ ← fτ (results)
for i ∈ [1, ..., nreward] do

(cid:46) add the nreward closest results to τ to Igood

Igood.append(result.c)andresults.remove(result) withdist(result, τ ) =

min(dist(results, τ ))

Ibad ← results.c (cid:46) all results not already removed in the for loop are bad results, not to be

rewarded

return Igood, Ibad

7:

8:

9: function updateReputations(Igood, Ibad, calc)
10:
11:
12:

avgRepChange ← len(Igood)/(len(Igood) + len(Ibad))
denominator ← (cid:80)(Reps) − (len(Reps) − 1) · (initRep − 1)
for blockP roposer ∈ calc.proposers do (cid:46) in-line with the results from Section 5.2, block

proposers rep. changes should be done before updating computers

13:

14:

15:

Reps[blockP roposer] ← Reps[blockP roposer]+

(avgRepChange · (cid:0)(Reps[blockP roposer]−
(initRep − 1))/(denominator − Reps[blockP roposer])(cid:1))
proposers/requester

(cid:46) Necessary for SINCE of

Reps[calc.requester] ← Reps[calc.requester]+ (avgRepChange · (cid:0)(Reps[blockP roposer]−

(initRep − 1))/(denominator − Reps[blockP roposer])(cid:1))
computation must receive increase in reputation, in line with Section 5.2

(cid:46) Requester of successfully resolved

Reps[tx.blockP roposer] ← Reps[tx.blockP roposer]+

(avgRepChange · (cid:0)(Reps[blockP roposer]−
(initRep − 1))/(denominator − Reps[blockP roposer])(cid:1))
transaction must also receive increase in reputation, in line with Section 5.2

(cid:46) Proposer including the Finalize

16:

Reps[Igood] ← Reps[Igood] + 1

21

Algorithm 4 Marvel DC for player Pi as a Requester
1: function initialize(calc)
2:
3:
4:
5:
6:

compEncKey, compDecKey ← generateKeyPair()
Rewardi ← SINCE reward to guarantee participation of computers
ncomp ← x withx > nψ
fτ getTargetFunction(calc)
broadcast(cid:104)REQUEST, calc, ncomp, nreward, compEncKey, Rewardi, fτ (cid:105)

(cid:46) Select target function for computation

7: upon len(calc.responses) = calc.ncomp or (Blockchain.height = calc.start + FD) do
8:

broadcast(cid:104)FINALIZE, calc, calc.compDecKey(cid:105)

Algorithm 5 Marvel DC for player Pi as a computer
1: broadcast(cid:104)REGISTER(cid:105)
2: upon (cid:104)REQUEST, calc, ncomp, nreward, compEncKey, Rewardi, fτ (cid:105) with i ∈ calc.I do
3:

broadcast(cid:104)RESPONSE, calc, result ← encrypt(compute(calc), calc.compEncKey)(cid:105)

6.2. Protocol Properties

In the following results, we make the assumption that rational requesters

randomly enter the system, running unique instances of the Request contract.

Under this assumption, we ﬁrst show that rational computers and rational re-

questers are strongly incentivized to participate in the protocol.

Theorem 6.1. There is a strict Nash Equilibrium in which, for any compu-
tation with a per player reward Rewardi > cost(calc)

, rational computers and

ω−γ

requesters follow the protocol.

Proof. Consider a Request( requester, ∗) instance corresponding to a computa-

tion calc, and computers selected for computation I. Based on ncomp > nψ, the

majority of computers in I are rational.

First consider a rational requester. Correctly running Finalize (calc, ∗) allows

the requester to receive back calc.escrowreq, and as such, rational requesters

follow the protocol.

Consider now rational computers.

If the requester correctly runs Final-

ize (calc, ∗), then calc.τ and calc.Igood are generated correctly. Therefore, if

all rational computers follow the protocol, the assumption under which we

chose Rewardi in Section 5, for a given rational computer ci correctly running

Repsonse(calc, ∗), ci is included in calc.Igood with probability ω. If ci incor-

rectly runs Response(calc, ∗), ci is included in calc.Igood with probability of at

22

most γ. By our choice of Rewardi, we have seen in Section 5, given calc.Igood is

generated correctly and computers included in calc.Igood receive this with prob-

ability 1, this is suﬃcient for rational computers to compute the result correctly,

equivalent to calling Response(calc, ∗).

Therefore, rational computers and requesters follow the protocol if Rewardi >
(cid:2)

cost(calc)
ω−γ

This result is enough to ensure rational players follow the Marvel DC proto-

col. However, because of the use of the same reputation and computer-selection

mechanism as described in Section 5.2, Marvel DC also guarantees that Byzan-

tine computers are selected with diminishing probability in the number of com-

putations, converging to 0 for any minority of selected computers. This is stated

formally in the following lemma.

Lemma 6.2. For a series of computations [calc1, calc2, ..., calci] with Rewardi >
cost(calc)
ω−γ

and ncomp > nψ, as the number of completed computations increases,

the probability of selecting a Byzantine computer for a computation with ncomp <
|C|
2 is strictly decreasing in expectancy and converging to 0 as i tends to inﬁnity.

Proof. As Rewardi > cost(calc)

ω−γ

, from Theorem 6.1 rational computers follow the

protocol. Let α be the share of computers that are Byzantine. We know a

majority of computers selected are rational, as ncomp > nψ. Therefore, Byzan-

tine computers are rewarded with probability γ < ω. For a given computation,

the expected reputation increase of a selected Byzantine computer is γ, while

the expected increase for a selected rational computer is ω. Given ncomp are

selected for the computation, the expected number of these being rational com-

puters is (1 − α)ncomp, while the number of selected Byzantine computers is

αncomp. Furthermore, this means the expected increase in reputation for ratio-

nal computers is (1 − α)ncompω, while the expected increase in reputation for

Byzantine computers is αncompγ. At the beginning of the protocol, the proba-

bility of selecting a Byzantine player from the set of all computers is in direct

proportion to starting reputation. Given initial reputations of initRep, after the

23

ﬁrst computation, the selection probability of a Byzantine computer reduces in

expectancy to:

|C| · initRep + ncomp

First it be can see that

α(|C| · initRep + ncompγ)

(cid:0)(1 − α)ω + αγ(cid:1) .

α(|C| · initRep + ncompγ)

|C| · initRep + ncomp

(cid:0)(1 − α)ω + αγ(cid:1) < α

(6)

(7)

meaning Byzantine selection probability is decreasing. To prove that Byzantine

selection probability tends to 0 in the number of computations as described in

the Lemma statements, let αk be the Byzantine computer selection probability

after k computations. We have the expected Byzantine selection probability

after k + 1 computations, denoted , αk+1, is:

αk(|C| · initRep + ncompγ)

|C| · initRep + ncomp

(cid:0)(1 − αk)ω + αkγ(cid:1)

=

αk(|C| · initRep + γncomp)
|C| · initRep + ncompω − αkncomp(ω − γ)

.

We have already seen αk+1 equals

αk(|C| · initRep + ncompγ)
|C| · initRep + ncompω − αkncomp(ω − γ)

< αk.

which implies:

(|C| · initRep + ncompγ)
|C| · initRep + ncompω − αkncomp(ω − γ)

< 1.

(8)

(9)

(10)

Letting the term on the left be rk, we can see rk is decreasing in k as:

• ncomp(ω − γ) > 0 (because ω > γ).

• 0 < αk+1 < αk.

These together mean the negative term in the denominator of rk, αkncomp(ω −

γ), is increasing (towards 0) and as such the denominator of rk is increasing.
(cid:2)
Therefore αk < α0rk

0 , with r0 < 1. The result follows.

24

Remark 6.3. Lemma 6.2 depends on the output of the on-chain randomness

oracle being unpredictable when Request is called. Existing solutions, such as

the Chainlink VRF 8, provide proofs that provided randomness was generated

correctly. Analysis of the quality of this randomness is beyond the scope of this

work.

As a direct consequence of Lemma 6.2, with reasonable choices for rewarding

functions and number of computers per-computation (explored in Table 3), both

enforceable by the protocol, Byzantine players are eventually removed from the

system. This improves the eﬃciency of the protocol over time, reducing the

minimum requirements for computers, and as such, latency, transaction fees,

and rewards.

6.3. Privacy Marvel DC

In this section we outline a privacy enhancement to Marvel DC which we

call Privacy Marvel DC. The motivation for this enhancement is to allow for an

additional level of computer privacy which can be seen as necessary in computa-

tions such as those in FL protocols. The privacy provided is based on existing,

well-known ZK techniques. However, this additional privacy on top of the novel

contributions of being strong incentive compatible, generically applicable and

fully decentralized further add to the applicability and utility of our work in an

even larger set of DC problems.

We present Privacy Marvel DC by describing it’s key diﬀerences to Marvel DC

to ensure that in an optimistic scenario, only the requester and computers in-

volved in a computation learn the results, and that players in the system can at

most infer a computer submitted a good result (or bad result), but not which

of the good results (bad results). In the pessimistic scenario, all players in the

blockchain observe the results, but it still holds that any player in the system

can at most infer a computer submitted a good result (or bad result), but not

which of the good results (bad results). In Privacy Marvel DC, there is an addi-

8https://docs.chain.link/docs/chainlink-vrf/

25

tional contract, Reveal, which is to be executed after the Response contract, and

before rewards are ﬁnalized. The purpose of the Reveal contract is described

later in this section.

During computer registration, computers in Privacy Marvel DC privately

generate S1, r1 ∈ {0, 1}O(κ), and attach regID1 ← fcom(S1, r1) to the registra-
tion message, as described in Section 4.2. Then, when a requester requests a

computation, and the indices for computation I are calculated, the requester

now generates a Merkle Tree containing the indices as speciﬁed in I. This

Merkle Tree is the structure to which only selected computers submitting re-

sults can prove membership in ZK. Results are therefore associated to a ZK

set-membership proof which reveals nothing about the player that generated

the proof. In Privacy Marvel DC, this separates result submission and player

identity. To maintain this separation of identity from result, ZK set-membership

proofs are required in the updated Finalize contract, described later in this sec-

tion.

In addition to the deposits of Marvel DC, the requester must also deposit a

pool of money necessary to incentivize relayers (as described in Section 4.3) to

publish transactions on behalf of computers involved in the computation. Given

the amount of money required by one relayer to include a blockchain transaction

is Fee(relay), the additional required deposit is ncomp ·Fee(relay) for the relaying

of computer messages during the Respnse phase.

In the Response contract for Privacy Marvel DC, computers selected in

I privately generate a ZK-proof proving their membership in I. Formally,

given a computation result of result, the computer sets response ← encrypt

(compute(calc) , calc.compEncKey). The computer also generates a new S2,
r2 ∈ {0, 1}O(κ) pair, and computes regID2 ← fcom(S2, r2) . Setting m ←
(cid:104)calc, response, r1, regID2(cid:105), the computer generates a NIZKSoK π1 ← NIZK-

SoK [m]{(regID1, r1) : MemVerify (I, regID1) = 1 & regID1 = fcom( S1, r1) }.

Finally, the computer then publishes m and π1 to the blockchain through a re-

layer, who receives Fee(relay) upon the transactions addition to the blockchain.

In the Reveal contract, the requester oﬀ-chain performs the same calculations

26

that were done on-chain in Marvel DC to calculate the results to be rewarded,

but instead of adding computer indices to responsesgood, the requester adds the

corresponding regID2s. The requester publishes responsesgood and the encryp-

tion of calc.compDecKey using each public key corresponding to computers in

calc.I to the blockchain. However, rewards are not immediately distributed to

computers in responsesgood.

In the Finalize contract, computers now have a chance to contest the com-

putation of responsesgood for up to T blocks after the Reveal contract is called.

If responsesgood was computed incorrectly, any of the computers in calc.I can

publish the decryption of all results and pass them into the rateComputations

function of Marvel DC, proving the incorrect computation of responsesgood by

the requester. In this case, all computers are rewarded, and the requesters es-

crow is destroyed. To prevent malicious computers in calc.I from attempting

this proof in order to reveal computation results, a further escrow is required,

which is returned on the correct proving of miscomputation of responsesgood by

the requester.

If instead responsesgood was computed correctly, any computer whose regID2

is included in responsesgood can generate a proof of membership to responsesgood.

Furthermore, as regID1 can no longer be used for future computations (using the

same regID1 would reveal the same r1 in the next calc), the computer generates
a new S3, r3 ∈ {0, 1}O(κ) pair and corresponding regID3 ← fcom(S3, r3). Setting
m ← (cid:104)calc, f alse, regID3(cid:105), the computer with regID2 in responsesgood then gen-

erates a NIZKSoK π2 ← NIZKSoK [m]{(regID2, r2) : MemVerify (responsesgood,

regID2) = 1 & regID2 = fcom( S2, r2) }. Finally, the computer publishes m and

π2 to the blockchain. In this variation of the protocol, computers not included

in responsesgood must also respond, updating there regID1. If this is not done,

computers forfeit escrowcomp and any reputation earned.

Observation 6.4. As computers submit results through a relayer, and with an

accompanying NIZKSoK π proving membership in the selected indices for com-

putation, all players in the blockchain protocol can be sure the player submitting

27

the message must be a selected computer, but nothing else can be learned about

the submitting player’s identity. Similarly, when collecting rewards, or replacing

regID1, the only thing learned when a computer submits a valid message during

the Finalize phase is to which set, responsesgood or responses\responsesgood, the

computer belongs.

6.4. Further Privacy Enhancements

There are further privacy enhancements possible for Marvel DC. One such

enhancement is to detach reward collection/reputation updates from the com-

putation. Given responsesgood was calculated correctly, computers included in

responsesgood can instead delay their claiming of the reward and associated rep-

utation increase arbitrarily. After a Finalize phase without arbitration, the

set of regID2s corresponding to responsesgood can be added to a pool of all

recorded good responses throughout the protocol. These can then be immedi-

ately/periodically/sporadically claimed by computers, depending on the privacy

requirements of the computer in question. This again uses the same NIZK set-

membership techniques, except now with a larger set in which to diﬀuse.

7. Implementation Analysis

In this section we analyse Marvel DC and Privacy Marvel DC as described

in Sections 6 and 6.3. We show that on top of the unique formal guarantees

of Section 6.2, both protocols are cost-eﬀective and practical for both comput-

ers and requesters. Our reputation and computer selection mechanisms perform

analogously to those graphed in [8]. Crucially however, our protocols are proven

to be strong incentive compatible in a fully decentralized setting, where com-

puters an requesters have asymmetric utilities. The encoding of Marvel DC is

available here [10].

28

7.1. Gas cost of running Marvel DC and Privacy Marvel DC

Setup()

Marvel DC
2,000,000

Register()

80,000

Request()

500,000 + ncomp · 31,000 + 0.25 LINK††

Response()

Reveal()

Finalize()

60,000

N/A

-

Privacy Marvel DC
2,450,000 + hψ · 150, 000†

82,000

500,000 + ncomp · 31,000
+ ncomp · hψ · 51, 000††† + 0.25 LINK††

63,000 +300, 000††††
80,000 +nreward · hψ · 51, 000†††

-

-No Arbitration

80,000 +nreward · 14,000

(results not revealed) 83,000 + 300, 000††††

-Arbitration

N/A

80,000 +ncomp · 14,000

Table 2: Gas costs of each contract call in Marvel DC and Privacy Marvel DC. †Cost of
accessing Chainlink randomness. ††Cost to generate a once-oﬀ Merkle Tree which can be
reused for all computations. ††† Cost to insert computer into copy of Merkle Tree. †††† Cost
to verify proof of membership on-chain.

There are several considerations when calculating the cost of running Mar-

vel DC on a blockchain. In the case where a computation has a single 32 byte

answer, the costs are signiﬁcantly less than in the case of gradient estimation

problem where answers contain thousands or millions of numbers. More con-

cerning still is the prohibitive nature of messages in the order of MBs in many

blockchain protocols. To counteract this, messages for the Response and Final-

ize contracts can be submitted to memory-eﬃcient alternatives such as IPFS9,

Layer-2 chains or even through an MPC protocol between computers and re-

questers (not necessarily the same entities involved in the computation). All

of these suggestions require the use of checkpoints (such as those proposed in

[6]), pieces of summary information identifying permanent states in an oﬀ-chain

protocol which are published to the main-chain, updating the state of the main-

chain.

In Table 2 we present the approximate gas costs for Marvel DC and Privacy

Marvel DC on an Ethereum-compatible blockchain of the main operations for

a requester and computers in a computation, given ncomp and a 256-bit result,

with all messages published on-chain. This can be extended to l-dimensional

9https://ipfs.io/

29

results for any l > 1. The set-membership tools described in Privacy Marvel DC

are pre-compiled, and currently being used in the Tornado Cash privacy pro-

tocol. We thus calculate the gas cost of the set-membership tools using the

Tornado Cash library. All other operations are typical on-chain array manipu-

lation, encryption/decryption, deposit, withdraw and writing to memory oper-

ations. We also include the cost of calling an on-chain randomness oracle in our

calculation. This call needs to be made prior to the calculation of the indices for

computation, and must be made when depositing rewards and escrow to ensure

the requester cannot manipulate the selection of computers. To approximate

the costs of running Privacy Marvel DC described in Section 6.3, we utilize nψ

the maximum number of computers required to select in order to guarantee a

majority are rational. We let hψ = (cid:100)log2(nψ)(cid:101) + 1. This is the required height

of the Merkle Tree to be used in the ZK-proofs for set-membership.

As an example, using current gas costs of 32 GWEI/gas and 1 GWEI =

$0.00000335 10, for nψ = 10, and a computation with ncomp = 10, for the basic

protocol, this is a per computer cost of 140,000 gas, or $15, while a requesters

cost is 950,000 gas, or $102 + $4.5 for the LINK11 required to access the on-

chain randomness 12. Deploying on a cheaper protocol like Harmony with gas

costs of $0.00000005 at the time of writing 13, this is an approximate cost of

$0.001 and $4.505 respectively.

For Privacy Marvel DC on Harmony with nreward = 5, this gives hψ = 4,

and a gas cost of 950,000+ 2,040,000 for requesting, and 80,000+1,020,000 for

revealing rewards, a total of 4,190,000 gas ($0.02), plus the cost for accessing

on-chain randomness ($4.5), a total cost for the requester of $4.52 . For com-

puters, the cost is 746,000 gas ($0.004) in the optimistic execution, and 503,000

($0.0026) in the pessimistic, but only for one computer. This means both im-

plementations of Marvel DC are suitable for immediate deployment on public

10https://etherscan.io/gastracker, Accessed: 03/04/2022
11https://docs.chain.link/docs/vrf-contracts, Accessed:03/04/2022
12https://www.coingecko.com/en/coins/chainlink, Accessed:03/04/2022
13https://explorer.harmony.one/, Accessed: 03/04/2022

30

blockchains.

7.2. Latency and Throughput

A direct comparison of our protocol to most existing distributed FL solutions

with respect to throughput and latency is of limited beneﬁt. This is because

the the concept of time in decentralized systems (blocks in a blockchain) has

no immediate parallel when centralized parties are required, as in [16, 1, 20, 19,

13, 27, 26].

Considering the protocols which allow for tokenized rewards in a decentral-

ized setting (protocols which do not allow for tokenized rewarding have limited

utility in a decentralized setting), this leaves only [25] and [24]. Using the ter-

minology of our paper, every protocol phase, a period of time where an event

occurs which requires a response, lasts up to T blocks. These T blocks (as

used in Section 6.1) are equivalent to the time required to ensure players can

submit transactions to the blockchain after a particular on-chain event, such

as a computation request. Marvel DC therefore lasts up to 2T blocks, which

covers the time for computers to respond to a request, and the time taken for

the requester to reveal the decryption key. The protocol of [25] lasts at least 4T

blocks to ensure workers are incentivized to submit at least one correct model

update (using the terminology of [25], 2 model update rounds are needed for

this to be the case). The additional costs are due to requesters and computers

being required to respond twice each after the initial request. The protocol of

[24] requires at least 3T blocks, as computers must commit to the data-set to

be used, before submitting a computation result. All 3 protocols, including our

own, are equipped to spawn arbitrarily many computations in parallel.

31

7.3. Necessary bounds on the number of computers per-computation

ncomp =10

25

50

100

250

500

1000

α = 0.45

0.504

0.694

0.716

0.817

0.936

0.986

0.999

0.4

0.33

0.25

0.2

0.1

0.05

0.01

0.633

0.846

0.902

0.973

0.999

0.787

0.958

0.989

0.922

0.997

0.967

0.998

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

Table 3: The approximate probability, correct to 3 decimal places, of choosing a majority of
rational computers given speciﬁc starting adversarial % of computers α (left column) and se-
lected numbers of computers ncomp (top row) from a suﬃciently large population of computers
such that adversarial share represents the per-selection probability of selecting an adversarial
computer throughout sampling.

To estimate the required value of nψ required to ensure a suﬃciently prob-

ably majority of rational players, Table 3 serves as a starting point. We rec-

ommend conservative choices of adversarial share and probability of rational

majority. For example, given an adversarial share of 20% of computers, any

value of nψ ≥ 25 suﬃces to ensure a majority of rational computers are chosen

per-computation.

8. Conclusion

We present Marvel DC, a strong incentive compatible blockchain-based de-

centralized DC protocol which stands as a new standard in constructing fully

decentralized DC protocols. This is achieved through a novel combination of

strong incentivisation of rational computers in the presence of Byzantine com-

puters, reputation-aware computer selection and privacy-enhancing techniques

which can be bootstrapped to the core Marvel DC protocol to allow for the

use of Marvel DC on computations revealing sensitive data about the comput-

ers participating in the protocol. Much work remains to ensure DC protocols

remain incentive compatible and practical where computations produce large

32

outputs, with storage being a limiting resources in mainstream blockchain pro-

tocols. Marvel DC and Privacy Marvel DC serve as key protocols with which

to continue this research.

Declaration of Competing Interest

The authors declare that they have no known competing ﬁnancial interests or

personal relationships that could have appeared to inﬂuence the work reported

in this paper.

Acknowledgements

We thank IEEE Fellow Josep Domingo-Ferrer and his group at Universitat

Rovira i Vigili for many interesting and motivating conversations related to this

paper.

Vitaes

Conor McMenamin

Conor is a Marie Curie Fellow, working as researcher at Nokia-Bell Labs

undertaking a PhD in Universitat Pompeu Fabra (UPF). He holds a Bachelor

of Science degree in Computational Thinking (2015), and a Master of Science

degree in Cryptography (2019). His research focuses on the game-theoretic

aspects of blockchain technology, both at the consensus and the application

layer.

33

Vanesa Daza

Vanesa is an Associate Professor at UPF. She holds a degree and a PhD

in Mathematics. Her research now focuses on designing cryptographic primi-

tives and protocols to undertake security and privacy challenges on blockchain

technologies. She has co-authored over 40 papers and is the co-inventor of two

international patents. She has served as Associate Editor for two IEEE Transac-

tions journals, several Program Committees and reviewer of international jour-

nals. She currently coordinates two H2020 projects and collaborates with several

companies. Likewise, she has served at UPF in several roles, including chairing

the Department of Information and Communication Technologies.

References

[1] Xianglin Bao, Cheng Su, Yan Xiong, Wenchao Huang, and Yifei Hu.

FLChain: A blockchain for auditable federated learning with trust and

incentive. In 2019 5th International Conference on Big Data Computing

and Communications (BIGCOM), pages 151–159, 2019.

[2] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian

Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anony-

mous payments from Bitcoin. In 2014 IEEE Symposium on Security and

Privacy, pages 459–474, 2014.

[3] Daniel Benarroch, Matteo Campanelli, Dario Fiore, Kobi Gurkan, and

Dimitris Kolonelos. Zero-knowledge proofs for set membership: Eﬃcient,

succinct, modular. In Nikita Borisov and Claudia Diaz, editors, Financial

Cryptography and Data Security, pages 393–414, Berlin, Heidelberg, 2021.

Springer Berlin Heidelberg.

34

[4] Peva Blanchard, El Mahdi El Mhamdi, Rachid Guerraoui, and Julien

Stainer. Machine learning with adversaries: Byzantine tolerant gradient

descent.

In Proceedings of the 31st International Conference on Neural

Information Processing Systems, NIPS’17, page 118–128, Red Hook, NY,

USA, 2017. Curran Associates Inc.

[5] Vincenzo Botta, Daniele Friolo, Daniele Venturi, and Ivan Visconti.

Shielded computations in smart contracts overcoming forks.

In Nikita

Borisov and Claudia D´ıaz, editors, Financial Cryptography and Data Secu-

rity, pages 73–92, Berlin, Heidelberg, 2021. Springer Berlin Heidelberg.

[6] Vitalik Buterin and Virgil Griﬃth. Casper the friendly ﬁnality gadget.

https://arxiv.org/pdf/1710.09437, 2017. Retrieved: 19/04/2022.

[7] Josep Domingo-Ferrer, Oriol Farr`as, Sergio Mart´ınez, David S´anchez, and

Jordi Soria-Comas. Self-enforcing protocols via co-utile reputation man-

agement. Information Sciences, 367-368:159–175, 2016.

[8] Josep Domingo-Ferrer, David S´anchez, Alberto Blanco-Justicia, and Na-

jeeb Jebreel. Co-utile peer-to-peer decentralized computing.

In 2020

20th IEEE/ACM International Symposium on Cluster, Cloud and Inter-

net Computing (CCGRID), pages 31–40, 2020.

[9] Lisa Eckey, Sebastian Faust, and Benjamin Schlosser. Optiswap: Fast

optimistic fair exchange. In Proceedings of the 15th ACM Asia Conference

on Computer and Communications Security, ASIA CCS ’20, page 543–557,

New York, NY, USA, 2020. Association for Computing Machinery.

[10] Github. https://github.com/The-CTra1n/MarvelDC, 2022.

[11] Jens Groth. On the size of pairing-based non-interactive arguments.

In

Marc Fischlin and Jean-S´ebastien Coron, editors, Advances in Cryptology

– EUROCRYPT 2016, pages 305–326, Berlin, Heidelberg, 2016. Springer

Berlin Heidelberg.

35

[12] Kobi Gurkan, Koh Wei Jie,

and Barry Whitehat.

Commu-

nity proposal:

Semaphore:

Zero-knowledge signaling on Ethereum.

https://github.com/appliedzkp/semaphore, 2020. Retrieved: 19/04/2022.

[13] Hyesung Kim, Jihong Park, Mehdi Bennis, and Seong-Lyun Kim.

Blockchained on-device federated learning. IEEE Communications Letters,

24(6):1279–1283, 2020.

[14] Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos

Papamanthou. Hawk: The blockchain model of cryptography and privacy-

preserving smart contracts.

In 2016 IEEE Symposium on Security and

Privacy (SP), pages 839–858, 2016.

[15] Harry C. Li, Allen Clement, Edmund L. Wong, Jeﬀ Napper, Indrajit Roy,

Lorenzo Alvisi, and Michael Dahlin. Bar gossip. In Proceedings of the 7th

Symposium on Operating Systems Design and Implementation, OSDI ’06,

page 191–204, USA, 2006. USENIX Association.

[16] Yuzheng Li, Chuan Chen, Nan Liu, Huawei Huang, Zibin Zheng, and Qiang

Yan. A blockchain-based decentralized federated learning framework with

committee consensus. IEEE Network, 35(1):234–241, 2021.

[17] Chao Lin, Debiao He, Xinyi Huang, and Kim-Kwang Raymond Choo.

OBFP: Optimized blockchain-based fair payment for outsourcing compu-

tations in cloud computing. IEEE Transactions on Information Forensics

and Security, 16:3241–3253, 2021.

[18] Ziyao Liu, Jiale Guo, Wenzhuo Yang, Jiani Fan, Kwok-Yan Lam, and

Jun Zhao. Privacy-preserving aggregation in federated learning: A sur-

vey. https://arxiv.org/abs/2203.17005, 2022. Retrieved: 30/06/2022.

[19] Chuan Ma, Jun Li, Ming Ding, Long Shi, Taotao Wang, Zhu Han, and

H. Vincent Poor. When federated learning meets blockchain: A new dis-

tributed learning paradigm. https://arxiv.org/abs/2009.09338, 2020.

Retrieved: 30/06/2022.

36

[20] Umer Majeed and Choong Seon Hong. FLchain: Federated learning via

mec-enabled blockchain network. In 2019 20th Asia-Paciﬁc Network Op-

erations and Management Symposium (APNOMS), pages 1–4, 2019.

[21] Conor McMenamin, Vanesa Daza, and Matteo Pontecorvi. Achieving state

machine replication without honest players. In Proceedings of the 3rd ACM

Conference on Advances in Financial Technologies, page 1–14, New York,

NY, USA, 2021. Association for Computing Machinery.

[22] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zero-

coin: Anonymous distributed e-cash from Bitcoin. In 2013 IEEE Sympo-

sium on Security and Privacy, pages 397–411, 2013.

[23] Torben P. Pedersen. Non-interactive and information-theoretic secure veri-

ﬁable secret sharing. In Proceedings of the 11th Annual International Cryp-

tology Conference on Advances in Cryptology, CRYPTO ’91, page 129–140,

Berlin, Heidelberg, 1991. Springer-Verlag.

[24] Timon R¨uckel, Johannes Sedlmeir, and Peter Hofmann. Fairness, integrity,

and privacy in a scalable blockchain-based federated learning system. Com-

put. Netw., 202(C), jan 2022.

[25] Kentaroh Toyoda and Allan N. Zhang. Mechanism design for an incentive-

aware blockchain-enabled federated learning platform. In 2019 IEEE In-

ternational Conference on Big Data (Big Data), pages 395–403, 2019.

[26] Muhammad Habib ur Rehman, Khaled Salah, Ernesto Damiani, and Davor

Svetinovic. Towards blockchain-based reputation-aware federated learning.

In IEEE INFOCOM 2020 - IEEE Conference on Computer Communica-

tions Workshops (INFOCOM WKSHPS), pages 183–188, 2020.

[27] Jiasi Weng, Jian Weng, Jilian Zhang, Ming Li, Yue Zhang, and Weiqi

Luo. Deepchain: Auditable and privacy-preserving deep learning with

blockchain-based incentive. IEEE Transactions on Dependable and Secure

Computing, 18(5):2438–2455, 2021.

37

[28] Yinghui Zhang, Robert H. Deng, Ximeng Liu, and Dong Zheng. Blockchain

based eﬃcient and robust fair payment for outsourcing services in cloud

computing. Information Sciences, 462:262–277, 2018.

38

