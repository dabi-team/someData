Understanding blockchain: deﬁnitions, architecture,
design, and system comparison

Mohammad Hossein Tabatabaei
Department of Informatics
University of Oslo
mohammht@iﬁ.uio.no

Roman Vitenberg
Department of Informatics
University of Oslo
romanvi@iﬁ.uio.no

Narasimha Raghavan Veeraragavan
Department of Informatics
University of Oslo
raghavan@iﬁ.uio.no

2
2
0
2

l
u
J

5

]
I

N
.
s
c
[

1
v
4
6
2
2
0
.
7
0
2
2
:
v
i
X
r
a

Abstract—The explosive advent of the blockchain technology
has led to hundreds of blockchain systems in the industry,
thousands of academic papers published over the last few years,
and an even larger number of new initiatives and projects.
Despite the emerging consolidation efforts, the area remains
highly turbulent without systematization, educational materials,
or cross-system comparative analysis.

In this paper, we provide a systematic and comprehensive
study of four popular yet widely different blockchain systems:
Bitcoin, Ethereum, Hyperledger Fabric, and IOTA. The study
is presented as a cross-system comparison, which is organized
by clearly identiﬁed aspects: deﬁnitions, node roles, entities,
and the characteristics and design of each of the commonly
used layers in the cross-system blockchain architecture. Our
exploration goes deeper compared to what is currently available
in academic surveys and tutorials. For example, we provide the
ﬁrst extensive coverage of the storage layer in Ethereum and
the most comprehensive explanation of the consensus protocol in
IOTA. The exposition is due to the consolidation of fragmented
information gathered from white and yellow papers, academic
publications, blogs, developer documentation, communication
with the developers, as well as additional analysis gleaned from
the source code. We hope that this survey will help the readers
gain in-depth understanding of the design principles behind
blockchain systems and contribute towards systematization of
the area.

Index Terms—Blockchain system, Distributed ledger technol-

ogy, Bitcoin, Ethereum, Hyperledger Fabric, IOTA

I. INTRODUCTION

Since Bitcoin inception and deployment back in 2009, it
has been creating waves of discussions and debates about
its success as the ﬁrst widely popular cryptocurrency effort.
Bitcoin did away with a broker entity and showed that it
is fundamentally possible to have a working cooperative
economic model in practice where the technology does all
the mediation.

In 2014–2016, there occurred an explosive extension in
the range of applications, with everybody talking about the
Blockchain Paradigm underlying the technology that enables
cooperative economic models and cooperative storage and
management of agreements. According to [1],
the annual
revenue of blockchain-based enterprise applications worldwide
will reach $19.9 billion by 2025, up from about $2.5 billion
in 2016.

energy markets based on microgrids are viewing blockchain as
a major technological enabler [3]. Blockchain is becoming a
common element in solutions for decentralized digital identity
(DID) [4], certiﬁcate storage [5],
land registries [6], and
supply chains [7]. Microsoft declares “blockchain” as one of
the key “must win” technologies for their Azure platform
and business [8]. Similarly, IBM unveils a new ambitious
blockchain service and strategy [9]. A long row of major
enterprises such as Accenture, Cisco, Citibank, Facebook,
Disney Studios, Goldman Sachs, and HSBC have publicly
declared their investment in the technology with the intent
of exploring the potential for exploitation, which has resulted
in an establishment of industrial blockchain associations such
as Diem [10]. Governments in North America, Europe, and
Asia are advancing blockchain-related strategy and legislation,
reﬂecting their signiﬁcant
towards the advent and
interest
utilization of the technology [11], [12], [13], [14], [15], [16].
Blockchain has become one of the hottest topics at many
societal, industrial, and academic conferences.

The above has resulted in hundreds of blockchain systems
in the industry, thousands of academic papers published over
the last few years, and an even larger number of new initiatives
and projects. Following this explosive development, the area
currently remains tumultuous, without commonly accepted
terminology and with occasionally diverging concepts and
ideas. For example, we list ﬁve different deﬁnitions of the term
”blockchain” in Section II-A, all being used in the literature
and in description of actual systems.

Emerging surveys such as [17] and [18] among all have
made an important ﬁrst step towards orderly understanding of
the area. However, most of the published surveys are focusing
on one system (such as Bitcoin [19], [20]), a particular class of
blockchain (e.g., DAG-based [21]), or an individual aspect of
blockchain (such as proof-of-X or defense mechanisms against
security attacks of a speciﬁc type). In-depth comparisons
across systems of different type are exceedingly rare, and so
are standardization initiatives or attempts to establish general
taxonomies. Thus, despite the consolidation efforts, the area
remains highly turbulent without systematization. Accordingly,
there are no textbooks or comprehensive educational materials,
except for Bitcoin itself [22].

Declared intention of future use of blockchain in cooperative
healthcare provision is making global news [2]. Cooperative

Today, the only way to gain in-depth technical understand-
ing of the design behind almost any blockchain system is to

 
 
 
 
 
 
read typically outdated white and yellow papers followed by
perusing the continuously updated technical documentation,
followed by scanning hundreds of blog posts by the developers
and conﬂicting forum posts by the users and ﬁnally, by
studying the source code.

A. Contributions

Our main contribution is the ﬁrst systematic and compre-
hensive comparative study of blockchain design across differ-
ent systems. While many existing works provide a focused
cross-system comparison on a particular aspect, we aim to
provide a comparative design insight that goes far beyond
the information that is currently available in the literature.
The comparison is performed across four blockchain systems
representative of different blockchain strands (i.e., Bitcoin,
Ethereum, Hyperledger Fabric, and IOTA) with divergence in
the design priorities, architectural elements, performance, and
even node roles and basic deﬁnitions. While IOTA is not as
popular as the other three, it is the most commonly used DAG-
based system and it was ranked at the fourth place [23] by the
market cap in 2017.

First, we present generic node roles in blockchain along
with the signiﬁcance of each role and explain how the entities
(i.e., nodes of different categories) in a blockchain system of
each type map to these roles. We introduce a generic layered
architecture that applies to all blockchain systems regardless
of the type. The study of the four systems is organized across
these layers so that the design of each layer is considered sep-
arately from the rest. This methodology allows us to conduct
a comprehensive cross-system comparison. The comparison
is organized by clearly identiﬁed aspects: deﬁnitions, roles,
entities, and the characteristics and design of each of the
layers. We also contrast the performance of the four systems
based on the previously published information and explain the
reasons for the differences.

Our exploration goes deeper compared to what is currently
available in academic surveys and tutorials. For example,
we provide the ﬁrst extensive coverage of the storage layer
in Ethereum and the most comprehensive explanation of
the consensus protocol in IOTA. The exposition is due to
the consolidation of fragmented information about popular
systems from blogs, developer documentation, and studying
the source code.

Our main emphasis is on the education and pedagogical
exposition that lends itself to courses and tutorials. While such
descriptions exist for Bitcoin, no such materials are available
for Ethereum and IOTA to the best of our knowledge. A
more ﬁne-grained summary of our contribution along with the
comparison with existing surveys is available in Section V.

Our study focuses on the design of the systems themselves
rather than on application mechanisms developed atop them.
In particular, we do not cover hybrid storage systems that
combine on-chain and off-chain elements. Besides, the scope
does not include functional features such as sharding that are
still in development and that are not supported by the current
versions of the blockchain systems.

B. Roadmap

In Section II, we ﬁrst contrast various blockchain deﬁni-
tions and reﬂect on the discrepancies in the commonly used
terminology. Then, we introduce a list of node roles and a
layered blockchain architecture that are both applicable to all
blockchain systems regardless of the type. In Section III, we
present an overview of the four systems, discuss the entities
in each, and explain how they map to the generic roles. In
Section IV, we provide a layer-by-layer comparison between
the four systems while covering a variety of design aspects and
characteristics. In Section V, we contrast our work with other
state-of-the-art surveys. Finally, we present our conclusions in
Section VI.

II. UNDERSTANDING BLOCKCHAIN: DEFINITIONS AND
CONCEPTS

A. Reﬂection on Various Blockchain Deﬁnitions

The term of “blockchain” generally refers to a paradigm
for maintaining information in a distributed system that is
characterized by a number of properties. Since there is no
speciﬁcation or established standards in 2022 yet, different
concretizations of this general deﬁnition have been adopted in
the literature and existing popular blockchain-based systems.
Distributed Ledger Technologies (DLTs, in short) is a well-
deﬁned term: it refers to a system that records a ledger of
transactions or a history of changes to the system state. The
ledger is usually hard to tamper with, which is a boon for
security yet it also makes it hard to perform desirable changes,
e.g., to prune the history or compact the ledger.

While people tend to equate blockchain with DLTs, both
narrower and broader meanings of “blockchain” are in use.
Literally, blockchain means “a chain of blocks”, which implies
a speciﬁc data structure for the ledger implementation. A chain
of blocks precludes any parallelism between the transactions,
however, which has a negative impact on the performance.
Some ledger implementations use more a complex data struc-
ture such as braids [24] or a directed acyclic graph (DAG) in
IOTA, which allow some degree of parallelism by retaining
concurrently proposed competing blocks and merging them.
imply any speciﬁc data
Since the term of DLT does not
structure, it covers such a generalization. On the other hand,
the term of “blockchain” becomes a misnomer in that case.
In absence of more reﬁned terminology today, “blockchain” is
used in the literature to refer to a chain of blocks or generalized
DLTs.

To add to the confusion, some systems in this domain
do not maintain a distributed ledger at all. For example,
Corda [25] allows participating nodes to agree upon and main-
tain shared knowledge in a non-trusted environment typical for
blockchain. However, each piece of information is only shared
within a subset of nodes to which the information pertains. Yet,
the term of “blockchain” is sometimes used to collectively
refer to all systems in the domain including Corda.

We have been able to identify the following deﬁnitions in

the literature:

Deﬁnition 1: Blockchain is a system that uses the data
structure of Bitcoin but extends the functionality. This deﬁ-
nition is used by, e.g., Bitcoin spawn-offs that were created
either due to hard forks or as an extension of the limited
scripting functionality of Bitcoin. This deﬁnition is not limited,
however, just to cryptocurrency systems; it can be utilized for a
large spectrum of business logic by customizing the blockchain
modules and protocols.

Deﬁnition 2: Blockchain is a system that maintains a chain
of blocks. This deﬁnition does not specify details of the data
structure used for each block. For example, Ethereum and
Hyperledger match this deﬁnition.

Deﬁnition 3: Blockchain is a system that maintains a
ledger of all transactions. The ledger does not need to be
stored as a chain of blocks, however. IOTA is an example of
a system that follows this deﬁnition.

Deﬁnition 4: Blockchain is a system with distributed non-
trusting parties collaborating without a trusted intermediary.
This deﬁnition rather refers to the main beneﬁcial property of
the paradigm. It was originally advocated by Corda [25].

Deﬁnition 5: Blockchain is a system that provides support
for smart contracts. Many popular articles regard blockchain
as a way of replacing paper-based contracts and human
intermediaries with smart contracts, without considering how
such contracts are implemented.

The ﬁrst three deﬁnitions above are sorted by generality,
from the most concrete to the most general. While they refer
to the way the system is built, the last two deﬁnitions are about
the way the system is used.

In the absence of proper deﬁnition, a blockchain is some-
times compared to a distributed database. It is important to
observe that a blockchain differs from a database in two
fundamental ways. First, a database is an organized collec-
tion of data representing the current system state. The main
functionality of a database is to allow efﬁcient data retrieval,
fusion, and aggregation triggered by user queries. In contrast,
most blockchain implementations represent a ledger in which
a history of transactions (or, more generally, of changes to
the system state) is recorded. For example, there is simply no
concept of a user balance in Bitcoin! While Ethereum keeps
track of a contract state, it only provides limited means to
retrieve and process state data, as explicitly deﬁned by the
contract. It does not support abstractions of a ﬂexible query
language, data view, schema, join, etc. Besides, Ethereum
records a history of all changes to the state, which results in
blockchain space being more expensive and the storage less
efﬁcient compared to a database. As a result, only speciﬁc data
elements (such as short transactions or indices) are stored on
a blockchain. Many blockchain systems combine blockchain
with offchain storage (databases or dedicated ﬁle systems).

Secondly, the trust model is radically different as observed
in [25]. The database servers typically trust each other, even
in federated databases, in the sense that they do not expect
attacks from within the system. The main security focus is on
making it difﬁcult to compromise a server in the ﬁrst place. To
this end, database systems defend against malicious clients by

using ﬁrewalls, strict access control, and many other methods.
The situation is fundamentally different
in the blockchain
environment: the interests of participating nodes are inherently
misaligned so that they need to verify information received
from each other and run a consensus to agree on changes to
the data. While being able to agree on changes and progress in
absence of a trusted administrator is a powerful abstraction,
it bears a cost tag in terms of performance. If there are no
misaligned interests between the participants and attacks from
within the system are unlikely, there is little point in using
blockchain technologies.

B. Blockchain types

The two most important characterizations are the constraints
on which participants are allowed to propose updates to
blockchain data and which participants are allowed to read
blockchain data. In Bitcoin, any node may propose updates
to the ledger or read it. This is also the case for the public
deployments of Ethereum and IOTA. In Hyperledger Fabric,
only authorized nodes are allowed either. However, mixed
models are also possible: In Ripple, every node has read access
while only authorized nodes can propose updates. We call
these characterizations update-access-restricted and query-
access-restricted, respectively. We refer to a system that is
update-access-restricted or query-access-restricted as access-
restricted. Obviously, systems that are access-restricted require
node authorization.

Usually, the identities are also handled differently in systems
that are access-restricted. Namely, such systems typically use
real node identities while systems that are not access-restricted
commonly use public keys for identiﬁcation. In principle,
however, systems that are not access-restricted can still use
real identities, if such identities can be veriﬁed and if the
transparency of participation is more important than privacy.
It is also not unimaginable for access-restricted systems to
employ public keys or pseudonyms, though it may require
the authorization or authentication component to operate un-
der different trust and security assumptions compared to the
blockchain system itself.
There exists another

related dimension for classifying
blockchain systems, namely decentralization. Large-scale de-
centralized blockchain systems, such as Bitcoin, Ethereum,
and IOTA, may have up to millions of participating nodes
without any managed system structure, node organization,
or network connections. On the other hand, consortium
blockchain systems such as Hyperledger Fabric are smaller
proprietary deployments where the consortium may decide to
partially manage all of the above. We observe, however, that
even consortium blockchain does not lend itself to complete
management. In other words, all blockchain systems are self-
organizing, though the extent of self-organization varies across
the systems. The scale and extent of management signiﬁcantly
affects design priorities and implementation components as
we explain in the rest of this survey. Consortium systems are
access-restricted by nature. Large-scale decentralized systems

Figure 1. Roles of the participating nodes and the relations between these roles

are not query-access-restricted, though they may be update-
access-restricted.

Unfortunately, the above complexity is not reﬂected in the
currently existing terminology. All blockchain systems are
coarsely divided into two categories in the existing literature.
The ﬁrst category is referred to as public or open or permis-
sionless while the second category is called private or closed
or permissioned. The exact meaning of these six terms and
differences between them are not precisely deﬁned to the best
of our knowledge.

C. Participants and their Roles

Since the models and implementations signiﬁcantly differ
in various blockchain systems, we need to identify com-
mon fundamental elements in order to perform a systematic
comparison. Two such unifying elements are the roles of
participating nodes and the conceptual layered architecture.
We discuss these two elements in Sections II-C and II-D,
respectively. They apply to all blockchain systems studied in
the rest of the paper, and they will likely generalize to many
other blockchain approaches as well.

As commonly accepted in descriptions of distributed archi-
tectures, node roles refer to the functional responsibilities. The
same entity may play a single or multiple roles in the system.
The roles in a blockchain system are presented in Figure 1.

Creators of Transactions: Different entities implement-
ing a blockchain application can create transactions and inject
them into the system by broadcasting a transaction onto the
network.

Proposers and Acceptors: A central functionality of a
blockchain system is to validate injected transactions and
decide which transactions will be appended to the blockchain
and in what order. This is the main responsibility of nodes
acting as acceptors. To this end, they need to run a distributed
consensus protocol. However, all consensus solutions have an
inherent limitation when it comes to scalability: they do not
work very well if there are too many acceptors or too many
concurrent
transactions to be considered. This also makes
consensus protocols susceptible to denial-of-service (DoS)
attacks: an attacker can bombard a blockchain system with
invalid transactions, effectively stalling consensus progress. To
improve the scalability and resilience to DoS, most blockchain
systems introduce the role of a proposer. Proposers act as

intermediaries between creators of transactions and acceptors.
They may reduce the rate of concurrent proposals by (a)
verifying and pre-authorizing them locally and ﬁltering out
invalid or non-authorized transactions, (b) introducing explicit
rate control, and (c) batching multiple transactions into a
block. The exact distribution of responsibilities between the
acceptor and proposer roles depends on a speciﬁc blockchain
system but the conceptual separation applies to most systems.
Since blockchain systems do not assume that all nodes are
trustworthy, they may need to incentivize the nodes to per-
form their roles correctly, without deviations. Additionally,
proposers and acceptors contribute to making the blockchain
tamperproof, together with data recorders.

Data recorders: These entities record the additions to the
blockchain accepted by the acceptors, which results in storing
the entire blockchain. Along with proposers and acceptors,
they contribute to data security by making the data tamper-
proof through the use of cryptographic primitives.

Query issuers: They issue queries of different types over

the current blockchain data.

Query responders: Some of the nodes playing the role of
data recorders have an additional responsibility of respond-
ing to the queries from query issuers based on the stored
blockchain data. The need for and the exact role of query
responders is further detailed in Section IV-D6.

D. Architecture

The design of blockchain systems is based on a layered

architecture, which we show in Figure 2.

Hardware Layer: This is the bottommost

layer of a
blockchain system. While most blockchain systems can be
deployed without any specialized hardware, hardware can
make the computation (e.g., of cryptographic hashes) more
efﬁcient, provide extra security of the storage and computing
environment, etc.

Data Storage Layer: This is the most important part of a
blockchain system when it comes to storing data, keeping it
safe from modiﬁcations, and making it traceable. This layer
is also responsible for providing availability and durability of
data. All of these features depend on the data items used in
this layer, the method of storing the data, and the structure of
the storage.

analyzing four blockchain systems with signiﬁcantly different
properties and implementations. In this work, Bitcoin Core,
Ethereum 1.0, Hyperledger Fabric v.2.0, and IOTA IRI v.1.5
are compared to each other in terms of blockchain entities
and features and mechanisms of each architecture layer. The
blockchain ﬁeld is known for dynamic developments, with
relatively short update cycles. However, Bitcoin does not
undergo signiﬁcant changes at this point so that we expect
all Bitcoin-related descriptions to remain valid in the future.
Ethereum has declared its intent to release a new version with
several signiﬁcant changes, including a transition from PoW
to PoS. However, no studies of the new version have been
published ahead of the release so that we base our survey
on the current operational version. While Hyperledger Fabric
continues to be under active development, the new versions
introduce new features and performance optimizations, switch
to a different default consensus implementation, and modify
the chaincode features and structure. They do not radically
change the fundamental design of each layer, which we
discuss in our survey. Finally, IOTA IRI is currently the best
documented version of IOTA that is presented in the white
paper [26].

Table I maps the blockchain roles to the entities of different
blockchain implementations. In the following, we explain the
functionality of each entity and the interactions happening
between the entities:

A. Bitcoin

Every node in Bitcoin is able to create and send transactions
to the blockchain network. Created transactions are gathered
by the miners who are the proposers in Bitcoin. However, the
network cannot sustain every miner making a proposal at an
arbitrary point in time because of scalability and potential DoS
attacks by the miners. It is therefore needed to moderate the
number of proposers and rate of concurrent proposals. The
entire Bitcoin system must attain a balance with respect to
the proposal rate: a high rate will hamper scalability while
a low rate will
limit progress and transaction throughput.
Furthermore, Bitcoin must achieve that moderation through
distributed mechanisms, without a centralized moderating en-
tity. In order to keep the rate down, Bitcoin introduces a
Proof-of-work (PoW) mechanism: A miner needs to solve a
cryptopuzzle by performing a heavy computation and showing
the proof of it, in order to gain the right to form a block with
the validated transactions, and then broadcast the block to the
network.

into two categories:

Bitcoin nodes are split

full and
lightweight. Full nodes play two roles: they act as both block
acceptors and recorders of the whole blockchain. Upon receiv-
ing a newly broadcast block from the network, they verify it
using the previously stored data and potentially append it to
the blockchain.

Lightweight nodes are also called simpliﬁed payment veri-
ﬁcation (SPV) [27] nodes. SPV nodes neither store the entire
blockchain nor participate in the decision of accepting new
blocks. They can however, use the SPV method to verify

Figure 2. Layers of a blockchain system

Communication Layer: Any blockchain system needs a
mechanism for disseminating the transactions and blocks be-
tween the participants. This is especially important for large-
scale permissionless blockchain systems. The granularity of
dissemination, protocol of communication, ordering guaran-
tees, privacy and security guarantees, and propagation time
are related to this layer.

Data Manipulation Layer: The main responsibilities of
the data manipulation layer include updating the blockchain
and offering a search functionality for blockchain data. Since
an update must be a coordinated decision in a decentralized
environment with a lack of trust between individual par-
ticipants, the consensus protocol plays a central role in all
blockchain systems. Design choices of the data manipulation
layer can affect different parameters related to performance
and the strength of security and privacy guarantees, including
the ability to withstand or mitigate DoS attacks.

Contract Layer: Blockchain systems provide the ability of
deﬁning contracts for creating and enforcing the rules among
the participants of the network. Different blockchain systems
may use various methods for developing the contracts based
on their application domain. This layer deals with invoking
and executing transactions within the contract, as well as
programming languages (which may be Turing-complete or
not) and execution environments.

Application Layer: This is an abstraction of the applica-
tion built atop a blockchain system. While its speciﬁc design
is outside the scope of a blockchain system, it deﬁnes the
requirements that a blockchain system needs to satisfy.

III. UNDERSTANDING BLOCKCHAIN SYSTEMS: OVERVIEW
AND ENTITIES

While pursuing the question of in-depth understanding of
blockchain, we opt to illustrate the range of possibilities by

Table I
MAPPING ROLES TO THE ENTITIES OF DIFFERENT BLOCKCHAIN SYSTEMS

Blockchain system Transaction creator Proposer

Bitcoin

Ethereum

Nodes

Nodes

Miners

Miners

Hyperledger Fabric Application clients

Application clients, endorsers
& orderers

Acceptor

Full nodes

Recorder

Full nodes

Full nodes

Full nodes

Query responder
Dedicated services on top of
full nodes
Dedicated services on top of
full nodes

Query issuer

Everyone1

Everyone

Orderers & peers Peers

Application-dependent

Application clients

IOTA

Clients

Clients

Nodes

Nodes & permanodes

Dedicated services on top of
nodes & permanodes

Everyone

1 Everyone means any networked device

that a block header is valid and that a given transaction is
included into the blockchain. To this end, they can retrieve
block headers and speciﬁc secure hashes from a full node and
employ a Merkle verﬁcation algorithm. Merkle veriﬁcation is
explained in Section IV-B.

For the Bitcoin system, there are dedicated services which
act as query responders: they provide information for any node
on the Internet even if the node is not on the Bitcoin network.
However, these services can only handle ﬁxed basic query
types so that they are not as semantics-rich as specialized
databases. Additional information about queries in blockchain
systems is given in Section IV-D.

B. Ethereum

The entities in the Ethereum system and the interactions be-
tween them are similar to those in Bitcoin. However, Ethereum
introduces a number of additional underlying concepts and
mechanisms not present in Bitcoin. The most central of those
concepts is that of gas: since transactions in Ethereum can
be Turing-complete programs, it is impossible to predict how
much of computational and storage resources a transaction will
consume. It is only feasible to monitor resource consumption
at runtime and abort the transaction if it exceeds the permitted
budget. Ethereum manages budgets for executable units such
as transactions, blocks, smart contracts, etc. These budgets are
measured in gas and paid for by the creators of transactions.
Ethereum assigns gas cost to resources (operations and storage
units). When a transaction executes an operation, Ethereum
deducts the cost of that operation from the budget. In Sec-
tion IV, we consider additional concepts and mechanisms in
the context of each layer and cover them in detail.

C. Hyperledger Fabric

As Hyperledger Fabric is designed for use in private
blockchain systems, it does not have the concept of miners.
Furthermore, its entities and their responsibilities are com-
pletely different compared to Bitcoin and Ethereum. There are
three types of entities in Fabric: application clients, peers, and
orderers. Clients are application nodes external to the Fabric
that connect to Fabric nodes. They constitute the application
running atop blockchain and play the role of transaction cre-
ators. The peers are authenticated and authorized Fabric nodes
that constitute the core of the private blockchain network. The
orderers are special nodes provided by the Fabric deployment.

The ﬂow in Fabric is as follows: Clients send every proposed
transaction to the endorsing peers (also called endorsers),
which are a subset of all peers determined by the endorsement
policy. More precisely, the endorsement policy deﬁnes the
smallest set of endorsers that need to endorse a transaction in
order for it to be valid [28]. The endorsers typically come from
different organizations within the consortium that deploys an
application.

Endorsers are responsible for simulating the transaction
without updating the blockchain and verifying if the update
causes a conﬂict with the current state or with the policy. If an
endorser approves the transaction, it identiﬁes the set of data
read and updated by the transaction, which is called a read-
write (or R-W) set. Then, the endorser sends the R-W set back
to the client, along with the endorser’s signature. If transaction
approvals obtained by the client are insufﬁcient according
to the endorsement policy, the ﬂow effectively terminates.
Otherwise, the client submits the endorsed transaction and the
R-W set to the ordering service.

Ordering service consists of orderers which are responsible
for receiving the endorsed transactions and their R-W sets
from different clients, ordering them, and forming a block.
The orderers run a consensus protocol to achieve ordering
of transactions. Once produced by the consensus protocol, a
block is disseminated to all of the peer nodes in the system.
Peers validate the block’s transactions by checking whether
the R-W sets still match the current state of the blockchain.
the peers add successfully veriﬁed blocks to the
Finally,
blockchain and update the state.

All peers store blocks, thereby playing the role of data
recorders. There is no equivalent of lightweight nodes in
Fabric. Orderers may be conﬁgured to store blocks as well.

In the above ﬂow,

the role of acceptors is distributed
between endorsing peers in the ﬁrst phase, orderers in the
second phase, and all peers in the third phase. For example,
the peers may reject the block produced by the orderers, if it
is malformed or if it causes an inconsistency.

Since the deployment scale of private blockchains such as
Fabric is typically smaller compared to a public blockchain
such as Bitcoin, the signiﬁcance of having a proposer role is
reduced accordingly, see Section II-C. However measures to-
wards improving scalability are still taken: Endorsers perform
pre-authorization of transactions, clients themselves may abort

the ﬂow if the approvals are insufﬁcient as per the endorsement
policy, while orderers batch transactions and form blocks.

Regarding query issuers and responders, application clients
issue queries in Fabric, while the peers which keep the state
respond to those queries.

D. IOTA

Similar to Bitcoin and Ethereum, IOTA is a permissionless
blockchain system. IOTA organizes transactions into bundles
instead of blocks. The main difference is that a bundle groups
related transactions together; a single transaction in a bundle
cannot be understood or performed independently of other
transactions in the bundle. For example, IOTA differentiates
between input
transactions that may combine funds from
multiple input addresses together and output transactions that
may split a sum into multiple output addresses. A bundle
commonly contains related input and output transactions, as
well as transactions of other types. More details are given in
Section IV-B.

The main purpose of grouping transactions in a block in
Bitcoin, Ethereum, and Hyperledger Fabric is to improve the
throughput of the consensus protocol that is used to update
the ledger. Bundles cannot be used to this end because they
cannot combine unrelated transactions. Interestingly, IOTA
achieves higher throughput compared to Bitcoin and Ethereum
by organizing bundles in a directed acyclic graph (DAG) as
opposed to organizing blocks in a chain. We provide a detailed
discussion in the context of the storage and data manipulation
layers in Sections IV-B and IV-D.

The roles and responsibilities in the IOTA network are
shared by three main entities: a) clients b) nodes and c)
permanodes. Clients are external to the IOTA network. They
are responsible for creating bundles and disseminating them to
the full nodes. In order to prevent spamming and DoS attacks,
a client needs to solve a low-complexity cryptopuzzle in order
to propose a bundle.

Nodes are interconnected together to form the core of
the IOTA network. After having received a bundle from a
client, a node P validates it as follows. First P conﬁrms
that the transactions in the bundles do not conﬂict with the
past transactions. Additionally, P checks if all the related
transactions are available in the same bundle by computing
whether or not the total sum of values of the transactions in the
bundle is equal to 0. After a successful validation, P attaches
the approved bundle to the local copy of the ledger called the
Tangle [26]. Nodes run a consensus protocol to synchronize
their copies of the Tangle.

Note that unlike Bitcoin and Ethereum, nodes do not create
competing proposals for updating the ledger. Accordingly,
there is no concept of mining in IOTA. Since nodes do not
need to perform any signiﬁcant computation, they are not
rewarded for participation in the system either. Nodes are also
able to answer limited queries about the Tangle but this is not
their primary purpose.

Permanodes are dedicated nodes, many of which are pro-
vided by the IOTA Foundation itself. Similarly to nodes, they

store a copy of the Tangle. However, they are external entities
to the IOTA network: they do not receive bundles from the
clients or participate in the consensus protocol. Instead, they
receive Tangle updates from nodes. Their main purpose is
to support complex queries. To this end they store Tangle
information in a special database, as explained in detail in
Section IV-B.

In summary, clients play the role of transaction creators
and proposers. Nodes play the role of acceptors (validating
the transactions in the bundle), recorders (storing the bundles
in the local ledger), and query responders (supporting services
with simple queries). Permanodes play the role of recorders
and query responders; yet they support richer queries com-
pared to nodes.

IV. UNDERSTANDING BLOCKCHAIN SYSTEMS LAYER BY
LAYER

As we discussed in Section II-D, blockchain systems are
categorized into six different layers: hardware, data storage,
communication, data manipulation, contract, and application.
We now analyze the features and implementation of each layer
in the four selected blockchain systems.

A. Hardware Layer

While blockchain implementations are primarily software-
based, hardware components are used for two purposes: im-
proved efﬁciency and enhanced security. In particular, im-
plementations of open blockchain systems such as Bitcoin,
Ethereum, and IOTA, are resource-bound: there is a hardware
resource that limits the ability of a single node to propose
numerous changes to the blockchain at a fast rate. The exact
resource varies across the systems, however. On the other
hand, this is not required in permissioned blockchain because
of a tight membership control. Table II highlights related
aspects for the analyzed systems.

As mentioned in Section III, miners in Bitcoin require to
perform costly and time consuming computations in order to
create a valid block. They need to solve a cryptopuzzle by
exhaustively going over the solution space and calculating
a hash value for each potential solution, which results in a
massive amount of hash computations. Therefore, the Bitcoin
technology is strongly dependent on the processing power of
the miners. Nowadays, the most common hardware for the
purpose of mining bitcoins are ASIC processors [22]. They
are designed speciﬁcally for the purpose of computing Bitcoin
hashes in an optimized way.

In contrast

to Bitcoin, Ethereum follows ASIC-resistant
approach in its hardware layer. The goal of choosing such
an approach is coming up with a puzzle that reduces the
gap between the most cost-effective customized hardware
and what most general-purpose computers can do, so that
it would be economical for individual users to mine with
the computers they already have [22]. To achieve this goal,
Ethereum uses a different PoW algorithm compared to Bitcoin,
called ethash [29]. The ethash algorithm needs 64 sequential
page fetches from the memory to generate a single hash

Table II
HARDWARE LAYER OF DIFFERENT BLOCKCHAIN SYSTEMS

Features
Limiting resource
Cryptopuzzle solving device

Additional hardware for security
(Research initiatives)

Bitcoin
Processor
ASIC
Hardware-based trusted
execution environment (e.g.
Intel SGX processor)

Ethereum
Memory bandwidth
GPU

Hyperledger Fabric
Application-dependent
No cryptopuzzles

IOTA
Processor & network bandwidth
Proprietary processor (being phased out)

Hardware-based trusted
execution environment

Application-dependent

No additional hardware

and compare it with the cryptopuzzle target. Since ethash is
bound by the speed of memory access rather than computation,
speeding up the processor computation by ASICs does not
help in a signiﬁcant way. Furthermore, since an expensive top
performing computer only has moderate improvement in the
speed of memory access compared to commodity hardware,
vertical scaling does not have a strong effect on the efﬁciency
of mining in Ethereum. Hence, utilizing GPU processors,
which can solve cryptopuzzles faster than CPUs [30], is more
cost-effective for mining in Ethereum. This has an additional
effect that cryptopuzzles in Ethereum can be less computa-
tionally intensive. On the other hand, the power consumption
of GPU is higher compared to ASIC so that the net effect on
power consumption in Ethereum is not clear.

The design of cryptopuzzles in both Bitcoin and Ethereum
facilitates parallel computation, which increases the risk of
mining power centralization in the hands of powerful players.
While ethash limits the potential of vertical scaling for mining,
horizontal scaling is widely used in both systems.

As there is no concept of mining in Hyperledger Fab-
ric,
it does not need specialized hardware components to
boost the efﬁciency, unless required by a speciﬁc application.
While IOTA does not use blocks and does not employ the
concept of mining or monetary rewards, it still uses a less
computationally intensive version of cryptopuzzles in order
to prevent denial-of-service attacks. Therefore, IOTA is also
dependent on the computation power of participating nodes.
Since resource-limited IoT devices is the main focus of IOTA
implementations [31], IOTA has developed a proprietary low-
energy processor called JINN [32]. The main purpose is to
expedite the computation of relevant cryptographic primitives,
though currently the computation is typically done in software.
Besides computation power, bandwidth is another critical
resource in IOTA since IoT devices are also bandwidth-
limited [33].

A major focus of the blockchain technology is to provide
tamperproof storage in absence of trust in individual par-
ticipants. In view of this, a number of initiatives such as
Teechain [34] have tried to enhance the security of Bitcoin
and Ethereum by taking advantage of the hardware-based
Trusted Execution Environment (TEE) technology, such as
Intel® SGX processor [35]. TEE is designed to create a more
secure computation environment for the processor by isolating
and protecting the running application against unauthorized
access or tamper by the host machine. While the use of TEE
still requires the trust in the TEE manufacturer, it mitigates
potential attacks by individual blockchain participants.

B. Data Storage Layer

The purpose of the storage layer is to record all transactions
in a distributed ledger and provide support for their efﬁcient
veriﬁcation. While simple transactions merely transfer ﬁnan-
cial tokens, general transactions represent transitions in the
global system state. It is important to keep track of the state,
e.g., in order to perform veriﬁcation of transactions. While it is
possible to reconstruct the most updated state by starting from
the initial state and replaying all transactions recorded in the
ledger, this would be a time-consuming and inefﬁcient process,
especially since the ledger size is continuously growing. As a
result, all blockchain systems store explicit information about
the current state in addition to the transactions. However, the
systems differ in terms of what state-related information they
store and in terms of how they organize it. Additionally, the
storage layer provides support for veriﬁcation of transactions
issued by the clients and for computation on the state in the
ledger.

The rest of the storage layer description covers state tracking
approach, general organization of blockchain storage,
the
block structure, structure of transactions and their grouping
in blocks, on-disk storage, the use of trees in Bitcoin and
Ethereum, in-memory storage, and data retention. Table III
presents a comparison of salient storage design aspects across
the four systems.

1) State Tracking Approach: So far, all blockchain systems
have been employing one of the two principal approaches for
tracking system state. Bitcoin employs the unspent transac-
tional output (UTXO) approach while Ethereum utilizes the ar-
bitrary state approach. IOTA follows the UTXO approach with
a minor modiﬁcation, as we explain below. Fabric does not
track state by default but the application developer can devise
and plug in any desired implementation with some restrictions.
The two approaches differ by generality, compactness of trans-
actions, simplicity and efﬁciency of storage organization, ease
of parallelizing transaction processing, as well as transaction
linkability, i.e. that ease at which a transaction can be linked
to an individual user.

In the UTXO approach, a transaction transfers currency
tokens by consuming a number of input tokens and producing
a number of output tokens. For example, suppose Alice has
previously received 6 tokens in a single transaction. In this
case, the six tokens become identiﬁable transactional outcome
(TXO), which is marked as unspent. Assume Alice later wants
to transfer 4 tokens to Bob. She can use the six token UTXO
as the input to the new transaction. During the transaction
execution, the protocol will verify that the UTXO has not

Table III
DATA STORAGE LAYER OF DIFFERENT BLOCKCHAIN SYSTEMS

Features
State tracking
approach

Bitcoin

UTXO

Ethereum

Hyperledger Fabric

Account/balance

Application-dependent

IOTA

UTXO

Higher-level structure

Sequence of blocks with
transactions

Sequence of blocks with
transactions

Sequence of blocks with
transactions

Maximum
block/bundle size

On-disk
storage

Ledger
storage

Index

State-
related
storage

Extra
storage
elements

In-memory storage

1 MB block ﬁxed by the
protocol
Block data as multiple
ﬁles of limited size each
Block index in a
LevelDB database

UTXO set in a LevelDB
database

Each block ﬁle has a
corresponding undo ﬁle
to support
reorganization/fork
Block index database,
UTXO cache, & Merkle
trie of transactions

Block’s gas limit
determined by miners
Block data as multiple ﬁles
of limited size each

-

Each node of tries (state,
storage, receipts, txs) in a
LevelDB database
All block data (block
header and transaction
data) in a LevelDB
database

Conﬁgurable block size as
per application
Block data as multiple ﬁles
of conﬁgured size
Block index in a
LevelDB database

DAG of transaction
bundles with edges
signifying approvals

Unlimited bundle size

Tangle stored in a
RocksDB database

-

Worldstate in a LevelDB or
CouchDB database

Balance info stored in
RocksDB database

-

Snapshot data as a ﬁle

Cache of Merkle Patricia
tries vertices

Application-dependent; peer
cache

Tangle Accelerator
(proxy cache for nodes)

Data retention

No retention policy

State tree pruning

No retention for ledger;
application-dependent for the
state

Snapshot purges the
database

two new UTXOs will be created: one
been spent. Then,
UTXO worth 4 tokens will be transferred to Bob while another
UTXO worth two tokens will be transferred back to Alice.
Additionally, the old six token TXO will be marked as spent.
In the UTXO approach, the system only keeps track of the
unspent transactional outputs because they can be used as input
to future transactions. Since there is no concept of accounts
or wallets at the protocol level, the “burden” of maintaining a
user’s balance is shifted to the client side. Wallets maintain a
record of all UTXOs associated with a user and compute the
total sum, which represents the balance. However, this balance
is inaccessible to all but the user who owns the wallet.

The UTXO approach in IOTA slightly differs in that the
term of “address” is used to refer to a TXO and an address
can be reused to receive funds in multiple transactions, thus
acting as a pseudo-account. The storage system in IOTA keeps
track of all transactions that have transferred funds to a given
address. Like a TXO, an address can only be used once when
sending funds such that the entire amount is spent. This minor
difference in IOTA does not have a signiﬁcant impact on the
properties of the UTXO approach, which we discuss below.

in that

The arbitrary state approach is more general

it
supports arbitrary state rather than just tokens transferred be-
tween the users. This naturally leads to more complex storage
structures compared to the UTXO approach. In particular, it
is common to keep the state partitioned. For example, each
user in Ethereum has an associated account and the state
is partitioned by those accounts so that the state tracking
approach in Ethereum is commonly referred to as “account-
based”. Since there exists no single public deployment of
Hyperledger, the state in Hyperledger is kept separately for
each proprietary deployment. Besides, the worldstate in Fabric

is further partitioned per channel. The conﬁgurable nature of
Hyperledger allows an application developer to choose an
appropriate approach per partition, based on the application
needs.

Since the general state may be of an arbitrarily large size,
a question of limiting the state size arises. This challenge is
mitigated in permissioned blockchains by the ability to have
a tighter control over the behavior of each particular user
and application. In public blockchains, on the other hand, the
users need to be disincentivized from storing too large of a
state. This is achieved in Ethereum through the gas spending
mechanisms mentioned in Section III-B: the users pay gas
not only for transaction execution but also for state storage,
proportionally to the state size.

The per-account state in Ethereum includes the user bal-
ance as well as any additional variables required for general
calculations. In the above example, a transaction transferring
four tokens from Alice to Bob would need to check Alice’s
balance, decrease it, and add the funds to Bob’s balance.

A single user may receive many token transfers in the
UTXO approach and may own many unspent TXOs simul-
taneously. This means that when limited to applications that
transfer currency tokens, the blockchain state may grow with
the number of transactions over time, whereas in the balance-
based approach, the state size only depends on the number
of users. In this scenario, the balance-based approach may
require less storage compared to the UTXO approach. Besides,
a single UTXO-based transaction may take many input TXOs
and may produce many output TXOs. This makes the veriﬁca-
tion protocol less efﬁcient compared to the simple veriﬁcation
procedure in the balanced-based approach.

On the other hand, the UTXO approach may allow for better

parallelization of transaction processing. For example, if Alice
wants to transfer one UTXO to Bob and another to Carol, the
two transfers can be handled in parallel. In contrast, Alice’s
balance would need to be checked sequentially in the account-
based model, which would require serialization of the two
transfers.

The UTXO approach also has an edge when it comes to
privacy, speciﬁcally hiding the link between the user and
her transactions and balance. In the account-based approach,
the system maintains the user’s balance and keeps explicit
association between the transactions and accounts. No such
association is maintained in the UTXO approach so that the
state cannot be linked to an individual user.

As mentioned in the beginning of this section, Fabric does
not provide any implementation for state tracking that would
be included in the installation. The application developer,
however, can implement any state tracking approach in Fabric
using the key-value store provided to this end. If a ﬁnancial
application needs to maintain user accounts with correspond-
ing balances, the account name can be used as a key while the
balance will be included in the value. The UTXO model can be
implemented in the key-value store of Fabric as follows [36].
First, every UTXO can be represented as a unique key-value
entry in the store. Any unique identiﬁer created for the UTXO
can be used as a key. The value will specify (a) the amount of
cryptocurrency that the UTXO holds and (b) the reference
to the owner of the UTXO, which can be represented in
different ways, such as the public key or the Fabric identity.
Any transfer transaction will spend old UTXOs and destroy
their entries in the store. It will also create new entries, one
for each new UTXO.

2) Organization of blockchain storage: The storage orga-
nization is conceptually similar in Bitcoin, Ethereum, and
Fabric. The transactions are grouped together into blocks to
improve scalability of the consensus protocol as explained
in Section IV-D. The blocks are stored in ﬁles on disk. To
provide tamper resistance, the individual blocks are linked to
each other to form the logical structure of a chain. Since each
block includes a hash pointer to the previous block in the
chain, tampering with one block would affect the hash values
in all subsequent blocks in the chain.

In addition to the chain of blocks, the storage includes a
key-value store for keeping auxiliary information, e.g., related
to the system state as explained in Section IV-B1. An increased
emphasis on the state storage and state-related operations
(such as search) in Ethereum results in signiﬁcantly more
complex storage mechanisms compared to Bitcoin. Besides,
the balance of roles between the chain of blocks and the key-
value store is fundamentally different in Bitcoin and Ethereum
because a key-value store lends itself better to state-related
operations. In Bitcoin, search for blocks and even transactions
is conducted primarily using the chain of blocks, with the
help of a block index maintained in the key-value store. In
Ethereum, on the other hand, block headers and transactions
are duplicated in the key-value store, which is the main storage
element used in the search. Furthermore, much of the data kept

in the key-value store is organized in cryptographic search
trees (henceforward referred to as cryptographic tries), while
Bitcoin only constructs trees in memory and for a different
purpose, as we elaborate upon in Section IV-B6.

IOTA is different from Bitcoin, Ethereum, and Fabric in
three respects: there are no blocks, the structure is different
from the linked list, and the transactions themselves are stored
in a database rather than a ledger. As opposed to the chain
of blocks, IOTA utilizes a directed acyclic graph (DAG).
In essence, the nodes represent transactions while the edges
signify approval of the transactions. A new transaction has to
verify and approve two existing transactions in order to be
included in the DAG. Accordingly, the consensus algorithm
signiﬁcantly differs as we explain in Section IV-D4. When it
comes to storage, DAG storage requires more space compared
to systems that use a chain of blocks. This is because there
are more nodes in the DAG than blocks in a chain, and every
node has non-trivial meta-information attached to it.

3) The block structure in Bitcoin, Ethereum, and Fabric:
The key differences in the block storage structures in Bitcoin,
Ethereum, and Fabric are mainly due to two important design
choices: a) record keeping model and b) consensus protocols.
As the account model requires more storage to represent the
association between the accounts and the balances, the block
structures for account models are relatively complex compared
to those for UTXO. As we detail in Section IV-B5, Ethereum
has to keep track of the states and changes associated with
each account in contrast to UTXO-based Bitcoin.

The block body in all

three systems includes a list of
transactions. In Ethereum, it additionally includes a list of
uncles (whose concept is explained in Section IV-D2).

The block header in all three systems contains the parent
block hash. This hash is inherent to all blockchain systems
that create a chain of blocks. Although in Hyperledger Fabric,
the current block hash is also stored in the block header,
Bitcoin and Ethereum do not include the block hash inside the
block’s data structure. Instead, Bitcoin and Ethereum nodes
compute the block hash when they receive the block from
the network. Nonce is another important ﬁeld in the block
header of blockchain systems that use mining such as Bitcoin,
Ethereum, and IOTA; it contains a solution for the block
cryptopuzzle. In Ethereum, the header additionally includes
a hash of the uncle list stored in the block body, as explained
above. Furthermore, Ethereum stores the root hash for each of
the multiple search tries in the block header, as we explain in
Section IV-B6.

Considering the permissioned nature of Hyperledger, the
block storage structures in the system include the real identity
and signatures of the clients, endorsing peers, and the orderer.
Such identities are not present
in Bitcoin, Ethereum, and
IOTA. Furthermore, invalid transactions may be included as
part of the conﬁrmed block due to the working principles
of the consensus protocol of the Hyperledger as explained in
Section IV-D. Therefore, there is a ﬁlter ﬂag for each stored
transaction, which is used to differentiate between valid and
invalid transactions in the block.

transaction-related information:

Account nonce: A node issuing transactions on behalf of
the user maintains a counter of the number of transactions
sent from the user’s account. When the transaction is issued,
the node sets account nonce to the current value of the
counter. Keeping track of this count over time is important
for two reasons: ﬁrst, it establishes sequential order between
transactions sending funds from the same account so that the
miners or validators will process the transactions in that order.
Second, the account nonce prevents transaction replay attacks
by the recipient of funds because a repeated transaction with
the same nonce will be detected as invalid.

Gas price is the price of each unit of gas, expressed in

Figure 3. An Ethereum transaction structure

Ether.

4) Structure of transactions and their grouping in a block:
The maximum number of transactions that can be grouped
together is determined by the maximum size of the block.
For example, in Bitcoin, the maximum size of the block is
ﬁxed by the protocol at 1MB. The transaction size in Bitcoin
varies since a UTXO transaction can have multiple inputs and
multiple outputs. Unlike Bitcoin, Ethereum uses the concept of
gas to determine the size of the block. Every transaction in the
block has a gas price and the sum of prices for all transactions
in a block should not exceed the maximum gas limit of the
block set by Ethereum miners. In the case of Hyperledger, the
maximum block size can be conﬁgured by the administrator of
the network, in accordance with the application requirements.
While not using blocks, IOTA utilizes the concept of bun-
dles. A bundle is a group of transactions that are tied to each
other. The need for bundles arises because, unlike Bitcoin,
transactions in IOTA are limited in terms of the maximum
allowed number of inputs and outputs. Since proposing each
transaction in a bundle requires a separate proof-of-work (see
Section IV-D5), these limits translate to the maximum amount
of transactional data permitted for each proof-of-work; longer
bundles would require more work. Thus, if Alice wants to
consolidate funds from multiple addresses and transfer those
funds to several different users, she would need to create a
bundle with multiple transactions. Thus, the entire bundle is
issued by the same client. The size of the bundle is determined
by the input; it is unpredictable and beyond the system control.
Furthermore, IOTA does not have a predeﬁned limit on the
number of transactions in the bundle.

In the IOTA implementation presented in this survey [37],
the bundles can be used as a node in the DAG as opposed to
individual transactions.

Bitcoin transaction structure is described both in the spec-
iﬁcations [38] and textbooks [22] in detail. Its main ﬁelds
are the list of inputs and the list of outputs common in the
UTXO model as explained in Section IV-B1. As Ethereum
does not follow the UTXO model, it has a different transaction
structure. As shown in Figure 3, the transaction structure in
Ethereum includes a data ﬁeld, the hash of the transaction,
its size, and the sender. The data ﬁeld contains the following

Gas limit is the maximum amount of gas that can be

consumed by executing this transaction.

Recipient is the address of the transfer receiver.
Amount is the value to be transferred to the recipient.
Payload: If the transaction is meant to be an execution of a
contract (the recipient is a contract account), the payload ﬁeld
would be a message that identiﬁes the function and argument
values of the contract. Otherwise, if the transaction is for
payment (the recipient is a user account), the payload ﬁeld
would be empty.

Signature values: This ﬁeld includes components of the
signature algorithm of the sender. Ethereum transactions use
ECDSA (Elliptic Curve Digital Signature Algorithm) [39]
as their digital signature for veriﬁcation. The signature of
a transaction conﬁrms that
the sender has authorized this
transaction.

In Hyperledger Fabric, the design of the transaction struc-
ture depends on the application and state tracking approach
chosen for the speciﬁc deployment.

5) On-disk storage: The most important element stored on
the disk is the ledger. Bitcoin, Ethereum, and Hyperledger
Fabric store their block data as multiple ﬁles, each of which
is limited in size. Although the ﬁle size limit is ﬁxed in Bitcoin
and Ethereum, it is conﬁgurable in Hyperledger Fabric [40].
Block ﬁles store the blocks appended to the local copy of the
ledger [41].

Bitcoin additionally stores block indexes on the disk to keep
track of the information available in the chain of blocks. These
indexes are stored in a LevelDB (key-value store) database.
Similar to Bitcoin, Hyperledger Fabric utilizes indexes. By
default, Fabric also stores indexes in LevelDB but it can be re-
placed by other databases. The primary purpose of the indexes
is to support search functionalities for blocks and transactions
stored in the ﬁle through various keys such as a block number,
block hash, transaction id, and transaction number. The values
of the LevelDB key-value store are corresponding ﬁle location
pointers to the chain of block ﬁles [41], [42]. When an API
call to access blocks and transactions of the blockchain occurs,
these search indexes are utilized to ﬁnd the actual data location
in the ﬁle. On the other hand, Ethereum relies on a database
for keeping track of changes and ﬁnding data items, so that
has no need for indexing the ﬁles.

Figure 4. On-disk storage of Ethereum consists of the block data and database records

State-related storage is another salient on-disk element.
Bitcoin, Ethereum, and Hyperledger Fabric use a database of
key-value pairs for keeping track of the latest blockchain state.
In Bitcoin, the UTXO set which stores all unspent outputs is
all information that is required to validate a new transaction
without the need to traverse the whole blockchain [43]. Bitcoin
keeps the UTXO set in a LevelDB storage called chainstate.
On the other hand, Hyperledger Fabric keeps track of the
latest values of the business assets in its state-related storage
called worldstate. The state-related storage of Hyperledger
Fabric is represented on the disk as a LevelDB key-value store
by default. The keys and values of the state-related storage
reﬂect the data model described in the application chaincode,
as deﬁned by the developer. (see Section IV-E). In Fabric,
if the business application requires a complex data model
and access pattern, various other databases such as CouchDB,
GraphDB, and a relational datastore can be used to represent
the worldstate instead of LevelDB. These alternatives support
rich queries and data types [44]. Similarly, Ethereum stores
the latest values of all the accounts in a LevelDB database
as the state-related storage to facilitate calculating the current
value of any account available in the ledger. For this purpose,
Ethereum constructs the following four tries:

State trie represents the global state that efﬁciently stores

the mapping between all the addresses and accounts.

Storage trie is responsible for maintaining the relationship

between the account and the corresponding balance. State trie
is linked to the storage trie.

Transactions trie represents the transactions that change

the state of the Ethereum.

Receipts trie represents the outcome of the successful ex-

ecution of transactions.

Individual systems additionally maintain auxiliary meta-
data stored on the disk. In Bitcoin, each block ﬁle has a
corresponding undo ﬁle which contains the information that is
necessary to roll back and remove a block from the blockchain
in the event of a reorganization/fork [41]. In Ethereum, in
addition to storing block data as ﬁles, all block data including
the block header and the block body is stored in a LevelDB
database as shown in Figure 4.

Due to the different organization of blockchain storage
in IOTA as described in Section IV-B2, Tangle is stored
in a database rather than in ﬁles. Thus, all the information
about both transactions and balances is kept in the RocksDB
database. As an extra element, an IOTA node keeps snapshot
data (explained in Section IV-B8) in a ﬁle. Each time a new
snapshot arrives, it removes all transactions from the Tangle,
i.e. RocksDB database, and moves only non-zero balances to
a ﬁle in order to be used by the new pruned Tangle. Thus,
similarly to Hyperledger Fabric, IOTA maintains only the
current balances associated with the addresses.

6) On the use of trees in Bitcoin and Ethereum: Bitcoin
and Ethereum use trees to organize data items (transactions

and in the case of Ethereum, other data elements related to
state tracking) in the context of a given block. The trees are
cryptographic: every non-leaf vertex stores a secure hash value
for each of its child vertices. This way, tampering with a
single tree vertex n, or inserting a new vertex n will lead to
modiﬁcation of all the hashes on the path from n to the root
of the tree, making it easily detectable. Due to this, the hash
of the root node becomes a cryptographic ﬁngerprint of the
entire tree structure. Because of its signiﬁcance, the hash of
every root vertex is kept in the corresponding block of Bitcoin
or Ethereum for the sake of veriﬁcation.

However, Bitcoin and Ethereum use trees for different pur-
poses, and accordingly, their implementation is quite different.
Bitcoin uses binary Merkle trees as shown in Figure 5. For
a given block, the tree is constructed as follows: each leaf
represents a block transaction. The order of leaves corresponds
to the deterministic order in which the transactions are listed
in the block body. Each non-leaf vertex is created by com-
puting a secure hash of the concatenation of the two child
values. Due to this construction, the tree is deterministically
reproducible from the block body stored on the disk. This is
important because Bitcoin constructs Merkle trees in memory
on demand.

The main purpose of utilizing Merkle trees in Bitcoin is to
minimize the amount of bandwidth used for disseminating the
proof that a given transaction is included in a given block. It is
a typical situation that a lightweight Bitcoin node, without the
knowledge of the ledger, inquires about the inclusion status
of a particular transaction in a new block. To this end, the
node sends a veriﬁcation request including the transaction
hash to a full node which keeps track of the ledger. The
full node ﬁrst needs to locate the Merkle tree of the block
in memory and then, sequentially scan the leaves of the tree
in order to verify the inclusion. While a sequential scan is
not an efﬁcient operation, its inefﬁciency does not have a
strong impact because the number of transactions in a block
is relatively small. However, once the transaction is found,
the full node can construct the Merkle proof efﬁciently [45].
The Merkle proof includes all vertices on the path from the
leaf with the transaction to the root of the tree, along with
the children of these vertices. The full node can then send the
Merkle proof back to the lightweight node. The crucial point
is that the lightweight node can verify the inclusion based on
the Merkle proof, without requiring the rest of the vertices in
the Merkle tree. The size of the Merkle proof is logarithmic
with the size of the Merkle tree.

In addition to constructing Merkle proofs, there are in fact
very few operations supported by Bitcoin Merkle trees. Miners
beneﬁt from being able to efﬁciently append new leaves with
transactions because new transactions can arrive while mining
a block. Merkle trees allow for efﬁciently implementing this
particular type of vertex insertion because a new transaction
becomes the rightmost leaf. Additionally, the trees can be
pruned: for example, if we do not need to verify the inclusion
of Transactions 1 and 2 in Figure 5 any longer because their
TXOs have already been spent, we can remove corresponding

Figure 5. Bitcoin’s transaction Merkle tree

leaves, along with their hash vertices. We do need to keep the
vertex with Hash(Hash(TX1)+Hash(TX2)), however, for the
purpose of constructing Merkle proofs, as explained above.
On the other hand, vertex search, update, and deletion are
neither needed nor efﬁciently supported.

This is in a stark contrast with Ethereum, which uses the
trees for storing the state, in addition to transactions. Unlike
transaction history which is ﬁxed, the state in Ethereum needs
to be frequently changed: new accounts are inserted and old
accounts are deleted. The state of a particular account needs to
be searched and updated as well, potentially often. Ethereum
uses Merkle Patricia trie, which provides logarithmic com-
plexity for search, insertion, update, and deletion, in addition
to efﬁcient construction of Merkle proofs. Similarly to the
Merkle tree, data items are stored in the leaves. However,
Merkle Patricia trie is a preﬁx tree that uses the hash of a data
item as a key string that determines the path of the data item
within the tree. Normally, preﬁx trees create a new tree level
for each character in the key: the ﬁrst character will determine
the branch at the root, the second character will determine the
branch at the next level, and so on. However, Merkle Patricia
trie is a compact radix tree: if there are two vertices with
keys “abcd” and “abef” respectively, an intermediate vertex
with the key “ab” will be created. This vertex will have two
direct children corresponding to “abcd” and “abef”, without
any additional intermediate levels. In Ethereum, the key is
encoded as a hexadecimal value so that each vertex has at
most 16 children.

As shown in Figure 4, each vertex of every Ethereum
Merkle Patricia trie is stored as a separate record in the
LevelDB storage, and the key string for the trie vertex is also
used as a key for the LevelDB record. The tries are constructed
on a per-block basis. For each block, Ethereum stores the
root hashes of state, receipt, and transaction tries in the block
header. The root hash of each trie is used as the starting point
for ﬁnding other trie vertices in the database.

In particular, each leaf of the state tree corresponds to
an account in Ethereum. The leaf includes the balance and
the root hash for the storage trie of the account. The keys
and values of the account storage reﬂect
the data model
described in the Ethereum smart contract. An updated state of
an Ethereum account is retrievable by traversing the storage

Figure 6. Constructing tries across multiple blocks in Ethereum

trie vertices in the LevelDB database.

Figure 4 provides an illustration for the storage organization
on disk in Ethereum. Header and body for Block 2 are stored
in both Block 2 data ﬁle(s) and in the database. The header
contains root hashes for the state, receipt, and transaction tries.
Each root hash is a key for the corresponding root vertex
record in the database. From the root record of the state trie,
we can reach the branch vertex record, which points to Leaves
1 and 2B, each of which corresponding to a different account.
The record of Account 2B points to the root of the storage
trie for that account. The pointers between the vertices of the
storage trie in the database are presented in a similar way.
it
Another interesting functionality of Ethereum is that
continues maintaining correct tries for old blocks, not just for

the most recent block. For example, we can query the value of
an account or the value of a variable (maintained by a smart
contract) in a past block, even if those values have later been
updated. This functionality allows for an efﬁcient veriﬁcation
of transactions of block n: when applied on the state of block
n − 1, these transactions, if valid, will update the state to
that of block n. To implement this functionality in a space-
efﬁcient fashion, Ethereum uses an interesting variation of the
copy-on-write technique, as illustrated in Figure 6. While the
transaction and receipt tries are strictly separate for each block,
the state and storage tries can be partially shared across the
blocks. In the illustration, the state record of Account 1 in
Block 1 hashes to value b10a5. The record is placed in Leaf
1, which is the leftmost child of the branch node. Similarly,

the state record of Account 2 in Block 1 hashes to value b1d14
and it is placed in Leaf 2A. The state of Account 1 has not
been modiﬁed by the transactions of Block 2. Therefore, the
branch node in Block 2 points to the same record of Leaf 1
as the branch node in Block 1. On the other hand, the state
of Account 2 has been modiﬁed by the transactions of Block
2; its new hash value is b1a12. In this case, Ethereum creates
a new record and places it in Leaf 2B under the branch node
in Block 2. Storage tries are updated in a similar way. As a
result, the state and storage tries are only partially updated due
to the transactions in every new block. In reality, the changes
in the state and storage tries of each Ethereum block are fairly
small [46].

7) In-memory storage: Bitcoin creates Merkle trees in
memory on demand, when a need arises (see Section IV-B6).
As mentioned in Section IV-B6, the trees are deterministically
reproducible in memory from transactions stored on disk.
Furthermore, in Bitcoin, the entire LevelDB database of block
indexes is loaded into memory on startup to achieve a better
performance of ﬁnding the blocks [41]. UTXO cache is
another critical data structure maintained in Bitcoin mem-
ory [47]. As the UTXO set stored in LevelDB is accessed
frequently during block validation, the access time becomes a
major bottleneck. Therefore, during the block validation, the
required unspent coins are pulled from LevelDB into an in-
memory cache. Since the size of the entire UTXO set exceeds
8GB, cache management is required.

In Ethereum, different node implementations such as Geth
maintain an in-memory cache of conﬁgurable size, designated
for vertices of various tries. In the context of Hyperledger
Fabric, when using a state database, read delays during
endorsement and validation phases have historically been a
performance bottleneck. With Fabric v2.0 [48], a new peer
cache replaces many of the expensive lookups with fast local
cache reads, and the cache size can be conﬁgurable. Moreover,
what is stored in the memory storage of Hyperledger Fabric
depends on the implementation of the application. Finally,
IOTA uses Tangle Accelerator [49], which is an intermediate
caching proxy server between the client and IOTA node to
speed up the attachment process of a bundle to tangle.

8) Data Retention: Data retention is performed differently
in each of the representative blockchain systems. The ledger
in Bitcoin grows more slowly compared to Ethereum and
IOTA because Bitcoin stores less data per-block compared
to Ethereum and because new blocks are appended less
frequently compared to ledger changes in Ethereum or IOTA.
As a result, Bitcoin is less in need for ledger pruning mech-
anisms. For the time being, Bitcoin does not have any data
retention policy and keeps all of its transactions forever. As a
consequence, the storage on Bitcoin full nodes can potentially
grow large in size over time, which may become an even
bigger issue if Bitcoin manages to overcome its scalability
barrier and raise the average rate of transactions.

Similar to Bitcoin, Ethereum keeps its transactions forever
in the ledger. However, Ethereum has a state trie pruning
mechanism [46] for obsolete states. This mechanism tracks

when trie nodes are no longer referenced by the state trie (for
example, the Leaf2A node in Figure 6 has dropped out of the
state trie in Block 2), and at that point places the dropped nodes
on a death row in the database. From this point, after 5000
new blocks have been appended, the node will be permanently
deleted from the database. Essentially, Ethereum stores the trie
nodes that are part of the current state or part of the recent
history [46] (up to 5000 recent blocks).

Similar to Bitcoin and Ethereum, transactions on the ledger
will never be deleted in Hyperledger Fabric. However, data
from the worldstate database can be deleted if an application
developer deﬁnes the procedure of pruning obsolete data in
the implementation.

IOTA provides snapshots regularly in order to reduce the
size of storage needed by full nodes. The snapshot process
removes all the transaction history and the addresses with
zero balances and creates the list of addresses with a non-zero
balance to reduce the Tangle size [50]. This in turn speeds
up the time required to do synchronization among full nodes.
Another advantage is that the snapshot can indirectly improve
the throughput of transactions in IOTA by increasing the speed
of computing the balance for the accounts. Considering the
nature of light nodes and permanodes (refer to Section III-D),
the snapshot process does not have any impact on their storage.

C. Communication Layer

Comparison between the communication layer features of
the surveyed blockchain systems is shown in Table IV. In
order to manage the granularity of dissemination, Hyperledger
Fabric is using the concept of channels. Transactions submitted
and propagated in a channel are isolated from the other
channels. The channels are independent of each other in terms
of the order, delivery, and processing of the transactions. On
the other hand, transactions in Bitcoin, Ethereum and IOTA
are propagated through the whole network.

Next, we consider the communication protocol and propa-
gation time for each of the four systems. In Bitcoin, each node
sends inventory messages (inv) [51] periodically to advertise
its knowledge of transactions or blocks to the neighbors.
This advertisement contains the hash value of the transactions
or blocks as their identiﬁers, which is much shorter than
the actual
transaction or block. Then, each neighbor that
receives the advertisement checks if it mentions knowledge of
transactions or blocks the neighbor has not seen before. In this
case, the neighbor requests the missing transactions or blocks
from the sender via the getData message [51]. Experiments
in [52] indicate that it takes about 40 seconds for a new block
to propagate to 95% of the Bitcoin network (the mean time to
receive a block for a node is 12.6 seconds). This time includes
the transmission time (for inv message, getData message, and
delivery), as well as the veriﬁcation time. The propagation
time is likely to be even shorter for the transactions compared
to blocks.

In Ethereum, a miner that creates a block or another node
that receives a new block from the network use the same

Table IV
COMMUNICATION LAYER OF DIFFERENT BLOCKCHAIN SYSTEMS

Features
Granularity of
dissemination

Communication
protocol

Mean time to
receive a block
Ordering
guarantees
Privacy &
security
guarantees

Initial peer
discovery

Geo-proximity between
nodes

Bitcoin

Ethereum

Hyperledger Fabric

IOTA

Whole network

Whole network

Per channel

Whole network

Inventory
push-gossiped & blocks
pulled by nodes

Blocks or block hashes
push-gossiped & block
headers and bodies pulled

leader pulls blocks from
orderers & push-gossips to
peers

Push-ﬂooding

About 12.6 seconds

About 109 milliseconds

Application-dependent

No studies conducted

No guarantees

No guarantees

No guarantees

Through a set of DNS seeds
or direct conn. to a known
node
135 ms (avg.) peer-to-peer
latency

Proprietary deployment can
enable encrypted &
authenticated messages
Through a set of
bootnodes or direct conn. to a
known node
171 ms (avg.) peer-to-peer
latency

Totally ordered
broadcast

No guarantees

Authenticated channels

No guarantees

Anchor peering &
channel membership

Manual conn.
through a node list

Depends on consortium
network topology

No studies conducted

propagation protocol. Namely, the node considers a set S
of its neighbors and picks a random subset S(cid:48) ⊂ S of size
|S(cid:48)| = (cid:112)|S|. Then, the node forwards the entire block to
nodes in S(cid:48) while only sending a hash of the block to nodes in
S\S(cid:48). The neighbors receiving the hash of a new block request
the block header via a GetHeader message [53] from either
the sender or any of their neighbors that possess the block.
Finally, after getting the new block header, the Ethereum node
requests the block body in a way similar to requesting the
header. [54] shows that 95% of the blocks are propagated
through the Ethereum network within 211 milliseconds (the
average time of a block propagation delay is stated to be 109
milliseconds). [53] estimates that it takes only 3 or 4 hops to
broadcast a new block to the entire Ethereum network. This
small world of an Ethereum network compared to the Bitcoin
network can be the reason for the lower block propagation
time in Ethereum.

Peers in Hyperledger Fabric use both push and pull methods
in the communication protocol [55]. In the case of block
dissemination, a leader is selected from the peers. The leader
becomes responsible for pulling blocks from the orderers and
then initiating a push-gossip protocol to propagate the blocks
to the peers: Each peer broadcasts the blocks to a random set of
neighbors in the channel. In addition to push-gossiping, each
peer is also responsible for selecting a number of random peers
regularly and attempting to pull the missing blocks from them.
The design choice to use a leader for initiating push-gossip is
motivated by the need to reduce the load of sending blocks
from the orderers to the network. Orderers in Hyperledger Fab-
ric also enforce basic access control for channels, restricting
who can read and write data to the channels, and who can
conﬁgure them [56]. In Hyperledger Fabric, the propagation
time is dependent on application characteristics, especially on
the transactions type and network size.

In IOTA, the transactions are ﬂooded throughout the net-
work similarly to Ethereum. On the other hand, since no
studies have been conducted for the propagation time in IOTA,
it can be considered an interesting subject for future research.

Regarding the ordering guarantees, Hyperledger Fabric is
the only system among the blockchain systems covered in this
survey which supports total-order broadcasting [57] within
each communication channel. This guarantee ensures that
different endorsers and orderers receive transactions from each
given client ordered in the same way relatively to the trans-
actions from other clients. The relative order of transactions
is important because of the effects that the transactions may
have on each other.

To support privacy and security guarantees,

transferred
transactions between the Ethereum nodes are encrypted and
authenticated [58], which makes the Ethereum communication
layer more secure compared to Bitcoin. Furthermore, Whis-
per [59], a conﬁgurable messaging protocol, which can be
enabled in proprietary Ethereum deployments, provides the
beneﬁt of hiding the location of sender and receiver in the net-
work, if such privacy requirements arise. Whisper can achieve
this beneﬁt by using onion routing and other techniques
common in the Tor [60] network. Hyperledger Fabric utilizes
the authenticated channels to provide the privacy and security
of the network. IOTA has also introduced the functionality of
issuing and accessing encrypted data streams by implementing
the Masked Authenticated Messaging (MAM) protocol [61] as
a second layer communication protocol to improve the privacy
and security of the communication layer.

Geographical proximity between nodes is one of the param-
eters that have effect on the block propagation time throughout
the network. Measurements in [58] indicate that Bitcoin ex-
hibits a higher degree of clustering compared to Ethereum,
i.e., it has many more groups of nodes that are geographically
close to each other. [58] shows that an estimated peer-to-
peer latency between Ethereum nodes is 26.7% higher on
average compared to Bitcoin. The main reason for this higher
clustering degree is that many Bitcoin nodes are running
in data centers. This research claims that 56% of Bitcoin
nodes belong to autonomous systems that provide dedicated
hosting services whilst the percentage for Ethereum nodes is
28%. On the other hand, in permissioned blockchains such

Table V
DATA MANIPULATION LAYER OF DIFFERENT BLOCKCHAIN SYSTEMS

Bitcoin
Chain convergence
using longest-chain rule
About 10 minutes to
mine a block
3-7

Ethereum
Chain convergence using
GHOST protocol
About 12-15 seconds to
mine a block
About 15

No mining

Conﬁguration-dependent

Hyperledger Fabric
Conﬁgurable consensus module
(Raft is the default)

IOTA
DAG convergence using tip
selection algorithm

Above 99%

Below 97%

No mining

Probabilistic based on
the number of blocks

Probabilistic based on the
number of blocks

PoW + Gas price

Deterministic,
after committing on the peers
Permissioned
authentication

No

SQL-like query

PoW

No

No mining

About 50

No mining

Probabilistic based on
conﬁrmation conﬁdence

PoW

No

Features

Consensus protocol

Mining difﬁculty

Throughput (tps)
Mining power
utilization
Transaction
conﬁrmation
Mitigating DoS
attacks
Rich search
functionality

as Hyperledger Fabric, geographical proximity between nodes
depends on the consortium network topology. To the best of
our knowledge, geographical proximity between IOTA nodes
has not been studied yet.

D. Data Manipulation Layer

Data manipulation in blockchain primarily consists of two
operations: updating the state of the blockchain and query-
ing it. Since the transactions stored in the blockchain are
immutable, the only update operation allowed is adding a
new transaction to the ledger, which additionally results in
performing bookkeeping needed to keep track of the updated
state. While the goal is simple, the update process is quite
complex because it requires running a consensus protocol
across the nodes. The blockchain type and even design goals
vary across the systems, which results in signiﬁcant variations
in the ﬂavor of consensus protocols used [62], [63]. This is the
reason why blockchain systems exhibit signiﬁcant variations
in their performance and in security assumptions and threats
they can withstand. Besides, the performance is affected by
deployment characteristics, such as the blockchain network,
transaction rate, duration of transaction execution, and the
distribution of mining power in systems that use mining.
Accordingly, most of this section is dedicated to the update
protocol in the four systems considered. For each system, we
also discuss the security and performance properties. Table V
shows the differences in the features of the representative
blockchain systems in the data manipulation layer.

Querying the blockchain is conceptually much simpler than
updating it because it does not require coordination across all
nodes and because the scalability and security constraints are
not nearly as severe. However, the differences in blockchain
types and stored data (see Section IV-B) lead to different query
models.

Finally, security plays a very important role in the design of
the data manipulation layer. Yet, different blockchain systems
exhibit differences in the security assumptions and tolerated
threats so that there exist no easily identiﬁable baseline to
compare blockchain systems against. For example, the issue
of double-spending and concentration of computing power
in the hands of a single participant (or a group of collud-

ing participants) is a major consideration for Bitcoin and
Ethereum. However, it is a non-issue for Hyperledger Fabric
which does not use PoW and which leaves it to the application
to implement digital currency, if needed. The security model
behind IOTA has only been partially explored and deﬁned.
Accordingly, we discuss security aspects of each system
separately in the context of presenting the consensus protocol.
However, all blockchain systems must be resilient to denial-
of-service (DoS) attacks, which is why we include a focused
discussion comparing the defense mechanisms to DoS attacks
in all four systems.

1) Updating blockchain in Bitcoin: The mechanism of
updating the blockchain in Bitcoin has been presented in
other survey works (see Section V) and in a textbook [22].
In this section, we provide an extended description written in
a pedagogical way. While containing limited novelty by itself,
this description serves as a basis for comparison with the more
novel descriptions of updating the blockchain in the other three
systems, presented in the later sections.

is especially interesting about

The general ﬂow of updating the blockchain can be found
in Section III-A. What
the
blockchain update solution in open blockchain such as Bit-
coin is that it is fully self-moderated: the nodes are fully
autonomous. They do not have to follow the complex protocol
but do so because they are given a combination of incentives
and protective mechanisms. For example, the consensus pro-
tocol is very sensitive to the rate of proposals: too many and
the protocol stops to scale; too few and the system does not
make any progress.

The PoW mechanism prevents the miners from issuing
proposals at
too high of a rate. The rate is regulated by
the complexity of the cryptopuzzle, called mining complexity.
Bitcoin adjusts the mining complexity every 2016 blocks so
as to keep the average interval between consecutive block
proposals limited to 10 minutes. To be precise, every miner
in Bitcoin adjusts its own mining complexity independently
based on its local copy of the chain. However, since the
adjustment is based on the height of a block and not on the
data in the chain, every miner performs the same adjustment
after the same block number, which ensures fairness of mining.
In order to keep the rate up, Bitcoin incentivizes miners

to spend their resources on solving cryptopuzzles. Speciﬁ-
cally, it introduces two incentive mechanisms: (a) a block
creation reward that is given to a miner whose block has
been successfully included into the chain, and (b) a transaction
inclusion fee that a transaction creator may voluntarily pay to
the miner that includes the transaction into the proposed block.
The block creation reward is regulated by Bitcoin similarly
to the mining complexity. It is halved every 210000 blocks.
Taking into account the average 10 minute interval between
consecutive blocks, the reward is expected to become zero
before 2140. Currently, the block creation reward plays a
more important role than a transaction inclusion fee but as
the reward gets smaller, the transaction inclusion fee will
start playing an increasingly more important role. Every block
includes a single transaction assigning block creation reward
to the proposer; this is the only mechanism by which Bitcoin
injects new funds into circulation. In order to increase the
chance of receiving block creation reward, a group of miners
can organize themselves into a mining pool. Then, all members
of the pool work together to mine each block, and the revenue
of mining a block is shared among them.

In Bitcoin, there is no entity in the system that knows the
state of the global chain. Every full node maintains a local
copy of the global chain (ledger and UTXO information as
explained in Section IV-B) and may update it upon receiving
a new block proposal. As different Bitcoin miners may create
and propagate different valid block proposals in parallel, the
local ledger copies on different nodes may temporarily diverge.
In the example of Figure 7, Block 2a and Block 2b are
both valid and created in parallel as successors to Block
1. This situation when different blocks are referring to the
same predecessor block is called a fork in the blockchain. In
addition to the accidental fork creation which happens because
of concurrent block proposals, there are also intentional forks.
Whenever the blockchain protocol is updated (for example
when the block size is changed) on a subset of nodes, it can
result into two types of fork: hard and soft. In the hard fork
situation, the nodes with updated protocol cannot interoperate
with the nodes running the old version of the protocol at all.
A hard fork can lead to creation of a new cryptocurrency. For
example, Bitcoin Cash [64] has been created as a hard fork
of Bitcoin, and is now completely independent of Bitcoin. On
the other hand, soft forks support backward compatibility. It
means that transactions from nodes running the new protocol
are accepted by the nodes running the old one, but transactions
created by the new protocol addresses are not accepted by the
old nodes. Segregated Witness (SegWit) [65] is an example
of a soft fork. SegWit is created as a protocol upgrade of
Bitcoin to improve block capacity and prevent the transaction
malleability (changing a transaction after signing it) problem
by introducing a new transaction structure.

In the case of accidental fork creation, the miners have
to decide which of the branches will be included in the
main chain and which branch will be discarded. In order to
reach a consensus on the included branch, Bitcoin has the
longest chain rule for resolving conﬂicts between competing

Figure 7. Bitcoin chooses the main chain based on the longest chain rule.
Any valid block outside the main chain will be ignored and called a stale
block.

branches [27]. This rule stipulates that the longest branch
wins and becomes part of the main chain for building the
subsequent block upon. The rationale for this rule is that the
longest chain corresponds to the biggest amount of work on the
cryptographic puzzles; by including this branch and discarding
shorter branches, we are wasting the least amount of work.
Eventually, the local copies converge to the same global state.
In the example of Figure 7, Block 3 points to Block 2a
as its predecessor while ignoring Block 2b. This may happen
because the miner creating Block 3 received 2a before 2b.
In this case, Block 2b is discarded according to the longest
chain rule despite being valid and veriﬁed. It is called a stale
(sometimes called orphan) block [66].

the blockchain state. A node may attempt

It should be noticed that because the convergence of the
local copies is only eventual, this complicates the reasoning
about
to infer
information about the global state based on the local copy,
without any consultation with other nodes. The most common
case of inference is when a node tries to establish whether
a given transaction has been included in the blockchain. The
inference is correct with a certain probability, which never
reaches 100%: A transaction A may be included in a block
and added to the local copy, but at a later time, a different
branch may become the longest and win the race, in which
case A will not be included in the chain. However,
the
more subsequent blocks are added to the local copy after
the block BA containing A, the longer the branch in the
local copy becomes, which reduces the probability that a
competing branch not including BA will become longer yet.
In Figure 7, transaction A (TX A) and transaction B (TX B) are
included in Block 2a and Block 2b respectively. The inclusion
probability of transaction A in the main chain is increased
by creating Block 3 upon Block 2a, while, the chance of
inclusion in the chain for transaction B is reduced since it is
not included in the longer chain. A more precise calculation
of probabilities for the ﬁnality of transaction inclusion can be
found, e.g., in [67]. Bitcoin nodes use this reasoning to provide
a conﬁrmation about the inclusion of transactions: after 6
subsequent blocks are included into the local copy, the node
considers the probability high enough to send a conﬁrmation
to the user. For example, a transaction may transfer a fee in

bitcoins to a service provider.

However, a malicious node that owns more than 50% of the
network mining power, may overcome the network by mining,
producing valid blocks, and building longest chains faster than
the rest of the network. In particular, it gains the ability to
tamper with the data and subvert the blockchain. This situation
is called a 51% attack. The miner performing the attack
can exploit the situation in different ways, such as ignoring
some speciﬁc transactions or depriving the competing miners
from receiving block creation rewards. It can also deﬁne a
new policy and impose it onto the network. As an example,
the exact amount of block creation reward is conﬁgurable
and subject to an agreed policy. An attacker will be able to
increase the block creation reward in hope that the attacker
will be mining most blocks and ripping the beneﬁts of a higher
reward. Furthermore, the attacker that owns more than 50%
of the network mining power can perform a double-spending
attack, that is to transfer the same virtual coin in two different
transactions. For example, an attacker creates one transaction
to send some bitcoins to a recipient in exchange for a service
or product. This transaction is included in Block 2b, which is
appended to the blockchain. Let us denote the predecessor of
Block 2b as Block 1 (see Figure 7). After receiving the service
or product from the recipient of the transaction, the attacker
creates another transaction that sends the same bitcoins to a
different address of his own. The powerful attacker quickly
creates and mines Block 2a with the new transaction, and then
creates and mines Block 3 as a successor of Block 2a, in order
to ensure that Block 2a is included in the longest branch, and
that Block 2b becomes stale. As a result, the attacker gets the
service or product without paying any bitcoins for it.

The probability of a 51% attack being successful depends
on a number of factors [68], above all those contributing to
the presence of forks. The situation illustrated in Figure 7 is
undesirable from the security point of view. This is because
Block 2b does not contribute to securing the main chain so that
the attacker requires less mining power to subvert the chain. To
capture this point, [69] has introduced the metric of mining
power utilization, which is deﬁned as the ratio between the
mining power that secures the main chain and the total mining
power. Mining power wasted on work that does not appear
on the blockchain accounts for the difference. The higher the
mining power utilization, the more mining power an attacker
must have in order to subvert the chain.

The argument of mining power utilization is the main
reason against reducing the complexity of PoW in Bitcoin.
Even though such a reduction may improve the throughput of
transactions and reduce transaction conﬁrmation time (that is
the time required for a transaction to reach a certain probability
threshold for being included in the chain), it will lead to
signiﬁcant forking and reduced security [68], [70].

The subject of block size is a hotly debated topic in Bitcoin
where no common view has been reached. Original Bitcoin
design by Satoshi Nakamoto has introduced a limit on the
maximum block size; this limit still applies. A bigger block
size would allow more transactions to be included in the

block, thereby improving the throughput of transactions. On
the other hand, a bigger block would potentially increase the
block propagation time (see Section IV-C), which may give
an advantage to the miner of the current block who can start
mining the next block earlier before it is disseminated to other
miners. This may potentially increase the centralization in the
Bitcoin network. However, the exact effect of the latter is very
difﬁcult to capture and analyze without deployment, which
contributes to the controversy; some believe that a limit on the
block size is artiﬁcial and can be relaxed or even eliminated.
An attack strategy called selﬁsh mining [71] was proposed
to show that even with less than half of the network’s mining
power, misusing of the Bitcoin’s longest chain rule is possible.
The principal claim of this work is that a selﬁsh mining
pool with 1/3 mining power of the network can still defeat
the honest mining protocol, and the revenue of a selﬁsh
pool rises superlinearly as the pool size grows. However,
some researches such as [72] and [73] refute selﬁsh mining
strategy’s assumptions and beneﬁts, and claim that there is
no advantage for a selﬁsh miner to follow the attack strategy
instead of the honest one. Selﬁsh mining has not been observed
in the Bitcoin network in practice which reinforces these
claims. Even if a selﬁsh mining attack succeeds in the short
term, it may lower the value of Bitcoin, which further reduces
the beneﬁts of the attack compared to honest mining.

2) Updating blockchain in Ethereum: Conceptually,
the
protocol of updating the blockchain in Ethereum is similar
to that of Bitcoin: Both systems are permissionless and use
mining. Both systems use the same entities that play the same
roles. In both systems the miners propose new blocks of
transactions. In both systems the full nodes maintain local
copies of the ledger which eventually converge but may
temporarily diverge.

At the same time, the two systems exhibit signiﬁcant differ-
ences related to the design goals and choices, and deployment
characteristics, as we elaborate below. These differences affect
both performance metrics (such as transaction throughput,
transaction conﬁrmation time and chain convergence speed,
and energy consumption) as well as system security and the
risk of centralization.

With respect to design goals, Ethereum supports general
transactions written in a Turing-complete programming lan-
guage. This means that the execution of transactions them-
selves is more resource- and time-consuming in Ethereum
compared to Bitcoin. This leads to reduced throughput and
increased energy consumption. Since executing transactions is
unlikely to be as computationally intensive as solving cryp-
topuzzles, the effect is likely to be less pronounced compared
to that of PoW. However, it has never been analyzed. Another
interesting aspect of Turing-complete transactions is that it
becomes absolutely essential to limit a block. However, unlike
in Bitcoin, it does not make sense to express the limit in bytes
because the block size is no longer the main limiting factor.
Instead, the limit is speciﬁed in the amount of computation
required, which is expressed in the maximum amount of
Ethereum gas consumed. Of course, the limit on the amount of

unrewarded.

Secondly, both the original GHOST protocol and the version
used in Ethereum consider the uncle blocks and merge the
amount of work that has been done for each block in different
branches in order to choose the main chain. For example,
in Figure 8, the main chain is chosen based on the GHOST
protocol, and the result is different from the longest chain rule.
The algorithm starts from Block 0 and at each fork, chooses
the block leading to the heaviest subtree. In the given example,
the subtree of Block 1a contains 4 blocks, while the subtree of
Block 1b (prior to the inclusion of the new block) consists of
5 blocks. Assuming that each block has the same cryptopuzzle
complexity, Block 1b will be chosen. According to the same
rule, Blocks 2c and 3b are included in the main chain. Then,
a miner that wants to propose a new block, will choose Block
3b as the predecessor.

The original GHOST protocol additionally considers trans-
actions in uncle blocks when computing the blockchain state.
This element is not present in Ethereum.

Since the stale blocks are adding to the weight of the main
chain, forks are less affecting mining power utilization in
Ethereum compared to Bitcoin [75], which makes the main
chain more secure and reduces the risk of centralization. As a
consequence, Ethereum can afford shorter block creation time,
which results in a higher number of forks but also better decen-
tralization, transaction throughput, and conﬁrmation time [68],
[70]. Speciﬁcally, the average time to solve a cryptopuzzle
is 12-15 seconds in Ethereum compared to 10 minutes in
Bitcoin [76].

Regarding the conﬁrmation time, an Ethereum node con-
ﬁrms inclusion of a transaction after 12 subsequent blocks
are included into the local copy of the blockchain [77], in
contrast to 6 blocks in Bitcoin. The probability of a transaction
inclusion being ﬁnal has not been analyzed as thoroughly
for Ethereum as it has been for Bitcoin. However, as the
Ethereum’s block creation time is shorter compared to Bit-
coin’s, Ethereum transactions are conﬁrmed faster.

Finally, the characteristics of the main Ethereum deploy-
ment, namely the Ethereum network, distribution of the mining
power across the miners, and the rate and computational
requirements of transactions have a non-trivial impact on the
performance and security metrics. As a result, each metric is
affected by a multitude of factors as illustrated in Table VI.
The volume of studies quantifying the effect of each factor
on each metric is limited. However, the empirical study of
various metrics in Ethereum is available in [58]. This work
shows, e.g., that the mining power utilization in Ethereum is
97% compared to 99% in Bitcoin. Besides, the throughput in
Ethereum is 15 transactions per second [78] compared to 7
transactions per second in Bitcoin [79].

3) Updating blockchain in Hyperledger Fabric: The con-
sensus protocol in Hyperledger Fabric is fundamentally differ-
ent from those in Bitcoin and Ethereum. First, the entities are
different as explained in Section III-C. Second, Fabric provides
the ability to partition a consortium network into independent
channels so that each channel can execute a consensus protocol

Figure 8. Ethereum chooses the main chain based on the GHOST protocol.
Uncle blocks are considered when choosing the main chain (the heaviest chain
rule) and their miners are rewarded in Ethereum.

computation also indirectly restricts the length of transactions
and their number in a block and thereby, the block size.
In September 2019, the average block gas limit was around
10,000,000 gas, which translated to the average block size of
between 20 to 30 kilobytes in size, based on the transaction
rate and transaction computational requirements in Ethereum
at that point in time.

Another difference in design goals is that Ethereum supports
more complex state storage (see Section IV-B1), which results
in bigger block sizes compared to Bitcoin. While this has
an impact on most performance metrics, the exact effect has
never been scientiﬁcally studied. Besides, bigger blocks may
increase the risk of centralization, as we explained for Bitcoin
in Section IV-D1.

Regarding design choices, Ethereum uses a somewhat dif-
ferent conﬂict resolution rule and a block reward model, as
well as less complex cryptopuzzles. Besides, a higher number
of subsequent blocks is required for transaction conﬁrmation
in Ethereum compared to Bitcoin. We now consider these in
detail.

For conﬂict resolution, Ethereum is using a modiﬁed version
of Greedy Heaviest Observed Subtree (GHOST) protocol [68]
instead of the longest-chain rule. This fact is mentioned in [74]
without comparing the original version of the GHOST protocol
with the version used in Ethereum. We believe that our analysis
below provides the ﬁrst complete comparison in the literature.
The ﬁrst point of departure in all versions of the GHOST
protocol compared to Bitcoin is that the miner producing a
block is incentivized to reference a limited number of stale
blocks, in addition to the previous block. In Ethereum, the
miner can speciﬁcally reference up to two stale blocks from
the header of the newly generated block, as shown in Figure 8.
The miner is incentivized to do so by increased block creation
reward for each referenced stale block. A stale block that is not
included in the main chain but referenced by a main chain’s
block is called uncle or ommer block in Ethereum. In the
example of Figure 8, Blocks 2b and 2d are uncle blocks for
the new block. The uncle block’s miner is also compensated,
so that the miner’s effort of producing the block does not go

Table VI
HOW DIFFERENCES FROM BITCOIN AFFECT VARIOUS PERFORMANCE AND SECURITY METRICS IN ETHEREUM

Factor
General transactions
Complex storage
Considering uncles
Less complex cryptopuzzles
Deployment characteristics

Throughput Conﬁrmation time Energy consumption Decentralization and Mining power utilization
worsens
worsens
unknown
improves
unknown

worsens
worsens
unknown
improves
unknown

worsens
worsens
unknown
improves
unknown

worsens
worsens
improves
worsens
unknown

in parallel and independently of other channels. In a sense,
there is a separate ledger maintained for each channel. Besides,
only authorized nodes can participate in the consensus for
each channel, as determined by the consortium policies and
related channel conﬁguration. Third, the consensus protocol
in Fabric is deterministic unlike Bitcoin and Ethereum where
there could temporarily be divergent branches of the ledger
that eventually and probabilistically converge. In Fabric, there
could be no divergent branches and the transaction becomes
ﬁnal and 100% conﬁrmed relatively fast.

A different class of consensus protocols leads to a re-
markable contrast in performance characteristics. As discussed
in Sections IV-D1 and IV-D2, Bitcoin and Ethereum can
achieve throughput of 3–7 and 12–15 transactions per second
respectively when updating the ledger. On the other hand,
[80] has shown that the throughput in Hyperledger Fabric
can reach many thousands of transactions per second with
speciﬁc optimizations in place, as we discuss in the later part
of this section. While providing a high transaction rate, the
deterministic consensus protocol in Fabric does not scale well
w.r.t. the number of nodes participating in any single channel.
At the same time, the probabilistic consensus protocols of
Bitcoin and Ethereum can handle the scale of many thousands
of nodes, which is beyond the reach for Fabric [62].

Ledger update in Fabric is performed in three phases called
proposal, ordering, and validation [56]. In the proposal phase,
clients send every transaction proposal to the endorsers (see
Section III-C), which are responsible for simulating the trans-
action without updating the database. The endorsement policy
speciﬁes which endorsers a transaction is sent to for approval,
and how many endorsements are needed for a transaction.
For example, a policy can specify that m signatures out of
n endorsers are enough for a given transaction to proceed to
the ordering phase.

During the ordering phase, the orderer service runs a con-
sensus protocol and decides on the order in which concurrent
endorsed transactions will be executed and added to the
ledger. Hyperledger Fabric uses pluggable modules for the
ordering service which allows for signiﬁcant conﬁgurability.
Currently, the Raft [56] implementation based on the Raft
protocol [81] is the recommended option due to being easier to
set up and manage compared to the alternatives [56]. However,
PBFT [82], Apache Kafka [83], BFT-SMaRt [84], SBFT [85],
and other implementations can also be used as the orderer
service for Hyperledger Fabric. The choice of the implemen-
tation and speciﬁc consensus protocol may signiﬁcantly affect
the throughput of adding transactions to the ledger.

Additionally, the resilience of the entire ledger update pro-
cedure is mainly inherited through the fault-tolerant guarantees
offered by the chosen ordering protocol. The two most popular
families of protocols for implementing ordering are Paxos and
View-stamped replication [86]. Both protocols tolerate crash
failures when the number of faulty processes is below n/2,
where n is the total number of participating nodes. To tolerate
byzantine failures, ordering protocols such as BFT-SMaRt [84]
or PBFT [82] can be employed [63]. These protocols work
when the number of faulty processes is below n/3.

Then, in the validation phase, the orderer service sends
the block containing ordered transactions to the peers, and
the peers validate the correctness of transactions. Transactions
successfully validated and committed at this stage are never
revoked, which means that their inclusion into the chain is
ﬁnal and deterministic.

It is interesting to observe that in Bitcoin and Ethereum,
the block proposer (miner) broadcasts the blocks only after
transactions in the block are valid. In
verifying that all
contrast,
the block proposer (orderer) in Fabric does not
validate transactions while the blocks are created in phase
two. Transaction validation only happens at the proposal (ﬁrst)
phase by the endorsers and at the validation (third) phase of the
consensus protocol. While this makes the protocol susceptible
to denial-service of attacks by polluting the blocks with invalid
transactions, the permissioned access allows Fabric to make an
assumption that there is no signiﬁcant incentive for the entities
participating in the consensus protocol to launch a deliberate
security attack. The design decision to ofﬂoad the transaction
validation task from the block proposer confers performance
beneﬁts in terms of higher throughput at the cost of ledger
potentially storing invalid transactions.

[87] shows a number of interesting performance character-
istics of the Hyperledger Fabric as follows. First, there is a
saturation point for throughput at around 140 transactions per
second (tps). When the transaction arrival rate reaches the
saturation point, the commit latency of blocks is increased
from 100ms to tens of seconds. The raise in the latency is
due to the increased number of ordered transactions waiting
in the queue for the peers to validate their correctness in the
validation phase. In other words, the validation phase becomes
the bottleneck. Furthermore, when the transaction arrival rate
is lower than the saturation threshold, the increase in block
size leads to the increase in the block creation time in the
orderer phase which in turn impacts the transaction latency.
Additionally, when the arrival rate is 50 tps, the increase in the
block size from 10 to 100 causes transaction latency increase

by a factor of ﬁve from 242ms to 1250ms. On the other hand, it
has also been demonstrated that when the transaction arrival
rate is higher than the saturation threshold, the increase in
block size leads to decreased transaction latency and enhanced
throughput. This is due to the fact that the time taken to
validate and commit one large block is shorter than the time
taken to validate and commit many small blocks.

Additionally, [87] has demonstrated that heterogeneity in
the resources of peers and networks of organizations leads
to performance degradation. Furthermore, this work shows
that increasing the number of channels, using fewer endorsers,
and performing bulk read/write operations contribute to better
throughput and reduced latency in Fabric.

Moreover, [80] uses common system optimization tech-
niques to achieve end-to-end transaction throughput of around
20,000 transactions per second. Examples of these techniques
include separation of concerns (separating metadata from
data while creating blocks in the ordering service), using
parallelism and caching during the transaction validation,
and replacing the database of worldstate with lightweight in-
memory data structure such as hashtable. One of the key
assumptions in [80] towards achieving high throughput
is
that
the incoming transaction workload is contention-free.
When there is a high contention and a large number of
incoming transactions compete for a small set of hot keys
in the worldstate, the throughput drops down signiﬁcantly as
discussed in [88].

[88] proposes changes to the transaction ﬂow in Hyperledger
Fabric to handle both high and low contention transaction
workloads. [88] shows that its transaction throughput (3000
transactions per second) is signiﬁcantly better than in Fabric
and [80] when the workload exhibits high contention. One of
the key design ideas in [88] is to separate the dependent and
independent sets of transactions in the block and process both
sets concurrently during the validation phase. To realize this
idea, a transaction dependency analyzer is introduced, whose
goal is to isolate the transactions that are having overlap on
the keys of their R-W sets with transactions that do not have
any overlaps. As a consequence, the knowledge regarding the
subset of transactions that can be processed concurrently is
gained. The dependent transactions are marked invalid in the
R-W set validation and will be re-executed on the latest version
of the worldstate. The independent set of transactions that are
marked valid can be successfully committed concurrently.

it

in IOTA is probabilistic,

4) Updating blockchain in IOTA: While the consensus
protocol
is different from the
protocols in Bitcoin and Ethereum in many respects. Neither
the concept of miner nor the chain of blocks exist in the IOTA
network. As it is explained in Section IV-B, IOTA utilizes
a specially crafted DAG called Tangle instead of a chain of
blocks. In a Tangle, vertices represent bundles (or transactions)
while the edges signify approval of the bundles (see Figure 9).
A Tangle starts with a genesis bundle and grows as new
bundles are added, each new bundle having to validate and
approve two bundles already included in the Tangle. Similar
to the ledger in Bitcoin and Ethereum, each node participating

in the IOTA network maintains its own copy of the Tangle
and synchronizes it with other nodes; these copies may be
temporarily diverging. Figure 9 illustrates a situation where
participating nodes 2 and 3 have a partial knowledge of the
Tangle while node 1 possesses combined knowledge.

In IOTA, every node x that wants to issue a transfer of funds

has to perform the following sequence of actions:

Bundle creation: x creates a bundle including all input
and output transactions that together constitute the transfer
(see Section IV-B4). For example, node 1 creates bundle O in
Figure 9.

Weight assignment: x decides upon an integer weight w
for the bundle. A bigger weight results in a probabilistically
faster conﬁrmation for the bundle (as we explain below) at the
expense of a more signiﬁcant computational effort for x.

Cryptopuzzle solution: x needs to solve a cryptopuzzle
for each of the bundle’s transactions. The difﬁculty of the
cryptopuzzle is proportional to w selected by x. It is however,
signiﬁcantly lower compared to Bitcoin and Ethereum because
in the latter, the cryptopuzzles regulate proposal creation rate
while in IOTA they only prevent DoS attacks.

Tip selection: x selects two tips to approve where the tip is
a bundle already included in the Tangle but not yet approved
by any other bundle. For examples, bundles G, H, I, and
N are tips in Figure 9. To this end, x runs a tip selection
algorithm [26] twice, once for each tip. We describe the tip
selection algorithm in detail below. In addition to the tip itself,
the algorithm selects a path from the genesis bundle to the tip.
Validation: First, x validates the integrity of every bundle
on the two selected paths. If any structurally invalid transaction
or bundle is found, it is excluded from the Tangle. Secondly, x
validates that the two paths contain no conﬂicting bundles that
lead to double-spending. To detect possible double-spending
or prevent spending a larger sum than what is available in
an account, x needs to keep values of all addresses in all the
veriﬁed bundles on the two selected paths. If any of the values
turns negative, then we know that the paths include conﬂicting
transactions but we do not necessarily learn which transactions
are conﬂicting.
If the validation fails because of any of the above two issues,
the tip selection algorithm is invoked again to ﬁnd a different
pair of tips and paths. Then, the validation is performed for
the new pair of paths. This happens repeatedly until a valid
pair is found. Some additional optimizations are implemented
in case of structurally invalid bundles, which we do not cover
in our description.
In Figure 9, no bundle violates structural integrity but bundles
D and D(cid:48) are conﬂicting. In this case, node 1 selects a new
pair of tips as shown in Figure 10. The new pair of paths
passes the validation so that the algorithm stops.

Bundle propagation: x propagates the new bundle along
with the id of the two selected tips using the communication
layer. Interestingly, a proof of neither correct tip selection nor
performed validation is supplied in the message. When a node
other than x receives the bundle from the communication
it performs the cheaper integrity validation for that
layer,

Figure 9. Every node has its own copy of the Tangle; copies might be diverging

bundle. However, it does not perform an expensive detection of
double-spending nor does it traverse any path from the genesis
block to the new bundle.

Monitoring of conﬁrmation and reattachment: The val-
idation and tip selection algorithms include a lot of random-
ness as we discuss below. Because of this randomness, some
bundles may get conﬁrmed much faster than the others, while
some valid bundles may in fact be never conﬁrmed and be
left behind. In view of this, x needs to monitor the Tangle
for signs of conﬁrmation, which we also discuss below. IOTA
introduces the concept of reattachment: node 1 may create a
new bundle in the future that speciﬁes the very same transfer
as bundle O in the illustration, and inject this new bundle into
the Tangle by performing all the above steps. In this case, the
new bundle will be conﬂicting with O so that node 1 should
only do it if O is not getting conﬁrmed for a long period of
time.

The tip selection algorithm is essentially a weighted random
walk through the Tangle starting from the genesis bundle
and moving toward the tips. At each step,
the algorithm
proceeds from the current bundle to one of the bundles directly
approving the current bundle. The probability of choosing a

bundle as next step is proportional to the cumulative weight
of that bundle. The cumulative weight of each bundle Y is
equal to the own weight of Y plus the sum of own weights
of all bundles that directly or indirectly approve Y . Figure 9
illustrates the cumulative weight of each bundle (denoted as
cw inside the bundles) as calculated by node 1 (the values for
nodes 2 and 3 will be different). For instance, the cumulative
weight of A is equal to the sum of weights of bundles C, D,
E, F , G, H, I, J, D(cid:48), K, L, M , and N . When the random
walks determines the next step from the genesis bundle, it will
make a probabilistic choice between bundles A and B based
on their cumulative weights (of 21 and 23 respectively). The
random walk stops when it reaches one of the tips.

Based on the above algorithm, it is clear that choosing a
bigger weight for a new bundle increases the probability of that
bundle to be selected by the random walk performed during
the tip selection. This ultimately results in probabilistically
faster conﬁrmation for a bundle with a large weight.

Besides, it is obvious that the cumulative weight of a bundle
incrementally increases as it is getting approved directly or
indirectly by new bundles added to the Tangle. As a result,
the cumulative weight can be used as a metric for conﬁrming

Figure 10. Choosing a pair of tips happens repeatedly until a valid pair is found

bundle inclusion in the Tangle, similarly to how the number of
subsequently added blocks is used as a metric for conﬁrming
block inclusion in Bitcoin and Ethereum. This is important,
e.g., when a node decides to reattach the bundle. Notably,
heavy bundles tend to gain the weight faster due to the
weighted random walk. In some scenarios, this may lead to
situations when a bundle is never conﬁrmed, thereby rendering
the reattachment mechanism essential. However, as the number
of users and transactional rate in the network increase, the
probability and speed of conﬁrming any bundle regardless of
its weigh grow.

Apart from the cumulative weight,

there exists another
metric in IOTA used for monitoring bundle inclusion. The
metric is called conﬁrmation conﬁdence and denoted cc in
Figure 9. The conﬁrmation conﬁdence of a bundle is the
percentage of the tips which directly or indirectly approve the
bundle. In Figure 9, if we consider the Tangle status on node
1 before O is included, the conﬁrmation conﬁdence of bundle
D is %75 because among the four tips of G, H, I, and N ,
G, H, and I are approving D while N is not. Note, however,
that conﬁrmation conﬁdence is not always a good indicator
of bundle inclusion if the Tangle copies on different nodes
are diverging. For example, the conﬁrmation conﬁdence for

bundle K is %100 on node 3 but this is only because node 3
does not know about bundles G, H, and I yet.

In terms of Tangle security, several attacks and defenses
have been considered in the literature [26], [21]. The replay
attack [89], [90] performs double-spending by exploiting the
reattachment mechanism: the reattached bundle normally in-
validates the original bundle but in the attack, both bundles re-
main valid, which results in double-spending. The attack only
works under reuse of addresses, which is within the control
of the users and which the users should strive to avoid as per
IOTA recommendation. In the parasite chain attack [26], [91],
the attacker aims to replace the current Tangle with its own
subgraph, which the attacker builds in secret while taking steps
to ensure that the secret subgraph will have sufﬁciently high
cumulative weights. To perform double-spending, the attacker
initiates two conﬂicting transactions. The ﬁrst transaction is
injected into the current Tangle while the second transaction
is included into the secret subgraph. After the ﬁrst transaction
is conﬁrmed and the attackers receives the services or beneﬁts
for the payment, the attacker broadcasts all bundles in the
secret subgraph, which replaces the Tangle. This way the
attacker gets the second transaction conﬁrmed as well. In the
splitting attack [26], [92], the attackers partitions the Tangle by

making sure that two subgraphs within the Tangle maintain a
similar cumulative weight over time, and injecting transactions
so as to maintain this balance. Such partitioning allows the
attacker to perform double-spending by placing two conﬂicting
transactions, one in each subgraph.

The author of [26] proposes the following idea to defend
against the parasite chain and splitting attacks. The probabilis-
tic choice of the next step in the random walk is governed by
parameter α in addition to the cumulative weights of candidate
nodes. A big value of α means that the node with a larger
cumulative weight wins with a very high probability while
a small value of α means that the winning chance for a
heavier node is only slightly higher. This work shows that
a large value of α reduces the risk of successful parasite
chain and splitting attacks. Unfortunately, larger values of α
increase the probability for a bundle to be left behind and never
conﬁrmed [93], [91]. In [91], the authors propose a detection
mechanism for parasite chains, with the idea of using smaller
values of α in a normal situation but adaptively increasing
the values if a parasite chain is detected. A different idea
advocated in [93] is to modify the tip selection algorithm so as
to explicitly search for left-behind tips and increase the chance
of their selection.

Since the tip selection and validation are nontrivial algo-
rithms in IOTA, it is interesting to consider incentives to
perform them for node x that wants to issue a new bundle. This
is especially important because during the bundle propagation
phase, x does not supply any proof of correct tip selection and
validation. However, while a node receiving a bundle from x
does not perform a random walk with validation immediately,
it will do so upon creating its own bundle in the future. If
x does not perform the validation properly and approves two
tips from two traversal paths that are conﬂicting, this may
also negatively affect the probability of conﬁrmation for the
new bundle produced by x. In the illustration of Figure 9,
if O approves G and N , then the conﬂict between D and
D(cid:48) may be discovered by a later random walk, which will
reduce the probability of O to be selected. However, there
are multiple paths from the genesis bundle to O that do not
traverse D and D(cid:48), in which case O may still be selected.
Note that if a conﬂict between D and D(cid:48) is later detected by
other nodes, it is impossible for them to establish whether x
deliberately neglected validation or simply was unlucky with
detection because x selected non-conﬂicting paths leading to
G and N during its random walk. The exact quantiﬁcation
of the reduction in conﬁrmation probability requires a very
complex probabilistic analysis, which has not been performed
in the literature to the best of our understanding.

In the context of tip selection, different tips have different
probability to be reached by the random walk. If x just
arbitrarily selects two tips without performing the random
walk, this may result in reduced probability for the new bundle
to be reached by the random walk performed by other nodes
at a later point. As a result, x will be punished by a higher
conﬁrmation time. On the other hand, x may minimize the
conﬁrmation time for its bundle by performing a deterministic

walk which selects a node with the biggest cumulative weight
at each step. Eliminating the randomness during the walk may
exacerbate the problem of heavy nodes gaining weight very
fast, resulting in a higher number of reattachments. There exist
considerations, however, that detract from the beneﬁts of such
a selﬁsh node strategy, as outlined in [26].

The consensus algorithm in IOTA is relatively lightweight
and scalable in the sense that it can sustain a higher rate of
adding new transactions to the storage and conﬁrming them.
This improvement eliminates the need in two design elements
in the other three systems we consider: batching
present
transactions into a block and having long intervals between
consecutive blockchain updates. As a result of allowing shorter
intervals between updates, PoW is much more lightweight
in IOTA compared to Bitcoin and even Ethereum. Currently,
IOTA has achieved a throughput of above 500 transactions
per second under a stress test [94]. These advantages do come
at a cost. Since discovery of conﬂicts is probabilistic, it may
take a lot of time until double-spending is discovered. The
Tangle storage requires more space compared to systems that
use a chain of blocks, as explained in Section IV-B2. Most
importantly, the paths produced by the tip selection algorithm
become long as the Tangle grows, resulting in a very expensive
veriﬁcation procedure.

To address the challenge of scaling the Tangle and the
validation algorithm, IOTA employs a snapshot process that
prunes the transaction history (see Section IV-B8) and shortens
validation paths by creating a new snapshot bundle that effec-
tively serves as a new genesis bundle. The snapshot process is
periodically performed by the IOTA Foundation, which goes
against the blockchain spirit of eliminating the trust in any
single entity or organization. The Coordicide project [95] is
focused on removal of coordination and in particular, the need
for a snapshot process.

5) Defense against DoS attacks: DoS attacks in Bitcoin,
Ethereum and IOTA are mitigated by the Proof-of-Work mech-
anism. As discussed in Section III-A, a PoW algorithm re-
quires solving cryptographic puzzles for creating new blocks.
If a message with a new block or transaction does not contain
a valid solution to a cryptopuzzle, the message is rejected
without further processing, which makes it easier for the
system to ﬁlter out spurious messages.

However, PoW requires a signiﬁcant amount of energy [96]
and wasted computation performed by legitimate miners.
Proof-of-Stake (PoS) protocols were developed as energy-
saving alternatives to PoW [97]. Instead of solving a cryp-
topuzzle as in the PoW, a block creator is selected based on
its stakes (the number of digital tokens that it holds) in PoS.
As there is no heavy computation process in PoS, the block
creation time is much shorter than in PoW, thereby resulting
in a higher transaction throughput. In order to prevent DoS,
a block proposer needs to make a deposit to gain the right
to make a proposal. Since the deposit is locked until the next
block is selected, this makes it more expensive for the miner
to create multiple proposals within a short period of time.
Besides, the deposit can be conﬁscated for malicious behaviors

such as performing a DoS attack.

The Ethereum network has developed the Casper proto-
col [98] in an attempt to ease the transition from the current
PoW protocol to a pure PoS protocol. Ethereum 2.0 will
deploy the Casper protocol on top of the existing PoW
protocol, prior to switching to a pure PoS protocol in future
releases. So, while blocks are still going to be mined via PoW
in Ethereum 2.0, every ﬁxed interval (every 50 blocks [99])
is going to be a PoS checkpoint where the ﬁnality of blocks
is assessed by a dynamic committee that votes via a BFT
protocol. To join the committee, a validator has to make a
deposit to gain a voting right proportional to that deposit.

An additional vector of attacks for a user in Ethereum is to
inject a computationally- or storage-expensive transaction that
would consume resources on all of the nodes in the network.
The gas budget concept (see Section III-B) plays an essential
role in defending against this attack: the attacker itself would
need to pay a substantial amount of gas in order to launch the
attack.

While IOTA is using PoW as well, the cryptopuzzles in
IOTA are much simpler compared to Bitcoin and Ethereum
which leads to a higher throughput. The reason for choosing a
lower-difﬁculty PoW in IOTA is that IOTA uses PoW just as
a spam protection [95]; whereas, in Bitcoin and Ethereum,
PoW is additionally used for controlling the rate of block
production. On the other hand, a separate PoW is required
for each transaction in a bundle since a bundle may theo-
retically contain an unlimited number of transactions. While
the current implementation of IOTA is utilizing a simple PoW
mechanism, the IOTA Coordicide [95] project has proposed an
adaptive rate control mechanism which intelligently adjusts the
difﬁculty of the PoW per node based on different factors, such
as a number of recently-issued transactions and reputation of
the issuer [95].

Hyperledger Fabric does not have a single main deployment.
Instead, there is a multitude of proprietary deployments, where
each deployment is partitioned by channels (see Section IV-C).
Besides, the system is permissioned and requires authorization
for joining each channel. These factors signiﬁcantly mitigate
the risk of DoS attacks.

6) Querying blockchain:

In Section IV-B, we describe
different data items stored by the data recorder nodes of each
blockchain system. Any data stored by the recorder nodes
can in principle be locally queried by those nodes. If a data
recorder node acts as a query responder, it can essentially
answer any queries related to the stored data that are initiated
by query issuers.

However, the fact that the data is stored does not nec-
essarily mean that there exist means to query it efﬁciently.
The functionality of blockchain systems is different compared
to general-purpose databases (see Section II-A). The native
implementation of most blockchain systems only efﬁciently
supports limited queries as simple as retrieving a data item
by its hash code. The main reason for the limited support
of queries is the limitations in the default database imple-
mentation of the blockchain systems. For example, levelDB

used in Bitcoin, Ethereum, and Hyperledger Fabric as a key-
value database supports only querying based on keys. Another
reason is the way of utilizing the database for storing and
accessing data. For example, retrieving values in Ethereum
requires traversing multiple trie structures (see Figure 4 in
Section IV-B5), and accessing values associated with the
queried hash code (i.e. the key) requires searching multiple
keys over the disk, which is time-consuming [100].

Due to these reasons, supporting analytical and complex
queries (querying based on values other than keys) such
as ﬁlter, aggregation, and sorting queries on the blockchain
systems require some extra considerations and functional com-
ponents. The modularity of Hyperledger Fabric and its focus
on highly conﬁgurable proprietary deployments allow for
modifying the native implementation. Speciﬁcally, replacing
the default database module of LevelDB with CouchDB allows
for supporting more complex search semantics in an efﬁcient
way [44]. For example, as CouchDB allows storing data in
JSON format, it is possible to query by data values, and not
just by keys. The tradeoff, however, is that CouchDB requires
more disk space for storing the data compared to LevelDB.

Research proposals of adding an extra query layer to ex-
isting blockchain systems have also emerged. For example,
EtherQL [100] supports a set of analytical queries such as
aggregation and top-k queries on top of Ethereum. These
proposals, however, have not been implemented in the actual
systems as of 2021.

The most common way of solving the issue of rich query
semantics is designating a subset of data recorders as dedi-
cated query responders (see Section II-C). In practice, query
responders maintain a separate database in addition to the
blockchain data, which allows them to answer richer queries
efﬁciently. Such designated query responders are used in Bit-
coin, Ethereum, and IOTA. Blockchain.com [101] and ether-
scan.io [102] are websites that allow anyone to search for a
speciﬁc address, transaction, or block on Bitcoin and Ethereum
databases respectively. However, these sites do not provide
more advanced search functionalities such as looking for trans-
actions with a speciﬁc amount of input. Some other services
store the blockchain in an SQL database and provide the ability
to issue general SQL queries. Notably, BlockchainSQL [103]
does it for Bitcoin while Anyblock.tools [104] provides such
a service for Ethereum and some other blockchain systems.
IOTA foundation provides a website (explorer.iota.org [105])
as an external dedicated service for querying IOTA. This web-
site supports basic search functionalities for the IOTA Tangle
based on keys, such as searching based on a transaction hash,
a bundle hash, or an IOTA address. As an example, searching
for an IOTA address through this website gives information
about the balance of the address and all transactions related to
that address. thetangle.org [106] is another external dedicated
service for IOTA, which provides visualization for a number
of speciﬁc queries.

However, such designated query responders pose two major
challenges. First, the exact rich query semantics is up to a
speciﬁc implementation; it is not standardized in any way.

Table VII
CONTRACT LAYER OF DIFFERENT BLOCKCHAIN SYSTEMS

Features

Type

Bitcoin

Ethereum

Hyperledger Fabric

Scripting system

Smart contracts

Smart contracts packaged into a chaincode

IOTA
No support yet
(in progress)

Programming language

Forth-like

Turing completeness
Executing nodes
Execution language

No
Full nodes
Bitcoin script

Execution environment

Script interpreter

Several languages, Solidity as
the most popular one
Yes
Full nodes
Ethereum Bytecode
Ethereum Virtual
Machine

Go, Node.js, Java

Yes
Speciﬁed by endorsement policy
Programming language-dependent

Docker container

-

-
-
-

-

importantly,

they do not provide the
Secondly and most
security, dependability, and availability guarantees commonly
attributed to blockchain systems. This is because they are
managed by individual nodes that are fundamentally untrusted
in the blockchain paradigm. In particular, query responders can
decide on an access control policy that is not aligned with the
access control policy of a particular permissioned or permis-
sionless blockchain system. For example, Anyblock.tools pro-
vides different query services based on the paid subscription
tier of the users.

In summary, query responders serve two purposes: (a) to
provide rich query semantics otherwise unavailable in the
blockchain system and (b) to facilitate operation of lightweight
nodes that do not record all of the blockchain data.

E. Contract Layer

The contract layer allows users of the blockchain system
to develop programmatic extensions and install them atop
blockchain. Smart contracts are similar to distributed objects
in nature. A contract implements a collection of procedures,
each of which can be invoked remotely and executed as a
transaction. A contract may additionally invoke transactions
implemented by other contracts.

Features of the different blockchain systems in the contract
layer are shown in Table VII. As Bitcoin was designed with a
speciﬁc deﬁned application in mind, it does not implement
a general-purpose contract layer. Instead, it uses a simple
scripting system for its transactions. Each transaction con-
tains an output and an input script [22]. When a transaction
executes, its inputs are veriﬁed. Let us assume transaction
T1 has an input I, which is an output of transaction T0.
In this case, I is veriﬁed by executing the output script of
T0 followed by an input script of T1. By combining the
input script of the new transaction with the output script of
the referenced transaction, a full node can validate that the
new transaction can redeem the previous transaction output.
The reason for concatenating the input and output scripts
is that the output script speciﬁes the veriﬁcation procedure,
whereas the input script contains cryptographically secure
information about the redeeming node (speciﬁcally, the public
key and a signature of that public key), which is used as an
input to the veriﬁcation procedure. Bitcoin provides a default
implementation of an output script (called scriptPubKey) and
a default implementation of an input script (called scriptSig).
This default implementation tests if the hash of the provided

public key matches the hash in the scriptPubKey, and then
checks the signature against the public key to ﬁnally validate
the new transaction. Bitcoin full-nodes are responsible for
validating the transactions by executing Bitcoin scripts in their
script interpreter environment. The programming language of
Bitcoin scripts resembles Forth [107]. Similar to Forth, Bitcoin
scripts are stack-based and they use reverse-Polish notation
(processed from left to right). Since Bitcoin scripts are not
intended for writing general-purpose applications, they are
not Turing-complete [22]. In particular, the language does not
support jumps and loops so that malicious users cannot create
code that would waste the power and computing resources of
the Bitcoin network.

Instead of simple scripts, Ethereum utilizes smart contracts,
which can be used for implementing a variety of decentral-
ized applications. One of the main differences between the
Ethereum smart contracts and Bitcoin scripts is that smart
contracts are Turing complete, which is essential for a general-
purpose blockchain platform. When a contract procedure is
invoked, it is executed on top of the blockchain platform
by Ethereum full-nodes, using the Ethereum Virtual Ma-
chine (EVM) environment. As discussed in the storage layer
Section IV-B, a smart contract stores its own data. Remote
invocations that update the contract state are executed under
transactional semantics.

Currently, the most common and supported language for
writing smart contracts is Solidity [108], [109]. What makes
this language popular is that Solidity is object-oriented and
high-level, and it provides a rich support for developing
contracts. Solidity has similarities to C++, Python, and
JavaScript. LLL (a low-level Lisp-like language) [110] and
Vyper (Python-derived) [111] are other popular alternative
languages for writing smart contracts. A code written in any of
these languages needs to be complied to Ethereum Bytecode
in order to run in the EVM environment.

Hyperledger Fabric also has the concept of smart contracts,
similar to that of Ethereum. However, related smart contracts
can be grouped together and packaged into a chaincode in Fab-
ric; While smart contracts are governing transactions, chain-
code governs how smart contracts are packaged for deploy-
ment [112]. When a chaincode is instantiated on a channel, an
endorsement policy is deﬁned for it [112]. Therefore, the en-
dorsement policy applies to all smart contracts deﬁned whithin
the same chaincode in the context of a channel. In Fabric,
unlike Bitcoin and Ethereum, transactions and smart contracts

are only executed by endorsers (see Sections IV-D3 and III-C),
which create W-R sets. The other nodes validating or applying
the transaction only process W-R sets instead of executing the
code of the transaction. Currently, smart contracts of Fabric
can be written in Go, node.js, and Java [113], which are all
Turing complete languages. Endorsers execute the chaincode
and its smart contracts in a Docker container environment
corresponding to the contract programming language [113].
Docker container is an isolated sandbox inside the endorser
whose purpose is to prevent the chaincode from accessing the
endorser’s local environment and resources.

The IOTA foundation has stated that smart contracts will
not be a feature of IOTA core [114]. However, there are some
projects such as Qubic protocol [115] which aim to design a
contract layer on top of IOTA Tangle in order to deploy smart
contracts and other applications on it.

V. RELATED WORK

All published surveys on blockchain technology can be
categorized as surveys on individual aspects or on blockchain
as a whole. For the former survey type, [63], [116], [117], and
[118] concentrate speciﬁcally on the consensus mechanisms of
blockchain. In [119], [120], [121], and [122], the focus is on
the security analysis. Smart contracts are covered in depth in
[123] and [124]. Data management and analysis of blockchain
data are investigated in [125] and [126]. Network layer aspects
of permissionless blockchains are addressed in [127]. Surveys
of [128], [129], [130], [131], and [132] review integration of
blockchain with other technology, namely with edge comput-
ing, machine learning, cloud storage, cloud computing, and
cloud of things respectively. [133], [134], [135], and [136]
survey on applying blockchain to various application domains
such as IoT, healthcare, and smart cities.

In contrast, blockchain surveys of the second type provide
a general exposition of blockchain systems. However,
the
coverage signiﬁcantly varies across speciﬁc surveys. As our
paper falls in this category of blockchain surveys, we explore
the related surveys of this type in greater detail and compare
them with our work in the rest of this section (see Table VIII).
[19] has been one of the ﬁrst surveys on blockchains as
a whole. However, it is limited to the cryptocurrency use
case of blockchain. [19] reviews research perspectives and
challenges for Bitcoin and other cryptocurrencies. It focuses
on Bitcoin and presents transactions (including scripts), the
consensus protocol, and the communication network as the
main technical components. Incentivizing correct behavior in
Bitcoin, transition towards more powerful and energy-efﬁcient
customized hardware, and security issues of cryptocurrencies
are the other important aspects covered in [19]. [20] is another
technical survey on Bitcoin and cryptocurrencies similar to
[19]. Additionally, it includes a tutorial-style introductory part
and an in-depth overview of more recent existing literature.

The authors of [137] compare Bitcoin with Ethereum and
propose a design taxonomy based on this comparison. Discus-
sion of the architectural design in [137] is structured by topics
of decentralization, computation, infrastructural conﬁguration,

among others. Based on this discussion, [137] evaluates con-
sensus protocols and system performance. Bitcoin scripts and
Ethereum smart contracts are also compared as another princi-
pal aspect of blockchain in this paper. Similar to [137], [138] is
another survey using Ethereum and Bitcoin as a case study to
describe the inner workings of blockchain in detail. The survey
covers blockchain incentive structures, smart contracts, and
scalability issues such as transaction throughput and latency.
[139] is yet another comparison of Bitcoin with Ethereum
which considers a number of additional aspects: UTXO and
account model for tracking the states, different hardware used
for mining in Bitcoin and Ethereum, and the differences in
the network layer. Similarly to [137] and [138], consensus
protocol and scripting language of Bitcoin and Ethereum are
also reviewed in [139]. As another work that compares Bitcoin
and Ethereum, [145] introduces a quantitative framework to
analyze the security and performance implications of various
consensus and network parameters of PoW blockchains. Im-
pact analysis of parameter choices such as block interval, stale
block rate, and average block size on the network propagation
time and the throughput of PoW blockchain systems is one of
the main contributions in [145].

Lack of formalization and standardization in blockchain
technology has prompted a research on ontologies that aim at
providing a vocabulary of key blockchain terms. A high-level
ontology for concepts and deﬁnitions without technical details
is proposed in [140]. A more technical ontology is introduced
in [141]. Furthermore, this work provides an overview of
a number of blockchain components with the main focus
on Bitcoin and Ethereum, namely of consensus, transaction
model, scalability limits, scripting language, and the reward
incentives. These ontologies, however, do not survey alterna-
tive term deﬁnitions in this turbulent area and do not aim to
analyze the differences.

In contrast to the other related works that concentrate on
Bitcoin as a basis for analyzing blockchain design, [142]
focuses on aspects unrelated to cryptocurrency. This paper
compares Ethereum, Hyperledger Fabric, and Corda in terms
of participation of peers, consensus, and smart contracts to
show the most suitable use cases for each blockchain system.
The only other related survey that is not based on Bitcoin
is [21] which provides a comprehensive analysis of DAG-
based blockchain systems. In this recent survey, consensus
over DAGs, performance analysis, and transaction models are
considered based on over 20 DAG-based systems including
IOTA.

The work of [143] proposes a benchmark framework for
evaluating the performance of a variety of blockchain net-
works, both public and private. The authors apply the frame-
work to Ethereum, Hyperledger Fabric, and another private
blockchain system and provide both qualitative and quantita-
tive performance analysis. Additionally, the authors focus on
smart contracts and provide a short survey of other blockchain-
related mechanisms without speciﬁcally focusing on individual
systems.

[144] is another comprehensive survey that identiﬁes a list

Table VIII
COMPARISON WITH STATE OF THE ART SURVEYS ON BLOCKCHAINS AS A WHOLE

1

2

3

4

5

6

Main analayzed aspects of
blockchains

Comparison of alternative
deﬁnitions
Roles and entities

Hardware layer

Data storage
layer

State tracking

Disk

Memory

Communication layer

Data
manipulation
layer

Consensus
algorithm
Quantitative
performance
comparison

DoS prevention

Querying

Our
work

(cid:51)1

U3
B5,E6,
H7,I8
B,E,
H,I
B,E,
H,I
B,E,
H,I
B,E,
H,I
B,E,
H,I

B,E,
H,I

B,E,
H,I
B,E,
H,I
B,E,
H,I

[19]

[20]

[137]

[138]

[139]

[140]

[141]

[142]

[21]

[143]

[144]

[17]

[18]

(cid:55)2

(cid:55)

(cid:55)

(cid:55)

B,etc. B,etc.

B

(cid:55)

(cid:55)

B

B

(cid:55)

B

B

(cid:55)

B

B,etc.

(cid:55)

B,etc. B,etc.

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

B,E,
etc.

B,E,
etc.

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

B,E,
etc.
B,E,
etc.
(cid:55)

(cid:55)

B,E,
etc.
B,E,
etc.

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

I11,etc.

(cid:55)

(cid:55)

(cid:55)

B,E,
etc.

E,H,
etc.

.

I,etc.

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

E,H,
etc.

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

B,E,H,
I,etc.

(cid:55)

E,H

(cid:55)

(cid:55)

S4

(cid:55)

B,E,
etc.
(cid:55)

(cid:55)

B,E,
etc.
B,E,
etc.

(cid:55)

(cid:55)

(cid:55)

(cid:55)

U

B9,E10

B,E,
H,etc.
H12

(cid:55)

B,E,
H,etc.
B,E,
H,etc.

(cid:55)

B,E

(cid:55)

7

Contract layer

E,H,
etc.
1(cid:51): Considered, 2(cid:55): Not considered, 3U: Universal, 4S: System speciﬁc, 5B: Bitcoin, 6E: Ethereum, 7H: Fabric, 8I: IOTA, 9B: Brieﬂy mentioned in Bitcoin,
10E: Brieﬂy mentioned in Ethereum, 11I: Brieﬂy mentioned in IOTA, 12H: Brieﬂy mentioned in Fabric

B,E,H,
I,etc.

B,E,
H,etc.

E,H,
etc.

B,E,
etc.

B,etc.

B,E

B,E

B,E

B

(cid:55)

(cid:55)

(cid:55)

of 40 DLT characteristics that are fundamental for assessing
the suitability of DLT designs for applications on DLT. These
characteristics are grouped into 6 categories. Then, based on
the introduced characteristics, [144] proposes 24 trade-offs in
the DLT design. Performance is one of the categories analyzed
in this survey. As a consequence, performance characteristics
such as block creation interval, block size limit, throughput,
etc. are explored for Bitcoin, Ethereum, Hyperledger Fabric,
IOTA, and other blockchains. According to the classiﬁcation
of [144], smart contracts are one of the characteristics men-
tioned for the ﬂexibility category; thus, they are discussed in
the context of a trade-off with the other DLT characteristics in
the survey. In addition to the characteristics explored in [144],
consensus mechanisms of Bitcoin, Ethereum, Hyperledger
Fabric, and IOTA are brieﬂy introduced, and DoS prevention
solutions of Ethereum and Hyperledger Fabric are explained.

[17] compares data models, network discovery process, and
consensus process across four blockchain platforms including
Bitcoin and Ethereum. It also brieﬂy considers actors and roles
in each of the systems. [18] is an excellent recent tutorial
that touches upon a large number of aspects and state-of-the-
art mechanisms related to blockchain, including roles, entities,
data model, communication protocols, consensus mechanisms,
smart contracts, and much more. The tutorial mentions the
implementation of as many as seven systems, including Bit-
coin, Ethereum, and Hyperledger. The main goal of [18] is to
provide a very broad picture of the state-of-the-art and answer
a number of important high-level questions, while we provide
in-depth design comparison of the four systems.

to seven major aspects of blockchain: (1) comparison of
alternative deﬁnitions, (2) taxonomy of roles and entities,
(3) coverage of the hardware layer, (4) coverage of the data
storage layer including state tracking, on-disk, and in-memory
storage, (5) coverage of the communication layer, (6) coverage
of the data manipulation layer at ﬁne granularity including
consensus algorithm, quantitative performance comparison,
DoS prevention, and blockchain querying, and (7) coverage of
the contract layer. The coverage of aspects 3 to 7 is shown in
the table at the granularity of individual systems we consider
in our survey.
The ﬁrst

alternative
the
blockchain deﬁnitions, has not been considered in the state-
of-the-art surveys and is one of the contributions of our work.
In Section II-A we identify ﬁve blockchain deﬁnitions used
in the literature and existing blockchain-based systems. The
second aspect
is a comprehensive taxonomy of roles and
entities. While there are works that consider roles and entities
in speciﬁc systems, the only prior cross-system taxonomy is
given in [18] to the best of our knowledge. We extend this
taxonomy to additional roles and present the implementation
of each system in the light of this taxonomy. Our analysis
of roles and entities, given in Section II-C, is universal and
applicable to all blockchain systems.

comparison of

aspect,

i.e,

The third aspect for comparison is coverage of the hardware
layer. While a few related works discuss the mining devices
of Bitcoin or Ethereum, we compare all four systems in terms
of the limiting resources, cryptopuzzle solving device, etc. We
also consider how additional hardware is used for security.

In Table VIII, we explain how our survey differs from
the aforementioned studies. The rows of the table correspond

Fourth, we provide a comprehensive coverage of the data
storage layer in Section IV-B including state tracking, on-disk

and in-memory storage. While other surveys have considered
the storage in Bitcoin, in-depth understanding of the storage
in Ethereum, Hyperledger Fabric, and IOTA requires reading
system documentation, blog posts, and even the source code.
To the best of our knowledge, we provide the ﬁrst in-depth
survey coverage for these systems.

The ﬁfth aspect is coverage of the communication layer.
While the basic communication protocol in Bitcion is ex-
plained in a few related works, our description in Section IV-C
considers ordering guarantees, privacy and security, propaga-
tion time, initial peer discovery, and geographical proximity
between nodes in Bitcoin, Ethereum, Hyperledger Fabric, and
IOTA.

The sixth aspect of consideration is coverage of the data ma-
nipulation layer. This is possibly the most substantial layer of
blockchain; it is touched upon by almost all the related works
but the breadth and depth of coverage varies. Consideration
of the consensus algorithm has received a lot of attention in
each of the systems, yet cross-system comparisons are rare
beyond the general comparison between permissioned and
permissionless systems. For example, our survey is the ﬁrst
to provide a comprehensive comparison between consensus
in Bitcoin and Ethereum and to contrast the consensus in
IOTA with other systems not based on DAG. In particular,
we provide the most complete presentation of the consensus
protocol in IOTA that covers incentive-based attacks. Some of
the elements pertaining to the data manipulation layer, such as
DoS prevention and querying blockchain are covered in much
greater detail in our survey compared to related work. When
it comes to performance comparison, we contrast quantitative
and qualitative ﬁndings about each individual system produced
by the developers and researchers and attempt to place them
in a unifying framework.

Regarding the seventh aspect, i.e., coverage of the contract
layer, state-of-the-art mostly considers the scripting language
languages of Ethereum. In
of Bitcoin and smart contract
comparison, we compare different systems by the contract
executing nodes, programming vs. execution language, and
contract execution environment.

VI. CONCLUSIONS

We have presented a comparative study of Bitcoin,
Ethereum, Hyperledger Fabric, and IOTA. The study is orga-
nized by node roles, system entities, as well as system layers
in a cross-system blockchain architecture: hardware, storage,
communication, data manipulation, and contract. We have also
discussed the performance of the four systems based on the
previously published information. The study has emphasized
the differences in the design goals and principles between the
systems. We hope that the study can be used as educational
material in courses and tutorials. It is our conjecture that this
ﬁrst cross-system comparison will facilitate similar studies in
the future, and that such studies will collectively contribute
toward standardization of the area.

ACKNOWLEDGMENT

We are thankful to many researchers who proofread an
earlier version of this survey and provided insightful com-
ments. A complete list of acknowledgements will be provided
in subsequent versions.

REFERENCES

[1] Coindesk, “State of blockchain - q4 2017,” 2017.
[2] A. Rana, “Is blockchain the solution for healthcare? - dataconomy,”
[Online]. Available: https://dataconomy.com/2017/03/

March 2017.
blockchain-solution-healthcare/

[3] F. Hasse, A. von Perfall, T. Hillebrand, E. Smole, L. Lay, and
M. Charlet, “Blockchain–an opportunity for energy producers and
consumers,” PwC global power & utilities, pp. 1–45, 2016.

[4] P. Windley and D. Reed, “Sovrin: A protocol and token for self-
sovereign identity and decentralized trust,” Whitepaper, The Sovrin
Foundation, 2018.

[5] M. M. Lab, “What we learned from designing an academic
certiﬁcates system on the blockchain,” Jun 2016. [Online]. Available:
https://medium.com/mit-media-lab/what-we-learned-from-designing-
an-academic-certiﬁcates-system-on-the-blockchain-34ba5874f196

[6] CoreLedger,

“Land

2020.
[Online]. Available: https://medium.com/coreledger/land-registry-on-
blockchain-a0da4dd25ea6

blockchain,”

registry

Jan

on

[7] “Blockchain for

Jul
2021. [Online]. Available: https://www.ibm.com/blockchain/industries/
supply-chain

ibm blockchain 2021,”

supply chain -

[8] M. Gray, “Ethereum blockchain as a service now on azure,”
November 2015. [Online]. Available: https://azure.microsoft.com/en-
us/blog/ethereum-blockchain-as-a-service-now-on-azure/
goes
and

unveil-
[Online].
https://www.coindesk.com/ibm-goes-big-on-blockchain-

ing
Available:
unveiling-ambitious-new-service-offerings-and-strategy

Rizzo,
services

“Ibm
suite

blockchain

strategy,”

[9] P.

2016.

Feb

big

on

[10] “The diem association.” [Online]. Available: https://www.diem.com/en-

us/

[11] R. Wattenhofer, The science of

the blockchain.

Inverted Forest

Publishing, 2016.

[12] M. Huillet, “Dutch ministry develops national blockchain research
agenda,” May 2018. [Online]. Available: https://cointelegraph.com/
news/dutch-ministry-develops-national-blockchain-research-agenda

[13] “Blockchain partnership — shaping europe’s digital future.” [Online].
Available: https://digital-strategy.ec.europa.eu/en/policies/blockchain-
partnership

[14] “European blockchain services

[Online].
infrastructure
https://ec.europa.eu/digital-building-blocks/wikis/display/

(ebsi).”

Available:
EBSI/Home

[15] P. Zhou, Y. Du, B. Li et al., “China blockchain technology and
application development white paper,” in Ministry of Industry and
Information Technology of the People’s Republic of China, ed. China
Blockchain Technology and Application, 2016.

[16] M. Stone, “The tiny european country that became a global
leader in digital government,” Forbes, 2016. [Online]. Available:
https://www.forbes.com/sites/delltechnologies/2016/06/14/the-tiny-
european-country-that-became-a-global-leader-in-digital-government/
[17] A. Ellervee, R. Matulevicius, and N. Mayer, “A comprehensive refer-
ence model for blockchain-based distributed ledger technology.” in ER
Forum/Demos, 2017, pp. 306–319.

[18] M. Belotti, N. Boˇzi´c, G. Pujolle, and S. Secci, “A vademecum on
blockchain technologies: When, which, and how,” IEEE Communica-
tions Surveys & Tutorials, vol. 21, no. 4, pp. 3796–3838, 2019.
[19] J. Bonneau, A. Miller, J. Clark, A. Narayanan, J. A. Kroll, and E. W.
Felten, “Sok: Research perspectives and challenges for bitcoin and
cryptocurrencies,” in 2015 IEEE symposium on security and privacy.
IEEE, 2015, pp. 104–121.

[20] F. Tschorsch and B. Scheuermann, “Bitcoin and beyond: A technical
survey on decentralized digital currencies,” IEEE Communications
Surveys & Tutorials, vol. 18, no. 3, pp. 2084–2123, 2016.

[21] Q. Wang, J. Yu, S. Chen, and Y. Xiang, “Sok: Diving into dag-based

blockchain systems,” arXiv preprint arXiv:2012.06128, 2020.

[22] A. Narayanan, J. Bonneau, E. Felten, A. Miller, and S. Goldfeder, Bit-
coin and cryptocurrency technologies: a comprehensive introduction.
Princeton University Press, 2016.
“A little-known

90%
after
2017.
[Online]. Available: https://www.cnbc.com/2017/12/04/cryptocurrency-
iota-rallies-after-launch-of-data-marketplace.html

surges
currency
like microsoft,” Dec

[23] R. Browne,

up with

teaming

digital

ﬁrms

[24] B. McElrath, “Braiding the blockchain,” Presentation at Scaling
Bitcoin Hong Kong (7 December 2015). https://scalingbitcoin.
org/hongkong2015/presentations/DAY2/2 breaking the chain 1 -
mcelrath. pdf, 2015.

[25] M. Hearn and R. G. Brown, “Corda: A distributed ledger,” Corda

Technical White Paper, 2019.
[26] S. Popov, “The tangle,” 2018.
[27] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,

http://bitcoin.org/bitcoin.pdf,” 2008.
Endorsement

[28] (2020)

policies.

[Online].

Available:

https://hyperledger-fabric.readthedocs.io/en/release-2.0/developapps/
endorsementpolicies.html
[29] (2018, August) Ethash.
ethereum/wiki/wiki/Ethash

[Online]. Available: https://github.com/

[30] (2013, January) Why a gpu mines faster than a cpu. [Online]. Available:
https://en.bitcoin.it/wiki/Why a GPU mines faster than a CPU
[31] What can i do with iota? what are some potential use-cases? [Online].

Available: https://www.iota.org/get-started/faqs
[32] Jinn. [Online]. Available: https://iotanodes.org/jinn/
[33] (2018, Aug) Proof of scarcity and sybil attacks. [Online]. Available:

https://helloiota.com/proof-of-scarcity-and-sybil-attacks/

[34] J. Lind, O. Naor, I. Eyal, F. Kelbert, E. G. Sirer, and P. Pietzuch,
“Teechain: a secure payment network with asynchronous blockchain
access,” in Proceedings of the 27th ACM Symposium on Operating
Systems Principles, 2019, pp. 63–79.

[35] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shaﬁ,
V. Shanbhogue, and U. R. Savagaonkar, “Innovative instructions and
software model for isolated execution.” Hasp@ isca, vol. 10, no. 1,
2013.

[36] E. Androulaki, A. Barger, V. Bortnikov et al., “Hyperledger fabric:
a distributed operating system for permissioned blockchains,” in Pro-
ceedings of the 13th EuroSys conference, 2018, pp. 1–15.

[37] “Iota reference implementation,” Aug 2020.

[Online]. Available:

https://github.com/iotaledger/iri

[38] “Transaction - bitcoin wiki.” [Online]. Available: https://en.bitcoin.it/

wiki/Transaction

[50] R. Rottmann.

(2019, May)

Iota snapshot.

[Online]. Available:

https://iota-news.com/iota-snapshot/

[51] “Bitcoin wiki.” [Online]. Available: https://en.bitcoin.it/wiki/Protocol

documentation

[52] C. Decker and R. Wattenhofer, “Information propagation in the bitcoin

network,” in IEEE P2P Proceedings, 2013, pp. 1–10.

[53] T. Wang, C. Zhao, Q. Yang, S. Zhang, and S. C. Liew, “Ethna: An-
alyzing the underlying peer-to-peer network of ethereum blockchain,”
IEEE Transactions on Network Science and Engineering, vol. 8, no. 3,
pp. 2131–2146, 2021.

[54] P. Silva, D. Vavricka, J. Barreto, and M. Matos, “Impact of geo-
distribution and mining pools on blockchains: A study of ethereum,” in
2020 50th Annual IEEE/IFIP International Conference on Dependable
Systems and Networks (DSN).
dissemination

IEEE, 2020, pp. 245–252.
–
protocol

data
master documentation.”
fabric.readthedocs.io/en/release-2.0/gossip.html

hyperledger-fabricdocs
[Online]. Available: https://hyperledger-

[55] “Gossip

[56] “The ordering service – hyperledger-fabricdocs master documenta-
tion.” [Online]. Available: https://hyperledger-fabric.readthedocs.io/en/
release-2.0/orderer/ordering service.html

[57] “Architecture explained – hyperledger-fabricdocs master documenta-
tion.” [Online]. Available: https://hyperledger-fabric.readthedocs.io/en/
release/arch-deep-dive.html

[58] A. E. Gencer, S. Basu, I. Eyal, R. van Renesse, and E. G. Sirer,
“Decentralization in bitcoin and ethereum networks,” in International
Conference on Financial Cryptography and Data Security, 2018, pp.
439–457.

[59] “Whisper - ethereum wiki.” [Online]. Available: https://github.com/

ethereum/wiki

[60] P. Syverson, R. Dingledine, and N. Mathewson, “Tor: The second

generation onion router,” in Usenix Security, 2004.

[61] “Mam — client

line]. Available:
introduction/overview

libraries — iota

[On-
https://docs.iota.org/docs/client-libraries/0.1/mam/

documentation.”

[62] M. Vukoli´c, “The quest for scalable blockchain fabric: Proof-of-work
vs. bft replication,” in Open Problems in Network Security. Springer
International Publishing, 2016, pp. 112–125.

[63] C. Cachin and M. Vukoli´c, “Blockchain consensus protocols in the

wild,” arXiv preprint arXiv:1707.01873, 2017.

[64] Bitcoin cash. [Online]. Available: https://www.bitcoincash.org/
[65] E. Lombrozo, J. Lau, and P. Wuille. (2015) Segregated witness
(consensus layer). [Online]. Available: https://github.com/bitcoin/bips/
blob/master/bip-0141.mediawiki

[39] H. Mayer, “Ecdsa security in bitcoin and ethereum: a research survey,”

[66] Orphan block. [Online]. Available: https://en.bitcoin.it/wiki/Orphan

CoinFaabrik, June, vol. 28, no. 126, p. 50, 2016.

Block

[40] Hyperledger Fabric Block ﬁle manager,

[Online].
https://github.com/hyperledger/fabric/blob/main/common/

Jan 2019.

Available:
ledger/blkstorage/blockﬁle mgr.go

[41] “Bitcoin core 0.11 (ch 2): Data storage - bitcoin wiki,” June 2020.
[Online]. Available: https://en.bitcoin.it/wiki/Bitcoin Core 0.11 (ch
2): Data Storage

[42] “Github

fabric

Available:
86f87ebcd8a1819e3832b289f2d94d4a88bb6e05/common/ledger/
blkstorage/fsblkstorage/blockindex.go

storage

[Online].
https://github.com/hyperledger/fabric/blob/

source

code.”

[43] S. Delgado-Segura, C. P´erez-Sola, G. Navarro-Arribas, and J. Herrera-
Joancomart´ı, “Analysis of the bitcoin utxo set,” in International Con-
ference on Financial Cryptography and Data Security. Springer, 2018,
pp. 78–91.
[44] “Couchdb

master documentation.”
fabric.readthedocs.io/en/release-2.0/couchdb as state database.html

database

hyperledger-fabricdocs
[Online]. Available: https://hyperledger-

state

the

as

–

[45] B. Prahalad, “Merkle proofs explained.” Dec 2018.

[Online].
Available: https://medium.com/crypto-0-nite/merkle-proofs-explained-
6dd429623dc5

[46] V. Buterin. (2015, June) State tree pruning. [Online]. Available:

https://ethereum.github.io/blog/2015/06/26/state-tree-pruning/

[47] jamesob, “Coins: allow ﬂush() without cache drop,” Jan 2020.

[Online]. Available: https://bitcoincore.reviews/17487

[48] “What’s new in Hyperledger Fabric v2.x – hyperledger-fabricdocs
master documentation.” [Online]. Available: https://hyperledger-fabric.
readthedocs.io/en/release-2.2/whatsnew.html

[49] “Tangle-accelerator,” Jun. 2021, original-date: 2018-09-25T02:28:48Z.

[Online]. Available: https://github.com/DLTcollab/tangle-accelerator

[67] Y. Kawase and S. Kasahara, “Priority queueing analysis of transaction-
conﬁrmation time for bitcoin,” Journal of Industrial & Management
Optimization, vol. 16, no. 3, p. 1077, 2020.

[68] Y. Sompolinsky and A. Zohar, “Secure high-rate transaction processing
in bitcoin,” in International Conference on Financial Cryptography and
Data Security. Springer, 2015, pp. 507–527.

[69] I. Eyal, A. E. Gencer, E. G. Sirer, and R. van Renesse, “Bitcoin-ng:
A scalable blockchain protocol,” in 13th {USENIX} symposium on
networked systems design and implementation ({NSDI} 16), 2016, pp.
45–59.

[70] V. Bagaria, S. Kannan, D. Tse, G. Fanti, and P. Viswanath, “Prism:
Deconstructing the blockchain to approach physical limits,” in Pro-
ceedings of the 2019 ACM SIGSAC Conference on CCS, 2019, pp.
585–602.

[71] I. Eyal and E. G. Sirer, “Majority is not enough: Bitcoin mining is
vulnerable,” Communications of the ACM, vol. 61, no. 7, pp. 95–102,
2018.

[72] C. S. Wright and S. Savanah, “The fallacy of the selﬁsh miner
in bitcoin: An economic critique,” July 2017. [Online]. Available:
https://papers.ssrn.com/sol3/papers.cfm?abstract id=3009466

[73] Marlow, “Why Selﬁsh miners do not exist and never will,” Apr.
[Online]. Available: https://medium.com/@ProfFaustus/why-

2018.
selﬁsh-miners-do-not-exist-and-never-will-6d68b5ad571c

[74] V. Buterin, “Ethereum: A next-generation smart contract and
decentralized application platform.” 2014. [Online]. Available: https:
//ethereum.org/en/whitepaper

[75] ——, “Eip 100: Change difﬁculty adjustment
block time including uncles.” April 2016.
https://eips.ethereum.org/EIPS/eip-100

to target mean
[Online]. Available:

[76] V. Gramoli, “From blockchain consensus back to byzantine consensus,”

[102] “Ethereum (eth) blockchain explorer.” [Online]. Available: http:

Future Gen. Computer Systems, 2017.

//etherscan.io/

[77] I. Weber, V. Gramoli, A. Ponomarev, M. Staples, R. Holz, A. B. Tran,
and P. Rimba, “On availability for blockchain-based systems,” in 36th
Symposium on Reliable Distributed Systems (SRDS).
IEEE, 2017, pp.
64–73.

[78] A. Hertig. (2018, February) How will ethereum scale? [Online].
Available: https://www.coindesk.com/information/will-ethereum-scale
[79] K. Croman, C. Decker, I. Eyal, A. E. Gencer, A. Juels, A. Kosba,
A. Miller, P. Saxena, E. Shi, E. G. Sirer et al., “On scaling decentralized
blockchains,” in International Conference on Financial Cryptography
and Data Security, 2016, pp. 106–125.

[80] C. Gorenﬂo, S. Lee, L. Golab, and S. Keshav, “Fastfabric: Scaling
hyperledger fabric to 20,000 transactions per second,” in International
Conference on Blockchain and Cryptocurrency (ICBC).
IEEE, 2019,
pp. 455–463.

[81] D. Ongaro and J. Ousterhout, “In search of an understandable consen-

sus algorithm,” in 2014 USENIX ATC, 2014.

[82] M. Castro, B. Liskov et al., “Practical byzantine fault tolerance,” in

OSDI, vol. 99, no. 1999, 1999, pp. 173–186.

[83] N. Garg, Apache Kafka. Packt Publishing Ltd, 2013.
[84] A. Bessani, J. Sousa, and E. E. Alchieri, “State machine replication
for the masses with bft-smart,” in 2014 44th Annual IEEE/IFIP Inter-
national Conference on Dependable Systems and Networks.
IEEE,
2014, pp. 355–362.

[85] G. G. Gueta, I. Abraham, S. Grossman, D. Malkhi, B. Pinkas, M. K.
Reiter, D. Seredinschi, O. Tamir, and A. Tomescu, “Sbft: a scal-
able decentralized trust infrastructure for blockchains,” arXiv preprint
arXiv:1804.01626, 2018.

[86] R. van Renesse, N. Schiper, and F. B. Schneider, “Vive la diff´erence:
Paxos vs. viewstamped replication vs. zab,” IEEE Transactions on
Dependable and Secure Computing, vol. 12, no. 4, pp. 472–484, 2014.
[87] P. Thakkar, S. Nathan, and B. Viswanathan, “Performance bench-
marking and optimizing hyperledger fabric blockchain platform,” in
MASCOTS.

IEEE, 2018, pp. 264–276.

[88] C. Gorenﬂo, L. Golab, and S. Keshav, “XOX fabric: A hybrid approach
to blockchain transaction execution,” in International Conference on
Blockchain and Cryptocurrency, (ICBC).

IEEE, 2020, pp. 1–9.

[89] J. Rebstock, 2018. [Online]. Available: https://github.com/joseph14/

iota-transaction-spammer-webapp

[90] G. De Roode, I. Ullah, and P. J. Havinga, “How to break iota heart by
replaying?” in 2018 IEEE Globecom Workshops (GC Wkshps).
IEEE,
2018, pp. 1–7.

[91] A. Penzkofer, B. Kusmierz, A. Capossele, W. Sanders, and O. Saa,
“Parasite chain detection in the iota protocol,” arXiv preprint
arXiv:2004.13409, 2020.

[92] B. Kusmierz and A. Gal, “Probability of being left behind and
probability of becoming permanent tip in the tangle v0. 2,” IOTA
Foundation, 2018.

[93] G. Bu, ¨O. G¨urcan, and M. Potop-Butucaru, “G-iota: Fair and conﬁ-
dence aware tangle,” in IEEE INFOCOM 2019-IEEE Conference on
Computer Communications Workshops (INFOCOM WKSHPS).
IEEE,
2019, pp. 644–649.

[94] “In tangle we trust - 10 amazing facts about iota,” Aug 2017. [Online].
Available: https://steemit.com/iota/@steemhoops99/in-tangle-we-trust-
10-amazing-facts-about-iota-1000000-token-giveaway-faucet

[95] I. F. Coordicide Team, “The coordicide,” May 2019.
[96] A. De Vries, “Bitcoin’s growing energy problem,” Joule, vol. 2, no. 5,

pp. 801–805, 2018.

[97] C. T. Nguyen, D. T. Hoang, D. N. Nguyen, D. Niyato, H. T. Nguyen,
and E. Dutkiewicz, “Proof-of-stake consensus mechanisms for future
blockchain networks: fundamentals, applications and opportunities,”
IEEE Access, vol. 7, 2019.

[98] V. Buterin and V. Grifﬁth, “Casper the friendly ﬁnality gadget,” arXiv

preprint arXiv:1710.09437v4, 2019.

[99] V. Buterin, D. Reijsbergen, S. Leonardos, and G. Piliouras, “Incentives
in ethereum?s hybrid casper protocol,” in 2019 IEEE international
conference on blockchain and cryptocurrency (ICBC).
IEEE, 2019,
pp. 236–244.

[100] Y. Li, K. Zheng, Y. Yan, Q. Liu, and X. Zhou, “Etherql: a query
layer for blockchain system,” in International Conference on Database
Systems for Advanced Applications. Springer, 2017, pp. 556–567.

[101] “Blockchain.com explorer.”
blockchain.com/explorer

[Online]. Available:

https://www.

[103] “Bitcoin

blockchain

sql

query.”

[Online]. Available:

http:

//blockchainsql.io/

[104] “Anyblock.tools documentation.” [Online]. Available: https://docs.eth.

events/en/latest/index.html

[105] “Iota tangle explorer.” [Online]. Available: https://explorer.iota.org/

mainnet

[106] “Iota tangle explorer and statistics.” [Online]. Available: https:

//thetangle.org/

[107] L. Brodie and C. FORTH Inc, Starting Forth.

Prentice-Hall, Inc.,

1987.

[108] Y. Hirai, “Programming languages that compile into evm,” 2017.
[Online]. Available: https://eth.wiki/en/concepts/evm/ethereum-virtual-
machine-(evm)-awesome-list
is
coding

next
blockchain
[Online]. Avail-
able: https://media.consensys.net/solidity-is-twice-as-popular-as-the-
next-blockchain-coding-language-9330af9aeaa3

as
language,” May

[109] “Solidity

popular

2019.

twice

the

as

[110] Lll introduction. [Online]. Available: https://lll-docs.readthedocs.io/en/

latest/lll introduction.html

[111] “Vyper documentation.” [Online]. Available: https://vyper.readthedocs.

io/en/latest/

[112] “Smart

contracts

and

master documentation.”
fabric.readthedocs.io/en/release-2.0/smartcontract/smartcontract.html

chaincode

hyperledger-fabricdocs
[Online]. Available: https://hyperledger-

–

[113] “Chaincode tutorials – hyperledger-fabricdocs master documenta-
tion.” [Online]. Available: https://hyperledger-fabric.readthedocs.io/en/
release-2.0/chaincode.html

[114] R. Rottmann,

2018.
[Online]. Available: https://medium.com/@ralf/about-smart-contracts-
in-iota-626d2bd3619e

iota,” Mar

contracts

“About

smart

in

[115] The qubic project. [Online]. Available: https://qubic.iota.org/
[116] C. Natoli, J. Yu, V. Gramoli, and P. Esteves-Verissimo, “Deconstructing
blockchains: A comprehensive survey on consensus, membership and
structure,” arXiv preprint arXiv:1908.08316, 2019.

[117] Y. Xiao, N. Zhang, W. Lou, and Y. T. Hou, “A survey of distributed
consensus protocols for blockchain networks,” IEEE Communications
Surveys & Tutorials, vol. 22, no. 2, pp. 1432–1465, 2020.

[118] S. Gupta, J. Hellings, and M. Sadoghi, “Fault-tolerant distributed
transactions on blockchain,” Synthesis Lectures on Data Management,
vol. 16, no. 1, pp. 1–268, 2021.

[119] R. Zhang, R. Xue, and L. Liu, “Security and privacy on blockchain,”

ACM Computing Surveys, vol. 52, no. 3, pp. 1–34, 2019.

[120] T. Salman, M. Zolanvari, A. Erbad, R. Jain, and M. Samaka, “Security
services using blockchains: A state of the art survey,” IEEE Commu-
nications Surveys & Tutorials, vol. 21, no. 1, pp. 858–880, 2018.
[121] M. Saad, J. Spaulding, L. Njilla, C. Kamhoua, S. Shetty, D. Nyang,
and D. Mohaisen, “Exploring the attack surface of blockchain: A
comprehensive survey,” IEEE Communications Surveys & Tutorials,
vol. 22, no. 3, pp. 1977–2008, 2020.

[122] I. Homoliak, S. Venugopalan, D. Reijsbergen, Q. Hum, R. Schumi, and
P. Szalachowski, “The security reference architecture for blockchains:
Toward a standardized model for studying vulnerabilities, threats, and
defenses,” IEEE Communications Surveys & Tutorials, vol. 23, no. 1,
pp. 341–390, 2020.

[123] M. Bartoletti and L. Pompianu, “An empirical analysis of smart
contracts: platforms, applications, and design patterns,” in International
conference on ﬁnancial cryptography and data security.
Springer,
2017, pp. 494–509.
´A. J. Varela-Vaca and A. M. R. Quintero, “Smart contract languages:
A multivocal mapping study,” ACM Computing Surveys, vol. 54, no. 1,
pp. 1–38, 2021.

[124]

[125] J. Eberhardt and S. Tai, “On or off the blockchain? insights on off-
chaining computation and data,” in European Conference on Service-
Oriented and Cloud Computing. Springer, 2017, pp. 3–15.

[126] H. T. Vo, A. Kundu, and M. K. Mohania, “Research directions in
blockchain data management and analytics,” in EDBT, 2018, pp. 445–
448.

[127] T. Neudecker and H. Hartenstein, “Network layer aspects of per-
missionless blockchains,” IEEE Communications Surveys & Tutorials,
vol. 21, no. 1, pp. 838–857, 2018.

[128] R. Yang, F. R. Yu, P. Si, Z. Yang, and Y. Zhang, “Integrated blockchain
and edge computing systems: A survey, some research issues and
challenges,” IEEE Communications Surveys & Tutorials, vol. 21, no. 2,
pp. 1508–1532, 2019.

[129] Y. Liu, F. R. Yu, X. Li, H. Ji, and V. C. Leung, “Blockchain and
machine learning for communications and networking systems,” IEEE
Communications Surveys & Tutorials, vol. 22, no. 2, pp. 1392–1431,
2020.

[130] P. Sharma, R. Jindal, and M. D. Borah, “Blockchain technology
for cloud storage: A systematic literature review,” ACM Computing
Surveys, vol. 53, no. 4, pp. 1–32, 2020.

[131] K. Gai, J. Guo, L. Zhu, and S. Yu, “Blockchain meets cloud computing:
a survey,” IEEE Communications Surveys & Tutorials, vol. 22, no. 3,
pp. 2009–2030, 2020.

[132] D. C. Nguyen, P. N. Pathirana, M. Ding, and A. Seneviratne, “Inte-
gration of blockchain and cloud of things: Architecture, applications
and challenges,” IEEE Communications Surveys & Tutorials, vol. 22,
no. 4, pp. 2521–2549, 2020.

[133] L. Lao, Z. Li, S. Hou, B. Xiao, S. Guo, and Y. Yang, “A survey of iot
applications in blockchain systems: Architecture, consensus, and trafﬁc
modeling,” ACM Computing Surveys, vol. 53, no. 1, pp. 1–32, 2020.
[134] M. S. Ali, M. Vecchio, M. Pincheira, K. Dolui, F. Antonelli, and M. H.
Rehmani, “Applications of blockchains in the internet of things: A
comprehensive survey,” IEEE Communications Surveys & Tutorials,
vol. 21, no. 2, pp. 1676–1717, 2018.

[135] E. J. De Aguiar, B. S. Faic¸al, B. Krishnamachari, and J. Ueyama, “A
survey of blockchain-based strategies for healthcare,” ACM Computing
Surveys, vol. 53, no. 2, pp. 1–27, 2020.

[136] J. Xie, H. Tang, T. Huang, F. R. Yu, R. Xie, J. Liu, and Y. Liu, “A survey
of blockchain technology applied to smart cities: Research issues and
challenges,” IEEE Communications Surveys & Tutorials, vol. 21, no. 3,
pp. 2794–2830, 2019.

[137] X. Xu, I. Weber, M. Staples, L. Zhu, J. Bosch, L. Bass, C. Pautasso,
and P. Rimba, “A taxonomy of blockchain-based systems for archi-
tecture design,” in 2017 IEEE International Conference on Software
Architecture (ICSA).
IEEE, 2017, pp. 243–252.

[138] J. Kolb, M. AbdelBaky, R. H. Katz, and D. E. Culler, “Core concepts,
challenges, and future directions in blockchain: a centralized tutorial,”
ACM Computing Surveys, vol. 53, no. 1, pp. 1–39, 2020.

[139] F. Haffke, “Technical analysis of established blockchain systems,”

Master’s thesis, TU Munich, 2017.

[140] J. De Kruijff and H. Weigand, “Understanding the blockchain using
enterprise ontology,” in International Conference on Advanced Infor-
mation Systems Engineering. Springer, 2017, pp. 29–43.

[141] P. Tasca, T. Thanabalasingham, and C. J. Tessone, “Ontology of
blockchain technologies. principles of identiﬁcation and classiﬁcation,”
SSRN Electronic Journal, vol. 10, 2017.

[142] M. Valenta and P. Sandner, “Comparison of ethereum, hyperledger
fabric and corda,” Frankfurt School Blockchain Center, vol. 8, 2017.
[143] T. T. A. Dinh, R. Liu, M. Zhang, G. Chen, B. C. Ooi, and J. Wang, “Un-
tangling blockchain: A data processing view of blockchain systems,”
IEEE Transactions on Knowledge and Data Engineering, vol. 30, no. 7,
pp. 1366–1385, 2018.

[144] N. Kannengießer, S. Lins, T. Dehling, and A. Sunyaev, “Trade-offs be-
tween distributed ledger technology characteristics,” ACM Computing
Surveys, vol. 53, no. 2, pp. 1–37, 2020.

[145] A. Gervais, G. O. Karame, K. W¨ust, V. Glykantzis, H. Ritzdorf,
and S. Capkun, “On the security and performance of proof of work
blockchains,” in Proceedings of the 2016 ACM SIGSAC Conference on
CCS, 2016, pp. 3–16.

