1
2
0
2

v
o
N
0
3

]

C
D
.
s
c
[

1
v
9
9
3
5
1
.
1
1
1
2
:
v
i
X
r
a

Evaluating Blockchain Application Requirements and their
Satisfaction in Hyperledger Fabric
A Practical Experience Report

Sadok Ben Toumia
University of Passau
bentou01@ads.uni-passau.de

Christian Berger
University of Passau
cb@sec.uni-passau.de

Hans P. Reiser
University of Passau
hr@sec.uni-passau.de

ABSTRACT
Blockchain applications may offer better fault-tolerance, integrity,
traceability and transparency compared to centralized solutions.
Despite these benefits, few businesses switch to blockchain-based
applications. Industries worry that the current blockchain imple-
mentations do not meet their requirements, e.g., when it comes
to scalability, throughput or latency. Hyperledger Fabric (HLF) is
a permissioned blockchain infrastructure that aims to meet en-
terprise needs and provides a highly modular and well-conceived
architecture. In this paper, we survey and analyse requirements of
blockchain applications in respect to their underlying infrastructure
by focusing mainly on performance and resilience characteristics.
Subsequently, we discuss to what extent Fabric‚Äôs current design
allows it to meet these requirements. We further evaluate the per-
formance of Hyperledger Fabric 2.2 simulating different use case
scenarios by comparing single with multi ordering service perfor-
mance and conducting an evaluation with mixed workloads.

CCS CONCEPTS
‚Ä¢ General and reference ‚Üí Surveys and overviews; ‚Ä¢ Com-
puting methodologies ‚Üí Distributed algorithms; ‚Ä¢ Computer
systems organization ‚Üí Fault-tolerant network topologies;

KEYWORDS
Hyperledger Fabric, Distributed Ledger Technology, Blockchain,
Application Requirements, Performance, Scalability, Benchmarking

1 INTRODUCTION
Since the invention of Bitcoin [24], many people are speculating
about how blockchain can revolutionize our daily lives. Several
sectors can profit from blockchain, whereas for many other areas it
is considered an overkill [33]. Today, a number of industries still
struggle with basic concerns like traceability, integrity protection,
or privacy [8, 16, 17]. Competition is higher than ever, which makes
certain parties secretive about their transactions. Such issues are
often not being sufficiently handled by traditional applications.

This raises the demand of a platform that can handle these issues
while meeting their standards in respect to resilience and perfor-
mance [8, 16]. Enterprises often need a permissioned blockchain
that restricts participation to a consortium of members. Due to com-
petitors being also on the blockchain network, these parties need
privacy: not everyone should be able to see all their transactions ‚Äì
instead transactions must be on a need-to-know basis [7].

1

Hyperledger Fabric (HLF) [1] is an open-source, permissioned
blockchain platform that intends to satisfy enterprise application
requirements. It presents a modular architecture with pluggable
consensus and can achieve high throughput. Previous studies have
highlighted the issue of missing support for Byzantine fault toler-
ance (BFT) [30]. Starting from version 2.0, HLF switched from a
Kafka-based ordering serviceto a Raft-based ordering service. While
Raft (like Kafka) does not assume BFT, it could be transformed to do
so in future, and could essentially be a step towards implementing
BFT in HLF.

We think that it is important to discuss and validate how far
design decisions like these, which concern the infrastructure of a
blockchain system, match up with the requirements concrete appli-
cations impose towards the underlying blockchain infrastructure.
Contribution and Outline. Our main contribution consists in
investigating relevant requirements of blockchain applications and
discussing how far these are addressed in HLF. In the remainder
of this report, we refer to related work (¬ß2), provide relevant back-
ground knowledge (¬ß3), explain our methodology (¬ß4) and conduct
a requirements analysis for blockchain applications selected from
different use-cases (¬ß5). Further, we analyse design choices HLF
makes to match these requirements (¬ß6) and investigate on the
question whether HLF can satisfy performance requirements by
conducting experiments for different scenarios (¬ß7). Finally, we
draw our conclusions (¬ß8).

2 RELATED WORK
Li et al. [21] have recently published a survey paper highlighting
Hyperledger Fabric and Hyperledger Composer‚Äôs use-cases. The
paper examined current theoretical and real-life HLF deployment
while highlighting how HLF was used as a solution to solve exist-
ing enterprise problems. A recently published dissertation [8] has
studied the requirements and unresolved issues of supply chains
while also proposing architectures based on blockchains to address
these issues, the main focus was however restricted to supply chain
management.

Several papers have included benchmarks for Hyperledger Fab-
ric [1, 3, 11, 29, 31], mainly focusing on the v1.x versions of Fabric
with FastFabric pushing an impressive 20,000 transactions per sec-
ond (TPS) [11]. Androulaki et al. proposed the architecture, compo-
nents and design choices behind HLF and experimentally validated
the system performance [1] whereas Thakkar et al. studied how
various parameters of the network impacted performance such as
number of channels, number of endorsers and world-state database

 
 
 
 
 
 
choice [31] - their proposals were incorporated in future Hyper-
ledger Fabric versions.

Further, Guggenberger et al. [12] have recently published a de-
tailed performance report for Hyperledger Fabric v2.0 combining
several configurations and testing Fabric‚Äôs fault-tolerance using
DLPS [28]. Their report covers an in-depth benchmark analysis of
HLF.

In our report, we focus on discussing application requirements of
blockchain and how these requirements are met by HLF‚Äôs design.
Our report also includes a performance evaluation that conducts
experiments on multi ordering service performance and mixed
workloads (e.g., mostly read vs. mostly write) which have yet not
been sufficiently studied by previous works but are interesting from
an application point of view.

3 BACKGROUND
To begin with, we briefly explain important terminology as well
as a few fundamental concepts about blockchain and, in particular,
Hyperledger Fabric.

Blockchain. The term blockchain is not used consistently in
academic literature. Our definition emphasizes that we are referring
to a complete system rather than just a specific data structure:

A blockchain is a distributed system that manages an append-
only and totally-ordered log of immutable transactions (also called
the ledger) in a replicated fashion. Several nodes hold a consistent
copy of the ledger, and several nodes are involved in validating
transactions issued by clients. To order transactions, typically a
consensus algorithm is employed. Further, transactions are usually
grouped into blocks, which are chained by referencing the hash of
the previous block in the block header.

The traceability and immutable history of transactions in a
blockchain fundamentally increase the trustworthiness and trans-
parency of the system. As long as a sufficiently large portion of
nodes in the system (e.g., determined by quantity, resource allo-
cation, or stake) behaves correctly, the overall system works as
intended. There is no need to put trust into the correctness of any
single node, thus eliminating single point of failure for blockchain
applications. Immutability refers to the property that each block
bears also the hash of the previous block, and a modification to a
block modifies its hash, which results in the link being broken and
thus invalidating subsequent blocks [30, 35].

Hyperledger Fabric (HLF). HLF is a highly modular enterprise-
grade distributed ledger platform. HLF has plug and play capabilities
that allow it to be suitable for a wide range of use-cases. Further, HLF
follows an execute-order-validate architecture, where transactions
are first simulated (this means executed against the current state
of the ledger) by endorsing peers, ordered by the ordering service,
and then committed by committing peers.

The transaction flow consists of the following steps (also shown
in Figure 1) [1]: The client sends a transaction proposal to the peers
specified in the endorsement policy and the endorsing peers simu-
late the transaction ( 1 ), which produces read sets and write sets,
without changing the state of the ledger. After that, the client col-
lects the responses of the endorsing peers ( 2 ), which contain the
read and write sets, checks if the endorsement policy is satisfied,

Figure 1: Hyperledger Fabric transaction flow [1].

assembles them in an envelope and sends that to the ordering ser-
vice ( 3 ). Subsequently, the ordering service orders the transaction
without knowing the contents of the envelope. Transactions are
batched and once one of the conditions for cutting a block is met,
the ordering service sends the block to the committing peers ( 4 ).
Finally, committing peers validate or invalidate the transactions in
the block and the block is eventually appended to the ledger ( 5 ).

4 METHODOLOGY
Our evaluation approach covers two dimensions: performance and
resilience. Performance characteristics are quantitative (e.g., trans-
action throughput) and are used to assert that the blockchain can
handle the application‚Äôs workload. Resilience characteristics are
often qualitative and describe if the blockchain can deliver a certain
service quality (e.g., tolerating faults, providing confidentiality).

Aspects of Resilience. Resilience is a broad term that encom-
passes many aspects [5]. We employ the following aspects in our
subsequent analysis:

Fault Tolerance Coverage (FTC). A measure of effectiveness for
fault tolerance is fault tolerance coverage [2]: it encompasses the
error- and fault-handling coverage, a measure to capture how many
of the occurring faults are actually covered by the fault tolerance
mechanism (development faults might restrict the intended fault-
handling coverage) and the fault assumption coverage, which is a
measure for reasoning about how closely assumptions of a fault
model actually cover reality. In our analysis we employ assumption
coverage to indicate which type of faults a blockchain can tolerate.
Fault Tolerance Proportion (FTP). Fault tolerance proportion is
an assumed upper-bound that indicates the ratio of faulty nodes a
blockchain can tolerate, to total nodes participating in the system
(this property is also sometimes called resilience bound). Fault
tolerance coverage and proportion are often coupled.

Membership (Node Authenticity). In permissioned blockchains
a consortium of nodes is defined and a mechanism for manag-
ing membership is required. Providing membership information

2

clientendorsingpeer 1endorsingpeer 2endorsingpeer 3Peer(non-endorsing)ordering serviceorderersInvocation111234455551Chaincode execution2Endorsementcollection3/4OrderingBroadcast/Delivery5ValidationCommitCommitCommitCommitTable 1: Categorization of performance requirements.

Scalability
Throughput
Latency

Low
<100 nodes
<100 TPS
<3 s

Medium
100 to 1000 nodes
100 to 1000 TPS
3 s to 10 s

High
>1000 nodes
>1000 TPS
>10 s

and node authenticity is an important feature for blockchains and
blockchain applications might demand the blockchain system to be
capable to changing (e.g., expanding) its consortium at run-time.

Confidentiality. There are different types of application require-
ments associated with confidentiality depending whether the con-
tent, sender, or other information of a transaction need to be confi-
dential.

Integrity. Integrity is a main motivator towards blockchain adop-
tion. Data integrity in blockchains is achieved by the immutability
property of the ledger. Undetected tampering is almost infeasible,
as hashes can be used to quickly validate for correctness. We argue
that all blockchain applications share the need of this characteristic
and will thus not use it in a comparison.

Aspects of Performance. We consider typical blockchain per-

formance aspects that application might demand, in particular:

Scalability. Number of nodes that can participate in the blockchain

system.

Throughput. Number of transactions per second (TPS) that can

be processed by the blockchain system.

Latency. Time that elapses between a transaction being issued on
the client side and being finalized within a block that is appended
to the ledger.
For each aspect, we categorize performance requirements of block-
chain applications into three categories: low, medium and high as
shown in Table 1. This categorization is rough and aligns with
performance magnitudes of blockchain systems. Achieving low
latency is better and thus means a higher requirement towards the
blockchain infrastructure. For the other aspects, higher is better.

5 REQUIREMENTS ANALYSIS
HLF is currently being used in a number of fields [23], some of
them are already in production, but most of them are still in devel-
opment or proof-of-concept status. These use-cases are high-risk
environments with a lot at stake where some parties could be in-
terested in gaining unauthorized access or tampering with the data
for personal gain, thus requiring a highly resilient infrastructure.
In this section, we analyse use-cases and derive which of the
characteristics (Section 4) are required by which application. We
also present a summary in Table 2.

5.1 Electronic Voting (EVote)
EVote [26, 27] is an open-source proof-of-concept application for
holding an electronic election. The app leverages HLF to meet its
needs for immutability and traceability, which in return reduce
election fraud. Smart contracts are used to tally up votes, therefore
reducing costs of manual work [27]. A voting network to hold an

3

election is a highly adversarial environment that might encourage
malicious behaviour of individuals. Therefore, we consider it valu-
able for such a system to be Byzantine fault-tolerant (and to tolerate
up to 33% of participants becoming faulty). The system should be
permissioned. It should further provide high confidentiality: when
votes need to be checked for their validity (to prevent double vot-
ing) they should be untraceable to the voter to prevent any form
of coercion. Subnetworks could help to enforce a need-to-know
policy for different entities involved in the process.

From a performance standpoint, a high latency is tolerable in
such a network, because voting is per user a one-time action. It
should however not exceed 30 seconds in order to maintain a pleas-
ant user-experience. To maintain such a latency, the system has to
have at least a medium throughput, as elections are usually held
in a small time period where at peak times, many transactions are
issued. In such a use-case, the scalability of the system has another
goal other than being able to handle such a traffic and that is trans-
parency and ensuring that not a single entity has more control over
the voting process. An approach for this might be to have every
election district host a peer node (or more in order to avoid a single
point of failure) and as such a medium to high scalability becomes
a requirement.

5.2 Supply Chains (IBM Food Trust and

GoDirect Trade)

GoDirect Trade [16] is a practical use case for blockchain tech-
nology, offering an online marketplace for aerospace parts. The
traceability feature of blockchain allows users to access the lifecycle
of parts and any associated information required by the govern-
ment. IBM Food Trust [17, 20] is a project by Walmart, IBM, Nestle,
and Unilever aimed at improving traceability of products and all
their ingredients to the farms and also to access different data about
the product in order to satisfy customer needs and guarantee the
safety of foods [17]. IBM Foodtrust and GoDirect Trade both utilize
the immutability and traceability aspects of blockchain, in that both
are interested in the history and provenance of items recorded on
the immutable ledger.

From a resilience perspective of view, IBM Foodtrust could go
well with BFT (and have a resilience bound of 33%) whereas GoDi-
rect Trade could benefit from using only CFT (and having a re-
silience bound of 50%). Contrary to IBM Foodtrust, where par-
ticipants could bring up their own peers and deploy their own
smart-contracts, GoDirect Trade‚Äôs nodes are in-house [16]. Further,
both applications need to be run on a permissioned blockchain,
where participants are granted access based on their status on the
market. Moreover, both systems require high confidentiality, as
trade secrets are at stake here as in both networks competitors are
present.

Contrary to EVote, where users are usually one-time users, sup-
ply chains, due to the globalisation of the markets, are usually
comprised of a lot of actors and each one of them uses the network
multiple times in a small time frame [8]. In terms of throughput and
latency, GoDirect Trade requires only a medium throughput and a
medium latency wheras IBM FoodTrust requires a high throughput
and a low latency. This is due to the to the number of incoming

transactions where supply chains in the context of food generate a
lot more requests than supply chains in the context of aviation. In
GoDirect Trade, network clients are not allowed to host their own
nodes. As stated in [16] the system operates five validating nodes,
which indicates that low scalability might suffice. In contrast, IBM
FoodTrust subscribes are allowed to host their own nodes, install
their own private smart-contracts on private channels to automate
transactions, which indicates that it requires a higher scalability
than GoDirect Trade and therefore needs a least medium scalability.

5.3 Healthcare (Change Healthcare)
Change Healthcare [15] is a company with the aim to modernize
the American health system. Leveraging HLF the company is able
to link providers and payers in a trustful environment in order to
facilitate claims.

As an actor in the healthcare industry, Change Healthcare has to
be very wary about how data on their network is handled. Providing
access to unauthorized persons has serious legal consequences [25],
which is why Change Healthcare needs very high confidential-
ity and private ledgers. Most importantly, transactions, such as
financial or patient data, should be on a subnetwork with only par-
ticipating entities granted access (need-to-know basis), for example
a hospital at which a person was a patient in and the insurance com-
pany for claims processing. Similarly to GoDirect Trade, Change
Healthcare‚Äôs nodes are in-house and it can benefit from providing
only CFT and having a fault tolerance proportion of up to ùúñ < 50%.
The blockchain network has initially run on six nodes in the com-
pany‚Äôs data-center but now they are looking towards expanding to
the cloud. As such, Change Healthcare only needs low scalability
due to the nodes belonging to it like in GoDirect Trade‚Äôs case. Cur-
rently the system can process 550 transactions per second (TPS) but
the company is aiming for a higher number in near future [15]. As
such, the blockchain system needs at least medium throughput and
works best with low to medium latency to maintain a satisfactory
user-experience.

5.4 Banking (VISA B2B Connect)
VISA B2B Connect [32] is a project by VISA to facilitate cross-
border and cross-currency payments. It leverages HLF to create a
secure and trusted network of financial institutions where interna-
tional transfers do not have to go through intermediate banks, thus
drastically reducing both delays and costs.

The current standard for cross-border cross-currency payments
and the main system VISA B2B Connect is challenging is SWIFT,
which handles approximately 33.6 million transactions per day.
VISA B2B circumvents the shortcoming of traditional banking ap-
plications by employing an one-to-many architecture, in which
VISA B2B is directly linked to several financial institutions, there-
fore intermediaries can be bypassed. As a result of this centraliza-
tion and the SWIFT system as a motivator, such a system requires
medium scalability, and very high throughput to be capable of han-
dling peak workloads. Typical other banking methods have varying
throughput with PayPal having around 450 TPS [13] and credit-card
companies such as VISA itself require 50,000 TPS [11].

4

This centralization also means VISA‚Äôs nodes are in-house. How-
ever, unlike GoDiectTrade and other companies hosting their nodes
in-house VISA should employ BFT along with a FTP of up to 33%.
The nature of this system makes attacks highly rewarding and in-
sider attacks are a legitimate concern, such as if a participant is
compromised or participant himself being dishonest.

6 HOW HLF MEETS ENTERPRISE

REQUIREMENTS

In this section, we focus on the design considerations and features of
Fabric that allow it to meet performance and resilience requirements
of potential use-cases.

6.1 Resilience Requirements
In the following we highlight Fabric‚Äôs features, components and
design choices while briefly explaining their role in increasing
resilience.

Blockchain Features. Maintaining integrity of the data is a
critical aspect of resilience and a priority for businesses. HLF, being
an implementation of blockchain, comes with both immutability
and traceability. Data is immutable once appended to the ledger,
this way users can insure its integrity [1].

Permissions. Fabric is a permissioned blockchain, permissions
are maintained by one or more membership service providers (MSP)
which use cryptographic identities. Transactions are checked at
every step to verify authenticity of requests. This in turn limits
unwanted access and increases trust [1].

Channels. Unlike other blockchain implementations, HLF uses
channels. A channel is a dedicated subnetwork with its own private
ledger and a group of channel members that manage a copy of the
ledger, thus ensuring that not every peer on the network has access
to the ledger, therefore increasing confidentiality.

Endorsement Policy. Channel administrators define the en-
dorsement policy, which specifies which peers (endorsers) have to
approve a transaction before this is sent to the ordering service. If a
client does not fulfil an endorsement policy he has to retry submit-
ting the transaction again [1]. An endorsement policy consisting of
multiple peers belonging to different organizations would increase
transparency and trust in the system, as no single entity is in full
control of endorsing transactions. A single point of failure can be
avoided by defining a minimum number or percentage of endorsing
peers.

Consensus. An appealing feature of HLF is pluggable consen-
sus. Older versions of HLF use Kafka + ZooKeeper (ZK), while the
current default consensus protocol is Raft. Both Raft and Kafka+ZK
are crash fault-tolerant and not Byzantine fault-tolerant. Since con-
sensus is pluggable, however, the developer could opt for a BFT
ordering service in future as a new BFT consensus library has been
proposed for HLF recently [4]. Raft is embedded into HLF and thus
enjoys the direct support of the HLF community whereas Kafka+ZK
are supported by Apache. From a performance perspective, a pub-
lished benchmark [10] with v1.4.1 showed that Raft can be much
more efficient.

Table 2: Summary of requirements of blockchain applications towards the underlying blockchain infrastructure with very
high(‚ú≠), high (
) demands. Note that, lower latency is better, and is thus considered a higher demand
towards the infrastructure, e.g., tolerating a higher latency as in EVote means a lower requirement.

), medium (

) and low (

Resilience

Application
EVote
IBM FoodTrust
GoDirect Trade
Change Healthcare
Visa B2B Connect

FTC FTP Membership
BFT
BFT
CFT
CFT
BFT

33%
33%
50%
50%
33%

Yes
Yes
Yes
Yes
Yes

Confidentiality
‚ú≠ (sender, content)

(content)
(content)

‚ú≠ (sender, content)

(content)

Performance
Scalability Throughput Latency

‚ú≠

Resilience of the Execute-Order-Validate Design. HLF em-
ploys an execute-order-validate architecture to separate these dif-
ferent concerns. A goal of this design is to help withstanding attacks
that may target performance degradation or resource exhaustion. In
particular, this design can help to circumvent bottleneck situations
since it allows for transactions to be processed in parallel and by
only a subset of nodes.

General Purpose Language based Chaincode. Moreover, the
Fabric team decided not to limit the programming language choice
in smart contracts to domain specific languages and allow devel-
opers to use general-purpose languages to minimize programming
errors as a result of developers having to learn new languages [1].
Peer Gossip. Peer gossip enables peers‚Äô ledgers stay in sync by
distributing data to other peers on the channel. This aids resiliency
in that peers that have gone offline for sometime are able to have
synced ledgers and can endorse transactions again after they are
back online.

Records of Invalid Transactions. All transactions in HLF, in
contrast to other blockchain implementations, are recorded on the
ledger whether they are valid or invalid. This allows dishonest or
malicious users to be detected and black-listed from the network
which results in a more secure platform [1].

Identity Mixer. HLF supports the use of identity mixer (Idemix)
to enhance privacy by providing unlinkability and anonymity ‚Äì this
however, comes with limitations such as not being able to endorse
transactions. An Idemix entity (issuer) certifies a user‚Äôs attributes
in form of a digital certificate, users are then able to generate a
zero-knowledge proof of possession of a certificate while revealing
only what they choose to reveal to a verifier.

Hardware Security Module. HLF supports the usage of hard-
ware security modules (HSM) allowing cryptographic operations
like signature generation to be offloaded to them. This has the ad-
vantage of letting the HSM manage private keys of peers or orderers,
therefore protecting the keys from unauthorized reading.

Transport Layer Security. Communication over a HLF net-
work can be secured using TLS. This can be a one-way or a two-way
authentication.

Private Data Collections. Channels support data privacy by
having only organizations on the channel that are allowed to view
these transactions. In cases where a subset of channel members need
to conduct transactions between each other while not wanting other
channel members to know the contents of these transactions, they
could create a new channel. This is however associated with a higher

administrative overhead. A solution for this would be the usage of
1. Private data has a separate transaction flow
private data collections
compared to other data on the channel. Only authorized peers can
see private data and it is communicated between them using gossip,
all other nodes including ordering nodes only see hashes of this
data, non-authorized nodes append the hashes of this private data in
their ledgers, so they know a transaction has taken place privately
between entities on the channel but they do not know its content.
To comply with government regulations, some organizations might
need to delete private data after a certain time, this is doable and
will leave behind a hash in the peer‚Äôs ledgers as evidence that some
data was there [18].

Chaincode Lifecycle. Introduced in v2.0, the new Fabric chain-
code lifecycle requires organizations participating in the endorse-
ment process to approve a transaction. Previously, in v1.x one
organization would define attributes of a chaincode and other or-
ganizations choose either to opt-in by installing the chaincode or
opt-out and not be able to endorse transactions. The chaincode life-
cycle provides equality on a channel by allowing the chaincode to
be instantiated only after gathering enough approvals. Chaincode
packages also do not need to be identical anymore, different orga-
nizations can install different chaincode packages and introduce
organization-specific behaviour (for example perform different val-
idations for their interests). This does not conflict with transaction
approval as long as endorsement results match [19].

6.2 Performance Requirements
Further, some of Fabric‚Äôs design choices were made to increase the
performance of the overall infrastructure.

The Advantage of Execute-Order-Validate. In HLF execu-
tion and ordering of transactions are separated. This allows for
better scalability for both phases while increasing modularity and
performance because of the decreased amount of work a node has
to do [1]. Some blockchain implementations use an order-execute
architecture, but this design has its limitations. HLF uses an execute-
order-validate approach to allow for parallel execution and elimi-
nate non-determinism of smart contracts (transactions can be pro-
cessed by a subset of endorsers) therefore increasing throughput
and decreasing latency [1].

How Channels Help Performance. Dividing the network into
channels where each channel is serving a purpose and linking a

1See https://hyperledger-fabric.readthedocs.io/en/release-2.2/private-data/private-
data.html, last accessed 12-22-2020

5

subset of the organizations on the network while having their own
endorsers can increase performance due to the decreased work-
load. This is HLF‚Äôs version of sharding (HLF can scale up hori-
zontally using channels), which has frequently been proposed to
increase performance in blockchains [9, 10, 34]. Generally, the idea
of parallelizing transaction processing is an important scalability
technique [6].

Peer Gossip. The optional peer gossip feature of Fabric allows
for better performance. The throughput of the ordering service is
limited by the network capacity of its nodes, and adding more nodes
could decrease throughput. This service elects a leader per organi-
zation that pulls blocks from the ordering service and distributes
them to the rest [1]. This reduces the workload of the ordering
service.

BatchSize and BatchTimeout. The ordering service in Fabric
uses batching and forms blocks out of transactions. A new block is
created if (1) the number of transactions in the block is equal to the
maximum allowed, (2) the block‚Äôs size in bytes has reached max, or
(3) an amount of time has passed since the first transaction of a new
block was received [1]. The parameters BatchSize and BatchTimeout
are customizable, allowing adaptation to the use case. If, however,
the wrong values are chosen Fabric‚Äôs performance can be heavily
affected [14].

Supporting Multiple Ordering Services. The ordering ser-
vice is usually responsible for multiple channels. As the number of
channels grows the load on the ordering service grows, scaling the
ordering service leads to a performance decrease [1]. In cases where
adding more channels would overwhelm the ordering service, a
new ordering service instance can be brought up [10].

World-State Database Choice. Recent work [22] has investi-
gated the difference in performance between the supported world-
state databases in Fabric. Mostly with lower BatchSizes, LevelDB
has shown better performance than CouchDB, but CouchDB of-
2. Applications should
fers better functionality through rich queries
again make trade-offs here of whether they want more functionality
in a database or a better performance. FastFabric has experimented
with an in-memory hash table as a ledger [11] and achieved a huge
increase in throughput (from 3200 to 7500 TPS).

7 PERFORMANCE EVALUATION
In this section, we aim to examine Hyperledger Fabric‚Äôs perfor-
mance under different conditions similar to real-world use-cases
in terms of setup and transaction loads. For our purposes, we use
Hyperledger‚Äôs Caliper3, a state of the art tool for benchmarking
different blockchain platforms such as Hyperledger Fabric and
Ethereum.

In the first part of our evaluation, we focus on the ordering ser-
vice by examining the benefits of operating a secondary ordering
service whilst scaling the number of channels as well as the trans-
action load. In the second part of this evaluation, we investigate
how HLF performs under different mixed application workloads in
terms of read and write operations, thereby simulating real-world

https://hyperledger-fabric.readthedocs.io/en/release-2.2/couchdb_as_state_

2See
database.html, last accessed 12-22-2020
3See https://www.hyperledger.org/use/caliper

scenarios. To mimic a real application, we exemplary choose a fab-
car chaincode deployment. The fabcar is a simple chaincode that
allows users to add or change data (to be concrete: cars and their
ownership) on the ledger using the Fabric contract API4. This way
we can observe the effect of concurrent reads and writes, i.e., users
browsing listings and at the same time users creating new listings.
For our purposes, we may employ setups with an increasing
number of nodes. We are running each node on a 4 vCPU, 6GB
RAM Debian VM running in a private OpenNebula cloud and our
university‚Äôs virtualization farm.

7.1 Multi Ordering Services Performance
We first examine the benefits of operating a secondary ordering
service. The need for a secondary ordering service could arise when
the first ordering service is already operating at a high load and
servicing a high number of channels or to include only a certain
subset of organizations in the ordering phase for certain channels.

Setup. We experiment with 8, 16 and 28 two-peer channels

7.1.1
where each peer is a member of 2, 4 or 7 channels respectively.

Organizations: 8
Peers per Organization: 1
Peers per Channel: 2
Nodes per Ordering Service: 3
MaxMessageCount: 10
BatchTimeOut: 0.5
Endorsement: 50%
Chaincode: fabcar

For load generation, we used a suitable number of workers for
each workload, since employing too many workers can result in
inaccuracies in terms of maintained transaction load, while too few
workers may not be able to maintain the desired load.

7.1.2 Method. In this experiment we scale up the number of chan-
nels while experimentally controlling the transaction loads with
Hyperledger Caliper. Note that, for a a multi ordering service setup,
each orderer owns half the channels and processes and as such half
the transaction load.

Further, the load generation and performance measurement is
performed using Hyperledger Caliper where each invocation of
the submitTransaction() method generates a new transaction per
channel thus guaranteeing a fair load distribution among channels
and ordering services.

Hyperledger Caliper provides a set of rate controllers to conduct
different types of experiments. For our purposes, we decided on
the fixed-load controller which we slightly modified because it was
highly inaccurate when it comes to maintaining a constant load or
a minimally-oscillating load. For this, we have overestimated the
perceived network throughput in the controller which minimized
the delta between the specified transactionLoad and the actual load
at any time during the experiment.

7.1.3 Observations. We make the following observations:

4See https://github.com/hyperledger/fabric-samples/tree/master/chaincode/fabcar

6

28 Channels (Multi)

28 Channels (Single)

16 Channels (Multi)

16 Channels (Single)

8 Channels (Multi)

8 Channels (Single)

)
S
P
T

(

t
u
p
h
g
u
o
r
h
T

650
600
550
500
450
400
350
300
250
200
150
100
50
0

0

10

20

30

40

50

60

70

80

90 100 110

)
s
(
y
c
n
e
t
a
L

2.4
2.2
2
1.8
1.6
1.4
1.2
1
0.8
0.6
0.4
0.2
0

0

10

20

30

40

50

60

70

80

90 100 110

Transaction Load (per Channel)

Transaction Load (per Channel)

(a) Throughput comparison of multi ordering services and
single ordering service setups.

(b) Latency comparison of multi ordering services and single
ordering service setups.

Figure 2: Evaluating the performance impact of ordering services setups in HLF with variabel number of channels.

Observation 1: Figure 2 (a) shows that throughput is continu-
ously increasing as the transaction load increases and converges
to approximately 600 TPS for 28 and 16 channel deployments and
to 425 TPS for 8 channel deployments. Increasing the number of
channels increases throughput, a 100 Requests per Second (RPS)
transaction load per channel achieves approximately 425 TPS for 8
channel deployments and 600 TPS 16 channel and 28 channel multi
ordering service deployments. The same holds for a network level
load, a 800 RPS network load (50 RPS per channel for a 16 channel
deployment and 100 RPS per channel for an 8 channel deployment)
achieves approximately 550 TPS at 16 channels compared to 425
TPS at 8 channels.

Takeaway 1: Increasing the number of channels increases through-
put. The difference in throughput between a 28 channel and 16
channel setup is insignificant with both setups reaching a peak of
approximately 600 TPS whereas for an 8 channel setup the peak is
reached at approximately 425 TPS. Increasing transaction load also
increases throughput however the throughput converges after a
certain point.

Observation 2: Figure 2 (b) shows that increasing the number of
channels leads to an increase in latency. For 28 channel setups the la-
tency difference between a single ordering service setup and a multi
ordering service setup is somewhat significant with approximately
2.4 ùë† and 1.8 ùë† respectively.

Takeaway 2: Increasing the number of channels increases latency.
This increase is more noticeable in single ordering service setups.
Latency has increased by more than 100% between 28 channel and
8 channel setups.

Observation 3: Having a secondary ordering service results in a
small throughput increase (<20 TPS) and a slight latency improve-
ment.

Takeaway 3: A multi ordering service setup does not seem to

lead to a significant performance increase.

7.2 Mixed Workloads
In this experiment we investigate how HLF performs with mixed
application workloads. For this reason, we measure performance
for different read-to-write ratios, in particular mostly write (20/80
read/write), equal usage (50/50 read/write) and mostly read (80/20
read/write).

Setup. Our mixed workloads deployment, is similar to our
7.2.1
multi ordering-service deployment in terms of number of organiza-
tions and endorsement. We are using five ordering-service nodes
for this deployment since this is a more suitable option in practice.

Channels: 1
Organizations: 8
Peers per Organization: 1
Peers per Channel: 8
Ordering Service Nodes: 5
MaxMessageCount: 100
BatchTimeOut: 0.4
Endorsement: 50%
Chaincode: fabcar

7.2.2 Method. We evaluate the performance for increasing input
rates for which the system is under a transaction load of 100 re-
quests to 1000 requests at any given time depending on the setup.
Each invocation of the submitTransaction() method results in the
generation of a single read or write transaction with a certain prob-
ability, e.g., for 20/80 read-write ratio, the probability that a read
operation is generated equals 20%.

7.2.3 Observations. We make the following observations:

Observation 1: The mostly-read workload achieves the highest
throughput. The difference between a mostly-write and a mostly-
read workload is significant with approximately 120 TPS difference.
Equal usage achieves a decent throughput of about 300 TPS, i.e.,

7

)
S
P
T

(

t
u
p
h
g
u
o
r
h
T

400

350

300

250

200

150

100

50

0

0

mostly write
equal usage
mostly read

200

400

600

800

1,000

Transaction Load

)
s
(
y
c
n
e
t
a
L

4

3.5

3

2.5

2

1.5

1

0.5

0

0

mostly write
equal usage
mostly read

200

400

600

800

1,000

Transaction Load

(a) Throughput comparison of mixed workloads.

(b) Latency comparison of mixed workloads.

Figure 3: Evaluating the performance of HLF with different mixed read/write application workloads.

a 50 TPS increase compared to a mostly-write workload and a 70
TPS decrease compared to a mostly-read workload at 1000 RPS.

Takeaway 1: The mostly-read workload results in a noticeable
throughput increase when compared to a mostly-write workload
with 376 TPS and 248 TPS respectively at 1000 RPS.

Observation 2: Latency increases with an increased transaction
load. The mostly write workload achieves the worst latency with
approximately 4ùë† at 1000 RPS. Note that the difference between the
latencies of the individual workloads is more noticeable at higher
transaction loads.

Takeaway 2: An increased RW ratio results in a latency decrease
with approximately 4ùë† at a mostly-write workload compared to
approximately 2.5ùë† at a mostly-read workload.

7.3 Discussion
The obtained results indicate that Hyperledger Fabric achieves
performance of several hundreds of transactions per second even
on commodity hardware. It is performance-wise superior to some
other blockchain platforms, e.g., Ethereum (as of time of writing).
Applying our results to the aforementioned applications, it seems
that Fabric meets their requirements to a certain extent. For GoDi-
rect Trade and Change Healthcare, HLF proves to be a perfect fit
as a platform. For other applications such as Visa B2B Connect
and EVote, Fabric lacks BFT support which is vital in these adver-
sarial environments. We assume this aspect will likely change in
future releases of HLF. Further, for VISA B2B Connect and payment
settlement in general, HLF could be a bit slow due to the massive
workload (in particular of peak loads) such applications bear.

Summarizing, HLF, compared to other solutions, already meets
most business requirements performance and security-wise with
some trade-offs, and future releases could potentially narrow the
gap between enterprise requirements and HLF, especially the planned
introduction of BFT.

8

8 CONCLUSION
Enterprises have previously had minimal interest in blockchains
due to the scalability and performance issues. This is however
continuously changing in the recent years. The use cases discussed
in this paper, as shown in Section 5, all have different needs which
make the modularity, customizability, privacy features and the
coinless nature of Hyperledger Fabric very attractive.

HLF on the other hand, tries to meet these needs by mainly
diverting from traditional architectures like order-execute and by
increasing privacy through the usage of channels and private data
collections. Its design also allows it to be integrated easily in the way
that a potential user could integrate their own certificate authority
or employ their own version of an ordering service.

Previous work and our own experience with Fabric have shown
that it is massively improving and progressing towards being more
decentralized while setting new performance and security stan-
dards for other blockchain platforms. The next releases will maybe
provide Byzantine fault-tolerance which which would be a major
step towards being a production-ready blockchain for high-profile
businesses deployed in possibly adverse environments.

ACKNOWLEDGEMENTS
This work has been funded by the Deutsche Forschungsgemein-
schaft (DFG, German Research Foundation) grant number 446811880
(BFT2Chain).

REFERENCES
[1] Androulaki, E., and et al. Hyperledger fabric: a distributed operating system
for permissioned blockchains. In Proc. of the 13th EuroSys Conf. (2018), ACM,
pp. 1‚Äì15.

[2] Avizienis, A., Laprie, J. C., Randell, B., and Landwehr, C. Basic concepts and
taxonomy of dependable and secure computing. IEEE Trans. on Dep. and Sec.
Comp. 1, 1 (Jan 2004), 11‚Äì33.

[3] Baliga, A., Solanki, N., Verekar, S., Pednekar, A., Kamat, P., and Chatterjee,
S. Performance characterization of hyperledger fabric. In 2018 Crypto Valley
conference on blockchain technology (CVCBT) (2018), IEEE, pp. 65‚Äì74.

[4] Barger, A., Manevich, Y., Meir, H., and Tock, Y. A byzantine fault-tolerant
consensus library for hyperledger fabric. In 2021 IEEE International Conference
on Blockchain and Cryptocurrency (ICBC) (2021), IEEE, pp. 1‚Äì9.

[5] Berger, C., Eichhammer, P., Reiser, H. P., Domaschka, J., Hauck, F. J., and
Habiger, G. A survey on resilience in the iot: Taxonomy, classification, and
discussion of resilience mechanisms. ACM Computing Surveys (CSUR) 54, 7 (2021),
1‚Äì39.

[6] Berger, C., and Reiser, H. P. Scaling byzantine consensus: A broad analysis.
In Proceedings of the 2nd Workshop on Scalable and Resilient Infrastructures for
Distributed Ledgers (2018), pp. 13‚Äì18.

[7] Cocco, S., and Singh, G. Top 6 technical advantages of hyperledger fabric
for blockchain networks. https://developer.ibm.com/technologies/blockchain/
articles/top-technical-advantages-of-hyperledger-fabric-for-blockchain-
networks/, 2018. last accessed 12-22-2020.

[8] Costa, P. M. L.

Supply chain management with blockchain technologies.
https://repositorio-aberto.up.pt/bitstream/10216/114335/2/278462.pdf, 2018. last
accessed 12-22-2020.

[9] Dang, H., Dinh, T. T. A., Loghin, D., Chang, E.-C., Lin, Q., and Ooi, B. C.
Towards scaling blockchain systems via sharding. In Proceedings of the 2019
Int. Conf. on Management of Data (New York, NY, USA, 2019), SIGMOD ‚Äô19,
Association for Computing Machinery, p. 123‚Äì140. last accessed 12-22-2020.
[10] Ferris, C. Does hyperledger fabric perform at scale? https://www.ibm.com/
blogs/blockchain/2019/04/does-hyperledger-fabric-perform-at-scale/, 2019. last
accessed 12-22-2020.

[11] Gorenflo, C., Lee, S., Golab, L., and Keshav, S. Fastfabric: Scaling hyperledger
fabric to 20 000 transactions per second. Int. Journal of Network Management 30,
5 (2020), e2099.

[12] Guggenberger, T., Sedlmeir, J., Fridgen, G., and Luckow, A. An in-depth inves-
tigation of performance characteristics of hyperledger fabric. CoRR abs/2102.07731
(2021).

[13] Hartnett, S. When it comes to throughput transactions per second is the
wrong blockchain metric. https://energyweb.org/2018/05/10/when-it-comes-
to-throughput-transactions-per-second-is-the-wrong-blockchain-metric/, 2018.
last accessed 12-22-2020.

Guizani, M. Performance evaluation of hyperledger fabric. In 2020 IEEE Inter-
national Conference on Informatics, IoT, and Enabling Technologies (ICIoT) (2020),
IEEE, pp. 608‚Äì613.

[30] Sousa, J., Bessani, A., and Vukolic, M. A Byzantine fault-tolerant ordering
service for the hyperledger fabric blockchain platform.
In 2018 48th annual
IEEE/IFIP international conference on dependable systems and networks (DSN)
(2018), IEEE, pp. 51‚Äì58.

[31] Thakkar, P., Nathan, S., and Viswanathan, B. Performance benchmarking
and optimizing hyperledger fabric blockchain platform. In 2018 IEEE 26th Int.
Symp. on Modeling, Analysis, and Simulation of Computer and Telecommunication
Systems (MASCOTS) (2018), IEEE, pp. 264‚Äì276.

Visa b2b connect a network solution for global large-value
https://usa.review.visa.com/dam/VCOM/global/partner-with-us/

[32] VISA.com.
payments.
documents/visa-b2b-connect-white-paper.pdf, 2019. Accessed 12-22-2020.
[33] W√ºst, K., and Gervais, A. Do you need a blockchain? In 2018 Crypto Valley Conf.
on Blockchain Technology (CVCBT) (2018), pp. 45‚Äì54. last accessed 12-22-2020.
[34] Zamani, M., Movahedi, M., and Raykova, M. Rapidchain: Scaling blockchain
via full sharding. In Proceedings of the 2018 ACM SIGSAC Conf. on Computer and
Communications Security (2018), pp. 931‚Äì948.

[35] Zheng, Z., Xie, S., Dai, H., Chen, X., and Wang, H. An overview of blockchain
technology: Architecture, consensus, and future trends. In 2017 IEEE Int. Congress
on Big Data (BigData Congress) (2017), pp. 557‚Äì564. last accessed 12-22-2020.

[14] Hua, S., Zhang, S., Pi, B., Sun, J., Yamashita, K., and Nomura, Y. Reasonableness
discussion and analysis for hyperledger fabric configuration. In 2020 IEEE Int.
Conf. on Blockchain and Cryptocurrency (ICBC) (2020), IEEE, pp. 1‚Äì3.

[15] Hyperledger.org.

Case

study: Change healthcare using hyper-
ledger fabric to improve claims lifecycle throughput and transparency.
https://www.hyperledger.org/wp-content/uploads/2019/06/Hyperledger_
CaseStudy_ChangeHealthcare_Printable_6.19.pdf, 2019.
12-22-2020.

last accessed

[16] Hyperledger.org. Case study: Honeywell aerospace creates online parts
marketplace with hyperledger fabric. https://www.hyperledger.org/wp-content/
uploads/2019/12/Hyperledger_CaseStudy_Honeywell_Printable_12.12.19.pdf,
2019. last accessed 12-22-2020.

[17] Hyperledger.org. How walmart brought unprecedented transparency to the
food supply chain with hyperledger fabric. https://www.hyperledger.org/wp-
content/uploads/2019/02/Hyperledger_CaseStudy_Walmart_Printable_V4.pdf,
2019.

[18] Hyperledger.org. Private data. https://hyperledger-fabric.readthedocs.io/en/
release-2.2/private-data/private-data.html, 2020. last accessed: 10-07-2021.
[19] Hyperledger.org. What‚Äôs new in hyperledger fabric v2.x. https://hyperledger-
fabric.readthedocs.io/en/release-2.2/whatsnew.html, 2020. Accessed 12-22-2020.
[20] IBM.com. Ibm food trust. https://www.ibm.com/downloads/cas/8QABQBDR,

2019. last accessed 12-22-2020.

[21] Li, D., Wong, W. E., and Guo, J. A survey on blockchain for enterprise using hy-
perledger fabric and composer. In 2019 6th International Conference on Dependable
Systems and Their Applications (DSA) (2020), pp. 71‚Äì80.

[22] Lincoln, N.

Hyperledger fabric 1.4.0 performance information re-
port. https://hyperledger.github.io/caliper-benchmarks/fabric/resources/pdf/
Fabric_1.4.0_javascript_node.pdf. last accessed 12-22-2020.

[23] Muscara, B. Hyperledger fabric use-cases. https://wiki.hyperledger.org/display/

LMDWG/Use+Cases, 2020. last accessed 12-22-2020.

[24] Nakamoto, S.

Bitcoin: A peer-to-peer electronic

cash system,‚Äù

http://bitcoin.org/bitcoin.pdf, 2009. last accessed 12-22-2020.

[25] Peterson, K.

J., Deeduvanu, R., Kanjamala,

and Mayo,
A blockchain-based approach to health information exchange
https://www.semanticscholar.org/paper/A-Blockchain-

K.
networks.
Based-Approach-to-Health-Information-Peterson-Deeduvanu/
c1b189c81b6fda71a471adec11cfe72f6067c1ad, 2016. last accessed 12-22-2020.

P.,

[26] Porutiu, H. Evote. https://github.com/IBM/evote, 2019. Accessed 12-22-2020.
[27] Porutiu, H., Bablini, D., Zhang, G., Ryan Bouchard, K. W., Hernandez-
Build a secure e-voting app.

Lu, E., and Ramamurthy, S. G.
https://developer.ibm.com/technologies/blockchain/patterns/how-to-create-
a-secure-e-voting-application-on-hyperledger-fabric/, 2019.
12-22-2020.

last accessed

[28] Sedlmeir, J., Ross, P., Luckow, A., Lockl, J., Miehle, D., and Fridgen, G. The
dlps: A new framework for benchmarking blockchains. In Proceedings of the 54th
Hawaii International Conference on System Sciences (2021), p. 10.

[29] Shalaby, S., Abdellatif, A. A., Al-Ali, A., Mohamed, A., Erbad, A., and

9

