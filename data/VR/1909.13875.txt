EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

9
1
0
2

v
o
N
8
1

]

O
R
.
s
c
[

2
v
5
7
8
3
1
.
9
0
9
1
:
v
i
X
r
a

Tiago Ribeiro∗
INESC-ID &
Instituto Superior Técnico
University of Lisbon
Portugal
me@tiagoribeiro.pt

Ana Paiva
INESC-ID &
Instituto Superior Técnico
University of Lisbon
Portugal
ana.paiva@inesc-id.pt

November 19, 2019

ABSTRACT

With new advancements in interaction techniques, character animation also requires new methods, to
support ﬁelds such as robotics, and VR/AR. Interactive characters in such ﬁelds are becoming driven
by AI which opens up the possibility of non-linear and open-ended narratives that may even include
interaction with the real, physical world. This paper presents and describes ERIK, an expressive
inverse kinematics technique aimed at such applications. Our technique allows an arbitrary kinematic
chain, such as an arm, snake, or robotic manipulator, to exhibit an expressive posture while aiming
its end-point towards a given target orientation. The technique runs in interactive-time and does
not require any pre-processing step such as e.g. training in machine learning techniques, in order
to support new embodiments or new postures. That allows it to be integrated in an artist-friendly
workﬂow, bringing artists closer to the development of such AI-driven expressive characters, by
allowing them to use their typical animation tools of choice, and to properly pre-visualize the
animation during design-time, even on a real robot. The full algorithmic speciﬁcation is presented and
described so that it can be implemented and used throughout the communities of the various ﬁelds we
address. We demonstrate ERIK on different virtual kinematic structures, and also on a low-ﬁdelity
robot that was crafted using wood and hobby-grade servos, to show how well the technique performs
even on a low-grade robot. Our evaluation shows how well the technique performs, i.e., how well the
character is able to point at the target orientation, while minimally disrupting its target expressive
posture, and respecting its mechanical rotation limits.

Keywords Character Animation, Robot Animation, Inverse Kinematics, Expressive Control

1

Introduction

When we think of animated characters, what immediately comes to our mind are the characters seen on TV and
in movies. These characters were artistically crafted either by hand or using computer graphics (CGI) and design
techniques, in order to convey the illusion that they are alive (e.g. [1, 2, 3]). Currently however, we can ﬁnd characters
that live out of the big screens, and are becoming more interactive, powered by artiﬁcial intelligence (AI), immersive
media such as virtual reality (VR) [4] and augmented reality (AR) [5], and even through robots.

While the virtual characters used in VR and AR applications are more familiar to the animation community, social
robots in particular are posing as a new form of animated characters. In order to be used in social applications such as
education, entertainment, assisted living or in public spaces, they are endowed with the most powerful AI capabilities,
and the most advanced robotics hardware technology.

∗www.tiagoribeiro.pt

 
 
 
 
 
 
EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

However what is common to all applications of AI and social agents to physical and immersive characters, is the need
to be expressive while also being fully interactive. As a need, this is also what distinguishes these interactive characters,
from the linear characters created for TV and movies [6]. Such virtual and robotic animated characters must be able to
respond to users in various situations and environments, without appearing stiff or pre-scripted, in order to become
believable interactive characters, ones that convey the illusion of life [7, 8, 9].

Our goal is to turn what used to be regarded as a machine, into life-like animated characters, by focusing on the software
technology and animation techniques that would allow a socially interactive AI to expressively control a complex,
physical embodiment during an autonomous interaction with human users. As such this paper places a stronger focus
on robot animation, while linking to and from CGI character animation. In particular, our long-term goal is to connect
the world of character animation and robotics, and to allow animation artists to take a central role in the development of
social robots, by providing expert body knowledge that can be used by an AI-driven character. On that topic, we have
previously described many of the Nutty-based robot animation theories and practices [10]. Please refer to that reference
for more details on our holistic view and approach regarding robot animation.

Through this paper, we do contribute to our goal with a novel inverse kinematics technique that allows interactive
expressive characters, either virtual or robotic, to convey an expressive posture while facing towards any given direction
(e.g. as when gazing an object, or tracking a person). Our contribution is expected to establish new boundaries in the
ﬁelds we address, by allowing such interactive characters to become more expressive and less scripted, thus becoming
more believable, and capable of exhibiting the illusion of life.

While this paper focuses on robot animation, we consider that our approach, as being heavily based on CGI character
animation, could further be applied to other types of interactive characters in which immersion and interaction with the
physical users and their world is key, such as in VR and AR applications.

1.1 Expressive Interactive Characters and Robots

Animating autonomous social robots introduces concerns that are not typically addressed by CGI animation. However
CGI animation has already solved many problems and introduced many techniques that allow artists to remain central
to the character and animation design process. Therefore we have been looking both at techniques from CGI character
animation and from robotics and human-robot interaction (HRI), in order to understand how these worlds can be bridged
together. By addressing both worlds (virtual and robotic), we expect to uncover new paradigms that will allow such
animated characters to become fully expressive and seamlessly interactive regardless of the form or physicality of its
embodiment.

One of the basic expressive behaviours expected from an interactive character is the ability to face towards people or
particular directions, either using its face when one exists (gazing), or using its body, or part of it (e.g. pointing using an
arm, a tail), or the whole body if e.g. the character is a snake or a worm. In social robots in particular, this behaviour is
cornerstone to the illusion of life, as it is through gazing that the robot is able to convey the illusion of thought, and of
being aware of others, itself, and of its surrounding environment [11, 12, 13, 9].

In order to implement expressive gazing behaviour, such socially interactive robots generally contain either very simple
expressive traits, or anthropomorphic features that allow the gaze-blending process to become quite straightforward, by
containing speciﬁc degrees of freedom (DoFs), such as a neck, which can be dedicated to such behaviour [14, 9, 15,
16, 17]. For more complex and articulated embodiments, one could use inverse kinematics (IK), however the existing
techniques focus on specifying a target position and/or orientation for the end-point, and do not care for the expressivity
of the pose that results from the IK solution. In other cases where some level of control over the posture is permitted,
the techniques require full motion planning before being executed, which hinders their degree of interactivity (e.g. [18])

The problem of conveying an expressive posture towards a given target orientation is complex because the whole
embodiment must be used to shape the posture (designed by an animator), while simultaneously using the same degrees
of freedom to warp that posture towards a given orientation (e.g. gaze-tracking direction), while disrupting the posture
as little as possible, so that the character conveys the same emotion or gesture as the animator had initially intended.
Furthermore such a problem must be solved in real-time for interactive use, and the resulting postures should allow to
provide a smooth and natural motion while solving through different continuously changing postures and orientation.
To add up to the problem, we also argue that the solution to the problem should work without going through major
tweaking or training through examples or demonstrations, which could heavily embarrass and deprive the creative
process. As such, the solution must be able to do its best to take what the animator wanted to convey, and use it
interactively with minimal disruption.

This section presents and describes ERIK, a heuristic inverse kinematics technique that allows a virtual or robotic
character with an arbitrary articulated embodiment to convey and hold a given expressive posture while facing a given

2

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

direction during an interaction. It is able to provide many solutions per second using a standard computer, allowing it to
be used for interactive applications.

The effort to design expressive behaviours for interactive characters using ERIK is also minimal. Animators can design
single front-facing postures for any given embodiment, which are used as input to the algorithm, with no pre-computing
or ofﬂine training required for any new posture or embodiment. The algorithm is then able to take that posture and warp
it in real-time, so that a given end-point is facing any given orientation, while respecting the embodiment’s kinematic
constraints, and while attempting as best to hold the overall shape of the posture.

Furthermore, ERIK was also developed to support its use with robots. As such, its output consists of a list of rotation
angles, one for each joint, which can be used either in virtual or robotic applications. The solver computes on a
per-frame basis in order to easily ﬁt into a typical animation cycle, i.e., it produces one full-body solution at a time, and
not a pre-planned motion trajectory.

Figure 1 illustrates the work-ﬂow of a Nutty-ERIK system [10]. ERIK can either be used as a component of an
Interactive Application such as a game, VR/AR application, or a robotic AI, or alternatively, it can be used as a plug-in
for an animation authoring tool. In the latter case, due to its real-time nature, it allows artists to creatively explore
the design of expressive postures for real robots in real-time, and directly in the real, physical embodiments. This
animator-inclusive workﬂow follows on the work initially proposed by [12, 15].

Figure 1: The ERIK workﬂow, illustrated as a particular version of the Nutty Pipeline [10]. Animators can create
expressive postures using typical animation tools. Those expressive postures can be selected by an AI or character
controller in an Interactive Application to drive an animation engine which, through the use of ERIK, is able to perform
the selected posture towards a selected orientation (e.g. from a user-perception component). Alternatively (dotted
arrow), ERIK can also be used by a plug-in for the animation tool, to allow live authoring of postures on real robots i.e.,
the animators are able to test the result of the postures in a given robot directly and in real-time.

ERIK can be used to create tools and character animation engines directed at animation artists, so that they can take a
stronger role in the development of autonomous, interactive, computer-animated characters, be them virtual or robotic.
By bringing the artists closer to the AI - or the AI closer to the artists - we expect ERIK to prove as a strong technological
contribution for the creation of better and more life-like interactive characters, in particular within immersive and
emergent applications such as the ones based on VR, AR and robotics.

In many cases, the algorithm will be solving for two constraints that are not simultaneously satisﬁable: the expressive
posture of the character, i.e. the conﬁguration of angles for each DoF that results in the given posture; and the global
orientation of the end-point node, i.e. the conﬁguration of angles for each DoF such that the end-point node faces
towards a given orientation (in world coordinates). This means that depending on the character’s embodiment, on the
target posture, and on the target orientation, the resulting pose may either fully satisfy both goals, or fully satisfy the
orientation goal while partially satisfying the posture goal. Due to mechanical limitations, there will be many cases in
which it is physically impossibly to solve both goals. Given that ERIK aims at autonomous characters that interact
with humans, it will prefer a pose that complies with the given orientation target (where a human is expected to be),

3

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

while allowing the posture to fall short of the target expression. This design decision makes ERIK most appropriate for
situations in which the characters perform a merely expressive role, where the control of its embodiment is not crucial
for safety or successful completion of tasks, such as robotic manipulation of real objects.

From our evaluation, we found that ERIK does in fact solve most cases successfully for both the posture and orientation
goals, as long as the embodiment contains enough DoFs to achieve it.

2 Related Work

ERIK was built based on existing models, techniques and ideas from the ﬁelds of robotics, HRI, interactive virtual
agents (IVAs) and from CGI animation. This sections presents not all of them, but the ones we found most relevant for
grounding work and inspiration.

2.1 Robotics and HRI

The AUR is a robotic desk lamp with 5 DoFs and an LED lamp which can illuminate in a range of the RGB colour
space [19]. It is mounted on a workbench and controlled through a hybrid control system that allows it to be used
for live puppeteering, in order to allow the robot to be expressive while also being responsive. In AUR, the motion is
controlled by extensively trained puppeteers, and was composed through several layers. The bottom-most layer moves
each DoF based on a pre-designed animation that was made speciﬁcally for the scene of the play. If the robot was set to
establish eye contact, several speciﬁc DoFs would be overridden by an ik solution using CCD. A ﬁnal animacy layer
added smoothed sinusoidal noise, akin to breathing, to all the DoFs, in order to provide a more lifelike motion to the
robot.

Weinberg has dedicated to the creation of robotic musical companions, such as Shimon, a gesture based musical
improvisation robot created along with Hoffman [20]. Shimon plays a real marimba. Its behaviour is a mix between
its functionality as a musician, and being part of a band. Using its head, it is able to perform expressive behaviour by
gazing towards its band mates during the performance.
Various interactive social robots have been created at MIT’s MediaLab [21], in particular the AIDA2, which is a friendly
driving assistant for the cars of the future. AIDA interestingly delivers an expressive face on top of an articulated
neck-like structure to allow to it move and be expressive on a car’s dashboard.
Walt3 is a social collaborative robot that that helps factory workers assemble cars. Walt uses a screen to exhibit an
expressive face, icons or short animations. Its body is a concealed articulated structure that allows it to gaze around at
its co-workers.
The use of animation principles was explored by Takayama et al. using the PR-24 robot [11]. This is a large mobile
robot with two arms, that can navigate in a human environment. A professional animator from Pixar Animation Studios
collaborated on the design of the expressive behaviour so that the robot could exhibit a sense of thought, by clearly
demonstrating the intention of its actions. Thought and Intention are two concepts that are central in character animation,
and in the portrayal of the illusion of life. In this work, the authors argue for the need of both functional and expressive
behaviours, i.e., that some of the robot’s behaviours would be related with accomplishing a given task (e.g. picking
up an object; opening a door), and that another part would concern its expressiveness in order to convey thought and
emotion.

Nutty Tracks [15] is an animation engine and pipeline, aimed at providing an expressive bridge between an application-
speciﬁc artiﬁcial intelligence (AI), the perception of user and environment, and a physical, animated embodiment. It
is able to combine and blend multi-modal expressions such as gazing towards users, while performing pre-designed
animations, or overlaying expressive postures over the idle- and gazing- behaviour of a robot5. This has allowed
the researchers to explore the use of animation principles in such autonomous interactions with humans by focusing,
however, on the behaviour selection and management mechanisms, and on pre-designing particular animations that
were solely selected and played back on the robots. Nutty Tracks therefore stands as an animation engine that is aimed
at interactive social robots, which however, through the use of simple animation blending, lacks the ability to compute
expression for more complex embodiments, i.e., when techniques such as IK are required.

2http://robotic.media.mit.edu/portfolio/aida (accessed January 12, 2019)
3http://robovision.be/offer/#airobots (accessed January 12, 2019)
4http://www.willowgarage.com/pages/pr2/overview (accessed January 12, 2019)
5http://vimeo.com/67197221 (accessed January 12, 2019)

4

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

The challenge of providing legible and predictable motion to autonomous collaborative robots has also been addressed
by Dragan et al., which demonstrates the beneﬁts of including such properties into motion planners[18]. Their technique
however focuses on these two properties in particular, which become embedded into the planner through a more
mathematical solution that does not provide an actual free-form expressive control.

2.2 Virtual Characters and Computer Animation

The challenge of dynamically generating expressive and meaningful behaviour in the ﬁeld of virtual characters is not
new. Most work devoted to bridging AI and virtually animated characters focuses on the animation of human ﬁgures
(e.g. [22]), and is based on standardizing behaviours through markup language speciﬁcations that allow such characters
to either be pre-scripted, or to have their scripted behaviour generated by an AI during interaction.

This method is widespread across the ﬁeld of IVAs, with authors focusing on how to specify and generate e.g. emotions
[23], gestures [24], facial expressions [25, 26] or even more general full-body behaviour [27, 28, 29, 30]. By relying
heavily on scripting however, it makes it difﬁcult to generalize behaviour to any type of embodiment (most are
speciﬁcally made for virtual humans), and also makes it difﬁcult to specify certain nuances for particular characters and
situations. This is because most of the behaviour tags are directed at specifying particular communicative behaviours
used by humans such as hand gestures, head movement, or facial expressions based on FACS [31] or FAPs [32].

Some works do focus more on motion generation, in order to generate appropriate e.g. gestures in a more procedural
way.
For the video-game Spore6, the authors had to create an innovative animation system that allowed creatures with custom
morphologies to behave coherently by performing locomotion and animated actions in a procedurally generated world
[33]. They preserved a traditional animation workﬂow so that artists could take a central role in the development
process. The Spore engine is aimed speciﬁcally at the types of creatures used in the game, which contain leg groups
and arm groups, and perform a set of pre-determined actions. The piece of this work that became most relevant and
inspiring to us is the use of the Particle IK Solver, which will be described in the next subsection.

Smartbody is a popular procedural animation system in the virtual humans ﬁeld [34]. It takes a BML [29] speciﬁcation
of behaviour as input in order to control any type of embodied agent. This behaviour is scheduled and executed
in several motion controllers, which are combined in each frame to generate a set of skeletal joint rotations and
translations. Smartbody procedurally generates and adapts gestures using an example-based motion synthesis technique
for locomotion, reach and object manipulation [35]. That technique takes a large set of example postures of a given
embodiment e.g. reaching towards different directions, and is then able to produce a grasping pose for any direction by
blending the previously authored examples. This approach was very inspiring to us, as its end-result seems similar to
what we would like to achieve in the ﬁeld of robot animation, however we want to remove the need to provide a large
set of example postures from the workﬂow.

2.3 Forward and Inverse Kinematics

In general, computing motion of an articulated structure is done through Forward Kinematics (FK) and Inverse
Kinematics (IK). Here we brieﬂy introduce some fundamental concepts and techniques regarding these processes.
Figure 2 provides a visual guide on each of the elements that compose an FK/IK problem. The kinematic chain
is a sequence of segments connected through links, starting at a segment S1 at the Origin (O) of the world-frame
through link L1 (or LRoot). The tip of the last segment is designated as the End-Point (or End-Effector). Each link Li’s
world-space location is Pi, and it allows for a rotation α about an arbitrary axis Ri! = (cid:126)0 with angular limits such that
minαi ≤ α ≤ maxαi. A posture is a set of world-space positions P1, ..., PN for each joint. A Kinematic Solution (KS)
is a set of angles α1, ..., αN to be applied to each link L1, ..., LN . FK allows to compute the ﬁnal Posture achieved
from a given Kinematic Solution, while IK computes the Kinematic Solution that allows the end-point S to achieve a
target transform T , containing an orientational component Tori and/or a world-space position component Tpos.

A comprehensive summary of the most popular IK techniques has already been gathered by Aristidou et al. [36] and
is recommended to the interested reader. Given that the latter one is recent and already describes nearly every option
of inverse kinematics up to date, we will refrain from extending this literature section beyond the bare minimum. As
such we describe here only the techniques that are central to our contribution in addition to the basic Jacobian methods,
while solely providing a mention to various other relevant techniques such as [37, 38, 39, 33, 40, 41, 42].

6https://www.spore.com/ (accessed January 12, 2019)

5

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Figure 2: An articulated structure (kinematic chain) as used in both Forward Kinematics (FK) and Inverse Kinematics
(IK). Also shown is a given target T that is to be reached by the end-point S.

Figure 3: The Jacobian solution as a linear approximation of the actual motion of the kinematic chain. Description and
image cited verbatim from [36].

While in general, the IK problem is highly non-linear, the Jacobian methods provide linear approximations to it. They
are based on the computation and inversion of the Jacobian matrix which contains the partial derivatives of the entire
chain system, relative to the end-effectors.

An extensive explanation of these methods is provided by Buss [43] and should be consulted for more details. The
problem is illustrated by Figure 3. In simple terms, given the current position and/or orientation (cid:126)s (i.e. transform) of an
end-effector, and a target position and/or orientation (cid:126)t that it should achieve, let (cid:126)e = (cid:126)t − (cid:126)s represent the error vector
(or task) between the end-effector and the desired target values, and θ = (θ1, ..., θn)T , the current joint angles of the
system, having n as the number of joints. The value m will be the dimension of (cid:126)e (and consequently, of both (cid:126)s and (cid:126)t)
and will depend on the target IK task. If the task is e.g. the 3D position constraint or 3D orientation constraint of a
single end-effector then m = 3. If it is to control both the 3D position and 3D orientation, then m = 6. However one
might choose a task that controls the orientation of only two of the rotation axes, in which case m = 2. Alternatively,
one might also require to set one end-point to a given XY position, regardless of its position in the Z axis; in that case
m would also be 2.
Note that for position control, the task is directly calculated as (cid:126)e = (cid:126)t − (cid:126)s, while for orientation control many
parametrizations exist. When using Euler angles, one option is to calculate it the same way, i.e., solving at the
differential level, by using the desired angular velocity vector. When using quaternions, we may take the vector part of
the target quaternion orientation q(cid:126)v, and use this vector as the task.
The Jacobian matrix J of size m × n (rows× columns) is a function of the current θ values deﬁned by

J(θ) =

(cid:19)

(cid:18) ∂si
∂θj

i,j

6

(1)

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

ψi,j =

Joint j is
Prismatic Revolute

Task i is

Translation

(cid:126)rot

i
z

i
(cid:126)rot

z × ( (cid:126)posi − (cid:126)posi−1)

Rotation or Posture

0

i
(cid:126)rot
z

Table 1: Calculation of the Jacobian terms ψi,j.

It will result in a matrix such as

J =







ψ1,2
ψ1,1
ψ2,2
ψ2,1
...
...
ψm,1 ψm,2







. . . ψ1,n
. . . ψ2,n
...
. . .
. . . ψm,n

where each column represents the inﬂuence of joint j over each task i. A simple rule for calculating each element ψi,j
is presented in Table 1.

Let Ti be the transform matrix for the frame of joint i:








i
i
i
(cid:126)rot
(cid:126)rot
(cid:126)rot
z
y
x
(cid:35)
(cid:35) (cid:34)rz1
(cid:35) (cid:34)ry1
(cid:34)rx1
rz2
ry2
rx2
ry3
rx3
rz1
0
0
0

(cid:126)posi
(cid:35)
(cid:34)x
y
z

1








Ti =

The term (cid:126)pos0,i is the translation between the root frame and joint i’s frame, while (cid:126)rot
is the z-vector of the rotation
between the root frame and joint i’s frame. Assuming that the root frame is located at [0, 0, 0] and that its rotation is
equal to I3 (i.e., Troot = I4), we can take the values of both (cid:126)rot
i directly from matrix Ti. If that is not the
case, then either Ti must be transformed by T −1
Please refer to [43] or [44] for more information on how to calculate the Jacobian matrix, or alternatively to [45] for
a fully detailed description. This matrix allows to approximate the change in the end-effector’s transform given an
increment in the system’s joint angles of ∆θ:

root, or both vectors (cid:126)rot and (cid:126)pos must be transformed by that inverse.

z and (cid:126)pos0,i

0,i

0,i
z

The problem will be solved by seeking a value for ∆θ such that ∆(cid:126)s becomes approximately equal to (cid:126)e, by making:

∆(cid:126)s ≈ J∆θ

(2)

This equals the question how much must I increment each joint angle θ in order for the end-effector to move by the
amount (cid:126)e?

A solution to the IK problem is therefore given by equation (2) for ∆θ, using the inverse of the Jacobian:

(cid:126)e = J∆θ

(3)

∆θ = J −1(cid:126)e

The implementation of any variation of the Jacobian methods typically follow a similar approach, which is as an
optimization problem that minimizes the residual error etotal = (cid:107)(cid:126)e(cid:107).

In most cases however, this equation cannot be solved uniquely, as Jacobian J may be non-square, non-invertible, or
nearly singular (which would provide poor and unstable results). Several alternatives have been found to calculate the
Jacobian’s inverse. One of them is to use the Jacobian’s transpose J T instead of its inverse, and multiplying it by an
appropriate scalar α (Equation 4).

∆θ = αJ T (cid:126)e
(4)
Another possibility is to use its pseudoinverse J † (also called the Moore-Penrose inverse of J) as shown in Equation 5.
∆θ = J †(cid:126)e

(5)

7

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Using the pseudoinverse method also allows to perform a projection into the nullspace of the Jacobian, meaning that we
may further optimize the solution towards a secondary task as shown in Equation 6. An example of that would be to use
the end-effector’s orientation as the main task (cid:126)e, for which the solved ∆θ would minimize the error J∆θ − (cid:126)e, while
choosing a (cid:126)z vector of the same dimension as θ, that would attempt to keep the resulting angles as close as possible to
zero (secondary task), without disrupting the main task.

PN (J) = I − J †J

∆θ = J †(cid:126)e + PN (J)(cid:126)z

(6)

The (cid:126)z vector can be calculated by minimizing a criterion h(θ), using (cid:126)z = ξ∇h(θ), where ξ is a gain factor. Baerlocher
shows an example of the typical application of keeping the joint angles as close as possible to some desired values (e.g.
to zero) [44], by using h(θ, θdesired) = (cid:107)θ − θdesired(cid:107)2. The example of keeping the joint angles close to zero would
therefore be to have just h(θ) = (cid:107)θ(cid:107)2. Alternatively, if the secondary task e2 is clearly represented as a Jacobian matrix
J2, then we might also use Equation 7, as explained by [44].

z = (J2PN (J1))†( (cid:126)e2 − J2J †

1(cid:126)e)

(7)

Both the transpose and the pseudoinverse methods however, suffer from either approximation errors, or from instability
near singularities. Such methods also suffer from poor results when the target is too distant from the current position or
orientations. One method to mitigate that problem is also presented by Buss [43], and consists in clamping the (cid:126)e vector
so that its norm is never greater than a constant value Dmax, as shown in Equation 8.

(cid:126)e = ClampMag((cid:126)t − (cid:126)s, Dmax)
(cid:26) w

if (cid:107)w(cid:107) ≤ d
otherwise

d w
(cid:107)w(cid:107)

ClampMag(w, d) =

(8)

The damped least squares method (DLS), also called the Levenberg-Marquardt method further attempts to address
these issues, by including a non-zero damping constant. This constant however, must be chosen carefully depending on
the kinematic conﬁguration of the system and on its purpose, in order to remain numerically stable near singularities,
without keeping the convergence rate too slow. Equation 9 shows how to calculate ∆θ using the DLS method, where
λ is the damping constant, which must be carefully selected based on the details of the multibody and expected
target positions, in order to ensure stability. A larger damping value allows the solutions to become more stable near
singularities, however if the constant is too large then the convergence rate will be lower (as it will require more
iterations).

= J T (JJ T + λ2I)−1

J †λ
∆θ = J †λ

(cid:126)e

(9)

Alternatively, the DLS method may also be implemented through the Singular Value Decomposition method (SVD),
which decomposes a matrix J of m×n into three matrices U (m×m), D (m×n) and V (n×n), such that J = U DV T .
D is the singular value matrix of J, with its only non-zero values being along its diagonal di,i = σi, being σi the ith
singular value of J. Also, because σi may be zero, let r be the largest value such that σr (cid:54)= 0, with σ being sorted such
that σi ≥ σi+1. Based on the SVD of J and following the elaboration by [43], the DLS method can also be expressed
as in Equation 10:

r
(cid:88)

= (

J †λ

i=1
∆θ = J †λ

(cid:126)e

σi
i + λ2 )viuT
σ2

i

(10)

As mentioned before, the major issue with the DLS technique is the selection of an appropriate damping factor. Buss
and Kim [46] address this issues with the Selectively Damped Least Squares (SDLS) method that adjusts the damping
factor for each singular vector of the Jacobian’s singular value decomposition (SVD). This method converges faster than
DLS and does not require ad hoc damping constants. First a global γmax is chosen, for which they recommend a typical
value to be π/4 (45 degrees). This will be the maximum permissible change in any joint angle in a single iteration.
Then we take the SVD of J = U DV T and express the desired change in end-effector position as (cid:126)e = (cid:80)
i αiui where
ui is the ith column of U and αi = (cid:104)(cid:126)e, ui(cid:105) = uT
i (cid:126)e. Let also ρ(cid:96),j = (cid:107)∂s(cid:96)/∂θj(cid:107) be the relative magnitude of the change

8

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

of the (cid:96) th task variable in response to a small change in the jth joint angle (from Equation 1). We further deﬁne the
auxiliary N and M vectors along with the selective damping factor γ:

Ni =

m
(cid:88)

j=1

(cid:107)uj,i(cid:107), ∀i ∈ [1, n]

M (cid:48)

i,(cid:96) = σ−1

i

n
(cid:88)

j=1

|vj,i|ρ(cid:96),j, ∀i ∈ [1, m], ∀(cid:96) ∈ [1, m]

Mi = σm

(cid:96)=1M i, (cid:96), ∀i ∈ [1, n]

γi = min(1,

Ni
Mi

) · γmax

Finally, the SDLS solution is expressed as ∆θ:

ϕi = ClampMaxAbs(σ−1

∆θ = ClampMaxAbs(

i αivi, γi)
r
(cid:88)

ϕi, γmax)

(11)

(12)

i=1

Baerlocher introduced techniques that allow to solve the IK problem for multiple tasks with priorities, i.e., by specifying
the priority in which each task should be achieved [44]. In particular he aimed at solving the problem of postural control
for virtual humans, by allowing to specify e.g. a task for one hand to reach a certain goal position, plus another task
for the head to face a certain direction, while keeping the whole body balanced. His technique is actually a rewritten
version of the solution initially proposed by Maciejewski [47], upon also being modiﬁed to account for algorithmic
singularities. We found his approach to be the most signiﬁcant one to compare to given our goals. Equation 13 presents
Baerlocher’s formulation of the DLS applied to two tasks (cid:126)e1 and (cid:126)e2, whose corresponding Jacobian matrices are Ji and
damping constants λi, i ∈ [1, 2], with the ﬁrst task having a higher priority than the second.

∆θ = J †λ1

1

(cid:126)e1 + (J2PN (J1))†λ2 ( (cid:126)e2 − J2J †λ1

1

(cid:126)e1)

(13)

He ﬁnally elaborates towards a formulation that supports more than two levels of priority, by following the same
approach. In that case, given a set of tasks [ (cid:126)e1, (cid:126)e2, ..., (cid:126)ep], for which Ji and λi, i ∈ [1, p] are the corresponding Jacobian
and damping constants, with i = 1 corresponding to the highest priority, and i = p to the lowest, Equation 14 presents
the general formulation for the multiple-task-priority method:

i−1))†λi ((cid:126)ei − Ji∆θi−1)

∆θi = ∆θi−1 + (JiPN (J A
∆θ1 = J †λ1
(cid:126)e1
1


J1
J2
...
Ji

J A
i =









(14)

The major difference between his problem statement and ours is that his problem is especially directed at virtual humans
(VH) with many DoFs while ours is directed at robots with much fewer DoFs than the VH, therefore his problem is
more under-constrained (or redundant) than ours. One of the consequences of that is that the null-space projection
operator in his situation will allow for the secondary task to perform much better than in our case.

Finally, within his techniques, Baerlocher also suggests the use of Maciejewski’s method for computing an appropriate
damping factor based on the minimum singular value of the Jacobian [48]. Let bmax be a bound on the norm of the
solution such that (cid:107)J †λ

∆x(cid:107) ≤ bmax, then Maciejewski’s damping factor can be calculated through Equation 15.




d
2



(cid:112)σmin(d − σmin)
0
(cid:107)(cid:126)e(cid:107)
bmax

λ =

d =

if σmin ≤ d
2
if d
2 ≤ σmin ≤ d
if σmin ≥ d

(15)

Conclusions drawn from the comparison of several Jacobian techniques (e.g., Jacobian Transpose, Damped Least
Squares (DLS), Selectively Damped Least Squares (SDLS)), both by Buss [43] and by Aristidou [36] are that the

9

1 θ(cid:48) ← (θ1, ..., θN )T
2 ˙θ ← (cid:126)0
3 best ˙θ ← ˙θ
4 besterror ← MAX_FLOAT
5 (cid:126)s ← ForwardKinematics(θ(cid:48));
6 for N ← 1 to MAX_ITERATIONS do
7

(cid:126)e ← ClampMag((cid:126)t − (cid:126)s, Dmax);
if (cid:107)(cid:126)e(cid:107) ≤ besterror then
besterror ← (cid:107)(cid:126)e(cid:107)
best ˙θ ← ˙θ

if (cid:107)(cid:126)e(cid:107) ≤ ERROR_TOLERANCE then

break

8

9

10

11

12

13

14

15

16

17
18 end
19 return θ + best ˙θ

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 1: Pseudocode for a typical Jacobian method’s iterative solver.
input :θ, (cid:126)t;

// initial joint angles,
// target task variables (position and/or orientation)

// calculate EE position and/or orientation from θ(cid:48)

// where (cid:126)t is the target position and/or orientation

J ← Jacobian(θ(cid:48))// calculate Jacobian of θ(cid:48)
J −1 ← CalculateInverse(J)// using one of the possible methods
˙θ ← J −1 · (cid:126)e
θ(cid:48) ← θ(cid:48) + ˙θ
(cid:126)s ← ForwardKinematics(θ(cid:48));

// calculate EE position and/or orientation from θ(cid:48)

Jacobian methods are mostly appropriate for single end-effector situations, not always suitable for time-critical situations
(e.g. real-time computation) and the incorporation of constraints using this family of methods is neither straightforward
nor controllable towards an optimal solution. Furthermore, while the SDLS seems to be the most promising method, it
is not clear how to use it along with a secondary task.

To conclude this section we share the base pseudocode for such methods in Algorithm 1.

Analytical solutions may seem like another candidate option, as they are good for time-critical situations, however their
closed-form nature makes them unsuitable for scalability. For scalable and extensible time-critical situations, which
are the ones we are interested in, heuristic approaches seem to be the best choice, both because of efﬁciency (faster),
scalability (no virtual limit on the DoFs) and extensibility (multiple end-effectors, multiple goals/tasks, etc.).

One such heuristic approach is the Cyclic Coordinate Descent (CCD), which is very popular both in computer graphics
animation and in robotics [49, 36]. It is an iterative, univariate type of algorithm, as it solves each variable (DoF) one
by one, through a series of iterations that attempt to minimize the error between the current KS and the given target.
Some of its main advantages are that it is very easy to implement, fast to compute, and has linear-time complexity
regarding the number of DoFs. However it typically returns un-natural poses and consecutive executions of it with
similar parameters frequently result in large discontinuities.

FABRIK is another heuristic iterative method that takes on a geometric approach to the IK problem [50, 51]. It was
inspired by the knot-tying problem [52] and borrows the idea of iterating through each joint individually as in CCD,
but instead works in the joint-position space (instead of angles), and each iteration includes a forward step (traversing
from the end-point to the base) followed by a backward step (that traverses from the base back to the end-point). This
technique was created for, and works in virtual space, as it intentionally breaks the kinematic conﬁguration of the
system by stretching each segment during the Forward phase, which most likely ends up bringing the base joint to a
position that is not the origin of the space as it was initially. However the Backward phase solves this, while bringing
the whole KS closer to a solution. By working directly in the joint-position space, FABRIK avoids calculation of
angles, which is one of its main advantages, making it even faster to compute than CCD. Other of its main features are
that it does not suffer from singularity problems, produces naturally smooth and continuous motion, and emphasizes
movement in the joints closer to the base. Following an approach similar to [53], it also supports multiple end-effectors,
and as such, full-body IK solving. Regarding the application of constraints, the authors present successful results in a
system where each link is modelled as a generic 3-DoF, by decomposing the induced quaternions into swing and twist
components, and enforcing limits on them separately following on the method described in [54]. However FABRIK
cannot be trivially used with robots, as it is suited for 3-DoF links. In particular, by operating only in the Cartesian

10

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

space, it does not properly represent twist motions, i.e., a joint whose rotation axis is aligned with its segment. While
virtually one could see it performing twist, enforcing angular limits to such joints becomes impractical.

Regarding expressive posture control, Neff & Fiume have presented the Body Shape Solver [55] which addresses the
problems of pose modelling, balance, and world-space and body-space constraints into a single integrated solver for
humanoid skeletons. The technique can be used by animators to solve for character poses either based on a given set
of parameters, or by selecting a shape set. However their algorithm is speciﬁc to the human body, as it is a hybrid
technique that uses both analytical and optimization methods

Johnson has proposed an Expressive IK solution that also uses expert body knowledge (example poses given by
animators) to augment the quality of the results given by a CCD algorithm [56]. The examples are both used to estimate
joint constraints, and also to perform multi-target pose blending which would then be used as an initial solution before
the IK algorithm is ran (this step was not developed, however). The algorithm, QuCCD, is a Quaternion-based version
of the popular CCD algorithm. QuCCD includes a fast joint-limit constraint approach similar to [54], that takes on a
geometrical approach instead of clamping angles as usual (which would require converting the quaternion to Euler
angles, clamp, and then back to a quaternion). Some of Johnson’s proposed techniques were used to animated Anemone,
an expressive IK robot [57]. This robot used a hybrid between pose-blending, for the DoFs near its base, and QuCCD,
to animate the upper half, so that it could both maintain an expressive posture, while still facing its "head" towards
things in its environment. The whole computation was performed through quaternions, holding off the conversion
until "just-in-time", before converting and sending the actual Euler angles to the motors. Despite presenting promising
results for 3D animated characters, the author does end up announcing that “this method tends to produce very slow
convergence for 1 DOF joints which are constantly bumping into a boundary”.

Grochow et al. propose an IK system that is trained through a set of human poses [58]. The selected poses will therefore
deﬁne the style of the resulting motion. By training with different poses, one can drive the solver to produce different
styles of animation. A key feature is that it can both extrapolate a new pose from a style training set, while also allowing
to interpolate between different styles. However, despite addressing the problem of style and expressivity of IK, the
system was especially developed for motion capture, and requires off-line training, which conﬁnes the results to be
highly dependant on the quality of the training data.

The Particle IK Solver, featured in the video-game Spore and mentioned in the previous subsection, was developed
to allow characters with various custom morphologies to walk naturally and to perform actions in their surrounding
environment such as looking towards a direction, or grasping an object [33]. Particle IK can solve for various goals by
using embodiments that result in an underdetermined system, i.e., ones that will result in more DoFs than IK goals.
Therefore the remaining DoFs can be used to achieve secondary objectives. The solver runs in two phases. First it
solves for the spine of the character and then for the limb poses, while treating the spine as ﬁxed. Their argument was
that a single-phase solver based on existing techniques did not allow them to make speciﬁc ad hoc tuning adjustments
or treat special cases, without compromising the quality of the solution in other areas of the pose. By elaborating a
new solver, they managed to achieve local control over the solution, which was not possible using conventional IK
techniques.

3 ERIK Pipeline and Model

ERIK is an iterative algorithm for expressive kinematics that was developed with articulated structures of 1-DoF joints in
mind, such as real robots, and in particular, robotic manipulators. It provides a joint model that allows to use techniques
initially developed for CGI and not for robotics, such as FABRIK or other IK techniques, which solve for Cartesian
(position-based) solutions, instead of angle-based solutions as is commonly used in robotics.

Our algorithm was initially developed towards the problem of expressive gazing, in which a given embodiment,
composed of an articulated kinematics chain, is required to orient its end-point towards a target, while also providing
expressive control over its posture using expert body knowledge provided by character animators.

Although technically an iterative algorithm, we may also describe ERIK as a multi-phase super-iterative algorithm given
that for each set of goals, it solves them iteratively, while using other iterative techniques within each of its iterations.
In particular within each iteration it may solve small steps using the popular CCD technique, and will use the custom
BWCD technique, which is an adaptation of the CCD algorithm, tailored to simplify some of the steps within ERIK.

3.1 From FABRIK to Expressive Robots

The major portion of the algorithm was inspired by the FABRIK technique [51]. While CCD is commonly used in
isolation to solve the IK problem required for a given end-point to face a given direction, its solutions suffer from

11

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

discontinuities and un-natural poses. In this aspect, FABRIK performs signiﬁcantly better, which makes it more
appropriate to be used for expressive motion. However, by operating on the Cartesian level, it cannot ensure reliable
orientation constraints. Given a set of parallel, 1-DoF joints as we commonly ﬁnd in robots, it frequently runs into
indeterminations, given that a Cartesian representation of a skeleton can not properly represent induced parallel rotations
(i.e., twist). As the authors point out, that results in deadlock situations [51]. They propose that deadlocks can be
detected by checking if the distance between the target and the end-point is becoming smaller on each iteration. If
not, a deadlock situation is detected. We have imported this concept into ERIK, although we have called these the
Nonconvergence cases, for which we provide additional Nonconvergence Tricks. Our dealing if the Nonconvergence
cases is expressly different, given that under constraints, we must allow the end-point orientation to temporarily move
away from the target in some situations, while it is e.g. twisting its root joint to readjust the whole chain to allow
reaching the goal, which makes the Nonconvergence detection less trivial. Furthermore, the Tricks we apply must
consider the fact that we expect to hold the given expressive target posture as best as possible, while in FABRIK, one of
the proposed solutions when the target is detected to be out of reach, is solely to place the whole chain in a straight line
(which is OK if we do not care for the resulting posture). These limitations have restricted FABRIK’s use for robotics,
as it was especially formulated for motion-capture of virtual humans, and on IK problems for position-based targets.
Still, FABRIK provides various beneﬁts, such as supporting full-body IK i.e., multiple end-points, non-leaf end-points,
closed loops, and prismatic (i.e., sliding) joints. Therefore, we chose FABRIK as the starting point for ERIK so that in
the future we may have the chance to replicate and adopt those same features.

3.2 BWCD: Backward Coordinate Descent

The BWCD is an IK technique that was speciﬁcally created to solve some of the intermediate steps within ERIK. Its
execution is similar to CCD’s except that execution starts at the root of the chain instead of at the end-point. Therefore
the bulk of the warping introduced by BWCD will be concentrated at the bottom of the chain, while CCD tens to
introduce it at the top of the chain. The formulation of BWCD was necessary to allow warping postures towards an
orientation goal, with preference for having such warping at the root of the chain. That is because by concentrating
most of the warping at the root, we expect to maintain more of the shape of the posture through the rest of the chain, up
to the tip. Because the warping occurs at the root, which is typically less constrained (such as in a turret, or a pan-tilt
mount), BWCD can return an acceptable solution in a small number of iterations (e.g. <5). Therefore, while being an
iterative algorithm, it is fast enough to be used as an internal step within ERIK.

Within ERIK, BWCD is used to operate both on Postures and on Solutions. The Posture version solves it in Cartesian
space and does not enforce joint rotation limits. The Solution version runs in angular space and enforces joint rotation
limits.

3.3 The ERIK Pipeline

Figure 4 shows the main components of ERIK: the inputs Target Orientation and Posture, the Joint Model, the
Warp Posture phase, the Solve for Goals phase and the Motion Filter.

ERIK takes in a Target Orientation, along with a Target Posture, that are to be achieved by the given skeleton, which
is the representation of the embodiment’s structure, depicted as the Joint Model. The Target Posture is ﬁrst naively
warped using BWCD, so that its end-point is pointing towards the target orientation. This step, however, breaks the
kinematic constraints. Therefore ERIK moves on to the FABRIK-inspired iterative portion that starts by running
a Forward Phase, and a Backward Phase (inspired by FABRIK’s own Forward and Backward phases). After the
Backward phase, the candidate solution exhibits a shape as close as possible to the given Target Posture, and respects
all kinematic constraints, but its end-point orientation may not match the given Target Orientation. Upon testing
the candidate solution, if it is within the acceptable parameters, then the solution is returned. Otherwise, the BWCD
algorithm is used to orient the solution’s end-point towards the given Target Orientation. This step will likely cause a
slight deformation to the intended posture. If after this step, the new candidate solution is still not acceptable, then
ERIK will proceed with a new iteration, starting from the current candidate solution. Before doing so however, it may
perform some Noncovergence Tricks, in case the algorithm detects that the candidate solution errors are not properly
minimizing.

3.3.1 Nonconvergence Tricks

Upon detection of a non-converging execution, we attempt two approaches, which we call tricks, to attempt to get the
solution to converge. The ﬁrst attempt is to add a small offset to the target orientation. It may be the case that the
speciﬁc target orientation may not be mechanically achievable, and that the algorithm will deadlock trying to achieve

12

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

it. In that case we attempt to perform a random disturbance of a pre-speciﬁed magnitude ΛDisturbanceθ on the Target
Orientation, and proceed to the next iteration using the new target.

If the execution comes again to a non-convergence detection, then we attempt to run the CCD technique, using the
current intermediate solution as the initial state. This CCD step will likely disturb the expected resulting posture, but
will ensure that the end-point is pointing towards the target as best as possible. Given that we take the current solution
as the initial state, it is, however expected that the introduced posture disturbance is minimal.

If still this CCD step was unable to provide an acceptable solution, then it is likely that the intermediate solution has
become locked due to joint constraints, and that CCD will not be able to solve it. In that case, and only in that ﬁnal case,
will we disregard the target posture, and therefore run the CCD technique again, but starting from the zero-pose.

3.4 The ERIK Joint Model and LALUT

In order to allow the use of a FABRIK-based approach with robot-oriented calculus, we started by developing the ERIK
Joint Model (EJM) that contains all the required information and operations.

(cid:126)

RotationAxis, within the angular limits of [Minθ, Maxθ].

Figure 5 shows the unit-sphere EJM space of a joint, where the
which can rotate about a
Vector (cid:126)t is a target vector, which speciﬁes the direction where we wish to compute a solution for the joint. Note that
(cid:126)Parent was purposely misplaced so that it ends at the origin, to help to visualize this representation as a segment
the
hierarchy, and that all the vectors used are normalized to unit length. Note also that we suggest always considering that
(cid:126)Parent is aligned with the (cid:126)y of the child’s local space, although other conventions can be used. The coordinate axes
the
on the top-right corner of Figure 5 should help to clarify the convention in case of any doubt.

(cid:126)Parent segment is connected to the link’s

(cid:126)Segment,

Figure 4: ERIK Pipeline. The given Target Posture and Orientation are ﬁrst warped using BWCD, so that the posture’s
end-point is aiming towards the Target Orientation, without enforcing joint limits. The result feeds the ﬁrst iteration
of the Iterative portion, which, through various phases on each iteration, returns the ﬁnal solution. The Joint Model
containing the skeletal information and auxiliary operations. The ﬁnal solution runs through a motion ﬁlter to ensure
smooth, continuous output.

13

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

(cid:126)Parent segment, and in this
Figure 5: The ERIK Joint Model. A joint is deﬁned as having its origin at the tip of its
RotationAxis, within an angle that lies in
coordinate frame, to contain its own
the range {Minθ, Maxθ}. In order to achieve a given target t, which is deﬁned in its own local space, it can perform a
local rotation of αswing, bringing its segment to S(cid:48), and then have its parent joint perform a twist of βtwist in case the
parent is a twister joint.

(cid:126)Segment, which can rotate about a given

(cid:126)

The goal of the EJM is to provide answers to the following question: What angular rotation do I need to apply to the
local joint, if I know the joint’s rotation limits, and if I know that the Parent joint is a Twister, along with how much it
can twist?
Taking ﬁgure 5 as example, and note the segment (cid:126)S(cid:48). In order to point the
(cid:126)Segment to (cid:126)t, the EJM provides the rotation
(cid:126)Segment, resulting in (cid:126)S(cid:48), followed by βtwist on
(cid:126)Parent. This would be because the segment wound not
of αswing on
achieve (cid:126)t through a positive rotation due to its rotational limit Maxθ. Therefore it needs to locally rotate away from the
target, and then rely on its parent’s Twist capabilities to ﬁnally turn to the right direction.

The αswing value is calculated using a pre-computed look-up table which we call the LALUT. First, the target direction
(cid:126)t is turned into a single decimal number we call a latitude λ, which is calculated from Equation 16.

λ((cid:126)t) = σ((cid:126)t) ·

(cid:126)t · (cid:126)P + 1
2
(cid:126)P OA)

.

σ((cid:126)t) = sign((cid:126)t ·
(cid:126)P OA = (cid:126)R × (cid:126)P (only computed once)

(16)

This λ is then used to query the LALUT, which therefore stands for LAtitude Look-Up Table. Additionally some
auxiliary vectors are computed only once on joint initialization following Equations 17

(cid:126)OA =

(cid:126)P OA =











, if ¬( (cid:126)R (cid:107) (cid:126)S)
(cid:126)R × (cid:126)S
(cid:126)R × ˆY , else if |(cid:126)S · ˆX| = 1
(cid:126)R × ˆZ , else
(cid:126)R × (cid:126)P , if ¬( (cid:126)R (cid:107) (cid:126)P )
ˆX
ˆZ

, else if (cid:126)R · ˆX = 0
, else

(17)

Figure 6 illustrates the concept of latitude. Given one of the target vectors shown, the latitude will be a number between

14

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Figure 6: The latitude coordinate system. Given a target, represented by the yellow arrows, the corresponding latitude λ
is calculated following Equation 16. A target pointing at the south pole has a λ of zero (0.00), while one pointing at the
north pole has a λ of one (1.00). The λ will be positive or negative depending on if it lies in the right or left hemisphere,
which is deﬁned by the plane

RotationAxis × (cid:126)Parent.

(cid:126)

zero and one, which is inspired on the concept of geographic latitude. The south pole corresponds to zero (0.00), while
the north pole corresponds to one (1.00). The unit sphere is also split in two vertical hemispheres using the plane
(cid:126)Parent. Given a target vector (cid:126)t, the hemisphere it lays in is is used to deﬁne the
deﬁned by the vectors
sign of the latitude (positive or negative).

RotationAxis and

(cid:126)

3.4.1 The Latitude Look-Up Table

The LALUT serves as a look-up table (LUT), which consists of an indexed array, stored in memory, for which we
can associate a value y to an index x. For intermediate values of x that are not present in the table, it should be able
to compute the corresponding values of y by interpolation. It is computed only once, on initialization, given that the
RotationAxis of
kinematics of a joint are not expected to change in run-time (i.e., the speciﬁc vectors
the system remain the same throughout execution).
This table is computed by iterating a variable a from αmin to αmax, in small steps (e.g. π
180 rad). The size of the step can
be adjusted depending on the needs, with a smaller step requiring linearly more initialization time, but providing higher
accuracy. In any case the total execution time should be less than a few seconds on a typical computer.

(cid:126)Segment,

(cid:126)Parent,

(cid:126)

RotationAxis, a), which produces a new
On each iteration, we rotate
vector (cid:126)u. We then store the value of a in the LALUT, indexed by its latitude λ((cid:126)u). Conceptually, this means that the
LALUT stores, for a given latitude, the local angle that resulted in it.

(cid:126)Segment using a quaternion QlutStep = AxisAngle(

(cid:126)

Because the LALUT is stored for two hemispheres, it actually contains a positive LUT and a negative LUT. An entry
is placed in either the positive one or the negative one depending on the sign of σ((cid:126)u). Later, for retrieval, the same
procedure is followed: Given a target t, a latitude λ and a sign σ are calculated from Equation 16. If σ is negative then
the negative LUT is queried for λ, otherwise the positive one is queried.

3.5 ERIK Parameters and Model Speciﬁcation

The algorithm relies on a set of Parameters (Π) used to deﬁne the execution goals, which are expected to change
frequently (even between each solution), along with a set of Hyperparameters (Λ) which should remain unchanged
throughout the execution, and are used to conﬁgure the algorithm execution. Table 2 outlines the main Parameters
and Hyperparameters required for ERIK, along with the symbol by which they shall be represented throughout the
document, and especially within Appendix 7 (Algorithmic Speciﬁcation).

15

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Table 2: Description of Parameters and Hyperparameters of ERIK.

Symbol

Meaning

Π
Λ
Πτ , Π(cid:126)τ
ΠΨ
ΠΘt−1
ΛSk
ΛSki
NDoFs
Λφ

ERIK Parameters
ERIK Hyperparameters
Target Orientation, Target Direction
Target Posture
Previous Solution
Skeleton Information (EJM)
ith joint counting from the root7
Number of DoFs of the Skeleton
Error Function

ΛMaxERIKIterations Maximum iteration count
ΛMaxCCDIterations Maximum iteration count for CCD (and BWCD)
Value of Hyperparameter f oo
Extension bar is active
Solution’s error value

Λfoo
ΛΞbar
Θε

Table 3: List of joint information, given a joint k of a Solution (Θk), a Posture (Ψk), or a Skeleton (Skk). Let Φ
represent either a Solution or a Posture.

Symbol Meaning

ΨEE, ΘEE A Posture or Solution’s End-Effector joint.

(cid:126)kσ
(cid:126)kRA
(cid:126)kOA
(cid:126)kP OA
Φkρ
Φkθ
ΦkQ
ΦkL
ΦkΩ
(cid:126)Φkd

Joint’s (child) Segment.
Joint’s Rotation Axis.
Joint’s Orthogonal Rotation Axis.
Joint’s Parent-Orthogonal Rotation Axis.
World-Position of joint.
Local angle of joint.
World-Frame (basis) of joint (Quaternion).
Local-Frame orientation transform (Quaternion).
World-frame orientation transform (Quaternion).
Direction where the joint segment is pointing at (unit vector).

Besides the Parameters and Hyperparameters, ERIK requires the concept and model of Solutions (Θ), Postures (Ψ)
and Links (K). The Solution object is used both for intermediate and candidate solutions, used internally during the
execution of ERIK, and also to represent initial and ﬁnal solutions provided to and by the algorithm. The Posture object
is similar to the Solution one, except that it is used to represent a target pose, which may be represented either based on
a set of angles, or a set of positions for each joint, and which may or may not comply with the mechanical limits of the
Skeleton. In case of Solutions, they contain kinematic information that adheres to the joints’ kinematic limits.

Additionally, candidate and ﬁnal solutions contain an error value Θε which represents the result of the error function
Λφ(Θ). The Skeleton information object contains the set of Links, along with information such as which is the root or
end-point joints of the chain.

Both Solutions and Postures contain joint information represented in a similar way. The joint ﬁelds used by both are
listed in Table 3, while some additional algebraic deﬁnitions are listed in Table 4. The computation of some of the ﬁelds
from Table 3 is explained in Equations 18a–18c. Let us clarify that the orientation transforms ΦkL and ΦkΩ represent

16

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

the orientation to which the joint’s segment is facing, after applying its own local rotation. Also note that an alternative
to Equation 18c would be to take the (cid:126)y axis of ΦkΩ ’s corresponding matrix.

ΦkL = QAxisAngle( (cid:126)kRA, Φkθ )
ΦkΩ = ΦkQ · ΦkQL
(cid:126)Φkd = QAxisAngle( ˆY , Φkθ )

(18a)
(18b)

(18c)

Table 4: Deﬁnition of mathematical symbols used in the algorithms.

Symbol Meaning

Qθ, Qv
QM
Qk

Scalar and Vector parts of quaternion Q
Rotation Matrix that corresponds to quaternion Q.
Axis k of Q’s rotation matrix QM , k ∈ {x, y, z} (simpliﬁcation of QMk ).

ˆX, ˆY , ˆZ Unit-vectors in the X, Y or Z directions.

3.6 The Error Function

To measure the quality of the solutions produced by ERIK, we established two concurrent error measures, (cid:15)Orientation
and (cid:15)Posture. These are concurrent measures because in most cases, minimizing one results in not minimizing the other.
Through successive iterations, the algorithm attempts to minimize the error function Λφ (Equation 19), which calculates
a weighted sum of the two measures. The error threshold ΛThresholdε speciﬁes when the result of the error function is
small enough to be acceptable (for which it can successfully terminate and return the computed solution). In all cases,
any value that measures error lies within the interval [0.0, 1.0]. The orientation error function φOrientation calculates the
(cid:15)Orientation for a given solution, while similarly, φPosture calculates its (cid:15)Posture.

Λφ(Θ, τ, Ψ, Λ) = ΛOrientationErrorWeight · φOrientation(ΘEEΩ , τ, Λ) + ΛPostureErrorWeight · φPosture(Θ, Ψ, Λ)

(19)

These two error functions are deﬁned in equations 20 and 21, and further speciﬁed in the appendix in Algorithms 5
and 6. The posture error function φPosture measures how different the posture of a solution is, in shape, from the target
one. It does so by measuring the local angular deviation between each non-twister solved joint, and target joint, and is
designed to punish more for deviations closer to the end-point than closer to the root, which supports our preference.
In equations 21 and 22, α is a shortcut for the aggravation factor ΛErrorAggravation.

φOrientation(ω, τ, Λ) =

(cid:26)

min(Z(τ, ω), Z(τ, QAA(RotVQ( ˆY , ω), π) · ω))
Z(τ, ω)

, if ΛΞSymmetricEndpoint
, otherwise

Z(τ, ω) =

min(|τ − ω|, |τ + ω|)
√
2

·

φPosture(Θ, Ψ, Λ) =

Υ(P, i) =

1
ΛPostureNorm



(cid:107)ΛSkRootσ

NDoFs(cid:88)

(cid:26) 0

αi · |(1 − 1+Υ(Ψ,i)

2

i=1
(cid:107) · (cid:107)P(i+1)ρ − Piρ (cid:107)

IsTwister(ΛSki)

, if
, otherwise

) − (1 − 1+Υ(Θ,i)

2

)|

, i = 1

(20)

(21)



(cid:107)Piρ − P(i−1)ρ (cid:107) · (cid:107)P(i+1)ρ − Piρ (cid:107)

otherwise

The Hyperparameter ΛErrorAggravation (used in the Equations 21-22 as α) deﬁnes how worse the punishment becomes,
as the function calculates deviations closer to the end-point. A value of 1.0 would mean that the punishment is the
same across the links. A value of 2.0 means that a given deviation amount at one link would result in twice the error
value, one level up the kinematic chain. We can see that the resulting value of φPosture is divided by the ΛPostureNorm,

7Thus the root joint is ΛSk1 , the end-effector is ΛSkN , and the Superpoint (Section 3.8) will be ΛSkN +1 .

17

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

which reduces the ﬁnal sum to a value in the interval [0.0, 1.0]. This hyperparameter is calculated once on the skeleton’s
initialization and given by Equation 22.

ΛPostureNorm =

NDoFs(cid:88)

i=1

(cid:26) 0
αi

, if IsTwister(ΛSki)
otherwise

(22)

Depending on the target application, and the embodiment used, one can use different values for the error measure
weights, and for the error threshold. We share, as an example, that for a 5-link robotic manipulator aimed at entertainment
applications, where expressivity and responsiveness is more important than precision, we achieved good results using
an error threshold of 0.04, with a weight of 1.0 for ΛOrientationErrWeight and 0.2 for ΛPostureErrWeight. As such, we took these
values as a reference when evaluating the algorithm as we will report further in the appropriate section of the document
(Section 4).

3.7 The Nutty Motion Filter

The ﬁnal component of the pipeline is the Nutty Motion Filter, which we refer to as the NMF [10]. This piece’s function
is to interpolate successive ERIK solutions, to ensure that the ﬁnal produced movement is smooth and continuous.
Furthermore, it can shape the motion to make it appropriate for use with robots.
The NMF allows to deﬁne limits for the velocity, acceleration and jerk8 of the signal. Additionally it includes a set of
tweaking parameters that can be creatively explored to provide different characteristics to the motion, such as allowing
it to respond fast, as in a light character, or respond very slowly and with a lot of inertia, as in a heavy character.

The motion ﬁlter is calculated individually for each joint, at the end of each frame in the animation engine’s animation
cycle, which is not necessarily synchronized (and should not be) with the ERIK solver engine. We recommend not
attaching these given that the ERIK cycle may have inconsistent frame times and drop to a lower rate than is expected
in the animation cycle.
The output of the NMF on each frame is given by the function X(x(t), t(i), s), where x(t) : R+
0 → [Pmin, Pmax] is
the motion signal history, i.e., the previous positions that were output from the ﬁlter. The parameters Pmin and Pmax
represent the minimum and maximum values respectively (e.g. angular limits). Note that each joint may deﬁne its own
limits and motion parameters for the NMF. x(0) corresponds to the initial position of the joint and must be initially
speciﬁed. The function t(i) : N0 → R+
0 (shortened to ti) represents the time at each sample i, such that 0 ≤ ti−1 < ti,
and ti − ti−1 = ∆t, where ∆t is a ﬁxed time-step, calculated from the animation output rate R, such that ∆t = 1
R .
Note that from this deﬁnition, i refers to the current sample, and therefore the current time is always represented by ti,
while the time of the last sample is ti−1 and so on.

Finally, the set-point s is the new target position, and is used to calculate the induced velocity ˙x(ti). With this
consideration, x(ti) is used to represent the output that will be computed of the ﬁlter at the current time (not in the
history yet), while s therefore represents the input. As such, ˙x(ti) must be calculated from s instead of x(ti).

Equation 23 contains the explicit deﬁnition of the NMF equations. Within them we can ﬁnd the various motion
parameters, which we follow to explain.

The β parameter controls the exponent of the position-limiter de-acceleration, allowing to control how close to the
angular limit of the joint the output is allowed to get before being saturated. As β increases, the saturation becomes
more similar to a hard clamping function. The use of a soft limiter allows the output ﬁlter to avoid overshooting any
joint beyond its physical limits, given that in most cases, overshooting at the software’s output level would result in a
hard break at the hardware level. The default value for β is 1.

The {σ, ρ} parameters both represent smoothness and responsiveness respectively, and allow to tweak the ﬁlter, changing
how quickly it responds and how much it is allowed to oscillate. We call these the character parameters, as different
conﬁgurations for them will shape the motion differently. As such we argue that they can be used to model different
character traits, even when the same physical limits are enforced. The smoothness parameter σ will ease out the
oscillations. However, depending on other ﬁlter parameters such as the physical limits, fully easing out might become
too slow and make the motion seem too muddy and ﬂat. That is where the responsiveness parameter ρ comes in, which
allows to precipitate the easing out, so that it may still be smooth, but faster, and thus, more responsive.

8Jerk is commonly used in robotics. It is the derivative of the acceleration. Think of it as the speed at which the acceleration

changes.

18

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Please refer to the Nutty Animation paper [10] for more details and examples on the Nutty Motion Filter and the use of
its parameters.

χ(x, ti) = x(ti−1) + λ(ψ(x, ti), velocity_limit)

ψ(x, ti) = ˙x(ti−1) + λ(

ξ(x, ti) = ¨x(ti−1) + λ(

ξ(x, ti) − ˙x(ti−1)
∆t

, acceleration_limit)

v·H(v)− ˙x(ti−1)
∆t

− ¨x(ti−1)

∆t

, jerk _limit)

v = Ω( ˙x(ti), x(ti−1), Pmax, Pmin, β)

˙x(tk) =

H(v) =

λ(x, k) =

Ω( ˙x, x, Pmax, Pmin, β) =

α =

3.8 The Superpoint






v
2

k
2



s−x(tk−1)
∆t

, if k = i

x(tk)−x(tk−1)
∆t

otherwise

(cid:32)

·

tanh

(cid:18)(cid:16) |v|
1 − ρ

(cid:17)1−σ

(cid:19)

(cid:33)

− π

+ 1

, 0 ≤ σ ≤ 1, 0 ≤ ρ < 1

(23)

· tanh(x/

(cid:32)

˙x ·

1 −

)

k
2
(cid:18)

(cid:19)2β(cid:33)
,

x−Pmin−α
α

if (x > α & ˙x > 0) | (x < α & ˙x < 0)

˙x,


Pmax − Pmin
2

otherwise

In order for some of the calculations to work on the end-point link, we created the concept of the Superpoint. This is a
fake, 0-DoF joint, used within Postures, that extends the end-point’s segment. It allows the End-point to be treated as if
it had a child link with 0-DoF. Whenever the Posture’s data for the End-point is changed, the data for the Superpoint is
also updated, using the rules in Equation 24. Also note, by the deﬁnitions in Table 2 that the Superpoint may be referred
to either as ΨEEChild or ΛSkN +1.

ΨEEChildθ
ΨEEChildQ
ΨEEChildρ

3.9 ERIK Extensions

= 0

Let Ψ be the posture and EE the Endpoint

= ΨEEΩ
= ΨEEρ + Rotate(EEσ, ΨEEΩ )

(24)

Not all embodiments and application pose the same requirements. As such, ERIK was designed with the idea of
extensions (Ξ) in mind. Think of extensions as options that you may want to have activated or not, which may change
the way the algorithm runs, and thus can result on better outcomes for a given situation (while possibly providing
worse outcomes, for a different situation, with different criteria). In that sense, Extensions fall in the category of
Hyperparameters, and are therefore contained within those. The extensions we have designed and included in the
algorithm on this paper were all found to yield better results given the purpose we deﬁne (i.e., entertainment). If your
purpose or criteria is different, there is an option to disable such extensions, to modify them, or even to create new ones.
The currently included extensions are:

ΞSymmetricEndpoint Allows the algorithm to ﬂip the end-point upside down. This is useful if the end-point is symmetric,
and can be used both ways. By using such a design, and activating this extensions, the possible solution space
doubles, and therefore allows the algorithm to properly solve in many more cases.

ΞAvoidEdges Instructs the algorithm to avoid positioning joints exactly on its angular limits. In cases where some minor
deviation from the goals is accepted, this extensions helps to avoid dead-lock situation when the joint limits
are equivalent to singularity-prone angles (such as ± π
2 ).

19

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

ΞNonConvOffsetTrick Allows ERIK to attempt the Non-converging Offset Trick when a non-converging execution is
detected. This trick applies a small, random orientational offset to the target orientation in cases where the
execution has become non-converging. It results in an increase on the amount of cases where the algorithm is
able to converge, as long as a minor deviation from the goals is accepted. The deviation applied is deﬁned by
hyperparameter ΛDisturbanceθ.

ΞNonConvCCDTrick Allows ERIK to run the CCD algorithm on a non-converging solution, after the Non-converging
Offset Trick failed to bring the execution into a converging state. It typically results in achieving the orientation
goal esier, while allowing the posture goal to become more disrupted (as expected through the direct use of
CCD).

4 Evaluation

Before claiming on the quality and success of ERIK, we are required to run extensive evaluation procedures. Given that
the algorithm aims at being used with any embodiment and expressive pose created by animators, we did not want to
access if the resulting solutions were able to solve particular use cases, as those should be tailored creatively by such
animators in the future. Instead, we realized that we wanted to assure that the algorithm would be able to fulﬁll an
animator’s intentions while authoring expressive postures for use with ERIK. Therefore, given an expressive posture, we
wanted to test how well the algorithm was able to hold its shape, while orienting its endpoint towards various different
target orientations. At the same time, we were concerned with how well the resulting solution effectively aimed at the
given target orientation, regardless of the resulting expression. This is because, for interactive, real-work situations, we
consider it particularly important to get the aiming right, so that the character is believable, and is able to provide an
immersive experience for the user. The expressivity of any particular posture is not, in fact, evaluated. Instead, the
evaluation focused on what can be regarded as a meta-expressivity, i.e., given any posture, which an animator would
have thought to be appropriately expressive for some purpose, we measure how well the algorithm is able to reach a
shape that is similar to the one given by that posture, and that capability is what is evaluated as the expressive goal.

With the purpose of evaluating how well ERIK solves both the orientational goals and the expressive goals, we
performed what can be dubbed as a brute-force evaluation procedure. This procedure consisted of generating many
different expressive postures, and testing how well ERIK is able to solve them for a large set of different orientation
targets. All this was done for several different embodiments. It is impossible to cover every possible case through such
approach. However we consider that the tested cases are a sufﬁcient reﬂection of how the algorithm performs in general,
and are representative of both 1) the space of different expressive postures that any animator would possibly produce;
and 2) the space of different orientations to which the character might possibly have to face.

Additionally we compared ERIK against an existing technique. In this case we followed the description by Baerlocher
on how to solved an IK problem for multiple tasks [44] based on the DLS method. Taking the example of a two-priority
problem, the ﬁrst task, with higher priority, would be the orientation constraint, while the secondary task, of lower
priority, would be the postural constraint. The technique was evaluated in the same way we tested ERIK with multiple
embodiments, and the results were further included in the same analysis.

4.0.1 Error Measures

Through preliminary experimentations, we decided to established a weight of 1.0 for (cid:15)Orientation and 0.2 for (cid:15)Posture, along
with an error threshold ΛThresholdε of 0.04. The use of these weights states that it is more important to get the orientation
goal solved than the expressive posture one. This is because we prefer that the resulting solution is properly aiming
at the target orientation, and, because we are aiming at expressive applications, we tolerate that the posture may fall
slightly out of shape, as long as it is still within an acceptable amount of disﬁgurement.

As to the error threshold, while it should be adapted to each embodiment, we found 0.04 to be a decent tolerance to
demonstrate and compare the results among different embodiments. In a real-world application, we would have tweaked
a different error tolerance for each of the different skeletons.

4.0.2 Evaluation Embodiments

In order to see how the algorithm performed for embodiments with various amounts of DoFs, we established 7 different
test skeletons, which are presented in Table 5.

It is important to note that we have included skeletons with a low number of DoFs in order to validate that the algorithm
behaves as expected, even in such highly constrained situations. Our hypothesis here is that these low-DoF skeletons
will yield very poor results, and that by adding more DoFs, or conﬁguring them in different ways and with different

20

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

angular limits, we can augment the expressive capabilities of the expressive character, which should be proven by
yielding better results in the same type of evaluation.

21

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Table 5: Deﬁnition of test-skeletons used in the evaluation procedure. In the ﬁgures, green nodes represent a (cid:126)Y -oriented
rotation axis, while a red one is oriented with (cid:126)X, and blue with (cid:126)Z.

Skeleton

# DoFs and
rotation axis
sequence
(root to endpoint)

Angular Range

Illustration

A

B

C

D

E

F

G

3 links
Y-X-Y

4 links
Y-X-Z-Y

5 links
Y-X-X-Z-Y

5 links
Y-X-Z-X-Y

5 links
Y-X-Z-X-Y

6 links
Y-X-X-Z-X-Y

[− π
2 , π
2 ]
(all links)

[−π, π]
(all links)

2 , π
[− π
2 ]
(all links)

[−π, π]
(all links)

2 , π
[− π
2 ]
(all links)

2 , π
[− π
2 ]
(all links)

8 links
Y-X-Z-X-Y-X-Z-Y

[− π
2 , π
2 ]
(all links)

4.0.3 Procedure

Each skeleton was used to test ERIK in various different target postures and target orientations. The target postures were
generated by sweeping the angular range of each joint as long as it is not a root twist-joint, or an endpoint twist-joint,
with a given resolution, from its minθ to its maxθ, and combining them to create a large set of postures. Based on our
convention, the twist-joints are the ones whose rotation axis is aligned with (cid:126)Y . In fact, the full set of skeletons has
twist-joints both as root and as endpoints, which means that for each skeleton, all joints except these two were swept to
generate the target postures. The reason why we exclude these two are that they do not change the actual shape of the
posture, and including them would dramatically increase the simulation space.

22

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Figure 7: Five example test postures for skeleton C, representing the type of generated postures tested.

Figure 8: The postural simulation space for skeleton C, illustrating 3789 target postures in three different views.

In Figure 7 we can see examples of different target postures generated for Skeleton C, with 5 links. The whole postural
simulation space for the same skeleton is illustrated in Figure 8, where we see each of the 3789 generated postures
overlapped. Note that the simulation space contains no rotation on the root joint, as it would merely revolve the posture
around the vertical (cid:126)Y axis, and thus would not change the posture’s actual shape.

Similarly, for the target orientations, we wanted to test the most various orientations in all different directions around
the character. For that we swept a horizontal angle αh, a vertical angle αv, and a twist angle αt, all in the range {−π,
π}. The sets of three angles were then used to generate a large number of target orientations (as quaternions) through
the Yaw-Pitch-Roll composition method. It may seem that for αv, sweeping in the range {− π
2 } would have been
enough; however extending the range to {−π, π} introduces additional target orientations in which the target orientation
is deﬁned upside-down. We wanted to include such cases in the evaluation, to ensure that the algorithm was also
numerically capable of dealing with them. As a result, for each of the generated postures of each skeleton, we took a
point-cloud centered on the robot, each point representing a target orientation (including the roll component). This
method allowed us to run the algorithm on a large amount of different parameters, while also taking extra care to ensure
that potential failure points, such as angles set to ±π, and orientations aligned with any of the coordinate axes, were
guaranteed to be included.

2 , π

Figure 9 shows the orientational simulation space as a point-cloud with 7609 points, which was used to run simulations
for each posture or each skeleton. Each point illustrates a polar and azimuthal orientation angle, along with a twist that
is given by the radial distance from the center. Therefore variously twisted orientation quaternions are tested in the
same direction. Both positive and negative twist angles are tested - in this representation, the zero-twist orientations

23

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

are represented by the points that lie at the center of the point-cloud radius, while positive ones increase towards the
exterior, and negative ones towards the interior.

Figure 9: Illustration of a point cloud corresponding to 7609 test samples, each representing a different quaternion to be
used as the target orientation. Each point represents a polar and azimuthal orientation angle, along with a twist that is
given by its radial distance. The colors of the points are modulated from the twist angle (red are negative, blue is zero,
green are positive). Please note that the apparent existence of blue or even green dots at the center is an illusion - they
are in fact part of target directions that are roughly aligned with the viewing direction.

4.0.4 Comparison with the two-priority DLS

In order to compare ERIK against another existing technique, we chose to use the two-task-priority DLS as described
by Baerlocher [44], using Maciejewski’s damping factor [48] and the SVD method. These techniques have already
been reviewed in Section 2.3, and are reiterated in Equation 25.

This technique posed as the most appropriate to provide a comparison to ERIK, as it allows us to deﬁne two tasks: the
orientation task characterized by J1∆θ = (cid:126)e1, with a high priority, and the postural task J2∆θ = (cid:126)e2 with a lower priority.
Both J1 and (cid:126)e1 are calculated as they would usually be for an orientation-constraint task. The secondary task is meant
to keep the joint angles as close as possible to a given target posture Ψ. Therefore we calculate (cid:126)e2, = Ψ − ((cid:126)s + ∆x),
having ∆x = J †λ1
(cid:126)e1, i.e., the current solution to the primary task. We recall also that (cid:126)s is the initial joint conﬁguration.
Therefore the error vector for the secondary task represents the error between the target posture and the posture that
results from solving the primary task. As the secondary task aims at solving towards a given posture, its Jacobian matrix
J2 should correspond to the Identity matrix I n, where n is the number of joints. We add just one correction to it, by

1

24

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

α
(Twist Angle)
π
2
0
π
2
π
2
0

a
(Link Length)
0
30
30
0
0

d
(Joint Offset)
10
0
0
0
40

Link

1
2
3
4
5

θ
(Joint Angle)
0
π
2
0
π
2
π
2

Table 6: Denavit-Hartenberg parameters (classic) used to run the simulations of DLS on Skeleton C.

setting the value for the 1st and nth joint to zero in case that joint is a twist joint, given that as in ERIK, those do not
change the resulting posture’s overall shape.

∆θ = J †λ1
1
r
(cid:88)

J †λ

= (

i=1

(cid:126)e1 + (J2PN (J1))†λ2 ( (cid:126)e2 − J2J †λ1

1

(cid:126)e1)

σi
σ2
i + λ2
σ

)viuT
i

//SVD

PN (J) = I − J †J




d
2



(cid:112)σmin(d − σmin)
0
(cid:107)(cid:126)e(cid:107)
bmax

λσ =

d =

if σmin ≤ d
2
if d
2 ≤ σmin ≤ d
if σmin ≥ d

(25)

The simulations using DLS were ran using Skeleton C, for which each joint can rotate only 90◦ to each side, therefore
making it much more difﬁcult to face orientations that are behind the robot. Using ERIK, that was not a problem given
that we have the extension ΞSymmetricEndpoint, which allows the end-effector to be used upside-down. While this feature is
still used within DLS at the error function level, it is not properly considered by the actual algorithm. We therefore also
apply a correction to the orientation target in order to keep its up-side oriented in a way that it is reachable by the test
skeleton given its joint limits. This correction was the only one that we ever added to enhance the results for a particular
skeleton or technique, and in fact, is used only to enhance the results of the technique to which we are comparing ERIK,
for more realistic results. Initially we considered the results of DLS too bad, and therefore the comparison (while
optimistic for ERIK) was considered inappropriate.

The correction is made by ﬂipping the target orientation’s quaternion upside-down (i.e., performing a rotation of π
about the unit (cid:126)Z vector) in speciﬁc regions of the target space, so that we guarantee that the target’s up-side is always
directed to facilitate the result of DLS using Skeleton C, i.e., when the target is facing forward then its Y-axis will
always be facing down; when the target is facing backward, then its Y-axis will always be facing up. Therefore the
target is never an orientation that is mechanically unachievable a priori.

The classic Denavit-Hartenberg parameters used to model Skeleton C are presented in Table 6.

Finally, because the DLS technique outcome is very dependent on the maximum number of iterations execution, we
also ran several trials with the technique using 100, 200, 400 maximum iterations. Each will be referred to as e.g.
DLS100 or DLS400. Whenever we refer solely to DLS, we will be referring to the best version of it (DLS400).

We started by running a set of simulations using DLS100_nopost, which is DLS100 without the homogeneous solution,
i.e., without the second part of the equation which attempts to solve for the target posture using the primary Jacobian’s
null space. The goal with these simulations was to assess how well the DLS implementation was able to solve solely for
orientation targets using Skeleton C, which is highly prone to singularities. Although the technique we follow is stated
to be free of algorithmic singularities, the parametrization of the skeleton may also introduce kinematic singularities
(e.g. gimbal lock). In fact, upon running the simulation using DLS100_nopost, we found that there were many target
orientations for which the algorithm became stuck yielding a very high orientation error, which we attribute to such
type of singularities. In order not to impair the results of the DLS simulations when compared to ERIK (which does
not suffer from such singularities), we further used this simulation to ﬁlter the DLS results in order to remove all the
samples for which the DLS100_nopost version yielded an orientation error above 3x the speciﬁed threshold, thus

25

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

excluding from the comparison exceptionally bad results that were not due to the posture constraint, but to inappropriate
handling of kinematic singularities. As such, in the comparison of ERIK and the DLS variants (Section 4.0.13) the
results from the DLS simulations presented are the results of applying such ﬁlter.

Figure 10 compares the resulting orientation error histograms and normal distribution plots for ERIK and the ﬁltered
DLS100_nopost on Skeleton C. Note that the data from ERIK actually resulted of the full simulation of ERIK with both
orientation and posture targets. Therefore we see that ERIK has performed better in solving the orientation constraint
even through it also had the posture goal. The DLS performed slightly below expectations, but we must consider that
the simulation attempted to orient the end-effector to a very large big range of orientations in full 3D, i.e., pan, pitch and
roll of the end-effector, towards the full vertical and horizontal 360◦range. The DLS results here have been corrected
to match the number of samples of the ERIK one (which was also solved for each posture), therefore presenting a
comparable scale; otherwise considering only the range of orientation targets, the DLS result would present far less
samples and thus make these difﬁcult to compare.

(a) Orientation error histogram for skeleton C running ERIK compared to DLS100_nopost.

(b) Normal distribution plots of the orientation error of ERIK compared to DLS100_nopost.

Figure 10: Comparison of orientation errors of ERIK on Skeleton C compared to DLS100_nopost after ﬁltering out
samples with excessive orientation error in the latter.

4.0.5 Results

Using ERIK, a total of 239 245 243 samples were simulated from 39 739 postures across all 7 skeletons. The DLS was
simulated for a total of 86 491 503 samples from 3789 postures using Skeleton C, in this case using three different
maximum iteration counts. However as explained in the previous section, the DLS results were further ﬁltered resulting
in a total of 61 684 497 selected samples.

The simulations were ran on a high-performance computer cluster (HPCC) containing a mix of nodes with AMD
Opteron 6180 SE and 6344, and AMD EPYC 7401 CPUs, organized into nodes of either 48 or 96 CPUs. In order to
normalize and interpret the performance results from these simulations in comparison with a typical laptop CPU, we
have searched for single-core benchmarks of these CPUs on community-sourced benchmark websites. We took as an
example the Intel i7-7700HQ, which is a popular CPU, featured in many mid and high-end personal laptops, and that is
also at least 2 years old (launched Q1’2017) to represent an average laptop CPU. Despite the multiprocessing capabilities

26

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

of any of them, we were interested in the single-core performance, as each simulated sample ran as a single-core process,
and are also expected to run as such in a real-world application (even if it is used within a multi-threaded/multi-core
application, the IK engine per se should run sequentially in a single thread).

Table 7 shows the highest benchmark of each of these CPUs, using a Linux 64-bit system, as found on the community-
sourced Geekbench website9. We consider these values to stand as an acceptable comparison of how the performance
statistics collected through the HPCC compare to those of an average computer. By considering this score instead of
theoretical values such as MIPS or GFLOPS, we are also considering more of a general performance capability without
considering particular architecture-wise optimizations. For ERIK, all the simulations except the largest one were
arbitrarily assigned to an Opteron node, which leads us to consider an average of both those CPUs for those simulations
(these CPUs were distributed 50/50 among the total). The largest simulation, for Skeleton G, was speciﬁcally assigned
to an EPYC 7401 node. For DLS, the simulations were arbitrarily assigned to any of the available nodes, being mostly
attributed to an Opteron one. However in various cases the simulations were ran on an EPYC node. As such, for the
DLS simulations we consider the weighted average benchmark score for all nodes, given that from a total of 672 CPUs,
there were 192 EPYCs, and 240 of each of the Opteron types.

Table 7: A comparison of the single-core performance of the CPUs used in the HPCC for the simulations, and how they
related with the performance of a typical laptop CPU (ratio).

CPU

Max Benchmark Score

Ratio

Intel i7-7700HQ
AMD Opteron 6180 SE
AMD Opteron 6344
AMD EPYC 7401
AMD 6180 SE & 6344 average
ALL AMD - weighted average (4:5:5)

5341
1615
2233
3853
1924
2475

1.0000
0.3024
0.4181
0.7214
0.3602
0.4634

The statistics regarding the whole procedure are summarized in Table 8. This table contains the number of postures and
total samples ran for each skeleton (recall that each posture was simulated on 7609 target orientations). It additionally
contains various run-time statistics regarding the execution time to process a single sample (posture-orientation pair),
and on the number of iterations that were ran. The execution time presented was corrected based on the ratios from
Table 7 and therefore represent measured time · ratio in order to present all the statistics corrected as if they had all
been ran on an average computer (taking an Intel i7-7700HQ as example).

Table 8: Statistics regarding the evaluation experiments with a total of ∼ 239M samples. Note that for the DLS cases,
we present the total number of postures simulated, but the number of samples corresponds to the result of applying the
ﬁlter explained in the previous section.

Skeleton

A
B
C
C-DLS100
C-DLS200
C-DLS400
D
E
F
G

Number of

Iteration Count

Time per Sample (ms)

DoFs Postures

Samples Min Max Mean

S.D. Min Max Mean S.D.

3
4
5
5
5
5
5
5
6
8

33
377
3 789
3 789
3 789
3 789
3 789
3 789
8 305
19 657

251 097
2 868 593
28 830 501
20 561 499
20 561 499
20 561 499
28 830 501
28 830 501
63 192 745
149 570 113

1
1
1
1
1
1
1
1
1
1

7
10
12
100
200
400
13
12
13
11

4.14
3.42
2.31
63
120
234
2.02
1.93
1.61
1.35

2.17
2.19
2.08
43.6
92.8
191.6
1.67
1.78
1.46
1.02

6
8
6
1.60
1.57
1.55
10
6
13
22

126
189
1165
2112
3822
7520
458
225
368
759

45
45
37
167
298
678
36
28
35
74

28
30
36
121
240
570
30
27
35
63

4.0.6 Analysis of Results: ERIK

After running the simulations on the different skeletons, we collected all the data and plotted the histogram for the error
function and measures, as presented in Figure 12. Each line of the histogram ﬁgure represents an embodiment, from
skeleton A to G, as indicated in the titles of the individual graphs. The ﬁrst column of graphs contains the results for the

9https://browser.geekbench.com/ (accessed January 12, 2019)

27

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

value of the (combined) error function Λφ for each ﬁnal solution. The second and third columns of graphs contain the
ﬁnal error for the individual measures (cid:15)Orientation and (cid:15)Posture. At the top of the ﬁgures matrix we have placed the Legend,
which applies to all the graphs.

Each graph shows the distribution of the error for all the solutions. The vertical axis represents the total count (frequency)
of solutions that yielded a ﬁnal error, given by the horizontal axis. Note also the dashed vertical lines, which represent
the intended maximum error (ΛThresholdε), and also the solid vertical line, which aids in the visualization of the data, by
representing the maximum error produced within the graph’s samples. Note also that the range of the horizontal axis
(error range) is the same in all rows except for the shaded ones in the ﬁrst row, and that in the 5-link skeleton rows, each
column presents the same Y value across all the three rows in order to help comparing between these cases.

Plotting the normal distribution of the error function results for each skeleton, provides further support on the
interpretation of the results beyond the individual histograms, as illustrated in Figure 11. This ﬁgure shows the normal
distribution for the combined error and for each of the error measures, for each of the skeletons except for A, which,
due to its large error, disrupts the presentation of the others (and does not provide a signiﬁcant interpretational value).
The general interpretation taken from the normal plots is that all skeletons performed well regarding the Orientation
Measure, and that the performance on the Posture Measure increased with the number of DoFs in the skeleton. Detailed
interpretations will follow below.

Figure 11: Normal distribution plots of the ﬁnal combined error and error-measures for each skeleton except skeleton A.

4.0.7 Results for Skeleton A

These show that the target orientation goal failed immensely. This was highly expected given that the mechanical
limitations of its joints, with only one pitch joint, limited to [− π
2 ], would not allow it to aim at any orientations below
the horizon. We also see that the posture errors do not seem so bad - that is because being a single-segment embodiment,
the single and only posture it can perform is a straight line. Given that the whole corpus of experiment data would also
generate only straight postures to be tested, it ended up not performing so bad there. Despite that, this case was meant
to test if the algorithm reﬂected the expected results on such a constrained embodiment, with nearly no possibility of
performing expressive postures while aiming at a given direction. The results conﬁrm our hypothesis.

2 , π

4.0.8 Results for Skeleton B

These show a substantial decrease in error compared to Skeleton A. By adding one more DoF, and allowing each DoF to
have a higher range of motion, the skeleton was able to aim even at orientations below the horizon, as can be seen in its
Orientation Error histogram, which always produced an error below the threshold. However, in order to achieve all the
target orientations, the posture goal was largely missed, as seen in its Posture Error histogram. The normal plot shows
that the error for Skeleton B (in red) was largely distributed beyond the speciﬁed threshold on the Posture Measure, and
consequently on the Combined Error. However the graph for the Orientation Measure shows a good performance (its
curve overlaps with the one of Skeleton C, in yellow). Still this skeleton does not represent a useful use-case for ERIK -
instead it provides further support over the validity of the algorithm and its evaluation, as its bad results go in line with
our expectation.

4.0.9 Results for Skeletons C, D, E

By adding another DoF, these results show lower error values compared to those of Skeleton B. We can note that in
particular, the maximum Posture Error has decreased, meaning that the extra DoF provided the character with the ability
to perform more expressive postures towards any direction. In C and E, some Orientation Error outliers have however
produced an error above the intended threshold. However, it seems that there were very few of these situations, which
makes them nearly imperceptible in the graph, if it wasn’t for the Highest Error line.

28

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

(a) Results for skeletons A and B, the 3- and 4-link skeletons, which perform below expectations, but contribute to verify that the
algorithm results the expected results for those cases.

(b) Results for skeletons C, D and E, the three different 5-link skeletons, which start to yield satisfactory results.

(c) Results for skeletons F and G, the 6- and 8-link skeletons, which return the most satisfactory results.

Figure 12: Results of ERIK’s evaluation process. Each line corresponds to one of the seven skeletons used. The columns
correspond to each one’s Error Function result, Orientation Error and Posture Error. Please note that the legend above
the graphs applies to all of them.

29

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

These skeletons start to yield results as we expect: to successfully orient to any given direction, while holding an
arbitrary expressive posture that is allowed to slightly distort in order to ensure the prioritized orientation constraint.
We take these conclusions from the Orientation Error histogram, which contains only some outliers beyond our given
error threshold, and by the fact that the majority of the Posture Error is within the threshold, and that the ones that were
distorted beyond it are contained within at most 3x that threshold, with frequency decreasing as the error increases.

Is is however interesting to perform a comparison between these three 5-link skeletons. Although they all have the same
number of DoFs, they are conﬁgured in different ways. As seen in Table 5, skeleton C has an YXXZY conﬁguration,
while skeletons D and E use an YXZXY conﬁguration. Furthermore, the angular limits of skeleton D are [−π, π] while
skeletons C and E have limits [− π
2 ]. The normal plots make this comparison more explicit. It becomes clear that
from these three (C in yellow, D in green, E in cyan), all performed approximately well in the Orientation Measure,
with Skeleton D performing best in the Posture Measure and the Combined Error, where Skeleton C performed worst.
This draws the conclusion and illustrates that 1) a different joint conﬁguration such as between C and E affects the
performance, with, in this case, the layout of E providing better expressive capabilities than the one of C, while also
showing, as expected, that by providing a wider range of motion, as in D versus E, that D, the one with the wider
motion, can also perform better.

2 , π

4.0.10 Results for Skeleton F

By introducing just one additional DoF as compared to C, D and E, the algorithm increases its performance. It is
interesting here to compare in particular skeleton F to skeleton D, being that F has a lower angular range than D, but an
additional DoF. While it may seem unclear from the histograms which of the two performed best, the normal plots does
elucidate that Skeleton F performs better as seen in the normal distribution of the Combined Error, and of the Posture
Measure. Interestingly skeleton D performed better in the Orientation Measure, however both performed within the
threshold.

4.0.11 Results for Skeleton G

Finally, Skeleton G, with 8 links shows the best results as can be clearly seen in both the histograms and the normal
plots. Again, through the normal plots it is seen to be not the best performer on the Orientation Measure, however, its
ability to perform well on that measure, and perform exceptionally on the Posture Measure make it the best from this
case set.

4.0.12 Results Comparison

The results presented here conﬁrm our initial hypothesis that, as long as an embodiment has enough DoFs, it is able to
use ERIK orient its endpoint towards any given target orientation, while successfully portraying a given expressive
posture with minimal disruption. We group the results in three groups. Skeletons A and B can be seen as proofs of
concepts, that serve to show that the algorithm fails when and how we expect it to fail (in highly constrained skeletons,
with very few DoFs). Skeletons C, D, E and F are representative of cases where the algorithm starts to show positive
results - with 5 or 6 DoFs it is mostly able to comply with all the constraints we have imposed, such as the joint limits
and the error threshold, when solving for an integrated posture-orientation goal. Finally, skeleton F, with 8 DoFs already
represents a case where the problem is solved in the most acceptable way, with both error measures performing below
the threshold for nearly all the tested samples.

4.0.13 Analysis of Results: ERIK vs DLS

The same procedure was followed for analysing the results of the DLS technique. Figure 13 shows the normal
distribution plots of the errors compared to the ones of ERIK with the same skeleton. Here we ﬁnd that despite the
improvements, there was nearly no difference in the general distribution of the errors across the different variations of
DLS. In fact the three curves nearly overlap and become indistinguishable. We additionally detail the mean value and
standard deviation for each of the cases in Table 9, which shows that there was a very slight improvement in the errors
as the maximum number of iterations was increased.

In particular, and as we had already foreseen, ERIK performed better in achieving the correct target orientation. What
we were most interested in ﬁnding out was how the posture error of the DLS would perform. Here we ﬁnd similarly
shaped curves for both ERIK and DLS, although ERIK’s curve is centred around a lower mean error, thus revealing that
it did in fact also perform better than DLS on solving the the posture target.

30

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Figure 13: Comparison of the normal distribution plots of the errors for each DLS version and for ERIK Skeleton-C.

5 Discussion

The ERIK technique is a promising new step in the ﬁeld of character animation, especially for robots and other
interactive and immersive characters that are driven by AI. When driven by such AIs, and/or subject to stimuli such as
user perception, it is important that the character animation engines for real-time, interactive characters, are able to
process the ﬂow of information that arrives through its sensors, and use it to inﬂuence and drive the character’s behavior
and animation. Our work takes an important step in that direction as the results support our initial claim that ERIK
is able to provide expressive inverse kinematics solutions in real-time which simultaneously solve for an expressive
posture goal, and for a target orientational goal.

Aiming at characters that are driven in real-time, and need to be expressive while also using their body to interact,
such as gaze-tracking a person or object, ERIK succeeds in tackling both goals simultaneously for the majority of
the situations. It was expected that by having more DoFs in the embodiment, both goals could be solved with lower
error measures. In average, for a 5-link skeleton, the algorithm took 34ms to calculate a solution, and 74ms for a more
complex 8-link skeleton, yielding a solution rate of 30 and 14 Hz respectively. While it would be desirable to have
higher performance rates, our own implementation has show it to be adequate for real-time applications, as long as the
IK solver is not synchronously running with the output module. By using the Nutty Motion Filter on the output module
to smoothly interpolate the IK solutions in real-time, we are able to achieve smooth, sustained motion that can be used
in such applications.

We have tested various skeleton conﬁgurations and ran extensive simulations in order to validate our claims. It is
arguable how such an evaluation should be performed, however, in order to provide a general view, we opted out of
evaluating the use of a robot using ERIK in a particular application with a smaller set of expressive postures, as that
would also conﬁne the validity of any conclusions to that single embodiment and set of postures. We therefore outlined
the requirements that should be met by the algorithm to allow it to be used in any application, with any posture and with
an arbitrary skeleton layout. Instead of using a small set of animator-designed postures, we took a sample of all the
possible postures that each skeleton would allow to design. Instead of measuring how well a result met an animator’s
expectations (which is a subjective evaluation), we measured how close the resulting postures were to the original
posture in terms of shape, using a heuristic method (the Posture Measure). By ensuring that the resulting posture is
similar to the original, which in a real-world application, would be given by an animator, we expect and claim that the
animator would also ﬁnd the resulting posture satisfactory.

We additionally compared the results of the ERIK simulations to the same simulations using the DLS technique with
postural control as the secondary task. Results showed that ERIK performed better in both the individual orientation task
and the posture task. We argue that the DLS simulations using the tested Skeleton C are prone to kinematic singularities,
which may have not been properly addressed. Therefore the result comparison was made with a ﬁltered version of
the DLS results, in order to excluded samples that seemed excessively bad due to that issue. The ﬁltered results still
show a worse performance compared to ERIK. Furthermore, even if all the kinematic singularities were properly dealt
with in every case, the DLS simulations performed signiﬁcantly slower than ERIK. Therefore, for the problem that

Orientation Error
S.D.
Mean
0.009977
0.005819
0.085997
0.052744
0.085980
0.052652
0.085669
0.052523
Table 9: Mean value and Standard Deviation for the ERIK and DLS variants comparison.

Combined Error
S.D.
Mean
0.021258
0.026614
0.086930
0.087067
0.086897
0.086973
0.086581
0.086831

S.D.
0.021520
0.020593
0.020591
0.020579

Mean
0.020795
0.034323
0.034321
0.034308

ERIK
DLS100
DLS200
DLS400

Posture Error

31

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

we specify, ERIK represents a substantial improvement against using the DLS technique with the secondary task for
posture-control, given that:

• Using ERIK one can use any embodiment even if highly redundant, which would be prone to kinematic

singularities using Jacobian methods;

• ERIK performs on average about 4.5x faster than DLS on a similar task.

6 Future Directions

At the moment we have only implemented support for embodiments that are structured as a single chain of DoFs with
arbitrary rotations axes and limits. In the future we will bring in more features that are part of the FABRIK technique,
such as the support for multiple end-points, which allows for full-body control of e.g humanoids. We will also develop
support for prismatic (sliding) joints, which are more commonly found in robots. One of the reasons why FABRIK was
chosen as the building block for ERIK was because of all those features that it supports by extension, which could later
be introduced into ERIK as well. Currently we identify no theoretical obstacle on the implementation of such features.

One additional potential direction for ERIK is the support of full out-of-the-box animation warping in real-time, i.e.,
given not just a posture, but an animated motion, to have that motion warped so that the end-effector aims at a given
direction, again, in real-time, for an arbitrary embodiment, and without any training or machine learning technique
required. At the moment there is theoretically no obstacle to such a feature, hindered only by the performance of the
algorithm. Because ERIK operates at an unstable rate, with an average of e.g. 14Hz and peaks of 1.3Hz on an 8-link
skeleton, we would be unable to guarantee the proper execution of an animation that runs faster than 1.3fps across its
whole timeline. Further optimization and development is required to achieve performance rates that allow ERIK to be
used seamlessly on animations as well as on postures.

ACKNOWLEDGEMENTS

This work was supported by national funds through FCT - Fundação para a Ciência e a Tecnologia with references
UID/CEC/50021/2019 and SFRH/BD/97150/2013. A special thank you goes to Sergio Almeida from CENTRA
- Center for Astrophysics and Gravitation of Instituto Superior Técnico, who provided access and support to the
High-Performance Computing Cluster used on the algorithm’s evaluation.

References

[1] Frank Thomas and Ollie Johnston. The Illusion of Life: Disney Animation. Hyperion, 1995.

[2] John Canemaker. Tex Avery: The MGM years, 1942-1955. Turner Publishing, 1996.

[3] Eric Goldberg. Character Animation Crash Course! Silman-James Press, 2008.

[4] Sahil Narang, Andrew Best, and Ari Shapiro. PedVR: Simulating Gaze-Based Interactions between a Real
User and Virtual Crowds. VRST ’16 Proceedings of the 22nd ACM Conference on Virtual Reality Software and
Technology, pages 91–100, 2016.

[5] Gokcen Cimen, Ye Yuan, Robert W Sumner, Stelian Coros, and Martin Guay.

Interacting with Intelligent
Characters in AR. Proceedings of the 1st Workshop on Artiﬁcial Intelligence Meets Virtual and Augmented Worlds
(AIVRAR) in conjucntion with SIGGRAPH Asia 2017, 2017.

[6] Bill Tomlinson. From linear to interactive animation: how autonomous characters change the process and product

of animating. Computers in Entertainment (CIE), 3(1):1–20, 2005.

[7] John Lasseter. Principles of traditional animation applied to 3D computer animation. ACM International

Conference on Computer Graphics and Interactive Techniques - SIGGRAPH ’87, 21(4):35–44, 1987.

[8] Joseph Bates. The role of emotion in believable agents. Communications of the ACM, 37(7):122–125, 1994.

[9] Guy Hoffman and Wendy Ju. Designing Robots With Movement in Mind. Journal of Human-Robot Interaction,

3(1):89, 2014.

[10] Tiago Ribeiro and Ana Paiva. Nutty-based robot animation - principles and practices, 2019.

[11] Leila Takayama, Doug Dooley, and Wendy Ju. Expressing thought. In ACM/IEEE International Conference on

Human-Robot Interaction - HRI ’11, page 69, 2011.

32

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

[12] Tiago Ribeiro and Ana Paiva. The Illusion of Robotic Life Principles and Practices of Animation for Robots. In
ACM/IEEE International Conference on Human-Robot Interaction - HRI ’12, number 1937, pages 383–390, 2012.

[13] André Pereira, Rui Prada, and Ana Paiva. Improving social presence in human-agent interaction. In ACM

Conference on Human Factors in Computing Systems - CHI ’14, pages 1449–1458. ACM, 2014.

[14] T Fong. A survey of socially interactive robots. Robotics and Autonomous Systems, 42(3-4):143–166, 3 2003.

[15] Tiago Ribeiro, Doug Dooley, and Ana Paiva. Nutty Tracks: Symbolic Animation Pipeline for Expressive Robotics.
ACM International Conference on Computer Graphics and Interactive Techniques Posters - SIGGRAPH ’13, page
4503, 2013.

[16] Tiago Ribeiro, André Pereira, Eugenio Di Tullio, and Ana Paiva. The SERA ecosystem: Socially Expressive

Robotics Architecture for Autonomous Human-Robot Interaction. In AAAI Spring Symposium, 2016.

[17] Jibo Inc. Jibo Robot, 2018.

[18] Anca D Dragan, Shira Bauman, Jodi Forlizzi, and Siddhartha S Srinivasa. Effects of Robot Motion on Human-
Robot Collaboration. ACM/IEEE International Conference on Human-Robot Interaction - HRI ’15, 1:51–58,
2015.

[19] Guy Hoffman, Rony Kubat, and Cynthia Breazeal. A hybrid control system for puppeteering a live robotic stage
actor. IEEE International Symposium on Robot and Human Interactive Communication - RO-MAN ’08, pages
354–359, 8 2008.

[20] Guy Hoffman and Gil Weinberg. Gesture-based human-robot Jazz improvisation.

In IEEE International

Conference on Robotics and Automation - ICRA ’10, pages 582–587, 2010.

[21] Jesse Gray, Guy Hoffman, Sigurdur Orn Adalgeirsson, Matt Berlin, and Cynthia Breazeal. Expressive, interactive
robots: Tools, techniques, and insights based on collaborations. In ACM/IEEE International Conference on
Human-Robot Interaction - HRI ’10 - Workshop on What do Collaborations with the Arts Have to Say About
Human-Robot Interaction, 2010.

[22] N.I. Badler. Real-time virtual humans. In Proceedings The Fifth Paciﬁc Conference on Computer Graphics and

Applications, number June, pages 4–13, 1997.

[23] W. Scott Neal Reilly. Believable Social and Emotional Agents, 1996.

[24] Justine Cassell and Timothy Bickmore. BEAT : the Behavior Expression Animation Toolkit. Knowledge Creation

Diffusion Utilization, (August):12–17, 2001.

[25] Berardina De Carolis, Catherine Pelachaud, and Isabella Poggi. APML , a Mark-up Language for Believable

Behavior Generation. Informatica, pages 1–22, 2004.

[26] Radosław Niewiadomski, Elisabetta Bevacqua, Maurizio Mancini, and Catherine Pelachaud. Greta : an interactive

expressive ECA system. Environments, pages 1399–1400, 2009.

[27] Ken Perlin and Athomas Goldberg. Improv: A System for Scripting Interactive Actors in Virtual Worlds. ACM
International Conference on Computer Graphics and Interactive Techniques - SIGGRAPH ’96, (212):205–216,
1996.

[28] H Prendinger. MPML: a markup language for controlling the behavior of life-like characters. Journal of Visual

Languages & Computing, 15(2):183–203, 4 2004.

[29] Stefan Kopp, Brigitte Krenn, and Stacy Marsella. Towards a common framework for multimodal generation: The
behavior markup language. In International Conference on Intelligent Virtual Agents - IVA ’06, pages 205–217,
2006.

[30] Alexis Heloir and Michael Kipp. EMBR: A realtime animation engine for interactive embodied agents. 3rd
International Conference on Affective Computing and Intelligent Interaction and Workshops, 1:1–2, 9 2009.

[31] P Ekman and W Friesen. Facial Action Coding System: A Technique for the Measurement of Facial Movement.

Consulting Psychologists Press, Palo Alto, 1978.

[32] Igor S Pandzic and R. Forchheimer. MPEG-4 Facial Animation: The Standard, Implementation and Applications.

John Wiley & Sons, Inc., New York, 2003.

[33] Chris Hecker, Bernd Raabe, Ryan W. Enslow, John DeWeese, Jordan Maynard, and Kees van Prooijen. Real-time
motion retargeting to highly varied user-created morphologies. ACM Transactions on Graphics, 27(3):1, 8 2008.

[34] Marcus Thiebaux, Marina Rey, Andrew N Marshall, Stacy Marsella, and Marcelo Kallmann. SmartBody :
Behavior Realization for Embodied Conversational Agents. Information Sciences, (Aamas):12–16, 2008.

33

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

[35] Andrew W. Feng, Yuyu Xu, and Ari Shapiro. An example-based motion synthesis technique for locomotion and
object manipulation. ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games - I3D ’12, page 95,
2012.

[36] A. Aristidou, J. Lasenby, Y. Chrysanthou, and A. Shamir. Inverse Kinematics Techniques in Computer Graphics:

A Survey. Computer Graphics Forum, 37(6):35–58, 2018.

[37] Ronan Boulic. Hierarchical kinematic behaviors for complex articulated ﬁgures. Interactive computer animation,

(1):1–27, 1996.

[38] Richard Kulpa and Franck Multon. Fast inverse kinematics and kinetics solver for human-like ﬁgures. Proceedings

of 2005 5th IEEE-RAS International Conference on Humanoid Robots, 2005:38–43, 2005.

[39] Nicolas Courty and Elise Arnaud. Sequential Monte Carlo Inverse Kinematics. Research Report, 24:194947–1,

2008.

[40] Luis Unzueta, Manuel Peinado, Ronan Boulic, and Ángel Suescun. Full-body performance animation with

Sequential Inverse Kinematics. Graphical Models, 70(5):87–104, 2008.

[41] Pawan Harish, Mentar Mahmudi, Benoît Le Callennec, and Ronan Boulic. Parallel Inverse Kinematics for

Multithreaded Architectures. ACM Transactions on Graphics, 35(2):1–13, 2016.

[42] Sebastian Starke. A Hybrid Genetic Swarm Algorithm for Interactive Inverse Kinematics. MSc Thesis. PhD thesis,

University of Hamburg, 2016.

[43] Samuel R. Buss. Introduction to inverse kinematics with jacobian transpose, pseudoinverse and damped least

squares methods. University of California, San Diego, Technical Reports., 2009.

[44] Paolo Baerlocher. Inverse kinematics techniques for the interactive posture control of articulated ﬁgures. Epﬂ,

2383:1–156, 2001.

[45] David E. Orin and William W. Schrader. Efﬁcient Computation of the Jacobian for Robot Manipulators. The

International Journal of Robotics Research, 3(4):66–75, 1984.

[46] Samuel R. Buss and Jin-Su Kim. Selectively Damped Least Squares for Inverse Kinematics. Journal of Graphics,

GPU, and Game Tools, 10(3):37–49, 2005.

[47] Anthony A. Maciejewski and Charles A. Klein. Obstacle Avoidance for Kinematically Redundant Manipulators

in Dynamically Varying Environments. The International Journal of Robotics Research, 4(3):109–117, 1985.

[48] Anthony A. Maciejewski and Charles A. Klein. Numerical ﬁltering for the operation of robotic manipulators

through kinematically singular conﬁgurations. Journal of Robotic Systems, 5(6):527–552, 1988.

[49] L.-C.T. Wang and C.C. Chen. A combined optimization method for solving the inverse kinematics problems of

mechanical manipulators. IEEE Transactions on Robotics and Automation, 7(4):489–499, 1991.

[50] Andreas Aristidou and Joan Lasenby. FABRIK: A fast, iterative solver for the Inverse Kinematics problem.

Graphical Models, 73(5):243–260, 2011.

[51] Andreas Aristidou, Yiorgos Chrysanthou, and Joan Lasenby. Extending FABRIK with model constraints. Computer

Animation and Virtual Worlds, 27(1):35–57, 2016.

[52] Joel Brown, Jean Claude Latombe, and Kevin Montgomery. Real-time knot-tying simulation. Visual Computer,

20(2-3):165–179, 2004.

[53] Damian Merrick and Tim Dwyer. Skeletal Animation for the Exploration of Graphs. Australasian Symposium on

Information Visualisation, (invis.au’04), 35:61–70, 2004.

[54] Paolo Baerlocher and Ronan Boulic. Parametrization and range of motion of the ball-and-socket joint. IFIP

Advances in Information and Communication Technology, 68:180–190, 2001.

[55] Micahel Neff and Eugene Fiume. Methods for exploring expressive stance. Graphical Models, 68(2):133–157,

2004.

[56] Michael Patrick Johnson. Exploiting Quaternions to Support Expressive Interactive Character Motion. PhD

thesis, Massachusetts Institute of Technology, 2003.

[57] Cynthia Breazeal, Andrew Brooks, Matt Hancher, Josh Strickon, Cory Kidd, John McBean, and Dan Stiehl. Public
Anemone: An Organic Robot Creature. ACM SIGGRAPH 2002 Conference Abstracts and Applications, page 76,
2002.

[58] Keith Grochow, Steven L. Martin, Aaron Hertzmann, and Zoran Popovi´c. Style-based inverse kinematics. ACM

Transactions on Graphics, 23:522, 2004.

34

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

7 Algorithmic Speciﬁcation

One of this paper’s major contribution is to share the full algorithmic speciﬁcation that allows to implement ERIK.
However it would be impractical and even unintelligible to present the whole algorithm here in detail. Instead we
have done our best to describe in detail only the major parts of it, while presenting either a textual description or a
mathematical formulation for the parts that are less particular to ERIK, and which may be understood and implemented
by someone with appropriate CGI animation knowledge.

Aiming at a more comprehensible reading experience, we have shifted all the detailed algorithms to the next section
of the appendix, 8. The entry point to the algorithm is the CalculateERIK function, outlined in Algorithm 3. This
function takes as input the ERIK Parameters (Π), and Hyperparameters (Λ), which have been described in detail in
Section 3.5.

Some of the macros or functions used in the algorithms are brieﬂy described in the next section. For simplicity, all the
quaternions used are rotation quaternions, i.e, quaternions of unit length. As an additional reminder, please note that the
child link of the end-point link refers to the posture’s SuperPoint (Section 3.8).

7.1 Description of functions used throughout the algorithms

This section outlines a short description and/or mathematical formulation for some of the auxiliary functions and
operations used within ERIK.

EmptySolution(Sk) Return an empty solution for skeleton Sk.
SafeAngle(k, θ, bCycle = False) Returns θ(cid:48) as an angle that is safe for joint k given its maximum and minimum angle

limits, while allowing the angle to cycle instead of purely clamping:

θ(cid:48) =

(cid:26) min(kMaxθ, max(kMinθ, 2π · ( θ
min(kMaxθ, max(kMinθ, θ))

2π − (cid:98) θ

2π (cid:101))))

ifbCycle
otherwise

SetOriFromParent(k, Θ) Sets k’s basis orientation from its parent:
(cid:26) ΘkParentQ · ΘkParentL

ΘkQ =

I

ifnot kIsRoot
otherwise

SetPosFromParent(k, Θ) Sets k’s basis position from its parent:

Θkρ =

(cid:26) ΘkParent ρ + RotVQ(kParent(cid:126)σ, ΘkQ)

(cid:126)0

ifnot kIsRoot
otherwise

SetFrameFromParent(k, Θ) Call SetOriF romP arent(k, Θ) and SetP osF romP arent(k, Θ) and returns the new

Θ.

ApplyFK(Θ, k = ΘRoot) Performs Forward Kinematics calculus on solution Θ starting from node k (optional).
RotVQ((cid:126)v, Q) Returns vector V rotated by quaternion Q.
QAA((cid:126)v, α) Returns a normalized quaternion that represents a rotation of α about the axis (cid:126)v (axis-angle).
VDiffAsQ( (cid:126)v1, (cid:126)v2) Returns the orientation difference between (cid:126)v1 and (cid:126)v2 as a Quaternion.
QDiff(Q1, Q2) Returns rotation difference between Q1 and Q2 as a Quaternion.
TBasis(k, Q(cid:48)) Transforms the world-space basis of link k globally by Q(cid:48) (kQ = Q(cid:48) · kQ).
TBasisRoll(k, Q(cid:48)) Transforms the world-space basis of link k locally by Q(cid:48) (kQ = kQ · Q(cid:48)).
VecAngle( (cid:126)v1, (cid:126)v2) Angle θ between (cid:126)v1 and (cid:126)v2 using atan2.
VecAngle( (cid:126)v1, (cid:126)v2, (cid:126)r) Angle θ between (cid:126)v1 and (cid:126)v2 using atan2 with sign(θ) = −1 if r · ( (cid:126)v1 × (cid:126)v2) < 0 else 1.
LALUT(k, λ) Queries joint k’s LALUT for latitude λ.
TargetLatitude(k, (cid:126)τ ) Calculates the latitude λ for target (cid:126)τ on k’s joint model:

ς = −1 if ˆτ · kP OA < 0 else 1

λ = max(kBottomλ, min(kTopλ,

ˆτ · ˆY + 1
2

))

35

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

PitchRA(k) Returns (cid:126)r such that:

(cid:126)r =

(cid:40) kChildRA

if IsTwister(k) and kIsRoot

kParentRA if IsTwister(k) and not kIsRoot
kRA

otherwise

EPA(Q, (cid:126)u) Ensures Positive Axis on quaternion Q based on a rotation axis (cid:126)u:

EP A(Q) = −Q if (cid:126)u · (cid:126)Qv < 0 else Q

IsTwister(L) Returns True if link L’s rotation axis is aligned with its own segment.

AvoidJointEdge(k, δ) Performs an angular offset of ±δ on joint k if it is currently at its minimum (+δ) or maximum

(−δ) value.

AvoidPostureJointEdges(Ψ, δ) Runs AvoidJointEdge(k, δ) on each joint k in posture Ψ.

BWCD(Ψ|Θ, (cid:126)τ , Λ) Performs BWCD (Section 3.2) on posture Ψ or solution Θ, towards the target direction (cid:126)τ .

CCD(Θ, (cid:126)τ , Λ) Finds a new solution that turns the current solution Θ’s end-point towards direction (cid:126)τ using CCD.

NonConversionDetected(aux, Λ) Checks whether or not the current auxΘε is converging towards a ﬁxed value or

behaving as a cyclic function, and therefore not converging.

NonConvOffsetTrick(aux, k) Shifts the current Target Orientation to a slightly different direction choosing link k

and child as the expected offset solvers, by applying:

Ω(Θ, k, δ) =






QAA(RotV Q(kRA, ΘkQ), δ)

if
|Θkθ − kMinθ| >
|Θkθ − kMaxθ|

QAA(RotV Q(kRA, ΘkQ), −δ) otherwise

δ = ΛDisturbanceθ
k = ΛSkRoot

auxτ = Ω(auxΘ, kChild, δ) · Ω(auxΘ, k, δ) · auxτ

auxTriedNonconvOffset) = T rue

SelectBestSolution(aux) Returns Θ such that:

(cid:26) auxΘ

Θ =

if auxΘε ≤ auxbestΘε

auxbestΘ otherwise

36

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

8 Detailed Algorithms

We start by presenting a map of the algorithms in Figure 14, which serves as a visual index to know where to ﬁnd each
of the pieces, and where they are invoked. Please refer back to Tables 2–4 in Section 3.5 and to the description of
functions in Section 7.1 while following or implementing these algorithmic descriptions.

Figure 14: A map of the algorithmic description of ERIK, to be used as a visual index throughout this section. Each
arrow means that the algorithm from where it departs invokes the algorithm at which it arrives.

Algorithm 2: InitializeSolution
input
output :aux

:τ, Ψ, Λ

// Orientation, Posture, Hyperparams
// container of execution variables

1 begin
2

aux ← ∅
auxτ ← τ
if IsTwister(ΛSkEE) then

3

4

5

6

7

8

9

10

11
12 end

auxτ ← τ · RotVQ( ˆY , ΨEndP ointθ )

auxΨ ← Ψ
auxpreviousΘ ← EmptySolution(ΛSk)
CalculateSolutionError(auxpreviousΘ, τ, Ψ, Λφ)
auxbestΘ ← auxpreviousΘ
auxΘ ← auxpreviousΘ
return aux

// save a working copy of orientation

// save a working copy of posture

37

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 3: CalculateERIK
input
output :Θ

:Π, Λ

// Parameters, Hyperparameters
// Solution

1 begin
2

aux ← InitializeSolution(Πτ , ΠΨ, Λ)
auxΨ ← BWCD_Posture(auxΨ, aux(cid:126)τ , Λ)
if ΛΞAvoidJointEdges then

AvoidPostureJointEdges(auxΨ, ΛDisturbanceθ)

for i ← 1 to ΛMaxERIKIterations do
for k ← ΛSkEE to ΛSkRoot do

τ ← auxτ if kIsEndPoint else auxΘkQChild
ForwardPhase(k, τ, auxΨ, auxΘ, Λ)

end
for k ← ΛSkRoot to ΛSkEE do

BackwardPhase(aux, k, Π, Λ)

end
if SolutionOK(Π, Λ, aux) then

return auxΘ

auxΘ ← BWCD_Solution(auxΘ, aux(cid:126)τ , Λ)
if SolutionOK(Π, Λ, aux) then

return auxΘ

if NonConversionDetected(aux, Λ) then

if ΛΞNonConvOffsetTrick and ¬auxTriedNonconvOffset then
aux ← NonConvOffsetTrick(aux , Λ)
continue

else if ΛΞNonConvCCDTrick then

auxΘ ←CCD(auxΘ, auxτ , Λ)
if SolutionOK(Π, Λ, aux) then

return auxΘ

else

aux ← CCD(EmptySolution(ΛSk), auxτ , Λ)
if SolutionOK(Π, Λ, aux) then

return auxΘ

return SelectBestSolution(aux)

// Try from a new empty solution.

end
return SelectBestSolution(aux)

33
34 end

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

Algorithm 4: CalculateSolutionError
input
output :The solution’s combined error Θ(cid:15)

:Θ, τ, Ψ, Λ

// Solution, Target Orientation, Target Posture, Hyperparameters

1 begin
2

3
4 end

(cid:15) ← ΛOrientationErrorWeight· OrientationError(ΘEE, τ, Λ) + ΛPostureErrorWeight· PostureError(Θ, Ψ, Λ)
return (cid:15)

38

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 5: OrientationError
input
output :The solution’s orientation error (cid:15)Orientation

:Φ, τ, Λ

// End-Effector Solution, Target Orientation, Hyperparameters

1 begin

2

3

4

5

6

ω(cid:15) ← min(|τ −ΦEEΩ |,|τ +ΦEEΩ |)
if ΛΞSymmetricEndpoint then

√

2

ξ ← QAA(RotVQ( ˆY , ΦEEΩ ), π) · ΦEEΩ
ξ(cid:15) ← min(|τ −ξ|,|τ +ξ|)
ω(cid:15) ← min(ω(cid:15), ξ(cid:15))

√

2

// Absolute distance between quaternions

// Rotate symmetrically about its rotation axis
// Absolute distance between quaternions

return ω(cid:15)

7
8 end

Algorithm 6: PostureError
input
output :The solution’s posture error measure (cid:15)Posture

:Θ, Ψ, Λ

// Solution, Target Posture, Hyperparameters

1 begin
2

(cid:15) ← 0,
i ← 0
(cid:126)s ← (cid:126)t ← ΛSkRoot σ
a ← ΛErrorAggravation
for k ← ΛSkRoot to ΛSkEE do
if ¬IsTwister(k) then

3

4

5

6

7

8

9

10

11

12

13

end
return

14
15 end

(cid:126)u ← ΘkChildρ − Θkρ
(cid:126)v ← ΨkChild (cid:126)ρ − Ψk(cid:126)ρ
dsu ← 1 − (1+(cid:126)s·(cid:126)u)
dtv ← 1 − (1+(cid:126)t·(cid:126)v)
(cid:15) ← (cid:15) + ai ∗ |dtv − dsu|
i ← i + 1,

(cid:126)s ← (cid:126)u,

2

2

(cid:126)t ← (cid:126)v

(cid:15)
ΛPostureNorm

Algorithm 7: SolutionOK
:Π, Λ, aux
input
output :Is auxΘ acceptable (Boolean)

// Parameters, Hyperparameters

1 begin
2

3

4

5
6 end

CalculateSolutionError(auxΘ, Πτ , ΠΨ, Λφ)
if auxΘε ≤ auxbestΘε then
auxbestΘ ← auxΘ
return auxΘε ≤ ΛThresholdε

39

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 8: ForwardPhase
input
output :Intermediate solution Θ after forward phase

:k, τ, Ψ, Θ, Λ /* Joint, Target Orientation, Target Posture, (aux) Solution, HypParams

*/

1 begin
2

if kIsEndPoint then Θkρ ← Ψk(cid:126)ρ
if not kIsRoot then

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

(cid:126)s ← RotVQ(k(cid:126)σ, ΘkQ)
TBasis(k, VDiffAsQ((cid:126)s, Ψk(cid:126)ρ − ΨkParent (cid:126)ρ))
(cid:126)rp ← RotVQ(PitchRA(k), ΨkQ)
(cid:126)rs ← RotVQ(PitchRA(k), ΘkQ)
θ ← VecAngle(proj (cid:126)rs, (cid:126)Θkd
TBasisRoll(k, QAA( ˆY , θ))

, proj (cid:126)rp, (cid:126)Θkd

, (cid:126)Θkd )

if not IsTwister(k) then
(cid:126)s ← ΨkChild (cid:126)ρ − Ψk(cid:126)ρ
(cid:126)rp ← (cid:126)0, n ← k, f lipped ← F alse
while (cid:107) (cid:126)rp(cid:107) ≈ 0 and n (cid:54)= ∅ do

m ← n
(cid:126)p ← n(cid:126)σ if nIsRoot else (Ψn(cid:126)ρ − ΨnParent (cid:126)ρ)
(cid:126)rp ← ˆp × ˆs
if nIsRoot and notf lipped then
− ΨkChild (cid:126)ρ

(cid:126)s ← ΨkChildChild (cid:126)ρ
f lipped ← T rue, n ← nChild

else (cid:126)s ← (cid:126)p, n ← nParent

(cid:126)s←RotVQ(PitchRA(m), I if mIsRootelse ΘmParentQ)
(cid:126)p ← RotVQ(PitchRA(m), ΘkQ )
if ((cid:126)p · (cid:126)rp < 0) (cid:54)= ( (cid:126)rp · (cid:126)s < 0) then (cid:126)rp ← − (cid:126)rp
, (cid:126)Θmd)
θ ← VecAngle(proj(cid:126)s, (cid:126)Θmd
PropagateRollDown(QAA( ˆY , θ), k, Θ)

, proj (cid:126)rp, (cid:126)Θmd

if not kIsEndPoint then

(cid:126)a ← (cid:126)kRA if IsTwister(kChild) else
(cid:126)r ← RotVQ((cid:126)a, ΘkQ)
(cid:126)rc ← RotVQ((cid:126)a, ΘkChildQ)
if IsTwister(kChild) and (cid:126)rc · (cid:126)r < 0 then

(cid:126)kChildRA

else if (cid:107)proj (cid:126)rc

PropagateRollUp(QAA( ˆY , π), k, Θ, T rue)
(cid:126)Θkd (cid:107) ≈ 0 then
(cid:126)Θkd , (cid:126)Θkd )

θ ← VecAngle(proj (cid:126)rc
PropagateRollUp(QAA( ˆY , θ), k, Θ, θ ≈ π)

(cid:126)Θkd (cid:107) ≈ 0 or (cid:107)proj(cid:126)r

(cid:126)Θkd , proj(cid:126)r

Qy, Qp, Qr ← Y P R(QDiff(ΘkQ, τ ), kRA)
if kIsEndPoint and Qrθ > π

2 then
Qr ← QAA( (cid:126)Qrv , π − Qrθ )
else if kIsEndPoint and Qrθ < − π

2 then

Qr ← QAA( (cid:126)Qrv , −π − Qrθ )

if IsTwister(k) then

Θkθ ← SafeTwist(k, Qyθ + Qrθ )

else

Θkθ ← LocalSwing(k, RotVQ((cid:126)τ , ΘkQ∗ ))
if Qr (cid:54)= I then PropagateRollDown(Qr, k, Θ)

return FinishForward(k, Θ, Λ)

45
46 end

40

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 9: PropagateRollDown
input
output :Solution Θ with Roll propagated down the kinematic chain.

:Q, k, Θ

1 begin
2

repeat

// Roll, Start link, Solution

k ← kParent
ΘkQ ← ΘkQ · Q

until kIsRoot
return Θ

6
7 end

Algorithm 10: PropagateRollUp
:Q, k, Θ, bF lip = F alse
input
output :Solution Θ with Roll propagated up the kinematic chain, with pitch angles ﬂipped if bF lip = T rue.

1 begin
2

while ¬kIsEndPoint do

ΘkChildQ ← ΘkChildQ · Q
if bF lipP itch and not IsTwister(kChild) then

ΘkChild θ ← −ΘkChild θ

k ← kChild

end
return Θ

8
9 end

Algorithm 11: YPR
:Q, (cid:126)R

input
output :Qy, Qp, Qr such that Q = Qy · Qp · Qr

1 begin

// Quat orientation, Rotation axis

(cid:126)u ← ˆY , (cid:126)x ← (cid:126)R
(cid:126)yQ ← (cid:126)u · QM
(cid:126)xQ ← (cid:126)x · QM
(cid:126)N ← (cid:126)u × (cid:126)yQ
if (cid:107) (cid:126)N (cid:107) = 0 then

if (cid:126)u · (cid:126)yq ≈ 1 or (cid:107) (cid:126)yQ(cid:107) = 0 then

Qy ← Qp ← I
Qr ← QAA((cid:126)u, Qθ if (cid:126)u · (cid:126)Qv ≈ 1 else − Qθ)

else

Qy ← I
Qp ← QAA((cid:126)x, −π)
Qr ← QAA((cid:126)u, VecAngle((cid:126)x, (cid:126)xQ, (cid:126)yQ))

else

if (cid:126)N · (cid:126)x < 0 then (cid:126)N ← −vecN
Qy ← QAA((cid:126)u, VecAngle((cid:126)x, ˆN , (cid:126)u))
Qp ← QAA((cid:126)x, VecAngle((cid:126)u, (cid:126)yQ, ˆN ))
Qr ← QAA((cid:126)u, VecAngle( ˆN , (cid:126)xQ, (cid:126)yQ))
return EPA(Qy, (cid:126)u), EPA(Qp, (cid:126)x), EPA(Qr, (cid:126)u)

19
20 end

41

3

4

5

3

4

5

6

7

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 12: SafeTwist
input
output :Safe θ as cyclic local twist for ERIK’s Joint Model

:k, θ

// Joint, Angle

1 begin
2

θ(cid:48) ← SafeAngle(k, θ, bCycle ← T rue,)
β ← (θ − θ(cid:48)) mod π
if |β| > 0 and ¬kIsEndPoint then

if θ ≤ kMinθ then θ(cid:48) ← −kMinθ + β
else if θ ≥ kMaxθ then θ(cid:48) ← −kMaxθ + β

3

4

5

6

return θ(cid:48)

7
8 end

Algorithm 13: LocalSwing
input
output :θ local swing angle using ERIK’s LALUT

:k, (cid:126)τ

// Joint, Target direction (local)

1 begin
2

3
4 end

λ ← TargetLatitude(k, (cid:126)τ )
return SafeAngle(k, LALUT(k, λ))

Algorithm 14: FinishForward
input
output :Solution Θ after Forward Phase

:k, Θ, Λ

// Link, Partial Solution, Hyperparams

3

4

5

6

7
8 end

1 begin
2

if ΛΞAvoidEdges then

Θkθ ← AvoidJointEdge(k, ΛDisturbanceθ)

if ¬kIsEndPoint then

ΘkQ ← EPA(QDiff(ΘkΩ , ΘkChildQ · ΘkQ), kRA,)
Θkρ ← ΘkChildρ − RotVQ(k(cid:126)σ, ΘkChildQ)
Θ ← ApplyFK(Θ, k,)

42

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 15: BackwardPhase
input
output :(Final) Solution Θ after backward phase

:k, τ, Θ, Λ

/* Joint, Target Orientation, (aux) Solution, Hyperparameters */

1 begin
2

Θ ←SetFrameFromParent(k, Θ,
) if IsTwister(k) then
if ¬kIsEndPoint then

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

Θ ←BackwardChildRoll(k, Θ, Λ)

θ ←BWTwist(τM , ΘkΩM
if kIsEndPointand ΛΞSymmetricEndpoint then

)+Θkθ

θ(cid:48) ←BWTwist(τM · QAA( ˆY , π), ΘkΩM
if |θ(cid:48)| < |θ| then θ ← θ(cid:48)

)+Θkθ

Θkθ ← θ

else

Q ← ΘkQ∗ · τ
λ ← TargetLatitude(k, (cid:126)Qy)
θ ← SafeAngle(k, LALUT(k, λ))
if ¬kIsEndPoint then

θ(cid:48) ← SafeAngle(k, LALUT(k, −λ))
(cid:126)σ ← RotVQ(k(cid:126)σ, ΘkQ · QAA(kRA, θ))
(cid:126)σ(cid:48) ← RotVQ(k(cid:126)σ, ΘkQ · QAA(kRA, θ(cid:48)))
(cid:126)d ← RotVQ(k(cid:126)σ, ΘkChildΩ )
if (cid:126)σ(cid:48) · (cid:126)d > (cid:126)σ · (cid:126)d then
Swap(θ, θ(cid:48))
Swap(σ, σ(cid:48))
(cid:126)d ← RotVQ(k(cid:126)σ, τ )
if (cid:126)σ(cid:48) · (cid:126)d > (cid:126)σ · (cid:126)d then

θ ← θ(cid:48)

Θkθ ← θ
if ¬kIsRoot and IsTwister(kParent) then

(cid:126)rt ← RotVQ(kRA, τ )
(cid:126)rk ← RotVQ(kRA, ΘkQ)
(cid:126)rp ← RotVQ(kParentRA, ΘkParentQ )
if |(cid:126)rt · (cid:126)rp| = 1 or | (cid:126)rk · (cid:126)rp| = 1 then

(cid:126)rt ← RotVQ(kOA, τ )
(cid:126)rk ← RotVQ(kOA, ΘkQ)

(cid:126)p ← proj (cid:126)rt
if ¬kIsEndPoint then

(cid:126)rp

q ← QAA(ΘkChildd , VecAngle((cid:126)rt, (cid:126)p, ΘkChild d ))
(cid:126)p ← projRotVQ(kRA,q·τ ) (cid:126)rp

(cid:126)rp, (cid:126)p, (cid:126)rp)

γ ← VecAngle(proj (cid:126)rk
ΘkParent θ ← γ + ΘkParent θ
Θ ←SetFrameFromParent(k, Θ,
)

return FinishBackward(k, Θ)

42
43 end

43

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

if cBz · (cid:126)cD ≈ 1 or cBz · (cid:126)cD ≈ −1 or cBx · Θkd ≈ 0 then axis ←’x’
else axis ←’z’

Algorithm 16: BackwardChildRoll
input
output :Θ with ΘkChildRA aligned with plane ⊥ to ΘkChildd

:k, Θ, Λ

1 begin
2

if ¬RotVQ(kChildRA, ΘkChildQ) · ΘkQy
(cid:126)cD ← ΘkChild d cB ← ΘkChildQM
axis ←’y’
if cBy · (cid:126)cD ≈ 1 or cBy · (cid:126)cD ≈ −1 or
Θkd · (cid:126)cD ≈ 1 or Θkd · (cid:126)cD ≈ −1 then

= 0 then

(cid:126)cv ← cBaxis , (cid:126)pv ← ΘkQaxis
(cid:126)cD, (cid:126)pp ← proj (cid:126)pv
(cid:126)cp ← proj (cid:126)cv
q ← QAA( (cid:126)cD, VecAngle( (cid:126)cp, (cid:126)pp, (cid:126)cD)) · ΘkChildQ
q(cid:48) ← QAA( (cid:126)cD, VecAngle( (cid:126)cp, (cid:126)pp, − (cid:126)cD)) · ΘkChildQ
if qaxis · (cid:126)pv < q(cid:48)
ΘkChildQ ← q(cid:48)

axis · (cid:126)pv then

(cid:126)cD

else

ΘkChildQ ← q

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

end
return Θ

18
19 end

Algorithm 17: BWTwist
input
output :Angle the joint should twist to achieve the given target τ based on its current orientation Ω

:τ, Ω

//Target, Current Orientation

1 begin
2

dzy ← τz · Ωy
dxy ← τx · Ωy
if dzy ≈ 1 or dzy ≈ −1 or |dxy| < |dzy| then

return VecAngle(Ωx,projτx

else

Ωy,Ωy)

3

4

5

6
7 end

return return VecAngle(Ωz,projτz

Ωy,Ωy)

Algorithm 18: FinishBackward
input
output :Solution Θ after BackwardPhase

:k, Θ

1 begin
2

if ¬kIsRoot and IsTwister(kParent) then

3

Θ ←FinishBackward(kParent, Θ)

Θ ← SetOriFromParent(k, Θ)

4
5 end

44

// Link, Partial Solution

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 19: BWCD_Posture
input
output :Ψ result of the BWCD algorithm as a new posture.

:Ψ, (cid:126)τ , Λ

// Posture to solve, Target Direction, Hyperparameters

1 begin
2

for i ← 1 to ΛMaxCCDIterations do
for k ← ΛSkRoot to ΛSkEE do

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

(cid:126)pd ← RotVQ(ΛSkEE ˆσ, ΨSuperpointQ
if CCDTest((cid:126)τ , (cid:126)pd, Λ) then

)

return Ψ

end
(cid:126)r ← RotVQ(kRA, ΨkQ)
(cid:126)pdp ← proj (cid:126)pd(cid:126)r
(cid:126)tdp ← proj(cid:126)τ(cid:126)r
if (cid:107) (cid:126)pdp(cid:107) (cid:54)= 0 and (cid:107) (cid:126)tdp(cid:107) (cid:54)= 0 then
α ← VecAngle( (cid:126)pdp, (cid:126)tdp, (cid:126)r)
if (cid:98)|α|(cid:101) > 0 then

q ← EPA(QAA((cid:126)r, α), kRA)
(cid:126)p ← Ψk(cid:126)ρ
Ψkθ ← Ψkθ + α
for j ← k to ΛSkEE do

Ψj(cid:126)ρ ← (cid:126)p
c ← jChild if not jIsEndPoint else ΨSuperPoint
ΨcQ ← q · ΨcQ
if jIsEndPoint then
ΨSuperpoint(cid:126)ρ

← (cid:126)p + RotVQ(j(cid:126)σ, ΨcQ )

else

(cid:126)p ← (cid:126)p + RotVQ(j(cid:126)σ, ΨcQ)

end

end

end

end
(cid:126)pd ← RotVQ(ΛSkEE ˆσ, ΨSuperpointQ
if CCDTest((cid:126)τ , (cid:126)pd, Λ) then

)

return Ψ

end

end
return Ψ

34
35 end

Algorithm 20: CCDTest

:(cid:126)t, (cid:126)ee, Λ, returnError=False

input
output :Current (cid:126)ee is an acceptable solution for a CCD-based algorithm.

// Joint, Target, EndEffector, Hyperparameters, (optional)

1 begin

(cid:101)

(cid:15) ← (cid:98)− (cid:126)t· (cid:126)ee−1
if returnError then return (cid:15) ≤ ΛCCDPrecision, (cid:15)
return (cid:15) ≤ ΛCCDPrecision

2

2

3

4
5 end

45

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 21: BWCD_Solution
input
output :Θ(cid:48) result of the BWCD algorithm as a new solution.

:Θ, τ, Λ

// Solution to solve, Target Direction, Hyperparameters

1 begin
2

for i ← 1 to ΛMaxCCDIterations do

(cid:126)eod ← ΘEEd
for k ← ΛSkRoot to ΛSkEE do

if CCDTest((cid:126)τ , (cid:126)eod, Λ) then

ΘEEθ ← ΘEEθ +BWTwist(τM , ΘEEΩM
return Θ

)

end
(cid:126)r ← RotVQ(kRA, ΘkΩ )
(cid:126)top ← proj(cid:126)τ(cid:126)r
(cid:126)eop ← projeod(cid:126)r
if (cid:107) (cid:126)(cid:126)top(cid:107) (cid:54)= 0 and (cid:107) (cid:126)(cid:126)eop(cid:107) (cid:54)= 0 then

Θkθ ← Θkθ + VecAngle( (cid:126)eop, (cid:126)top, (cid:126)r)
ApplyFK(Θ, k)
(cid:126)eod ← ΘEEd

end

end
if CCDTest((cid:126)τ , (cid:126)eod, Λ) then

ΘEEθ ← ΘEEθ +BWTwist(τM , ΘEEΩM
return Θ

)

end

end
ΘEEθ ← ΘEEθ +BWTwist(τM , ΘEEΩM
return Θ

24
25 end

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

)

46

EXPRESSIVE INVERSE KINEMATICS SOLVING IN REAL-TIME
FOR VIRTUAL AND ROBOTIC INTERACTIVE CHARACTERS

Algorithm 22: CCD
:Θ, τ, Λ
input
output :Θ result of the CCD algorithm as a new solution.

// Solution to solve, Target Orientation, Hyperparameters

1 begin
2

(cid:15) ← 10000, last(cid:15) ← 0
(cid:126)td ← (cid:126)τ
(cid:126)ed ← ΘEE (cid:126)d
for i ← 1 to ΛMaxCCDIterations do

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

last(cid:15) ← (cid:15)
for k ← ΛSkEE to ΛSkRoot do

ok, (cid:15) ← CCDTest( (cid:126)td, (cid:126)ed, Λ, returnError = T rue)
if ok then

ΘEEθ ← ΘEEθ +BWTwist(τM , ΘEEΩM
return Θ

)

end
r ← RotVQ(kRA, ΘkQ)
(cid:126)tdp ← proj (cid:126)tdr
(cid:126)edp ← proj (cid:126)edr
if (cid:107) (cid:126)tdp(cid:107) (cid:54)= 0 and (cid:107) (cid:126)edp(cid:107) (cid:54)= 0 then

Θkθ ← Θkθ + VecAngle( (cid:126)edp, (cid:126)tdp, r)
if ΛΞAvoidJointEdges then

AvoidPostureJointEdges(Θ, ΛDisturbanceθ)

ApplyFK(k,)
(cid:126)ed ← ΘEE (cid:126)d

end

end
ok, (cid:15) ← CCDTest( (cid:126)td, (cid:126)ed, Λ, returnError = T rue)
if ok then

ΘEEθ ← ΘEEθ +BWTwist(τM , ΘEEΩM
return Θ

)

end
if |(cid:15) − last(cid:15)| ≤ ΛP recision then

ΘEEθ ← ΘEEθ +BWTwist(τM , ΘEEΩM
return Θ

)

end

end
ΘEEθ ← ΘEEθ +BWTwist(τM , ΘEEΩM
return Θ

35
36 end

)

47

