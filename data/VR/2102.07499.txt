1
2
0
2

y
a
M
8
1

]

R
G
.
s
c
[

2
v
9
9
4
7
0
.
2
0
1
2
:
v
i
X
r
a

An All-In-One Geometric Algorithm for
Cutting, Tearing, and Drilling
Deformable Models

Manos Kamarianakis and George Papagiannakis

Abstract. Conformal Geometric Algebra (CGA) is a framework that
allows the representation of objects, such as points, planes and spheres,
and deformations, such as translations, rotations and dilations as uniform
vectors, called multivectors. In this work, we demonstrate the merits of
multivector usage with a novel, integrated rigged character simulation
framework based on CGA. In such a framework, and for the ﬁrst time,
one may perform real-time cuts and tears as well as drill holes on a
rigged 3D model. These operations can be performed before and/or after
model animation, while maintaining deformation topology. Moreover,
our framework permits generation of intermediate keyframes on-the-ﬂy
based on user input, apart from the frames provided in the model data.
We are motivated to use CGA as it is the lowest-dimension extension
of dual-quaternion algebra that amends the shortcomings of the major-
ity of existing animation & deformation techniques. Speciﬁcally, we no
longer need to maintain objects of multiple algebras and constantly trans-
mute between them, such as matrices, quaternions and dual-quaternions,
and we can eﬀortlessly apply dilations. Using such an all-in-one geo-
metric framework allows for better maintenance and optimization and
enables easier interpolation and application of all native deformations.
Furthermore, we present these three novel algorithms in a single CGA
representation which enables cutting, tearing and drilling of the input
rigged model, where the output model can be further re-deformed in
interactive frame rates. These close to real-time cut,tear and drill algo-
rithms can enable a new suite of applications, especially under the scope
of a medical VR simulation.

Mathematics Subject Classiﬁcation (2010). Primary 68U05.

The authors are aﬃliated with the University of Crete, Greece and the ORamaVR company
(http://www.oramavr.com).
This is an extended version of work originally presented in the CGI 2020 conference, on the
ENGAGE workshop. [15].

 
 
 
 
 
 
2

Keywords. Conformal Geometric Algebra (CGA), Skinning, Inter-
polation, Cutting Algorithm, Tearing Algorithm, Drilling Algorithm,
Keyframe Generation.

1. Introduction

In this work, we introduce a novel algorithm to perform drill in the rigged
model and provide further background knowledge for representing and apply-
ing translations, rotations and dilations (uniform scalings) in multivector form.
Furthermore, we give better insight regarding multivector interpolation and
provide the updated performance results of our optimized cutting algorithm.
Rigged models and their animation and deformation techniques have
been among the most studied topics in computer graphics since their inception,
and especially in the past few years due to the rapid growth of the industry
of Virtual/Augmented Reality and computer games.

Although the linear-blend skinning algorithm for rigged models [19] has
not radically changed over the years, the demand for more robust and eﬃcient
real-time implementations of the animation, led researchers into developing
more complex mathematical frameworks to enhance the overall performance
and decrease running times. Originally [1], the animation techniques were based
on matrix representation of the three basic deformations: translation, rotation
and dilation. The core idea was to be able to apply these deformations to 3D
point by simply multiplying the respective matrices, in the desired order, with
the homogeneous coordinates of the point. Since matrix multiplications are
extremely fast to perform due to GPUs’ ability of parallel processing, matrices
became and still remain the favorite representation class of deformations for
the majority of current state-of-the-art skeletal animation frameworks.

The major drawback of using matrices was discovered when the need of
creating interpolated keyframes highlighted the fact that the interpolation
result of two rotation matrices does not correspond to a rotation matrix. The
idea of using the original Euler angles instead of the derived rotation matrix
did not solve the problem as it yielded an even greater one; the famous gimbal
lock. Modern implementations tackle the issue, using quaternions; an algebra
of 4 dimensions, originally introduced by Hamilton in 1843. Quaternions,
often denoted by H, are an extension of the complex numbers, using two more
negative dimensions, i.e., they include, besides i, two more distinct imaginary
basis elements j, k such that j2 = k2 = −1. It was proved that a certain
subset of quaternions, called unit quaternions, could encapsulate the essence
of a rotation and also support interpolation.

The idea of using unit quaternions to store rotations provided a solution
to the matrix interpolation problem and remains until today the world stan-
dard in computer graphic’s modern engines. However, it also introduced the
need to constantly transmute rotations from quaternion to matrix form and

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

3

vice versa in every intermediate step, adding an extra performance burden.
Matrices are still needed in such implementations to store translation and
dilation data, while vertices are kept in homogeneous coordinates.

As in improvement to this situation, an algebraic extension of quaternions
called dual quaternions was used [17]. A speciﬁc subset of these 8-dimensional
objects, called the unit dual quaternions, was proved to be able to uphold both
rotation and translation data and still allow for eﬀortless and inexpensive linear
blending. Nevertheless, this advance did not solve the uniformity problem,
however it reduced artifacts appearing during animation [16], while further
post-processing can be used to further minimize them [18].

Our approach utilizes the CGA framework to perform both model
animation and more complex techniques such as cutting, tearing and drilling.
CGA is an algebra containing of dual-quaternions, where all entities such
as vertices, spheres, planes as well as rotations, translations and dilation
are uniformly expressed as multivectors [13, 9, 27]. The usage of multivectors
allows model animation without the need to constantly transmute between
matrices and (dual) quaternions, enabling dilation to be properly applied along
with translation [23, 22]. Furthermore, the interpolation of two multivectors
of the same type correctly produces the expected intermediate result [12],
which makes creation of keyframes trivial to implement. Finally, usage of the
proposed framework demands a single representation type for all data and
results, which is the current trend in computer graphics [21].

The use of Conformal Geometric Algebra and multivector representation
allows the creation of simpler algorithms to perform complicated tasks, as
fundamental geometric predicates are baked in the framework. For example,
the intersection of two planes can be determined by simply evaluating they
geometric product.

Therefore, complex operations such as cutting, tearing and drilling a
model are now easier to be accomplished, with near real-time results. Such
operations have become a major research topic as they appear in increasing
frequency in real-time simulation applications, for both academic as well as
industrial purposes. Current algorithms [7, 29] handle such deformations using
tetrahedral mesh representations of the model, which demands a heavy pre-
processing to be performed. Since originally introduced, cutting and tearing
methods have been upgraded and extended to allow almost real-time results,
using mostly ﬁnite element methods, intuitive optimization and heavy pre-
processing [4, 20, 6]. To make the ﬁnal results even more realistic, physics
engines utilizing position-based dynamics are used to simulate soft-tissue cuts
at the expense of performance [5, 2, 3].

Our contribution: The novelty of our work involves the complete im-
plementation of rigged model animation in terms of CGA, extending the work
of Papaefthymiou et al. [22] in a python-based implementation that enables
keyframe generation on-the-ﬂy. The original animation equation involving
matrices is translated to its equivalent multivector form (see Section 4.1) and
all information required to apply the linear blend skinning algorithm (vertices,

4

M. Kamarianakis and G. Papagiannakis

animation data) is obtained from the model and translated as multivector.
This enables us to have future animation models in CGA representation only,
which, in combination with an optimized GPU multivector implementation,
produces faster results under a single framework. Another major novelty
of our work is the cutting, tearing and drilling algorithms that are being
applied on top of the previous framework; given the input animated model,
we perform cuts, tears and drills on the model surface with the ability to
further re-deform the newly processed model. The subpredicates used in
these algorithms utilize the multivector form of their input, so they can be
implemented in a CGA-only framework. Their design was made in such a
way that little to no pre-processing of the input model is required while
allowing a future integration with a physics engine. Furthermore, using our
method, we can generate our own keyframes instead of just interpolating
between pre-deﬁned ones. Our all-in-one CPU python implementation is able
to process an existing animation model (provided in .dae or .fbx format)
and translate the existing animation in the desired CGA form while further
tweaks or linear-blend deformations are available in a simple way to perform.
Such an implementation is optimal as far as rapid prototyping, teaching and
future connection to deep learning is concerned. It also constitutes the base
for interactive cutting, tearing and drilling presented in Section 4.2. The
simplicity and robustness of our algorithms design promise real-time results if
run in a compiled programming language such as C++ or C#.

2. Introduction to Conformal Geometric Algebra

The Conformal Geometric Algebra (CGA) used in this paper can be seen as
another algebra containing dual-quaternions which allows round elements such
as spheres to be represented as objects of this algebra, i.e., as multivectors. To
be more precise, CGA is the lowest possible extension where this is possible.
Being able to represent round elements in conjunction with the ability to
reﬂect on objects using the so-called sandwich operation presented in the
following sections, CGA is also able to represent dilators (uniform scaling) as
multivectors. Therefore, CGA is a geometric algebra where round elements
(points, spheres, circles), ﬂat elements (lines, planes, point pairs) and all basic
deformations (translations, rotations, dilations) can be expressed explicitly in
multivector form.

In order to create the model of 3D CGA, we extend the basis {e1, e2, e3}
of the original Euclidean space R3 by two elements e+ and e−. These elements
have positive and negative signature respectively, i.e., it holds that e2
+ =
− = 1. The resulting non-Euclidean space is usually denoted as R4,1 while
−e2
the Cliﬀord (geometric) algebra of R4,1 is denoted as R4,1 or G(4, 1).

It is convenient to deﬁne a null basis given by the original basis vectors

e1, e2, e3 of R3 and

eo =

1
2

(e− − e+),

e∞ = e− + e+.

(1)

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

5

The elements eo and e∞ are called null vectors because e2
∞ = 0, where
the operation implied is the geometric product described in the following
sections.

o = e2

2.1. Vector Objects of R4,1
A generic vector Y of R4,1 is a linear combination of the basis elements
{e1, e2, e3, e∞, eo}, i.e.,

Y = y1e1 + y2e2 + y3e3 + y∞e∞ + yoeo,

yi ∈ R.

(2)

Note that CGA is a projection space where the elements Y and Z are
equivalent if and only if there is a λ ∈ R such that Y = λZ. Due to this
equivalence, we usually assume, without loss of generality, that the coordinate
of eo is either 0 or 1. In this algebra, points, spheres and planes are easily
represented as vector objects of the space, as described below.

Points. A point x = (x1, x2, x3) = x1e1 + x2e2 + x3e3 of R3 is up-projected

into the conformal vector

X = x +

1
2

x2e∞ + eo

1
2
Spheres. A sphere s of the R3, centered at x = (x1, x2, x3) with radius r

= x1e1 + x2e2 + x3e3 +

3)e∞ + eo.

1 + x2

2 + x2

(x2

(3)

is up-projected into the conformal vector

S = X −

1
2

r2e∞

= x1e1 + x2e2 + x3e3 +

1
2

(x2

1 + x2

2 + x2

3 − r2)e∞ + eo,

(4)

where X is the image of x in R4,1.

Planes. A plane π of the original space, with Euclidean distance d from the
origin, perpendicular to the normal vector (cid:126)n = (n1, n2, n3) is up-projected
into the conformal vector

Π = (cid:126)n + de∞ = n1e1 + n2e2 + n3e3 + de∞.

(5)

2.2. Products in R4,1
There are three major products in R4,1: the inner, the outer and the geometric.
Each of these products is initially deﬁned among the vectors e1, e2, e3, e−,
e+, eo, e∞. The respective deﬁnition is then extended to any element (a
multivector ) of the space. Below we present some of the basic properties of
these products; further information can be found in [9, 13].

Inner. The inner product (denoted by ·) of the basis elements is deﬁned

as follows:

• ei · ej := δij for i, j ∈ {1, 2, 3, +},
• e− · e− := −1,
• e− · ej := 0 for j ∈ {1, 2, 3, +},
• eo · eo := e∞ · e∞ = 0,
• eo · e∞ := −1,

6

M. Kamarianakis and G. Papagiannakis

• ei · ej := 0 for i ∈ {1, 2, 3, +} and j ∈ {o, ∞}.

Outer. The outer product of the basis elements ei and ej is denoted as
ei ∧ ej. The outer product is an associative operation that can be applied
to more than two elements, e.g., ei ∧ ej ∧ ek and ei ∧ ej ∧ ek ∧ e∞ are
properly deﬁned. The outer product of k basis vectors is called a k-blade
and k is usually referred to as the grade of this blade. A sum of k-blades
is called a k-vector and the addition of k-vectors of diﬀerent grades is a
multivector.

The importance of the outer product derives from the fact that it
allows us, in certain cases, to obtain the intersection of two objects by
simply evaluating their outer product. Speciﬁcally, a circle (resp. line)
can be seen as the intersection - outer product of two spheres (resp.
planes). The outer product of a circle with an intersecting sphere or
equivalently, the outer product of three intersecting spheres represent a
set of two points, usually referred to as a point pair.

Geometric. The most important product in R4,1 is the so-called geometric
product. For the basis vectors ei and ej, their geometric product eiej is
deﬁned as the addition of the outer and inner product of the elements,
i.e.,

eiej := ei ∧ ej + ei · ej.

Note that, by the deﬁnition, eiej = ei ∧ ej for every i, j ∈ {1, 2, 3, ∞, o}
such that i (cid:54)= j and {i, j} (cid:54)= {∞, o}.

2.3. Dual Objects
First, let us denote the pseudoscalar I of R4,1,

I := e1 ∧ e2 ∧ e3 ∧ e+ ∧ e− = e1 ∧ e2 ∧ e3 ∧ e∞ ∧ eo.

Using I, we may deﬁne the dual object m(cid:63) of a multivector m is to be

m(cid:63) := −mI,

(6)

(7)

where the operation between m and I is the geometric product. Notice that it
holds that (m(cid:63))(cid:63) = −m and therefore we can easily obtain the normal form m
of an object from it’s dual form m(cid:63) and vice versa.

The dual form of certain objects holds strong geometric meaning, as

described below.

• The outer product of 4 non-coplanar points yields the dual form of the

sphere deﬁned by these points.

• The outer product of 3 non-collinear points and e∞ yields the dual form

of the plane deﬁned by these points.

• The outer product of 3 non-coplanar points yields the dual form of the

circle deﬁned by these points.

• The outer product of 2 points and e∞ yields the dual form of the line

deﬁned by these points.

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

7

2.4. Rotations, Translations and Dilations

So far we have shown that objects (or their duals) such as points, planes, circles,
spheres, lines and point pairs are represented as multivectors. However, the
beauty and versatility of this algebra comes from its ability to also represent
rotations, translations and dilations as multivectors as described below.
Rotation. A rotation in CGA is encapsulated in a multivector
(cid:19)

(cid:19)

(cid:19)

(cid:18)

(cid:19)

(cid:18)

R := exp

−b

= exp

−I3u

= cos

− uI3 sin

,

(8)

φ
2

(cid:18) φ
2

(cid:18) φ
2

φ
2

where φ is the angle of the rotation, b is the normalized plane of the rotation, u
is the normalized axis of the rotation and I3 := e1e2e3. All products are
geometric products and exp(·) denotes the exponential function. The inverse
multivector of R is

R−1 := exp

(cid:19)

(cid:18)

b

φ
2

(cid:18)

= exp

I3u

(cid:19)

φ
2

= cos

(cid:19)

(cid:18) φ
2

+ uI3 sin

(cid:19)

.

(cid:18) φ
2

Translation. The multivector

(cid:18)

T := exp

−

(cid:19)

te∞

= 1 −

1
2

1
2

te∞,

(9)

(10)

where t = t1e1 + t2e2 + t3e3 is a euclidean vector, represents a translation
by t in CGA. The inverse multivector of T is

T −1 := exp

(cid:19)

te∞

= 1 +

(cid:18) 1
2

1
2

te∞.

Dilation. The multivector

D = 1 +

1 − d
1 + d

e∞ ∧ eo

(11)

(12)

corresponds to a dilation of scale factor d > 0 with respect to the origin. The
inverse of D is given by the expression

D−1 =

(1 + d)2
4d

+

d2 − 1
4d

e∞ ∧ eo.

(13)

An interesting remark is that, for d = 0, it holds that D = 1 + e∞ ∧ eo =
1 + e+e−, which is clearly not invertible in R4,1 as (e+e−)2 = 1.

The conformal space model allows us to apply any or multiple of the op-
erations above not only to a point but also to any object O that was previously
deﬁned. Let Mi, for i = 1, . . . , n, be either a rotation, a translation or a dila-
tion as deﬁned above. To apply the transformations M1, M2, . . . Mn (in this
order), to an object O, we ﬁrst deﬁne the multivector M := MnMn−1 · · · M1,
where all in-between products are geometric. The object

O(cid:48) := M OM −1

(14)

represents the ﬁnal form of O after all transformations are applied.

8

M. Kamarianakis and G. Papagiannakis

2.5. Interpolation of Multivectors
Interpolation of data is an essential part for Computer Graphics as it is
needed in every animation procedure of a rigged model. The poses of the
model with respect to time are not stored in a continuous manner but rather
at discrete time-steps. If additional intermediate frames are demanded, we
have to interpolate the animation data between two provided keyframes.

As in the case of matrix ([1]) or (dual) quaternion quaternion interpola-
tion [16], a blending of two multivectors can be accomplished in various ways,
yielding diﬀerent results [12, 26]. Choosing a proper interpolation technique is
not a simple task as it may depend on the model or other factors. However,
two methods remain dominant in analogue with the quaternion case: the
linear and the logarithmic blending.

Linear blending of the multivectors m1 and m2, which, in a model
animation context, may represent translations, rotations or dilations, is done by
evaluating (1 − α)m1 + αm2, for α ∈ [0, 1]. Another blending method is the so-
called logarithmic interpolation where we evaluate m1 exp(α log(m−1
1 m2)), for
α ∈ [0, 1], where the exponential and logarithmic function of a multivector m
are approximated in our case using the respective Taylor series expansion.
Notice that m1 is either a rotator, a translator, a dilator with d > 0 or a
geometric product of such multivectors and therefore is invertible. Although
not evident, one can prove that that the logarithmic interpolation method
is symmetric if we interchange m1 and m2 as well as α and 1 − α, by using
basic exponential and logarithmic properties. Using diﬀerent blendings, we
obtain diﬀerent results, as shown in Figure 1. More information regarding
the evaluation and properties of multivector logarithms/exponentials can be
found in [10, 23, 8, 25].

In our framework, linear blending is preferred when generating frames
on-the-ﬂy by the user, whereas logarithmic blending is used when reading the
models existing animation data.

3. State of the Art

The current state of the art regarding skeletal model animation and defor-
mation is based on the linear-blend skinning algorithm [19] and the repre-
sentation of bones animation via transformation matrices and quaternions
or dual-quaternions. Such an implementation allows for eﬃcient and robust
interpolation methods between keyframes. A shortcoming of such an implemen-
tation is the inability to represent a dilation as a quaternion or dual-quaternion
, which forces the use of multiple representations and frameworks [22].

To be more precise regarding the mechanics of the deformation process,
in the case of a simple rigged model, every bone bi amounts to an oﬀset matrix
Oi and an original transformation matrix ti. The skin of the model is imported
as a list of vertices v and a list of faces f . A bone hierarchy is also provided
where {ti} are stored along with information regarding the animation of each
joint. This information, usually referred to as TRS data, is provided in the

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

9

(a)

(b)

(c)

Figure 1. Linear Versus Logarithmic Interpolation. Three
vertex points deﬁning a triangular face are interpolated. This
face is interpolated between the bottom blue and top grey
keyframe. Both the vertices as well as translation (t), rotation
(r) and scaling(s) data that are interpolated in their multivec-
tor form. In (A), we have used a classic linear interpolation,
whereas in (B) we have used a logarithmic blending. In (C),
the outcomes of these two methods are superimposed.

form of a quaternion, a translation vector and a scaling vector that represent
respectively the rotation, displacement and scaling of the joint with respect
to the parent joint for each keyframe (see Section 3.1).

In order to determine the position of the skin vertices at any given
time k and therefore render the scene by triangulating them using the faces
list, we follow the steps described below. Initially, a matrix G is evaluated as
the inverse of the transformation matrix that corresponds to the root node.
Afterwards, we evaluate the global transformation matrix for every bone bi at
time k and denote it as Ti,k. To evaluate all Ti,k, we recursively evaluate the
matrix product Tj,kti,k where bj is the parent bone of bi, given that Tr,k is the
identity matrix (of size 4), where br denotes the root bone. The matrix ti,k is
a transformation matrix equal to ti if there is no animation in the model; in
this case, our implementation allows to generate the keyframes ourselves in
real-time. Otherwise, ti,k is evaluated as

ti,k = T Ri,kM Ri,kSi,k

(15)

where T Ri,k, M Ri,k, Si,k are the interpolated matrices that correspond to the
translation, rotation and scaling of the bone bi at a given time k.

10

M. Kamarianakis and G. Papagiannakis

After evaluating the matrices {Ti,k} for all bones {bi}, we can evaluate
the global position of all vertices at time k, using the rigged deformation
equation:

Vk[m] =

wm,nGTn,kOnv[m]

(16)

(cid:88)

where

n∈Im

• Vk[m] denotes the skin vertex of index m (in homogeneous coordinates)

at the animation time k,

• Im contains up to four indices of bones that aﬀect the vertex v[m],
• wm,n denotes the “weight”, i.e., the amount of inﬂuence of the bone bn

on the vertex v[m],

• On denotes the oﬀset matrix corresponding to bone bn, with respect to

the root bone,

• G denotes the inverse of the transformation matrix that corresponds to

the root bone (usually equals the identity matrix) and

• Tn,k denotes the deformation of the bone bn at animation time k, with

respect to the root bone.

3.1. State-of-the-art Representation
The modern way to represent the TRS data of a keyframe is to use matrices
for the translation and dilation data as well as quaternions for the rotation
data. Let {T Ri, Ri, Si}, denote such data at keyframe i ∈ {1, 2}, where:

• T Ri =





1 0
0


0 0

0 0

1 0
1
0

0 xi
yi
zi
1





and Si =







sxi
0
0
0

0
syi
0
0

0
0
szi
0


0
0


0

1

represent the

translation by (xi, yi, zi) and the scale by (sxi, syi, szi) respectively, and

• Ri is a quaternion representing the rotation.

Note that these matrices and quaternions are extracted from a provided
animated rigged model ﬁle (usually a *.dae or *.fbx ﬁle) or could be created
on-the-ﬂy by the user. Before quaternions, Euler angles and the derived
rotation matrices were used to represent rotation data. However the usage of
such matrices induced a great problem: a weighted average of such matrices
does not correspond to a rotation matrix and therefore interpolating between
two states would require interpolating the Euler angles and re-generate the
corresponding matrix. This in turn would sometimes lead to a gimbal lock or
to ‘candy-wrapper’ artifacts such as the ones presented in [16].

The usage of quaternions allowed for easier interpolation techniques while
eradicating such problems. Nevertheless, a transformation of the interpolated
quaternion to corresponding rotation matrix was introduced since the GPU
currently handles only matrix multiplications in a suﬃcient way for skinning
reasons. Therefore, the interpolation between the two keyframes mentioned
above follows the following pattern:

1. the matrices T Ra = (1 − a)T R1 + aT R2 and Sa = (1 − a)S1 + aS2 are

evaluated for a given a ∈ [0, 1],

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

11

2. the quaternion Ra = (1 − a)R1 + aR2 is determined and ﬁnally,
3. the rotation matrix M Ra that corresponds to Ra is calculated.

The interpolated data T Ra, M Ra and Sa are then imported to the GPU
in order to determine the intermediate frame, based on the equation(16). The
calculation of the intermediate keyframes amongst multiple ones, is either
performed via explicit selection of those contained in the oﬄine animation
ﬁle or they are generated procedurally via interpolation blending, via the
tweening method.

Using the method proposed in this paper, all data are represented in
multivector form. A major implication of this change is that the interpolation
between two states is done in a more clear and uniform way as presented in
Section 4. This also makes the need to constantly transform a quaternion
to a rotation matrix redundant, although we are now obliged to perform
multivector additions and multiplications as well as down project points
from R4,1 to R3 to parse them to the GPU. However, since all our data
and intermediate results are in the same multivector form, we could (ideally)
program the GPU to implement such operations and therefore greatly improve
performance.

4. Our Algorithms and Results

4.1. Multivector Form of the Rigged Deformation Equation
The deformation equation (16), core of the animation algorithm, yields fast
results (especially when combined with a GPU implementation) but denies
us a robust way to dilate with respect to a bone. Our motivation is to extend
and apply the animation equation for multivector input as proposed in [22].
To be more speciﬁc regarding our method, we propose the replacement
of all matrices appearing in (16) with multivectors for animation purposes.
The transformation matrix of ti of each bone bi as well as all information
regarding translation and rotation for each keyframe, initially extracted
from the provided model ﬁle, can be easily converted to multivectors [13, 9].
Consequently, we can evaluate the multivector Mi,k which is equivalent to
the matrix Ti,k by following the same procedure of determining the latter
(described in Section 3) while substituting all involved matrices with the
corresponding multivectors.

Note that various techniques can be used to interpolate between two
keyframes to obtain Mi,k; for existing keyframes logarithmic blending is
preferred [12, 16], whereas for keyframe generation we use linear blending. In
both scenarios, the intermediate results are multivectors of the correct type.
Furthermore, each oﬀset matrix On and each skin vertex v[m] is trans-
lated to their CGA form Bn and c[m] respectively. Finally, G matrix is
normalized to identity and is omitted in the ﬁnal equation.

Our ﬁnal task is to translate in CGA terms the matrix product

Tn,kOnv[m],

12

M. Kamarianakis and G. Papagiannakis

(a)

(b)

(c)

Figure 2. Skinning via the multivectors versus skinning
via the dual quaternions. The original model is deformed
using multivectors and depicted in magenta wireframe, su-
perimposed with the color-graded result (based on the z
coordinate of each vertex) of the quaternion method for the
same deformation. It is qualitatively veriﬁed that linear blend-
ing of multivectors produces similar results with the current
state-of-the-art method. Evaluating the vector diﬀerences
of all vertices for the two methods, we have evaluated the
approximation error assuming the quaternion method to be
the correct, using the inﬁnity ((cid:96)∞) norm. (A) We applied a
slight rotation on the neck joint, resulting in approximation
error 0.3%. (B) We applied a slight dilation on the neck joint,
approximation error is 0.00035%. (C) We applied a slight
translation on the neck joint, approximation error 1%. The
model used contains 1261 vertices and 1118 faces.

where apparently each multiplication sequentially applies a deformation to
vertex v[m]. To apply the respective deformations, encapsulated by Mn,k and
Bn, to CGA vertex c[m], we have to evaluate the sandwich geometric product
(Mn,kBn)c[m](Mn,kBn)(cid:63) where V (cid:63) denotes the inverse multivector of V (see
[17, 13] for details).

Summarizing, if the multivector form of the vertex Vk[m], which corre-
sponds to the ﬁnal position of the m-th vertex at animation time k, is denoted
by Ck[m], then the multivector deformation equation becomes

Ck[m] =

(cid:88)

n∈Im

wm,n(Mn,kBn)c[m](Mn,kBn)(cid:63)

(17)

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

13

After the evaluation of Ck[m] for all m, we can down-project all these conformal
points to the respective euclidean ones in order to represent/visualize them
and obtain the ﬁnal result of the keyframe at time k.

The replacement of matrices with multivectors enables the introduction
of dilations in a simple way. The multivector Mi,k that represents a rotation
and translation with respect to the parent bone of bi can be replaced with
Mi,kDi,k where Di,k is the corresponding dilator and the operation between
them is the geometric product. The dilator corresponds to a scale factor with
respect to the parent bone, information that could not be easily interpreted
via matrices. However, since the application of a motor and/or a dilator to a
vertex is a sandwich operation, such a dilation becomes possible when using
multivectors.

A comparison between the results of our proposed method and the
current state-of-the-art is shown in Figure 2, where we successfully apply
dilation to diﬀerent bones and obtain similar results. Rotations, dilations
and translations are obtained in our method using multivectors only, under a
single framework with simpler notation/implementation; linear blending is
used to interpolate between keyframes.

4.2. Cutting, Tearing and Drilling Algorithms
A novelty we present in this paper is the cutting, tearing and drilling algorithms
on skinned triangulated models. As the name suggests, the ﬁrst module enables
the user to make a planar cut of the model whereas the second is used to
perform smaller intersections on the skin. The last module can be utilized to
drill holes in the skinned model. In the following sections, we provide a detailed
presentation of the algorithms involved as well as certain implementation
details.

4.2.1. Cutting Algorithm. Cutting a skinned model is implemented in
current bibliography in many forms [7, 31, 24, 14, 30]. The most common
technique is via the usage of tetrahedral meshes [4] which require a heavy
pre-processing on the model and currently do not enable further animation of
the model or scale to VR environments. Our work includes an algorithm for
planar model cut, where the ﬁnal mesh is deformable, as we implemented a
function to calculate weights for all additional vertices that did not originally
exist (see Figure 3). Most of the subpredicates used in the cutting algorithm
are implemented in terms of conformal geometry and therefore can be used
even if the model is provided in multivector form.

Our proposed planar cut implementation is summarized as Algorithm 1.
A description of how we tackle the weight evaluation in step 2 is found in
Section 4.3. Our algorithm does not require tetrahedral meshed models and
requires minimum to none pre-processing. It is GA-ready and the low number
of operations it demands make it suitable for VR implementations.

4.2.2. Tearing Algorithm. The purpose of this module is to enable partial
cuts on the skinned model, in contrast with the cutting module where the
cut is, in a sense, complete. The importance of this module derives from the

14

M. Kamarianakis and G. Papagiannakis

(a)

(b)

(c)

(d)

Figure 3. Cutting module intermediate steps. (A) The orig-
inal animated model. (B) The model where the (red) intersec-
tion points of the cutting plane and the mesh are calculated
and re-triangulated. (C) The model after the cut. (D) The
model is deformed by a rotation (axis=(0, 1, 1), 0.7 rad), a
translation (vector=(13, 0, 0)) and a dilation (factor = 0.5)
at joint 1 (elbow), as well as another rotation (axis=(0, 1, 1),
0.3 rad) at joint 2 (wrist). Note that minimal artifacts occur
in the ﬁnal result. The vertices in (D) are colored depending
on the inﬂuence of joint 1 which is mostly deformed. The
vertices in (A)-(C) are colored based on their z coordinate.

fact that most of the surgical incisions are partial cuts and therefore they are

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

15

worth replicating in the context of a virtual surgery. Towards that direction,
our work involves an algorithm that both tears a skinned model and also
enables animation of the ﬁnal mesh (see Figures 4 and 5).

To understand the philosophy behind the design of the tearing algorithm
that is described below, one must comprehend the diﬀerences between cutting
and tearing. In tearing, the movement of a scalpel deﬁnes the tear rather
than a single plane. To capture such a tear in geometric terms, we have to
take into consideration the location of the scalpel in either a continuous way
(e.g., record the trail of both endpoints of the scalpel in terms of time) or
a discrete way (e.g., know the position of the scalpel at certain times ti).
For VR purposes, the latter way is preferred as it yields results with better
fps, since input is hard to be monitored and logged continuously in a naive
way. For these reasons, our implementation requires the scalpel position to be
known for certain ti.

The proposed tearing algorithm is summarized in Algorithm 2. A descrip-
tion of how we tackle the weight evaluation in step 4 is found in Section 4.3.
Our major assumption is that all intermediate intersection points lie on
this plane, which is equivalent to the assume that the tearing curve is smooth,
given that ti and ti+1 are close enough. In our implementation, during step 6,
the intermediate torn points are moved parallel to the direction of the normal
of the plane Π and away from it, to replicate the opening of a cut human
tissue.

4.2.3. Drilling Algorithm. The usage of Virtual Reality by surgeons and
their need to drill holes in a simulated 3D model motivated the creation of
the drilling module. Given a triangulated mesh and ﬁnite cylindrical drill, we
would like to evaluate the mesh that corresponds to the drilled model.

Designing the drilling predicate was more intriguing, compared to the
respective cutting and tearing algorithms, as multiple ideas turned out to
be inadequate. The initial idea of substituting the cylinder with a prism of
n-surfaces, for some suitable n, looked promising enough, as it would enable
using drill as a special case of tear. However, one would have to provide an
easy way to determine an n that would be suﬃciently large to produce a
smooth hole-like eﬀect in the outcome mesh. On the other hand, choosing an

Algorithm 1 Cutting Algorithm

Input: Triangulated Mesh M = (v, f ) (f is the face list), and a plane Π.
Output: Two meshes M1 = (v1, f1) and M2 = (v2, f2), result of M getting

cut by Π

1: Evaluate (using GA) and order the intersection points of Π with each face

of M .

2: Evaluate the weights and bone indices that inﬂuence these points.
3: Re-triangulate the faces that are cut using the intersection points.
4: Separate faces in f1 and f2, depending on which side of the plane they lie.
5: From f1 and f2, construct M1 and M2.

16

M. Kamarianakis and G. Papagiannakis

Algorithm 2 Tearing Algorithm

Input: Triangulated Mesh M = (v, f ), and scalpel position at time steps ti

and ti+1

Require: Scalpel properly intersects M at these time steps
Output: The mesh Mt = (vt, ft) resulting from M getting torn by the scalpel
1: Determine the intersection points Si and Si+1 of M with the scalpel at

time step ti and ti+1 respectively.

2: Determine the plane Π, containing Si and the endpoints of scalpel at time

ti+1. Small time steps guarantee that Π is well-deﬁned.

3: Evaluate the intersection points Qj of Π and M , s.t. the points
Si,Q0,Q1,. . .,Qm,Si+1 appear in this order on Π when traversing the
skin from Si to Si+1.

4: Assign weights to points Si, Si+1 and all Qj.
5: Re-triangulate the torn mesh, duplicating Qj vertices.
6: Move the two copies of Qj away from each other to create a visible tear

(optional).

arbitrary large n would result in many surfaces and therefore many costly
tear operations had to be performed, hindering our chances of a real-time
implementation. The prismatic approach also yielded the question of how to
choose the position the edges of the prism such that the intersection points of
the prism and the mesh would be re-triangulated in a clever and robust way.
Of course, if the edges of the prism were selected such that they intersected
the mesh’s faces only on their boundaries, the re-triangulation would be more
eﬃcient and not produce a lot of slither faces. However, if we had to decide the
optimal prism, that would be equivalent to specify the intersection points of
all mesh edges with our initial cylinder, which is the idea behind our proposed
algorithm.

In the core of our drill module lies a point-versus-cylinder predicate
that allows us to determine the intersection point of every edge of the given
mesh with the cylindrical drill. Since the drill is described by its radius
r and two endpoints A (the “tip” of the drill) and B that deﬁne its axis,
we can easily determine the plane Π that is perpendicular to its axis and
goes through B. Given an edge e deﬁned by the vertices vi and vj of the
mesh, we ﬁrst determine if any of these two vertices lie inside the semi-ﬁnite
cylinder (we ignore the existence of A for now and consider that the cylinder
is only bounded by Π and goes indeﬁnitely towards the direction of A). To
accomplish such task for the vertex v ∈ {vi, vj}, we project it to the plane
Π and compare the distance of the projected point P (v) and B with r; if it
is smaller (respectively larger) then v lies strictly inside (resp. outside) the
cylinder. In the case of equality, the vertex v lies on the cylinder.

If the vertices vi and vj lie on diﬀerent sides with respect to the cylinder,
then we ﬁrst evaluate the intersection point of the edge deﬁned by µ := P (vi)
and ν := P (vj) with the sphere centered at B with radius r. The coordinates

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

17

(a)

(b)

(c)

Figure 4. Tearing module intermediate steps. (A) The orig-
inal animated model and the scalpel’s position at two con-
secutive time steps. (B) The plane deﬁned by the scalpels
(depicted as a red triangle) intersects the skin in the yel-
low points. (C) The intermediate points are used in the
re-triangulation, and are «pushed» away from the cutting
plane to form an open tear.

of µ and ν can be explicitly determined as they are the projections of the
points vi and vj respectively on the plane going through B with normal
(cid:126)n = (cid:126)AB/|| (cid:126)AB||. Therefore, the projected image of (cid:126)v ∈ {vi, vj} on the plane
is (cid:126)v − (cid:104)(cid:126)n, (cid:126)v − (cid:126)OB(cid:105)(cid:126)n, where (cid:104)·, ·(cid:105) denotes the classic inner product.

Since every point on the projected edge is of the form αµ + (1 − α)ν for
some α ∈ [0, 1], and the edge is intersected by the sphere - as it is intersected
by the cylinder- there exists an α that corresponds to the intersection point.
For this α, the point ξ := αµ + (1 − αν must have exact distance from B
equal to r. If d(·, ·) denotes the Euclidean distance, solving the equation
d2(ξ, B) = r2 in terms of α yields that α is a root of the quadratic equation
Kα2 + Lα + N = 0, where

K = (xµ − xν)2 + (yµ − yν)2 + (zµ − zν)2 (cid:54)= 0,
L = 2(xµ − xν)(xν − xB) + 2(yµ − yν)(yν − yB)

+ 2(zµ − zν)(zν − zB),

N = (xν − xB)2 + (yν − yB)2 + (zν − zB)2 − r2,

(18)

(19)

(20)

18

M. Kamarianakis and G. Papagiannakis

(a)

(b)

(c)

(d)

Figure 5. Deformation of a torn model. (A) The original
model after applying the tear. (B) Two rotations are applied
to the torn model, one at elbow joint around y-axis by −1 rad,
and another at wrist joint around y-axis by 1 rad. (C) A
dilation of scale 1.5 is applied to the torn model, at elbow
joint. (D) A translation is applied to the torn model at
elbow joint with translation vector (18, 0, 0). In all cases,
minor artifacts only arise, despite the great magnitude of
the applied deformations. In (B),(C) and (D), vertices are
colored depending on the inﬂuence of elbow joint which is
mostly deformed. In (A), vertices are colored based on their
z coordinate.

and ξ = (xξ, yξ, zξ), for ξ ∈ {µ, ν, B}.

Therefore, we conclude that α is the only root of the quadratic that
belongs in [0, 1]. Since for this α, the point αP (vi) + (1 − α)P (vj) is the
intersection of the cylinder with the projected edge, the point αvi + (1 − α)vj
is a good approximation of the intersection point of cylinder with the original
edge.

Except of the basic edge-cylinder intersection where the endpoints vi and
vj of the edge lie on diﬀerent sides with respect to the cylinder, another two
cases have to be taken into consideration. It is possible that both endpoints
lie outside of the cylinder but the edge intersects the cylinder in two points
or is tangent to the cylinder in one point. These cases are equivalent to both
P (vi) and P (vj) lying outside the spheres centered at B with radius r and
the quadratic Kα2 + Lα + N = 0 has one or two root(s) α ∈ [0, 1]. As before,
the intersection point(s) is(are) approximated by αvi + (1 − αvj for these α.

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

19

(a)

(b)

(c)

Figure 6. Drilling module intermediate steps. (A) The drill
intersects the model skin in the yellow points. (B) The inter-
section points are used in the re-triangulation. (C) The elbow
joint of the drilled model is translated by (1, 1, 1), rotated by
0.3 rad around all 3 axis and then dilated by a factor of 2.
The weight function ensures that minimal to no artifacts
arise in the drilled area despite the deformation.

After evaluating the intersection points of the drill with the model and
since all of them lie on some edge of the original mesh, a robust and eﬃcient
triangulation can be easily applied. If the number of intersection points is
below some threshold, e.g., 6, we can perform a “split” operation on all aﬀected
faces and drill again. To split a triangular face one may connect the middle
points of all edges and therefore create four smaller sub-triangles similar to
the original. This operation will create a more “dense” triangulation in the
speciﬁc part of the model, resulting in more intersection points with the drill
and hopefully in a more realistic result. Although generating more intersection
points when needed is not a diﬃcult task, we have to take into consideration
that it has to be done in a clever way so as not to hinder the re-triangulation
process in terms of performance or implementation complexity.

The results of our drilling module when applied to our arm model are
demonstrated in Figure 6. As in the precious modules, we can assign weights
to the newly introduced intersection points, allowing re-deformation of the
drilled model. The outline of the proposed drilling algorithm is described in
Algorithm 3. A summary of how we address the weight evaluation in step 4 is
found in Section 4.3.

20

M. Kamarianakis and G. Papagiannakis

4.3. Implementation Details and Performance Remarks
The main framework used for skinning and animation with the use of multi-
vectors is Python’s PyAssimp1 and Cliﬀord2 package for the evaluation of the
vertices and the Meshplot package for rendering the model. The use of Python
language was preferred for a more user and presentation-friendly experience;
for a more robust and eﬃcient implementation C++ would be advised.

An instance of a class called v_w is used to store for each vertex a
list of up to 4 bones that inﬂuence it along with the corresponding inﬂuence
factors. The node tree is then traversed and all information regarding rotation,
translation and dilation are translated to multivectors [13, 9] and also stored
in the instance for convenience. In order to evaluate the ﬁnal position of
the vertices, all that is left is to to evaluate the sum in equation (17) for all
vertices and down project it to R3, for each vertex. There are two possible
ways of achieving this task. The ﬁrst way is to evaluate the sum and then
down project the ﬁnal result to obtain each vertex in Euclidean form. The
second way is to down project each term and then add them to get the ﬁnal
result. Although not obvious, the second method yields faster results since the
addition of 4 multivectors (32-dimensional arrays) and one down-projection is
slower than down-projecting (up to) 4 multivectors and adding 4 euclidean
vectors of dimension 3.

A ﬁnal implementation detail regards the weight evaluation for newly
added vertices in the cutting and tearing modules. In the former module, such
vertices necessarily lie on an edge of the original mesh, whose endpoints both
lie on diﬀerent sides of the cutting plane. Another method is the one used

1PyAssimp Homepage: https://pypi.org/project/pyassimp/
2Cliﬀord Homepage: https://clifford.readthedocs.io/

Algorithm 3 Drilling Algorithm

Input: Triangulated Mesh M = (v, f ) and drill position via its endpoints A

(“tip” of the drill),B and radius r.
Require: Drill properly intersects M
Output: The mesh M (cid:48) = (v(cid:48), f (cid:48)) resulting from M being drilled
1: Let Π denote the plane perpendicular to the drill axis going through the

endpoint B.

2: Determine the faces of M that are pierced by the drill and run a BFS
algorithm that checks, for this and all neighboring faces, if at least one of
its three vertices, when projected to Π, has distance from B less than r,
i.e., if it lies within the drill. Mark such a face as “aﬀected”.

3: For all aﬀected faces, determine in the plane Π the intersection points
of the drill and the projected face and then down-project them to the
original mesh.

4: Assign weights to the intersection points of the original mesh.
5: Re-triangulate the drilled mesh by replacing the aﬀected faces by appro-

priate ones.

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

21

in the tearing module where the intersection point can also lie inside a face.
Assuming the point X lie somewhere on the face ABC, we can explicitly write
OX = pOA + qOB + rOC for some a, b, c ∈ [0, 1] such that p + q + r = 1.
The tuple (p, q, r) is called the barycentric coordinate of X with respect to
the triangle ABC. Each of the vertices A, B, C are (usually) inﬂuenced by
up to 4 bones, so let us consider that they are all inﬂuenced by a set of
N (≤ 12) vertices, where the bones beside the original 4 have weight 0. Let
wA, wB, wC, wX denote the vectors containing the N weights that correspond
to vertices A, B, C and X respectively, for the same ordering of the N involved
bones. To determine wX , we ﬁrst evaluate w = pwA + qwB + rwC and consider
two cases. If w contains up to 4 non-zero weights, then wX = w. Otherwise,
since each vertex can be inﬂuenced by up to 4 bones, we keep the 4 greater
values of w, set the others to zero, and normalize the vector so that the sum of
the 4 values add to 1; the ﬁnal result is returned as wX . We denote this weight
as weight of X via barycentric coordinates. Variations of this technique can be
applied in both modules to prioritize or neglect inﬂuences on vertices lying on
a speciﬁc side of the cutting plane. Diﬀerent variations of the weight function
allows for less artifacts [28], depending on the model and the deformation
subsequent to the cutting/tearing.

Performance: Running the cutting algorithm in the arm model (5037
faces, 3069 vertices) took for a simple cylinder model a total of 898 ms: 42 ms
for vertex separation, 757 ms for re-triangulation of the 92 intersection points,
87 ms to split faces in two meshes and 12 ms to update the weights. To cut the
arm model, it took 4666 ms as shown in Table 4.3, where most time (2205 ms)
was spent on the evaluation and triangulation of the intersection points of the
cutting plane and the model. The oﬄine pre-processing time of the model,
i.e., the time required to translate the model skin or animation data from
Euclidean coordinates or matrices respectively to multivector form is not
taken into account in the above measurements.

Applying the tearing algorithm to the arm model took 2437 ms for the
ﬁnal output, for 34 intersection points. Most of this time (2411 ms) were
needed just to determine which two faces were intersected by the scalpel.
Tearing a simple cylinder model (758 faces, 634 vertices) took 362 ms for
17 intersection points. Again, most time (331 ms) was spend for the scalpel
intersection.

The drilling algorithm for the arm model takes on average 274 ms for
a hole consisting of 17 intersection points on our arm model. For a hole
of the same diameter consisting of 20 intersection points, the algorithm
requires 319 ms to return the ﬁnal outcome whereas, the running time grows
to 595 ms when the diameter is increased from 2 to 3 and the intersection
points become 33. As a rule of thumb, there is an average running time of
16 − 18 ms per intersection point.

These running times, produced in a MacbookPro with a 2,6 GHz 6-Core
Intel Core i7 processor, can be greatly improved as our current unoptimized
CPU-based Python implementation has to thoroughly search all faces for

22

M. Kamarianakis and G. Papagiannakis

Subroutine

Subroutine 1
Subroutine 2
Subroutine 3
Subroutine 4
Cutting time

Time Spent Using Time Spent Using
Euclidean Tools

GA Tools

0, 036439578 + sec
2, 050984303 sec

0, 072434584 sec
2, 205727577 sec

0, 061544961 sec
2, 326937914 sec

4, 475906756 sec

4, 666645036 sec

Table 1. Running times of the four main subroutines of
the cutting algorithm. In the 2nd column, point-versus-plane
relative positions for subroutine 1 and segment-plane intersec-
tions for subroutine 2 were determined using only Euclidean
subpredicates. In the 3rd column, the same operations were
carried using Geometric Algebra equivalent subpredicates.
The subroutines 3 and 4 are independent of the model data
representation. Subroutines: (1) Check vertices locations with
respect to the cutting plane, (2) Detect which faces are inter-
sected by the cutting plane, evaluate the intersection points
and triangulate them, (3) Evaluate weights for the intersec-
tion points, (4) Split original model into submodels.

cuts/tears. Multivector operations are performed by the Cliﬀord python pack-
age which, in some cases, allows some parallelization. However, since python
list comprehensions and functions of multiple types of inputs are involved in
our implementation, we could not fully parallelize our algorithm and python
performed most operations in a single thread. A GPU implementation opti-
mized for multivector operations would allow the comparison of our proposed
method with the current state-of-the-art methods, which however do not
allow further deformation of the model. The running times of our algorithms
indicate that there is only a small percentage of performance load added when
using Geometric Algebra representation forms instead of Euclidean ones to
perform cuts/tears and drill holes.

5. Conclusions and Future Work

This work describes a novel way to perform model animation and deformation
as well as cutting, tearing and drilling under a single geometric framework
in Conformal Geometric Algebra. We focus towards a pure geometric-based
implementation that can be applied to rigged models even in low-spec VR
headsets and ultimately enable real-time operations such as the ones presented
here. Our current results were obtained using python but, since our goal is
to have a full implementation in real-time virtual reality simulation, we will
inevitably have to use more suitable programming languages and platforms
such as C#/C++ and Unity/Unreal Engines. It is our intention to use recently

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

23

developed acceleration techniques [11] and parallel processing to further
optimize our algorithms and further decrease running times. We currently
redesign parts of the algorithm to allow parallelization in all functions where
this is applicable. Finally, we intend to combine our modules in conjunction
with a physics engine to obtain a realistic opening eﬀect, e.g., after the user
performs a tear, without the need to pre-record it and therefore lift the
limitation of only predeﬁned, physics-based,plausible cuts,tears or drills.

6. Acknowledgements

We would like to cordially thank the anonymous paper reviewers as well as
the handling editor for the constructive and helpful comments.

References

[1] Alexa, M.: Linear combination of transformations. ACM Trans. Graph. 21(3),

380–387 (2002)

[2] Bender, J., Müller, M., Otaduy, M.A., Teschner, M., Macklin, M.: A survey on
position-based simulation methods in computer graphics. Computer Graphics
Forum 33(6), 228–251 (2014)

[3] Berndt, I.U., Torchelsen, R.P., Maciel, A.: Eﬃcient Surgical Cutting with
Position-Based Dynamics. IEEE Computer Graphics and Applications 37(3),
24–31 (2017)

[4] Bielser, D., Glardon, P., Teschner, M., Gross, M.: A state machine for real-time
cutting of tetrahedral meshes. In: 11th Paciﬁc Conference onComputer Graphics
and Applications, 2003. Proceedings., pp. 377–386. IEEE (2003)

[5] Bielser, D., Maiwald, V.A., Gross, M.H.: Interactive Cuts through 3-Dimensional

Soft Tissue. Computer Graphics Forum 18(3), 31–38 (1999)

[6] Bruyns, C.D., Senger, S.: Interactive cutting of 3d surface meshes. Computers

& Graphics 25(4), 635–642 (2001)

[7] Bruyns, C.D., Senger, S., Menon, A., Montgomery, K., Wildermuth, S., Boyle,
R.: A survey of interactive mesh-cutting techniques and a new method for
implementing generalized interactive mesh cutting using virtual tools. The
journal of visualization and computer animation 13(1), 21–42 (2002)

[8] Colapinto, P.: Articulating space: Geometric algebra for parametric design–
symmetry, kinematics, and curvature. Ph.D. thesis, UC Santa Barbara (2015).
URL https://escholarship.org/content/qt5m76n8tg/qt5m76n8tg.pdf
[9] Dorst, L., Fontijne, D., Mann, S.: Geometric algebra for computer science -
an object-oriented approach to geometry. The Morgan Kaufmann series in
computer graphics (2007)

[10] Dorst, L., Valkenburg, R.: Square root and logarithm of rotors in 3d conformal
geometric algebra using polar decomposition. In: Guide to Geometric Algebra
in Practice, pp. 81–104. Springer (2011)

[11] Hadﬁeld, H., Hildenbrand, D., Arsenovic, A.: Gajit: Symbolic Optimisation and
JIT Compilation of Geometric Algebra in Python with GAALOP and Numba.
In: Advances in Computer Graphics, pp. 499–510. Springer (2019)

24

M. Kamarianakis and G. Papagiannakis

[12] Hadﬁeld, H., Lasenby, J.: Direct Linear Interpolation of Geometric Objects in
Conformal Geometric Algebra. Advances in Applied Cliﬀord Algebras 29(4),
01 (2019)

[13] Hildenbrand, D.: Foundations of geometric algebra computing, 2013. Springer
[14] Ji, Z., Liu, L., Chen, Z., Wang, G.: Easy mesh cutting. In: Computer Graphics

Forum, vol. 25, pp. 283–291. Wiley Online Library (2006)

[15] Kamarianakis, M., Papagiannakis, G.: Deform, cut and tear a skinned model
using conformal geometric algebra. In: Computer Graphics International Con-
ference, pp. 434–446. Springer (2020)

[16] Kavan, L., Collins, S., Žára, J., O’Sullivan, C.: Geometric skinning with ap-

proximate dual quaternion blending. ACM Trans. Graph. 27(4) (2008). DOI
10.1145/1409625.1409627. URL https://doi.org/10.1145/1409625.1409627
[17] Kenwright, B.: A beginners guide to dual-quaternions: What they are, how
they work, and how to use them for 3D character hierarchies. In: WSCG 2012
- Conference Proceedings, pp. 1–10. Newcastle University, United Kingdom
(2012)

[18] Kim, Y.B., Han, J.H.: Bulging-free dual quaternion skinning. In: Computer
Animation and Virtual Worlds, pp. 321–329. Korea University, Seoul, South
Korea, John Wiley & Sons, Ltd (2014)

[19] Magnenat-thalmann, N., Laperrire, R., Thalmann, D., Montréal, U.D.: Joint-
dependent local deformations for hand animation and object grasping. In: In
Proceedings on Graphics interface ’88, pp. 26–33 (1988)

[20] Mor, A.B., Kanade, T.: Modifying Soft Tissue Models: Progressive Cutting
with Minimal New Element Creation. In: Advances in Computer Graphics, pp.
598–607. Springer Berlin Heidelberg, Berlin, Heidelberg (2000)

[21] Müller, M., Chentanez, N., Macklin, M.: Simulating visual geometry. In: Pro-
ceedings - Motion in Games 2016: 9th International Conference on Motion in
Games, MIG 2016, pp. 31–38 (2016)

[22] Papaefthymiou, M., Hildenbrand, D., Papagiannakis, G.: An inclusive Conformal
Geometric Algebra GPU animation interpolation and deformation algorithm.
The Visual Computer 32(6-8), 751–759 (2016)

[23] Papagiannakis, G.: Geometric algebra rotors for skinned character animation

blending. In: SIGGRAPH Asia 2013 Technical Briefs, SA 2013 (2013)

[24] Wang, D., Zhang, Y., Wang, Y., Lee, Y.S., Lu, P., Wang, Y.: Cutting on
triangle mesh: local model-based haptic display for dental preparation surgery
simulation. IEEE Transactions on Visualization and Computer Graphics 11(6),
671–683 (2005)

[25] Wareham, R.: Computer graphics using conformal geometric algebra. Ph.D.

thesis, University of Cambridge (2007)

[26] Wareham, R., Cameron, J., Lasenby, J.: Applications of conformal geometric
algebra in computer vision and graphics. In: Computer algebra and geometric
algebra with applications, pp. 329–349. Springer (2004). DOI 10.1007/11499251_
24. URL https://doi.org/10.1007/11499251_24

[27] Wareham, R., Cameron, J., Lasenby, J.: Applications of conformal geometric
algebra in computer vision and graphics. In: Computer Algebra and Geometric
Algebra with Applications, pp. 329–349. Springer Berlin Heidelberg, Berlin,
Heidelberg (2005)

A Geometric Algorithm for Cutting, Tearing, and Drilling Models

25

[28] Wareham, R., Lasenby, J.: Bone glow: An improved method for the assignment
of weights for mesh deformation. In: International Conference on Articulated
Motion and Deformable Objects, pp. 63–71. Springer (2008)

[29] Wu, J., Westermann, R., Dick, C.: A Survey of Physically Based Simulation of
Cuts in Deformable Bodies. Computer Graphics Forum 34(6), 161–187 (2015)
[30] Ye, X., Ji’er, X., Zhu, L., Yan, R.: Research on soft tissue deformation and cut-
ting in the virtual surgery. In: The 2011 IEEE/ICME International Conference
on Complex Medical Engineering, pp. 340–345. IEEE (2011)

[31] Ye, X., Zhang, J., Gu, Y.: An improved collision detection and cutting algo-
rithm of the soft tissue in virtual surgical simulation. International Journal of
Mechatronics and Automation 4(4), 236–247 (2014)

Manos Kamarianakis
Department of Mathematics & Applied Mathematics,
University of Crete,
Voutes Campus, 70013 Heraklion, Greece
Orchid ID: 0000-0001-6577-0354
e-mail: m.kamarianakis@gmail.com

George Papagiannakis
Department of Computer Science,
University of Crete,
Voutes Campus, 70013 Heraklion, Greece
Orchid ID: 0000-0002-2977-9850
e-mail: george.papagiannakis@gmail.com

