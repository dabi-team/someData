6
0
0
2

p
e
S
9
1

]

O
L
.
s
c
[

1
v
9
0
1
9
0
6
0
/
s
c
:
v
i
X
r
a

The recognizability of sets of graphs

is a robust property1

Bruno Courcelle2,

Pascal Weil3

Abstract

Once the set of ﬁnite graphs is equipped with an algebra structure
(arising from the deﬁnition of operations that generalize the concatena-
tion of words), one can deﬁne the notion of a recognizable set of graphs in
terms of ﬁnite congruences. Applications to the construction of eﬃcient
algorithms and to the theory of context-free sets of graphs follow natu-
rally. The class of recognizable sets depends on the signature of graph
operations. We consider three signatures related respectively to Hyper-
edge Replacement (HR) context-free graph grammars, to Vertex Replace-
ment (VR) context-free graph grammars, and to modular decompositions
of graphs. We compare the corresponding classes of recognizable sets.
We show that they are robust in the sense that many variants of each
signature (where in particular operations are deﬁned by quantiﬁer-free
formulas, a quite ﬂexible framework) yield the same notions of recog-
nizability. We prove that for graphs without large complete bipartite
subgraphs, HR-recognizability and VR-recognizability coincide. The same
combinatorial condition equates HR-context-free and VR-context-free sets
of graphs. Inasmuch as possible, results are formulated in the more general
framework of relational structures.

1 Introduction

The notion of a recognizable language is a fundamental concept in Formal Lan-
guage Theory, which has been clearly identiﬁed since the 1950’s. It is important
because of its numerous applications, in particular for the construction of com-
pilers, and also for the development of the Theory: indeed, these languages can
be speciﬁed in several very diﬀerent ways, by means of automata, congruences,
regular expressions and logical formulas. This multiplicity of quite diﬀerent def-
initions is a clear indication that the notion is central since one arrives at it in a
natural way from diﬀerent approaches. The equivalence of deﬁnitions is proved
in fundamental results by Kleene, Myhill and Nerode, Elgot and B¨uchi.

1This paper was prepared in part while the second author was an invited Professor at the
University of Nebraska-Lincoln. The second author acknowledges partial support from the AS
93 of the D´epartement STIC of CNRS, and the ACI S´ecurit´e Informatique of the Minist`ere
de la Recherche.

2LaBRI, Universit´e Bordeaux-1 – 351 cours de la Lib´eration – 33405 Talence Cedex –

France. bruno.courcelle@labri.fr

3LaBRI, CNRS – 351 cours de la Lib´eration – 33405 Talence Cedex – France.

pascal.weil@labri.fr

1

 
 
 
 
 
 
The notion of a recognizable set has been extended in the 1960’s to trees
(actually to trees representing ﬁnite algebraic terms), to inﬁnite words and to
inﬁnite trees.
In the present article we discuss its extension to sets of ﬁnite
graphs.

The recognizability of a set of ﬁnite words or trees can be deﬁned in several
ways, as mentioned above, and in particular by ﬁnite deterministic automata.
This deﬁnition (together with the related eﬀective translations from other deﬁ-
nitions) provides linear-time recognition algorithms, which are essential for com-
piler construction, coding, text processing, and in other situations. Recognizable
sets of words can also be deﬁned in an algebraic way by ﬁnite saturating con-
gruences relative to the monoid structure. These deﬁnitions, by automata and
congruences, extend smoothly to the case of ﬁnite trees (i.e., algebraic terms),
using the natural algebra structure. The notion of recognizability in a general
algebra is due to Mezei and Wright [37]. We will not discuss here the extensions
to inﬁnite words and trees, which raise speciﬁc problems surveyed by Thomas
[43] and Perrin and Pin [40]. Our aim will be to consider sets of ﬁnite graphs.
For ﬁnite graphs, there is no automaton model, except in very special cases,
and in particular in the case of graphs representing certain labelled partially
ordered sets and traces (a trace is a directed acyclic graph, representing the
equivalence class of a word w.r.t. a partial commutation relation), see the
volume edited by Diekert [22] and the papers by Lodaya and Weil [32, 33]
and ´Esik and N´emeth [24]. Algebraic deﬁnitions via ﬁnite congruences can
be given because the set of ﬁnite graphs can be equipped with an algebraic
structure, based on graph operations like the concatenation of words. However,
many operations on graphs can be deﬁned, and there is no prominent choice
for a standard algebraic structure like in the case of words where a unique
associative binary operation is suﬃcient. Several algebraic structures on graphs
can be deﬁned, and distinct notions of recognizability follow from these possible
choices. It appears nevertheless that two graph algebras, called the HR-algebra
and the VR-algebra for reasons explained below, emerge and provide robust
notions of recognizability. The main purpose of this paper is to demonstrate
the robustness of these notions. By robustness, we mean that taking variants of
the basic deﬁnitions does not modify the corresponding classes of recognizable
sets of graphs.

In any algebra, one can deﬁne two family of sets, the recognizable sets and
the equational sets. The equational sets are deﬁned as the components of the
least solutions of certain systems of recursive set equations, written with set
union and the operations of the algebra, extended to sets in the standard way.
Equational sets can be considered as the natural extension of context-free lan-
guages in a general algebraic framework (Mezei and Wright [37], Courcelle [12]
for a thorough development). The two graph algebras introduced above, the
HR- and the VR-algebra, are familiar to readers interested in graph grammars,
because their equational sets are the (context-free) Hyperedge Replacement (HR)
sets of graphs on the one hand, and the (context-free) Vertex Replacement (VR)
sets on the other. Both classes of context-free sets of graphs can be deﬁned in
alternative, more complicated ways in terms of graph rewritings, and are robust

2

in the sense that they are closed under certain transformations expressible in
Monadic Second-Order Logic (Courcelle [15]).

The main results of this paper, described below in more detail, are:
1) the robustness of the classes of VR- and HR-recognizable sets of graphs,
2) the robustness of the class of recognizable sets of ﬁnite relational structures
(equivalently of simple directed ranked hypergraphs), which extends the two
previous classes,

3) the exhibition of structural conditions on sets of graphs implying that

HR-recognizability and VR-recognizability coincide,

4) the comparison of the recognizable sets of the VR-algebra and those of
a closely related algebra representing modular decompositions (modular decom-
position is another useful notion for graph algorithms).

The notion of recognizability of a set of ﬁnite graphs is important for sev-
eral reasons. First, because recognizability yields linear-time algorithms for the
veriﬁcation of a wide class of graph properties on graphs belonging to certain
ﬁnitely generated graph algebras. These classes consist of graphs of bounded
tree-width and of bounded clique-width. These two notions of graph complex-
ity are important for constructions of polynomial graph algorithms, see Downey
and Fellows [23] and Courcelle et al.
[20]. Furthermore, these graph proper-
ties are not very diﬃcult to identify because Monadic second-order (MS) logic
(In many cases, an MS
can specify them in a formalized and uniform way.
formula can be obtained from the graph theoretical expression of a property).
More precisely, a central result [8, 9, 15, 20] says that every set of graphs (or
graph property) deﬁnable by an MS formula is recognizable (respectively admits
such algorithms), for appropriate graph algebras. This general statement covers
actually several distinct situations.

Another reason comes from the theory of Graph Grammars. The intersec-
tion of a context-free set of graphs and of a recognizable set is context-free (in
the appropriate algebraic framework). This gives immediately many closure
properties for context-free sets of graphs, via the use of MS logic as a speciﬁ-
cation language for graph properties. Recognizability also makes it possible to
construct terminating and (in a certain sense) conﬂuent graph rewriting rules by
which one can recognize sets of graphs of bounded tree-width by graph reduction
in linear time, see Arnborg et al. [2].

Finally, recognizability is a basic notion for dealing with languages and sets
of terms, and on this ground, its extension to sets of graphs is worth investi-
gating. Logical characterizations of recognizability can be given using MS logic,
extending many results in language theory [16, 28, 24, 29, 30]. Several questions
remain open in this research ﬁeld.

We have noted above that deﬁning recognizability for sets of graphs cannot
be done in terms of ﬁnite automata, so that the algebraic deﬁnition in terms
of ﬁnite congruences has no alternative. Another advantage of the algebraic
deﬁnition is that it is given at the level of universal algebra (Mezei and Wright
[37]), and thus applies to objects other than graphs. However, even in the
case of graphs, the algebraic setting is useful because it hides (temporarily) the

3

complexities of operations on graphs and makes it possible to understand what
is going on at a structural level.

We now present the main results of this article more in detail. The two
main algebraic structures on graphs called VR and HR, originate from algebraic
descriptions of context-free graph grammars. Deﬁnitions will be given in the
body of the text. It is enough for this introduction to retain that the operations
of VR are more powerful than those of HR. Hence every HR-context-free set of
graphs (i.e., deﬁned by a grammar based on the operations of HR) is VR-context-
free, but not vice-versa. For recognizability, the inclusion goes in the opposite
direction : every VR-recognizable set is HR-recognizable but the converse is not
true. However, if the graphs of a set L have no subgraph of the form Kn,n
(the complete bipartite graph on n + n vertices) for some n, then L is HR-
recognizable if and only if it is VR-recognizable (this is the main theorem of
Section 6). A similar statement is known to hold under the same hypothesis for
context-free sets: if L is without Kn,n (i.e., no graph in L contains a subgraph
isomorphic to Kn,n), then it is HR-context-free if and only if it is VR-context-
free (Courcelle, [14]). The proofs of the two statements are however diﬀerent
(and both diﬃcult).

Up to now we have only discussed graphs, but our approach, which extends
the approach developped by Courcelle in [9], also works for hypergraphs and for
relational structures.

The operations on graphs, hypergraphs and structures are basically of three
types deﬁned in Section 3: we use only one binary operation, the disjoint union;
we use unary operations deﬁned by quantiﬁer-free ﬁrst-order formulas; and basic
graphs and structures corresponding to nullary operations. In this way we can
generate graphs and structures by ﬁnite algebraic terms. The quantiﬁer-free
deﬁnable operations can modify vertex and edge labels, add or delete edges.
This notion is thus quite ﬂexible. What is remarkable is that these numerous
operations can be added without altering the notion of recognizability.

The main result of Section 4 states that the same recognizable sets of graphs
are obtained if one uses the basic VR-algebra (closely connected to the deﬁnition
of clique-width), the same algebra enriched with quantiﬁer-free deﬁnable oper-
ations, and even the larger algebra dealing with relational structures. Variants
of the VR-algebra which are useful, in particular for algorithmic applications,
are also considered, and they are proved to yield the same class of recognizable
sets.

In Section 5, we discuss similarly the HR-algebra which is very important
because of its relation with tree-width and with context-free graph grammars.
We prove a robustness result relative to the subclass such that the distinguished
vertices denoted by distinct labels (nullary operations) are diﬀerent. The HR-
operations are appropriate to handle graphs and hypergraphs with multiple
edges and hyperedges (whereas the VR-operations are not). The original deﬁ-
nitions (see Courcelle [8]) were given for graphs with multiple edges and hyper-
edges. In Section 7, we prove that for a set of simple graphs, HR-recognizability
is the same in the HR-algebra of simple graphs and in the larger HR-algebra of
graphs with multiple edges. Without being extremely diﬃcult, the proof is not

4

just a routine veriﬁcation.

In Section 8, we consider an algebra arising from the theory of modular
decomposition of graphs. We show that under a natural ﬁniteness condition,
the corresponding class of recognizable sets is equal to that of VR-recognizable
ones.

In an appendix, we clarify the deﬁnitions of certain equivalences of logical
formulas, focusing on cases where they are decidable, and we give upper bounds
to the cardinalities of the quotient sets for these equivalences. These results
yield upper bounds to the number of equivalence classes in logically based con-
gruences. They are thus useful for the investigation of recognizability in view
of the cases where the sets under consideration are deﬁned by logical formulas.
They also provide elements to appreciate (an upper bound of) the complexity
of the algorithms underlying a number of the eﬀective proofs in the main body
of the paper.

This work has been presented in invited lectures by B. Courcelle [17] and P.

Weil [47].

2 Recognizability

The notion of a recognizable set is due to Mezei and Wright [37]. It was origi-
nally deﬁned for one-sort structures, and we adapt it to many-sorted ones with
inﬁnitely many sorts. We begin with deﬁnitions concerning many-sorted alge-
bras.

2.1 Algebras

We follow essentially the notation and deﬁnitions from [45], see also [12]. Let
S be a set called the set of sorts. An S-signature is a set F given with two
mappings α: F −→ seq(S) (the set of ﬁnite sequences of elements of S), called
the arity mapping, and σ: F −→ S, called the sort mapping. We denote by
ρ(f ) the length of the sequence α(f ), which we call also arity. The type of
f in F is the pair (α(f ), σ(f )) that we shall rather write α(f ) → σ(f ), or
(s1, s2, . . . , sn) −→ s if α(f ) = (s1, · · · , sn) and σ(f ) = s. The sequence α(f ) may
be empty (that is, n = 0), in which case f is called a constant of type σ(f ) = s.
An F -algebra is an object M = h(Ms)s∈S, (fM )f ∈F i, where for each s ∈ S, Ms
is a non-empty set, called the domain of sort s of M . For a nonempty sequence
of sorts µ = (s1, · · · , sn), we denote by Mµ the product Ms1 × Ms2 × · · · × Msn. If
ρ(f ) > 0, then fM is a total mapping from Mα(f ) to Mσ(f ). If f is a constant of
type s, then fM is an element of Ms. The objects fM are called the operations
of M . We assume that Ms ∩ Ms′ = ∅ for s 6= s′. We also let M denote the union
of the Ms (s ∈ S). For d ∈ M , we let σ(d) denote the unique s ∈ S such that
d ∈ Ms.

A mapping h: M → M ′ between F -algebras is a homomorphism (or F -
s for

homomorphism if it is useful to specify the signature) if it maps Ms into M ′
each sort s and it commutes with the operations of F .

5

We denote by T (F ) the set of ﬁnite well-formed terms built with F (we will
call them F -terms), and by T (F )s the set of those terms of sort s (the sort of a
term is that of its leading symbol). If F has no constant the set T (F ) is empty.
There is a standard structure of F -algebra on T (F ). Its domain of sort s is
T (F )s, and T (F ) can be characterized as the initial F -algebra. This means that
for every F -algebra M , there is a unique homomorphism valM : T (F ) −→ M .
If t ∈ T (F )s, the image of t under valM is an element of Ms, also denoted by
tM . It is nothing but the evaluation of t in M , where the function symbols are
interpreted by the corresponding functions of M . One can consider t as a term
denoting tM , and tM as the value of t in M . The set of values in M of the
terms in T (F ) is called the subset generated by F . We say that a subset of M
is ﬁnitely generated if it is the set of values of terms in T (F ′) for some ﬁnite
subset F ′ of F .

Let F be an S-signature, F ′ be an S′-signature where S′ ⊆ S. We say that
F ′ is a subsignature of F , written F ′ ⊆ F , if F ′ is a subset of F and the types
of every f in F ′ are the same with respect to F and to F ′. We say then that an
s ⊆ Ms for every s ∈ S′,
F ′-algebra M ′ is a subalgebra of an F -algebra M if M ′
and every operation of M ′ coincides with the restriction to the domains of M ′
of the corresponding operation of M .

We will often encounter the case where an F -algebra M is also the carrier
of a G-algebra, and the G-operations of M can be expressed as F -terms: in that
case, we say that the G-operations of M are F -derived, and the G-algebra M is
an F -derived algebra (or it is derived from M ).

More formally, an S-sorted set of variables is a pair (X, σ) consisting of a
set X and a sort mapping σ: X −→ S (usually denoted simply by X). We let
T (F , X) be the set of (F ∪ X)-terms written with F ∪ X, where it is understood
that the variables are among the nullary symbols (constants) of F ∪X. T (F , X)s
denotes the subset of those terms of sort s. Now if X is a ﬁnite sequence of
pairwise distinct variables from X and t ∈ T (F , X)s, we denote by tM,X the
mapping from Mσ(X ) to Ms associated with t in the obvious way (σ(X ) denotes
the sequence of sorts of the elements of X ). We call tM,X a derived operation of
the algebra M . If X is known from the context, we write tM instead of tM,X .
This is the case in particular if t is deﬁned as a member of T (F , {x1, · · · , xk}) :
the sequence X is implicitly (x1, · · · , xk).

2.2 Recognizable subsets

Let F be an S-signature. An F -algebra M is locally ﬁnite if each domain Ms is
ﬁnite. If M is an F -algebra and s ∈ S is a sort, a subset L of Ms is M -recognizable
if there exists a locally ﬁnite F -algebra A, a homomorphism h: M −→ A, and a
(ﬁnite) subset C of As such that L = h−1(C).

We denote by Rec(M )s the family of M -recognizable subsets of Ms.
In
some cases it will be useful to stress the relevant signature and we will talk of
F -recognizable sets instead of M -recognizable sets.

congruence on M is an equivalence relation ≈ on M =

An equivalent deﬁnition can be given in terms of ﬁnite congruences. A
Ss∈S Ms, such that each

6

set Ms is a union of equivalence classes, and which is stable under the operations
of M . It is locally ﬁnite if for each sort s, the restriction ≈s of ≈ to Ms has
ﬁnite index. A congruence saturates a set if this set is a union of classes. A
subset L of Ms is M -recognizable if and only if it is saturated by a locally ﬁnite
congruence on M .

The following facts are easily veriﬁed from the deﬁnition of recognizability
or its characterization in terms of congruences (see [12]), and will be used freely
in the sequel.

Proposition 2.1 Let M be an F -algebra.

• For each sort s, the family Rec(M )s contains Ms and the empty set, and

it is closed under union, intersection and diﬀerence.

• If h is a unary derived operation of M or a homomorphism of M ′ into
M , (where M ′ is another F -algebra), then the inverse image under h of
an M -recognizable set is recognizable.

• If N is a G-algebra with the same domain as M , and if every G-congruence
of N is an F -congruence of M (e.g. N is derived from M , or G is ob-
tained from F by adding constants), then every M -recognizable set is N -
recognizable. If in addition G contains F , then M and N have the same
recognizable subsets.

• If M ′ is a subalgebra of M and L is an M -recognizable set, then L ∩ M ′
is M ′-recognizable. This includes the case where M ′ has the same domain
as M , and is an F ′-algebra for some subsignature F ′ of F .

• Suppose that M is generated by F and let valM be the evaluation homo-
morphism from T (F ) onto M . A subset L of Ms is F -recognizable if and
only if val−1
If in addition F is
ﬁnite, then this is equivalent to the existence of a ﬁnite tree-automaton
recognizing val−1

M (L) is a recognizable subset of T (F ).

M (L).

Example 2.2 On the set of all words over a ﬁnite alphabet A, let us consider
the binary operation of the concatenation product, and the unary operation u 7→
u2, which is derived from the concatenation product. Then the 3rd statement
in Proposition 2.1 shows that we have the same recognizable subsets as if we
considered only the concatenation product.
It is interesting to note that, in
contrast, adding the operation u 7→ u2 to the signature adds new equational
⊓⊔
languages, e.g. the set of all squares.

We will see more technical conditions that guarantee the transfer of recog-

nizability between algebras in Section 2.4 below.

7

2.3 Remarks on the notion of recognizability

We gather here some observations on the signiﬁcance of recognizability.

First, we note that if f is an operation of an F -algebra M , with arity k,
and if B1, . . . , Bk are M -recognizable, then f (B1, . . . , Bk) is not necessarily
recognizable. This is discussed for instance in [10], where suﬃcient conditions
are given to ensure that f (B1, . . . , Bk) is recognizable.
It is well-known for
instance that the product of two recognizable subsets of the free monoid (word
languages) or of the trace monoid is recognizable; a similar result holds for
recognizable sets of trees.

Now, let M be an F -algebra and let F ′ be a signature which diﬀers from
F only by the choice of constants and their values. In particular, F ′ may be
obtained from F by the addition of countably many new constants. Then the
congruences on M are the same with respect to F and to F ′ and it follows that
a subset of M is F -recognizable if and only if it is F ′-recognizable.

It is customary to assume that the F -algebra M is generated by the signature
F . If M is a countable F -algebra that is not generated by F , we can enrich F
to F ′ by adding to F one constant of the appropriate sort for each element of
M . Then F ′ generates M (in a trivial way). As noted above, M has the same
F - and F ′-recognizable subsets. If L is one of these subsets, the set val−1
M (L)
of F ′-terms is recognizable but we cannot do much with it, because we lack the
notion of a ﬁnite tree-automaton. See the conclusion of the paper for a further
discussion of this point.

Finally, we can question the interest of the notion of a recognizable set. Is

it interesting in every algebra? The answer is clearly no. Let us explain why.

If the algebraic structure over the considered set M is poor, for example
in the absence of non-nullary functions, then every set L is recognizable, by
a congruence with two classes, namely L and its complement. The notion of
recognizability becomes void.

Another extreme case is when the algebraic structure is so rich that there
are very few recognizable sets. For an example, consider the set N of natural
integers equipped with the successor and the predecessor functions (predecessor
is deﬁned by pred(0) = 0, pred(n + 1) = n). The only recognizable sets are N
and the empty set. Indeed, if ∼ is a congruence and if n ∼ n + p for some n ≥ 0,
p > 0, then by using the function pred n + p − 1 times, we ﬁnd that 0 ∼ 1.
It follows (using the successor function repeatedly) that any two integers are
equivalent.

Intuitively, if one enriches an algebraic structure by adding new operations,

one gets fewer recognizable sets.

For another example, let us consider the monoid {a, b}∗ of words over two
letters. Let us add a unary operation, the circular shift, deﬁned by : sh(1) = 1
and sh(au) = ua, sh(bu) = ub, for every word u. The language a∗b is no
longer recognizable w.r.t. this new structure, however recognizability does not
degenerate completely since every commutative language that is recognizable in
the usual sense remains recognizable in the enriched algebraic structure.

It is not completely clear yet which algebraic condition makes recognizability

8

“interesting”.

2.4 Technical results on recognizability

The statements in this section explain how to transfer a locally ﬁnite congruence
from one algebra to another, possibly with a diﬀerent signature, and hence how
to transfer recognizability properties between algebras. Proposition 2.1 above
contains examples of such results.

The statements that follow will be used in the proof of some of our main re-
sults, in Section 4. They are, unfortunately, heavily technical in their statements
(but not in their proofs. . . )

Lemma 2.3 Let F be an S-signature and let G be a T-signature. Let S be an
F -algebra and let T be a G-algebra. Let also H be a collection (Ht,s) such that,
for each t ∈ T and s ∈ S, Ht,s consists of mappings from Tt into Ss with the
following property:

for each operation g ∈ G of type (t1, . . . , tr) 7→ t and for each h ∈ Ht,s,
there exist sorts s1, . . . , sr ∈ S, mappings hi ∈ Hti,si (1 ≤ i ≤ r) and
an F -derived operation f of type (s1, . . . , sr) 7→ s such that, for every
x1 ∈ T1, . . . , xr ∈ Tr, h(g(x1, . . . , xr)) = f (h1(x1), . . . , hr(xr)).

Finally, let ≡ be an F -congruence on S and let ≈ be the equivalence relation
deﬁned, on each Tt, by

x ≈ y if and only if h(x) ≡ h(y) for every h ∈ Ht,s, s ∈ S.

Then ≈ is a G-congruence on T .

Proof. Let g be an operation in G, of type (t1, . . . , tr) 7→ t, and let x1, y1 ∈
Tt1, . . . , xr, yr ∈ Ttr such that xi ≈ yi for each i = 1, . . . , r. Let also h ∈ Ht,s
with s ∈ S.

By hypothesis, there exist sorts s1, . . . , sr ∈ S, mappings hi ∈ Hti,si (for

i = 1, . . . , r) and an F -derived operation f of type (s1, . . . , sr) 7→ s such that

h(g(x1, . . . , xr)) = f (h1(x1), . . . , hr(xr))
h(g(y1, . . . , yr)) = f (h1(y1), . . . , hr(yr)).

Since xi ≈ yi for each i, we have hi(xi) ≡ hi(yi); and since ≡ is an F -congruence,
it follows that h(g(x1, . . . , xr)) ≡ h(g(y1, . . . , yr)). Thus we have g(x1, . . . , xr) ≈
⊓⊔
g(y1, . . . , yr), which concludes the proof.

With the notation of Lemma 2.3, for each sort t ∈ T, let ≤t be the quasi-

order relation deﬁned on Ht =

Ss∈S Ht,s by

h ≤t h′ if there exists an F -derived unary operation f such that h′ = f ◦ h.

Lemma 2.4 With the notation of Lemma 2.3, if for each t the order rela-
tion associated with ≤t has a ﬁnite number of minimal elements, and if the
F -congruence ≡ on S is locally ﬁnite, then the G-congruence ≈ on T is locally
ﬁnite.

9

Proof. Let t ∈ T. We want to show that there are only ﬁnitely many ≈-classes
in T (t). By assumption, there exist elements h1, . . . , hk ∈ Ht such that every
mapping of Ht is of the form f ◦ hi for some 1 ≤ i ≤ k and some F -derived
operation f .

For each i, let Ssi be the range of hi and let ni be the number of ≡-classes
in Ssi. It is immediately veriﬁed from the deﬁnition of ≤t that if x, y ∈ Tt, then
x ≈ y if and only if hi(x) ≡ hi(y) for each 1 ≤ i ≤ k. In particular, Tt has at
⊓⊔
most n1 · · · nk ≈-classes, which concludes the proof.

We will actually need even more technical versions of these lemmas.

Lemma 2.5 Let S, T , F , G and H be as in Lemma 2.3, and let ζ be a G-
congruence on T such that:

for each operation g ∈ G of type (t1, . . . , tr) 7→ t, for each h ∈ Ht,s
and for each ~z = (z1, . . . , zr) where each zi is a ζ-class of Tti , there
exist sorts s1,~z, . . . , sr,~z ∈ S, mappings hi,~z ∈ Hti,si,~z (1 ≤ i ≤ r) and
an F -derived operation f~z of type (s1,~z, . . . , sr,~z) 7→ s such that, in T ,
h(g(x1, . . . , xr)) = f~z(h1,~z(x1), . . . , hr,~z(xr)) if each xi is in zi.

Finally, let ≡ be an F -congruence on S and let ≈ be the equivalence relation
deﬁned, on each Tt, by

x ≈ y if and only if x ζ y and h(x) ≡ h(y) for every h ∈ Ht,s, s ∈ S.

Then ≈ is a G-congruence on T . Moreover, if H satisﬁes the hypothesis of
Lemma 2.4 and ≡ and ζ are locally ﬁnite, then ≈ is locally ﬁnite as well.

Proof. The proof is the same as for Lemmas 2.3 and 2.4.

⊓⊔

3 Algebras of relational structures

Even though we are ultimately interested in studying sets of graphs, it will be
convenient to handle the more general case of relational structures. Further-
more, relational structures can be identiﬁed with simple directed hypergraphs.
Such hypergraphs form a natural representation of terms. See for instance the
chapter on hypergraphs in [15] for applications.

In this paper, all graphs and structures are ﬁnite or countable. Our proofs
will not usually depend on cardinality assumptions on the graphs or struc-
tures, and hence our results will hold for ﬁnite as well as for inﬁnite graphs or
structures. However, recognizability in the algebraic sense we deﬁned, is really
interesting only for dealing with ﬁnitely generated objects, and hence for ﬁnite
graphs and structures. For dealing with inﬁnite words, trees and graphs, other
tools are necessary, see for instance [40, 43, 29, 30].

10

3.1 Relational structures

Let R be a ﬁnite set of relation symbols, and C be a ﬁnite set of nullary symbols.
Each symbol r ∈ R has an associated positive integer called its rank, denoted by
ρ(r). An (R, C)-structure is a tuple S = hDS, (rS)r∈R, (cS)c∈C i such that DS is
a (possibly empty) set called the domain of S, each rS is a ρ(r)-ary relation on
DS, i.e., a subset of Dρ(r)
, and each cS is an element of DS, called the c-source
of S.

S

We denote by StS(R, C) the class of (ﬁnite or countable) (R, C)-structures,
and we sometimes write StS(R) for StS(R, ∅). By convention, isomorphic struc-
tures will be considered as equal. In the notation StS, St stands for structures,
while the second S stands for sources.

A structure S ∈ StS(R, C) is source-separated if cS 6= c′

S for c 6= c′. We will
denote by StSsep(R, C) the class of source-separated structures in StS(R, C).
See Corollary 3.11 and Section 3.5.2 below.

In order to handle graphs, we will consider particular kinds of structures in
the sequel. We let E = {edge} be the set of relation symbols consisting of a
single binary relation edge, intended to represent directed edges. Thus graphs
can be seen as the elements of StS(E), also written Graph. Clearly these graphs
are directed, simple (we cannot represent multiple edges) and they may have
loops. For a discussion of graphs with multiple edges, see Section 7.

We let GS(C) denote the set StS(E, C). These structures are called graphs

with sources. We let GSsep(C) denote the intersection GS(C) ∩ StSsep(R, C).

We will discuss also graphs with ports (Section 4): if P is a ﬁnite set of unary
relation symbols called port labels, then we denote by EP the set of relational
symbols E ∪ P and by GP(P ) the class StS(EP ). Port labels are useful for
studying the clique-width of graphs, see [18, 19] and Remark 4.11 below.

3.2 The algebra StS

We ﬁrst deﬁne some operations on structures.

Disjoint union Let C and C′ be disjoint sets of constants and let S ∈
StS(R, C) and S′ ∈ StS(R′, C′). Let us also assume that S and S′ have dis-
joint domains. We denote by S ⊕ S′ the union of S and S′, which is naturally
a structure in StS(R ∪ R′, C ∪ C′).

If S and S′ are not disjoint, we replace S′ by a disjoint copy. We need not
be very precise on how to choose this copy because diﬀerent choices will yield
isomorphic ⊕-sums, and we are interested in structures up to isomorphism.

Remark 3.1 It is also possible to deﬁne a similar operation, without the re-
striction that C and C′ are disjoint (as in, say, [9, 13]). See Section 3.5.1 below
⊓⊔
for a discussion.

11

Quantiﬁer-free deﬁnable operations Our purpose is now to deﬁne func-
tions from StS(R, C) to StS(R′, C′) by quantiﬁer-free formulas. We denote by
QF (R, C, {x1, ..., xn}) the set of quantiﬁer-free formulas on (R, C)-structures
with variables in {x1, ..., xn}.

A qfd operation scheme from StS(R, C) to StS(R′, C′) is a tuple

(δ, (ϕr)r∈R′ , (κc,d)c∈C,d∈C ′),

where δ ∈ QF (R, C, {x}), ϕr ∈ QF (R, C, {x1, . . . , xρ(r)}) if r is a ρ(r)-ary
relation symbol, κc,d ∈ QF (R, C, ∅), such that the following formulas are valid
in every structure in StS(R, C), for all c, c′ ∈ C, d ∈ C′ and r ∈ R′ of arity
ρ(r):

• κc,d ∧ κc′,d =⇒ c = c′;

•

We∈C κe,d;
• κc,d =⇒ δ(c);

• ∀x1, . . . , xρ(r) (cid:16)ϕr(x1, . . . , xρ(r)) =⇒

ρ(r)
i=1 δ(xi)(cid:17).

V

The reason for these conditions becomes apparent with the following deﬁnition
of the qfd operation g: StS(R, C) → StS(R′, C′) deﬁned by such a scheme. Let
S ∈ StS(R, C). The domain of the structure g(S) is the subset of the domain
of S deﬁned by formula δ and the relation r (r ∈ R′) on g(S) is described by
formula ϕr. Finally, if d ∈ C′, then dg(S) = cS if c ∈ C and S satisﬁes κc,d. The
ﬁrst two conditions imposed above assert that relative to S, c is uniquely deﬁned
for each d, the third condition asserts that dg(S) always lies in the domain of
g(S), and the fourth condition asserts that the relation ϕr (r ∈ R′) can only
relate elements of the domain of g(S).

Remark 3.2 Note that in the ﬁrst condition, c = c′ does not mean that c and
c′ are the same constant, but that they have the same value in the considered
⊓⊔
structure.

Remark 3.3 The conditions to be veriﬁed by a qfd operation scheme are de-
cidable. It follows that the notion of a qfd operation scheme is eﬀective. See
the appendix (Remark A.4 in particular) for a discussion of this decidability
⊓⊔
result.

Example 3.4 Let R be a ﬁnite set of relational symbols, C be a ﬁnite set of
source labels and let a, b be source labels. We deﬁne the following operations.

• if a ∈ C and b 6∈ C, srcrena→b is the unary operation of type (R, C) →
(R, C \ {a} ∪ {b}) which renames the a-source of a structure to a b-source;

• if a ∈ C, srcfga is the unary operation of type (R, C) → (R, C \ {a}) which

forgets the a-source of a structure;

12

• if a 6= b ∈ C, fusa,b is the unary operation of type (R, C) → (R, C) which
identiﬁes the a-source and the b-source of a structure (so the resulting
domain element is both the a-source and the b-source), and reorganizes
the tuples of the relational structure accordingly.

Note that the operation names srcrena→b, srcfga and fusa,b are overloaded:
they denote diﬀerent operations when the sets R and C are allowed to vary. A
completely formal deﬁnition would use operation names such as srcrena→b,R,C ,
which would be inconvenient.

It is immediately veriﬁed that the operations of the form srcrena→b and srcfga
are qfd. It is probably worth showing explicitly a qfd operation scheme deﬁning
the operation fusa,b.

Let δ(x) be the formula (a = b) ∨ ((a 6= b) ∧ (x 6= a)). If r ∈ R has arity

ρ(r) = n, let ϕr(x1, . . . , xn) be the formula

(cid:16)(a = b) ∧ r(x1, . . . , xn)(cid:17) ∨

(cid:16)(a 6= b) ∧

(
^
_
i∈I
I⊆{1,...,n}

(xi = b) ∧

^
i6∈I

(xi 6= b) ∧ r(y1, . . . , yn))(cid:17),

where for each I, yi = a if i ∈ I and yi = xi otherwise. For each d ∈ C such
that d 6= a and for each c ∈ C, let κc,d be the formula c = d; let κb,a be the
formula true, and let κc,a be the formula c = a for each c 6= b. It is now routine
to verify that the scheme (δ, (ϕr)r∈R, (κc,d)c,d∈C) deﬁnes fusa,b.
⊓⊔

Remark 3.5 There is no qfd operation from StS(R) into StS(R′, C)′ if C′ 6= ∅,
because in the absence of constants in the input structure, we cannot deﬁne
⊓⊔
constants in the output structure.

Example 3.6 The natural inclusion of StS(R, C) into StS(R′, C) when R′
contains R is a qfd operation in natural way: the formulas intended to deﬁne
relations in R′ \ R are taken to be identically false.
⊓⊔

The signature S We deﬁne the algebra StS of structures with sources as
follows. First, let us ﬁx once and for all a countable set of relation symbols con-
taining edge and countably many relation symbols of each arity, and a countable
set of constants. In the sequel, ﬁnite sets of relation symbols R and ﬁnite sets
of constants C will be taken in these ﬁxed sets. The set of sorts consists of all
such pairs (R, C). The set of elements of StS of sort (R, C) is StS(R, C).

The signature S consists of the following operations (interpreted in StS).
First, for each pair of sorts (R, C) and (R′, C′) such that C ∩ C′ = ∅, the
disjoint union ⊕ is an operation of type ((R, C), (R′, C′)) → (R ∪ R′, C ∪ C′).
Note that we overload the symbol ⊕, that is, we denote in the same way an
inﬁnite number of operations on StS. Next, every qfd operation is a (unary)
operation in S.

13

Finally, we observe that the signature S contains the natural inclusions of
StS(R, C) into StS(R′, C) when R′ contains R, which are qfd (Example 3.6).
As for constants in S, one can pick a single source label a, and consider
a single constant a, denoting the structure with a single element, which is an
a-source, and no relations. Together with the operations in S, this constant
suﬃces to generate all ﬁnite relational structures. As noted in Section 2.3, the
choice of constants does not aﬀect recognizability. It only aﬀects the generating
power of the signature, but this is not our point in this paper.

3.3 Elementary properties of StS

We ﬁrst consider the composition of qfd operations.

Proposition 3.7 Qfd operations in StS are closed under composition (when-
ever types ﬁt for deﬁning meaningful composition).

Proof. Let g: StS(R, C) −→ StS(R′, C′) and g′: StS(R′, C′) −→ StS(R′′, C′′)
be qfd operations, given respectively by the schemes (δ, (ψr)r∈R′, (κc,d)c∈C,d∈C ′)
and (δ′, (ψ′

c,d)c∈C ′,d∈C ′′).

r)r∈R′′ , (κ′

r (r ∈ R′′) and κ0

The composite g′ ◦ g turns an (R, C)-structure into an (R′′, C′′)-structure.
Let δ0, ψ0
r and
c,d by replacing every occurrence of r(y1, . . . , yρ(r)) (r ∈ R′) by ψr(y1, . . . , yρ(r));
κ′
our formulas are now in the language of (R, C′)-structures and we need to
“translate” the constants d ∈ C′ into elements of C. However, this translation,
a mapping from C′ to C, depends on the structure in which we operate.

c,d (c ∈ C′, d ∈ C′′) be obtained from δ′, ψ′

To reﬂect this observation, for each mapping h: C′ → C, we let h(δ0) be the
conjunction of the formulas κh(d),d (d ∈ C′) and the formula obtained from δ0
by replacing each occurrence of d (d ∈ C′) by h(d). Finally, we let δ′′ be the
disjunction of the h(δ0) when h runs over all mappings from C′ to C.

We proceed in the same fashion to deﬁne ψ′′

c,d for each r ∈ R′′
and each c ∈ C′, d ∈ C′′. Finally, if b ∈ C and d ∈ C′′, we let λb,d =
Wc∈C ′(κ′
r )r∈R′′ , (λb,d)b∈C,d∈C ′′) is a qfd oper-
ation scheme, which deﬁnes the composite operation g′ ◦ g. This completes the
⊓⊔
proof.

It is a routine veriﬁcation that (δ′′, (ψ′′

r and κ′′

b,c ∧ κ′′

c,d).

For each S ∈ StS(R, C), we deﬁne the type of S, written ζ(S), to be the
restriction of S to its set of sources. That is: the domain of ζ(S) is the set of
C-sources of S, and the relations of ζ(S) are those tuples of C-sources that are
relations in S. In order to simplify notation, we also denote by ζ the equivalence
relation on StS given by

S ζ T if and only if

ζ(S) and ζ(T ) are isomorphic.

Lemma 3.8 Let S, T ∈ StS(R, C). Then S ζ T if and only if S and T satisfy
the same formulas in QF (R, C, ∅).

14

Proof. A formula in QF (R, C, ∅) is a Boolean combination of atoms of the form
c = d where c, d ∈ C, or r(x1, . . . , xn) where r ∈ R has arity n and the xi are
in C. It is immediate that such an atom is true in S if and only if it is true in
ζ(S). Thus S and ζ(S) satisfy the same formulas in QF (R, C, ∅): in particular,
ζ-equivalent structures satisfy the same formulas in QF (R, C, ∅). Thus, if we
denote by T hF O
0,R,C(S) the set of formulas in QF (R, C, ∅) that are satisﬁed by S
(see Section 3.4), we ﬁnd that T hF O

0,R,C(S) = T hF O
Conversely, we observe that if S is a structure in StS(R, C), which consists
only of its C-sources (that is, S = ζ(S)), then S is entirely described by some
formula in QF (R, C, ∅). Thus, if ζ(S) 6= ζ(T ), then T hF O
0,R,C(T ).
⊓⊔
This suﬃces to conclude the proof.

0,R,C(S) 6= T hF O

0,R,C(ζ(S)).

The type relation ζ has the following important property.

Proposition 3.9 The type relation ζ is a locally ﬁnite congruence on StS.

Proof. The veriﬁcation that ζ(S ⊕ S′) = ζ(S) ⊕ ζ(S′) (S ∈ StS(R, C), S′ ∈
StS(R′, C′) and C ∩ C′ = ∅) is immediate. Let us now consider a qfd op-
eration g: StS(R, C) −→ StS(R′, C′), speciﬁed by the qfd operation scheme
(δ, (ψr)r∈R′ , (κc,d)c∈C,d∈C ′). By Lemma 3.8, S and ζ(S) satisfy the same for-
mulas of QF (R, C, ∅). In particular, for each c ∈ C and d ∈ C′, S and ζ(S)
both satisfy κc,d, or both satisfy its negation. Thus g(S) and g(ζ(S)) have the
same sources, and hence ζ(g(S)) = ζ(g(ζ(S))).

We have just shown that the type relation is a congruence. To complete
the proof, it suﬃces to show that for each sort (R, C), the set of types of sort
(R, C), that is, the set ζ(StS(R, C)) is ﬁnite. Note that if S ∈ StS(R, C), then
ζ(S) has cardinality at most card(C) (and also at most card(S)). It follows that
Qr∈R 2card(C)ρ(r)
card(ζ(StS(R, C))) ≤ card(C)!
⊓⊔
Remark 3.10 Proposition 3.9 can be seen as a particular case of a result of
Feferman and Vaught [25], Theorem 3.12 below, which will be used in Section
⊓⊔
6. The simple formulation above will be very useful.

.

Note that the knowledge of ζ(S) is suﬃcient to determine whether S is
a source-separated structure. This observation is used to prove the following
corollary.

Corollary 3.11 Let (R, C) be a sort in StS. Then StSsep(R, C) is a recogniz-
able subset of StS(R, C).

Proof. Whether a structure S is source-separated depends only on its type
in particular, the type congruence ζ saturates StSsep(R, C). By Propo-
ζ(S):
sition 3.9, this relation is a locally ﬁnite congruence, and hence StSsep(R, C) is
⊓⊔
recognizable.

15

3.4 A result of Feferman and Vaught

If (R, C) is a sort of StS, we denote by F O(R, C) the set of closed ﬁrst-order
formulas over R and C. For each integer d, we denote by F Od(R, C) the set
of those formulas of quantiﬁer-depth at most d. Up to a decidable syntactic
equivalence (taking into account Boolean laws, properties of equality, renaming
of quantiﬁed variables, see Appendix A), there are only ﬁnitely many formulas
in each set F Od(R, C). Thus, we can reason as if F Od(R, C) was actually ﬁnite.
d,R,C(S) of
formulas in F Od(R, C) that are valid in S. It is ﬁnite since it is a subset of the
ﬁnite set F Od(R, C).

For an (R, C)-structure S, we let its F Od-theory be the set T hF O

Theorem 3.12 Let d ≥ 0.

(1) For every qfd operation f of type (R, C) → (R′, C′), there exists a mapping

f #
d such that, for every (R, C)-structure S

T hF O

d,R′,C ′(f (S)) = f #

d (T hF O

d,R,C(S)).

(2) For every (R, C) and (R′, C′), where C and C′ are disjoint, there exists
d such that, for every (R, C)-structure S, and every

a binary function ⊕#
(R′, C′)-structure S′,

T hF O

d,R∪R′,C∪C ′(S ⊕ S′) = T hF O

d,R,C(S) ⊕#

d T hF O

d,R′,C ′(S′).

Remark 3.13 The second assertion was proved in [25] for ﬁrst-order logic, and
extended by Shelah to monadic second-order logic [42]. The importance of this
⊓⊔
result is discussed by Makowsky in [36].

Remark 3.14 The functions f #
d have ﬁnite domains and codomains.
However these sets are quite large. These functions can be (at least in principle)
eﬀectively determined for given (R, C), (R′, C′), and d.
⊓⊔

d and ⊕#

3.5 Variants of the algebra of relational structures

In the literature on recognizable and equational graph languages, several vari-
ants of the signature S and the algebra StS are considered, notably a variant
where the deﬁnition of the disjoint union is replaced by a more general parallel
product, and a variant where all structures are assumed to be source-separated.
We verify in this section that these variants do not yield diﬀerent notions of
recognizability.

3.5.1 Parallel composition vs. disjoint union

In the literature (e.g.
[9, 13]), the operation of disjoint union ⊕ is sometimes
replaced by the so-called parallel composition (or product ), written k, an oper-
ation of type ((R, C), (R′, C′)) → (R ∪ R′, C ∪ C′) for which we do not assume

16

that C and C′ are disjoint. If S ∈ StS(R, C) and S′ ∈ StS(R′, C′), the parallel
composition S k S′ is obtained by taking the (set-theoretic) disjoint union of S
and S′ and then identifying the c-sources of S and S′ for each c ∈ C ∩ C′. Let
Sk denote the signature obtained from S by substituting k for ⊕.

Proposition 3.15 Let L be a subset of StS. Then L is S-recognizable if and
only if it is Sk-recognizable.

Proof. We ﬁrst observe that the operation ⊕ is a particular case of k. Therefore
S is a sub-signature of Sk and hence, every Sk-recognizable set is S-recognizable.
To prove the converse, it suﬃces to verify that k is an S-derived operation
by Proposition 2.1. Indeed, if S ∈ StS(R, C) and S′ ∈ StS(R′, C′), the parallel
composition S k S′ can be obtained by the following sequence of S-operations
(see Example 3.4 for their deﬁnition):

- for each c ∈ C ∩ C′, apply the qfd operation srcrenc→¯c which renames the
c-source in S′ with a new source label, say ¯c, not in C; let ¯S′ be the resulting
structure;

- take the disjoint union S ⊕ ¯S′;
- for each c ∈ C ∩ C′, apply the operation fusc,¯c which identiﬁes the c-source

and the ¯c-source in S ⊕ ¯S′;

- apply the source-forgetting operation srcfg¯c for each c ∈ C ∩ C′.

⊓⊔

3.5.2 Source-separated structures

The property that cS 6= c′
S for c 6= c′ is called source separation. This property
makes it easier to work with operations on structures and graphs, and hence we
discuss a variant of the S-algebra StS, which handles source-separated struc-
tures. We will also use it in Section 6.

Recall that StSsep(R, C) denotes the set of source-separated structures in
StS(R, C). We now deﬁne a subsignature Ssep of S such that StSsep is a sub-
algebra of StS.

Disjoint union ⊕ clearly preserves source separation, and is part of Ssep.
Next we include in Ssep the operations speciﬁed by qfd operation schemes such
that, for each c ∈ C and d 6= d′ ∈ C′ (see the notation in Section 3.2),

κc,d =⇒ ¬κc,d′,

(1)

which guarantees that the operation preserves source separation.

Example 3.16 The operations srcrena→b and srcfga deﬁned in Example 3.4 are
in Ssep. The operation fusa,b deﬁned in the same example is not.

In contrast, the operation written fusa→b, which identiﬁes the a-source and
the b-source of a structure as in fusa,b, and makes the resulting element of the
domain a b-source but not an a-source, preserves source separation. It can be
written as fusa→b = srcfga ◦ fusa,b.

The operation which, given a graph with source labels a and b, exchanges
the source labels a and b if the corresponding vertices are linked by an edge and
⊓⊔
does nothing otherwise, is another example of a qfd operation in Ssep.

17

Regarding the eﬀectiveness of the deﬁnition of Ssep, we observe the following.

Proposition 3.17 Given a qfd operation scheme, one can decide whether the
corresponding qfd operation preserves source separation.

Proof. Let g be the qfd operation speciﬁed by the given qfd operation scheme,
and let StS(R, C) be the domain of g. One can eﬀectively construct the images
under g of every type in StS(R, C), since there are only ﬁnitely many of them,
and they can all be enumerated. One can then verify whether the operation
preserves souce-separation on types.

Now it follows from the proof of Proposition 3.9 that for each S ∈ StS(R, C),
we have ζ(g(ζ(S))) = ζ(g(S)). In particular, g preserves source separation if
and only if it preserves it for the structures of the form ζ(S). Thus one can
⊓⊔
eﬀectively decide whether g ∈ Ssep.

We now show that the restriction to source-separated structures does not

change the notion of recognizability.

Theorem 3.18 Let L be a subset of StSsep. Then L is S-recognizable if and
only if it is Ssep-recognizable.

Proof. By deﬁnition, Ssep is a subsignature of S, so every S-recognizable set is
Ssep-recognizable.

To prove the converse, we ﬁrst deﬁne a mapping h, which maps a structure
S ∈ StS(R, C) to a source-separated structure h(S) ∈ StSsep(R, C) by splitting
sources that were identiﬁed in S.

We assume that the countable set of constant symbols (from which C is

taken, see Section 3.2) is linearly ordered. Let hS

0 : C → C be given by

hS
0 (c) = min{d ∈ C | cS = dS}.

0 = hS

1 = C \ CS

0 (C) and CS

We let CS
0 . The structure h(S) has domain set
the disjoint union of S and CS
0 , the c-source of h(S) is the
1 , the c-source of h(S) is the element c ∈ CS
c-source of S, and for each c ∈ CS
1 .
Finally, for each r ∈ R, the relation rh(S) equals the relation rS (so it does not
involve the elements of CS
1 ). Observe that h is not a qfd operation, and that
0 , CS
hS

1 depend only on ζ(S).

1 . For each c ∈ CS

0 and CS

Now let L be an Ssep-recognizable subset of StSsep and let ≡ be a locally
ﬁnite Ssep-congruence recognizing it. We need to construct a locally ﬁnite S-
congruence ∼ on StS which recognizes L.

The relation ∼ on StS is deﬁned as follows. If S, T ∈ StS(R, C), we say
that S ∼ T if ζ(S) = ζ(T ) and h(S) ≡ h(T ). It is immediately veriﬁed that ∼
is an equivalence relation. Moreover, the ∼-class of a structure S is determined
by its ζ-class, and by the ≡-class of h(S). Since both ζ and ≡ are locally ﬁnite,
∼ also is locally ﬁnite.

18

Let us now prove that ∼ is an S-congruence. Let S ∼ T ∈ StS(R, C) and
S′ ∼ T ′ ∈ StS(R′, C′), with C ∩ C′ = ∅. By Proposition 3.9, ζ(S ⊕ S′) =
ζ(T ⊕ T ′). It is not diﬃcult to verify that

h(S ⊕ S′) = h(S) ⊕ h(S′).

It follows that h(S ⊕ S′) ≡ h(T ⊕ T ′) since ⊕ is an operation in Ssep. Thus
S ⊕ S′ ∼ T ⊕ T ′.

Next let g be a qfd operation from StS(R, C) to StS(Q, B), given by the
qfd operation scheme (δ, (ψq)q∈Q, (κc,b)c∈C,b∈B). Let S and T be ∼-equivalent
elements of StS(R, C), which will remain ﬁxed for the rest of this proof. We
need to show that g(S) ∼ g(T ). We already know from Proposition 3.9 that
if S ∼ T ∈ StS(R, C), then ζ(g(S)) = ζ(g(T )), and we want to show that
h(g(S)) ≡ h(g(T )).

Since ζ(g(S)) = ζ(g(T )), the mappings hg(S)

, from B to B, co-
incide. Let B0 = hg(S)
(B) and B1 = B \ B0. Without loss of generality, we
may assume that B1 ∩ C = ∅. The domain set of h(g(S)) (resp. h(g(T ))) is the
disjoint union of the domain of g(S) (resp. g(T )) and B1.

and hg(T )

0

0

0

It suﬃces to show that there exists a qfd operation k ∈ Ssep, depending on
g and ζ(S), such that h(g(S)) = k(h(S) ⊕ B1) and h(g(T )) = k(h(T ) ⊕ B1)
(where B1 is the source-only element of StSsep(∅, B1)). Indeed, the fact that ≡
is an Ssep-congruence will then imply that h(g(S)) ≡ h(g(T )).

Let δ′ be obtained from δ by replacing every occurrence of c ∈ C by hS

For each q ∈ Q, c ∈ C and b ∈ B, let ψ′
obtained from κc,b in the same fashion.

q be obtained from ψq and κ′

Let now k′: StS(R, C ∪ B1) → StS(Q, B) be deﬁned by the scheme

0 (c).
c,b be

(γ′, (χ′
q)q∈Q, (λ′
γ′(x) = (cid:16)δ′(x) ∧

c,b)c∈C∪B1,b∈B) deﬁned as follows:

¬(x = c)(cid:17) ∨

(x = b)

_
b∈B1

^
c∈C S
1

q for each q ∈ Q

χ′
q = ψ′
λ′
b,b = true if b ∈ B1
λ′
c,b = false if b ∈ B1 and c 6= b
λ′
c,b = false if b ∈ B0 and c ∈ CS
1
λ′
c,b =

_
(a)=b, hS

hg(S)
0

0 (d)=c

κ′
d,a if b ∈ B0 and c ∈ CS
0 .

It is now a routine veriﬁcation that (for our ﬁxed structure S) k′(h(S) ⊕
B1) = h(g(S)). Since all our deﬁnitions depend only on ζ(S), we also have
k′(h(T ) ⊕ B1) = h(g(T )).

One last step is required in this proof as the qfd operation k′ may not
preserve source separation for all structures, that is, k′ may not lie in Ssep. It
does for the particular structures h(S) ⊕ B1 and h(T ) ⊕ B1, but perhaps not for
others. Actually, structures U such that ζ(U ) 6= ζ(h(S) ⊕ B1) = ζ(h(T ) ⊕ B1)

19

do not matter in this context, so we can replace k′ by the operation k, with
the same domain and range as k′, which maps a structure U to k′(U ) if ζ(U ) =
ζ(h(S) ⊕ B1), and to the source-only source-separated structure B ∈ StS(Q, B)
where all relations are empty. This new operation k preserves source separation
by construction, and it is easily veriﬁed to be qfd. This completes (at last) the
⊓⊔
proof.

4 The algebra GP of graphs with ports

Graphs with ports were introduced in Section 3.1. Recall that if P is a set of
unary relation symbols, then EP denotes the set EP = {edge} ∪ P and the class
of graphs with ports in P , written GP(P ) can be identiﬁed with StS(EP ). We
observe that a vertex of a graph with ports in P can be a p-port for one or
several port labels p ∈ P , or for none at all.

For convenience, we will consider that P is a ﬁnite subset of the set N of

natural integers.

4.1 The signature VR on graphs with ports
We deﬁne the set of sorts of the algebra GP to be the set of ﬁnite subsets of N.
For each such subset P , the set of elements of GP of sort P is the set GP(P ) of
graphs with ports in P .

The signature VR consists of constants, unary operations and binary opera-

tions. These operations (interpreted in GP) are as follows.

First, if P, Q are ﬁnite subsets of N, then ⊕ is as in StS, and is thus a binary
operation of type (EP , EQ) → EP ∪Q. In GP, we consider ⊕ as an operation of
type (P, Q) → P ∪ Q.

Next, the unary operations of VR are the following (clearly qfd) operations:

• if p, q are distinct integers, addp,q is an operation of type P → P for each
sort P such that p, q ∈ P :
it modiﬁes neither the domain (the set of
vertices) nor the unary relations p (p ∈ P ); the new edge relation has the
existing edges, plus every edge from a p-port to a q-port: it is given by

edge (x, y) ∨ (p(x) ∧ q(y));

• if D is a ﬁnite subset of N × N, mdfD is an operation of type P → Q where
P is any ﬁnite set containing the domain of the relation D and Q is any
ﬁnite set containing the range of D; it modiﬁes neither the domain (set of
vertices) nor the edge relation; for each q ∈ Q, the q-ports of the output
structure are the vertices of the input structure that are p-ports for some
p such that (p, q) ∈ D; that is, q(x) is given by

W(p,q)∈D p(x).

Finally, for each integer p, we let p be the constant of type {p} denoting the
graph with a single vertex, no edges, and whose vertex is a p-port. We also let
ploop be the same graph, with a single loop.

20

Remark 4.1 The following operations on graphs with ports occur in the liter-
ature, and are particular cases of VR-operations.

Let p 6= q be integers, P be a subset of N containing p and Q = P \ {p} ∪ {q}.
The operation renp→q, of type P → Q which renames every p-port to a q-port, is
an operation of VR: it is equal to mdfD where D = {(r, r) | r ∈ P \{p}}∪{(p, q)}.
Observe that this operation fuses the sets of vertices deﬁned by p and q.

Let p be an integer, and let P be a subset of N containing p. The operation
fgp, of type P → P \ {p}, which forgets p-ports is an operation of VR: it is equal
to mdfD where D = {(r, r) | r ∈ P \ {p}}.
⊓⊔

Remark 4.2 In our deﬁnition of graph with ports, an element of GP(Q) does
not need to have q-ports for each q ∈ Q. Thus, if P ⊆ Q, every graph with
ports in P can also be viewed as a graph with ports in Q. The natural inclusion
it is equal to mdfD where
of GP(P ) into GP(Q) is part of the signature VR:
⊓⊔
D = {(p, p) | p ∈ P }.

Remark 4.3 Again (as in Example 3.4), the operations introduced in this sec-
tion are denoted by overloaded symbols. A formal deﬁnition should specify the
type of the operation, and would read something like addp,q,P or mdfD,P,Q. We
⊓⊔
prefer the more concise notation introduced here.

4.2 A technical result

The following result describes the action of a qfd operation on a disjoint union of
structures. It is the key to the main results of this section, described in Section
4.3 below.

Proposition 4.4 Let ζ be the type congruence (see Section 3.3). Let h be
a unary qfd operation on StS, from StS(R, C) to StS(EQ, ∅) = GP(Q), let
(R1, C1) and (R2, C2) be sorts of StS such that R = R1 ∪ R2, C1 ∩ C2 = ∅ and
C = C1 ∪ C2, and let ~z = (z1, z2) with z1 a ζ-class in StS(R1, C1) and z2 a
ζ-class in StS(R2, C2).

Then there exist quantiﬁer-free deﬁnable operations g1,~z: StS(R1, C1) → GP(Q1,~z),

g2,~z: StS(R2, C2) → GP(Q2,~z), and f~z: GP(Q1,~z ∪ Q2,~z) → GP(Q), such that

• f~z is a composition of unary operations in VR;

• for each x1 ∈ StS(R1, C1) in class z1 and each x2 ∈ StS(R2, C2) in class

z2, h(x1 ⊕ x2) = f~z(g1,~z(x1) ⊕ g2,~z(x2)).

Proof. Let (δ, ψedge, (ψq)q∈Q) be the qfd operation scheme deﬁning the oper-
ation h: here ψedge deﬁnes the edge relation, ψq deﬁnes the q-ports (q ∈ Q),
and there is no formula of the form κc,d since the range of h is in GP(Q) =
StS(EQ, ∅). The formulas δ, ψedge and ψq, for q ∈ Q, are in the language of
(R, C)-structures.

21

The atoms of δ(v) are either of the form r(y1, . . . , yρ(r)) (r ∈ R), or v = c, or
c1 = c2 (c, c1, c2 ∈ C). Let δ1 be the formula obtained from δ(v) by substituting
the Boolean value 0 (false) for the following atoms, which are certainly false in a
disjoint sum x1 ⊕ x2, with x1 ∈ StS(R1, C1), x2 ∈ StS(R2, C2) and the variable
v interpreted in x1:

• each r-atom such that r 6∈ R1 and an argument of r is v or a constant in

C1;

• each r-atom such that r 6∈ R2 and an argument of r is a constant in C2;

• each r-atom such that r ∈ R1 ∩ R2, an argument of r is a constant in C2,

and another argument of r is v or a constant in C1;

• each atom of the form y = c such that c ∈ C2 and y is equal to v or to a

constant in C1.

The remaining atoms in δ1 are either in QF (R1, C1, {v}) or in QF (R2, C2, ∅).
Note that the ζ-class of an element of StS(R2, C2) determines entirely which
formulas in QF (R2, C2, ∅) it satisﬁes. For each ~z as in the statement of the
proposition, we let δ1,~z be the formula in QF (R1, C1, {v}) obtained from δ1 by
replacing each atom in QF (R2, C2, ∅) by the Boolean value 0 or 1 according to
the ζ-class z2. We observe that if v is a vertex of x1 ⊕ x2 which happens to be
in x1, then

δ(v) ⇐⇒ δ1,~z(v)

whenever the ζ-class of x2 is z2.

For each q ∈ Q, let ψ1,~z
of x1 ⊕ x2 in x1,

q be deﬁned similarly. Then we also have, if v is a vertex

ψq(v) ⇐⇒ ψ1,~z

q (v)

whenever the ζ-class of x2 is z2.

q

Let also δ2,~z and ψ2,~z
be deﬁned dually. And again, if i, j ∈ {1, 2}, we let
ψi,j
edge(v, w) be the formula obtained from ψedge by substituting the Boolean value
0 for the atoms that are certainly false in a disjoint sum x1 ⊕ x2 for the variable
v interpreted in xi and the variable w interpreted in xj:

• each r-atom such that r 6∈ Ri and v is an argument of r;

• each r-atom such that r 6∈ Rj and w is an argument of r;

• each r-atom such that r 6∈ R1 and a constant in C1 is an argument of r;

• each r-atom such that r 6∈ R2 and a constant in C2 is an argument of r;

• each r-atom such that r ∈ R1 ∩ R2, an argument of r is a constant in C2,

and another argument of r is a constant in C1;

• each r-atom such that r ∈ R1 ∩ R2, an argument of r is v (resp. w) and

another argument of r is a constant in C3−i (resp. C3−j);

22

• each atom of the form v = c with c ∈ C3−i, w = c with c ∈ C3−j , or

c1 = c2 with c1 ∈ C1 and c2 ∈ C2;

• if i 6= j, each r-atom such that r ∈ R1 ∩ R2, and v and w are arguments

of r.

As above, the remaining atoms in ψ1,1
edge are in QF (R1, C1, {v, w})∪QF (R2, C2, ∅),
and for each ~z, we let ψ1,1,~z
edge by substituting the Boolean
values 0 or 1 for the atoms in QF (R2, C2, ∅) according to the ζ-class z2. If v, w
are vertices of x1 ⊕ x2 in x1, and if the ζ-class of x2 is z2, then

edge be obtained from ψ1,1

ψedge(v, w) ⇐⇒ ψ1,1,~z

edge (v, w).

We deﬁne ψ2,2,~z

edge similarly, and get the analogous equivalence.

If i 6= j, the atoms of ψi,j

edge be obtained from ψi,j

edge are in QF (Ri, Ci, {v}) and in QF (Rj, Cj, {w})
– which may include atoms in QF (R1, C1, ∅) and in QF (R2, C2, ∅). Again, we
let ψi,j,~z
edge by substituting the Boolean values 0 or 1 for
the atoms without free variables according to the ζ-classes z1 and z2. And we
observe that if v, w are vertices of x1 ⊕ x2, v is in xi and in the ζ-class zi, w is
in xj and in the ζ-class zj, then

ψedge(v, w) ⇐⇒ ψi,j,~z

edge (v, w).

Now let k = 1 + max(Q), let Xk+1, . . . , Xℓ be an enumeration of the subsets
of QF (R1, C1, {y}), and let Yℓ+1, . . . , Ym be an enumeration of the subsets of
QF (R2, C2, {y}). Let us denote by Q1 the set Q ∪ {k + 1, . . . , ℓ} and by Q2 the
set Q ∪ {ℓ + 1, . . . , m}.

We deﬁne the qfd operation g1,~z: StS(R1, C1) → GP(Q1) deﬁned by the

following operation scheme:

δ1,~z,

ψ1,1,~z
edge ,

ψ1,~z
q

(q ∈ Q),

θn (k + 1 ≤ n ≤ ℓ)

where for each k + 1 ≤ n ≤ ℓ, θn(v) holds if the set of quantiﬁer-free formulas
in QF (R1, C1, {y}) satisﬁed by v is exactly Xn.

Similarly, the qfd operation g2,~z: StS(R2, C2) → GP(Q2) is deﬁned by the

operation scheme

δ2,~z,

ψ2,2,~z
edge ,

ψ2,~z
q

(q ∈ Q),

θn (ℓ + 1 ≤ n ≤ m)

where for each ℓ + 1 ≤ n ≤ m, θn(v) holds if the set of quantiﬁer-free formulas
in QF (R2, C2, {y}) satisﬁed by v is exactly Xn.

Finally, we consider structures x1 ∈ StS(R1, C1) and x2 ∈ StS(R2, C2),
with ζ-classes respectively z1 and z2, and we compare the graphs with ports
g1,~z(x1) ⊕ g2,~z(x2) and h(x1 ⊕ x2). The above remarks show that these two
graphs have the same set of vertices, the same q-ports (q ∈ Q), and the same
edges between two vertices of x1 or two vertices of x2. On the other hand,
g1,~z(x1) ⊕ g2,~z(x2) misses the edges of h(x1 ⊕ x2) that connect a vertex of x1
with a vertex of x2.

23

edge and ψ2,1,~z

edge (v, w) and ψ2,1,~z

These edges are captured by the formulas ψ1,2,~z

edge . Now, if v is a
vertex of x1 and w is a vertex of x2, we already observed that the truth values
of ψ1,2,~z
edge (w, v) are entirely determined by the quantiﬁer-free
formulas with one free variable satisﬁed by v in x1 and by w in x2: that is, they
are entirely determined by the (unique) index k + 1 ≤ n ≤ ℓ such that θn(v)
and by the (unique) index ℓ + 1 ≤ n ≤ m such that θn(w). In other words,
ψ1,2,~z
edge (a, b) and ψ2,1,~z
edge (b, a) are equivalent to disjunctions of conjunctions of the
form

θn(a) ∧ θu(b)

for some k + 1 ≤ n ≤ ℓ and ℓ + 1 ≤ u ≤ m.

Thus the edges in h(x1 ⊕ x2) from a vertex of x1 to a vertex of x2 can be
created from g1,~z(x1) ⊕ g2,~z(x2) by applying repeatedly the operations (in VR)
of the form addn,u such that n ∈ [k + 1, ℓ], θn ∧ θu is a disjunct of ψ1,2,~z
edge .

Similarly, the edges in h(x1 ⊕ x2) from a vertex of x2 to a vertex of x1 can
be created from g1,~z(x1) ⊕ g2,~z(x2) by applying the appropriate operations of
the form addu,n. The last operation consists in forgetting the auxiliary ports
numbered k +1 to m, that is, in applying the operation mdfD, with D = {(q, q) |
⊓⊔
q ∈ Q}.

4.3 Recognizable sets of graphs with ports

In this section, we consider diﬀerent notions of recognizability that can be used
for sets of graphs with ports. Let L ⊆ GP(P ). Then L can be VR-recognizable,
as a subset of the VR-algebra GP. It can also be S-recognizable, as a subset
of the S-algebra StS since GP(P ) = StS(EP ). Finally, we introduce another
signature, written VR+, on GP:
it is obtained from VR by adding all the qfd
operations between the sorts of GP.

Theorem 4.5 Let P be a ﬁnite subset of N and let L be a subset of GP(P ).
The following properties are equivalent:

1 L is S-recognizable;

2 L is VR+-recognizable;

3 L is VR-recognizable;

Proof. Since the operations of VR are operations of VR+, and the operations
of VR+ are operations of S, it follows from Proposition 2.1 that (1) implies (2),
and (2) implies (3). Thus, we only need to verify that (3) implies (1).

We use Lemma 2.5, with F = VR, S = GP, G = S, T = StS, and ζ the
type congruence (see Section 3.3), which relates structures with sources of the
same sort, provided they satisfy the same quantiﬁer-free formulas. We use the
collection H of sets H(R,C),P of unary qfd operations from StS(R, C) to GP(P ).
Let L be a VR-recognizable subset of GP(P ) and let ≡ be a locally ﬁnite
VR-congruence on GP such that L is a union of ≡-classes. Since ζ is a locally
ﬁnite S-congruence on StS (Proposition 3.9), its restriction to GP is also a

24

locally ﬁnite VR-congruence; and the intersection of ≡ and ζ is a locally ﬁnite
VR-congruence on GP which saturates L. Thus we can assume, without loss of
generality, that ≡-equivalent elements of GP are also ζ-equivalent.

Next we consider the equivalence relation ≈ on StS deﬁned as in Lemma 2.5.
Note that the identity of GP(P ) belongs to H(EP ,∅),P , so that ≈-equivalent ele-
ments of GP(P ) = StS(EP , ∅) are also ≡-equivalent. In particular, ≈ saturates
L and it suﬃces to show that ≈ is locally ﬁnite and is a S-congruence. In view of
Lemma 2.5, it is enough to verify that H satisﬁes the assumptions of Lemma 2.3
and 2.4.

We ﬁrst verify the hypothesis of Lemma 2.3. Let g be an operation of S:
either g is a unary qfd operation or g = ⊕. In the latter case, Proposition 4.4
states precisely that the required property holds.

If g is a qfd operation of type (R1, C1) → (R, C), and h ∈ H(R,C),P , then
h ◦ g is a qfd operation (Lemma 3.7) and hence, h1 = h ◦ g ∈ H(R1,C1),P . Now
letting f be the identity mapping of GP(P ), we ﬁnd that h(g(x)) = f (h1(x)) as
required. In this case, h1 and f do not depend on the ζ-class of x.

Next, we turn to the veriﬁcation of the hypothesis of Lemma 2.4. Let ϕ1,
. . . , ϕk be an enumeration of the elements of QF (R, C, {x}) and let χ1, . . . , χℓ
be an enumeration of the elements of QF (R, C, {x, y}).

Thus, a qfd operation scheme from StS(R, C) into GP(Q) consists in the
choice of a formula δ = ϕi0 (1 ≤ i0 ≤ k), a formula ψedge = χj (1 ≤ j ≤ ℓ), a
sequence of formulas ϕi1 , . . . , ϕir (1 ≤ i1 < . . . < ir ≤ k), and a partition of Q
as Q = Q1 ∪ · · · ∪ Qr: if q ∈ Qj, then ψq = ϕij . (If Q = ∅, then r = 0.)

Let us now consider two unary qfd operations g: StS(R, C) → GP(Q) and
g′: StS(R, C) → GP(Q′), associated with the same choice of values i0, j and
i1 < . . . < ir. Let Q = Q1 ∪· · ·∪Qr and Q′ = Q′
r be the corresponding
partitions of Q and Q′. Finally let π, π0, π1, . . . , πr be the following operations
in the signature VR. These operations have the common particularity to not
alter the graph structure, and to modify only the port predicates.

1 ∪· · ·∪Q′

The mapping π0 shifts every port index of an element of GP(Q) by m =
max(Q′), to yield a graph with ports in Q + m, whose port names do not
intersect Q′. We let Rh = Qh + m for 1 ≤ h ≤ r.

For 1 ≤ h ≤ r, πh = mdfDh where

Dh = {(a, a) | a ∈

[
i<h

Ri} ∪ (Rh × Q′

h).

Q′

i ∪

[
i>h
1 + · · ·+ Q′

1 + · · · + Q′

Thus πh turns a graph with ports in Q′
graph with ports in Q′
Si<h Q′
i ∪
set, the same edge relation, the same q-ports for each q ∈
and with each r-port (r ∈ Rh) turned into a q-port for each q ∈ Q′
h.

h−1 + Rh + Rh+1 + · · · Rr into a
h + Rh+1 + · · · Rr, with the same vertex
Si>h Ri,
It is now an easy veriﬁcation that, if π = πr ◦· · ·◦π1◦π0, then g′(x) = π(g(x))
for each x ∈ StS(R, C). Thus the quasi-order ≤(R,C) deﬁned in Lemma 2.4 is
⊓⊔
in fact a ﬁnite index equivalence relation, and this concludes the proof.

h−1 + Q′

Remark 4.6 This actually proves also that we get the same recognizable sets
of graphs with ports, if we consider GP(Q) as a domain of sort Q in the alge-

25

bra of structures without sources — which consists of the domains StS(R, ∅)
equipped with the operations of S between them. If we were only interested
in the equivalence of this recognizability with VR- and VR+-recognizability (or
just the equivalence between VR- and VR+-recognizability), we could do with
Lemmas 2.3 and 2.4 instead of Lemma 2.5, and with a simpler version of Propo-
⊓⊔
sition 4.4, making no reference to ζ.

4.4 Variants of the algebra of graphs with ports

The ﬁrst variant considered here replaces the signature VR by a smaller sig-
nature, which we will see is equivalent to VR in terms of recognizability. The
second one concerns a certain class of graphs with ports, and is central in the
deﬁnition of the clique-width of a ﬁnite graph.

4.4.1 A variant of VR on GP

In Section 4.3, we exhibited signatures larger than VR, for which all the VR-
recognizable sets of graphs with ports are recognizable: namely the signature
VR+ on GP and the signature S on the wider algebra StS.
In contrast, we
exhibit in this section a smaller signature (in fact, a signature consisting of
VR-derived operations) which does not create new recognizable subsets.

The basic idea behind the deﬁnition of this new signature is the following:
when we evaluate a VR-term t of the form addp,q(t′), then we add edges from
each p-port of G′, the value of t′, to each of its q-ports. It may happen that
some edges from a p-port to a q-port already exist in G′. In this case, we do
not add a parallel edge since we are dealing with simple graphs. Thus the term
t presents a form of redundancy, since some of its edges may be, in some sense,
deﬁned twice.

For disjoint sets of port labels P and Q, we denote by J(P, Q) the set of
VR-derived unary operations deﬁned by terms of the form f1(f2(. . . (fn(x)) . . .)),
where the fi are of the forms addp,q or addq,p for p in P and q in Q. Since the
operations addp,q are idempotent and commute with one another, an operation
in J(P, Q) is completely described by a subset of (P × Q) ∪ (Q × P ). Thus
J(P, Q) is ﬁnite, although one can write inﬁnitely many terms specifying its
elements. For each element J ∈ J(P, Q), we let ⊗J denote the binary operation
deﬁned, for G ∈ GP(P ) and H ∈ GP(Q), by G ⊗J H = J(G ⊕ H).

We observe that in the evaluation of a term of the form t⊗J t′, the application
of ⊗J does not recreate edges that already exist in G, the value of t, or in G′, the
value of t′ since the addp,q operations forming ⊗J add edges between the disjoint
graphs G and G′ (because p and q are not port labels of the same argument
graphs).

Now the signature NLC consists of the operations ⊗J as above, the unary
qfd operations of the form fgp and renp→q as deﬁned in Remark 4.1, and the
constants p and ploop as in VR. We denote by GP NLC the NLC-algebra of graphs
with ports.

26

Remark 4.7 The notation NLC refers to a very similar algebra used by Wanke
⊓⊔
[44].

Example 4.8 We have in fact already encountered NLC-operations and NLC-
derived operations.

The VR-derived operation f~z whose existence is proved in Proposition 4.4
is actually NLC-derived. Consider indeed the last paragraphs of the proof of
that proposition: the operation f~z is obtained by ﬁrst composing operations
of the form addn,u and addu,n, where the pairs (n, u) lie in a certain subset of
[k+1, ℓ]×[ℓ+1, m] and the pairs (u, n) lie in another subset of [ℓ+1, m]×[k+1, ℓ],
and then composing operations of the form fgp.

One can also check that the operations π0, . . . , πr at the end of the proof of
⊓⊔

Theorem 4.5 are NLC-derived.

Proposition 4.9 Let P be a ﬁnite subset of N and let L be a subset of GP(P ).
Then L is VR-recognizable if and only if L is NLC-recognizable.

Proof. The proof is a simple extension of the proof of Theorem 4.5.

Since the operations of NLC are VR-derived, every VR-recognizable subset
of GP is NLC-recognizable. For the converse, we observe that the proof that (1)
implies (3) in Theorem 4.5 can be modiﬁed to show that an NLC-recognizable
set of GP is S-recognizable.

Again, we rely on Lemma 2.5, but now with F = NLC, S = GP, and G, T ,

ζ and H as in Theorem 4.5.

In order to justify the fact that the arguments used in the proof of Theo-
rem 4.5 are also valid with these assumptions, we refer to Example 4.8. Indeed
this example shows two things: on one hand, the operation f~z in Proposition 4.4
is in fact NLC-derived, so that the ﬁrst hypothesis of Lemma 2.5 is satisﬁed by
this new choice of F and S. On the other hand the ﬁniteness hypothesis of
Lemma 2.4 is also satisﬁed with this new value of F = NLC. This completes
⊓⊔
the proof.

4.4.2 Graphs whose port labels partition the vertex set

In certain contexts, and in particular in the deﬁnition of the clique-width of a
graph (see Remark 4.11 below), one needs to consider graphs with ports where
port labels partition the vertex set. More precisely, for each set of port labels P ,
let GP π(P ) be the set of elements of GP(P ) such that each vertex is a port, and
no vertex is both a p-port and a q-port for p 6= q. Let also GP π = (GP π(P )).

Note that GP π is preserved by the operations of the form ⊕, addp,q and
renp→q. These operations form the signature VRπ, and GP π is a VRπ-algebra.

Remark 4.10 The operation addp,q is written αp,q in [19].

⊓⊔

27

Remark 4.11 The clique-width of a ﬁnite graph G, denoted by cwd(G), is
deﬁned as the smallest cardinality of a set P such that G is the value of a
(ﬁnite) VRπ-term using a set P of port labels, see [19, 7].

For algorithmic applications [20], it is useful to have eﬃcient recognition
algorithms for classes of graphs of clique-width at most k. At the moment we
⊓⊔
only know that this problem is N P . It is polynomial for k ≤ 3, see [7].

Proposition 4.12 Let L be a subset of GP π(P ). Then L is VRπ-recognizable
if and only if L is VR-recognizable.

Proof. Since VRπ consists of operations in VR, every locally ﬁnite VR-cong-
ruence on GP induces a locally ﬁnite VRπ-congruence on GP π. In particular, if
L is VR-recognizable, and hence is saturated by a locally ﬁnite VR-congruence
on GP, then L is saturated by a locally ﬁnite VRπ-congruence on GP π, and
hence L is VRπ-recognizable.

To prove the converse, we ﬁrst introduce the mapping σ: GP → GP π deﬁned
as follows. If G ∈ GP(P ), then σ(G) is the graph in GP π(2P ) with the same
set of vertices and the same edge relation as G, and such that for each vertex
v and each X ⊆ P , v is an X-port in σ(G) if and only if X is the set of p ∈ P
such that v is a p-port in G. We say that a port label p is void in G if there are
no p-ports in G.

Now let us assume that L is VRπ-recognizable, and let ≡ be a locally ﬁnite
congruence on GP π saturating it. If G, H ∈ GP(P ), we let G ∼ H if σ(G) and
σ(H) have the same non-void port labels, and σ(G) ≡ σ(H). It is immediately
veriﬁed that ∼ is a locally ﬁnite equivalence relation.

We now verify that ∼ is a VR-congruence. If G ∈ GP(P ) and H ∈ GP(Q),
it is easily seen that σ(G ⊕ H) = σ(G) ⊕ σ(H). If p, q ∈ P , then σ(addp,q(G)) =
f (σ(G)) where f is the composition of the operations addX,Y for each X, Y ⊆ P
such that p ∈ X and q ∈ Y . Finally, one can verify that if D ⊆ P × Q, then
σ(mdfD(G)) = g(σ(G)) where g is the composition of the operations renX→Y ,
where X ⊆ P , Y ⊆ Q and Y = D−1(X) = {q ∈ Q | (p, q) ∈ D for some p ∈ P }.
It is a routine task to derive from these observations the fact that ∼ is a
VR-congruence. We now need to verify that ∼ saturates L. Let G ∈ L and
G ∼ H. In particular, G ∈ GP π, so that the non-void port labels of σ(G) are
exactly the sets {p} where p is a non-void port label of G. Since σ(G) and σ(H)
have the same non-void port labels, H is also in GP π. Moreover, if h is the
composition of the operations ren{p}→p (p non-void in G), then G = h(σ(G))
and H = h(σ(H)). Since h is VRπ-derived, it follows that G ≡ H, and hence
⊓⊔
H ∈ L. This concludes the proof.

5 The algebra of graphs with sources

Recall that we call graphs with sources the elements of StS of sort (E, C), where
E = {edge} and C is some ﬁnite set of source labels, and that we write GS(C)
for StS(E, C) (see Section 3.1).

28

5.1 The signature HR

The disjoint union ⊕ and the operations of the form srcrena→b, srcfga and fusa,b
(deﬁned in Example 3.4) preserve graphs with sources. We denote by HR the
signature consisting of all these operations, so GS is an HR-algebra.

We note the following properties of HR-recognizability.

Proposition 5.1 Let C be a ﬁnite set of source labels. Every S-recognizable
subset of StS(E, C) is HR-recognizable.

Proof. This is a simple consequence of Proposition 2.1 and of the observation
given above that the operations of HR are also operations of S.
⊓⊔

Note that the class Graph of graphs, deﬁned in Section 3.1, is equal to GP(∅)
as well as to GS(∅) = StS(E). Thus VR-recognizability and HR-recognizability
are properties of subsets of Graph.

Corollary 5.2 Let L be a set of graphs (a subset of Graph).
recognizable, then it is HR-recognizable.

If L is VR-

Proof. This follows immediately from Proposition 5.1 and Theorem 4.5.

⊓⊔

Remark 5.3 Intuitively, the VR-operations are more powerful than the HR-
operations (every HR-context-free set of simple graphs is VR-context-free but
the converse is not true, Courcelle [14]), but the HR-operations are not among
the VR-operations, nor are they derived from them.
⊓⊔

We will see in Sections 6.1 and 6.2 suﬃcient conditions for HR-recognizable
sets to be VR-recognizable, and in Section 6.3, examples of HR-recognizable sets
which are not VR-recognizable.

5.2 Variants of the algebra of graphs with sources

We ﬁnd in the literature a number of variants of the signature HR or of the
algebra GS. We now discuss these diﬀerent variants, to verify that they do not
introduce artefacts from the point of view of recognizability.

5.2.1 The signature HRk

Let HRk denote the signature on GS obtained by substituting the parallel com-
position k for ⊕ (see Section 3.5.1). With the same proof as Proposition 3.15,
we get the following result.

Proposition 5.4 Let L be a subset of GS. Then L is HR-recognizable if and
only if it is HRk-recognizable.

29

5.2.2 Source-separated graphs

As in Section 3.5.2, we now discuss the class GSsep of source separated graphs.
The operations of HR all preserve source separation, except for fusa,b, but we
deﬁned in Example 3.16 the operation fusa→b = srcfga ◦ fusa,b which does. Let
HRsep be the signature on GSsep consisting of ⊕ and the qfd unary operations of
the form srcrena→b, srcfga and fusa→b.

Proposition 5.5 Let L be a subset of GSsep. Then L is HR-recognizable if and
only if it is HRsep-recognizable.

Proof. Since HRsep consists only of HR-derived operations, every HR-recog-
nizable set subset of GSsep is also HRsep-recognizable.

The proof of the converse is a variant of the proof of Theorem 3.18. First we
note that the type relation ζ (see Section 3.3) is also an HR-congruence on GS.
We use the same mapping h deﬁned in the proof of Theorem 3.18, that maps a
graph with sources S ∈ GS(C) to a source-separated graph h(S) ∈ GSsep(C) by
splitting sources that were identiﬁed in S. We refer to that proof for notation
used here.

If L is an HRsep-recognizable subset of GSsep and ≡ is a locally ﬁnite HRsep-
congruence recognizing it, we deﬁne a relation ∼ on GS as follows. If S, T ∈
GS(C), we say that S ∼ T if ζ(S) = ζ(T ) and h(S) ≡ h(T ). As in the proof of
Theorem 3.18, ∼ is easily seen to be a locally ﬁnite equivalence relation. It is
also easily seen that ∼ is preserved under the HRsep-operation ⊕.

We now need to verify that if S ∼ T ∈ GS(C) and g is one of the unary
operations of HRsep deﬁned on GS(C), then g(S) ∼ g(T ). Again, Proposi-
tion 3.9 shows that ζ(g(ζ(S))) = ζ(g(ζ(T ))) and we want to show that h(g(S)) ≡
h(g(T )). The graphs S and T are ﬁxed for the rest of this proof. We write h0,
C0 and C1 for hS

0 and CS
1 .

0 , CS

As in the proof of Theorem 3.18, it suﬃces to construct an HRsep-derived op-
eration k, depending on g and ζ(S), such that h(g(S)) = k(h(S)) and h(g(T )) =
k(h(T )). There is no reason why the operation k constructed in the proof of
Theorem 3.18 should be HRsep-derived, but the operations g considered here,
namely srcrena→b, srcfga and fusa→b are simple enough that we can directly
construct a suitable k in each case.

If g = srcrena→b Then g is deﬁned on GS(C) (where a ∈ C and b 6∈ C) and
its range is GS(C \ {a} ∪ {b}). One veriﬁes that h(srcrena→b(S)) is equal to:

• srcrena→b(h(S)) if a ∈ C1 and b > h0(a);

• srcrena→h0(a)(srcrenh0(a)→b(h(S))) if a ∈ C1 and b < h0(a);

• srcrena→b(h(S)) if a ∈ C0 and b < c for every c ∈ C1 such that h0(c) = a;

• srcrenc→b(srcrenb→c(h(S))) if a ∈ C0 and b > c = min{d ∈ C1 | h0(d) = a.

30

If g = srcfga Then g is deﬁned on GS(C) (where a ∈ C) and its range is
GS(C \ a). One veriﬁes that h(srcfga(S)) is equal to:

• fusa→h0(a)(h(S)) if a ∈ C1;

• fusa→c if a ∈ C0, h0

−1(a) 6= ∅ and c = min{h0

−1(a)};

• srcfga(h(S)) if a ∈ C0 and h0

−1(a) = ∅.

If g = fusa→b Then g is deﬁned on GS(C) (where a 6= b ∈ C) and its range is
GS(C \ a). One veriﬁes that h(fusa→b(S)) is equal to:

• srcrena→h0(a)(fush0(a)→h0(b)(h(S))) if a ∈ C1 and h0(b) < h0(a);

• srcrena→h0(b)(fush0(b)→h0(a)(h(S))) if a ∈ C1 and h0(b) > h0(a);

• srcrena→h0(a)(h(S)) if a ∈ C1 and h0(b) = h0(a);

• fusa→h0(b)(h(S)) if a ∈ C0 and a > h0(b);

• srcrena→c(fush0(b)→a(h(S))) if a ∈ C0, and c = min{h0(b), h−1

0 (a)}, and

a < h0(b);

• srcrena→c(fusa→c(h(S))) if a ∈ C0, a = h0(b) and c = min{d ∈ C1 |

h0(d) = a}.

This concludes the proof.

⊓⊔

Again with the same proof as for Proposition 3.15, we can show that the
operation ⊕ can be replaced by k in the signature HRsep – yielding the signature
HRsep,k.

Proposition 5.6 Let L be a subset of GSsep. Then L is HRsep-recognizable if
and only if it is HRsep,k-recognizable.

5.2.3 Other variants

The equivalence between HRsep,k- and HRk-recognizability for a set of source-
separated graphs – a consequence of Propositions 5.4, 5.5 and 5.6 – was already
established by Courcelle in [10] for graphs with multi-edges (see Section 7). In
the same paper, Courcelle established the equivalence between HRsep- and B-
recognizability for several variants B of the signature HR, which we now describe.
We refer to [10] for the proofs.

For each ﬁnite set C of source labels, let srcfgall be the composition of the
operations srcfgc for each c ∈ C (in any order). Let also ✷C be the follow-
if G, H ∈ GSsep(C), then
ing binary operation on GSsep, of type (C, C) → ∅:
G✷C H = srcfgall(G k H): G ✷C H is obtained by ﬁrst taking the parallel
composition G k H, and then forgetting all source labels.

Let CS be the signature on GSsep, which consists only of the ✷C operations.

31

Let HRfg be the derived signature of HRk, which consists of the operations

srcfgall and k.

Let HRren be the subsignature of HRk, which consists of the operations

srcrenp→q and k.
Let HRren

sep be the subsignature of HRsep,k, which consists of the operations k

and those operations srcrenp→q which preserve source separation.

The following result is a compilation of [10, Section 4].

Proposition 5.7 If L ⊆ GS, then L is HR-recognizable if and only if L is
HRren-recognizable.

If L ⊆ GSsep, then L is HRsep-recognizable if and only if L is HRren
If L ⊆ Graph, the following are equivalent:

sep-recognizable.

• L is HR-recognizable;

• L is CS-recognizable;

• L is HRfg-recognizable.

Remark 5.8 The notation CS refers to the notion of fully cutset-regular sets
of graphs, introduced by Abrahamson and Fellows [1]. Full cutset-regularity is
⊓⊔
equivalent to CS-recognizability.

In [10], Courcelle also shows a number of closure properties of the class of
HRsep-recognizable sets of source-separated graphs with sources. In particular,
it is shown that this class contains all singletons and it is closed under the
operations of HRsep [10, Section 6].

Finally Courcelle shows the following result [10, Theorem 6.7].

Proposition 5.9 Let L ∈ GS(C). Then L is HR-recognizable if and only if
srcfgall(L) is HR-recognizable.

6 Finiteness conditions ensuring that HR- and

VR-recognizability coincide

We saw that a VR-recognizable set of graphs is always HR-recognizable (Corol-
lary 5.2). The converse does not hold in general, as we discuss in Section 6.3. We
ﬁrst explore structural conditions on graphs, which are suﬃcient to guarantee
that an HR-recognizable set of graphs is also VR-recognizable.

−→
K n,n be the directed complete bipartite graph with n + n vertices. A
−→
K n,n if it has no subgraph isomorphic to

directed graph G ∈ Graph is without
−→
K n,n. The main result in this section is the following.

Let

Theorem 6.1 Let n be an integer. An HR-recognizable set of graphs without
−→
K n,n is VR-recognizable.

32

This theorem is proved in Section 6.1, and some of its corollaries are discussed

in Section 6.2.

Note that results similar to Corollary 5.2 and Theorem 6.1 hold for VR- and
HR-equational sets of graphs. As explained in the introduction, such sets are
exactly the context-free sets of graphs, formally speciﬁed in terms of recursive
sets of equations using the operations of VR and HR respectively. Speciﬁcally,
the following results are known to hold:

• every HR-equational set of simple directed graphs is VR-equational (Cour-

celle [15]);

• if a VR-equational set of directed graphs is without

−→
K n,n for some n, then
it is HR-equational (by the main theorem in Courcelle [14] and Lemma 6.6
below).

Thus the same combinatorial condition is suﬃcient to guarantee the equiv-
alence between VR- and HR-recognizability, as well as between VR- and HR-
equationality. A further similar result concerning monadic second-order deﬁn-
ability and using a stronger combinatorial property will be discussed in Sec-
tion 6.4.

6.1 Proof of Theorem 6.1

We ﬁrst record the following observation.

Lemma 6.2 Let G be a directed graph and let x, y be two vertices of G that are
not adjacent, and such that there is no vertex z such that both (x, z) and (y, z)
(resp. both (z, x) and (z, y)) are edges. Let H be obtained from G by identifying
x and y. If G contains

−→
K m,m as a subgraph, then so does H.

−→
Proof. Let K be a subgraph of G isomorphic to
K m,m. From the hypothesis,
the vertices x and y are not both in K. It follows that K is still isomorphic to
⊓⊔
a subgraph of H.

The proof of Theorem 6.1 will proceed as follows. We consider an HR-
−→
K n,n and we denote by m the largest
−→
K m,m is a subgraph of a graph in L. Such an integer exists

recognizable set L of ﬁnite graphs without
integer such that
by hypothesis.

Since we are talking about source-less graphs, the set L is HRsep-recognizable
by Proposition 5.5, and we consider a locally ﬁnite HRsep-congruence ≡ satu-
rating L. We will deﬁne a locally ﬁnite NLC-congruence ∼ on GP that also
saturates L. By Proposition 4.9, this suﬃces to show that L is VR-recognizable.
The deﬁnition of ∼ makes use of the notion of expansion of a graph, deﬁned
below.

Note that the following deﬁnitions depend on the integer m, even though

terminology and notation do not make this dependence explicit.

33

Small and large port labels and formulas Let G ∈ GP(P ) be a graph with
ports. If p ∈ P , we denote by pG the set of p-ports of G. We say that a port label
p is void in G if pG is empty, we say that p is small in G if 1 ≤ card(pG) ≤ m
and that p is large in G if card(pG) > m.

Observe that if the port labels p and q are both large in G, then addp,q(G)

contains

−→
K m+1,m+1 as a subgraph.

Moreover, if p is large in G, if r1, . . . , rk are small in G, let

H = addp,r1addp,r2 · · · addp,rk (G).

−→
For i = 1, . . . , k, let ni = card(riG). If H does not contain
K m+1,m+1, then we
must have n1 + · · · + nk ≤ m. If G already contains edges from the p-ports to
other vertices, then n1 + · · · + nk < m. The notion of expansion below will make
it possible to handle this sort of complicated situation (see Example 6.3 below).
Let us say that a closed ﬁrst-order formula is small if it has quantiﬁer-depth
−→
K m+1,m+1

at most 2m + 2. Note that the existence of a subgraph isomorphic to
can be expressed by a ﬁrst-order formula of quantiﬁer-depth 2m + 2.

Expansions We will deﬁne supergraphs of G ∈ GP(P ) called expansions, that
contain information relevant to the distribution of small and large port labels,
and where ports are represented by sources. Furthermore, it will be possible
−→
to simulate an NLC-operation on G that does not create
K m+1,m+1 subgraphs
by HR-operations on expansions of G. These expansions will then be used to
transform the HRsep-congruence ≡ into an NLC-congruence ∼.

Furthermore, we will deﬁne ∼ in such a way that two equivalent graphs

satisfy the same small ﬁrst-order formulas.

We now give formal deﬁnitions. For each port label p, we deﬁne a set C(p)

of source labels,

C(p) = {in(p, i), out(p, i), s(p, i) | 1 ≤ i ≤ m}.

If P is a set of port labels, C(P ) denotes the union of the C(p), for p in P .

Let G ∈ GP(P ) be a graph with ports, let C ⊆ C(P ), and let ¯G be a graph
in GSsep(C). We say that ¯G is an expansion of G if the following conditions
hold:

(1) ¯G has no subgraph isomorphic to

−→
K m+1,m+1.

(2) Except for the labeling of ports and sources, G is a subgraph of ¯G. The
sources of ¯G, and its vertices and edges not in G, are speciﬁed by Condi-
tions (3) and (4).

(3) If p is small in G, then each p-port of G is an s(p, i)-source of ¯G for some
integer i ≤ m. Diﬀerent p-ports are of course labelled by diﬀerent source
labels. There are no in(p, j)- or out(p, j)-sources.

(4) If p is large in G, then there may be vertices of ¯G that are not in G, with
source labels of the form in(p, i) or out(p, i) for some i ≤ m. Moreover,

34

there is an edge in ¯G from each vertex of pG to each in(p, i)-source, and
from each out(p, i)-source to each vertex in pG. There are no s(p, j)-
sources.

In particular, G may have several diﬀerent expansions, but it has only a
ﬁnite number of expansions (up to isomorphism). This number is bounded by a
function depending on m and the cardinality of P . Indeed, for each small port
label p, there is only a bounded number of ways to make p-ports into s(p, i)-
sources (see (3)), and for each large port label p, there is a bounded number of
ways to create in(p, i)- and out(p, i)-sources (see (4)).

Example 6.3 Let m = 2, and let G be a graph with port labels p, q, r. Suppose
that G has 4 p-ports, 2 q-ports and 1 r-port, so that p is large, and q, r are
small in G, see Figure 1. Then in any expansion of G, every q- and r-port
will be a source, say labeled by s(q, 1), s(q, 2) and s(r, 2) (there is only one
s(r, i)-source, but it is not required that these sources should be labeled with
consecutive numbers starting at 1).

out(p, 2)

in(p, 1)

in(p, 2)

p

p

p

p

x

H

G

q

q

s(q, 1)

s(q, 2)

r

s(r, 2)

Figure 1: H is an expansion of G

Moreover, an expansion of G may have up to two new vertices that are
in(p, j)-sources, and at most one out(p, j)-source. Say, an expansion H could
have new vertices as in(p, 1)- and in(p, 2)-sources, with edges from each of the
4 p-ports to each in(p, j)-source; and it could have a new vertex as a, say,
out(p, 2)-source, with edges from that vertex to each of the p-ports.

Note that if G has a vertex x with an edge from x to at least 3 p-sources,
then an expansion cannot have 2 out(p, j)-sources: otherwise it would contain
⊓⊔
a copy of

−→
K 3,3, which is not allowed for an expansion.

Remark 6.4 It is not always the case that G is determined by each of its
expansions ¯G. If p is large in G but ¯G has no in(p, i)- or out(p, i)-sources, then
⊓⊔
it is not possible to determine which of its vertices are p-ports.

35

Construction of an NLC-congruence from an HRsep-congruence Let ≡
be a locally ﬁnite HRsep-congruence saturating L. We deﬁne a relation ∼ on GP
as follows. For G and G′ in GP(P ) we let G ∼ G′ if and only if

(a) either G and G′ both contain

−→
K m+1,m+1 as a subgraph, or neither does

and in that case, the following two conditions hold:

(b) G and G′ satisfy the same small ﬁrst-order formulas (i.e., with quantiﬁer-

depth at most 2m + 2) on graphs with ports.

(c) for every expansion ¯G of G, there exists an expansion ¯G′ of G′ such that
¯G ≡ ¯G′ and ¯G and ¯G′ satisfy the same small ﬁrst-order formulas on
graphs with sources (we say that ¯G and ¯G′ are equivalent expansions);
and conversely, for every expansion ¯G′ of G′ there exists an expansion ¯G
of G equivalent to ¯G′.

Note that Condition (b) implies that G and G′ have the same void, small
and large port labels, and Condition (c) implies that ¯G and ¯G′ have the same
source labels.

The relation ∼ is clearly an equivalence relation on each set GP(P ). It has
ﬁnitely many classes on each GP(P ) since a ﬁnite graph has a uniformly bounded
number of expansions (up to isomorphism), the HRsep-congruence ≡ is locally
ﬁnite, and there are ﬁnitely many ﬁrst-order formulas of each quantiﬁer-depth
on graphs with sources in a subset of C(P ).
Now a graph without ports and without

−→
K m+1,m+1 has a unique expansion:
−→
K m+1,m+1, the

It follows that, for graphs without ports and without

itself.
equivalences ≡ and ∼ coincide. In particular, ∼ saturates L since ≡ does.

It remains to prove that ∼ is an NLC-congruence. Recall that the signature

NLC consists of the operations of the form fgp, renp→q and ⊗J .

The port forgetting operation We ﬁrst consider the operation fgp. We
consider G, G′ with G ∼ G′ and we want to prove that H ∼ H ′, where H =
fgp(G) and H ′ = fgp(G′).

First of all, the underlying graphs of G and H (resp. G′ and H ′) are identical,
−→
K m+1,m+1 if and only if so do H and H ′. If this is
so that G and G′ contain
the case, then G ∼ G′ and H ∼ H ′. We now exclude this case and assume that
−→
G and G′ are without
K m+1,m+1. Note also that if p is void in G, then it is in
G′ as well, and we have H = G, H ′ = G′, so that H ∼ H ′. We now assume
that p is not void in G.

It is an immediate consequence of Theorem 3.12 that H and H ′ satisfy the
same small ﬁrst-order formulas on graphs with ports, so Condition (b) is veriﬁed.
We now consider Condition (c). Let ¯H be an expansion of H. We will show
that there exists an expansion ¯G of G and a unary HRsep-term t such that ¯H =
t( ¯G). Since G ∼ G′, there exists an equivalent expansion ¯G′ of G′, and t( ¯G′) will
be the desired expansion of H ′. Using the fact that ≡ is an HRsep-congruence
and Theorem 3.12, we will have H ∼ H ′ as expected.

36

If p is large in G, the situation is particularly simple: ¯H is also an expansion
of G, so we can choose t to represent the identity. If ¯G′ is an expansion of G′,
equivalent to ¯H, then ¯G′ does not use source labels of the form s(p, i), in(p, i)
or out(p, i), so ¯G′ is also an expansion of H ′.

If p is small in G, let ¯G be a graph with source obtained from ¯H by letting
each p-port of G be an s(p, i)-source (where distinct source labels are used for
distinct p-ports). Then ¯G is an expansion of G, and ¯H = t( ¯G) where t is the
composition of the operations srcfgs(p,i) (1 ≤ i ≤ m). Using the deﬁnition of ∼,
there exists an expansion ¯G′ of G′ which is equivalent to ¯G, and we only need
to verify that ¯H ′ = t( ¯G′) is an expansion of H ′. The only point to check here
is the fact that H ′ is a subgraph of ¯H ′: this follows from the facts that G is a
subgraph of ¯G and the operations t and fgp do not change the underlying graph
structures.

The renaming operation We now consider the operation renp→q. Let G, G′
with G ∼ G′: as with the port forgetting operation, we want to prove that
H ∼ H ′ where H = renp→q(G) and H ′ = renp→q(G′). As above, we can reduce
−→
the proof to the case where neither G nor G′ contains
K m+1,m+1, and where
p is not void in G (if p is void in G, then H = G and H ′ = G′). Moreover,
Condition (b) follows from Theorem 3.12.

We consider Condition (c), following the same strategy as above. Let ¯H be

an expansion of H.

If q is void in G, then the transformation renp→q is a reversible renaming,
that is, G = renq→p(H). Moreover, if t is the composition of the operations
of the form srcrens(p,i)→s(q,i), srcrenin(p,i)→in(q,i) and srcrenout(p,i)→out(q,i), and
if t′ is the composition of the operations srcrens(q,i)→s(p,i), srcrenin(q,i)→in(p,i)
and srcrenout(q,i)→out(p,i), then ¯G = t′( ¯H) is an expansion of G, ¯H = t( ¯G).
Moreover, if ¯G′ is an expansion of G′, equivalent to ¯G, then ¯H ′ = t( ¯G′) is an
expansion of H ′.

We now assume that q is not void in G. We need to consider several cases.

Case 1. p and q are both large in G. Then p is void and q is large in H.

In order to build the desired ¯G, we split each in(q, i)-source of ¯H into an
in(p, i)-source and an in(q, i)-source. The in(p, i)-source is linked by incoming
edges to all p-ports of G, and the in(q, i)-source is linked similarly to all q-ports.
In the same fashion, we split each out(q, i)-source of ¯H into an out(p, i)-source
and an out(q, i)-source linked by ougoing edges to all p-ports of G and to all
q-ports respectively. The term t such that ¯H = t( ¯G) is the composition of the
operations fusin(p,i)→in(q,i) and fusout(p,i)→out(q,i).

The graph ¯G does not contain

−→
K m+1,m+1, since ¯H does not (by Lemma 6.2).
Hence ¯G is an expansion of G. Let now ¯G′ be an expansion of G′ equivalent to
¯G, and let ¯H ′ = t( ¯G′). It is easily veriﬁed that ¯H ′ is an expansion of H ′, and
as above, it follows that H ∼ H ′.

Case 2. p is small and q is large in G.

37

In order to build ¯G from ¯H, we make the p-ports of G into s(p, i)-sources, we
delete the edges between the in(q, i)- and the out(q, i)-sources and the p-ports
of G. The term t which must do the opposite (that is, construct ¯H from ¯G) is a
composition of source forgetting operations and of additions of new edges. More
precisely, for each i, j such that s(p, i) and in(q, j) are source labels in ¯G, we use
the operation Z 7−→ Z ⊕ (α −→ ω), where (α −→ ω) is the 2-vertex, 2-source,
1-edge graph, followed by the operations fusα→s(p,i) and fusω→in(q,j). We then
apply similar operations to create edges from the out(q, j)- to the s(p, i)-sources.
And we ﬁnally apply the operations srcfgs(p,i).

The graph ¯G is a subgraph of ¯H (up to source labels), so ¯G does not contain
−→
K m+1,m+1, and hence it is an expansion of G. The proof continues as in the
previous case.

Case 3. q is small and p is large in G.

To build ¯G from ¯H, we make the q-ports of G into s(q, i)-sources, we delete
the edges between the in(p, i)-sources or the out(p, i)-sources and the q-ports
of G. In addition we rename each in(p, i)-source to an in(q, i)-source, and each
out(p, i)-source to an out(q, i)-source. We can use the same reasoning as in Case
2 to conclude in this case.

Case 4. p and q are small in G, and card(pG) + card(qG) ≤ m.

To build ¯G from ¯H, we rename s(q, i) into s(p, i) whenever the s(q, i)-source
of ¯H is a p-port in G. The term t which does the opposite is a composition
−→
of source renamings. The graph ¯G does not contain
K m+1,m+1, otherwise ¯H
would do, since ¯G is equal to ¯H up to source labels, and hence ¯G is an expansion
of G. The other parts of the proof are the same.

Case 5. p and q are small in G, and card(pG) + card(qG) ≥ m + 1.

To build ¯G from ¯H, we make the p-ports (resp. q-ports) of G into s(p, i)-
sources (resp. s(q, i)-sources), we delete the edges between the in(q, i)- and
out(q, i)-sources and the p- and q-ports of G, and we delete the in(q, i)- and
out(q, i)-sources. The term t which does the opposite is a composition of addi-
tions of new edges and of srcfg operations, as in Case 2, see Figure 2. The graph
−→
¯G does not contain
K m+1,m+1, otherwise ¯H would too, since ¯G is a subgraph of
¯H (up to source labels), and hence ¯G is an expansion of G. The proof continues
as in the previous cases.

This concludes the proof that G ∼ G′ implies renp→q(G) ∼ renp→q(G′).

The operation ⊗J We now consider the operation ⊗J where J ⊆ (P × Q) ∪
(Q × P ), P and Q are disjoint. Let G ∼ G′ in GP(P ), K ∼ K ′ in GP(Q),
H = G ⊗J K and H ′ = G′ ⊗J K ′. We want to prove that H ∼ H ′.

We ﬁrst consider the very special case where J = ∅, and the operation ⊗J
−→
K m+1,m+1 if and only if G or K

is simply the disjoint union. Then H contains
does, if and only if G′ or K ′ does, if and only if H ′ does.

Asuming that H does not contain

−→
K m+1,m+1, an application of Theorem 3.12
ensures, as for the operations of port forgetting or renaming that H and H ′ sat-
isfy the same small ﬁrst-order formulas.

38

p

p

q

q

q

q

q

q

G

H

out(q,1)

in(q,2)

s(p,1) s(p,2) s(q,1) s(q,2)

¯G

¯H

out(q,1)

in(q,2)

E =

s(p,1) s(p,2) s(q,1) s(q,2)

Figure 2: m = 2 and ¯H = t( ¯G) = srcfgs(p,1),s(p,2),s(q,1),s(q,2)( ¯G k E)

We now consider an expansion ¯H of H. It is necessarily of the form ¯H =
¯G ⊕ ¯K where ¯G and ¯K are expansions of G and K respectively. Then there
exist expansions ¯G′ and ¯K ′ of G′ and K ′ respectively, which are equivalent to
¯G and ¯K. One then veriﬁes that ¯H ′ = ¯G′ ⊕ ¯K ′ is an expansion of H ′, which is
equivalent to ¯H.

Next we assume that J is a singleton, J = {(p, q)}, that is, G ⊗J K =

addp,q(G ⊕ K) with p ∈ P and q ∈ Q.

Since G and G′ on one hand, and K and K ′ on the other satisfy the same
small ﬁrst-order formulas, Theorem 3.12 shows that H = addp,q(G⊕K) contains
−→
K m+1,m+1 if and only if H ′ = addp,q(G′ ⊕ K ′) does. Assume now this is not
the case and consider an expansion ¯H of H.

Again there are several cases. Note that p and q cannot both be large in
G and K respectively. We claim that ¯H can deﬁned as t( ¯G, ¯K) where t is an
HRsep-term, ¯G is an expansion of G and ¯K is an expansion of K. As for the
other operations, we consider expansions ¯G′ and ¯K ′ of G′ and K ′, equivalent to
¯G and ¯K. Although it is a bit tedious, we verify formally that ¯H ′ = t( ¯G′ ⊕ ¯K ′)
is an expansion of H ′. It follows that ¯H ′ is equivalent to ¯H, and hence H ∼ H ′.

Case 1. p is large in G and q is small in K.

Then H has edges from all p-ports of G to all q-ports of K, which are actually
s(q, i)-sources in ¯H. For each of these s(q, i)-sources, say x, we create a new
vertex x′, and each edge coming from G to x is redirected towards x′. We make
x′ into an in(p, j)-source (for some appropriate j) of the expansion ¯G of G we are
constructing. The desired expansion ¯K of K is just the subgraph of ¯H induced

39

by the set of vertices of K. And ¯G consists of the subgraph of ¯H induced by
the vertices of G together with x′ and all these redirected edges. Then the
HRsep-term t needs only to fuse in ¯G ⊕ ¯K the above described in(p, j)-sources
with the corresponding s(q, i)-sources. This can be done by a combination of
the operation ⊕ and those of the form fusin(p,j)→s(q,i). The only point to check
−→
is that ¯G does not contain
K m+1,m+1. We can apply Lemma 6.2 because ¯H is
obtained from ¯G ⊕ ¯K by fusions of pairs of vertices which are not adjacent and
have no incoming edges with the same source (because G and K are disjoint)
and no outgoing edge at all.

Then there exist expansions ¯G′ and ¯K ′ of G′ and K ′ respectively, equivalent
to ¯G and ¯K. By letting ¯H ′ = t( ¯G′, ¯K ′), we get the desired expansion of H ′,
equivalent to ¯H.

This case is illustrated in Figure 3, where m = 3 and N is the constructed

expansion of G ⊗J K.

q

q

K

q

q

K

p

p
G

p

p

p
G

p

G ⊗J K = addp,q(G ⊕ K)

in(p,1) in(p,2) in(p,3)

s(q,1)

s(q,2)
¯K

¯G

Figure 3: N = t( ¯G, ¯K) = srcfgall( ¯G k srcrens(q,1)→in(p,2),s(q,2)→in(p,3)( ¯K))

N

Case 2. p is small in G and q is large in K.

It is fully similar to the ﬁrst case, creating new out(q, j)-sources instead of

in(p, j)-sources. We omit the details.

Case 3. p is small in G and q is small in K.

Let ¯G be the subgraph with sources of ¯H consisting of the vertices of G,
and let ¯K be deﬁned similarly in terms of K. Then ¯H is obtained from ¯G ⊕ ¯K
by the addition of edges from each s(p, i)-source of ¯G to each s(q, j)-source of
¯K, which can be done by an HRsep-term (see Case 2 of the discussion of the

40

renaming operation). Since ¯G and ¯K are subgraphs of ¯H, they cannot contain
−→
K m+1,m+1 and hence, they are in fact expansions of G and K as desired. The
proof continues as above.

Case 4. p is void in G or q is void in K.

Then addp,r acts as the identity on G ⊕ K, so ⊗J acts as ⊕ on (G, K) and
we are back to a previously studied case. Recall that if p (resp. q) is void in G
(resp. K), then it is void in every ∼-equivalent graph with source.

This concludes the study of the case where J is a singleton in P × Q. The

case where J is a singleton in Q × P is of course similar.

The proof is actually the same in the general case where J is not a singleton.
We need only do the same constructions for all elements (p, q) in J. The only
possible diﬃculty could arise from the use of Lemma 6.2 to verify that the
graphs ¯G and ¯K obtained from ¯H by the creation of vertices (like x′ in Case 1
−→
above) and the redirection of edges do not contain
K m+1,m+1, and hence are
expansions. Thus let us consider the transformation of ¯G⊕ ¯K into ¯H. It consists
in a sequence of fusions of pairs of vertices. Whenever we fuse an in(p, i)-source
of ¯G, say x, with an s(q, j)-source of ¯K, say y, we must verify that the fusions
performed previously keep the hypothesis of Lemma 6.2 valid. It is clear that x
and y are not adjacent, since x is adjacent with vertices of G only. Because of
previous fusions, there may exist an edge from some z in G to y. However, this
edge comes from a previously applied operation addp′,q with p′ 6= p. It follows
that there is no edge from z to x. An analogous argument also applies to fusions
between an out(p, i)-source of G and an s(q, j)-source of K, and also when we
exchange the roles of G and K. Hence, ﬁnally, we can apply Lemma 6.2 to
−→
K m+1,m+1 because ¯H does not. Hence,
deduce that ¯G and ¯K do not contain
they are expansions of G and K, as we needed to check.

This concludes the proof of Theorem 6.1.

6.2 Other ﬁniteness conditions

We now consider some consequences of Theorem 6.1. Let Kn,n be the undirected
complete bipartite graph with n + n vertices, that is, Kn,n is the undirected
−→
K n,n. We say that a (directed) graph is without Kn,n if its
graph underlying
undirected underlying graph has no subgraph isomorphic to Kn,n.

We say that a graph G is uniformly k-sparse if card(E(H)) ≤ k card(V (H))
for every ﬁnite subgraph H of G, where V (H) and E(H) are the sets of vertices
and edges of H. A set of graphs is uniformly k-sparse if each of its elements is.

Proposition 6.5 Let L ⊆ Graph be a set of graphs, satisfying one of the fol-
lowing properties:

L is without

−→
K n,n for some n

or L is without Kn,n for some n

or L consists only of planar graphs

41

or L is uniformly k-sparse for some k

or L consists only of graphs of tree-width at most k for some k.

Then L is HR-recognizable if and only if L is VR-recognizable.

Proof. By Corollary 5.2, it is always the case that a VR-recognizable set of
graphs is HR-recognizable.

−→
K n,n for some n, the converse implication was proved in
Theorem 6.1. Lemma 6.6 below shows that L is without Kp,p for some p if and
only if it is without

−→
K n,n for some n.

If L is without

It is well-known that planar graphs are without K3,3 (planarity is a property
of the underlying undirected graph, and K3,3 is the undirected graph underlying
−→
−→
K 3,3). It follows that planar graphs are also without
K 3,3, and the result follows
from Theorem 6.1.

−→
K 2k+1,2k+1 is not k-sparse. So if L is uniformly k-sparse,

It is easily seen that

then it is without

−→
K 2k+1,2k+1.

Finally, it is known that graphs of tree-width at most k are uniformly (k+1)-
⊓⊔

sparse (see for instance [16]), which yields the last assertion.

Lemma 6.6 Let p be an integer. There exists an integer n such that a directed
graph without

−→
K p,p, is without Kn,n.

Proof. We use the particular case of Ramsey’s Theorem for bipartite graphs,
given as Theorem 1 in [27, p. 95]. It states that for each p, there exists an
integer n such that, if the edges of Kn,n are partitioned into two sets A and B,
then either A or B contains the edges of a subgraph isomorphic to Kp,p.

So let us assume that U, W ⊆ V (G), where U and W are disjoint sets of n
elements and there is an edge between u and w (in one or both directions) for
each (u, w) ∈ U × W . Let A be the set of pairs (u, w) ∈ U × W such that the
edge is from u to w, and let B = (U × W ) \ A. Then there exist sets U ′ ⊆ U
and W ′ ⊆ W , with cardinality p, such that U ′ × W ′ ⊆ A or W ′ × U ′ ⊆ B. In
either case, we get a subgraph of G isomorphic to

−→
K p,p.

Note hat a quick and direct proof can be given with n = p22p, but we do
⊓⊔

not know the minimal n yielding the result.

Remark 6.7 The statement relative to bounded tree-width sets of graphs in
Proposition 6.5 is also a consequence (in the case of ﬁnite graphs) of Lapoire’s
result [31], which states that, in a graph of tree-width at most k, one can con-
struct a width-k tree-decomposition by monadic second-order (MSO) formulas.
This can be used to show that every HR-recognizable set of graphs of bounded
tree-width is deﬁnable in Counting Monadic Second-order (CMSO) logic, using
edge set quantiﬁcations. Courcelle showed [11] that, for ﬁnite graphs of bounded
tree-width, edge set quantiﬁcations can be replaced by vertex set quantiﬁcations.
The considered set is therefore deﬁnable in CMSO logic with vertex set quan-
tiﬁcations only, and hence is VR-recognizable by another of Courcelle’s results
⊓⊔
[9].

42

Remark 6.8 It is proved in [8] that every set of square grids is HR-recognizable.
It follows from Theorem 6.1 that every such set is also VR-recognizable. Hence,
there are uncountably many VR-recognizable sets of graphs, so we cannot hope
for an automata-theoretic or a logical characterization of VR-recognizability —
in contrast with the situation prevailing for words, trees and some special classes
⊓⊔
of graphs, see [43, 32, 33, 24, 29, 30].

6.3 HR-recognizable sets which are not VR-recognizable

The aim of this short section is to establish the existence of HR-recognizable
sets which are not VR-recognizable. We ﬁrst establish a lemma.

Lemma 6.9 Every set of cliques (of the form Kn, n ≥ 1) is HR-recognizable.

Proof. Let L be a set of undirected cliques (recall that an undirected graph is
a graph where the edge relation is symmetric). We provide a locally ﬁnite CS-
congruence on GSsep which saturates L (see Section 5.2.3). By Proposition 5.7,
this establishes that L is HR-recognizable.

For each ﬁnite set C of source labels, let Gi(C) be the set of graphs in
GSsep(C) having at least one internal vertex (i.e., a vertex which is not a source),
and let Gs(C) be the set of graphs in GSsep(C), in which every vertex is a source.
In particular, Gs(C) is ﬁnite.

Let ≡ be the following equivalence relation on GSsep. We use the operation
✷C , as in Section 5.2.3.
If G, G′ ∈ GSsep(C), we let G ≡ G′ if and only if
either G = G′, or G, G′ ∈ Gi(C) and for every H ∈ Gs(C), G ✷C H ∈ L iﬀ
G′ ✷C H ∈ L.

Note that for each C, there are only ﬁnitely many ≡-classes in GSsep(C), —

namely at most p + 2p, where p is the cardinality of Gs(C).

Moreover, ≡ saturates L. Indeed, suppose that G, G′ ∈ GSsep(C), G ≡ G′
and G ∈ L. Let H be the graph in GSsep(C) consisting of distinct c-sources
(c ∈ C) and no edges. Then we have G = G ✷C H and G′ = G′ ✷C H. It follows
from the deﬁnition of ≡ that G′ ∈ L.

Finally, we check that ≡ is a CS-congruence. Let G, G′, H, H ′ ∈ GSsep(C),
with G ≡ G′ and H ≡ H ′: we want to show that G ✷C H ≡ G′ ✷C H ′. We
observe that if both G and H have internal vertices, then G ✷C H is not a clique
(by deﬁnition of operation ✷C ), and hence cannot be in L. The rest of the proof
⊓⊔
is a straightforward veriﬁcation.

We can now prove the following.

Proposition 6.10 There is an HR-recognizable set of graphs which is not VR-
recognizable.

Proof. Let A be a set of integers which is not recognizable in hN, succ, 0i, for
instance the set of prime numbers, and let L be the set of cliques Kn for n ∈ A.
Then L is HR-recognizable by Lemma 6.9.

43

We now consider a set of VR-terms describing L and using exactly 2 port
labels, p and q. Recall that p denotes the VR-constant of type {p}, that is, the
graph with a single vertex that is a p-port and no edges. The constant q is
deﬁned similarly. Now let k1 = p, and kn+1 = renq→paddp,qaddq,p(kn ⊕ q). It is
not diﬃcult to verify that kn denotes the clique Kn where all the vertices are p-
ports, Kn itself is denoted by the term mdf∅kn, and the set K of all VR-terms of
the form kn is recognizable (as a set of terms, or trees). If L is VR-recognizable,
then the set of VR-terms in K that denote graphs in L is recognizable. This
set consists of all the terms of the form mdf∅kn with n ∈ A, and it can be
shown by standard methods that it is not recognizable. It follows that L is not
VR-recognizable.
⊓⊔

6.4 Sparse graphs and monadic second-order logic

Since graphs are relational structures, logical formulas can be used to specify
sets of graphs. Monadic second-order logic is especially interesting because

every monadic second-order deﬁnable set of ﬁnite graphs is VR-recognizable

(Courcelle [9, 15]).

There is actually a version of monadic second-order logic allowing quantiﬁ-
cations on edges and sets of edges (one replaces the graph under consideration
by its incidence graph; we omit details). We say that a set is M S2-deﬁnable
if it is deﬁnable by a monadic second-order formula with edge and edge set
quantiﬁcations, and that we use the phrase M S1-deﬁnable to refer to the ﬁrst
notion. It is immediately veriﬁed (from the deﬁnition) that

Every M S1-deﬁnable set is M S2-deﬁnable.
The two following statements are more diﬃcult.

Every M S2-deﬁnable set of simple graphs is HR-recognizable (Courcelle [8]).
If a set of simple graphs is uniformly k-sparse for some k and M S2-deﬁnable,

then it is M S1-deﬁnable (Courcelle [16]).

This is somewhat analogous to the situation of Theorem 6.1 (see Proposi-
tion 6.5). However the combinatorial conditions are diﬀerent: if a set of graphs
is uniformly k-sparse for some k, it is without Kt,t for some t, but the converse
does not hold. It is proved in the book by Bollobas [5] that, for each t ≥ 2,
there is a number a such that for each n, there is a graph with n vertices and
anb edges that does not contain Kt,t, where b = 2t/(t + 1). For these graphs,
the number of edges is not linearly bounded in terms of the number of vertices,
so they are not uniformly k-sparse for any k.

It is not clear how to extend Courcelle’s proof in [16], to use the condition

without Kt,t instead of uniformly k-sparse.

7 Simple graphs vs multi-graphs

The formal setting of relational structures is very convenient to deal with simple
graphs, as we have seen already. It can also be used to formalize multi-graphs

44

(i.e., graphs with multiple edges), if we consider two-sorted relational structures.
Formally, a multi-graph with sources in C is a structure of the form G =
hV, E, inc, (cG)c∈Ci where V is the set of vertices, E is the set of edges, each cG
is an element of V , and inc is a ternary relation of type E × V × V . We interpret
the relation inc(e, x, y) to mean that e is an edge from vertex x to vertex y. We
denote by GSm(C) the set of multi-graphs with sources in C. As in the study
of StS or GS, we assume that the ﬁnite sets of source labels C are taken in a
ﬁxed countable set. We let GSm be the union of the GSm(C) for all ﬁnite sets
C of source labels.

Graphs and hypergraphs with multiple edges and hyperedges are often used,
see the volume edited by Rozenberg [41]. In this context, it is in fact frequent to
consider operations on multi-graphs that are very similar to the HR-operations
on GS. More precisely, the operations of disjoint union, source renaming,
source forgetting and source fusion can be deﬁned naturally on multigraphs
with sources: thus GSm can be seen naturally as an HR-algebra.

It is clear that each simple graph in GS(C) can be considered as an element
in GSm(C). It is important to note however that the HR-operations on GSm,
when applied to such simple graphs, do not necessarily yield the same result as
in GS. For instance, let a, b be distinct elements of C, and let G ∈ GS(C) be
a simple graph. The action of fusing the a-source and the b-source of G may
now result in multiple edges:
if there were arrows in both directions between
aG and bG, or if there were arrows to (resp. from) a vertex of G from (resp. to)
both aG and bG. In contrast, the same operation in GS(C) yields fusa,b(G), an
element of GS(C) by deﬁnition. To avoid confusion, we will denote by mfusa,b
this operation when used in GSm.

Fortunately, we do not have this sort of problem with the other operations:
applying the operations of disjoint union, source renaming or source forgetting to
simple graphs considered as elements of GSm yields the same result as applying
the same operations within the algebra GS.

We let HRm be the signature on GSm consisting of the operations of the form
⊕, srcfga, srcrena→b and mfusa,b. Thus, GSm is an HRm-algebra. We observe
that, as a signature (that is, as a set of symbols denoting operations), HRm
is in natural bijection with HR. So we don’t really need to introduce the new
notation HRm, and we could very well say that GSm is an HR-algebra. We
simply hope, by introducing this notation, to clarify our comparative study of
recognizable subsets in the algebras GS and GSm. This distinction will be useful
in the proofs of Theorems 7.3 and 7.4.

To summarize and amplify the above remarks, let us introduce the following
notation. We denote by ı: GS → GSm the natural injection. For each multi-
graph G, we denote by u(G) the simple graph obtained from G by fusing multiple
edges (with identical origin and end): that is, u is a mapping from GSm onto
GS. Elementary properties of ı and u are listed in the next proposition.

Proposition 7.1 The mapping u: GSm → GS is a homomorphism of HR-algebras.
The mapping ı: GS → GSm is not a homomorphism, but it commutes with the
operations of the form ⊕, srcfga and srcrena→b.

45

ı does not commutes with the operations of the form fusa,b, but if G ∈ GS,

then ı(fusa,b(G)) = ı(u(mfusa,b(ı(G)))).

Finally, if G ∈ GS, then ı(G) = u−1(G) ∩ ı(GS) and u(ı(G)) = G.

We now prove the following theorems, which describe the interaction between
HRm-recognizability of sets of multi-graphs and HR-recognizability of sets of
simple graphs.

Theorem 7.2 The set of simple graphs is HRm-recognizable. More precisely,
for each ﬁnite set of source labels C, ı(GS(C)) is HRm-recognizable.

Theorem 7.3 Let C be a ﬁnite set of source labels and let L ⊆ GS(C). Then
L is HR-recognizable if and only if ı(L) is HRm-recognizable.

Theorem 7.4 Let C be a ﬁnite set of source labels and let L ⊆ GSm(C). If L
is HRm-recognizable, then u(L) is HR-recognizable.

7.1 Proof of Theorem 7.2

We ﬁrst introduce the notion of the type of a multi-graph: as for the elements
of StS, if G ∈ GSm(C), we let ζ(G) be the restriction of G to its C-sources and
to the edges between them. We also denote by ζ the relation on GSm induced
by this type mapping: two multi-graphs G, H ∈ GSm(C) are ζ-equivalent if
ζ(G) = ζ(H).

Lemma 7.5 The type relation ζ is an HRm-congruence on GSm. Moreover, for
each ﬁnite set of source labels C, the elements of ı(GS(C)) can be found in only
a ﬁnite number of ζ-classes.

Proof. The result follows from the following, easily veriﬁable identities, where
the multi-graphs G, H are assumed to have the appropriate sets of sources.

ζ(G ⊕ H) = ζ(G) ⊕ ζ(H)

ζ(srcrena→b(G)) = srcrena→b(ζ(G))
ζ(mfusa,b(G)) = mfusa,b(ζ(G))
ζ(srcfga(G)) = ζ(srcfga(ζ(G))).

The ﬁniteness of the number of ζ-classes containing elements of ı(GS(C)) follows
from the fact that there are only ﬁnitely many source-only simple graphs with
⊓⊔
sources in C.

We also introduce the following ﬁnite invariant for a simple graph G ∈
GS(C). We deﬁne η(G) to be the set of all pairs {a, b} of elements of C such
that a 6= b, aG 6= bG and there exists a vertex x of G with either edges from x
to both aG and bG, or edges to x from both aG and bG. The set η(G) can be
viewed as a symmetric anti-reﬂexive relation on C.

46

Lemma 7.6 Let G be a simple graph in GS(C) and let a 6= b be elements of C.
Then mfusa,b(G) has multiple edges if and only if {a, b} ∈ η(G) or mfusa,b(ζ(G))
has multiple edges.

Proof. We ﬁrst observe that mfusa,b(G) has multiple edges if and only if aG 6=
bG and at least one of the following situations occurs: there are edges in both
directions between aG and bG, or there is a vertex x of G with edges from (resp.
to) both aG and bG (this includes the case where there is a loop at aG or bG
and an edge in either direction between aG and bG). That is, mfusa,b(G) has
multiple edges if and only {a, b} ∈ η(G) or there are edges in both directions
between aG and bG.

We also observe that mfusa,b(ζ(G)) is a subgraph of mfusa,b(G), so the former
is simple if the latter is. Finally, the existence of edges in both directions between
aG and bG is suﬃcient to ensure that mfusa,b(ζ(G)) has multiple edges.

These observations put together suﬃce to prove the lemma.

⊓⊔

We are now ready to prove Theorem 7.2. Let ≃ be the following relation,
deﬁned on each GSm(C). We let G ≃ G′ if both G and G′ have multiple edges,
or both G and G′ are simple graphs, ζ(G) = ζ(G′) and η(G) = η(G′).

It is immediate that ≃ is an equivalence relation, saturating ı(GS(C)). It
follows from Lemma 7.5 and from the fact that η(G) is a subset of the ﬁnite
set C × C, that ≃ is locally ﬁnite. So we only need to show that ≃ is an
HRm-congruence.

We need to describe the interaction between the mapping η and the HRm-
operations. As observed in Proposition 7.1, all HRm-operations preserve simple
graphs except for the operations of the form mfusa,b. Assuming that G, H are
simple graphs with the appropriate sets of sources, we easily verify the following:

η(G ⊕ H) = η(G) ∪ η(H)

η(srcfga(G)) = η(G) \ {{a, b} | b ∈ C, {a, b} ∈ η(G)}
η(srcrena→b(G)) = η(G) \ {{a, c} | c ∈ C, {a, c} ∈ η(G)}
∪{{b, c} | c ∈ C, {a, c} ∈ η(G)}

Moreover, if aG 6= bG and mfusa,b(G) is simple (if it isn’t, its η-image is not
deﬁned), then η(mfusa,b(G)) consists of:

(1) all pairs in η(G),
(2) all pairs {c, d} such that there are edges in ζ(G) from a to c and from b

to d, or from c to a and from d to b,

(3) all pairs {a, c} (resp. {b, c}) such that {b, c} ∈ η(G) (resp. {a, c} ∈

η(G)),

(4) all pairs {a, c} and {b, c} such that there are edges in ζ(G) between a

and b (in either direction) and between a or b and c (in any direction).

Let us justify this statement:

it is easy to see that all these pairs belong
to η(mfusa,b(G)). In particular, η(G) ⊆ η(mfusa,b(G)) since, as mfusa,b(G) is
assumed to be simple, there is no {c, d} ∈ η(G) such that aG = cG and bG = dG.

47

Conversely, let us consider distinct edges in G′ = mfusa,b(G), from y to x
and from z to x, as in Figure 4 (note that x and y may be equal), such that
y = eG′ and z = fG′ for e, f ∈ C. If neither x, nor y nor z is the a- and b-source

y

z

x

z

x=y

Figure 4: Distinct edges in mfusa,b(G)

in G′, then we are in case (1), i.e., {e, f } ∈ η(G). If x is the a- and b-source in
G′ but neither y nor z is, then {e, f } satisﬁes case (1) or (2). If y is the a- and
b-source in G′ but neither x nor z is, then {e, f } satisﬁes case (3). The same
holds by symmetry if z is the only one of these three vertices to be the a- and
b-source in G′. Finally if x = y (resp. x = z) and is the a- and b-source,in G′
then there is an edge between the a- and the b-source in G and {e, f } satisﬁes
case (4). The case of edges from x to y and to z is symmetrical.

In particular, η(G ⊕ H), η(srcfga(G)), η(srcrena→b(G)) and η(mfusa,b(G))

are entirely determined by η(G), ζ(G) and η(H).

Let us now consider G, G′, H, H ′
in GSm (with the appropriate sets of
sources) such that G ≃ G′ and H ≃ H ′.
If G is not simple, then neither
are G′, G ⊕ H, srcfga(G), srcrena→b(G) and mfusa,b(G). In particular, we have
G ⊕ H ≃ G′ ⊕ H ′, srcfga(G) ≃ srcfga(G′), srcrena→b(G) ≃ srcrena→b(G′) and
mfusa,b(G) ≃ mfusa,b(G′).

Assume now that G and H are simple. Then so are G ⊕ H, srcfga(G) and
srcrena→b(G), and we have seen that their η-images are determined by η(G) and
η(H). Since ζ is an HRm-congruence (Lemma 7.5), it follows that ≃ is preserved
by the operations ⊕, srcfga and srcrena→b.

By Lemma 7.6, whether mfusa,b(G) is simple, is determined by ζ(G) and
η(G), and hence mfusa,b(G) and mfusa,b(G′) are both non-simple (and then ≃-
equivalent) or both simple. In the latter case, their η-images are equal since they
are both determined by η(G) = η(G′) and ζ(G) = ζ(G′). Thus ≃ is preserved
by the operation mfusa,b. This concludes the proof of Theorem 7.2.

7.2 Proof of Theorem 7.3

Recall that we want to show that for each L ∈ GS(C), L is HR-recognizable if
and only if ı(L) is HRm-recognizable.

One direction is quickly established: we know from Proposition 7.1 that
If L is HR-recognizable, then u−1(L) is HRm-
In view of Theorem 7.2, it follows

ı(L) = u−1(L) ∩ ı(GS(C)).
recognizable since u is a homomorphism.
that ı(L) is HRm-recognizable as well.

48

Conversely, let us assume that ı(L) is HRm-recognizable and let ≡ be a
locally ﬁnite HRm-congruence on GSm saturating ı(L). We want to deﬁne a
locally ﬁnite HR-congruence ∼ on GS saturating L.

For each symmetric anti-reﬂexive relation A on a ﬁnite set of source labels
D and for each graph G ∈ GS(D), let delA(G) ∈ GS(D) be the graph obtained
from G by deleting the edges between the a-source and the b-source for each
pair {a, b} in D. Let also fusA be the composition of the operations fusa,b for
all {a, b} ∈ D, in any order.

For G, G′ ∈ GS(D), we let G ∼ G′ if ı(G) ≡ ı(G′), ζ(G) = ζ(G′) and, for

each symmetric anti-reﬂexive relation A on D,

ıfusAdelA(G) ≡ ıfusAdelA(G′).

The relation ∼ is clearly an equivalence relation, and it is locally ﬁnite since
≡ and ζ are. Moreover, it saturates L since G ∈ L if and only if ı(G) ∈ ı(L),
and ≡ saturates ı(L). The rest of the proof consists in showing that ∼ is an
HR-congruence.

The source renaming operation Let G ∼ G′ in GS(D). Then ı(G) ≡ ı(G′).
Since ≡ is a congruence and in view of Proposition 7.1, ı(srcrena→b(G)) =
srcrena→b(ı(G)) ≡ srcrena→b(ı(G′)) = ı(srcrena→b(G′)).
It also follows from
Lemma 3.9 that ζ(srcrena→b(G)) = ζ(srcrena→b(G′)).

Let us now consider a symmetric anti-reﬂexive relation A on the set of source

labels of srcrena→b(G). It is easily veriﬁed that

delAsrcrena→b = srcrena→bdelB,

where B = {{c, d} ∈ A | {c, d} ∩ {a, b} = ∅} ∪ {{a, d} | {b, d} ∈ A}. We also
note that if c, d ∈ C \ {a, b}, then fusc,d and srcrena→b commute. Moreover
fusb,dsrcrena→b = srcrena→bfusa,d and fusc,bsrcrena→b = srcrena→bfusc,a. Thus
fusAsrcrena→b = srcrena→bfusB.

Now, using the fact that ı commutes with srcrena→b we have

ıfusAdelAsrcrena→b(G) = ıfusAsrcrena→bdelB(G)
= ısrcrena→bfusBdelB(G)
= srcrena→bıfusBdelB(G).

Since ≡ is an HRm-congruence, it follows that

ıfusAdelAsrcrena→b(G) ≡ ıfusAdelAsrcrena→b(G′)

and, ﬁnally, that srcrena→b(G) ∼ srcrena→b(G′).

The source forgetting operation The proof is the same as for the source re-
naming operation, with this simplifying circumstance that delAsrcfga = srcfgadelA
and fusAsrcfga = srcfgafusA (since a is not a source label of srcfga(G), and hence
does not occur in A).

49

The source fusion operation Let G ∼ G′ in GS(D). Here it is not immedi-
ate that ı(fusa,b(G)) ≡ ı(fusa,b(G′)). However, if we let A = {{a, b}}, we know
that

ıfusAdelA(G) ≡ ıfusAdelA(G′).
We note that fusAdelA(G) is equal to fusa,b(G) if G has no edge between its
a- or b-source, or if it has a loop at either. Otherwise, fusa,b(G) is equal to
fusAdelA(G) with a loop added to its a-source, that is:

fusa,b(G) = srcfgαsrcfgβfusa,αfusb,β(fusAdelA(G) ⊕ E)

(∗)

where α and β are source labels not in D and E is the graph in GS({α, β}) with
2 vertices and a single edge from its α-source to its β-source.

Observe also that the existence of loops at, or edges between the a- and
b-source of G is a condition that depends only on ζ(G), so it will be satisﬁed by
both G and G′ or by neither.

In the ﬁrst case, where fusAdelA(G) = fusa,b(G), we ﬁnd immediately that
ı(fusa,b(G)) ≡ ı(fusa,b(G′)). In the second case, the same ≡-equivalence is de-
rived from Proposition 7.1 and Equation (∗) above.

By Lemma 3.9, ζ-equivalence is preserved by the operation fusa,b.
Now let A be a symmetric anti-reﬂexive relation on D: we consider the graph

ıfusAdelAfusa,b(G). Our ﬁrst observation is that delAfusa,b = fusa,bdelB where

B = A ∪ {{a, c} | {b, c} ∈ A} ∪ {{b, c} | {a, c} ∈ A}.

Next, we observe that fusAfusa,b = fusa,bfusB. Thus we have

ıfusAdelAfusa,b(G) = ıfusAfusa,bdelB = ıfusa,bdelBfusB(G),

and hence ıfusAdelAfusa,b(G) ≡ ıfusAdelAfusa,b(G′). It follows that fusa,b(G) ∼
fusa,b(G′).

The disjoint union operation Let G ∼ G′ in GS(C) and H ∼ H ′ in GS(D)
(where C and D are disjoint). Since ı and ζ preserve ⊕, we have ı(G ⊕ H) ≡
ı(G′ ⊕ H ′) and ζ(G ⊕ H) = ζ(G′ ⊕ H ′).

Now let A be a symmetric anti-reﬂexive relation on C ∪ D. Let Q (resp. R)
be the restriction of A to C (resp. D) and let P = A ∩ ((C × D) ∪ (D × C)). It
is easily veriﬁed that

delA(G ⊕ H) = delQ(G) ⊕ delR(H)

fusAdelA(G ⊕ H) = fusP (fusQdelQ(G) ⊕ fusRdelR(H)).

It now follows from Proposition 7.1 that

ıfusAdelA(G ⊕ H) = ıfusP (fusQdelQ(G) ⊕ fusRdelR(H))

= ıumfusP ı(fusQdelQ(G) ⊕ fusRdelR(H))
= ıumfusP (ıfusQdelQ(G) ⊕ ıfusRdelR(H)).

Thus ıfusAdelA(G ⊕ H) ≡ ıfusAdelA(G′ ⊕ H ′), and hence G ⊕ H ∼ G′ ⊕ H ′.

This concludes the proof of Theorem 7.3.

50

7.3 Proof of Theorem 7.4

Let L ∈ GSm(C) be HRm-recognizable, and let ≡ be a locally ﬁnite HRm-
congruence saturating L. We want to show that u(L) (a subset of GS(C)) is
HR-recognizable.

Let G, G′ ∈ GS(D). We let G ∼ G′ if, for each H ∈ u−1(G), there exists
H ′ ∈ u−1(G′) such that H ≡ H ′, and symmetrically, for each H ′ ∈ u−1(G′),
there exists H ∈ u−1(G) such that H ≡ H ′.

The relation ∼ is easily seen to be a locally ﬁnite equivalence relation on

GS, saturating u(L). There remains to see that ∼ is an HR-congruence.

We ﬁrst establish the following lemma.

Lemma 7.7 Let G ∈ GSm and let H, K ∈ GS.

• u(G) = H ⊕ K if and only if there exist multi-graphs H ′, K ′ such that

G = H ′ ⊕ K ′, u(H ′) = H and u(K ′) = K.

• u(G) = srcfga(H) if and only if there exists a multi-graph H ′ such that

G = srcfga(H ′) and u(H ′) = H.

• u(G) = srcrena→b(H) if and only if there exists a multi-graph H ′ such that

G = srcrena→b(H ′) and u(H ′) = H.

• u(G) = fusa,b(H) if and only if there exists a multi-graph H ′ such that

G = mfusa,b(H ′) and u(H ′) = H.

Proof. Recall that G and u(G) have the same set of vertices, and each edge
e of u(G) arises from the identiﬁcation n(e) ≥ 1 edges of G between the same
vertices.

If u(G) = H ⊕ K, each edge of u(G) is in exactly one of H and K. Let H ′
(resp. K ′) be the graph obtained from H (resp. K) by replacing each edge e
by n(e) parallel edges. Then G = H ′ ⊕ K ′, u(H ′) = H and u(K ′) = K, as
required.

The proof of the statements relative to the operations srcfga and srcrena→b

is done in the same fashion.

Let us ﬁnally consider the case where u(G) = fusa,b(H). If aH = bH, that

is, H = u(G), then G = mfusa,b(G) and we can let H ′ = G.

If aH 6= bH , we let H ′ be obtained from H be obtained from H as follows:
for each vertex x, each edge e from x to y (y 6= a, b) is replaced by n(e) parallel
edges, and the edges from x to a and b are duplicated to a total of n(e) edges. ⊓⊔

We can now conclude the proof of Theorem 7.4, by proving that ∼ is an HR-
congruence. Let G ∼ G′ and H ∼ H ′. Let K ∈ u−1(G ⊕ H). By Lemma 7.7,
K = L ⊕ M for some L ∈ u−1(G) and M ∈ u−1(H). Since G ∼ G′ and H ∼ H ′,
there exist L′ ∈ u−1(G′) and M ′ ∈ u−1(H ′) such that L′ ≡ L and M ′ ≡ M .
Let K ′ = L′ ⊕ M ′. Then K ′ = L′ ⊕ M ′ ≡ L ⊕ M = K and K ′ ∈ u−1(G′ ⊕ H ′).
By symmetry, this shows that G ⊕ H ∼ G′ ⊕ H ′.

The veriﬁcation that ∼ is preserved by the other HR-operations proceeds

along the same lines. This concludes the proof of Theorem 7.4.

51

8 Graph algebras based on graph substitutions

The class Graph, deﬁned in Section 3.1, has already been discussed in terms of
the signatures S, VR and HR since it is a domain in each of the three algebras
StS, GP and GS. In this section, we consider a diﬀerent set of operations on
Graph, arising from the theory of the modular decomposition of graphs, which
makes Graph an algebra (one-sorted for a change!). This algebraic framework
was considered by the authors, in [13] and [46].

We ﬁrst recall the deﬁnition of the composition operation on graphs. Let H
be a graph with vertex set [n] = {1, . . . , n} (n ≥ 2). If G1, . . . , Gn are graphs,
then the composite HhG1, . . . , Gni is obtained by taking the disjoint union of
the graphs G1, . . . , Gn, and by adding, for each edge (i, j) of H where i 6= j, an
edge from every vertex of Gi to every vertex of Gj.

We say that a graph is indecomposable, or prime, if it cannot be written
non-trivially as a composition (a composition is trivial if each of its arguments
It is easily veriﬁed that if H and H ′ are isomorphic graphs,
is a singleton).
then the corresponding composition operations yield isomorphic graphs. So we
ﬁx a set F∞ of representatives of the isomorphism classes of indecomposable
graphs. In particular, we may assume that every graph in F∞ has a vertex set
of the form [n] for some n ≥ 2. We also denote by F∞ the resulting modular
signature, consisting of the composition operations deﬁned by these graphs. The
F∞-algebra of graphs is denoted by GraphF∞.

It turns out that every ﬁnite graph admits a modular decomposition, that
is, it can be expressed from the single-vertex graph using only operations from
F∞. This fact has been rediscovered a number of times in the context of graph
theory and of other ﬁelds using graph-theoretic representations. We refer to [38]
for a historical survey, and to [35] for a concise presentation. In other words,
Graph is generated by the signature F∞ augmented with the constants vloop and
v, which denote a single vertex graph, respectively with and without a single
loop edge.

Remark 8.1 The modular decomposition of a graph is unique up to certain
simple (equational) rules, see for instance [46]. Moreover, the modular decom-
⊓⊔
position of a graph can be computed in linear time [34, 35, 21].

Our ﬁrst results connect VR-recognizability and F∞-recognizability.

Proposition 8.2 Every VR-recognizable set of graphs is F∞-recognizable.

Proof. In view of Proposition 2.1 and Theorem 4.5, it suﬃces to show that
every operation in F∞ is VR+-derived.

For each integer i, let marki be the unary operation on GP, of type ∅ → {i},
deﬁned as follows: given a graph without ports, it simply marks every vertex
with port label i (leaving the set of vertices and the edge relation unchanged).
Note that marki is a qfd unary operation, and hence a VR+-operation.

52

Let H be an n-ary operation, that is, a graph in F∞ with vertex set [n], and
let edgeH be its edge relation. If G1, . . . , Gn are ﬁnite graphs, the construction
of HhG1, . . . , Gni can be described as follows:

- construct the disjoint union, mark1(G1) ⊕ · · · ⊕ markn(Gn), an element of

GP([n]);

- apply (in any order) to this disjoint union the operations addi,j for all

i, j ∈ [n] such that (i, j) is an edge of H and i 6= j;

- forget all ports, that is, apply the operation mdf∅.

This completes the veriﬁcation that the operation deﬁned by H can be expressed
as a VR+-term, and hence the proof.
⊓⊔

The following result shows that the converse of Proposition 8.2 does not

hold.

Proposition 8.3 Every set of prime graphs is F∞-recognizable, and there is a
set of prime graphs which is not VR-recognizable.

Proof. Let L be a set of prime graphs, and let ≡ be the relation on Graph
deﬁned as follows. We let G ≡ H if one of the following holds:

• neither G nor H is prime;

• G and H are both 1 (the graph with one vertex and no edge);

• G and H are both not 1, prime and in L;

• G and H are both not 1, prime and not in L.

This is clearly an equivalence relation with four classes, which saturates L.
Moreover, ≡ is an F∞-congruence. Indeed, let K be a graph with n vertices;
for i = 1, . . . , n, let Gi ≡ Hi for each i. If for some i, Gi 6= 1, then Hi 6= 1, and
neither KhG1, ..., Gni nor KhH1, ..., Hni is prime: therefore they are equivalent.
Otherwise, Gi = Hi = 1 for each i, KhG1, ..., Gni and KhH1, ..., Hni are both
equal to K, and hence they are equivalent. This concludes the proof that every
set of prime graphs is F∞-recognizable.

Before we exhibit a set of prime graphs which is not VR-recognizable, we
deﬁne inductively a sequence of VR-terms written with three port labels a, b, c.
We let

t0 = adda,b(a ⊕ b),

tn+1 = renc→b(renb→a(addb,c(tn ⊕ c))).

The term mdf∅(tn) (forgetting all port labels in tn) denotes the string graph
Pn+2, with n + 2 vertices, say 1, . . . , n + 2 and edges from i to i + 1 for each
1 ≤ i ≤ n + 1. Each of these graphs is prime.

Now let A be a set of positive integers that is not recognizable in hN, succ, 0i
and let L be the set of all terms Pn with n ∈ A. From the above discussion, we
know that L is F∞-recognizable. If L was VR-recognizable, standard arguments
would show that the set of VR-terms tn (n ∈ A) would be recognizable as well,
⊓⊔
and it would follow that A is recognizable, contradicting its choice.

53

Now let F be a ﬁnite subsignature of the modular signature F∞. A graph
which can be constructed from one-vertex graphs using only operations from
F is called an F -graph. The next result deals with sets of F -graphs. This
ﬁniteness condition (the elements of L are built by repeated composition of
In fact, for many
a ﬁnite number of graph-based operations) is non-trivial.
natural classes of graphs such as rectangular grids, it is not satisﬁed: since grids
are indecomposable, a set of graphs containing inﬁnitely many grids cannot
satisfy our ﬁniteness condition. But that condition is satisﬁed by other classical
classes (e.g. cographs, series-parallel posets), see [13, 46].

Using results of Courcelle [13], we can show the following result, which yields

in particular a weak converse of Proposition 8.2.

Theorem 8.4 Let F be a ﬁnite subsignature of F∞ and let L be a set of F -
graphs. The following properties are equivalent:

1. L is S-recognizable;

2. L is VR-recognizable.

3. L is F∞-recognizable.

4. L is F -recognizable.

Proof. The equivalence of (1) and (2) can be found in Theorem 4.5. Propo-
sition 8.2 shows that (2) implies (3). And (3) implies (4) as an immediate
consequence of Proposition 2.1 since F is a subsignature of F∞. The fact that
(4) implies (1) is a consequence of two results of Courcelle: [13, Theorem 4.1],
which states that if a set of F -graphs is F -recognizable, then it is deﬁnable in
a certain extension of M S-logic; and [13, Theorem 6.11], which states that all
⊓⊔
sets deﬁnable in this logical language are S-recognizable.

Remark 8.5 Theorem 8.4 states that for sets of graphs with only ﬁnitely many
prime subgraphs, all four notions of recognizability are equivalent. Presented in
⊓⊔
this fashion, the statement is somewhat similar to that of Theorem 6.1.

9 Conclusion

In this article, we have investigated the recognizability of sets of graphs quite
in detail, focusing on the robustness of the notion, which was not immediate
since many signatures on graphs can be deﬁned. Although we had in mind sets
of graphs, we have proved that embedding graphs in the more general class of
relational structures does not alter recognizability. We have proved that the
very same structural conditions that equate VR-equational and HR-equational
sets of graphs, also equates HR-recognizability and VR-recognizability.

Summing up, we have deﬁned a number of tools for handling recognizability.

Some questions remain to investigate.

54

• When is it true that a quantiﬁer-free operation preserves recognizability?

Results in this direction have been established in Courcelle [10]. Are they
applicable to quantiﬁer-free deﬁnable operations? In particular, is it true that
the set of disjoint unions of two graphs, one from each of two VR-recognizable
sets is VR-recognizable ?

• Which quantiﬁer-free deﬁnable operations can be added to the signature HR,
in such a way that the class of HR-recognizable sets is preserved (as is the case
when we extend VR to VR+)? The paper by Blumensath and Courcelle [3],
which continues the present research, considers unary non qfd operations that
can be added to VR+ and to StS while preserving the classes of equational and
recognizable sets.

• Our example of an HR-recognizable, not VR-recognizable set of cliques, is
based on the weakness of the parallel composition of graphs with sources, i.e.,
the fact that this operation is not able to split large cliques. Can one ﬁnd
another example, based on a diﬀerent argument? If one cannot, what does this
mean?

We conclude with an observation concerning the ﬁniteness of signatures.
Whereas all ﬁnite words on a ﬁnite alphabet can be generated by this alphabet
and only one operation, dealing with ﬁnite graphs (by means of grammars,
automata and related tools) requires inﬁnite signatures. More precisely, one
needs inﬁnitely many operations to generate all ﬁnite unlabelled graphs (see
Remark 9.1 below). On the other hand, applications to testing graph properties
require the consideration of algebras generated by a ﬁnite signature. Here is the
reason.

Let M be an F -algebra of graphs. If the unique valuation homomorphism
valM : T (F ) → M (which evaluates a term into an element of M ) is surjective,
i.e., if F generates M , then a subset L of M is recognizable if and only if
val−1
M (L) is a recognizable set of terms (see Proposition 2.1 and Section 2.3).
And the membership of a term in a recognizable set can be veriﬁed in linear
time by a ﬁnite deterministic (tree) automaton. Hence the membership of a
graph G in L can be checked as follows:

(1) One must ﬁrst ﬁnd some term t such that valM (t) = G,
(2) then one checks whether t belongs to val−1

M (L).

The latter step can be done in time proportional to the size of t, usually
no larger than the number of vertices of G. Although any term t with value G
gives the correct answer, it may be diﬃcult to ﬁnd at least one (graph parsing
problems may be N P -complete).

Because of this fact many hard problems (in particular if they are expressed
in Monadic Second-order logic) can be solved in linear time on sets of graphs
of bounded tree-width, and also on sets of graphs of bounded clique-width,
provided the graphs are given with appropriate decompositions, see Courcelle
[15], Courcelle and Olariu [19] or Downey and Fellows [23]. If the decompositions
are not given, one can achieve linear time for graphs of bounded tree-width and

55

M S2 problems using a result by Bodlaender [4], and polynomial time for graphs
of bounded clique-width and M S1 problems using a result by Oum and Seymour
[39].

However, even if F is inﬁnite or is ﬁnite without generating the set M , recog-
nizability remains interesting as an algebraic concept, and for every restriction
to a ﬁnitely generated subset of M , we are back to the “good” case of a ﬁnitely
generated algebra.

Finally, we think that inﬁnite signatures can be used for checking graph
properties deﬁning recognizable sets. This will not be possible by ﬁnite tree-
automata if the graph algebra is not ﬁnitely generated, but it can perhaps be
done with automata using “oracles”. An oracle would be a subroutine han-
dling some veriﬁcations for big subgraphs that cannot be decomposed by the
operations under consideration. This idea needs of course further elaboration.

Remark 9.1 We asserted above that ﬁnite unlabelled graphs cannot be gen-
erated with a ﬁnite signature. This is not entirely correct, and we brieﬂy de-
scribe here a signature with 6 operations on a 2-sorted algebra which generates,
somewhat artiﬁcially, all ﬁnite graphs (undirected and without loops). These
operations have no good behaviour with respect to automata and veriﬁcation
questions, and such an “economical” generation of graphs is useless.

The 2 sorts are o, the set of ﬁnite graphs equipped with a linear order of their
vertex set, and u, the set of ordinary, unordered graphs. There is one unary
operation of type o → u, which forgets the order on the vertex set. All other
operations are unary, of type o → o: one consists in adding one new vertex,
to be the new least element; one adds an (undirected) edge between the two
least vertices; one performs a circular shift of the vertices; and one swaps the
two least vertices. The three last operations leave the graph unchanged if it has
less than 2 vertices. Finally, one adds a 6th, nullary operation, of type o: the
⊓⊔
constant 0, standing for the empty graph with no vertices.

A Equivalences of logical formulas

In this appendix, we discuss some equivalences and transformations of logical
formulas which can be used to give upper bounds for the index of congruences
considered in this paper, and to complete the proof of the eﬀectiveness of certain
notions (e.g. quantiﬁer-free deﬁnition schemes).

More speciﬁcally, we make precise in what sense we can state, as we do in
the body of the paper, that the set of ﬁrst-order (resp. monadic second-order)
formulas over ﬁnite sets of relations, constants and free variables, and with a
bounded quantiﬁcation depth, can be considered as ﬁnite. Moreover, explicit
upper bounds on the size of these ﬁnite sets are derived, which can be used
to justify the termination of some of our algorithms, and in evaluating their
complexity. That these upper bounds have unbounded levels of exponentiation
is not unexpected, and even unavoidable by Frick and Grohe [26].

56

A.1 Boolean formulas

Let p1, . . . , pn be Boolean variables and let Bn be the set of Boolean formulas
written with these variables.
It is well known that Bn is ﬁnite up to logical
equivalence. For further reference, we record the following more precise state-
ment.

Proposition A.1 There exists a subset Bred
such that
every formula in Bn can be eﬀectively transformed into an equivalent formula
in Bred
n .

of Bn, of cardinality 22n

n

Proof. We let Bred
n be the set of Boolean formulas in disjunctive normal form,
where in each disjunct, variables occur at most once and in increasing order,
no two disjuncts are equal, and disjuncts are ordered lexicographically. These
constraints guarantee the announced cardinality of Bred
n ; the rest of the proof
⊓⊔
is classical.

Of course, the formula in Bred

n

equivalent to a given formula, is not always

the shortest possible.

A.2 First-order formulas, semantic equivalence

Let us consider ﬁnite sets R and C, of relational symbols and of constants
(nullary relations, source labels) as in Section 3.1. Recall that, if X is a ﬁnite set,
F O(R, C, X) denotes the set of ﬁrst-order formulas in the language of (R, C)-
structures, with free variables in X. For unproved results in this section, we
refer the reader to [6].

Several notions of semantic equivalence of formulas can be deﬁned. If ϕ, ψ ∈
F O(R, C, X), say that ϕ ≡ ψ if for every (R, C)-structure S and for every
assignment of values in S to the elements of X, ϕ and ψ are both true or both
false. Say also that ϕ ≡ω ψ if the same holds for every ﬁnite or countable
(R, C)-structure S, and ϕ ≡f ψ if S is restricted to being ﬁnite.

The equivalences ≡ and ≡ω coincide by the L¨owenheim-Skolem theorem.
Indeed this theorem states that if a closed formula has an inﬁnite model, then
it has one of each inﬁnite cardinality: to prove our claim, it suﬃces to apply it
to the formula ∃~x ¬(ϕ(~x) ⇔ ψ(~x)). We note that this equivalence cannot be
extended to monadic second-order formulas: there exists an MS formula with a
unique model, isomorphic to the set of integers N with its order.
Each of these three equivalences is known to be undecidable.
The equivalence ≡ (or ≡ω since we consider only ﬁrst-order formulas) is semi-
decidable: by G¨odel’s completeness theorem, ϕ ≡ ψ if and only if the formula
∀~x (ϕ(~x) ⇔ ψ(~x)) has a proof, which is a recursively enumerable property.

Trakhtenbrot proved that one cannot decide whether a ﬁrst-order formula is
true in every ﬁnite structure, thus proving that ≡f is not decidable. However,
the negation of ≡f is semi-decidable:
if ϕ 6≡f ψ, a counter-example can be
produced by exploring systematically all ﬁnite (R, C)-structures. This is a proof
also that ≡ and ≡f do not coincide.

57

A.3 First-order formulas, a syntactic equivalence

We now describe a syntactic equivalence ≈ on formulas, which reﬁnes the se-
mantic equivalences ≡ and ≡f : that is, if ϕ ≈ ψ, then ϕ ≡ ψ and ϕ ≡f ψ.

If b ∈ Bn, and if ϕ1, . . . , ϕn ∈ F O(R, C, X), we denote by b(ϕ1, . . . , ϕn)
the formula in F O(R, C, X) obtained by replacing each occurrence of pi in
It is clear that if b and b′ are equivalent Boolean formulas, then
b by ϕi.
b(ϕ1, . . . , ϕn) ≡ b′(ϕ1, . . . , ϕn).

A Boolean transformation step consists in replacing in a ﬁrst-order formula,
a sub-formula of the form b(ϕ1, . . . , ϕn) by the equivalent formula b′(ϕ1, . . . , ϕn),
where b, b′ ∈ Bn are equivalent. Then we let ϕ ≈ ψ if ϕ can be transformed
into ψ by a sequence of Boolean transformation steps and of renaming of bound
variables.

It is clear that if ϕ ≈ ψ, then ϕ ≡ ψ. We want to show that each ﬁrst-
order formula is eﬀectively equivalent to an ≈-equivalent formula of the same
quantiﬁer height, and to give an upper bound on the number of ≈-equivalence
classes of formulas of a given height.

A.3.1 Quantiﬁer-free formulas

Let QF (R, C, X) be the set of quantiﬁer-free formulas in F O(R, C, X). Such
formulas are Boolean combinations of atomic formulas. Let Atom(R, C, X) be
the set of these atomic formulas. Note that each atomic formula is either of the
form x = y, where x and y are in X ∪ C, or r(x1, . . . , xρ(r)) where r is a ρ(r)-ary
relation in R and the xi are in X ∪ C. Letting n = card(X) and c = card(C), it
is easily veriﬁed that

card(Atom(R, C, X)) = (n + c)2 +

(n + c)ρ(r).

X
r∈R

We let f (R, c, n) be this function. Note that if we allow for the (eﬀective)
syntactic simpliﬁcations of identifying the formulas of the form x = x with the
constant true, and of identifying the formulas x = y and y = x, we can lower
the value of f (R, c, n) to 1 + 1
2 (n + c)(n + c − 1) +
We then have the following.

Pr∈R(n + c)ρ(r).

Proposition A.2 There exists a subset QF red(R, C, X) of QF (R, C, X), of
cardinality 22f (R,c,n)
, such that every formula in QF (R, C, X) can be eﬀectively
transformed to an ≈-equivalent formula in QF red(R, C, X).

Proof. By deﬁnition of quantiﬁer-free formulas, QF (R, C, X) is the set of all
formulas of the form b(ϕ1, . . . , ϕn), where b is a Boolean formula and the ϕi are
atomic formulas. Now let QF red(R, C, X) be the set of all formulas of the form
b(ϕ1, . . . , ϕn), where b ∈ Bred
and the ϕi are pairwise distinct atomic formulas.
The proof of the precise statement is now immediate, using Proposition A.1. ⊓⊔

n

58

Example A.3 Let us consider graphs with sources, so that R consists of a
single, binary edge relation. Then f (R, c, 0) = 2c2 and card(QF red(R, C, ∅)) =
222c2
= q(c). Thus the type equivalence ζ (see Section 3.3 and Lemma 3.8) has
at most 2q(c) classes in GS(C).
⊓⊔

Remark A.4 Again, we are not claiming that the set QF red(R, C, X) is as
small as possible. On quantiﬁer-free formulas, the equivalence ≡ is decidable,
because ϕ ≡ ψ is false if and only if the closed formula ∃~x(ϕ(~x) 6⇔ ψ(~x))
is satisﬁable, and the satisﬁability problem for existential formulas in prenex
normal form is decidable (see [6]). Thus one can modify Proposition A.2 by
letting QF red(R, C, X) be the set of lexicographically minimal formulas in each
≡-class: the same statement of Proposition A.2 would then hold with ≡ instead
of ≈. In particular, the transformation would still be eﬀective, although very
It is not clear whether the cardinality of the new set of reduced
ineﬃcient.
⊓⊔
quantiﬁer-free formulas would be signiﬁcantly smaller.

A.3.2 Quantiﬁer depth of ﬁrst-order formulas

Recall that the quantiﬁer depth of a ﬁrst-order formula is the maximal num-
ber of nested quantiﬁers.
If we let F Ok(R, C, X) be the set of formulas in
F O(R, C, X) of quantiﬁer depth at most k, a formal deﬁnition is as follows:
F O0(R, C, X) = QF (R, C, X) and, for each k ≥ 0, F Ok+1(R, C, X) is the set
of Boolean combinations of formulas in

F Ok(R, C, X) = F Ok(R, C, X)
d

∪ {∃y ϕ | ϕ ∈ F Ok(R, C, X ∪ {y})}
∪ {∀y ϕ | ϕ ∈ F Ok(R, C, X ∪ {y})}.

Using the same recursion, let us deﬁne sets of “reduced” formulas of every
quantiﬁer depth. First we ﬁx an enumeration of the countable set of variables.
Next, we let F Ored
(R, C, X) = QF red(R, C, X). For each k ≥ 0, we then let
F Ored
k+1(R, C, X) be the set of formulas of the form b(ϕ1, . . . , ϕn) where b ∈ Bred
and the ϕi’s are in

n

0

F O
d

red
k (R, C, X) = F Ored

k (R, C, X)

∪ {∃y ϕ | ϕ ∈ F Ored
∪ {∀y ϕ | ϕ ∈ F Ored

k (R, C, X ∪ {y}), y minimal not in X}
k (R, C, X ∪ {y}), y minimal not in X}.

Proposition A.5 For each k ≥ 0, the set F Ored
(R, C, X) is ﬁnite. Moreover,
every formula in F Ok(R, C, X) can be eﬀectively transformed to an ≈-equivalent
formula in F Ored

(R, C, X).

k

k

Proof. Let n = card(X) and c = card(C), let g(k, R, c, n) be the cardinality of
F Ored

k (R, C, X), and let h(k, R, c, n) be the cardinality of

red
k (R, C, X). It is

F O
d

59

elementary to verify that these functions can be bounded as follows:

g(0, R, c, n) ≤ 2f (R,c,n) and for k > 0
g(k, R, c, n) ≤ 22h(k,R,c,n)
h(k, R, c, n) ≤ 3g(k − 1, R, c, n + 1).

The rest of the proof is immediate, from the recursive deﬁnitions.

⊓⊔

Remark A.6 Since there is a procedure to transform each ﬁrst-order formula
into an ≈-equivalent formula in “reduced form”, we can consider a new equiva-
lence relation on ﬁrst-order formulas: to yield the same reduced formula. This
⊓⊔
equivalence is decidable and it reﬁnes ≈ (and hence ≡).

Remark A.7 In Proposition A.5, we can still consider replacing each formula
by the lexicographically least equivalent formula, but this method is not eﬀec-
⊓⊔
tive, since the equivalence of ﬁrst-order formulas is not decidable.

A.4 Monadic second-order formulas

A very similar analysis can be conducted for monadic second-order formulas of
bounded quantiﬁer depth. One diﬀerence is that the L¨owenheim-Skolem theo-
rem does not hold for these formulas, so the semantic equivalence of formulas
based on coincidence on all ﬁnite or countable models does not imply coinci-
dence on all models. Moreover, since there is no complete proof systems for
such formulas, the equivalences ≡ and ≡ω are not semi-decidable.

For the rest, one can follow the same techniques as above, to prove the
following result. We denote by M Sk(R, C, W ) the set of monadic second-order
formulas of quantiﬁcation depth k in the language of (R, C)-structures, with
their ﬁrst- and second-order free variables in W .

Proposition A.8 For every ﬁnite R, C, W, k, one can construct a ﬁnite subset
M Sred
k
one can construct eﬀectively an ≡-equivalent formula in M Sred

(R, C, W ) of M Sk(R, C, W ) such that, for every formula in M Sk(R, C, W ),

(R, C, W ).

k

References

[1] K. Abrahamson, M. Fellows, Finite automata, bounded tree-width and well-
quasiordering. In: N. Robertson, P. Seymour (eds) Graph Structure Theory.
Contemporary Mathematics 147 (1993), 539-564.

[2] S. Arnborg, B. Courcelle, A. Proskurowski, D. Seese, An algebraic theory

of graph reduction. J. ACM 40 (1993), 1134-1164.

[3] A. Blumensath, B. Courcelle, Recognizability and hypergraph operations

using local information. Submitted (2004).

60

[4] H.L. Bodlaender, A linear-time algorithm for ﬁnding tree-decompositions of

small treewidth. SIAM J. Comput. 25 (1996), 1305-1317.

[5] B. Bollobas, Extremal graph theory. Academic Press (1978).

[6] E. B¨orger, E. Gr¨adel, Yu. Gurevich, The classical decision problems.

Springer, 1997.

[7] D. G. Corneil, M. Habib, J.-M. Lanlignel, B. Reed, U. Rotics, Polyno-
mial time recognition of clique-width ≤ 3 graphs, Extended abstract. In: G.H.
Gonnet, D. Panario, A. Viola (eds.) LATIN’2000. LNCS 1776 (2000), 126-
134.

[8] B. Courcelle, The monadic second-order logic of graphs I: recognizable sets of

ﬁnite graphs. Information and Computation 85 (1990), 12-75.

[9] B. Courcelle, The monadic second-order logic of graphs VII: Graphs as rela-

tional structures. Theoretical Computer Science 101 (1992) 3-33.

[10] B. Courcelle, Recognizable sets of graphs: equivalent deﬁnitions and closure
properties. Mathematical Structures in Computer Science 4 (1994), 1-32.

[11] B. Courcelle, The monadic second-order logic of graphs VI: on several repre-
sentations of graphs by relational structures. Discrete Applied Mathematics 54
(1994) 117-149. Erratum 63 (1995) 199-200.

[12] B. Courcelle, Basic notions of universal algebra for language theory and graph

grammars. Theoretical Computer Science 163 (1996), 1-54.

[13] B. Courcelle, The monadic second-order logic of graphs X: Linear orders. The-

oretical Computer Science 160 (1996), 87-143.

[14] B. Courcelle, Structural properties of context-free sets of graphs generated by

vertex-replacement. Information and Computation 116 (1995), 275-293.

[15] B. Courcelle, The expression of graph properties and graph transformations
in monadic second order logic. In: G. Rozenberg (ed.) Handbook of Graph
Grammars and Computing by Graph Transformations, vol. 1, chapter 5. World
Scientiﬁc, 1997, 313-400.

[16] B. Courcelle, The monadic second-order logic of graphs XIV: Uniformly sparse
graphs and edge set quantiﬁcations. Theoretical Computer Science 299 (2003),
1-36.

[17] B. Courcelle, Recognizability of graphs, hypergraphs and relational structures:

a survey. In: DLT 2004, LNCS 3340, Springer, 2004, 1-11.

[18] B. Courcelle, J. Engelfriet, G. Rozenberg, Handle rewriting hypergraph

grammars. J. Comput. and System Sci. 46 (1993), 218-246.

[19] B. Courcelle, S. Olariu, Upper bounds to the clique-width of graphs. Discrete

Applied Mathematics 101 (2000), 77-114.

61

[20] B. Courcelle, J.A. Makowsky, U. Rotics, Linear time solvable optimization
problems on graphs of bounded clique-width. Theory of Computing Systems, 33
(2000), 125-150

[21] A. Cournier, M. Habib, A new linear algorithm for modular decomposition.

In: S. Tison (ed.) CAAP 1994. LNCS 787, Springer, 1994, 68-84.

[22] V. Diekert, The book of traces. World Scientiﬁc (1995).

[23] R. Downey, M. Fellows, Parametrized complexity. Springer, 1997.

[24] Z. ´Esik, Z. N´emeth, Higher dimensional automata. J. Automata, Languages

and Combinatorics, to appear.

[25] S. Feferman, R. Vaught, The ﬁrst order properties of products of algebraic

systems. Fundamenta Mathematicae 47 (1959) 57-103.

[26] M. Frick, M. Grohe, The complexity of ﬁrst-order and monadic second-order

logic revisited. Annals of Pure and Applied Logic 130 (2004), 3-31.

[27] R. Graham, B. Rothschild, J. Spencer, Ramsey theory. J. Wiley, New York,

1980.

[28] H.J. Hoogeboom, P. ten Pas, Monadic second-order deﬁnable text languages.

Theory Comput. Systems 30 (1997) 335-354.

[29] D. Kuske, Towards a language theory for inﬁnite N -free pomsets. Theoretical

Computer Science 299 (2003) 347-386.

[30] D. Kuske, Regular sets of inﬁnite message sequence charts. Information and

Computation 187 (2003), 90-109.

[31] D. Lapoire, Recognizability equals Monadic Second-Order deﬁnability, for sets
of graphs of bounded tree-width. In: STACS 98. LNCS 1373, Springer, 1998,
618-628.

[32] K. Lodaya, P. Weil, Series-parallel languages and the bounded-width property.

Theoretical Computer Science 237 (2000), 347-380.

[33] K. Lodaya, P. Weil, Rationality in algebras with a series operation. Information

and Computation 171 (2001), 269-293.

[34] R. McConnell, J. Spinrad, Linear-time modular decomposition and eﬃcient
transitive orientation of comparability graphs. In: Fifth Annual ACM-SIAM Sym-
posium on Discrete Algorithms, ACM, 1994, 536-545.

[35] R. McConnell, J. Spinrad, Modular decomposition and transitive orientation.

Discrete Mathematics 201 (1999), 189-241.

[36] J. Makowsky, Algorithmic aspects of the Feferman-Vaught Theorem. Annals of

Pure and Applied Logic 126 (2004), 159-213.

[37] J. Mezei, J. Wright, Algebraic automata and context-free sets. Information

and Control 11 (1967), 3-29.

62

[38] R.H. M¨ohring, F.J. Radermacher, Substitution decomposition for discrete
structures and connections with combinatorial optimization. Annals of Discrete
Mathematics 19 (1984), 257-356.

[39] S. Oum, P. Seymour, Approximating clique-width and branch-width. Submitted

(2004).

[40] D. Perrin, J.-E. Pin, Inﬁnite words, Pure and Applied Mathematics, vol. 141.

Elsevier, 2004

[41] G. Rozenberg, Handbook of Graph Grammars and Computing by Graph Trans-

formations. World Scientiﬁc (1997).

[42] S. Shelah, The monadic theory of order. Annals of Mathematics 102 (1975),

379-419.

[43] W. Thomas, Automata on inﬁnite objects. In J. van Leeuwen ed. Handbook of

Theoretical Computer Science, vol. B. Elsevier, 1990, 133-192.

[44] E. Wanke, k-N LC graphs and polynomial algorithms. Discrete Applied Mathe-

matics 54 (1994), 251-266.

[45] W. Wechler, Universal algebra for Computer Scientists. Springer, 1992.

[46] P. Weil, On the logical deﬁnability of certain graph and poset languages. J.

Automata, Languages and Computation 9 (2004), 147-165

[47] P. Weil, Algebraic recognizability of languages. In: MFCS 2004 (J. Fiala, V.

Koubek, J. Kratochv´ıl eds.), LNCS 3153, Springer, 2004, 149-175.

63

