7
1
0
2

y
a
M
2
2

]

C
O
.
h
t
a
m

[

3
v
0
0
7
1
0
.
4
0
7
1
:
v
i
X
r
a

Accelerated Stochastic Quasi-Newton
Optimization on Riemannian Manifolds

Anirban Roychowdhury
Department of Computer Science and Engineering
Ohio State University
Columbus, OH 43210
roychowdhury.7@osu.edu

May 23, 2017

Abstract

We propose an L-BFGS optimization algorithm on Riemannian manifolds using
minibatched stochastic variance reduction techniques for fast convergence with con-
stant step sizes, without resorting to linesearch methods designed to satisfy Wolfe
conditions. We provide a new convergence proof for strongly convex functions
without using curvature conditions on the manifold, as well as a convergence discus-
sion for nonconvex functions. We discuss a couple of ways to obtain the correction
pairs used to calculate the product of the gradient with the inverse Hessian, and em-
pirically demonstrate their use in synthetic experiments on computation of Karcher
means for symmetric positive deﬁnite matrices and leading eigenvalues of large
scale data matrices. We compare our method to VR-PCA for the latter experiment,
along with Riemannian SVRG for both cases, and show strong convergence results
for a range of datasets.

1

Introduction

Optimization algorithms are a mainstay in machine learning research, underpinning
solvers for a wide swath of problems ranging from linear regression and SVMs to deep
learning. Consequently, scaling such algorithms to large scale datasets while preserving
theoretical guarantees is of paramount importance. An important challenge in this ﬁeld
is designing scalable algorithms for optimization problems in the presence of constraints
on the search space, a situation all too often encountered in real life. One approach to
handling such constrained optimization problems on vector spaces is to reformulate them
as optimization tasks on a suitable Riemannian manifold, with the constraints acting
as manifold parametrization. Often, the problems can be shown to possess desirable
geometric properties like convexity with respect to distance-minimizing geodesics
on the manifold, leading to provably efﬁcient optimization algorithms [1, 2, 3, 4].
These ideas can then be combined with stochastic optimization techniques inﬂuenced

1

 
 
 
 
 
 
by [5], to deal with large datasets with theoretical convergence guarantees. See [6,
7] for recent examples. For instance, we can consider the problem of computing
leading eigenvectors in the PCA setting [8] with unit-norm constraints. Projection-based
strategies are normally used for this kind of problems [9], but alternating between
solving and projecting can be prohibitively expensive in high dimensions. However, the
unit-norm constraint can be used to cast the eigenvector problem into an unconstrained
optimization scenario on the unit sphere, which happens to be one of the most well-
behaved Riemannian manifolds.

Once the problems have been cast onto manifolds, one would want fast optimization
algorithms that potentially use stochastic minibatches to deal with very large datasets.
Such algorithms operating in Euclidean space have been widely researched in the
optimization literature, but their development for Riemannian manifolds has been
limited so far. In particular, one should note that the convergence speed limitations of
unconstrained stochastic algorithms in the Euclidean case apply to manifold optimization
as well; for instance a straightforward port of stochastic gradient descent to Riemannian
manifolds [2] attains the same sublinear convergence seen in Euclidean space. There
has been extensive work in the Euclidean domain using variance-reduced gradients to
address this issue, with the aim of improving convergence rates by explicitly reducing
the variance of stochastic gradients with suitably spaced full-gradient evaluations [8, 10].
Another nice advantage of this technique is the removal of the need for decaying learning
rates for proving convergence, thereby solving the sublinearity issue as well sidestepping
the nontrivial task of selecting an appropriate decay rate for SGD-like algorithms in
large-scale optimization scenarios. Researchers have begun porting these methods to the
manifold optimization domain, with a stochastic ﬁrst-order variance reduced technique
[7] showing robust convergence guarantees for both convex and nonconvex problems
on geodesically complete manifolds.

Another complementary approach to improving convergence rates is of course using
second-order updates for the iterates. In the Euclidean setting, one can show quadratic
convergence rates for convex problems using Newton iterations, but these tend to be
prohibitively expensive in high-dimensional big-data settings due to the need to store and
invert the Hessian matrix. This limitation has led to the development of quasi-Newton
methods, most notably L-BFGS [11], which uses lower-order terms to approximate the
inverse Hessian. The curvature information provided by the Hessian estimate allows
superlinear convergence in ideal settings [12]. While widely used for small-to-medium
scale problems, adoption of these methods for big data problems has been limited, since
the second order updates can be prohibitively expensive to compute in these situations.
However, most optimization algorithms in the literature that use stochastic minibatching
techniques to deal with large datasets are modiﬁcations of ﬁrst order gradient-descent
[13, 14] with relatively slower convergence in practical situations. This has recently
begun to be addressed, with researchers devising stochastic variants of the L-BFGS
technique [15], with straightforward convergence analyses. This has also been combined
with variance reduction techniques and shown to have a linear convergence rate for
convex problems in Euclidean space [16]. Our work in this paper is in a similar vein:
we study quasi-Newton L-BFGS updates with stochastic variance reduction techniques
for optimization problems on Riemannian manifolds, and analyze their convergence
behavior for convex and nonconvex functions.

2

Contributions: The main contributions of this work may be summarized as follows:

1. We propose a stochastic L-BFGS method for Riemannian manifolds using
stochastic variance reduction techniques for the ﬁrst-order gradient estimates, and
analyze the convergence for both convex and nonconvex functions under standard
assumptions.

2. Our proof for strongly convex functions is different from those of recently
proposed stochastic L-BFGS algorithms using variance-reduced gradients in Euclidean
space [16] due to different bounds on the stochastic gradients. We do not use sectional
curvature bounds in our proof for the convex case, making it structurally different from
that of Riemannian SVRG [7].

3. We show strong experimental results on Karcher mean computations and cal-
culation of leading eigenvalues, with noticeably better performance than Riemannian
SVRG and VR-PCA; the latter is one of the best performing Euclidean algorithms for
the ﬁnding dominant eigenvalues, that also uses stochastic variance-reduced gradients.

2 Preliminaries

2.1 Riemannian geometry

We begin with a brief overview of the differential geometric concepts we use in this
work. We consider C∞ (smooth) manifolds that are locally homeomorphic to open
subsets of RD, in the sense that the neighborhood of each point can be assigned a
system of coordinates of appropriate dimensionality. Formally, this is deﬁned with the
notion of a chart c : U → RD at each x ∈ M, where U ⊂ M is an open subspace
containing x. Smooth manifolds are ones with covering collections of differentiable
(cid:1), that
(C∞) charts. A Riemannian metric g(·, ·) is a bilinear C∞ tensor ﬁeld of type (cid:0)0
is also symmetric and positive deﬁnite. A manifold endowed with such a metric is called
a Riemannian manifold. The tangent space TxM at every x ∈ M is a vector space,
with the Riemannian metric g : TxM × TxM → R as the attendant metric. g then
induces a norm for vectors in the tangent space , which we denote by (cid:107) · (cid:107).

2

Riemannian manifolds are endowed with the Levi-Civita connection, which induces
the notion of parallel transport of vectors from one tangent space to another along a
geodesic, in a metric preserving way. That is, we have an operator Γγ : TxM →
TyM where, informally speaking, γ joins x and y, and for any u, ν ∈ TxM, we have
g(u, ν) = g(Γ(u), Γ(ν)) . The parallel transport can be shown to be an isometry.

For every smooth curve γ : [0, 1] → M lying in M, we denote its velocity vector
as ˙γ(t) ∈ TxM for each t ∈ [0, 1], with the “speed” given by (cid:107) ˙γ(t)(cid:107). The length

of such a curve is usually measured as L(γ) =

1
(cid:82)

(cid:107) ˙γ(t)(cid:107)dt. Denoting the covariant

0

derivative along γ of some ν ∈ TxM, with respect to the Riemannian (Levi-Civita)
connection by Aν, we call A ˙γ the acceleration of the curve. Curves with constant
velocities (A ˙γ ≡ 0) are called geodesics, and can be shown to generalize the notion of
Euclidean straight lines. We assume that every pair x, y ∈ M can be connected by a
geodesic γ s.t. γ(0) = x and γ(1) = y. Immediately we have the notion of “distance”
between any x, y ∈ M as the minimum length of all geodesics connecting x and y,

3

assuming the manifolds are geodesically complete as mentioned above, in that every
countable decreasing sequence of lengths of geodesics connecting a pair of points has a
well-deﬁned limit.

The geodesic induces a useful operator called the exponential map, deﬁned as
Expx : TxM → M s.t. Expx(ν) = γ(1) where γ(0) = x, γ(1) = y and ˙γ(0) = ν.
If there is a unique geodesic connecting x and y, then the exponential map has an
inverse, denoted by Exp−1
x (y). The length of this geodesic can therefore be seen to be
(cid:107)Exp−1

x (y)(cid:107).

The derivative D of a differentiable function is deﬁned using the Riemannian
connection by the following equivalence: Df (x)ν = νf , where ν ∈ TxM. Then, by
the Riesz representation theorem, there exists a gradient ∇f (x) ∈ TxM s.t. ∀ν ∈
TxM, Df (x)ν = gx(∇f (x), ν). Similarly, we can denote the Hessian as follows:
D2f (x)(·, ·) : TxM × TxM → R. We denote the mapping from ν ∈ TxM to the
Riesz representation of D2f (x)(ν, ·) by ∇2f (x). One can consult standard textbooks
on differential geometry [17, 18] for more details.

2.2 Convexity and Lipschitz smoothness on manifolds

Similar to [2, 3, 7], we deﬁne manifold (or geodesic) convexity concepts analogous
to the Euclidean baselines, as follows : a set U ⊂ M is convex on the manifold if
∀x, y ∈ U there exists a geodesic γ connecting x, y that completely lies in U , i.e.
γ(0) = x, γ(1) = y. Then, a function can be deﬁned as convex w.r.t. geodesics if
∀x, y ∈ U where ∃γ connecting x, y on the manifold, we have:

f (γ(t)) ≤ tf (x) + (1 − t)f (y) ∀t ∈ [0, 1].

We can also deﬁne a notion of strong convexity as follows: a function f is called

S−strongly convex if for any x, y ∈ U and (sub)gradient ∇x, we have

f (y) ≥ f (x) + gx(∇x, Exp−1

x (y)) +

S
2

(cid:107)Exp−1

x (y)(cid:107)2.

(1)

We deﬁne Lipschitz smoothness of a function f by imposing Lipschitz continuity

on the gradients, as follows: ∀x, y ∈ U,

(cid:107)∇(x) − Γγ∇(y)(cid:107) ≤ L(cid:107)Exp−1

x (y)(cid:107),

where L is the smoothness parameter. Analogous to the Euclidean case, this property
can also be formulated as::

f (y) ≤ f (x) + gx(∇x, Exp−1

x (y)) +

L
2

(cid:107)Exp−1

x (y)(cid:107)2.

(2)

3 Stochastic Riemannian L-BFGS

In this section we present our stochastic variance-reduced L-BFGS algorithm on Rie-
mannian manifolds and analyze the convergence behavior for convex and nonconvex
differentiable functions on Riemannian manifolds. We assume these manifolds to be

4

L-Lipschitz smooth, as deﬁned above, with existence of unique distance-minimizing
geodesics between every two points, i.e. our manifolds are geodesically complete; this
allows us to have a well-deﬁned inverse exponential map that encodes the distance
between a pair of points on the manifold. For the convergence analysis, we also assume
f to have a unique minimum at x∗ ∈ U , where U is a compact convex subset of the
manifold.

3.1 The Algorithm

The pseudocode is shown in Algorithm 1. We provide a brief discussion of the salient
properties, and compare it to similar algorithms in the Euclidean domain, for example
[15, 16], as well as those on Riemannian manifolds, for example [3]. To begin, note
that ∇ denotes the Riesz representation of the gradient D, as deﬁned in §2.1. We
denote full gradients by ∇ and stochastic gradients by ˜∇. Similar to other stochastic
algorithms with variance-reduction, we use two loops: each iteration of the inner loop
corresponds to drawing one minibatch from the data and performing the stochastic
gradient computations (Steps 10, 11), whereas each outer loop iteration corresponds
to two passes over the full dataset, once to compute the full gradient (Step 6) and the
other to make multiple minibatch runs (Steps 8 through 30). Compared to the Euclidean
setting, note that the computation of the variance-reduced gradient in Step 11 involves an
extra step: the gradients (∇f (x)-s) reside in the tangent spaces of the respective iterates,
therefore we have to perform parallel transport to bring them to the same tangent space
before performing linear combinations.

To avoid memory issues and complications arising from Hessian-vector compu-
tations in the Riemann setting, we chose to update the second correction variable yr
using a simple difference of gradients approximation: yr = ˜∇f (ur) − Γγ ˜∇f (ur−1).
We should note here that the parallel transport parametrization should be clear from
the context; Γγ here denotes transporting the vector ˜∇f (ur−1) ∈ Tur−1M to TurM
along the connecting geodesic γ. We omit any relevant annotations from the transport
symbol to prevent notational overload. We calculate the ﬁrst correction pair zr in one
of two ways: (a) as zr = Γγ (η2ρt−1), or (b) as zr = Γγ (−η1νprev). We denote these
by Option 1 and Option 2 respectively in Alg. 1. Note that in both cases, Γγ denotes
the parallel transport of the argument to the tangent space at xs+1
. In our experiments,
we noticed faster convergence for the strongly convex centroid computation problem
with Option 1, along with computation of the correction pairs every iteration and a low
memory pool. For calculating dominating eigenvalues on the unit-radius sphere, Option
2 yielded better results. Once the corrections pairs zr, yr have been computed, we
compute the descent step in Step 21 using the standard two-loop recursion formula given
in [12], using the M correction pairs stored in memory. Note that we use ﬁxed stepsize
in the update steps and in computing the correction pairs, and do not impose or perform
calculations designed to have them satisfy Armijo or Wolfe conditions. Compared to
the Euclidean algorithms [15, 16], Alg.1 has some key differences: 1) we did not notice
any signiﬁcant advantage from using separate minibatches in Steps 10 and 18, therefore
we use the same minibatch to compute the VR gradient and the correction elements yr;
2) we do not keep a running average of the iterates for computing the correction element
zr (Steps 15 through 17); 3) we use constant stepsizes throughout the whole process, in

t

5

Algorithm 1 Riemannian Stochastic VR L-BFGS

1: Input: Initial value x0, parameters M and R, learning rates η1, η2, minibatch size mb.
2: Initialize c = 1;
3: Set r = 0;
4: Initialize H0;
5: for t = 0, 1, . . . do
Set xt+1
0 = xs;
Compute full gradient gt+1 = N −1 (cid:80)N
for i = 0, 1, . . . m − 1 do

i=1 ∇fi(xt);

7:

6:

8:

) and ˜∇f (xi) using Ii,mb;

) − Γγ( ˜∇f (xt) − gt+1);

i

i

Sample minibatch Ii,mb ⊂ 1, . . . , N ;
Compute ˜∇f (xi+1
i = ˜∇f (xt+1
Set νt+1
if c ≡ 0 mod R then
Set r = r + 1;
if r ≥ 2 then
r = xt+1
Set ut+1
i
Option 1: Compute zt+1
Option 2: Compute zt+1
r = ˜∇f (ut+1
Compute yt+1
Store correction pairs zt+1

;

r

end if
Set xprev = xt+1

i

, νprev = νt+1

i

;

end if
if c < 2R then
Set xt+1

else

i+1 = Expxt+1

(−η1νt+1

i

);

i = H t+1

Compute ρt+1
Set xt+1

νt+1
r
i
(η2ρt+1
i+1 = Expxt+1
i

, as mentioned in the text;
);

i

i

i−1

(cid:0)η2ρt+1

(cid:1);
r = Γγ
r = Γγ (−η1νprev);
) − Γγ ˜∇f (ut+1
and yt+1

r

r

i−1) using Ii,mb;

, using r to maintain memory depth M ;

9:

10:

11:

12:

13:

14:

15:

16:

17:

18:

19:

20:

21:

22:

23:

24:

25:

26:

27:

28:

29:

30:

end if
Set c = c + 1;

end for
Set xt+1 = xt+1
m ;

31:
32: end for

6

contrast to [15] that uses a decaying sequence. Note that, as seen in Step 24, we use the
ﬁrst-order VR gradient to update the iterates for the ﬁrst 2R iterations; this is because
we calculate correction pairs every R steps and evaluate the gradient-inverse Hessian
product (Step 26) once at least two pairs have been collected. Similar to [12], we drop
the oldest pair to maintain the memory depth M . Compared to the algorithms in [3, 19],
ours uses stochastic VR gradients, with all the attendant modiﬁcations and advantages,
and does not use linesearch techniques to satisfy Wolfe conditions.

3.2 Analysis of convergence

In this section we provide the main convergence results of the algorithm. We analyze
convergence for ﬁnite-sum empirical risk minimization problems of the following form:

min
x∈M

f (x) =

1
N

N
(cid:88)

i=1

fi(x),

(3)

where the Riemannian manifold is denoted by M. Note that the iterates are updated in
Algorithm 1 by taking the exponential map of the descent step multiplied by the stepsize,
with the descent step computed as the product of the inverse Hessian estimate and the
stochastic variance-reduced gradient using the standard two-loop recursion formula.
Thus, to bound the optimization error using the iterates, we will need bounds on both
the stochastic gradients and the inverse Hessians. As mentioned in [7], the methods
used to derive the former bounds for Euclidean algorithms cannot be ported directly
to manifolds due to metric nonlinearities; see the proof of Proposition 1 for details.
For the latter, we follow the standard template for L-BFGS algorithms in the literature
[4, 12, 15]. To begin, we make the following assumptions:

Assumption 1. The function f in (5) is strongly convex on the manifold, whereas

the fis are individually convex.

Assumption 2. There exist λ, Λ ∈ (0, ∞), λ < Λ s.t. λ(cid:107)ν(cid:107)2
x ∀ν ∈ TxM.

Λ(cid:107)ν(cid:107)2

x ≤ D2f ≤

These two assumptions allow us to (a) guarantee that f has a unique minimizer x∗
in the convex sublevel set U , and (b) derive bounds on the inverse Hessian updates using
BFGS update formulae for the Hessian approximations. Similar to the Euclidean case,
these can be written as follows:

ˆBr = Γγ

(cid:34)
ˆBr−1 −

Br−1(sr−1, ·) ˆBr−1sr−1
Br−1(sr−1, sr−1)

(cid:35)

Γ−1
γ ,

(4)

and by the Sherman-Morrison-Woodbury lemma, that of the inverse:

Hr = Γγ

(cid:20)
G−1Hr−1G +

gxr−1 (sr−1, ·)sr−1
yr−1sr−1

(cid:21)

Γ−1
γ ,

where G = I −
Hessian. Details on these constructs can be found in [4], in addition to [17, 18].

, and ˆBr is the Lax-Milgram representation of the

gxr−1 (sr−1,·)ˆyr−1
yr−1sr−1

7

3.2.1 Trace and determinant bounds

To start off our convergence discussions for both convex and nonconvex cases, we
derive bounds for the trace and determinants of the Hessian approximations, followed
by those for their inverses. The techniques used to do so are straightforward ports of
the Euclidean originals [12], with some minor modiﬁcations to account for differential
geometric technicalities. Using the assumptions above, we can prove the following
bounds [4]:

r = (cid:0)H s+1

Lemma 1. Let Bs+1
be the approximation of the Hessian generated by
Algorithm 1, and ˆBs+1
be the corresponding Lax-Milgram representations.
Let M , the memory parameter, be the number of correction pairs used to update the
inverse Hessian approximation. Then, under Assumptions 1 and 2, we have:

(cid:1)−1
r
and ˆH s+1

r

r

tr( ˆBs+1
r

) ≤ tr( ˆBs+1

0

) + M Λ,

det( ˆBs+1

r

) ≥ det( ˆBs+1

0

)

Also, γI (cid:22) ˆH s+1

r (cid:22) ΓI, for some Γ ≥ γ > 0.

λM
) + ΛM )M

(tr( ˆBs+1

0

.

From a notational perspective, recall that our notation for the parallel transport
operator is Γγ, with the subscript denoting the geodesic. The symbols γ and Γ in
Lemma 1 above are unrelated to these geometric concepts, merely being the derived
bounds on the eigenvalues of inverse Hessian approximations. The proof is given in the
supplementary for completeness.

3.2.2 Convergence result for strongly convex functions

Our convergence result for strongly convex functions on the manifold can be stated as
follows:

Proposition 1. Let the Assumptions 1 and 2 hold. Further, let the f (·) in (5) be S-
strongly convex, and each of the fi be L-smooth, as deﬁned earlier. Deﬁne the following
constants: p = (cid:2)LS−1 + 2η2S−1 (cid:8)2ηL3Γ2 − Sκγ(cid:9)(cid:3), and q(cid:48) = 6η2L3Γ2S−1. Denote
the global optimum by x∗. Then the iterate xT +1 obtained after T outer loop iterations
will satisfy the following condition:

E (cid:2)f (xT +1) − f (x∗)(cid:3) ≤ LS−1βT E (cid:2)f (x0) − f (x∗)(cid:3) ,

where the constants are chosen to satisfy β = (1 − p)−1 (cid:0)q(cid:48) + pT (1 − p − q(cid:48))(cid:1) < 1
for linear convergence.

For proving this statement, we will use the L-smoothness (2) and S-strong convexity
(1) conditions mentioned earlier. As in the Euclidean case [10, 16], we will also require
a bound on the stochastic variance-reduced gradients. These can be bounded using
triangle inequalities and L-smoothness on Riemannian manifolds, as shown in [7].
This alternative is necessary since the Euclidean bound ﬁrst derived in [10], using the
difference of the objective function at the iterates, cannot be ported directly to manifolds
due to metric nonlinearities. Thus we take a different approach in our proof compared

8

to the Euclidean case of [16], using the interpoint distances deﬁned with the norms
of inverse exponential maps. We do not use trigonometric distance inequalities [3, 6]
for the convex case either, making the overall structure different from the proof of
Riemannian SVRG as well. The details are deferred to the supplementary due to space
limitations. However we do use the trigonometric inequality along with assumed lower
bounds on sectional curvature for showing convergence for nonconvex functions, as
described next.

3.2.3 Convergence for the nonconvex case

Here we provide a convergence result for nonconvex functions satisfying the following
condition: f (xt) − f (x∗) ≤ κ−1(cid:107)∇f (xt)(cid:107)2, which automatically holds for strongly
convex functions. We assume this to hold even if f is nonconvex, since it allows us to
show convergence of the iterates using (cid:107)∇f (xt)(cid:107)2. Further, similar to [2, 7] we assume
that the sectional curvature of the manifold is lower bounded by cδ. This allows us to
derive a trigonometric inequality analogous to the Euclidean case, where the sides of the
“triangle” are geodesics [6]. The details are given in the supplementary. Additionally,
we assume that the eigenvalues of the inverse Hessian are bounded by (γ, Γ) within
some suitable region around an optimum. The main result of this section may be stated
as follows:

Proposition 2. Let the sectional curvature of the manifold be bounded below by cδ,
and the fi be L-smooth. Let x∗ be an optimum of f (·) in (5). Assume the eigenvalues
of the inverse Hessian estimates are bounded. Set η2 = µ0/ (ΓLnα1 ηα2 ), K = mT ,
and m = (cid:98)n3α1/2/ (cid:0)3µ0ζ 1−2α2 (cid:1)(cid:99), where α1 ∈ (0, 1] and α2 ∈ [0, 2]. Then, for suitable
choices of the inverse Hessian bounds γ, Γ, we can ﬁnd values for the constants µ0 > 0
and (cid:15) > 0 so that the following holds:

E(cid:107)∇f (xT )(cid:107)2 ≤ (K(cid:15))−1Lηα1

2 ζ α2 (cid:0)f (x0) − f (x∗)(cid:1) .

(cid:16)

(cid:16)

(cid:17)(cid:17)−1

tanh

d(cid:112)|cδ|

ζ is deﬁned as ζ =

d(cid:112)|cδ| if cδ < 0, and 0 otherwise; d is an
upper bound on the diameter of the set U mentioned earlier, containing an optimum x∗.
The proof is inspired by similar results from both Euclidean [20] and Riemannian [7]
analyses, and is given in the supplementary. One way to deal with negative curvature
in Hessians in Euclidean space is by adding some suitable positive α to the diagonal,
ensuring bounds on the eigenvalues. Investigation of such “damping” methods in the
Riemannian context could be an interesting area of future work.

4 Experiments

4.1 Karcher mean computation for PD matrices

We begin with a synthetic experiment on learning the Karcher mean (centroid) [21]
of positive deﬁnite matrices. For a collection of matrices {Wi}N
i=1, the optimization

9

(a)

(b)

(c)

Figure 1: Error decay plots for rSV-LBFGS and rSVRG obtained from the three synthetic
Karcher mean computation experiments. Figures (a), (b) and (c) show the log-errors for
datasets with condition numbers 1e3, 1e2 and 10 respectively, plotted against number
of passes over full dataset for each algorithm. See text for full details.

problem can be stated as follows:

argmin
W(cid:23)0

(cid:40) N
(cid:88)

i=1

(cid:107) log

(cid:16)

W−1/2XiW−1/2(cid:17)

(cid:107)2
F

(cid:41)

.

We compare our minibatched implementation of the Riemannian SVRG algorithm
from [7], denoted as rSVRG, with the stochastic variance-reduced L-BFGS procedure
from Algorithm 1, denoted rSV-LBFGS. We implemented both algorithms using the
Manopt [22] and Mixest [23] toolkits. We generated three sets of random positive
deﬁnite matrices, each of size 100 × 100, with condition numbers 10, 1e2, and 1e3, and
computed the ground truths using code from [24]. Matrix counts were 100 for condition
number 1e − 2, and 1000 for the rest. Both algorithms used equal batchsizes of 50
for the ﬁrst and third datasets, and 5 for the second, and were initialized identically.
Both used learning rates satisfying their convergence conditions. In general we found
rSV-LBFGS to perform better with frequent correction pair calculations and a low
retention rate, ostensibly due to the strong convexity; therefore we used R = 1, M = 2
for all three datasets. As mentioned earlier, the zr correction pair was calculated using
Option 1: zr = Γγ (η2ρt) where ρt is calculated using the two-loop recursion. We
used standard retractions to approximate the exponential maps. The retraction formulae
for both symmetric PD and sphere manifolds used in the next section are given in the
supplementary. We calculated the error of iterate W as (cid:107)W − W∗(cid:107)2
F , with W∗ being
the ground truth. The log errors are plotted vs the number of data passes in Fig.1.
Comparing convergence speed in terms of # data passes is often the preferred approach
for benchmarking ML algorithms since it is an implementation-agnostic evaluation and
focuses on the key bottleneck (I/O) for big data problems. Comparisons of rSVRG with
Riemannian gradient descent methods, both batch and stochastic, can be found in [7].
From Fig.1, we ﬁnd rSV-LBFGS to converge faster than rSVRG for all three datasets.

4.2 Leading eigenvalue computation

Next we conduct a synthetic experiment on calculating the leading eigenvalue of matri-
ces. This of course is a common problem in machine learning, and as such is a unit-norm

10

(a)

(c)

(b)

(d)

Figure 2: Error decay plots for rSV-LBFGS, rSVRG and VR-PCA obtained for domi-
nating eigenvalue computation on four synthetic data matrices. Eigengaps were 0.005,
0.05, 0.01 and 0.1 for (a), (b), (c) and (d) respectively. See text for experimental details.

constrained nonconvex optimization problem in Euclidean space. It can be written as:

min
z∈Rd:zT z=1

−zT

(cid:32)

1
N

N
(cid:88)

i=1

(cid:33)

didT
i

z,

where Dd×N is the data matrix, and di are its columns. We can transform this into
an unconstrained manifold optimization problem on the sphere deﬁned by the norm
constraint. To that end, we generated four sets of datapoints, for eigengaps 0.005, 0.05,
0.01 and 0.1, using the techniques described in [8]. Each dataset contains 100, 000
vectors of dimension 1000. We used a minibatch size of 100 for the two Riemannian
algorithms. As before, learning rates for rSVRG were chosen according to the bounds
in [7]. Selecting appropriate values for the four parameters in rSV-LBFGS (the ﬁrst
and second-order learning rates, L and M ) was a nontrivial task; after careful grid
searches within the bounds deﬁned by the convergence conditions, we chose η1 =
0.001, η2 = 0.1, and M = 10 for all four datasets. L was set to 5 for the dataset with
eigengap 0.005, and 10 for the rest. The zr correction pair was calculated using Option
2: zr = Γγ (−η1νprev). We plot the performance of rSV-LBFGS, rSVRG and VR-PCA
in Fig.2. Extensive comparisons of VR-PCA with other Euclidean algorithms have been

11

conducted in [8]; we do not repeat them here. We computed the error of iterate z as
1 − (N e∗)−1 (cid:107)DT z(cid:107)2

2, e∗ being the ground truth obtained from Matlab’s eigs.

We see that the rSV-LBFGS method performs well on all four datasets, reaching
errors of the order of 1e − 15 well before VR-PCA and rSVRG in the last three cases.
The performance delta relative to VR-PCA is particularly noticeable in each of the
four cases; we consider this to be a noteworthy result for ﬁxed-stepsize algorithms on
Riemannian manifolds.

5 Conclusion

We propose a novel L-BFGS algorithm on Riemannian manifolds with variance reduced
stochastic gradients, and provide theoretical analyses for strongly convex functions on
manifolds. We conduct experiments on computing Riemannian centroids for symmetric
positive deﬁnite matrices, and calculation of leading eigenvalues, both using large scale
datasets. Our algorithm outperforms other Riemannian optimization algorithms with
ﬁxed stepsizes in both cases, and performs noticeably better than one of the fastest
stochastic algorithms in Euclidean space, VR-PCA, for the latter case.

References

[1] P. A. Absil, R. Mahony, and R. Sepulchre. Optimization Algorithms on Matrix

Manifolds. Princeton University Press, 2008.

[2] H. Zhang and S. Sra. First-order methods for geodesically convex optimization.

In COLT, 2016.

[3] S. Sra and R. Hosseini. Conic geometric optimization on the manifold of positive

deﬁnite matrices. SIAM Journal on Optimization, 25(1):713–739, 2015.

[4] W. Ring and B. Wirth. Optimization methods on Riemannian manifolds and their
application to shape space. SIAM Journal on Optimization, 22(2):596–627, 2012.

[5] H. Robbins and S. Monro. A Stochastic Approximation Method. The Annals of

Mathematical Statistics, 22(3):400–407, 1951.

[6] S. Bonnabel. Stochastic gradient descent on Riemannian manifolds. IEEE Trans-

actions on Automatic Control, 58(9):2217–2229, 2013.

[7] H. Zhang, S. J. Reddi, and S. Sra. Riemannian SVRG: Fast stochastic optimization

on Riemannian manifolds. In NIPS, 2016.

[8] O. Shamir. A Stochastic PCA and SVD Algorithm with an Exponential Conver-

gence Rate. In ICML, 2015.

[9] E. Oja. Principal components, minor components, and linear neural networks.

Neural Networks, 5(6):927–935, 1992.

12

[10] R. Johnson and T. Zhang. Accelerating Stochastic Gradient Descent using Predic-

tive Variance Reduction. In NIPS, 2013.

[11] D. C. Liu and J. Nocedal. On the limited memory BFGS method for large scale

optimization. Mathematical Programming, 45(1–3):503–528, 1989.

[12] J. Nocedal and S. J. Wright. Numerical Optimization. Springer, 2006.

[13] L. Bottou and Y. LeCun. Large scale online learning. In NIPS, 2004.

[14] L. Bottou. Large-scale machine learning with stochastic gradient descent. In

International Conference on Computational Statistics, 2010.

[15] R. H. Byrd, S. L. Hansen, J. Nocedal, and Y. Singer. A Stochastic Quasi-Newton

Method for Large-scale Optimization, 2014. arXiv:1410.1068.

[16] P. Moritz, R. Nishihara, and M. I. Jordan. A Linearly-Convergent Stochastic

L-BFGS Algorithm. In AISTATS, 2016.

[17] J. Lee. Riemann Manifolds: an Introduction to Curvature. Springer-Verlag, 1997.

[18] W. M. Boothby. An Introduction to Differentiable Manifolds and Riemannian

Geometry. Academic Press Inc., 1986.

[19] R. Hosseini and S. Sra. Matrix Manifold Optimization for Gaussian Mixtures. In

NIPS, 2015.

[20] S. J. Reddi, A. Hefny, S. Sra, B. Póczós, and A. Smola. Stochastic Variance

Reduction for Nonconvex Optimization. In ICML, 2016.

[21] R. Bhatia. Positive Deﬁnite Matrices. Princeton University Press, 2007.

[22] N. Boumal, B. Mishra, P.-A. Absil, and R. Sepulchre. Manopt, a Matlab toolbox for
optimization on manifolds. Journal of Machine Learning Research, 15:1455–1459,
2014.

[23] R. Hosseini and M. Mash’al. Mixest: An Estimation Toolbox for Mixture Models,

2015. arXiv:1507.06065.

[24] D. A. Bini and B. Iannazzo. Computing the Karcher mean of symmetric positive
deﬁnite matrices. Linear Algebra and its Applications, 483(4):1700–1710, 2013.

[25] A. Mokhtari and A. Ribeiro. Global Convergence of Online Limited Memory

BFGS. Journal of Machine Learning Research, 16(1):3151–3181, 2015.

13

6 Appendices

We present the convergence results from Propositions 1 and 2 in the main text in this
section.

6.1 Analysis of convergence

We analyze convergence for ﬁnite-sum empirical risk minimization problems of the
following form:

min
x∈M

f (x) =

1
N

N
(cid:88)

i=1

fi(x),

(5)

where the Riemannian manifold is denoted by M. Note that the iterates are updated in
Algorithm 1 by taking the exponential map of the descent step multiplied by the stepsize,
with the descent step computed as the product of the inverse Hessian estimate and the
stochastic variance-reduced gradient using the standard two-loop recursion formula.
Thus, to bound the optimization error using the iterates, we will need bounds on both
the stochastic gradients and the inverse Hessians. As mentioned in [7], the methods
used to derive the former bounds for Euclidean algorithms cannot be ported directly
to manifolds due to metric nonlinearities; see the proof of Proposition 1 for details.
For the latter, we follow the standard template for L-BFGS algorithms in the literature
[4, 12, 15]. To begin, we make the following assumptions:

Assumption 1. The function f in (5) is strongly convex on the manifold, whereas

the fis are individually convex.

Assumption 2. There exist λ, Λ ∈ (0, ∞), λ < Λ s.t. λ(cid:107)ν(cid:107)2
x ∀ν ∈ TxM.

Λ(cid:107)ν(cid:107)2

x ≤ D2f ≤

These two assumptions allow us to (a) guarantee that f has a unique minimizer x∗
in the convex sublevel set U , and (b) derive bounds on the inverse Hessian updates using
BFGS update formulae for the Hessian approximations. Similar to the Euclidean case,
these can be written as follows:

ˆBr = Γγ

(cid:34)
ˆBr−1 −

Br−1(sr−1, ·) ˆBr−1sr−1
Br−1(sr−1, sr−1)

(cid:35)

Γ−1
γ ,

(6)

and by the Sherman-Morrison-Woodbury lemma, that of the inverse:

Hr = Γγ

(cid:20)
G−1Hr−1G +

gxr−1 (sr−1, ·)sr−1
yr−1sr−1

(cid:21)

Γ−1
γ ,

where G = I −
Hessian [4].

gxr−1 (sr−1,·)ˆyr−1
yr−1sr−1

. The ˆBr is the Lax-Milgram representation of the

6.1.1 Trace and determinant bounds

To start off our convergence discussions for both convex and nonconvex cases, we
derive bounds for the trace and determinants of the Hessian approximations, followed

14

by those for their inverses. The techniques used to do so are straightforward ports of
the Euclidean originals [12], with some minor modiﬁcations to account for differential
geometric technicalities. Using the assumptions above, we can prove the following
bounds [4]:

r = (cid:0)H s+1

Lemma 1. Let Bs+1
be the approximation of the Hessian generated by
Algorithm 1, and ˆBs+1
be the corresponding Lax-Milgram representations.
Let M , the memory parameter, be the number of correction pairs used to update the
inverse Hessian approximation. Then, under Assumptions 1 and 2, we have:

(cid:1)−1
r
and ˆH s+1

r

r

tr( ˆBs+1
r

) ≤ tr( ˆBs+1

0

) + M Λ,

det( ˆBs+1

r

) ≥ det( ˆBs+1

0

)

λM
) + ΛM )M

(tr( ˆBs+1

0

.

Also, γI (cid:22) ˆH s+1

r (cid:22) ΓI, for some Γ ≥ γ > 0.

Proof. For brevity of notation we temporarily drop the (s + 1) superscript. The proof
for the Euclidean case [15, 25] can be generalized to the Riemannian scenario in a
straightforward way, as follows. Deﬁne the average Hessian Gr by

Gr(·, ·) =

1
(cid:90)

0

D2[f (tzr)](·, ·)dt,

such that yr = Gr(zr, ·). Then, it can be easily shown that Gr satisﬁes the bounds in
Assumption 2. Furthermore, we have the following useful inequalities

yrzr
(cid:107)zr(cid:107)2 =

Gr(sr, sr)

(cid:107)zr(cid:107)2 ≥ λ,

(cid:107)yr(cid:107)2
yrzr

≤ Λ.

(7)

Let ˆyr be the Riesz representation of yr. Recall that parallel transport is an isometry
along the unique geodesics, which implies invariance of the trace operator. Then
using the L-BFGS update (6) and (7), we can bound the trace of the Lax-Milgram
representation of the Hessian approximations as follows:

tr( ˆBr) = tr(Γγ ˆBr−1Γ−1

γ ) −

≤ tr(Γγ ˆBr−1Γ−1

γ ) +

≤ tr(B0) + M Λ.

+

(cid:107)Γγ ˆyr−1(cid:107)2
yr−1sr−1

(cid:107)Γγ ˆBr−1sr−1(cid:107)2
Br−1(sr−1, sr−1)
(cid:107)Γγ ˆyr−1(cid:107)2
yr−1sr−1

This therefore proves boundedness of the largest eigenvalue of the ˆBr estimates.

Similarly, to get a lower bound for the minimum eigenvalue, we bound the determi-

15

nant as follows:

det( ˆBr) = det(ΓγBr−1Γ−1

γ ) · det

I −

(cid:32)

ˆBr−1sr−1sr−1
Br−1(sr−1, sr−1)

+ ˆB−1
r−1

yr−1yr−1
yr−1sr−1

(cid:33)

= det(ΓγBr−1Γ−1
γ )

= det(ΓγBr−1Γ−1
γ )

≥ det(ΓγBr−1Γ−1
γ )

yr−1sr−1
Br−1(sr−1, sr−1)
yr−1sr−1
(cid:107)sr−1(cid:107)2 ·
λ
λmax(Br−1)

,

(cid:107)sr−1(cid:107)2
Br−1(sr−1, sr−1)

where we use λmax to denote the maximum eigenvalue of Br−1, and use (7). Since λmax
is bounded above by the trace of ( ˆBr), we can telescope the inequality above to get

det( ˆBr) ≥ det(B0)

λM
(tr(B0) + M Λ)M .

The bounds on the maximum and minimum eigenvalues of Br thus derived allows us to
infer corresponding bounds for those of Hr as well, since by deﬁnition Hr = ˆB−1

.

r

6.1.2 Convergence results for the strongly convex case

Next we provide a brief overview of the bounds necessary to prove our convergence
result. First, note the following bound implied by the Lipschitz continuity of the
gradients:

f (xs+1

t+1 ) ≤ f (xs+1

t

) + g(∇f (xs+1

t

), Exp−1

xs+1
t

(xs+1

t+1 )) +

L
2

(cid:107)Exp−1

xs+1
t

(xs+1

t+1 )(cid:107)2.

Note the update step fom line 11 of Algorithm 1: xs+1
). We
can replace the inverse exponential map in the inner product above by the quantity in the
parentheses. In order to replace H s+1
by the eigen-bounds from Lemma 1, we invoke
the following result (Lemma 5.8 from [17]:
Lemma 2. For any D ∈ TxM and c, t ∈ R, γcD(t) = γD(ct),

t+1 = Expxs+1

(−ηH s+1

νs+1
t

r

r

t

where ν is the “speed” of the geodesic. This allows us to write Expx(cν) = γν(c) =
γcν(1). Recall that for Riemann geodesics we have (cid:107) ˙γ(t)(cid:107) = ¯s for all t ∈ [0, 1], a
constant.

Proposition 1. Let the Assumptions 1 and 2 hold. Further, let the f (·) in (5) be S-
strongly convex, and each of the fi be L-smooth, as deﬁned earlier. Deﬁne the following
constants: p = (cid:2)LS−1 + 2η2S−1 (cid:8)2ηL3Γ2 − Sκγ(cid:9)(cid:3), and q(cid:48) = 6η2L3Γ2S−1. Denote
the global optimum by x∗. Then the iterate xT +1 obtained after T outer loop iterations
will satisfy the following condition:

E (cid:2)f (xT +1) − f (x∗)(cid:3) ≤ LS−1βT E (cid:2)f (x0) − f (x∗)(cid:3) ,

where the constants are chosen to satisfy β = (1 − p)−1 (cid:0)q(cid:48) + pT (1 − p − q(cid:48))(cid:1) < 1
for linear convergence.

16

Proof. From the L-smoothness condition (2), we have the following:

f (xt+1

i+1) ≤ f (xt+1

i

(cid:16)

) + g

∇f (xt+1

i

) · Exp−1
xt+1
i

(xt+1
i+1)

(cid:107)Exp−1
xt+1
i

(xt+1

i+1)(cid:107)2

= f (xt+1

i

) − η2 · g (cid:0)∇f (xt+1

i

), H t+1
r

νt+1
i

(cid:1) +

(cid:107)H t+1
r

νt+1
i

(cid:107)2,

(cid:17) L
2
Lη2
2
2

where we have omitted subscripts from the metric. Taking expectations, and using the
bounds on the inverse Hessian estimates derived in Lemma 1, we have the following:

Ef (xt+1

i+1) ≤ Ef (xt+1

i

) − η2γ(cid:107)∇f (xt+1

i

)(cid:107)2 + η2

2L3Γ2 (cid:104)

2(cid:107)Exp−1
xt+1
i

(x∗)(cid:107)2 + 3(cid:107)Exp−1

xt (x∗)(cid:107)2(cid:105)
(8)

,

where we have used the following bound on the stochastic variance-reduced gradients
derived in [7]:

E(cid:107)νt+1
i

(cid:107)2 ≤ 4L2(cid:107)Exp−1
xt+1
i

(x∗)(cid:107)2 + 6L2(cid:107)Exp−1

xt (x∗)(cid:107)2.

This can be derived using triangle inequalities and the L-smoothness assumption. Note
that the bound is different from the Euclidean case [10], due to technicalities introduced
by the Riemannian metric not being linear in general.

Now, recall the condition f (xt) − f (x∗) ≤ 2κ)−1(cid:107)∇f (xt)(cid:107)2, which follows from

strong convexity. Using this, we can derive a bound on the ∇ term in (8) as follows:

(cid:107)∇f (xt+1

i

)(cid:107)2 ≥ 2κ (cid:0)f (xt+1

i

) − f (x∗)(cid:1) ≥ Sκ(cid:107)Exp−1
xt+1
i

(x∗)(cid:107)2,

where the second inequality follows from S-strong convexity (1), since ∇f (x∗) = 0.
Plugging this into (8), we have the following:

Ef (xt+1

i+1) ≤ f (xt+1

i

) + η2

(cid:2)2ηL3Γ2 − Sκγ(cid:3) (cid:107)Exp−1
xt+1
i

(x∗)(cid:107)2

+ 3η2

2L3Γ2(cid:107)Exp−1

xt (x∗)(cid:107)2.

(9)

Now, note that S-strong convexity allows us to write the following:

S
2

(cid:107)Exp−1
xt+1
i+1

(x∗)(cid:107)2 ≤ f (xt+1
= (cid:2)f (xt+1

i+1) − f (x∗)
i+1) − f (xt+1

i

≤ (cid:2)f (xt+1

i+1) − f (xt+1

i

i

)(cid:3) + (cid:2)f (xt+1
L
2

)(cid:3) +

(cid:107)Exp−1
xt+1
i

) − f (x∗)(cid:3)

(x∗)(cid:107)2,

where the last step follows from L-smoothness. Taking expectations of both sides, and
using (9) for the ﬁrst component on the right, we have

E(cid:107)Exp−1
xt+1
i+1

(x∗)(cid:107)2 ≤

(cid:8)2ηL3Γ2 − Sκγ(cid:9)

(cid:21)

(cid:107)Exp−1
xt+1
i+1

(x∗)(cid:107)2

(10)

+

(cid:20) L
S
6η2

+

2η2
S
2L3Γ2
S

(cid:107)Exp−1

xt (x∗)(cid:107)2.

17

Now, we denote p = (cid:2) L
. Then, taking
expectations over the sigma algebra of all the random variables till minibatch m, and
some algebra, it can be shown that:

(cid:8)2ηL3Γ2 − Sκγ(cid:9)(cid:3), and q(cid:48) = 6η2

S + 2η2

2 L3Γ2
S

S

E(cid:107)Exp−1
xt+1
m

(x∗)(cid:107)2 − qE(cid:107)Exp−1
xt+1
0

(x∗)(cid:107)2 ≤ pm (1 − q) (cid:107)Exp−1
xt+1
0

(x∗)(cid:107)2,

where q = (1 − p)−1q(cid:48). Note that this provides a bound on the iterate at the end of the
inner minibatch loop. Telescoping further, we have the bound

E(cid:107)Exp−1

xT +1(x∗)(cid:107)2 ≤ βT E(cid:107)Exp−1

x0 (x∗)(cid:107)2,

where β = q(cid:48)+pT (1−p−q(cid:48))
and S-strong convexity conditions, we have the bounds

1−p

. Then, using this result with a ﬁnal appeal to the L-Lipschitz

E (cid:2)f (xT +1) − f (x∗)(cid:3) ≤

≤

L
2
L
S

E(cid:107)Exp−1

xT +1(x∗)(cid:107)2

βT (cid:2)f (x0) − f (x∗)(cid:3) ,

thereby completing the proof.

6.1.3 Convergence results for the nonconvex case

We begin with the following inequality involving the side lengths of a geodesic “triangle”
[3, 6]:

Lemma 3. Let the sectional curvature of a Riemannian manifold be bounded below
by cδ. Let A be the angle between sides of length b and c in a triangle on the manifold,
with the third side of length a, as usual. Then the following holds:

a2 ≤

c(cid:112)|cδ|
(cid:16)

c(cid:112)|cδ|

tanh

(cid:17) b2 + c2 − 2bc cos A.

The cosine is deﬁned using inner products, as in the Euclidean case, and the distances
using inverse exponential maps, as seen above. The following sequence of results and
proofs are inspired by the basic structure of [20], with suitable modiﬁcations involving
the inverse Hessian estimates from the L-BFGS updates.

Lemma 4. Let the assumptions of Proposition 2 hold. Deﬁne the following functions:

ci = ci+1

(cid:0)1 + βη2Γ + 2ζL2η2

δi = η2γ −

ci+1η2Γ
β

− Lη2

2Γ2(cid:1) + L3η2
2Γ − 2ci+1ζη2

2Γ2,

2Γ2 > 0,

where ci, ci+1, β, η2 > 0. Further, for 0 ≤ t ≤ T − 1, deﬁne the Lyapunov function
i = E (cid:2)f (xt+1
Rt+1

)(cid:107)2(cid:3). Then we have the following bound:

) + ci(cid:107)Exp−1

xt (xt+1

i

i

Rt+1

i − Rt+1
δi

i+1

.

E(cid:107)∇f (xt+1

i

)(cid:107)2 ≤

18

Proof. As with the proof of Proposition 1, we begin with the following bound derived
from L-smoothness:

Ef (xt+1

i+1) ≤ E

(cid:20)
f (xt+1
i

) − η2γ(cid:107)∇f (xt+1

i

)(cid:107)2 +

Lη2
2Γ2
2

(cid:107)νt+1
i

(cid:107)2

(cid:21)

,

where we have bound the bounds on the inverse Hessian derived earlier. Then using
Lemma 3 above, we have:

E(cid:107)Exp−1

xt (xt+1

i+1)(cid:107)2 ≤ E(cid:107)Exp−1
≤ E (cid:2)(cid:107)Exp−1

i

xt (xt+1
xt (xt+1
(cid:20)
(2β)−1(cid:107)∇f (xt+1

)(cid:107)2 + ζ(cid:107)Exp−1
xt+1
i
2Γ2(cid:107)νt+1
β
2

)(cid:107)2 + ζη2

)(cid:107)2 +

i

i

i

(xt+1
i+1)(cid:107)2 − 2g
(cid:107)2(cid:3)

(cid:107)Exp−1

xt (xt+1

i

(cid:21)

,

)(cid:107)2

+ 2η2Γ

(cid:16)

Exp−1
xt+1
i

(xt+1

i+1), Exp−1
xt+1
i

(cid:17)

(x∗)

where we have used g(a, b) ≤ 1
2 (cid:107)b(cid:107)2. Note that we have used the norm of the
inverse exponential maps as the side lengths in Lemma 3. Using these last two results,
we can derive the following bound for the Lyapunov functions Rt+1
i+1:

2β (cid:107)a(cid:107)2 + β

Rt+1

i+1 ≤ E

(cid:26)

) −

(cid:20)
f (xt+1
i

ci+1η2Γ
β
+ ci+1 {1 + η2Γβ} E(cid:107)Exp−1
xt (xt+1

η2γ −

(cid:27)

i

)(cid:107)2.

(cid:107)∇f (xt+1

i

(cid:21)

)(cid:107)2

+ Γ2

(cid:26)

ci+1ζη2

2 +

(cid:27)

Lη2
2
2

E(cid:107)νt+1
i

(cid:107)2

The norm of the stochastic variance reduced gradient can be bounded as follows [7, 20]:

E(cid:107)νt+1
i

(cid:107)2 ≤ 2L2E(cid:107)Exp−1

xt (xt+1

i

)(cid:107)2 + 2E(cid:107)∇f (xt+1

i

)(cid:107)2.

This allows us to bound the Lyapunov function above as:

Rt+1

i+1 ≤ Rt+1

i −

(cid:26)

η2γ −

ci+1η2Γ
β

− Lη2

2Γ2 − 2ci+1ζη2

2Γ2

(cid:27)

E(cid:107)∇f (xt+1

i

)(cid:107)2,

which completes the proof.

Next we present a bound on (cid:107)∇f (·)(cid:107)2 using the δi’s deﬁned above (Thm 6 of [7]):

Lemma 5. Let the conditions of Lemma 4 hold, and deﬁne the quantities therein. Let
δi > 0 ∀i ∈ [0, m], and cm = 0. Let δδ = mini δi, and K = mT . Then if we randomly
(cid:9)m
return one of the iterates (cid:8)xt+1
i=1 as xt+1, then:

i

E(cid:107)∇f (xt)(cid:107)2 ≤

f (x0) − f (x∗)
Kδδ

.

This result can be shown by telescoping the bound derived in the previous lemma

for the Lyapunov functions, using cm = 0.

Proposition 2. Let the sectional curvature of the manifold be bounded below by cδ,
and the fi be L-smooth. Let x∗ be an optimum of f (·) in (5). Assume the eigenvalues
of the inverse Hessian estimates are bounded. Set η2 = µ0/ (ΓLnα1 ηα2 ), K = mT ,

19

and m = (cid:98)n3α1/2/ (cid:0)3µ0ζ 1−2α2 (cid:1)(cid:99), where α1 ∈ (0, 1] and α2 ∈ [0, 2]. Then, for suitable
choices of the inverse Hessian bounds γ, Γ, we can ﬁnd values for the constants µ0 > 0
and (cid:15) > 0 so that the following holds:

E(cid:107)∇f (xT )(cid:107)2 ≤ (K(cid:15))−1Lηα1

2 ζ α2 (cid:0)f (x0) − f (x∗)(cid:1) .

Proof. We deﬁne β = Lζ 1−α2/ (cid:0)nα1/2Γ(cid:1). Also, as mentioned in the proposition,
η2 = µ0/ (ΓLnα1 ηα2 ), with appropriate α1, α2. Note that we need a bound for δδ to
plug in the denominator of the bound in Lemma 5 above. This quantity can be lower
bounded as follow:

δδ = min

i

δi
(cid:26)

= min

i
(cid:26)

≥

η2γ −

η2γ −

ci+1η2Γ
β

− Lη2

2Γ2 − 2ci+1ζ 2η2

2Γ2

(cid:27)

c0η2Γ
β

− Lη2Γ2 − 2c0ζη2

2Γ2

(cid:27)

.

Now we need to bound c0. To that end, telescoping the ci+1 function deﬁned in Lemma
4 above with cm = 0, and denoting θ = η2βΓ + 2ζη2

2L2Γ2, we get the following:

c0 =

Lµ2

0 {( 1 + θ)m − 1}
n2α1 ζ 2α2θ

.

Using the deﬁnitions of η2 and β above, we note that θ < 1/m, implying c0 ≤
Lµ0
ζnα1/2 (e − 1). Plugging this in the bound above, we posit that δδ can be bounded below
as follows:

(cid:26)

δδ ≥ η2

γ −

µ0Γ(e − 1)
ζ 2−α2

−

µ0
nα2 ζ α2

−

2µ2
0(e − 1)
n3α1/2ζ α2

(cid:27)

≥

(cid:15)
Lnα1ζ α2

,

for some sufﬁciently small (cid:15), and suitable choices of the inverse Hessian bounds γ, Γ
and the rest of the parameters. Using this bound in the denominator of the right hand
side of Lemma 5 above completes the proof.

6.2 Retractions

We approximated the exponential maps with retractions from the Manopt [22] toolbox.
We used the following formulae: Rx(ηρ) = x cos (cid:107)ηρ(cid:107)F + ηρ
sin (cid:107)ηρ(cid:107)F for the
(cid:107)ηρ(cid:107)F
sphere manifold, and Rx(ηρ) = x · Mx(x \ ηρ) for the manifold of symmetric PD
matrices, where Mx denotes the matrix exponential, and \ is matrix division. Here
x ∈ M is some point on the manifold, ρ ∈ TxM is some descent step evaluated at x,
and η is the stepsize.

20

