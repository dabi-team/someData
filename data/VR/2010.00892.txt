0
2
0
2

t
c
O
2

]

G
L
.
s
c
[

1
v
2
9
8
0
0
.
0
1
0
2
:
v
i
X
r
a

Variance-Reduced Methods for Machine Learning

a
Robert M. Gower

b
, Mark Schmidt

c
, Francis Bach

d
, and Peter Richtárik

aLTCI, Télécom Paris, Institut Polytechnique de Paris ; cInria - PSL Research University, France; bUniversity of British Columbia, CCAI Afﬁliate Chair (Amii), Canada; dKing
Abdullah University of Science and Technology, Kingdom of Saudi Arabia

Stochastic optimization lies at the heart of machine learning, and
its cornerstone is stochastic gradient descent (SGD), a method intro-
duced over 60 years ago. The last 8 years have seen an exciting
new development: variance reduction (VR) for stochastic optimiza-
tion methods. These VR methods excel in settings where more than
one pass through the training data is allowed, achieving a faster con-
vergence than SGD in theory as well as practice. These speedups
underline the surge of interest in VR methods and the fast-growing
body of work on this topic. This review covers the key principles and
main developments behind VR methods for optimization with ﬁnite
data sets and is aimed at non-expert readers. We focus mainly on
the convex setting, and leave pointers to readers interested in exten-
sions for minimizing non-convex functions.

optimization, machine learning, variance reduction

the form [2], including L1-regularized least squares, support
vector machines, principal component analysis, conditional
random ﬁelds, and deep neural networks.

A key challenge in modern instances of problem [2] is that
the number of data points n can be extremely large. We regu-
larly collect datasets going beyond terabytes, from sources such
as the internet, satellites, remote sensors, ﬁnancial markets,
and scientiﬁc experiments. One of the most common ways
to cope with such large datasets is to use stochastic gradient
descent (SGD) methods, which use a few randomly chosen data
points in each of their iterations. Further, there has been a
recent surge in interest in variance-reduced (VR) stochastic
gradient methods which converge faster than classic stochastic
gradient methods.

1. Introduction

One of the fundamental problems studied in the ﬁeld of ma-
chine learning is how to ﬁt models to large datasets. For
example, consider the classic linear least squares model,

Stochastic variance-reduced methods are as cheap to
update as SGD, and also have a fast exponential con-
vergence like full gradient descent.

x? ∈ argmin

x∈Rd

(

1
n

n
X

(a>

2
i x − bi)

)

.

[1]

i=1

Here, the model has d parameters given by the vector x ∈ Rd
and we are given n data points {ai, bi} consisting of feature
vectors ai ∈ Rd and target values (labels) bi ∈ R. Fitting
the model consists of tuning these d parameters so that the
model’s output a>
i x is “close” (on average) to the targets
bi. More generally, we might use some loss function fi(x) to
measure how close our model is to the i-th data point,

(

x? ∈ argmin

f (x) :=

x∈Rd

)

fi(x)

.

1
n

n
X

i=1

[2]

If fi(x) is large, we say that our model’s output is far from the
data, and if fi(x) = 0 we say that our model ﬁts perfectly the
i-th data point. The function f (x) represents the average loss
of our model over the full dataset. A problem of the form [2]
characterizes the training of not only linear least squares, but
many models studied in machine learning. For example, the
logistic regression model solves

x? ∈ argmin

x∈Rd

(

1
n

n
X

i=1

log(1 + exp(−bia>

i x)) +

)

2

kxk

,

[3]

λ
2

where we are now considering a binary classiﬁcation task with
bi ∈ {−1, +1} (and predictions are made using the sign of
a>
i x). Here, we have also used λ
i , as a
regularizer. This and other regularizers are commonly added
to avoid overﬁtting to the given data, and in this case we
replace each fi(x) by fi(x) + λ
. The training procedure
in most supervised machine learning models can be written in

i=1 x2

:= λ
2

2 kxk

2 kxk

Pd

2

2

Fig. 1. Comparison of the GD, AGD (Accelerated GD (Nesterov, 1983)),
SGD and ADAM (Kingma and Ba, 2015) methods to the VR methods SAG
and SVRG on a logistic regression problem based on the mushrooms data
set (Chang and Lin, 2011), where n = 8, 124 and d = 112.

A. Gradient and Stochastic Gradient Descent. The classic GD
(gradient descent) method applied to problem [2] takes the
form

xk+1 = xk − γ

1
n

n
X

i=1

∇fi(xk),

[4]

where γ > 0 is a ﬁxed stepsize∗. At each iteration the GD
method needs to calculate a gradient ∇fi(xk) for every ith

∗

The classic way to implement GD is to determine γ as the approximate solution to
minγ>0 f (xk − γ∇f (xk)). This is called a line search since it is an optimization over a
line segment (Armijo, 1966; Malitsky and Mishchenko, 2019). This line search requires multiple

2To whom correspondence should be addressed. E-mail: gower.robert@gmail.com

Proceedings of the IEEE | October 5, 2020 | Vol. XXX | No. XXX | 1–15

 
 
 
 
 
 
The reason why SGD does not converge in this example is
because the stochastic gradients themselves do no converge to
zero, and thus the method [5] with a constant stepsize never
stops. This is in contrast with GD, where the method naturally
stops since ∇f (xk) → 0 as xk → x?.

C. Classic Variance Reduction Methods. There are several
classic techniques for dealing with the non-convergence due
to the variance in the ∇fi(xk) values. For example, Robbins
and Monro (1951) address the issue of the variance using a
sequence of decreasing stepsizes γk. This forces the product
γk∇fik (xk) to converge to zero. However it is diﬃcult to tune
this sequence of decreasing stepsizes so that the method does
not stop to early (before reaching the solution) or to late (thus
wasting resources).

Another classic technique for decreasing the variance is to
use the average of several ∇fi(xk) values in each iteration to
get a better estimate of the full gradient ∇f (x). This is called
mini-batching, and is especially useful when multiple gradients
can be evaluated in parallel. This leads to an iteration of the
form

xk+1 = xk − γ

∇fi(xk),

[7]

1
|Bk|

X

i∈Bk

where Bk ⊂ {1, . . . , n} is a set of random indices and |Bk| is the
size of Bk. When Bk is sampled uniformly with replacement,
the variance of this gradient estimator is inversely proportional
to the “batch size” |Bk|, so we can decrease the variance by
increasing the batch size.† However, the cost of this iteration
is proportional to the batch size. Thus, this form of variance
reduction comes at a computational cost.

Yet another common strategy to decrease variance and im-
prove the empirical performance of SGD is to add “momentum”,
an extra term based on the directions used in past steps. In
particular, SGD with momentum takes the form

mk = βmk−1 + ∇fik (xk)

xk+1 = xk − γmk,

[8]

[9]

where the momentum parameter β is in the range (0, 1). Set-
ting m0 = 0 and expanding the update of mk in [8] we have
that mk is a weighted average of the previous gradients,

mk =

k
X

t=0

βk−t∇fit (xt).

[10]

1−β

Pn

1−β , we have that

t=0 βk−t = 1−βk+1

i=1 ∇fi(xk), we can interpret 1−β

Thus mk is a weighted sum of the stochastic gradients. More-
over since Pk
1−βk−1 mk is a
weighted average of stochastic gradients. If we compare this
with the expression of the full gradient which is a plain average,
∇f (xk) = 1
1−βk mk (and
n
mk) as an estimate of the full gradient. This weighted sum
decreases the variance but it also brings about a key problem:
Since the weighted sum [10] gives more weight to recently
sampled gradients, it does not converge to the full gradient
∇f (xk) which is a plain average. The ﬁrst variance reduced
method we will see in Section 2.A contours this issue by using
a plain average, as opposed to any weighted average.

Fig. 2. Level set plot of 2D logistic regression with the iterates of SGD (left) and SAG
(right) with constant stepsize. The green star is the x∗ solution.

data point, and thus GD takes a full pass over the n data points
at each iteration. This expensive cost per iteration makes GD
prohibitive when n is large.

Consider instead the stochastic gradient descent (SGD)

method,

xk+1 = xk − γ∇fik (xk),

[5]

ﬁrst introduced by Robbins and Monro (1951). It avoids the
heavy cost per iteration of GD by using one randomly-selected
∇fik (xk) gradient instead of the full gradient. In Figure 1, we
see how the SGD method makes dramatically more progress
than GD (and even the “accelerated” GD method) in the initial
phase of optimization. Note that this ﬁgure plots the progress
in terms of the number of epochs, which is the number of times
we have computed n gradients of individual training examples.
The GD method does one iteration per epoch while the SGD
method does n iterations per epoch. We compare SGD and
GD in terms of epochs taken since we assume that n is very
large and that the main cost of both methods is computing
the ∇fi(xk) gradients.

B. The Issue with Variance. Observe that if we choose the
random index ik ∈ {1, . . . , n} uniformly, P [ik = i] = 1
n for
all i, then ∇fik (xk) is an unbiased estimate of ∇f (xk) since

E [∇fik (xk) | xk] =

n
X

i=1

1
n

∇fi(xk) = ∇f (xk).

[6]

Thus, even though the SGD method is not guaranteed to de-
crease f in each iteration, on average the method is moving in
the direction of the negative full gradient, which is a direction
of descent.

Unfortunately, having an unbiased estimator of the gradient
is not enough to guarantee convergence of the iterates [5] of SGD.
To illustrate this, in Figure 2 (left) we have plotted the iterates
of SGD with a constant stepsize applied to a logistic regression
function using the fourclass data set from LIBSVM (Chang
and Lin, 2011). The concentric ellipses in Figure 2 are the
level sets of this function, that is, the points x on a single
ellipse are given by {x : f (x) = c} for a particular constant
c ∈ R. Diﬀerent constants c give diﬀerent ellipses.

The iterates of SGD do not converge to the solution (the
green star), and instead form a point cloud around the solution.
In contrast, we have plotted the iterates of a VR method SAG
(that we present later) in Figure 2 using the same constant
stepsize.

evaluations of the full objective function f (xk), which in our setting is too expensive since this
would require loading all the data points multiples times. This is why we use ﬁxed constant stepsize
instead.

†

If we sample without replacement the variance decreases at a faster rate (see Section 2.7 in Lohr
(1999)), and with |Bk| = n the variance is zero.

2 |

et al.

D. Modern Variance Reduction Methods. As opposed to clas-
sic methods that use one or more ∇fi(xk) directly as an ap-
proximation of ∇f (xk), variance-reduced methods use ∇fi(xk)
to update an estimate gk ∈ Rd of the gradient so that
gk ≈ ∇f (xk). With this gradient estimate, we then take
approximate gradient steps of the form

F. Faster Convergence of VR Methods. In this section we in-
troduce two standard assumptions that are used to analyze
VR methods, and discuss the speedup over classic SGD meth-
ods that can be obtained under these assumptions. Our ﬁrst
assumption is Lipschitz continuity of the gradients, meaning
that the gradients cannot change arbitrarily fast.

xk+1 = xk − γgk,

[11]

Assumption 1.1. The function f is diﬀerentiable
and L-smooth, meaning that

where γ > 0 is again the stepsize. To make [11] converge with
a constant stepsize, we need to ensure that the variance of our
gradient estimate gk converges to zero, that is‡

E (cid:2)kgk − ∇f (xk)k

2(cid:3) −→

k→∞

0,

[12]

where the expectation is taken with respect to all the random
variables in the algorithm up to iteration k. Property [12]
ensures that the VR method will stop when reaching the optimal
point. We take [12] to be a deﬁning property of variance-
reduced methods and thus refer to it as the VR property. Note
that “reduced” variance is a bit misleading since the variance
converges to zero. The property [12] is responsible for the
faster convergence of VR methods in theory (under suitable
assumptions) and in practice as we see in Figure 1.

E. First example of a VR method: SGD?. One easy ﬁx that
makes the SGD recursion in [5] converge without decreasing
the stepsize is to simply shift each gradient by ∇fi(x?), that
is, to use the following method

xk+1 = xk − γ (∇fik (xk) − ∇fik (x?)) ,

[13]

called SGD? (?). We note that it is unrealistic that we would
know each ∇fi(x?), but we use SGD? as a simple illustration
of the properties of VR methods. Further, many VR meth-
ods can be seen as an approximation of the SGD? method;
instead of relying on knowing each ∇fi(x?), these methods
use approximations that converge to ∇fi(x?).

Note that SGD? uses an unbiased estimate of the full gradi-

ent. Indeed, since ∇f (x?) = 0,

E [∇fik (xk) − ∇fik (x?)] = ∇f (xk) − ∇f (x?) = ∇f (xk).

Furthermore, SGD? naturally stops when it reaches the optimal
point since, for any i,

k∇f (x) − ∇f (y)k ≤ Lkx − yk

[14]

for all x and y and some 0 < L < ∞. Each fi :
Rd → R is diﬀerentiable, Li-smooth and let Lmax :=
max{L1, . . . , Ln}.

While this is typically viewed as a weak assumption, in
Section 4 we comment on VR methods that apply to non-
smooth problems. This L-smoothness assumption has an
intuitive interpretation for univariate functions that are twice-
it is equivalent to assuming that the second
diﬀerentiable:
derivative is bounded by L, |f 00(x)| ≤ L for every x ∈ Rd.
For multivariate twice-diﬀerentiable functions, it is equivalent
to assuming that the singular values of the Hessian matrix
∇2f (x) are upper bounded by L for every x ∈ Rd. For the
least squares problem [1], the individual Lipschitz constants Li
2
are given by Li = kaik
, while for the L2-regularized logistic
regression problem [3], we have Li = 0.25kaik

+ λ.

2

The second assumption we consider in this section lower

bounds the curvature of the functions.

Assumption 1.2. The function f is µ-strongly con-
vex, meaning that the function x 7→ f (x) − µ
is
convex for some µ > 0. Furthermore, fi : Rd → R is
convex for each i = 1, . . . , n.

2 kxk

2

This is a strong assumption. While each fi is convex in the
least squares problem [1], the overall function f is strongly
convex if and only if the design matrix A := [a1, . . . , an] has
full row rank. On other hand, the L2-regularized logistic
regression problem [3] satisﬁes this assumption with µ ≥ λ
due to the presence of the regularizer. As we detail in Section 4,
it is possible to relax the strong convexity assumption as well
as the assumption that each fi is convex.

An important problem class where the assumptions are

satisﬁed are problems of the form

(cid:0)∇fi(x) − ∇fi(x?)(cid:1)(cid:12)

(cid:12)x=x?

= 0.

(

x? ∈ argmin

f (x) =

n
X

‘i(a>

i x) +

1
n

λ
2

)

2
kxk

[15]

Next, we note that SGD? satisﬁes the VR property [12] as xk
approaches x? (for continuous ∇fi) since

E (cid:2)kgk − ∇f (xk)k

2(cid:3) = E (cid:2)k∇fi(xk) − ∇fi(x?) − ∇f (xk)k

2(cid:3)

≤ E (cid:2)k∇fi(xk) − ∇fi(x?)k

2(cid:3),

where we used Lemma A.2 with X = ∇fi(xk) − ∇fi(x?)
and then used that E [∇fi(xk) − ∇fi(x?)] = ∇f (xk). This
property implies that SGD? has a faster convergence rate than
classic SGD methods, as we detail in Appendix B.

‡

To be exact [12] is not explicitly the total variance of gk , but rather the trace of the covariance
matrix of gk .

x∈Rd

i=1
in the case when each “loss” function ‘i : R 7→ R is twice-
diﬀerentiable with ‘00
i bounded between 0 and some upper
bound M . This includes a variety of loss functions with
L2-regularization in machine learning, such as least squares
(li(α) = (α − bi)2), logistic regression, probit regression, Huber
robust regression, and a variety of others. In this setting, for
all i we have Li ≤ M kaik

+ λ and µ ≥ λ.

2

The convergence rate of GD under these assumptions is
determined by the ratio κ := L/µ, which is known as the
condition number of f . This ratio is always greater or equal to
one, and when it is signiﬁcantly larger than one, the level sets
of the function become very elliptical which causes the iterates

et al.

iLCSS | October 5, 2020 |

vol. XXX | no. XX | 3

In Appendix B we give a simple proof showing that the
SGD? method has the same iteration complexity as the VR
methods.

2. Basic Variance-Reduced Methods

The ﬁrst wave of variance-reduced methods that achieve the
convergence rate from the previous section started with the
stochastic average gradient (SAG) method (Le Roux et al.,
2012; Schmidt et al., 2017). This was followed shortly after by
the stochastic dual coordinate ascent (SDCA) (Richtárik and
Takáč, 2014; Shalev-Shwartz and Zhang, 2013), MISO (Mairal,
2015), stochastic variance-reduced gradient (SVRG/S2GD) (Mah-
davi and Jin, 2013; Johnson and Zhang, 2013; Konecný and
Richtárik, 2013; Zhang et al., 2013), and SAGA (stochastic av-
erage gradient “amélioré”) (Defazio et al., 2014) methods. In
this section we present several of these original methods, while
Section 4 covers more recent methods that oﬀer improved
properties in certain settings over these original methods.

A. Stochastic Average Gradient (SAG). The ﬁrst VR method is
based on mimicking the structure of the full gradient. Since the
full gradient ∇f (x) is a plain average of the ∇fi(x) gradients,
our estimate gk of the full gradient should be an average of
estimates of the ∇fi(x) gradients. This idea leads us to our
ﬁrst variance-reduced method: the stochastic average gradient
(SAG) method.

The stochastic average gradient (SAG) method (Le Roux
et al., 2012; Schmidt et al., 2017) is a stochastic variant of the
earlier incremental aggregated gradient (IAG) method (Blatt
et al., 2007). The idea behind SAG is to maintain an estimate
vi
k ≈ ∇fi(xk) for each data point i. We then use the average
of the vi

k values as our estimate of the full gradient, that is

¯gk =

1
n

n
X

j=1

vj
k ≈

1
n

n
X

j=1

∇fj(xk) = ∇f (xk).

[18]

At each iteration, SAG samples ik ∈ {1, . . . , n} and updates
the vj

k using

vj
k+1 =

(cid:26)∇fik (xk)
vj
k

if j = ik ,
if j 6= ik ,

[19]

where each v0
i might be initialized to zero or to an approx-
imation of ∇fi(x0). As we approach a solution x?, each vi
converges to ∇fi(x?) which gives us the VR property [12].

To implement SAG eﬃciently, we need to take care in com-
puting ¯gk using [18], since this requires summing up n vectors
in Rd, and since n can be very large, computing this sum
can be very costly. Fortunately we can avoid computing this
summation from scratch every iteration since only one vi
k term
will change in the next iteration. That is, suppose we sample
the index ik on iteration k. It follows from [18] and [19] that

n
X

j=1,j6=ik
n
X

¯gk =

=

1
n

1
n

j=1,j6=ik
1
n

= ¯gk−1 −

vj
k +

1
n

vik
k

vj
k−1 +

1
n

vik
k

(Since vj

k−1 = vj

k for all j 6= ik)

vik
k−1 +

1
n

vik
k .

(Plus and minus 1

n vik

k−1) [20]

Fig. 3. Here we graph the level sets two logistic regression loss functions. The left
level sets are each of a well-conditioned logistic function with κ ≈ 1. The right level
sets are of an ill-conditioned logistic functions with κ (cid:29) 1.

of the GD method to oscillate. This is illustrated in Figure 3.
In contrast, when κ is close to 1, GD converges quickly.

Under Assumptions 1.1 and 1.2, VR methods converge at
a linear rate. We say that the function values {f (xk)} of a
randomized method converge linearly (in expectation) at a
rate of 0 < ρ ≤ 1 if there exists a constant C > 0 such that

E [f (xk)] − f (x?) ≤ (1 − ρ)kC = O(exp(−kρ)),

∀k.

[16]

This is in contrast to classic SGD methods that only rely on
an unbiased estimate of the gradient in each iteration, which
under these assumptions can only obtain the sublinear rate

E [f (xk)] − f (x?) ≤ O(1/k).

Thus, classic SGD methods become slower the longer we run
them, while VR methods continue to cut the error by at least
a ﬁxed fraction in each step.

As a consequence of [16], we can determine the number of
iterations needed to reach a given tolerance ε > 0 on the error
as follows

k ≥

1
ρ

log

(cid:17)

,

(cid:16) C
ε

then E [f (xk)] − f (x?) ≤ ε.

[17]

The smallest k satisfying this inequality is known as the
iteration complexity of the algorithm. Below we give the
iteration complexity and the cost of one iteration in terms of
n for the basic variant of GD, SGD, and VR methods:

Algorithm
GD
SGD
VR

# Iterations
O(κ log(1/ε))
O(κmax(1/ε))
O((κmax + n) log(1/ε))

Cost of 1 Iteration
O(n)
O(1)
O(1)

The total runtime of an algorithm is given by the product
of the iteration complexity and the iteration runtime. Above
we have used κmax := (maxi Li)/µ. Note that κmax ≥ κ,
thus the iteration complexity of GD is smaller than that of the
VR methods.§ But the VR methods are superior in terms of
total runtime since each iteration of gradient descent costs
n-times more than an iteration of a VR method¶. Classic
SGD methods have the advantage that their runtime and their
convergence rate does not depend on n, but it does have a
much worse dependency on the tolerance ε which explains
SGD’s poor performance when the tolerance is small. ‖

§

¶

‖

In Section 4 we discuss how non-uniform sampling within VR methods leads to a faster rate, de-
pending on the mean ¯L := 1
n

Li rather than on the maximum maxi Li.

P

i

And since Lmax ≤ nL.
We have omitted an additional term for the SGD iteration complexity of the form O(σ2/µε), where
σ2 ≥ Ei

(cid:2)k∇fi(x∗)k2(cid:3), see Theorem 2.1 in Needell et al. (2015)

4 |

et al.

k−1 are simply copied over to vj

Since the vj
k, when implement-
ing SAG we can simply store one vector vj for each j. This
implementation is illustrated in Algorithm 1.

Algorithm 1 SAG: Stochastic Average Gradient method

1: Parameters: stepsize γ > 0
2: Initialize: x0, vi = 0 ∈ Rd for i = 1, . . . , n
3: for k = 1, . . . , T − 1 do
4:

Sample ik ∈ {1, . . . , n}

5:

6:

7:

vik

1
¯gk = ¯gk−1 −
n
vik = ∇fik (xk)
vik
¯gk = ¯gk +
xk+1 = xk − γ¯gk

1
n

8:
9: Output: xT

The SAG method was the ﬁrst stochastic methods to enjoy
linear convergence with an iteration complexity of O((κmax +
n) log(1/ε)), using a stepsize of γ = O (1/Lmax) . This linear
convergence can be seen in Figure 1. Note that since an Lmax-
smooth function is also L0-smooth for any L0 ≥ Lmax, this
method obtains a linear convergence rate for any suﬃciently
small stepsize. This is in contrast to classic SGD methods,
which only obtain sublinear rates and only under diﬃcult-to-
tune-in-practice decreasing stepsize sequences.

At the time, the linear convergence of SAG was a remarkable
breakthrough given that SAG only computes a single stochastic
gradient (processing a single data point) at each iteration.
However, the convergence proof by Schmidt et al. (2017) is
notoriously diﬃcult, and relies on computer veriﬁed steps.
What speciﬁcally makes SAG hard to analyze is that gk is a
biased estimate of the gradient. Next we introduce the SAGA
method, a variant of SAG that uses the concept of covariates to
make an unbiased variant of the SAG method that has similar
performance but is easier to analyze.

B. SAGA. A common way to reduce the variance of the basic
unbiased estimate ∇fik (xk) is by using what is known as
covariates (or “control variates”). Let vi ∈ Rd be a vector
for i = 1, . . . , n. Using these vectors we can rewrite our full
gradient as

∇f (x) =

=

1
n

1
n

:=

1
n

n
X

i=1

n
X

i=1

n
X

i=1

(∇fi(x) − vi + vi)

∇fi(x) − vi +

!

1
n

n
X

j=1

vj

∇fi(x, v),

[21]

Pn

where ∇fi(x, v) := ∇fi(x)−vi + 1
j=1 vj. Now we can build
n
an unbiased estimate of the full gradient ∇f (x) by sampling
a single ∇fi(x, v) uniformly for i ∈ {1, . . . , n}. That is, we
can solve [2] by applying the SGD method with the gradient
estimate

gk = ∇fik (xk, v) = ∇fik (xk) − vi +

1
n

n
X

j=1

vj.

[22]

To see the eﬀect of the choice of the vi’s on the variance
(cid:2)vi(cid:3) =

of gk, substituting gk = ∇fik (xk, v) and using Ei∼ 1
1
n

Pn

n

[12] = E

j=1 vj in [12] gives
(cid:20)(cid:13)
(cid:13)
(cid:13)∇fi(xk) − vi + Ei∼ 1
h(cid:13)
(cid:13)∇fi(xk) − vi(cid:13)
(cid:13)

≤ E

2i

,

n

(cid:2)vi − ∇fi(xk)(cid:3)(cid:13)
(cid:13)
(cid:13)

2(cid:21)

[23]

where we used Lemma A.2 with X = ∇fi(xk) − vi. This
bound [23] shows us that we obtain the VR property [12] if vi
approaches ∇fi(xk) as k grows. This is why we refer to the
vi’s as covariates. We are free to choose any vi, so we can
choose them to reduce the variance.

As an example, the SGD? method [13] also implements this
approach with vi = ∇fi(x?). But again, this is not practical
since often we do not know ∇fi(x?). A more practical choice
for vi is the gradient ∇fi(¯xi) around a point ¯xi ∈ Rd that
we do know. SAGA uses a reference point ¯xi ∈ Rd for each
function fi and uses the covariate vi = ∇fi(¯xi) where each ¯xi
will be the last point for which we evaluated ∇fi(¯xi). Using
these covariates we can build a gradient estimate following [22]
which gives

gk = ∇fik (xk) − ∇fik (¯xik ) +

1
n

n
X

j=1

∇fj(¯xj).

[24]

To implement SAGA, instead of storing the n reference points ¯xi
we can store the gradients ∇fi(¯xi) That is, let vj = ∇fj(¯xj) for
j ∈ {1, . . . , n}, and similar to SAG we update vj of one random
gradient in each iteration. We formalize the SAGA method
as Algorithm 2, which is similar to the implementation of
SAG (Algorithm 1) except now we store the previously known
gradient of fik in a dummy variable vold so that we can then
form the unbiased gradient estimate [24].

Algorithm 2 SAGA

1: Parameters: stepsize γ > 0
2: Initialize: x0, vi = 0 ∈ Rd for i = 1, . . . , n
3: for k = 1, . . . , T − 1 do
4:

5:

6:

7:

8:

Sample ik ∈ {1, . . . , n}
vold = vik
vik = ∇fik (xk)
xk+1 = xk − γ (cid:0)vik − v
1
¯gk = ¯gk−1 +
v
n

vik −

1
n

old

(cid:1)

+ ¯gk

old

9: Output: xT

The SAGA method has an iteration complexity of O((κmax +
n) log(1/ε)) using a stepsize of γ = O(1/Lmax) as in SAG,
but with a much simpler proof. However, as with SAG, the
SAGA method needs to store the auxiliary vectors vi ∈ Rd
for i = 1, . . . , n which amounts to an O(nd) storage. This
can be infeasible when both d and n are large. We detail in
Section 3 how we can reduce this memory requirement for
common models like regularized linear models [15].

When the n auxiliary vectors can be stored in memory,
SAG and SAGA tend to perform similarly. When this memory
requirement is too high, the SVRG method that we review next
is a good alternative. The SVRG method achieves the same
convergence rate, and is often nearly as fast in practice, but
only requires O(d) memory for general problems.

et al.

iLCSS | October 5, 2020 |

vol. XXX | no. XX | 5

 
C. SVRG. Prior to SAGA, the ﬁrst works to use covariates used
them to address the high memory required of SAG (Johnson
and Zhang, 2013; Mahdavi and Jin, 2013; Zhang et al., 2013).
These works build covariates based on a ﬁxed reference point
¯x ∈ Rd at which we have already computed the full gradient
∇f (¯x). By storing ¯x and ∇f (¯x), we can implement the up-
date [24] using ¯xj = ¯x for all j without storing the individual
gradients ∇fj(¯x). In particular, instead of storing these vec-
tors, we compute ∇fik (¯x) in each iteration using the stored
reference point ¯x. Originally presented under diﬀerent names
by diﬀerent authors, this method has come to be known as the
stochastic variance-reduced gradient (SVRG) method, following
the naming of (Johnson and Zhang, 2013; Zhang et al., 2013).
Us-
ing [23] we have that the variance of the gradient estimate gk
is bounded by

We formalize the SVRG method in Algorithm 3.

E (cid:2)kgk − ∇f (xk)k

2(cid:3) ≤ E (cid:2)k∇fi(xk) − ∇fi(¯x)k
2
maxkxk − ¯xk
≤ L

,

2

2(cid:3)

where the second inequality uses the Li-smoothness of each
∗∗. Notice that the closer ¯x is to xk, the smaller the variance
Li
of the gradient estimate.

To make the SVRG method work well, we need to trade
oﬀ the cost of updating the reference point ¯x frequently, and
thus having to compute the full gradient, with the beneﬁts
of decreasing the variance. To do this, the reference point is
updated every t iterations to be a point close to xk: see line
11 of Algorithm 3 That is, the SVRG method has two loops:
one outer loop in s where the reference gradient ∇f (¯xs−1) is
computed (line 4), and one inner loop where the reference
point is ﬁxed and the inner iterates xk are updated (line 10)
according to stochastic gradient steps using [22].

In contrast to SAG and SAGA, SVRG requires O(d) memory
only. The downsides of SVRG are 1) we have an additional
parameter t, the length of the inner loop, which needs to be
tuned and 2) two gradients are computed per iteration and the
full gradient needs to be computed every time the reference
point is changed.

Algorithm 3 SVRG: Stochastic Variance-Reduced Gradient
method

1: Parameters stepsize γ > 0
2: Initialization ¯x0 = x0 ∈ Rd
3: for s = 1, 2, . . . do

4:

5:

6:

7:

8:

9:

10:

11:

Compute and store ∇f (¯xs−1)
x0 = ¯xs−1
Choose the number of inner-loop iterations t
for k = 0, 1, . . . , t − 1 do

Sample ik ∈ {1, . . . , n}
gk = ∇fik (xk) − ∇fik (¯xs−1) + ∇f (¯xs−1)
xk+1 = xk − γgk

¯xs = xt.

Johnson and Zhang (2013) showed that SVRG has iteration
complexity O((κmax + n) log(1/ε)), similar to SAG and SAGA.

This was shown assuming that the number of inner iterations
t is sampled uniformly from {1, . . . , m}, where a complex
dependency must hold between Lmax, µ, the stepsize γ, and t.
In practice, SVRG tends to work well by using γ = O(1/Lmax)
and inner loop length t = n, which is the setting we used in
Figure 1.

There are now many variations on the original SVRG method.
For example, there are variants that use alternative distribu-
tions for t (Konecný and Richtárik, 2013) and variants that
allow stepsizes of the form O(1/Lmax) (Hofmann et al., 2015;
Kulunchakov and Mairal, 2019; Kovalev et al., 2020). There
are also variants that use a mini-batch approximation of ∇f (¯x)
to reduce the cost of these full-gradient evaluations, and that
grow the mini-batch size in order to maintain the VR prop-
erty (Harikandeh et al., 2015; Frostig et al., 2015). And there
are variants that repeatedly update gk in the inner loop ac-
cording to (Nguyen et al., 2017)

gk = ∇fik (xk) − ∇fik (xk−1) + gk−1,

[25]

which provides a more local approximation.
Using this
continuous update variant [25] has shown to have distinct
advantages in minimizing nonconvex functions, as we brieﬂy
discuss in Section G. Finally, note that SVRG can use the values
of ∇f (¯xs) to help decide when to terminate the algorithm.

D. SDCA and Variants. A drawback of SAG and SVRG is that
their stepsize depends on Lmax, which may not be known
for some problems.
One of the ﬁrst VR methods (pre-
dating SVRG) was the stochastic dual coordinate ascent (SDCA)
method (Shalev-Shwartz and Zhang, 2013) which extended
recent work on coordinate descent methods to the ﬁnite-sum
problem.††

The intuition behind SDCA, and its variants, is that the co-
ordinates of the gradient provide a naturally variance-reduced
estimate of the gradient. That is, let j ∈ {1, . . . , d} and let
∇jf (x) := ∂f (x)
ej be the coordinate-wise derivative of f (x),
∂xj
where ej ∈ Rd is the jth unit coordinate vector. An important
feature of coordinate-wise derivatives is that ∇jf (x?) = 0,
since we know that ∇f (x?) = 0. This is unlike the derivative
for each data point ∇fj that may be diﬀerent than zero at x?.
Due to this feature, we have that

2
k∇f (x) − ∇jf (x)k

−→
x→x?

0,

[26]

and thus coordinate-wise derivative satisﬁes the VR prop-
erty [12]. Furthermore, we can also use ∇jf (x) to build an
unbiased estimate of ∇f (x). For instance, let j be a random
index sampled uniformly on average from {1, . . . , d}. Thus for
any given i ∈ {1, . . . , d} we have that P [j = i] = 1
d . Conse-
quently d × ∇jf (x) is an unbiased estimate of ∇f (x) since

E [d∇jf (x)] = d

d
X

i=1

P [j = i]

∂f (x)
∂xi

ei =

d
X

i=1

∂f (x)
∂xi

ei = ∇f (x).

Thus ∇jf (x) has all the favorable properties we would like
for a variance reduced estimate of the full gradient without
using covariates. The downside of using this coordinate-wise

∗∗

When each fi is also convex, we can derive the bound

E[k∇f (¯xs−1) − ∇f (xk)k2] ≤ 4Lmax(f (xk) − f (x∗) + f (¯xs−1) − f (x∗))

using analogous proof to Lemma A.1. This bound on the variance is key to proving a good conver-
gence rate for SVRG in the convex setting.

††

The modern interest in coordinate ascent/descent methods began with Nesterov (2012), which
considered coordinate-wise gradient descent with randomly-chosen coordinates, and included a
result showing linear convergence for L-smooth strongly convex functions. This led to an explosion
of work on the problem, as for many problem structures we can very-efﬁciently compute coordinate-
wise gradient descent steps (Richtárik and Takáˇc, 2014)

6 |

et al.

gradient is that for our sum-of-terms problem [2] it is expensive
to compute. This is because computing ∇jf (x) requires a full
pass over the data since

∇jf (x) =

1
n

n
X

i=1

∇jfi(x).

So it would seem that using coordinate-wise derivatives is
incompatible with the structure of our sum-of-terms prob-
lem. Fortunately though, we can often rewrite our original
problem [2] in what is known as a dual formulation where
coordinate-wise derivatives can make use of the inherit struc-
ture.

To illustrate, the dual formulation of the L2-regularized

linear models of the form [15] is given by

v? ∈ argmax

v∈Rn

(

1
n

n
X

i=1

−‘?

i (−vi) −

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)

λ
2

1
λn

n
X

i=1

viai

2)

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)

,

[27]

where ‘?
i (v) := supx{hx, vi − f (x)} is the convex conjugate of
‘i. We can recover the x variable of our original problem [15]
using the mapping

x =

1
λn

n
X

i=1

viai.

Consequently, plugging in the solution v? to [27] in the right
hand side of the above gives x?, the solution of [15].

Notice that this dual problem has n real variables vi ∈ R,
one for each training example. Furthermore, each dual loss
function ‘?
i in [27] is a function of a single vi only. That is,
the ﬁrst term in the loss function is separable over coordinates.
It is this separability over coordinates, combined with the
simple form of the second term, that allows for an eﬃcient
implementation of a coordinate ascent method.‡‡
Indeed,
Shalev-Shwartz and Zhang (2013) showed that coordinate
ascent on this dual problem has an iteration complexity of
O((κmax + n) log(1/ε)), similar to SAG, SAGA and SVRG.§§ The
iteration cost and algorithm structure are also quite similar:
by keeping track of the sum Pn
i=1 viai to address the second
term in [27], each dual coordinate ascent iteration only needs
to consider a single training example and the cost per iteration
is independent of n. Further, we can use a one-dimensional
line-search to eﬃciently compute a stepsize that maximally
increases the dual objective as a function of one vi. This
means that the fast worst-case runtime of VR methods can be
achieved with no knowledge of Lmax or related quantities.

Unfortunately, the SDCA method also has several disadvan-
tages. First, it requires computing the convex conjugates ‘?
i
rather than simply gradients. We do not have an equivalent
of automatic diﬀerentiation for convex conjugates, so this may
increase the implementation eﬀort. More recent works have
presented “dual-free” SDCA methods that do not require the
conjugates and instead work with gradients (Shalev-Shwartz,
2016). However, it is no longer possible to track the dual
objective in order to set the stepsize in these methods. Second,
while SDCA only requires O(n + d) memory for problem [15],
SAG/SAGA also only requires O(n + d) memory for this problem

‡‡

§§

We call it “coordinate ascent” instead of “coordinate descent” since [27] is a maximization problem.
This iteration complexity is in terms of the duality gap. Related results for certain problem structures
include Strohmer and Vershynin (2009); Collins et al. (2008).

¶¶

class (see the next section). Variants of SDCA that apply to
more general problems have the O(nd) memory of SAG/SAGA
since the vi become vectors with d-elements. A ﬁnal subtle
disadvantage of SDCA is that it implicitly assumes that the
strong convexity constant µ is equal to λ. For problems where
µ is greater than λ, the primal VR methods often signiﬁcantly
outperform SDCA.

3. Practical Considerations

In order to implement the basic VR methods and obtain a
reasonable performance, several implementation issues must
be addressed. In this section, we discuss several issues that
are not addressed above.

A. Setting the stepsize for SAG/SAGA/SVRG. While we can
naturally use the dual objective to set the stepsize for SDCA,
the theory for the primal VR methods SAG/SAGA/SVRG relies on
stepsizes of the form γ = O(1/Lmax). Yet in practice one may
not know Lmax and better performance can often be obtained
with other stepsizes.

One classic strategy for setting the stepsize in full-gradient
descent methods is the Armijo line-search (Armijo, 1966).
Given a current point xk and a search direction gk, the Armijo
line-search for a γk that is on the line γk ∈ {γ : xk + γgk}
and such that gives a suﬃcient decrease of the function

f (xk + γkgk) < f (xk) − cγkk∇f (xk)k

2

.

[28]

This requires calculating f (xk + γkgk) on several candidates
stepsizes γk, which is prohibitively expensive since evaluating
f (x) requires a full pass over the data.

So instead of using the full function f (x), we can use a

stochastic variant where we look for γk such that

2
fik (xk + γkgk) < fik (xk) − cγkk∇fik (xk)k

.

[29]

This is used in the implementation of Schmidt et al. (2017)
with c = 1
2 on iterations where k∇fik (xk)k is not close to zero.
It often works well in practice with appropriate guesses for
the trial stepsizes, although no theory exists for the method.
Alternatively, Mairal (2015) considers the “Bottou trick”
for setting the stepsize in practice.¶¶ This method takes
a small sample of the dataset (typically 5%), and performs
a binary search that attempts to ﬁnd the optimal stepsize
when performing one pass through this sample. Similar to
the Armijo line-search, the stepsize obtained with this method
tends to work well in practice but no theory is known for the
method.

B. Termination Criteria. Iteration complexity results provide
theoretical worst-case bounds on the number of iterations to
reach a certain accuracy. However, these bounds depend on
constants we may not know and in practice the algorithms
tend to require fewer iterations than indicated by the bounds.
Thus, we should consider tests to decide when the algorithm
should be terminated.

In classic full-gradient descent methods, we typically con-
sider the norm of the gradient k∇f (xk)k or some variation
on this quantity to decide when to stop. We can naturally
implement these same criteria to decide when to stop an SVRG

Introduced publicly by Léon Bottou during his tutorial on SGD methods at NeurIPS 2017.

et al.

iLCSS | October 5, 2020 |

vol. XXX | no. XX | 7

method, by using k∇f (¯xs)k. For SAG/SAGA we do not explic-
itly compute any full gradients, but the quantity ¯gk converges
to ∇f (xk) so a reasonable heuristic is to use k¯gkk in deciding
when to stop. In the case of SDCA, with a small amount of extra
bookkeeping it is possible to track the gradient of the dual
objective at no additional asymptotic cost. Alternately, a more
principled approach is to track the duality gap which adds an
O(n) cost per iteration but leads to termination criteria with a
duality gap certiﬁcate of optimality. An alternative principled
approach based on optimality conditions for strongly convex
objectives is used in the MISO method (Mairal, 2015), based
on a quadratic lower bound (Lin et al., 2018).

C. Reducing Memory Requirement. Although SVRG removes
the memory requirement of earlier VR methods, in practice
SAG/SAGA require fewer iterations than SVRG on many problems.
Thus, we might consider whether there exist problems where
SAG/SAGA can be implemented with less than O(nd) memory.
In this section we consider the class of linear models, where
the memory requirement can be reduced substantially.

Consider linear models where fi(x) = ‘i(a>

i x). Diﬀerenti-

ating gives

∇fi(x) = ‘0

i(a>

i x)ai.

Provided we already have access to the feature vectors ai, it
is suﬃcient to store the scalars ‘i(a>
i x) in order to implement
the SAG/SAGA method. This reduces the memory requirements
from O(nd) down to O(n). SVRG can also beneﬁt from this
structure of the gradients: by storing those n scalars, we can
reduce the number of gradient evaluations required per SVRG
“inner” iteration to 1 for this problem class.

There exist other problem classes, such as probabilistic
graphical models, where it is possible to reduce the memory
requirements (Schmidt et al., 2015).

D. Sparse Gradients. For problems where the gradients ∇fi(x)
have many zero values (for example, for linear models with
sparse features), the classical SGD update may be implemented
with complexity which is linear in the number of non-zero
components in the corresponding gradient, which is often
much less than d. This possibility is lost in plain variance
reduced methods. However there are two known ﬁxes.

The ﬁrst one, described by Schmidt et al. (2017, Section 4.1)
takes advantage of the simple form of the updates to implement
a “just-in-time” variant where the iteration cost is proportional
to the number of non-zeroes. For SAG (but this applies to all
variants), this is done by not explicitly storing the full vector
vik after each iteration. Instead, in each iteration we only
compute the elements vik
j corresponding to non-zero elements,
by applying the sequence of updates to each variable vik
since
j
the last iteration where it was nonzero.

The second one, described by Leblond et al. (2017, Sec-
tion 2) for SAGA, adds an extra randomness to the update
xk+1 = xk − γ (∇fik (xk) − ∇fik (¯xik ) + ¯gk), where ∇fik (xk)
and ∇fik (¯xik ) are sparse, but ¯gk is dense. The components
of the dense term (¯gk)j, j = 1, . . . , d, are replaced by wj(¯gk)j,
where w ∈ Rd is a random sparse vector whose support is
included in one of the ∇fik (xk), and in expectation is the
constant vector of all ones. The update remains unbiased
(but is now sparse) and the added variance does not impact
the convergence rate; the details are given by Leblond et al.
(2017).

4. Advanced Algorithms

In this section we consider extensions of the basic VR methods.
Some of these extensions generalize the basic methods to
handle more general scenarios, such as problems that are
not smooth and/or strongly convex. Other extensions use
additional algorithmic tricks or problem structure to design
faster algorithms than the basic methods.

A. Hybrid SGD and VR Methods. The convergence rate ρ of the
VR methods depends on the the number of training examples
n. This is in contrast to the convergence rates of classic SGD
methods, which are sublinear but do not have a dependence on
n. This means that VR methods can perform worse than classic
SGD methods in the early iterations when n is very large. For
example, in Figure 1 we can see that SGD is competitive with
the two VR methods throughout the ﬁrst 10 epochs (passes
over the data).

Several hybrid SGD and VR methods have been proposed to
improve the dependence of VR methods on n. Le Roux et al.
(2012) and Konecný and Richtárik (2013) analyzed SAG and
SVRG, respectively, when initialized with n iterations of SGD.
This does not change the convergence rate, but signiﬁcantly
improves the dependence on n in the constant factor. However,
this requires setting the stepsize for these initial SGD iterations,
which is more complicated than setting the stepsize for VR
methods∗∗∗.

More recently, several methods have been explored which
guarantee both a linear convergence rate depending on n, as
well as a sublinear convergence rate that does not depend on
n. For example, Lei and Jordan (2017) show that this “best of
both worlds” result can be achieved for the “practical” SVRG
variant where we use a growing mini-batch approximation of
∇f (¯x).

B. Non-Uniform Sampling. Instead of improving the depen-
dence on n, a variety of works have focused on improving the
dependence on the Lipschitz constants Li by using non-uniform
sampling of the random training example ik. In particular,
these algorithms bias the choice of ik towards the larger Li
values. This means that examples whose gradients can change
more quickly are sampled more often. This is typically com-
bined with using a larger stepsize that depends on the average
of the Li values rather than the maximum Li value. Under an
appropriate choice of the sampling probabilities and stepsize,
this leads to improved iteration complexities of the form

O((κmean + n) log(1/ε)),

P

which depends on κmean := ( 1
i Li)/µ rather than on
n
κmax = (maxi Li)/µ. This improved rate under non-uniform
sampling has been shown for the basic VR methods SVRG (Xiao
and Zhang, 2014), SDCA (Qu et al., 2015), and SAGA (Schmidt
et al., 2015; Gower et al., 2018).

Virtually all existing methods use ﬁxed probability distribu-
tion over {1, . . . , n} throughout the iterative process. However,
it is possible to further improve on this choice by adaptively
changing the probabilities during the execution of the algo-
rithm. The ﬁrst VR method of this type, ASDCA, was developed

∗∗∗

Instead, it replaces n in
The implementation of Schmidt et al. (2017) does not use this trick.
Line 7 of Algorithm 1 with the number of training examples that have been sampled at least once.
This leads to similar performance and is more difﬁcult to analyze, but avoids needing to tune an
additional stepsize.

8 |

et al.

by (Csiba et al., 2015) and is based on updating the probabili-
ties in SDCA by using what is known as the dual residue.

Nevertheless, this complexity still guarantees better worst-case
performance in ill-conditioned settings (where κmax (cid:29) n).

Schmidt et al. (2017) present an empirical method that tries
to estimate local values of the Li (which may be arbitrarily
smaller than the global values), and show impressive gains
in experiments. A related method with a theoretical backing
that uses local Li estimates is presented by Vainsencher et al.
(2015).

C. Mini-batching. Another strategy to improve the dependence
on the Li values is to use mini-batching, analogous to the
classic mini-batch SGD method [7], to obtain a better approxi-
mation of the gradient. There are a number of ways of doing
mini-batching, but here we will focus on a ﬁxed batch-size
chosen uniformly at random. That is, let b ∈ N and we choose
a set Bk ⊂ {1, . . . , n} with |Bk| = b with uniform probability
from all sets with b elements. We can now implement the VR
method by replacing each ∇fi(xk) with a mini-batch estimate
given by 1
b

∇fi(xk).

P

i∈Bk

There were a variety of early mini-batch methods (Takáč
et al., 2013; Konečný et al., 2016; Harikandeh et al., 2015;
Hofmann et al., 2015), but the most recent methods are able
to obtain an iteration complexity of the form (Qu et al., 2015;
Qian et al., 2019; Gazagnadou et al., 2019; Sebbouh et al.,
2019)

(cid:19)

(cid:18) L(b)
µ

+

n
b

log

(cid:17)

,

(cid:16) 1
ε

O

using a stepsize of γ = O(1/L(b)), where

L(b) =

1
b

n − b
n − 1

Lmax +

n
b

b − 1
n − 1

L,

[30]

[31]

is a mini batch smoothness constant ﬁrst deﬁned in (Gower
et al., 2018, 2019). This iteration complexity interpolate
between the complexity of full-gradient descent when L(n) = L
and VR methods where L(1) = Lmax. Since L ≤ Lmax ≤
nL it is possible that L (cid:28) Lmax. Thus using larger mini
batches allows for the possibility of large speedups, especially
in settings where we can use parallel computing to evaluate
multiple gradients simultaneously. However, computing L is
typically more challenging than computing Lmax.

For generalized linear models [15] with ‘00 < M we have
that L ≤ M λmax(AA>) where A = [a1, . . . , an] ∈ Rd×n
and λmax(·) is the largest eigenvalue function. The largest
eigenvalue can be computed using a reduced SVD at a cost of
O(d2n) or by using a few iterations of the power method to
get an approximation. Unfortunately, for some problems this
cost may negate the advantage of using mini batches. In such
a case, we could replace L with the upper bound 1
i=1 Li.
n
But this may be a very conservative upper bound.

Pn

√

D. Accelerated Variants. An alternative strategy for improving
the dependence on κmax is Nesterov or Polyak acceleration (aka
momentum). It is well-known that Nesterov’s accelerated GD
improves the iteration complexity of the full-gradient method
from O(κ log(1/ε)) to O(
κ log(1/ε)) (Nesterov, 1983). Al-
though we might naively hope to see the same improvement
κmax,
for VR methods, replacing the κmax dependence with
we now know that the best complexity we can hope to achieve
is O((
nκmax + n) log(1/ε)) (Woodworth and Srebro, 2016;
Lan and Zhou, 2018), which was ﬁrst achieved by an ac-
celerated SDCA method (Shalev-Shwartz and Zhang, 2014).

√

√

A variety of VR methods have been proposed that incorpo-
rate an acceleration step in order to achieve this improved com-
plexity (see, e.g., Shalev-Shwartz and Zhang, 2014; Zhang and
Xiao, 2017; Allen-Zhu, 2017a). Moreover, the “catalyst” frame-
work of Lin et al. (2018) can be used to modify any method
achieving the complexity O((κmax + n) log(1/ε)) to an acceler-
nκmax + n) log(1/ε)).
ated method with a complexity of O((

√

E. Relaxing Smoothness. A variety of methods have been pro-
posed that relax the assumption that f is L-smooth. The
ﬁrst of these was the SDCA method, which can still be ap-
plied to [2] even if the functions {fi} are non-smooth. This
is because the dual remains a smooth problem. A classic
example is the support vector machine (SVM) loss, where
fi(x) = max{0, 1 − bia>
i x}. This leads to a convergence rate
of the form O(1/ε) rather than O(log(1/ε)), so does not give
a worst-case advantage over classic SGD methods . However,
unlike classic SGD methods, we can optimally set the stepsize
when using SDCA. Indeed, prior to new wave of VR methods,
dual coordinate ascent methods have been among the most
popular approaches for solving SVM problems for many years.
For example, the widely-popular libSVM package (Chang and
Lin, 2011) uses a dual coordinate ascent method.

One of the ﬁrst ways to handle non-smooth problems that
preserves the linear convergence rate was through the use of
proximal-gradient methods. These methods apply when f
has the form f (x) = 1
i=1 fi(x) + Ω(x). In this framework
n
it is assumed that f is L-smooth and that the regularizer
Ω is convex on its domain. But the function Ω may be non-
smooth and may enforce constraints on x. However, Ω must be
“simple” in the sense that it is possible to eﬃciently compute
its proximal operator applied to step of GD, that is

Pn

xk+1 = argmin

x∈Rd

1
2

kx − (xk − γ∇f (xk))k

2

+ γΩ(x),

[32]

should be relatively inexpensive to compute. The above
method is known as the proximal-gradient algorithm (see, e.g.,
Combettes and Pesquet, 2011), and it achieves the iteration
complexity O(κ log(1/ε)) even though Ω (and consequently
f ) is not L-smooth or even necessarily diﬀerentiable. A com-
mon example where [32] can be eﬃciently computed is the
L1-regularizer, where Ω(x) = λkxk1 for some regularization
parameter λ > 0.

A variety of works have shown analogous results for proxi-
mal variants of VR methods. These works essentially replace
the iterate update by an update of the above form, with
∇f (xk) replaced by the relevant approximation gk. This
leads to iteration complexities of O((κmax + n) log(1/ε)) for
proximal variants of SAG/SAGA/SVRG if the functions fi are Li
smooth (Xiao and Zhang, 2014; Defazio et al., 2014).

Several authors have also explored combinations of VR meth-
ods with the alternating direction method of multipliers (ADMM)
approaches (Zhong and Kwok, 2014), which can achieve im-
proved rates in some cases where Ω does not admit an eﬃcient
proximal operator. Several authors have also considered the
case where the individual fi may be non-smooth, replacing
them with a smooth approximation (see Allen-Zhu, 2017a).
This smoothing approach does not lead to linear convergence
rates, but leads to faster sublinear rates than are obtained with
SGD methods on non-smooth problems (even with smoothing).

et al.

iLCSS | October 5, 2020 |

vol. XXX | no. XX | 9

F. Relaxing Strong Convexity. While we have focused on the
case where f is strongly convex and each fi is convex, these
assumptions can be relaxed. For example, if f is convex but
not strongly convex then early works showed that VR methods
achieve a convergence rate of O(1/k) (Schmidt et al., 2017;
Mairal, 2015; Konecný and Richtárik, 2013; Mahdavi and Jin,
2013; Defazio et al., 2014). This is the same rate achieved by
GD under these assumptions, and is faster than the O(1/
k)
rate of SGD in this setting.

√

Alternatively, more recent works replace strong convexity
with weakened assumptions like the PL-inequality and KL-
inequality (Polyak, 1963), that include standard problems like
(unregularized) least squares but where it is still possible to
show linear convergence (Gong and Ye, 2014; Karimi et al.,
2016; Reddi et al., 2016b,a).

G. Non-convex Problems. Since 2014 a sequence of papers
have gradually relaxed the convexity assumptions on the func-
tions fi and f , and adapted the variance reduction methods to
achieve state-of-the-art complexity results for several diﬀerent
non-convex settings. Here we summarize some of these results,
starting with the setting closest to the strongly convex setting
and gradually relaxing any such convexity assumptions. For a
more detailed discussion see Zhou and Gu (2019) and Fang
et al. (2018).

√

Lmax/

The ﬁrst assumption we relax is the convexity of the
fi functions. The ﬁrst work in this direction was for solv-
ing the PCA problem where the individual fi
functions
are non-convex (Shamir, 2015; Garber and Hazan, 2015).
Both Garber and Hazan (2015) and Shalev-Shwartz (2016)
then showed how to use the catalyst framework (Lin et al.,
2018) to devise algorithms with an iteration complexity of
O(n + n3/4√
µ) log(1/ε) for Li–smooth non-convex fi
functions so long as their average f is µ–strongly convex. Re-
cently, this complexity was shown to match the lower bound
in this setting (Zhou and Gu, 2019). Allen-Zhu (2017b) took
a step further and relaxed the assumption that f is strongly
convex, and instead, allowed f to be simply convex or even
have “bounded non-convexity” (strong convexity but with a
negative parameter −µ). To tackle this setting, Allen-Zhu
(2017b) proposed an accelerated variant of SVRG that achieves
state-of-the-art complexity results which recently have been
shown to be optimal (Zhou and Gu, 2019). †††

Even more recently, the convexity assumptions on f have
been completely dropped. By only assuming that the fi’s are
smooth and f has a lower bound, Fang et al. (2018) present
an algorithm based on the continuous update [25] that ﬁnds
2(cid:3) ≤ ε
an approximate stationary point such that E (cid:2)k∇f (x)k
using O (cid:0)n +
n/ε2(cid:1) iterations. Concurrently to this, Zhou
et al. (2018) presented a more involved variant of SVRG that
uses multiple reference points and achieves the same iteration
complexity. Fang et al. (2018) also provided a lower bound
showing that the preceding complexity is optimal under these
assumptions.

√

An interesting source of non-convex functions are problems
where the objective is a composition of functions f (g(x)),
where g : Rd → Rm is a mapping. Even when both f and
g are convex, their composition may be non-convex. There
are several interesting applications where either g is itself an

†††

Note that, when assuming that f has a bounded non-convexity, the complexity results are with

respect to ﬁnding a point xk ∈ Rd such that E (cid:2)k∇f (xk)k2(cid:3) ≤ ε.

average (or even expectation) of maps, or f is an average of
functions, or even both (Lian et al., 2017). In this setting, the
ﬁnite sum structures can also be exploited to develop variance
reduced methods, most of which are based on variants of
SVRG. In the setting where g is a ﬁnite sum, state-of-the-art
complexity results have been achieved using the continuous
update [25], see (Zhang and Xiao, 2020).

H. Second-Order Variants. Inspired by Newton’s method,
there are now second-order variants of the VR methods of
the form

[33]
xk+1 = xk − γkHkgk,
where Hk ∈ Rd×d is an estimate of the inverse Hessian matrix
∇2f (xk)−1. The challenge in designing such methods is ﬁnding
an eﬃcient way to update Hk that results in a suﬃciently
accurate estimate and does not cost too much. This is a
diﬃcult balance to achieve, for if Hk is a poor estimate it may
do more damage to the convergence of [33] than help. On the
other hand, expensive routines for updating Hk can make the
method inapplicable when the number of data points is large.
Though diﬃcult, the rewards are potentially high. Second
order methods can be invariant (or at least insensitive) to
coordinate transformations and ill-conditioned problems. This
is in contrast to the ﬁrst order methods that often require some
feature engineering, preconditioning and data preprocessing
to converge.

Most of the second order VR methods are based on the
BFGS quasi-Newton update (Broyden, 1967; Fletcher, 1970;
Goldfarb, 1970; Shanno, 1971).

The ﬁrst stochastic BFGS method that makes use of subsam-
pling was the online L-BFGS method (Schraudolph and Simon,
2007) which uses subsampled gradients to approximate Hessian-
vector products. The regularized BFGS method (Mokhtari and
Ribeiro, 2014, 2015) also makes use of stochastic gradients,
and further modiﬁes the BFGS update by adding a regularizer
to the Hk matrix.

The ﬁrst method to use subsampled Hessian-vector prod-
ucts in the BFGS update, as opposed to using diﬀerences of
stochastic gradients, was the SQN method (Byrd et al., 2016).
Moritz et al. (2016) then proposed combining SQN with SVRG.
The resulting method performs very well in numerical tests
and was the ﬁrst example of a 2nd order VR method with a
proven linear convergence, though with a signiﬁcantly worse
complexity than the O(κmax + n) log(1/(cid:15)) rate of the VR meth-
ods. Moritz et al. (2016)’s method was later extended to a
block quasi-Newton variant and analysed with an improved
complexity by Gower et al. (2016). There are also specialized
variants for the non-convex setting (Wang et al., 2017). These
2nd order quasi-Newton variants of the VR methods are hard
to analyse and, as far as we are aware, there exists no quasi-
Newton variants of [33] that have an update cost independent
of n and is proven to have a better global complexity than the
O((κmax + n) log(1/ε)) of VR methods.

However, there do exist stochastic Newton type methods,
such as Stochastic Dual Newton Ascent (SDNA) (Qu et al., 2016)
that perform minibatch type Newton steps in the dual space,
with a cost that is independent of n and does have a better
convergence rate than SDCA. Furthermore, more recently Ko-
valev et al. (2019) preposed a minibatch Newton method with
a local linear convergence rate of the form O((n/b) log(1/ε))
that is independent of the condition number, where b is the
mini-batch size.

10 |

et al.

Yet another line of stochastic second order methods is being
developed by combining variance reduction techniques with
the cubic regularized Newton method (Nesterov and Polyak,
2006) . These methods replace both the Hessian and gradient
by variance reduced estimates and then minimize at each iter-
ation an approximation of the second order Taylor expansion
with an additional cubic regularizer. What is particularly
promising about these methods is that they achieve state-of-
the-art sample complexity, in terms of accesses gradients and
Hessians of individual functions fi, for ﬁnding a second-order
stationary points for smooth non-convex problems Zhou et al.
(2019); Wang et al. (2018). This is currently a very active
direction of research.

5. Discussion and Limitations

In the previous section, we presented a variety of extensions
of the basic VR methods. We presented these as separate ex-
tensions, but many of them can be combined. For example,
we can have an algorithm that uses mini-batching and acceler-
ation while using a proximal-gradient framework to address
non-smooth problems. The literature has now ﬁlled out most
of these combinations.

Note that classic SGD methods apply to the general problem
of minimizing a function of the form f (x) = Ezf (x, z) for some
random variable z. In this work we have focused on the case
of the training error, where z can only take n values. However,
in machine learning we are ultimately interested in the test
error where z may come from a continuous distribution. If we
have an inﬁnite source of examples, we can use them within
SGD to directly optimize the test loss function. Alternatively,
we can treat our n training examples as samples from the test
distribution, then doing 1 pass of SGD through the training
examples can be viewed as directly making progress on the
test error. Although it is not possible to improve on the test
error convergence rate by using VR methods, several works
show that VR methods can improve the constants in the test
error convergence rate compared to SGD (Frostig et al., 2015;
Harikandeh et al., 2015).

We have largely focused on the application of VR methods
to linear models, while mentioning several other important ma-
chine learning problems such as graphical models and principal
component analysis. One of the most important applications
in machine learning where VR methods have had little impact
is in training deep neural networks. Indeed, recent work shows
that VR may be ineﬀective at speeding up the training of deep
neural networks (Defazio and Bottou, 2019). On the other
hand, VR methods are now ﬁnding applications in a variety of
other machine learning applications including policy evalua-
tion for reinforcement learning (Wai et al., 2019; Papini et al.,
2018; Xu et al., 2019), expectation maximization (Chen et al.,
2018), simulations using Monte Carlo methods (Zou et al.,
2019), saddle-point problems (Palaniappan and Bach, 2016),
and generative adversarial networks (Chavdarova et al., 2019).

Acknowledgement

We thank Quanquan Gu, Julien Mairal, Tong Zhang and Lin
Xiao for valuable suggestions and comments on an earlier draft
of this paper. In particular, Quanquan’s recommendations
for the non-convex section improved the organization of our
Section G.

References

Allen-Zhu, Z. (2017a). Katyusha: The ﬁrst direct acceleration
of stochastic gradient methods. The Journal of Machine
Learning Research, 18(1):8194–8244.

Allen-Zhu, Z. (2017b). Natasha: Faster non-convex stochastic
optimization via strongly non-convex parameter. In Pro-
ceedings of the 34th International Conference on Machine
Learning, volume 70, pages 89–97.

Armijo, L. (1966). Minimization of functions having Lips-
chitz continuous ﬁrst partial derivatives. Paciﬁc Journal of
Mathematics, 16(1):1–3.

Blatt, D., Hero, A. O., and Gauchman, H. (2007). A conver-
gent incremental gradient method with a constant step size.
SIAM Journal on Optimization, 18(1):29–51.

Broyden, C. G. (1967). Quasi-Newton methods and their
application to function minimisation. Mathematics of Com-
putation, 21(99):368–381.

Byrd, R. H., Hansen, S. L., Nocedal, J., and Singer, Y. (2016).
A stochastic quasi-Newton method for large-scale optimiza-
tion. SIAM Journal on Optimization, 26(2):1008–1031.

Chang, C. C. and Lin, C. J. (2011). LIBSVM : A library for
support vector machines. ACM Transactions on Intelligent
Systems and Technology, 2(3):1–27.

Chavdarova, T., Gidel, G., Fleuret, F., and Lacoste-Julien,
S. (2019). Reducing noise in gan training with variance
reduced extragradient. In Advances in Neural Information
Processing Systems 32, pages 393–403.

Chen, J., Zhu, J., Teh, Y. W., and Zhang, T. (2018). Stochastic
expectation maximization with variance reduction. In Ad-
vances in Neural Information Processing Systems 31, pages
7967–7977.

Collins, M., Globerson, A., Koo, T., Carreras, X., and Bartlett,
P. L. (2008). Exponentiated gradient algorithms for con-
ditional random ﬁelds and max-margin Markov networks.
Journal of Machine Learning Research, 9(Aug):1775–1822.

Combettes, P. L. and Pesquet, J.-C. (2011). Proximal splitting
methods in signal processing. In Fixed-point Algorithms for
Inverse Problems in Science and Engineering, pages 185–212.
Springer.

Csiba, D., Qu, Z., and Richtárik, P. (2015). Stochastic dual
coordinate ascent with adaptive probabilities. In Proceedings
of the 32nd International Conference on Machine Learning,
pages 674–683.

Defazio, A., Bach, F., and Lacoste-Julien, S. (2014). SAGA:
A fast incremental gradient method with support for non-
strongly convex composite objectives. In Advances in Neural
Information Processing Systems 27.

Defazio, A. and Bottou, L. (2019). On the ineﬀectiveness of
variance reduced optimization for deep learning. Advances
in Neural Information Processing Systems 33.

et al.

iLCSS | October 5, 2020 |

vol. XXX | no. XX | 11

Fang, C., Li, C. J., Lin, Z., and Zhang, T. (2018). Spider:
Near-optimal non-convex optimization via stochastic path-
In Advances in Neural
integrated diﬀerential estimator.
Information Processing Systems 31, pages 689–699.

Fletcher, R. (1970). A new approach to variable metric algo-

rithms. The Computer Journal, 13(3):317–323.

Frostig, R., Ge, R., Kakade, S. M., and Sidford, A. (2015).
Competing with the empirical risk minimizer in a single
pass. In Conference on Learning Theory, pages 728–763.

Garber, D. and Hazan, E. (2015). Fast and simple PCA via

convex optimization. CoRR, abs/1509.05647.

Gazagnadou, N., Gower, R. M., and Salmon, J. (2019). Op-
timal mini-batch and step sizes for SAGA. In Proceedings
of the 36th International Conference on Machine Learning,
volume 97, pages 2142–2150.

Goldfarb, D. (1970). A family of variable-metric methods
derived by variational means. Mathematics of Computation,
24(109):23–26.

Gong, P. and Ye, J. (2014). Linear convergence of variance-
reduced stochastic gradient without strong convexity.
arXiv:1406.1102.

Kingma, D. P. and Ba, J. (2015). Adam: A method for
stochastic optimization. In 3rd International Conference on
Learning Representations (ICLR).

Konečný, J., Liu, J., Richtárik, P., and Takáč, M. (2016).
Mini-batch semi-stochastic gradient descent in the proximal
setting. Journal of Selected Topics in Signal Processing,
pages 242–255.

Konecný, J. and Richtárik, P. (2013). Semi-stochastic gradient

descent methods. CoRR, abs/1312.1666.

Kovalev, D., Horváth, S., and Richtárik, P. (2020). Don’t jump
through hoops and remove those loops: SVRG and Katyusha
are better without the outer loop. In Proceedings of the 31st
International Conference on Algorithmic Learning Theory.

Kovalev, D., Mishchenko, K., and Richtárik, P. (2019). Stochas-
tic Newton and cubic Newton methods with simple local
linear-quadratic rates.
In NeurIPS Beyond First Order
Methods Workshop.

Kulunchakov, A. and Mairal, J. (2019). Estimate sequences
for variance-reduced stochastic composite optimization. In
International Conference on Machine Learning, pages 3541–
3550.

Gorbunov, E., Hanzely, F., and Richtárik, P. (2019). A uniﬁed
theory of SGD: Variance reduction, sampling, quantization
and coordinate descent. arXiv:1905.11261.

Lan, G. and Zhou, Y. (2018). An optimal randomized in-
cremental gradient method. Mathematical Programming,
171(1-2):167–215.

Gower, R., Goldfarb, D., and Richtarik, P. (2016). Stochastic
block BFGS: Squeezing more curvature out of data. In Pro-
ceedings of The 33rd International Conference on Machine
Learning, volume 48, pages 1869–1878.

Le Roux, N., Schmidt, M., and Bach, F. (2012). A stochastic
gradient method with an exponential convergence rate for
ﬁnite training sets.
In Advances in Neural Information
Processing Systems, pages 2663–2671.

Gower, R. M., Loizou, N., Qian, X., Sailanbayev, A., Shulgin,
E., and Richtárik, P. (2019). SGD: General Analysis and
Improved Rates. In Proceedings of the 36th International
Conference on Machine Learning, volume 97, pages 5200–
5209.

Gower, R. M., Richtárik, P., and Bach, F. (2018). Stochastic
quasi-gradient methods: Variance reduction via Jacobian
sketching. arXiv:1805.02632.

Leblond, R., Pedregosa, F., and Lacoste-Julien, S. (2017).
ASAGA: Asynchronous parallel SAGA. In International
Conference on Artiﬁcial Intelligence and Statistics (AIS-
TATS).

Lei, L. and Jordan, M. (2017). Less than a single pass: Stochas-
tically controlled stochastic gradient. In International Con-
ference on Artiﬁcial Intelligence and Statistics (AISTATS),
pages 148–156.

Harikandeh, R., Ahmed, M. O., Virani, A., Schmidt, M.,
Konečný, J., and Sallinen, S. (2015). Stop wasting my gradi-
ents: Practical SVRG. In Advances in Neural Information
Processing Systems 28, pages 2251–2259.

Lian, X., Wang, M., and Liu, J. (2017). Finite-sum compo-
sition optimization via variance reduced gradient descent.
In International Conference on Artiﬁcial Intelligence and
Statistics.

Hofmann, T., Lucchi, A., Lacoste-Julien, S., and McWilliams,
B. (2015). Variance reduced stochastic gradient descent
with neighbors. In Neural Information Processing Systems
28, pages 2305–2313.

Lin, H., Mairal, J., and Harchaoui, Z. (2018). Catalyst accel-
eration for ﬁrst-order convex optimization: from theory to
practice. Journal of Machine Learning Research (JMLR).,
18(212):1–54.

Johnson, R. and Zhang, T. (2013). Accelerating stochastic
gradient descent using predictive variance reduction. In Ad-
vances in Neural Information Processing Systems 26, pages
315–323.

Karimi, H., Nutini, J., and Schmidt, M. (2016). Linear con-
vergence of gradient and proximal-gradient methods under
the Polyak-łojasiewicz condition. In Joint European Con-
ference on Machine Learning and Knowledge Discovery in
Databases, pages 795–811. Springer.

Lohr, S. (1999). Sampling: Design and Analysis. Duxbury

Press.

Mahdavi, M. and Jin, R. (2013). MixedGrad: An O(1/T) con-
vergence rate algorithm for stochastic smooth optimization.
arXiv:1307.7192.

Mairal, J. (2015). Incremental majorization-minimization op-
timization with application to large-scale machine learning.
SIAM Journal on Optimization, 25(2):829–855.

12 |

et al.

Malitsky, Y. and Mishchenko, K. (2019). Adaptive gradient

descent without descent. arXiv:1910.09529.

Mokhtari, A. and Ribeiro, A. (2014). Regularized stochastic
BFGS algorithm. IEEE Transactions on Signal Processing,
62:1109–1112.

Mokhtari, A. and Ribeiro, A. (2015). Global convergence of
online limited memory BFGS. The Journal of Machine
Learning Research, 16:3151–3181.

Moritz, P., Nishihara, R., and Jordan, M. I. (2016). A linearly-
convergent stochastic L-BFGS algorithm. In International
Conference on Artiﬁcial Intelligence and Statistics, pages
249–258.

Needell, D., Srebro, N., and Ward, R. (2015). Stochastic gradi-
ent descent, weighted sampling, and the randomized Kacz-
marz algorithm. Mathematical Programming, 155(1):549–
573.

Nesterov, Y. (1983). A method for solving a convex pro-
gramming problem with convergence rate O(1/k2). Soviet
Mathematics Doklady, 27(2):372–376.

Nesterov, Y. (2012). Eﬃciency of coordinate descent methods
on huge-scale optimization problems. SIAM Journal on
Optimization, 22(2):341–362.

Nesterov, Y. (2014). Introductory Lectures on Convex Opti-
mization: A Basic Course. Springer Publishing Company,
Incorporated, 1 edition.

Nesterov, Y. and Polyak, T. B. (2006). Cubic regularization of
newton method and its global performance. Mathematical
Programming, pages 177–205.

Nguyen, L. M., Liu, J., Scheinberg, K., and Takáč, M. (2017).
SARAH: A novel method for machine learning problems
using stochastic recursive gradient. In Proceedings of the 34th
International Conference on Machine Learning, volume 70,
pages 2613–2621.

Palaniappan, B. and Bach, F. (2016). Stochastic variance
reduction methods for saddle-point problems. In Advances
in Neural Information Processing Systems, pages 1416–1424.

Papini, M., Binaghi, D., Canonaco, G., Pirotta, M., and
Restelli, M. (2018). Stochastic variance-reduced policy gra-
dient. In Proceedings of the 35th International Conference
on Machine Learning, volume 80, pages 4026–4035.

Polyak, B. (1963). Gradient methods for the minimisation of
functionals. Ussr Computational Mathematics and Mathe-
matical Physics, 3:864–878.

Qian, X., Qu, Z., and Richtárik, P. (2019). SAGA with
arbitrary sampling. In The 36th International Conference
on Machine Learning.

Qu, Z., Richtárik, P., and Zhang, T. (2015). Quartz: Ran-
domized dual coordinate ascent with arbitrary sampling. In
Proceedings of the 28th International Conference on Neural
Information Processing Systems, pages 865–873.

Reddi, S. J., Hefny, A., Sra, S., Póczos, B., and Smola, A.
(2016a). Stochastic variance reduction for nonconvex opti-
mization. In Proceedings of The 33rd International Confer-
ence on Machine Learning, volume 48, pages 314–323.

Reddi, S. J., Sra, S., Póczos, B., and Smola, A. (2016b). Fast
incremental method for smooth nonconvex optimization. In
2016 IEEE 55th Conference on Decision and Control, pages
1971–1977.

Richtárik, P. and Takáč, M. (2014).

Iteration complexity
of randomized block-coordinate descent methods for mini-
mizing a composite function. Mathematical Programming,
144(2):1–38.

Robbins, H. and Monro, S. (1951). A stochastic approximation
method. Annals of Mathematical Statistics, 22:400–407.

Roosta-Khorasani, F. and Mahoney, M. W. (2019). Sub-
sampled Newton methods. Mathematical Programmming,
174(1–2).

Schmidt, M., Le Roux, N., and Bach, F. (2017). Minimizing
ﬁnite sums with the stochastic average gradient. Mathemat-
ical Programming, 162(1):83–112.

Schmidt, M. W., Babanezhad, R., Ahmed, M. O., Defazio, A.,
Clifton, A., and Sarkar, A. (2015). Non-uniform stochastic
average gradient method for training conditional random
ﬁelds. In Proceedings of the Eighteenth International Con-
ference on Artiﬁcial Intelligence and Statistics, AISTATS.

Schraudolph, N. N. and Simon, G. (2007). A stochastic quasi-
Newton method for online convex optimization. In Proceed-
ings of 11th International Conference on Artiﬁcial Intelli-
gence and Statistics.

Sebbouh, O., Gazagnadou, N., Jelassi, S., Bach, F., and Gower,
R. M. (2019). Towards closing the gap between the theory
and practice of SVRG. In Advances in Neural Information
Processing Systems 32, pages 646–656.

Shalev-Shwartz, S. (2016). SDCA without duality, regulariza-
tion, and individual convexity. In Proceedings of The 33rd
International Conference on Machine Learning, volume 48,
pages 747–754.

Shalev-Shwartz, S. and Zhang, T. (2013). Stochastic dual
coordinate ascent methods for regularized loss. Journal of
Machine Learning Research, 14(1):567–599.

Shalev-Shwartz, S. and Zhang, T. (2014). Accelerated proximal
stochastic dual coordinate ascent for regularized loss mini-
mization. In International Conference on Machine Learning,
pages 64–72.

Qu, Z., Richtárik, P., Takáč, M., and Fercoq, O. (2016). SDNA:
Stochastic dual Newton ascent for empirical risk minimiza-
tion. In The 33rd International Conference on Machine
Learning, pages 1823–1832.

Shamir, O. (2015). A stochastic PCA and SVD algorithm
with an exponential convergence rate. In Proceedings of the
32nd International Conference on Machine Learning, ICML
2015, volume 37, pages 144–152.

et al.

iLCSS | October 5, 2020 |

vol. XXX | no. XX | 13

Shanno, D. F. (1971). Conditioning of quasi-Newton methods
for function minimization. Mathematics of Computation,
24(111):647–656.

Strohmer, T. and Vershynin, R. (2009). A randomized kacz-
marz algorithm with exponential convergence. Journal of
Fourier Analysis and Applications, 15(2):262.

Takáč, M., Bijral, A., Richtárik, P., and Srebro, N. (2013).
Mini-batch primal and dual methods for SVMs. In 30th
International Conference on Machine Learning, pages 537–
552.

Zhou, D., Xu, P., and Gu, Q. (2018). Stochastic nested vari-
ance reduced gradient descent for nonconvex optimization.
In Advances in Neural Information Processing Systems 31,
pages 3921–3932.

Zhou, D., Xu, P., and Gu, Q. (2019). Stochastic variance-
reduced cubic regularization methods. Journal of Machine
Learning Research, 20(134):1–47.

Zou, D., Xu, P., and Gu, Q. (2019). Stochastic gradient
hamiltonian monte carlo methods with recursive variance
reduction. In Advances in Neural Information Processing
Systems 32, pages 3830–3841.

Vainsencher, D., Liu, H., and Zhang, T. (2015). Local smooth-
ness in variance reduced optimization. In Advances in Neural
Information Processing Systems, pages 2179–2187.

A. Lemmas

Wai, H.-T., Hong, M., Yang, Z., Wang, Z., and Tang, K.
(2019). Variance reduced policy evaluation with smooth
function approximation. In Advances in Neural Information
Processing Systems 32, pages 5776–5787.

Wang, X., Ma, S., Goldfarb, D., and Liu, W. (2017). Stochastic
quasi-Newton methods for nonconvex stochastic optimiza-
tion. SIAM Journal of Optimization, 27:927–956.

Wang, Z., Zhou, Y., Liang, Y., and Lan, G. (2018). Sample
complexity of stochastic variance-reduced cubic regulariza-
tion for nonconvex optimization. CoRR, abs/1802.07372.

Woodworth, B. E. and Srebro, N. (2016). Tight complexity
bounds for optimizing composite objectives. In Advances in
Neural Information Processing Systems 29, pages 3639–3647.

Xiao, L. and Zhang, T. (2014). A proximal stochastic gradient
method with progressive variance reduction. SIAM Journal
on Optimization, 24(4):2057–2075.

Xu, P., Gao, F., and Gu, Q. (2019). An improved convergence
analysis of stochastic variance-reduced policy gradient. In
Proceedings of the Thirty-Fifth Conference on Uncertainty
in Artiﬁcial Intelligence, page 191.

Zhang, J. and Xiao, L. (2020). Stochastic variance-reduced
prox-linear algorithms for nonconvex composite optimiza-
tion. Technical report, Microsoft.

Zhang, L., Mahdavi, M., and Jin, R. (2013). Linear con-
vergence with condition number independent access of full
gradients. In Advances in Neural Information Processing
Systems, pages 980–988.

Zhang, Y. and Xiao, L. (2017). Stochastic primal-dual coordi-
nate method for regularized empirical risk minimization. The
Journal of Machine Learning Research, 18(1):2939–2980.

Zhong, L. W. and Kwok, J. T. (2014). Fast stochastic al-
ternating direction method of multipliers. In Proceedings
of the 31st International Conference on Machine Learning,
volume 32, pages 46–54.

Zhou, D. and Gu, Q. (2019). Lower bounds for smooth non-
convex ﬁnite-sum optimization. International Conference
on Machine Learning, pages 7574–7583.

14 |

Here we provide and prove several auxiliary lemmas.

Lemma A.1. Let fi(x) be convex and Lmax-smooth for i =
1, . . . , n. Let i be sampled uniformly on average from {1, . . . , n}.
It follows that for every x ∈ Rd we have that

(cid:2)k∇fi(x) − ∇fi(x?)k

2(cid:3) ≤ 2Lmax(f (x) − f (x?)).

Ek

[34]

Proof. Since fi is convex we have that

fi(z) ≥ fi(x?) + h∇fi(x?), z − x?i ,

∀z ∈ Rd,

[35]

and since fi is smooth we have that

fi(z) ≤ fi(x) + h∇fi(x), z − xi +

∀z, x ∈ Rd,
[36]
see Section 2.1.1 in Nesterov (2014) for more equivalent ways
of re-writing convexity and smoothness.
It follows for all
x, z ∈ Rd that

kz − xk

,

2

Lmax
2

fi(x?) − fi(x)

=
[35]+[36]
≤

fi(x?) − fi(z) + fi(z) − fi(x)

h∇fi(x?), x? − zi + h∇fi(x), z − xi

+

Lmax
2

kz − xk

2

.

To get the tightest upper bound on the right hand side, we
can minimize the right hand side in z, which gives

z = x −

1
Lmax

(∇fi(x) − ∇fi(x?)).

[37]

Substituting this in the above gives
D

fi(x?) − fi(x) =

∇fi(x?), x? − x +

(∇fi(x) − ∇fi(x?))

E

1
Lmax

−

+

1
Lmax
1
2Lmax

h∇fi(x), ∇fi(x) − ∇fi(x?)i

k∇fi(x) − ∇fi(x?)k

2

= h∇fi(x?), x? − xi

−

1
2Lmax

2
k∇fi(x) − ∇fi(x?)k

.

Taking expectation over i in the above and using that
(cid:4)
Ei [fi(x)] = f (x) and E [∇fi(x?)] = 0, gives the result.

Lemma A.2. Let X ∈ Rd be a random vector with ﬁnite
variance. It follows that

E (cid:2)kX − E [X]k

2(cid:3) ≤ E (cid:2)kXk

2(cid:3).

[38]

et al.

Proof.

E (cid:2)kX − E [X]k

2(cid:3) = E (cid:2)kXk
= E (cid:2)kXk

2(cid:3) − 2E [kXk]
2(cid:3) − E [kXk]

2

2

2

+ E [kXk]
2(cid:3).
≤ E (cid:2)kXk

Now by choosing γ ≤ 1

we have that γLmax −1 < 0 and
consequently 2γ(γLmax − 1)(f (xk) − f (x?)) is negative since
f (xk) − f (x?) ≥ 0. So it now follows by taking expectation
in [45] that

Lmax

[39]

(cid:4)

E (cid:2)kxk+1 − x?k

2(cid:3) ≤ (1 − µγ)E (cid:2)kxk − x?k

2(cid:3).

(cid:4)

B. Convergence Proof Illustrated via SGD?

For all VR methods, the ﬁrst steps of proving convergence are
the same. First we expand

2
kxk+1 − x?k

2
= kxk − x? − γgkk

= kxk − x?k

2

− 2γ hxk − x?, gki + γ

2

2
kgkk

.

Now taking expectation conditioned on xk and using [6], we
arrive at

(cid:2)kxk+1 − x?k

2(cid:3) = kxk − x?k

2

+ γ

2

Ek

(cid:2)kgkk

2(cid:3)

Ek

− 2γ hxk − x?, ∇f (xk)i .

Using either convexity or strong convexity, we can get rid
of the hxk − x?, ∇f (xk)i term.
In particular, since f (x) is
µ-strongly convex, we have

(cid:2)kxk+1 − x?k

Ek

2(cid:3) ≤ (1 − µγ)kxk − x?k
− 2γ(f (xk) − f (x?)).

2

+ γ

2

Ek

(cid:2)kgkk

2(cid:3)

[40]

(cid:2)kgkk

To conclude the proof, we need a bound on the second moment
2(cid:3) of gk. For the plain vanilla SGD, often it is simply
Ek
assumed that this variance term is bounded uniformly by an
unknown constant B > 0. But this assumption rarely holds
in practice, and even when it does, the resulting convergence
speed depends on this unknown constant B. In contrast, for a
VR method we can explicitly control the second moment of gk
since we can control the variance of gk and

(cid:2)kgk − ∇f (xk)k

2(cid:3) = E (cid:2)kgkk

2(cid:3) − k∇f (xk)k

2

.

Ek

[41]

To illustrate, we now prove the convergence of SGD?.

Theorem B.1 (?). Consider the iterates of SGD? [13].
If Assumptions 1.1 and 1.2 hold and γ ≤ 1
, then
the iterates converge linearly with

Lmax

E (cid:2)kxk+1 − x?k

2(cid:3) ≤ (1 − γµ)E (cid:2)kxk − x?k

2(cid:3).

[42]

Thus, the iteration complexity of SGD? is given by

k ≥

Lmax
µ

log

(cid:17)

(cid:16) 1
ε

⇒

E (cid:2)kxk − x?k
kx0 − x?k

2(cid:3)
2 < ε.

[43]

Proof. Using Lemma A.1, we have
(cid:2)kgkk

2(cid:3) = Ek

Ek

(cid:2)k∇fi(xk) − ∇fi(x?)k

2(cid:3)

≤ 2Lmax(f (xk) − f (x?)).

[44]

Using the above in [40] we have

(cid:2)kxk+1 − x?k

2(cid:3) ≤ (1 − µγ)kxk − x?k

2

Ek

+ 2γ(γLmax − 1)(f (xk) − f (x?)).

[45]

This proof also shows that the shifted SGD method is a

variance-reduced method. Indeed, since

E (cid:2)kgk − ∇f (xk)k

2(cid:3) = E (cid:2)k∇fi(xk) − ∇fi(x?) − ∇f (xk)k

2(cid:3)

≤ E (cid:2)k∇fi(xk) − ∇fi(x?)k
≤ 2Lmax(f (xk) − f (x?)),

2(cid:3)

where in the ﬁrst inequality we used Lemma A.2 with X =
∇fi(xk) − ∇fi(x?).

Robert M. Gower is a visiting re-
searcher at Facebook AI Research (2020
New York) and joined Télécom Paris as
an Assistant Professor in 2017. He is in-
terested in designing and analyzing new
stochastic algorithms for solving big data
problems in machine learning and scien-
tiﬁc computing. A mathematician by
training, his academic studies started
with a Bachelors and a Masters degree in applied mathematics
at the state University of Campinas (Brazil), where he de-
signed the current state-of-the-art algorithms for automatically
calculating high order derivatives using back-propagation.

Mark Schmidt is an associate pro-
fessor in the Department of Computer
Science at the University of British
Columbia. His research focuses on ma-
chine learning and numerical optimiza-
tion. He is a Canada Research Chair,
Alfred P. Sloan Fellow, CIFAR Canada
AI Chair with the Alberta Machine In-
telligence Institute (Amii), and was awarded the SIAM/MOS
Lagrange Prize in Continuous Optimization with Nicolas Le
Roux and Francis Bach.

Francis Bach is a researcher at In-
ria, leading since 2011 the machine learn-
ing team which is part of the Computer
Science department at École Normale
Supérieure. He graduated from École
Polytechnique in 1997 and completed
his Ph.D. in Computer Science at U.C.
Berkeley in 2005, working with Professor
Michael Jordan. He spent two years in
the Mathematical Morphology group at École des Mines de
Paris, then he joined the computer vision project-team at
Inria/École Normale Supérieure from 2007 to 2010. Francis
Bach is primarily interested in machine learning, and espe-
cially in sparse methods, kernel-based learning, large-scale
optimization, computer vision and signal processing. He ob-
tained in 2009 a Starting Grant and in 2016 a Consolidator
Grant from the European Research Council, and received the
Inria young researcher prize in 2012, the ICML test-of-time

et al.

iLCSS | October 5, 2020 |

vol. XXX | no. XX | 15

award in 2014, as well as the Lagrange prize in continuous
optimization in 2018, and the Jean-Jacques Moreau prize in
2019. In 2015, he was program co-chair of the International
Conference in Machine learning (ICML), and general chair in
2018. He is now co-editor-in-chief of the Journal of Machine
Learning Research.

Peter Richtárik is a Professor of
Computer Science and Mathematics at
KAUST. He is an EPSRC Fellow in Math-
ematical Sciences, Fellow of the Alan
Turing Institute, and is aﬃliated with
the Visual Computing Center and the
Extreme Computing Research Center at
KAUST. Prof. Richtárik received his
PhD from Cornell University in 2007, and
then worked as a Postdoctoral Fellow in
Louvain, Belgium, before joining Edin-
burgh in 2009, and KAUST in 2017. His research interests lie
at the intersection of mathematics, computer science, machine
learning, optimization, numerical linear algebra, and high
performance computing. Through his recent work on random-
ized decomposition algorithms (such as randomized coordinate
descent methods, stochastic gradient descent methods and
their numerous extensions, improvements and variants), he
has contributed to the foundations of the emerging ﬁeld of big
data optimization, randomized numerical linear algebra, and
stochastic methods for empirical risk minimization. Several of
his papers attracted international awards to his collaborators,
including the SIAM SIGEST Best Paper Award, the IMA
Leslie Fox Prize (2nd prize, three times), and the INFORMS
Computing Society Best Student Paper Award (sole runner
up).

16 |

et al.

