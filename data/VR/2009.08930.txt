0
2
0
2

p
e
S
8
1

]
E
S
.
s
c
[

1
v
0
3
9
8
0
.
9
0
0
2
:
v
i
X
r
a

Towards the Systematic Testing of Virtual Reality Programs (extended
version)
Preprint, compiled September 21, 2020

Stevão A. Andrade1, Fatima L. S. Nunes2, and Marcio E. Delamaro1

Universidade de São Paulo
1Instituto de Ciências Matemáticas e de Computação
2Escola de Artes, Ciências e Humanidades
{stevao, delamaro}@icmc.usp.br, fatima.nunes@usp.br

Abstract

Abstract
Software testing is a critical activity to ensure that software complies with its speciﬁcation. However, current
software testing activities tend not to be completely eﬀective when applied in speciﬁc software domains in
Virtual Reality (VR) that has several new types of features such as images, sounds, videos, and diﬀerentiated
interaction, which can become sources of new kinds of faults. This paper presents an overview of the main
VR characteristics that can have an impact on veriﬁcation, validation, and testing (VV&T). Furthermore, it
analyzes some of the most successful VR open-source projects to draw a picture concerning the danger of the
lack of software testing activities. We compared the current state of software testing practice in open-source VR
projects and evaluate how the lack of testing can be damaging to the development of a product. We assessed
the incidence of code smells and veriﬁed how such projects behave concerning the tendency to present faults.
We also perform the same analyses on projects that are not VR related to have a better understanding of these
results. The results showed that the practice of software testing is not yet widespread in the development of VR
applications. It was also found that there is a high incidence of code smells in VR projects. Analyzing Non-VR
projects we noticed that classes that have test cases tend to produce fewer smells compared to classes that were
not tested. Regarding fault-proneness analysis, we used an unsupervised approach to VR and Non-VR projects.
Results showed that about 12.2% of the classes analyzed in VR projects are fault-prone, while Non-VR projects
presented a lower fault-proneness rate (8.9%). Regarding the application of software testing techniques on VR
projects, it was observed that only a small number of projects are concerned about developing test cases for VR
projects, perhaps because we still do not have the necessary tools to help in this direction. Concerning smells,
we concluded that there is a high incidence in VR projects, especially regarding implementing smells and this
high incidence can have a signiﬁcant inﬂuence on faults. Finally, the study related to fault proneness pointed out
that the lack of software testing activity is a signiﬁcant risk to the success of the projects.

Keywords Software Testing · Virtual Reality · Validation · Veriﬁcation · Code Smells · Fault Proneness

1 Introduction

Researchers have studied software faults extensively. These
studies lead to the characterization of defects, both in the theo-
retical and practical contexts. Such characterization is essential
to evaluate software testing techniques concerning their ability
to reveal certain types of faults. These characterizations and tax-
onomies can provide guides for deﬁning test approaches, which
can support fault detection in speciﬁc software domains.

Technological advancement has led to the development of sys-
tems with new features such as images, sounds, videos, and
diﬀerentiated interaction. Thus, technologies such as Virtual Re-
ality (VR) have led to possibilities of creating three-dimensional
environments with real-time interaction.

There are various techniques to obtain a greater sensation of
immersion, according to the computational resources, equipment
and systems used, vision, touch, and hearing experiences can
be reproduced. Thus, in addition to simulating real situations,
VR also allows users to depict and interact with hypothetical
situations, involving static or moving virtual objects.

Despite the great beneﬁts of adopting VR for the development
of applications in various areas, it poses new challenges for
veriﬁcation, validation, and testing (VV&T) activities. For ex-
ample, VR software presents original software structures, such
as scene graphs, which may represent new sources of defects for
programs. These new challenges motivated the development of
some approaches that aim to contribute to the quality assurance
process of software in the context of VR.

As mentioned by Corrêa et al. [Corrêa et al., 2013], there is
interest in the literature on the subject. However, there is still
no concept regarding systematized practices for conducting this
activity. Studies have shown that the major problem remains in
the diﬃculty to deal with test oracles, which is considered to be
an open-ended research problem.

In general, the test activities for the VR domain are manually
performed and mostly conducted only after the end of the de-
velopment phase [Corrêa et al., 2018]. Such events generally
support the generation of test requirements (functional and non-
functional) which must be guaranteed before the product is de-
livered. The lack of studies that evaluate the cost of developing
new techniques or using existing ones assess their eﬀectiveness

 
 
 
 
 
 
Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

2

or even propose tools that can support their application, thus
contributing to impact VV&T activities in general and aggravate
this scenario.

Regardless of the programming technology used, a primary
development goal is to produce high-quality software. Con-
sequently, VR also needs to be tested and vetted for quality.
According to Neves et al. [Neves et al., 2018] there are series of
conceptual challenges and key questions related to quality that
need to be addressed when planning to apply software testing
practices in new domains: What should be tested?, What does
“adequate testing" mean?, What is a failure in VR software?, Can
we reuse something?, What is done nowadays?

Systematic testing of the VR system must be based on fault
models that reﬂect the structural and behavioral characteristics
of VR software. Criteria and strategies for testing VR should be
developed based on that fault model.

In this paper, we discuss whether new challenges for VV&T of
VR exist that require novel techniques and methods, or instead,
we need new ways of combining and using existing approaches.
We also try to evaluate how much the lack of VV&T activities
can negatively impact VR software development. To do so,
we analyze the most popular open-source projects and catego-
rize fault-proneness codes that could be mitigated by adopting
VV&T activities.

This paper is organized as follows: Section 2 present the related
work and discusses how they diﬀer from our work; Section 3
discusses the critical questions described above, as well as what
testing approaches proposed in other domains could be reused
for the VR domain; Section 4 presents an exploratory study to
assess how much the lack of VV&T activities can be prejudicial
to open-source projects; Section 5 discusses the results of the
experiment presented; Section 6 points out some limitations
related to this study; ﬁnally the conclusions and future work are
shown in Section 7.

2 Related Work

Although virtual
reality studies date back a long time
[Boman, 1995], only recently have few studies addressed the
development of VR applications from a software engineering
perspective. The increase in community interest has emerged
with the recent popularization of tools that have facilitated ac-
cess, and consequently developers’ interest in this technology,
which is still considered as emerging.

Rodriguez and Wang [Rodriguez and Wang, 2017] present a sur-
vey about projects developed for the Unity platform, highlighting
the growth of the number of projects in recent years. Another
highlight is the fact that despite the higher number of applica-
tions focused on games and entertainment, there has been an
increase in the number of applications for other purposes, such
as training and simulations.

Unlike our work, the paper does not analyze the content of
the cataloged material in detail, and is limited to studying the
growing trends, development involvement, favorite topics, and
frequent ﬁle changes in these projects.

Ghrairi et al. [Ghrairi et al., 2018] conducted a study on the
exploratory analysis of Github projects and questions extracted

from StackOverﬂow, analyzing it from a software engineering
point of view. The study demonstrates the current state of prac-
tice regarding the development of open-source VR applications,
highlighting mainly the most used platforms and technologies.
Moreover, the paper also discusses topics of interest for VR
developers by analyzing the VR questions extracted from Stack-
Overﬂow.

The main results show the greater popularity of the Unity and
Unreal Engine platforms as being the most popular among VR
application developers. However, they also point out that more
work needs to be done to better understand the VR requirements
under a software engineering context, which is one of the points
that our work seeks to elucidate.

From the perspective of software testing applications in the con-
text of VR, we highlight the work produced by Corrêa et al.
[Corrêa et al., 2018], which presents a proposal for application
software testing for VR applications. This study generates test
data using speciﬁed requirements through a semi-formal lan-
guage for VR application development. This approach moves in
the direction pointed out by our study, which is the proposition
of mechanisms that allow the systematization of the test activity
for VR applications.

Karre et al. [Karre et al., 2019] conducted a year-long multi-
level exploratory study to understand the various software de-
velopment practices within VR product development teams in
order to understand whether the traditional software engineering
practices are still exercised during VR product development.
The main results show that VR practitioners adopted hybrid
software engineering approaches in VR product development
and, in general, interviewed developers complain about the lack
of software testing tools. An alternative presented to solve this
problem is the involvement of consumers during the testing (pre-
release versions) phase to understand the customer experiences
and reactions.

Posteriorly Karre et al. [Karre et al., 2020] also assessed aspects
related to tasks such as scene design, acoustic design, vergence
manipulation, image depth, etc. which are speciﬁc to VR apps
and hence require evaluation processes that may be diﬀerent
from the traditional ones. They presented a categorization that
can support decision making in choosing a usability evaluation
method for the future development of VR products. By using
the categorization, the teams can use unique methods to improve
the usability of their products, once depending on the industry
(automobile, education, healthcare, etc.) the usability and the
metrics of evaluation methods can change.

3 Challenges and Issues

in the VR literature is to deﬁne a
The central concept
more advanced form of user-computer interaction in real-
time using synthetic three-dimensional multisensory devices
[Burdea and Coiﬀet, 1994, LaValle, 2019]. Objects can be pre-
sented, providing a sense that they are not the same as the user’s
perception when observing them in a limited area, such as a
monitor screen.

VR can be classiﬁed according to the user’s presence, as im-
mersive and non-immersive. It is said to be immersive when
the user has the sensation of being present within the virtual

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

3

world using sensory devices (stereoscopic glasses or helmets
with motion trackers) that capture their movements and behavior.
Moreover, it is considered non-immersive when the user is par-
tially transported to the virtual world via a monitor or projector
[Tori et al., 2006].

According to Machado et al. [Machado et al., 2003] and LaValle
[LaValle, 2019], immersion, and interactivity correspond to how
the user interacts with the virtual environment, using devices
that allow the manipulation of virtual objects. Several graphical
libraries have emerged to help develop applications that repro-
duce requirements in a virtual environment; these libraries act as
an abstraction layer providing information about the device’s po-
sition or orientation, without the application knowing in which
device the information is processed.

Despite the beneﬁts of adopting VR for the development of appli-
cations in several areas, this poses new challenges for software
quality assurance activities. For example, software developed
for the context of VR has unique software structures, which
may represent new sources of faults for the programs developed
[Takala et al., 2017]. These new challenges have motivated the
development of some approaches that aim to contribute to the
quality assurance process of software in the context of VR.

Automating software testing activities is often a complicated
and challenging process. The main tasks of this activity include
organizing, executing, registering the execution of the test cases,
and verifying the result of their execution.

In order to address these tasks, in the context of VR, some key
points discussed in the next subsections should be understood.

3.1 What should be tested?

Virtual reality systems use individual hardware devices to al-
low the interaction with the user and the system. The work of
graphics engines is not the primary concern for VR application
developers. Deﬁning scene graphs for organizing 3D objects
in a VR world, managing virtual users, controlling sensors for
detecting events such as object collision and processing events
for reacting to user inputs are some of the typical elements
of VR systems that the developers should be concerned about
[Zhao, 2009].

According to Runeson [Runeson, 2006], unit testing aims to test
the smallest units that make up the system, thus ensuring the
proper functioning of elements and easy-to-ﬁnd programming
faults, incorrect or poorly implemented algorithms, incorrect
data structures, limiting the internal logic within the limits of
the unit.

Figure 1 presents a general architecture of VR applications, as
we can observe, VR applications diﬀer from general programs by
handling speciﬁc devices, and data structures used to represent
the objects in a three-dimensional scene. Beyond represent
various aspects of the real or imaginary world, such as geometric
descriptions, appearance, transformations, behaviors, cameras,
and lighting. Each of the properties above is created, aiming to
represent objects present in a virtual environment, thus emerging
new challenges related to how to test them.

By observing the organization of 3D object elements and assets
in scene graphs, it seems that it needs a higher-level type of
In general, because they are independent, they do not
test.

have an architecture correlation of the source code. Therefore,
integration testing tends to be a more appropriate approach to
be used. In integration testing, the main aim is to verify the
communication between the units that make up the system.

3.2 What does “adequate testing” mean?

The solution to deﬁne this question: “What does adequate test-
ing mean?" is to apply test criteria, which consists of a set of
rules for dividing and evaluating the valid input domain for the
program being tested. A test criterion deﬁnes elements of a pro-
gram that must be exercised during its execution, thereby guiding
the tester in the process of designing the test cases for the system.
A test requirement may be, for example, a software-speciﬁc ex-
ecution path, a functionality obtained through speciﬁcation, a
mutation-based approach, etc [Bertolino, 2003].
As pointed out in the previous question, due to the diﬀerent
structures existing in VR applications, it is diﬃcult to deﬁne
which aspects of a VR application should be considered when
designing a test routine for VR applications. For example, the
Figure 2 shows that for a single frame existing in a 3D scene,
there are diﬀerent layers that have diﬀerent aspects that can be
taken into account when testing the application.

Corrêa et al.
[Corrêa et al., 2013] presented a set of studies
that deal with the application of software testing techniques to
programs in the VR context, showing that there is an interest in
the literature on the subject, however, there is still no concept
regarding systematized practices for the activity.

Due to the lack of deﬁned requirements, it is not easy to identify
test adequacy criteria for VR systems. How can we decide that
testing is enough? This question needs to be adapted to the
context.

3.3 What is a failure in a VR software?

In the context of VR applications, the testing activity hinges
on the diﬃculty of systematizing how the behavior of a test
case can be measured. This diﬃculty is described in the
literature as “test oracle problems" and it appears in cases
where traditional means of measuring the execution of a
test case are impractical or are of little use in judging the
correction of outputs generated from the input domain data
[Rapps and Weyuker, 1985, Barr et al., 2014].

Test oracles deal with a primary issue in software testing activi-
ties - deciding on program correctness based on predetermined
test data. In general, the test oracle accesses a data set needed to
evaluate the correctness of the test output. This data set is taken
from the speciﬁcation of the program under testing and should
contain suﬃcient information to support the ﬁnal decision of the
Oracle [Oliveira et al., 2014].

It is possible to explore a wide range of faults in the context of
VR software. It is possible to verify the strictness of speciﬁcation
based on scene graphs concepts, in addition to speciﬁc features
related to the virtual environment, it is also possible to verify
the behavior of objects and the actions performed by multiple
devices.

As can be seen, in addition to traditional source code routines,
several characteristics need to be taken into account when testing

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

4

Figure 1: General VR application architecture (Source: own construction, based on [Capilla and Martínez, 2004])

Figure 2: Example of scene rendering process (Source: own
construction, based on [Courrèges, 2016])

and the deﬁnition of what can be considered a failure is an
important step for each of the described aspects above can be
analyzed correctly during the testing activity.

3.4 Can we reuse something?

General tools such as capturing and replaying can be used, but
they oﬀer a shallow level of abstraction. Thus, any small change
to the system will result in the fact that the tests should be redone
[Leotta et al., 2013]. Therefore, using capture and replay tools
cannot be used when the system is in development.

From a unit test point of view, we can still reuse a traditional
approach in which we can quickly gauge the expected output to
a method execution, ensuring that the smallest units of the VR
system have been suﬃciently tested against their speciﬁcations.

Regarding integration testing which is expected to handle new
kinds of elements (3D objects, assets, behaviors, etc.) the litera-
ture review shows that we still need better-systematized practices
for this activity [Corrêa et al., 2013].

3.5 What is done nowadays?

Almost all 3D applications require some common features.
Therefore, developers tend to use platforms that provide these
features out-of-the box. Using game engines is one of the most
popular techniques among developers due to the fact it helps
produce the systems, besides speeding up the development pro-
cess.

Recently popular game engines, such as Unity3D1 and Unreal
Engine2, released their own set of testing tools, which allows
developers to produce automated testing during the development
phase of the system which can substantially increase the stability
of the product developed.

Despite the existence of tools, it still does not provide observable
test criteria, perhaps due to the lack of studies that propose, ex-
periment and validate eﬀectively applicable approaches, which
can be additionally repeatable, documented and do not rely only
on the tester’s creativity.

4 Do We Really Need to Test Virtual Reality

Software?

Considering popularizing VR application development, we are
interested in understanding, from the software engineering point
of view, how the development process of these applications is
currently conducted. We are especially interested in software
testing practices in the development process of such applications
in order to address what kinds of malfunctions the lack of test
practice can lead to.

One of the most used approaches to quantify quality attributes
in software projects is the evaluation of source code metrics.
Source code metrics are a signiﬁcant component for the software
measurement process and are commonly used to measure fault
proneness and improve the quality of the source code itself
[Palomba et al., 2014].

Another factor that can be exploited to evaluate code quality is to
identify anti-patterns since some studies show that there is a cor-
relation with fault proneness [Khomh et al., 2012]. Therefore,
these are two aspects that are taken into account in the evaluation

1https://docs.unity3d.com/Manual/

testing-editortestsrunner.html

2https://docs.unrealengine.com/latest/INT/

Programming/Automation

Data creationroutinesData process3D GeometryInpute DeviceDisplayInteractionRoutinesRenderView TransformRoutinesTracker DataRoutinesPosition TrackerOrientationTrackerDataCreationDisplayModulePreprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

5

Figure 3: Steps taken to carry out the study (Source: own construction)

carried out in our study to investigate the quality aspects of the
code in the context of software testing.

Ghrairi et al. [Ghrairi et al., 2018] made an exploratory study
on Github and Stack Overﬂow in order to investigate which are
the most popular languages and engines used in VR projects.
According to their results, the most popular language for VR
development is C#, and Unity is the most used game engine dur-
ing VR application development. Thus, we focus our analyses
targeting these characteristics.

4.1 Overview of the study

We formulated the following research questions regarding the
quality analysis goal of VR projects.

• RQ1 : “How does testing happen in open-source VR
software systems?" We focus on understanding how
testing practices are being applied in open-source VR
projects.

• RQ2 : “What are the distribution of architecture, im-
plementation and design smells in VR projects?" We in-
vestigated the distribution of smells to ﬁnd out whether
there is a set of code smells that occur more frequently
in VR systems.

• RQ3 : “Can we draw a relationship between code
metrics and fault proneness?" It is commonly believed
that code metrics and fault-proneness, i.e., if a set of
code metrics reaches a predeﬁned threshold, it is very
likely that the project could also have some faults. We
investigate this using an unsupervised defect prediction
approach.

4.2 Study Design

The process of selecting open-source projects consists of a sys-
tematized search, on Github, using the keywords “virtual re-
ality" and “VR". With the objective of drawing a more spe-
ciﬁc proﬁle, the search focused only on projects developed for
the Unity platform, since it has emerged as the most popular
VR development platform due to its extensive documentation
[Ghrairi et al., 2018].

Our primary aim is to explore virtual reality projects from both
project and source code perspectives. To do so, we cataloged
and analyzed a total of 151 open-source projects, available in
Github. Some of the projects could not be analyzed due to either
missing external dependencies or custom-build mechanisms (i.e.,
missing standard C# project ﬁles), thus we were able to analyze
a total of 119 projects.

In order to draw a picture concerning research questions RQ2
and RQ3, we also cataloged a set of general (Non-VR) open-
source projects, which have similar characteristics (same C#
programming language). The goal is to try to compare the infor-
mation observed in the VR application with Non-VR application.
Therefore, we catalog a total of 177 Non-VR projects. After an
individual process analysis, we removed duplicated projects and
projects that had missing external dependencies or custom-build
mechanism. In the end we achieved a total of 107 Non-VR
projects able to be used in our experiment.

Since our goal is to analyze which impacts the lack of software
testing practice can cause on VR projects, concerning Non-VR
projects, we will use only data related to classes that have been
properly tested.

Thus, for all the experiments, two types of projects were gath-
ered. The ﬁrst is a set of VR projects. The second is a set of
general-purpose projects that hold some unit test code used to
evaluate their modules.

The purpose of the ﬁrst step is to manually evaluate VR projects
in order to understand how much open-source VR application
developers are concerned regarding testing practices for this
speciﬁc domain.

Based on the observation of the results of the initial analysis, the
second step is to assess how much the lack of software testing
activity can contribute to the construction of codes that become
more diﬃcult to maintain over time. For this, an analysis is
made regarding the presence of code smells and the results
obtained in VR projects are compared with the results obtained
in general-purpose projects.

Finally, the last step aims to assess how much code metrics are
capable to point about fault proneness. The goal is to evaluate
the projects and observe how the VR projects and projects that

GitHubVR FilterTest FilterVR AplicationsGeneral porposetested applicationsData ExtractionRQ1RQ2RQ3(1)(2)(3)(4)(5)(a)(b)Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

6

Table 1: Characteristics of the repositories used in the experiment

Small size ( 1 ∼ 80 classes) Medium size (80 ∼ 200 classes)

Large size ( 201+ classes)

Features / Characteristics
No C# Classes
No Branches
No Commits
No Contributors
No Forks
No Subscribers
No Stars

VR
31.5
1.45
78.4
2.6
34.7
15.8
111.6

non-VR

VR
121.7
1.7
48.8
2.5
10.9
8.1
23.8

30.2
1.7
45.5
1.4
1.9
2
4

non-VR

126.4
2.5
245
2.2
1
2.5
0.7

VR
374.8
2.56
66.2
2.9
76.6
22.3
187.8

non-VR

4320
11.4
8931
47.1
82.4
176.8
89.4

have been tested behave, in order to understand whether test
practice can contribute to a given code snippet being less fault-
prone regarding untested code snippets.

• Contributors - refers to the number of people outside
the main project development team who have con-
tributed or wish to contribute to changes to the project.

The procedure carried out during the execution of the experiment
is described in Figure 3 and consists of the following steps:

1. Search the Github platform for projects with the tar-

geted characteristics.
(a) VR projects that were developed using the Unity

platform.

(b) General purpose projects that were developed us-
ing the C# programming language and have soft-
ware testing practices in their composition.
2. Data extraction related to testing practice in VR appli-

cation projects.

3. Code metrics and code smells information extraction

for all projects.

4. Use of code metrics to calculate fault-proneness in all

projects.

5. Summary of the results and answer the research ques-

tions.

4.3 Overview of Projects

One of the biggest concerns when carrying out experiments
using open-source artifacts is related to the representativeness
of the artifacts and whether therefore the results found can be
properly generalized [Hillenbrand and Gayvert, 2005].

With it in mind, we were careful to try to select the largest
number of study objects, in such a way that they could meet a
wide variety of characteristics and not be limited to toy examples.
Table 1 summarizes the information on the artifacts used in the
experiments developed in this paper. The data related to the
main characteristics of the repositories are presented in the form
of average, by classifying the repositories among small projects
(with up to 80 classes), medium (with projects that have between
80 and 200 classes) and large projects with a number of higher
classes to 200.

Below we present the main features cataloged in the repositories
used:

• Branches - correspond to branches used to implement
new features or correct faults, in such a way that the
unstable code is not merged into the main project ﬁles.
• Commits - commits refer to the act of submitting the
latest source code changes to the repository and making
these changes part of the main version of the repository.

• Forks - copies from a repository. Forking a reposi-
tory allows third parties to perform experiments on the
source code without aﬀecting the original project.

• Subscribers - number of people who are registered to
receive notiﬁcations related to updates on activities and
changes made to the project.

• Stars - indicates the number of people who have deﬁned
markers in the project so that they can follow what is
happening with the project in the future ( according
to Kalliamvakou et al. [Kalliamvakou et al., 2014] this
metric is commonly used to measure the popularity of
repositories).

In order to provide a view of the general scope of the artifacts
used, Table 2 presents information about the general characteris-
tics of all projects.

Table 2: General characteristics of the analyzed projects

Attributes

Projects
Number of tested classes
Number of classes (total)
Lines of code (C# only)

VR

119
63
21,508
2,314,522

Non-VR
107
4,186
21,563
2,455,766

Aiming to estimate non-functional requirements used to evaluate
the performance of a system, such as software quality attributes
of the projects, and to give an overall view of the projects an-
alyzed, we computed, according to an object-oriented design
[Chidamber and Kemerer, 1994], a set of metrics that are sum-
marized in Table 3.

Table 3: Metrics of the analyzed projects
Non-VR
VR
3,811
716
7,062
102,785
14,374
107,516
24,395
67
1,368
49,793
1,278
4,072
9,582
65,624
7,958
34,197
21,959
190,658

Metric
Number of Children
Number of Fields
Number of Methods
Number of Properties
Number of Public Fields
Depth of Inheritance Tree
Number of Public Methods
Lack of Cohesion of Methods
Weighted Method per Class

Average
0.17
4.77
4.99
1.13
2.31
0.18
3.05
1.58
8.86

Average
0.17
1.68
3.43
0.01
0.32
0.30
2.28
1.90
5.24

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

7

All the information about the projects, the data used for plotting
the tables and graphs, as well for the discussion, are available in
the experiment repository3.

5 Results and Discussion

In this section, we address the research questions and further dis-
cuss the results obtained from the analysis and our observations
with the empirical study.

5.1 How is VR software tested?

Existing software testing techniques seek to establish rules to
deﬁne test case sets that exercise the testing requirements needed
to eliminate software faults when they exist. Testing techniques
and criteria are of paramount importance in selecting test cases
because the tester can create more eﬀective test cases, and thus
reduce the number of test cases, ensuring that speciﬁc pieces
of software are exercised by the tests. Testing techniques diﬀer
from one another in the source of information used to create the
test requirements.

Regarding the ﬁrst research question (RQ1) of the study, which
aims to understand the question: “How does testing happen in
open-source VR software systems?", the 119 projects were man-
ually evaluated and it was found that only 6 VR projects (Bowl-
master - 53 tests, CameraControls - 60 tests, GraduationGame -
15 tests, MiRepositorio_VRPAD - 11 tests, space_concept - 11
tests, UnityBenchmarkSamples - 4 tests) are concerned with the
software testing practices, including a total of 154 unit test cases,
to evaluate the projects’ functionalities.

Despite the existence of unit testing, we were unable to calculate
information regarding testing criteria, such as code coverage,
since Unity does not provide an out-of-the box solution to code
coverage (till the present time) and Unity uses its own fork of
Mono [The Mono - Unity fork, 2018], which makes it impracti-
cal to use other C# coverage tools [Haas, 2014].

Based on the information collected, it can be observed that from
the 119 analyzed projects, only 6 (5.04%) have some software
testing activity, and even the projects that have test cases, do not
present many tests that can ensure that the main functionalities
of the applications were adequately tested.

Another interesting aspect observed when analyzing the 6
projects that have test cases is the fact that the Bowlmaster
project is part of a popular course, with more than 334,000
students enrolled 4, which aims to teach VR application develop-
ment practices. This demonstrates that there is a concern on the
part of educators regarding the awareness that testing activity is
a determining factor in the software development process and it
is expected that students are capable of apply concepts related
to testing practice software in their future projects.

Concerning RQ1 we came to the conclusion that there is not yet
consensus regarding the application of software testing practices
for VR applications and this motivated us to explore the next
research questions. These results are in agreement with the most

3https://github.com/stevao-andrade/ACL_defect_

prediction

4https://github.com/CompleteUnityDeveloper/

08-Bowlmaster-Original

recent papers in the literature. Karre et al. [Karre et al., 2019]
conducted an empirical study of VR practitioners to learn the
current practices and challenges faced in industry. The software
testing related results points out to the absence of adequate tools,
as well as uncertainty about how to test the VR app apart from
conducting a standard ﬁeld evaluation. As a consequence, this
lack of usability evaluation methods and automated testing tools
tend to cost a lot of time to release a VR product.

One possible explanation is due to the challenges of system-
atizing how the behavior of a test case can be measured in the
context of VR programs. This diﬃculty is described in the
literature as a “test oracle problem" and arises in cases where
traditional means of gauging the execution of a test case are im-
practical or are of little use in judging the correctness of outputs
generated from input domain data [Rapps and Weyuker, 1985,
Barr et al., 2014]. Test oracles deal with a primary issue in soft-
ware testing activities - deciding on program correctness based
on predetermined test data. In general, the test oracle accesses
a data set needed to evaluate the correctness of the test output.
This data set is taken from the speciﬁcation of the program under
testing and should contain suﬃcient information to support the
ﬁnal decision of the Oracle [Oliveira et al., 2014].

It should be emphasized that building a project with good test
cases is not an easy task. Testing requires discipline, concen-
tration, and extra eﬀort [Kasurinen et al., 2010]. As a reward,
the code presents a set of characteristics such as cleanliness,
easy-to-maintain, loosely coupled, and reusable APIs. Besides
the fact that testable code is easier to understand, maintain and
extend.

In order to understand the risks and advantages of these char-
acteristics and to accurately answer RQ2 and RQ3, in the next
sessions, we compare the diﬀerence between the VR projects and
Non-VR projects concerning code smells and fault-proneness
distribution.

5.2 Distribution of Code smell

Observing the lack of software testing practice in all the other
projects, we decided to investigate how this practice is reﬂected
within the projects. To do so, we decided to measure the inci-
dence of code smells [Fowler, 2018] within the projects inves-
tigated. This leads us to the second research question (RQ2)
presented: “What are the distribution of architecture, implemen-
tation, and design smells in VR projects?".

In general, the presence of code smells in software projects
indicates the presence of quality problems. For instance, one
of the most well-known code smell, God Class, is deﬁned as a
class that knows or does too much in the software system. God
Class is a strong indicator of possible problems because this
component is aggregating functionality that should be distributed
among several others components, therefore increasing the risk
of software faults [Hall et al., 2014]. Such problems directly
impact features such as maintainability and contribute to make
it diﬃcult for software to evolve.

To perform the evaluation discussed in this section we started
from an assumption that projects that do not have test cases in
their composition tend to have a lower code quality opposed to
projects that have been tested, considering developers probably
may not have observed aspects that would be capable of trigger-

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

8

ing unexpected behavior in the application, besides the fact the
smaller the number of bugs in the system, the higher the quality
related to a given project.

In order to better understand what is related to the lack of tests,
we compared the results obtained in the VR projects with the re-
sults obtained in Non-VR applications, which have well-deﬁned
test cases within the projects.
To better understand RQ2, we identiﬁed three diﬀerent types of
code smells in the projects:

Table 4: Description of the detected architecture smells and their
distribution

Smell
Ambiguous Interface
Cyclic Dependency
Dense Structure
Feature Concentration
God Component
Scattered Functionality
Unstable Dependency

ID
AAI
ACD
ADS
AFC
AGC
ASF
AUD
Std Dev
Average

VR

0.13%
0.99%
0.01%
1.70%
0.93%
0.39%
0.36%

29
212
3
366
201
84
78
118.34
139.0

Non-VR tested
0.02%
0.14%
0.05%
0.57%
0.29%
0.19%
0.26%

1
6
2
24
12
8
11
7.17
9.14

• Architecture smells: focus on identifying points of
interest for possible structural problems that can nega-
tively contribute and hamper activities such as debug-
ging and refactoring, as well as increasing the cost for
fault correction and refactoring, due to the characteris-
tic of increasing the complexity of the software, when
present [Mo et al., 2015].
• Implementation smells:

imple-
mentation smells were ﬁrst introduced by Fowler
[Fowler, 2018] and seek to establish a concept to clas-
sify shortcomings in object-oriented design principles.
This class of smells covers principles such as data ab-
straction, encapsulation, modularity, hierarchy, etc.
• Design smells: are speciﬁc types of structures that
may indicate a violation of a fundamental princi-
ple, which can impact aspects of design quality
[Suryanarayana et al., 2014].

code smells or

In order to calculate the distribution of the code smells previ-
ously described within the projects, we use the Designite tool
[Sharma et al., 2016]. The smells were classiﬁed according to
the number of occurrences in the analyzed classes and percent-
age distribution. The data is presented in Tables 4, 5 and 6.

It is worth mentioning that test case classes were not taken into
account for this smell classiﬁcation, once our initial target was to
measure the quality aspects of the source code classes. Besides
that, smells in software test codes require a whole diﬀerent
classiﬁcation approach [Tufano et al., 2016].

5.2.1 Architecture smells results

It can be observed that in Table 4, among the VR projects, there
is a low incidence of architecture smells, with only three types
(ACD, AFC, and AGC) presenting a percentage of occurrence
between 0.93 % and 1.70 %. Observing the Non-VR projects,
it can be observed that this category of smells had a lower
incidence compared to VR projects. The AUD, AGC and AFC
smells showed the highest occurrence rates, with percentages
between 0.26% and 0.57%.

VR project behavior can be justiﬁed due to the fact that within
the Unity platform, although an object-oriented language (C#) is
mostly used, the development model is considered a component-
based programming approach. This approach focuses on the
separation of concerns regarding the features to be developed in
the system.

Among the main advantages of a component-based program-
ming approach, we can point out the high reuse capacity of the
developed components due to the low coupling characteristics
of the components that make up the systems.

Despite Non-VR applications presenting lower rates of architec-
ture smells, it mainly shows a higher incidence of smell AFC.
This smell occurs when a component performs more than one
architectural concern/feature. This can be explained due to the
programming model adopted. A large part of Non-VR projects
corresponds to web applications, which typically use a Model-
View-Controller (MVC) standard for application development.
As shown by Aniche et al. [Aniche et al., 2018], systems that
adopt such architecture can be aﬀected by types of poor practices
that lead to the apparition of such a smell.

From a software testing point of view, the lower rate of archi-
tecture smells can be considered as a decisive successful factor,
since the low dependence between modules is a characteristic
that facilitates the application of unit tests [Aniche et al., 2013].
In general, when it is necessary to communicate with other units
of code, sometimes stubs or mock objects are used to represent
this communication. A huge beneﬁt of this approach is that by
lower coupling the system it is possible to reproduce complex
scenarios more easily.

Despite the advantages, it is important to keep in mind that
there are some threats related to the use of a component-based
approach in the context of integration testing, which as discussed
in subsection 3.1 must be one of the characteristics prioritized
in the context of testing VR applications. The main problems
are related to the use of components produced by third parties
since in general they work as a black box and it is necessary to
trust their correct functionality. An example of this model is the
components asset store available in the Unity platform5.

In order to better understand the presented results, regarding
each of the classes of smells analyzed, we veriﬁed if there
is, in fact, a statistical diﬀerence between the presence of
smells between groups of classes that were not tested and
groups of classes that were tested during its development pro-
cess. Therefore, due to the low number of smell types for
each category (architecture, design and implementation), and
since we can not guarantee that the data collected departs
from a normal distribution, we applied the Mann-Whitney test
[Fay and Proschan, 2010] to verify whether there is a statistical
diﬀerence between the presence of smells for each category of
smells evaluated.

The null hypothesis (H0) of the Mann-Whitney test indicates that
“The distribution of the variable in question is identical (in the
population) in the two groups", that is, there is no diﬀerence in
the presence of smells between classes that have not been tested
and classes that have been tested and the alternative hypothesis

5https://assetstore.unity.com/

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

9

(H1) indicates that “The distributions in the two groups are not
the same", therefore, there is a statistical diﬀerence between
the incidence of smells for classes that were not tested against
classes that were tested.
Considering the value of alpha = 0.05, which comprises the
complement of the margin of a conﬁdence level of 95%, for
the architecture smells, H0 with a p-value = 0.00760 could be
rejected. Thus, it indicates that there is a statistical diﬀerence
between the presence of smells when comparing architecture
smells in classes that were not tested against classes that were
tested.

Using a descriptive analysis, obtained by analyzing the number
of occurrences of each type of smells, it could be observed
that classes that were not tested tend to present a higher rate of
architecture smells in relation to classes that were tested.

5.2.2 Implementation smells results

It can be observed that, diﬀerent from the architecture smells, in
Table 5, we can identify a high rate of implementation smells
in the VR projects. We highlight ILI, ILS, and IMN, which had
a percentage of occurrence of 31.81%, 55.55%, and 117.46%,
respectively.

Although it does not pose a direct risk to the source code pro-
duced, smell ILI may be an indicator that something can be
revised/refactored. A very long identiﬁer may be an indication
that there is a need for too much text to distinguish/identify
variables and in some instances, this may indicate that the pro-
grammer may not be using the most suitable data structure to
represent it.

VR

Table 5: Description of the detected implementation smells and
their distribution
Smell
Complex Method
Complex Conditional
Duplicate Code
Empty Catch Block
Long Method
Long Parameter List
Long Identiﬁer
Long Statement
Magic Number
Missing Default
Virtual M. C. C.**

ID
ICM
ICC
IDC
IECB
ILM
ILPL
ILI
ILS
IMN
IMD
IVMCC
Std Dev
Average
**Virtual Method Call from Constructor

Non-VR
9
14
1
5
9
13
12
40
36
17
5
11.87
14.63

1,812
684
9
150
583
2,117
6,841
11,947
25,264
931
35
7,425.91
4,579.36

8.42%
3.18%
0.04%
0.70%
2.71%
9.84%
31.81%
55.55%
117.46%
4.33%
0.16%

0.22%
0.33%
0.02%
0.12%
0.22%
0.31%
0.29%
0.96%
0.86%
0.65%
0.12%

Non-VR projects again presented a lower occurrence rate. The
most frequent smells were ILS, IMN and IMD which achieved,
respectively, percentages of 0.96%, 0.85%, and 0.65%.

The occurrence of this type of smells is connected with the lack
of guidelines for standardization of code as well as the lack of
code refactoring practices. Usually, numbers have a meaning,
therefore it is recommended that it should be assigned variables
to make the code more readable and self-explaining. The names
of the variables should at least reﬂect what the variable means,
not necessarily its value.

Basic guides guide to the test to give a more appropriate context
and explanation of whatever numbers are present within the test.
The more sloppily the tests are written, the worse the actual code
will be and could become a door to possible faults, details about
that possibility will be addressed in the next section.

From the standpoint of software testing, opting to use of con-
stants instead of magic numbers can ensure that once the value
of the constant has been tested, there is no risk that the value of
the constant is erroneously declared in the future.

We also applied the Mann-Whitney test to verify whether there is
a statistical diﬀerence between the presence of implementation
smells in groups of classes that were not tested when compared
to the classes that were tested. Adopting a conﬁdence interval
of 95%, the test presented the p-value = 0.00040, which rejects
the null hypothesis of the test and conﬁrms the data presented in
Table 5, proving that classes that were tested tend to present a
lower rate of implementation smells.

Table 6: Description of the detected design smells and their
distribution

ID
DBH
DBM
DCM
DCH
DDH
DDE
DDA
DHM
DIA
DIM
DMH
DMA
DMH
DRH
DUE
DUH
DUA
DTA
DWH
Std Dev
Average

Smell
Broken Hierarchy
Broken Modularization
Cyclically-dependent M.
Cyclic Hierarchy
Deep Hierarchy
Deﬁcient Encapsulation
Duplicate Abstraction
Hub-like Modularization
Imperative Abstraction
Insuﬃcient Modularization
Missing Hierarchy
Multifaceted Abstraction
Multipath Hierarchy
Rebellious Hierarchy
Unexploited Encapsulation
Unfactored Hierarchy
Unnecessary Abstraction
Unutilized Abstraction
Wide Hierarchy

VR

245
991
3,149
6
0
8,101
2,469
4
627
1,171
18
209
1
389
15
483
3,741
6,987
64
2,344.41
1,508.94

1.14%
4.61%
14.64%
0.03%
0.00%
37.67%
11.48%
0.02%
2.92%
5.44%
0.08%
0.97%
0.00%
1.81%
0.07%
2.25%
17.39%
32.49%
0.30%

Non-VR
8
46
45
4
1
13
11
16
9
44
2
2
2
9
2
7
17
23
5
14.59
14.00

0.19%
1.10%
1.08%
0.10%
0.02%
0.31%
0.26%
0.38%
0.22%
1.05%
0.05%
0.05%
0.05%
0.22%
0.05%
0.17%
0.41%
0.55%
0.12%

ILS occurs when there is an excessively long statement. Long
declarations tend to make it diﬃcult to manage the code and are
consequently villains if observed from the practice of software
testing. Very long code snippets tend to be harder to test be-
cause they often become too complex when compared to smaller
snippets that are managed more eﬃciently.

Finally, IMN occurs when an unexplained number is used in an
expression. In general, magic numbers are unique values that
have some symbolic meaning. Good programming practices
indicate that in these cases, such numbers should be declared as
constants to facilitate the reading of the source code, as well as
to standardize its use.

5.2.3 Design smells results

Finally, we have the design smells which seek to identify
breaches of design principles. It can be concluded from Ta-
ble 6 it is possible to conclude that this class of smells was the
one that presented the highest degree of incidence in the VR
projects. DUA, DTA and DDE smells were the ones with the
highest percentage of occurrence with 17.39%, 32.49%, and
37.67% respectively.

The DUA smell deals with the practice of unnecessary ab-
stractions and is identiﬁed when an abstraction has more than
one responsibility attributed to it. This smell tends to occur

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

10

when there is an application of procedural programming fea-
tures in the context of object-oriented programming languages
[Suryanarayana et al., 2014].

From the standpoint of VR applications that adopt component-
based programming, the appearance of this smell can be ex-
plained by the fact that the programming approach focuses on
creating interchangeable code modules that work almost in-
dependently, not requiring that to be familiar with their inner
workings in order to use them.

Unnecessary design abstractions increase their complexity need-
less and aﬀect the comprehensibility of the overall design. From
a software testing point of view, this bad practice tends to hamper
test practices

DTA occurs when an abstraction is left unused, is not being
used directly, or because it is not reachable in the source code.
This smell correlates with DUA since unnecessary abstractions
tend not to be used. Another impact factor for the appearance
of this smell is linked to possible code maintenance/refactoring
activities, which tend to leave traces of code that are no longer
needed.

From the standpoint of software testing, the existence of a test
base that can be used as a regression test tends to facilitate the
localization of source code that is no longer necessary, causing
the occurrence of this smell to be reduced. From a tester’s point
of view, if there is a code that is not being used in the project, it
does not need to be tested. Therefore, identifying these snippets
of code can lead to more eﬃcient testing activities.

Finally, smell DDE, which identiﬁes cases of poor encapsulation,
had the highest occurrence rate in this class of smells. This
smell occurs when the declaration of attribute visibility of a
class is more permissive than necessary. For example, when the
attributes of a class are unnecessary declared as public.

From the standpoint of software testing, separation of interests
allows implementation details to be hidden. If an abstraction
exposes implementation details unnecessarily, it leads to unde-
sirable coupling in the source code. This will have an impact
on the testing activity because checking units that have a high
degree of coupling becomes a more challenging task due to the
need for more complex mocks and stubs.. Similarly, the high de-
gree of coupling causes changes that are made in a code snippet
to reﬂect in various parts of the application causing previously
designed tests to fail if they are not adequately designed.

Non-VR applications had a lower occurrence in this category
of smells, in which DBM and DCM are the two that presented
the highest occurrence, with 1.10% and 1.08% respectively. The
explanations for the occurrence rate for the DCM smell are
related to the cyclic dependence issue of the MVC model and
the DBM smell arises when data and/or methods that ideally
should have been localized into a single abstraction are separated
and spread across multiple abstractions.

Once again, we applied the Mann-Whitney test to check whether
the data obtained from our empirical evaluation can draw a
real picture about the behavior of class that does not have tests
compared to classes that were properly tested. Once again the
Mann-Whitney test proved with a p-value = 0.00089 that classes
that were tested tend to present lower rates of smells when
compared to classes that were not tested.

Our second research question (RQ2) sought to understand “What
are the distribution of architecture, implementation and design
smells in VR projects?". We investigated the main types of
smells for VR applications and compared their results with
Non-VR applications. We observed that in the context of VR
applications there is a greater incidence of code smells related
to implementation and design respectively since these two cate-
gories have code smells that are repeated frequently due to the
characteristics existing in the development of VR applications.

We also presented a discussion about how software testing prac-
tices can beneﬁt from avoiding the smells that obtained the
highest occurrence rate. Finally, the statistical tests performed
showed that when comparing VR and Non-VR projects, it was
possible to observe that the software testing practice can con-
tribute to increase the quality criteria and to reduce the presence
of code smells.

According to Hall et al. [Hall et al., 2014], code smells have a
signiﬁcant but small eﬀect on faults. This can justify the fact
that Non-VR application projects, which have test cases, present
a lower rate of code smells when compared to VR applications,
which do not have, for the most part, a well-deﬁned test activity.
However, the presence of smells not only hides potential source
code ﬂaws but also contributes to hindering the maintainability
and evolution of the source code in larger projects. This leads
us to the last research question of this study (RQ3), which aims
to investigate the fault proneness of VR projects. In a similar
way to the analysis of code smells, evaluate this in more depth,
we inserted the analysis of Non-VR projects so as to better
understand the results.

5.3 Analyzing fault proneness

As mentioned before, the presence of code smells can indicate
the absence of quality attributes in the source code and this
can be an indication of faults in a software [Hall et al., 2014].
Similarly, as previously mentioned, the higher occurrence rate
of code smells in the projects can hinder the practice of software
testing. To understand the risks of neglecting this activity, we
analyzed the projects concerning fault proneness.

Since code smells are identiﬁed according to rules and thresh-
olds deﬁned in code metrics [Khomh et al., 2009], we aim to
investigate (RQ3) the question: “Can we draw a relationship
between code metrics and fault proneness?". To do so, we use
the code metrics described in Table 3 with a fault prediction tech-
nique, which uses the metrics value as an indicator to suggest
whether a given source code is fault-prone or not.

By exploring relationships between software metrics and fault
proneness, we seek to justify the need for software testing ac-
tivities. For instance, a high threshold in a speciﬁc metric may
lead us to suspect, with high probability, about the reliability of
some parts of the code.
The eﬀectiveness of fault prediction techniques is often demon-
strated using historical repository data [Herbold, 2017]. How-
ever, once these techniques are adopted, it is not clear how
they would aﬀect projects that do not match with the char-
acteristics (language, platform, domain) of the built model
[He et al., 2015].

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

11

Figure 4: General process of ACL fault prediction approach (Source: own construction)

Since we do not have access to a dataset or a bug track his-
tory maintained with VR systems data, we tried to exploit an
approach that uses an unsupervised fault prediction technique
[Yang and Qian, 2016], that does not rely on historical data, to
investigate fault proneness on the analyzed projects.

We use the Average Clustering and Labeling (ACL)
[Yang and Qian, 2016] approach to predict fault proneness in
unlabeled datasets. ACL models obtain good prediction perfor-
mance and are comparable to typical supervised learning models
in terms of precision and recall, oﬀering a viable choice for fault
prediction when we do not have historical data related to faults.

This study can help software developers to understand the char-
acteristics of VR software and the potential implications of
neglect software testing activities. Raising awareness is the ﬁrst
step towards VV&T activities.

Figure 4 describes the process used by the approach to attest
if a given instance of code is deﬁned as fault-prone or not. In
general terms, the the process to run the approach consist mostly
of four steps:

• calculates the average value for each of the code met-

rics used;

• build a violation matrix metric;
• calculates metrics of instance violation; and
• deﬁnes whether the analyzed instance is considered as

fault-prone or clean.

The ﬁrst step is self-explanatory and uses the individual metrics
for each class, similar to those presented in Table 3, as input data.
After this stage, a violation matrix, which evaluates each metric,
is built using as a basis the average of the results constituted for
all classes in the project. The next step is to check the number of
violations for each class concerning the metrics evaluated and,
ﬁnally, in the last step to classify whether a particular instance
is fault-prone or not.
To perform the classiﬁcation, it is necessary to deﬁne a cutoﬀ
that will be used as a threshold and, if violated, it will identify
whether the class is fault-prone or not. The cutoﬀ point is
calculated using the number of metrics that are used in the
evaluation. Full details of the approach and the implementation

can be found in [Yang and Qian, 2016] and in the repository that
contains the information about this work.

The 119 VR projects were analyzed using the described ap-
proach and according to the classiﬁcation metric adopted, from
21,508 classes contained in all the projects, a total of 2,627
classes or 12.21% were classiﬁed as classes with a high prob-
ability of having faults, due to the fact they extrapolate the
threshold deﬁned by the approach to consider them as clean.

Similarly, in the 107 Non-VR projects, out of 21,568 classes, a
total of 1,921 were labeled as fault-prone, which corresponds to
a percentage of 8.90% of the analyzed classes.

In a superﬁcial analysis it is possible to have a mistaken view
of the results of this study and imagine that the percentage
of propensity to fail presented appears low and, therefore,
the time and expense necessary to identify them is perhaps
not justiﬁed. However, according to previous investigations
[Walkinshaw and Minku, 2018], the Pareto principle also tends
to apply to a software faults context. It is believed that 20% of
the ﬁles are responsible for up to 80% of the faults found in a
project. Therefore, it is natural that the percentage of classes
with a propensity to fail to follow this same trend, since it is
not an exact proportion and the classiﬁcation approach is not an
exact formula and serves only as a mechanism to assist in eﬀorts
to apply a software testing approach.

As pointed out by Nam [Nam, 2014], defect prediction ap-
proaches play a role as a complementary approach to help iden-
tify potential problems in the source code as well as a mechanism
to improve it and consequently get rid of productivity bottle-
necks and future issues. Thus, the results presented here are not
intended to point out the exact number of problems in a software
product evaluated, but to strengthen the hypotheses that projects
that adopt quality criteria, such as software testing practice, tend
to be less predisposed to future issues.

It’s also important to note that, since there is no precise informa-
tion about the test criteria used in Non-VR projects, as well as
any information regarding the coverage reached by the designed
tests, it is impossible to guarantee that the tests designed for a
class are enough to ensure that it is free of any problems. There-
fore, it is natural that the percentage of fault-proneness between

RepositoriesMetricsUnsupervised Clustering Labeling Rule CleanFault Proner Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

12

projects that have not been tested (VR projects) and projects that
have test cases (Non-VR projects) is slightly similar.

faults to Non-VR projects, and that propensity tends to increase
as the complexity of the projects increases.

It can be observed that despite having a larger number of classes
and lines of code for those analyzed in the VR projects, Non-VR
projects presented a lower fault-proneness rate. It is worth noting
that the fault-prone algorithm is executed only in the classes
related to the source code of the application, thus disregarding
the test classes in the Non-VR projects.

This analysis could be an indication that due to the practice of
testing, classes of the Non-VR projects have a higher degree
of reliability, and therefore are less fault-prone when compared
to the classes existing in the VR projects, which mostly do not
present test cases.

These numbers can be observed in Figure 5 and are alarming
numbers since they show the negative impact that a lack of
robust and standardized testing technologies can cause to the
software industry [Tassey and Gregory, 2002]. Consequently, it
contributes to an increase in the incidence of avoidable faults
that tend to appear only after the software is used by its end
users.

Similarly, the software development cost tends to increase be-
cause historically the process of identifying and correcting
faults during the software development process represents more
than half of the costs incurred during the development cycle
[Brooks, 1995]. This delay in the product development can lead
to situations such as the increase in the time needed to put a prod-
uct on the market, also resulting in market opportunity losses
[Afonso et al., 2008].

We went further trying to understand how the faults pointed
out by the approach are distributed into the projects. Since the
projects have a great variety of sizes, we grouped them into
6 diﬀerent categories (by the number of classes) in order to
observe how the distribution of fault-prone classes occurs.

Figure 6 shows this distribution.
It can be observed that in
both VR and Non-VR projects, there is a relation between the
number of fault-prone classes and the size of the projects. This
relation points out that the higher the number of classes in the
projects, the higher the average fault-prone classes, and leads
us to conclude that neglecting testing activity in larger projects
may be even more riskier in terms of the project’s success.

Future analyses could be extracted from the data obtained. How-
ever, we believe that the presented data are capable of attesting
a clear answer to RQ3, making it clear that in a general con-
text, the lack of software testing techniques have a direct impact
on quality attributes, as demonstrated by the metrics extracted
from the analyzed projects and this directly reﬂects the adoption
of bad development practices, which lead to the existence of
code smells, consequently becoming an outlet for the increase
in faults.

RQ3 sought to understand the question: “Can we draw a rela-
tionship between code metrics and fault proneness?" and by im-
plementing the approach to detect fault proneness in the projects
investigated, it could be observed that neglecting the test activity
can lead to a higher probability of development problems. Ac-
cording to our analysis, it was seen that the VR projects, which
do not present test cases, have a higher propensity to present

It was also observed that although Non-VR projects present
test cases in all projects, they still present a high rate of fault
proneness. This underscores the importance of the developing
software testing practice within the scope of project develop-
ment. Although Non-VR projects have test cases, the test sets
provided do not meet the basic test criteria, such as code cov-
erage, so that part of the code that is not tested is still prone to
possible failures.

Another point that this study raised is the need for speciﬁc test
practices for a speciﬁc domain. Software of diﬀerent domains
have diﬀerent characteristics, which must be adequately investi-
gated. In the context of VR applications, the simple use of unit
tests may not be suﬃcient to attest the quality of the developed
product, since the technological advancement has led to the de-
velopment of systems with advanced features such as images,
sounds, videos, and diﬀerentiated interaction, presenting new
challenges when compared to software testing in conventional
domains, such as the lack of information on typical defects and
even the lack of a precise deﬁnition of a test case and the oracle
problem [Rapps and Weyuker, 1985, Barr et al., 2014].

6 Limitations and Threats to Validity

The main limitations of this study are related to the fact that the
data used in this study were gathered from Github.

Although the collected data enabled us to discuss the state of
practice regarding the application of software testing techniques
in the context of VR, open source projects still represent only
a small portion of what is produced in the context of VR appli-
cations. Commercial projects and closed projects are also part
of this universe, and it is not possible to attest that the results
discussed from data extracted from open source projects can be
generalized for these other scenarios.

The problem described above opens opportunities to develop
similar research in partnership with industry in order to under-
stand whether the results converge in the same direction.

In addition to the limitations described above, another obstacle
that must be pointed out is the fact that despite the fact that the
assumptions made during the study were related to the context
of VR applications, it should be emphasized that all the samples
observed only use a single technology (Unity), therefore the
results indicated here cannot be generalized for other platforms.
To achieve such generalization, new studies should be carried
out to corroborate or counter the results presented in this study.

The validity of the results achieved in experiments depends on
factors in the experiment settings. Diﬀerent types of validity can
be prioritized depending on the goal of the experiment. Con-
cerning the threats to the validity of this study, which are related
both to the evaluation of code smells and to fault-proneness
detection, we can highlight the fact of performing an analysis
using samples extracted only from a platform and just for open
source projects was a signiﬁcant threat to validity - this relies
on the lack of representativity of the projects in serving as a
real sample of the universe of all types of projects for the VR
domain.

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

13

Figure 5: Classiﬁcation of the VR projects according to the ACL approach (Source: own construction)

using both descriptive analyses, and hypothesis testing in order
to guarantee that the conclusions drawn from this work enable
us to paint a clear and quantitative picture about the subject
explored.

Regarding the approach to detect fault proneness, the strategy
used was previously validated through experiments in large
datasets to attest its eﬃcacy [Yang and Qian, 2016], and it is
worth mentioning the fact that the main point of the approach
was not, in fact, to detect faults in the projects, but point out
classes that have a high probability of having faults, serving as
a guide to direct testing eﬀorts and to discuss the necessity of
apply software testing techniques.

Finally, we discuss threats to the internal validity of the study,
which are related to the level of conﬁdence between the expected
results and the results obtained. The whole study was conducted
in a way that minimized this threat. To increase conﬁdence about
the presented results, the data were analyzed using tables and
graphs and were also made available in a repository to enable
the replication if it is deemed necessary.

Figure 6: Distribution of fault-prone classes according to the
size of the projects (Source: own construction)

Unfortunately the lack of representativity is a problem that af-
fects the entire software engineering area, since there is no
well-ﬂedged theory capable of ensuring that a set of programs
is considered a representative sample for experimentation. To
try to mitigate this threat, the most signiﬁcant possible num-
ber of projects was assembled, varying in size (small, medium
and large) and application purposes (entertainment, simulation,
training, health).

Another measure taken to try to mitigate the threat described
above was to analyze Non-VR projects, which served as sub-
sidies to compare with the results obtained from VR projects,
ensuring a better grounded discussion and a minimum baseline
for comparison, since, unfortunately, there are still no projects
cataloged with VR applications that meet the requirements to be
used in this work.

Related to threats to construct validity, possible mistakes can be
pointed out both in the analysis of codes smells, as well as in
the evaluation of fault proneness. To minimize this threat, the
tool Designite was used to detect code smells, Designite is a
commercial tool and has already been successfully used in other
experiments [Sharma et al., 2017].

7 Conclusion and Future Work

This paper discusses the main challenges related to using soft-
ware testing practice in the VR domain. Some of the critical
issues related to the quality of these systems were pointed out
and possible solutions were also discussed that could be used
and adapted to deal with such issues.

We discussed whether or not there is a real need to test VR
systems. To better understand this, a comprehensive study was
conducted, guided by 3 research questions, whose objective was:
to understand the state of the practice of software testing in the
context of VR programs (RQ1), to measure metrics and quality
attributes in VR software (RQ2), and ﬁnally to evaluate fault
proneness in the collection of the software analyzed (RQ3).

In order to answer the raised questions, a collection of 119 VR
projects, available in open source projects and manually an-
alyzed, was cataloged to understand the state of the practice
concerning the application of software testing techniques. Re-
garding the application of software testing techniques (RQ1), it
was observed that out of all the projects, only 6 of them had
some test cases in their project.

In the context of the experiments carried in this study, in addition
to using a commercial tool to support the gathering of data
related to the code smell, all the data presented was evaluated

Given the results pointed out by RQ1, we decided to evaluate
how the negligence of the practice of software testing can be
detrimental to a software project, and it was decided to evaluate

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

14

the distribution of code smells among the analyzed projects.
Smells related to architecture, design, and implementation were
analyzed. It can be concluded that there is a high incidence of
smells in the projects analyzed, especially regarding implemen-
tation smells. We discussed the most common smells for each
of the categories and how they can discourage the practice of
software testing, and also how they can be avoided if a software
testing activity is appropriately conducted.

Finally, considering the results of RQ2, it was decided to inves-
tigate how the lack of good practices and the presence of code
smells can impact the quality of the source code produced. To
do so, an approach that evaluates code metrics was used to point
out classes that are fault-prone (RQ3). The study pointed out that
about 12% of the analyzed VR classes have such characteristics,
revealing a signiﬁcant risk to the success of the projects. The
distribution of these classes was also evaluated when observed
concerning the size of the projects analyzed. It was observed
that the larger a project becomes, there is a higher incidence of
fault-prone classes, which may be an indication that neglecting
test practices in larger projects becomes even more riskier.

We believe that the results reported in this paper will contribute
to raising the awareness of the software testing and virtual reality
community about the needs of software testing approaches for
VR developers. As software testing phase, also makes up one
of the development phases, it is necessary to understand the
point of view of stakeholders involved in the process, allowing
these groups narrow what they deem important, thus making it
possible to prioritize veriﬁcation concerning failures that should
not manifest in VR applications.

Observing such aspects, it is possible to guide the development
of a project using a speciﬁc testing approach for the VR domain.
So, in future works, we intend to survey what types of faults in
VR applications contribute to a negative experience. The goal of
this study is to obtain a view of the interest groups (for example,
which types of failures are most critical, which are less relevant,
how much each aﬀects the quality of the ﬁnal product, etc.), in
addition to investigating the knowledge of the groups of interest
regarding speciﬁc types of failures in VR applications.

Understanding the intends of stakeholders we expect to propose
a fault taxonomy to the context of VR programs. It is believed
that having such taxonomy, it would be possible to encourage the
development of speciﬁc software testing techniques and criteria
to the context of VR programs, thus spreading the practice
of software testing in order to mitigate possible problems and
move towards software projects that best meet software quality
requirements.

Acknowledgements

Stevão A. Andrade research was funded by FAPESP (São Paulo
Research Foundation), process number 2017/19492-1. This
study was also ﬁnanced in part by FAPESP (São Paulo Re-
search Foundation) process number 2019/06937-0. The au-
thors are grateful to Brazilian National Council of Scientiﬁc
and Technological Development (CNPq) for assistance (process
308615/2018-2), and National Institute of Science and Technol-
ogy Medicine Assisted by Scientiﬁc Computing INCT MACC (
Process 157535/2017-7).

We also would like to thanks Tushar Sharma and Designite team
by providing us an Academic license of Designite tool.

References

[Afonso et al., 2008] Afonso, P., Nunes, M., Paisana, A., and
Braga, A. (2008). The inﬂuence of time-to-market and target
costing in the new product development success. Interna-
tional Journal of Production Economics, 115(2):559–568.

[Aniche et al., 2018] Aniche, M., Bavota, G., Treude, C.,
Gerosa, M. A., and van Deursen, A. (2018). Code smells
for model-view-controller architectures. Empirical Software
Engineering, 23(4):2121–2157.

[Aniche et al., 2013] Aniche, M. F., Oliva, G. A., and Gerosa,
M. A. (2013). What do the asserts in a unit test tell us about
code quality? a study on open source and industrial projects.
In 2013 17th European Conference on Software Maintenance
and Reengineering, pages 111–120. IEEE.

[Barr et al., 2014] Barr, E. T., Harman, M., McMinn, P., Shah-
baz, M., and Yoo, S. (2014). The oracle problem in software
testing: A survey. IEEE transactions on software engineering,
41(5):507–525.

[Bertolino, 2003] Bertolino, A. (2003). Software testing re-
search and practice. In Börger, E., Gargantini, A., and Ric-
cobene, E., editors, Abstract State Machines 2003.

[Boman, 1995] Boman, D. K. (1995).

International survey:

Virtual-environment research. Computer, 28(6):57–65.

[Brooks, 1995] Brooks, F. (1995). The Mythical Man-Month,
Anniversary Edition: Essays On Software Engineering. Pear-
son Education.

[Burdea and Coiﬀet, 1994] Burdea, G. and Coiﬀet, P. (1994).
Virtual Reality Technology. John Wiley & Sons, 1st edition.
[Capilla and Martínez, 2004] Capilla, R. and Martínez, M.
(2004). Software architectures for designing virtual reality ap-
plications. In European Workshop on Software Architecture,
pages 135–147. Springer.

[Chidamber and Kemerer, 1994] Chidamber, S. R. and Ke-
merer, C. F. (1994). A metrics suite for object oriented design.
IEEE Transactions on software engineering, 20(6):476–493.

[Corrêa et al., 2013] Corrêa, A. C. S., Delamaro, M. E., and
Nunes, F. L. S. (2013). The relationship between require-
ments engineering and virtual reality systems: A systematic
In 2013 XV Symposium on Virtual and
literature review.
Augmented Reality, pages 53–62. IEEE.

[Corrêa et al., 2018] Corrêa, A. C. S., Nunes, F. L. S., and De-
lamaro, M. E. (2018). An automated functional testing ap-
proach for virtual reality applications. Software Testing, Veri-
ﬁcation and Reliability, 28(8):e1690.

[Courrèges, 2016] Courrèges,
- graphics study.

A.
(2016).
Available from:

Doom
https:

(2016)
//www.adriancourreges.com/blog/2016/09/09/
doom-2016-graphics-study/.

[Fay and Proschan, 2010] Fay, M. P. and Proschan, M. A.
(2010). Wilcoxon-mann-whitney or t-test? on assumptions
for hypothesis tests and multiple interpretations of decision
rules. Statistics surveys, 4:1.

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

15

[Fowler, 2018] Fowler, M. (2018). Refactoring: improving the

design of existing code. Addison-Wesley Professional.

In 2013 20th Working Conference on Reverse Engineering
(WCRE), pages 272–281. IEEE.

[Ghrairi et al., 2018] Ghrairi, N., Kpodjedo, S., Barrak, A.,
Petrillo, F., and Khomh, F. (2018). The state of practice
on virtual reality (vr) applications: An exploratory study on
github and stack overﬂow. In 2018 IEEE International Con-
ference on Software Quality, Reliability and Security (QRS),
pages 356–366. IEEE.

[Haas, 2014] Haas, J. K. (2014). A history of the Unity game

engine. PhD thesis, Worcester Polytechnic Institute.

[Hall et al., 2014] Hall, T., Zhang, M., Bowes, D., and Sun, Y.
(2014). Some code smells have a signiﬁcant but small eﬀect
on faults. ACM Transactions on Software Engineering and
Methodology (TOSEM), 23(4):1–39.

[He et al., 2015] He, P., Li, B., Liu, X., Chen, J., and Ma, Y.
(2015). An empirical study on software defect prediction with
a simpliﬁed metric set. Information and Software Technology,
59:170–190.

[Herbold, 2017] Herbold, S. (2017). A systematic mapping
study on cross-project defect prediction. arXiv preprint
arXiv:1705.06429.

[Hillenbrand and Gayvert, 2005] Hillenbrand,

and
Gayvert, R. T. (2005). Open source software for experiment
Journal of Speech, Language, and
design and control.
Hearing Research.

J. M.

[Kalliamvakou et al., 2014] Kalliamvakou, E., Gousios, G.,
Blincoe, K., Singer, L., German, D. M., and Damian, D.
(2014). The promises and perils of mining github. In Pro-
ceedings of the 11th working conference on mining software
repositories, pages 92–101.

[Karre et al., 2019] Karre, S. A., Mathur, N., and Reddy, Y. R.
(2019). Is virtual reality product development diﬀerent? an
empirical study on vr product development practices.
In
Proceedings of the 12th Innovations on Software Engineering
Conference (formerly known as India Software Engineering
Conference), pages 1–11.

[Karre et al., 2020] Karre, S. A., Mathur, N., and Reddy, Y. R.
(2020). Understanding usability evaluation setup for vr prod-
ucts in industry: A review study. SIGAPP Appl. Comput.
Rev., 19(4):17–27.

[Kasurinen et al., 2010] Kasurinen, J., Taipale, O., and Smolan-
der, K. (2010). Software test automation in practice: empiri-
cal observations. Advances in Software Engineering, 2010.

[Khomh et al., 2009] Khomh, F., Di Penta, M., and Gueheneuc,
Y.-G. (2009). An exploratory study of the impact of code
smells on software change-proneness. In 2009 16th Working
Conference on Reverse Engineering, pages 75–84. IEEE.

[Khomh et al., 2012] Khomh, F., Di Penta, M., Guéhéneuc, Y.-
G., and Antoniol, G. (2012). An exploratory study of the
impact of antipatterns on class change-and fault-proneness.
Empirical Software Engineering, 17(3):243–275.

[LaValle, 2019] LaValle, S. M. (2019). Virtual Reality. Cam-

bridge University Press.

[Machado et al., 2003] Machado, L. S., Moraes, R. M., Souza,
D. F. L., and Valdek, M. C. O. (2003). Siteg–Sistema Intera-
tivo de Treinamento em Exame Ginecológico. In Proceedings
of the VI Symposium on Virtual Reality (SVR), volume 12,
Ribeirão Preto, SP, Brasil.

[Mo et al., 2015] Mo, R., Cai, Y., Kazman, R., and Xiao, L.
(2015). Hotspot patterns: The formal deﬁnition and auto-
matic detection of architecture smells. In 2015 12th Working
IEEE/IFIP Conference on Software Architecture, pages 51–
60. IEEE.

[Nam, 2014] Nam, J. (2014). Survey on software defect predic-
tion. Department of Compter Science and Engineerning, The
Hong Kong University of Science and Technology, Tech. Rep.

[Neves et al., 2018] Neves, V. d. O., Bertolino, A., De Ange-
lis, G., and Garcés, L. (2018). Do we need new strategies
for testing systems-of-systems? In Proceedings of the 6th
International Workshop on Software Engineering for Systems-
of-Systems, SESoS ’18, page 29–32, New York, NY, USA.
Association for Computing Machinery.

[Oliveira et al., 2014] Oliveira, R. A., Kanewala, U., and Nardi,
P. A. (2014). Chapter three - automated test oracles: State of
the art, taxonomies, and trends. In Memon, A., editor, Ad-
vances in Computers, volume 95 of Advances in Computers,
pages 113 – 199. Elsevier.

[Palomba et al., 2014] Palomba, F., Bavota, G., Di Penta, M.,
Oliveto, R., and De Lucia, A. (2014). Do they really smell
bad? a study on developers’ perception of bad code smells.
In 2014 IEEE International Conference on Software Mainte-
nance and Evolution, pages 101–110. IEEE.

[Rapps and Weyuker, 1985] Rapps, S. and Weyuker, E. J.
(1985). Selecting software test data using data ﬂow infor-
IEEE transactions on software engineering, SE-
mation.
11(4):367–375.

[Rodriguez and Wang, 2017] Rodriguez,

I. and Wang, X.
(2017). An empirical study of open source virtual reality
software projects. In 2017 ACM/IEEE International Sympo-
sium on Empirical Software Engineering and Measurement
(ESEM), pages 474–475. IEEE.

[Runeson, 2006] Runeson, P. (2006). A survey of unit testing

practices. IEEE software, 23(4):22–29.

[Sharma et al., 2017] Sharma, T., Fragkoulis, M., and Spinellis,
D. (2017). House of cards: code smells in open-source c#
repositories. In 2017 ACM/IEEE International Symposium on
Empirical Software Engineering and Measurement (ESEM),
pages 424–429. IEEE.

[Sharma et al., 2016] Sharma, T., Mishra, P., and Tiwari, R.
(2016). Designite: A software design quality assessment tool.
In Proceedings of the 1st International Workshop on Bring-
ing Architectural Design Thinking into Developers’ Daily
Activities, pages 1–4.

[Leotta et al., 2013] Leotta, M., Clerissi, D., Ricca, F., and
Tonella, P. (2013). Capture-replay vs. programmable web
testing: An empirical assessment during test case evolution.

[Suryanarayana et al., 2014] Suryanarayana, G., Samarthyam,
G., and Sharma, T. (2014). Refactoring for software design
smells: managing technical debt. Morgan Kaufmann.

Preprint – Towards the Systematic Testing of Virtual Reality Programs (extended version)

16

[Takala et al., 2017] Takala, T. M. et al. (2017). A Toolkit for
Virtual Reality Software Development-Investigating Chal-
lenges, Developers, and Users. PhD thesis, Aalto University.
[Tassey and Gregory, 2002] Tassey and Gregory (2002). The
economic impacts of inadequate infrastructure for software
testing. National Institute of Standards and Technology.
[The Mono - Unity fork, 2018] The Mono - Unity fork (2018).
The mono - unity fork. Available from: https://www.
openhub.net/p/mono-unity.

[Tori et al., 2006] Tori, R., Kirner, C., and Siscoutto, R. (2006).
Fundamentos e Tecnologia de Realidade Virtual e Aumentada.
VIII Symposium on Virtual Reality, Belém/PA.

[Tufano et al., 2016] Tufano, M., Palomba, F., Bavota, G.,
Di Penta, M., Oliveto, R., De Lucia, A., and Poshyvanyk,
D. (2016). An empirical investigation into the nature of test
smells. In Proceedings of the 31st IEEE/ACM International
Conference on Automated Software Engineering, pages 4–15.
[Walkinshaw and Minku, 2018] Walkinshaw, N. and Minku, L.
(2018). Are 20% of ﬁles responsible for 80% of defects? In
Proceedings of the 12th ACM/IEEE International Symposium
on Empirical Software Engineering and Measurement, pages
1–10.

[Yang and Qian, 2016] Yang, J. and Qian, H. (2016). Defect
prediction on unlabeled datasets by using unsupervised clus-
In 2016 IEEE 18th International Conference on
tering.
High Performance Computing and Communications; IEEE
14th International Conference on Smart City; IEEE 2nd
International Conference on Data Science and Systems
(HPCC/SmartCity/DSS), pages 465–472. IEEE.

[Zhao, 2009] Zhao, Q. (2009). A survey on virtual reality. Sci-
ence in China Series F: Information Sciences, 52(3):348–400.

