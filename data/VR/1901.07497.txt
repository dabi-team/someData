Elastic Multi-resource Network Slicing:
Can Protection Lead to Improved Performance?

Jiaxiao Zheng, Gustavo de Veciana
Dept. of Electrical and Computer Engineering, The University of Texas at Austin, TX
gustavo@ece.utexas.edu

9
1
0
2

n
a
J

2
2

]
I

N
.
s
c
[

1
v
7
9
4
7
0
.
1
0
9
1
:
v
i
X
r
a

Abstract—In order to meet the performance/privacy require-
ments of
future data-intensive mobile applications, e.g., self-
driving cars, mobile data analytics, and AR/VR, service providers
are expected to draw on shared storage/computation/connectivity
the network “edge”. To be cost-effective, a key
resources at
functional requirement for such infrastructure is enabling the shar-
ing of heterogeneous resources amongst tenants/service providers
supporting spatially varying and dynamic user demands. This
paper proposes a resource allocation criterion, namely, Share
Constrained Slicing (SCS), for slices allocated predeﬁned shares
of the network’s resources, which extends traditional α−fairness
criterion, by striking a balance among inter- and intra-slice fairness
vs. overall efﬁciency. We show that SCS has several desirable
properties including slice-level protection, envyfreeness, and load
driven elasticity. In practice, mobile users’ dynamics could make
the cost of implementing SCS high, so we discuss the feasibility
of using a simpler (dynamically) weighted max-min as a surrogate
resource allocation scheme. For a setting with stochastic loads and
elastic user requirements, we establish a sufﬁcient condition for
the stability of the associated coupled network system. Finally,
and perhaps surprisingly, we show via extensive simulations that
while SCS (and/or the surrogate weighted max-min allocation)
provides inter-slice protection, they can achieve improved job delay
and/or perceived throughput, as compared to other weighted max-
min based allocation schemes whose intra-slice weight allocation is
not share-constrained, e.g., traditional max-min or discriminatory
processor sharing.

I. INTRODUCTION

Next generation networks face the challenge of supporting
data-intensive services and applications, such as self-driving
cars, infotainment, augmented/virtual reality [27], Internet of
things [6], [27], and mobile data analytics [1], [12]. In order
to accommodate the performance and privacy requirements of
such services/applications, providers are expected to draw on
shared storage/computation/connectivity resources at the net-
work “edge”. Such network systems can take advantage of
Software-Deﬁned Networking and Network Function Virtual-
ization technologies to provision slices of shared heterogeneous
resources and network functions which are customized to ser-
vice providers’/tenants’ requirements.

The ability to support slice-based provisioning is central
to enabling service providers to take control of managing
performance of their own dynamic and mobile user populations.
This also improves the scalability by reducing the complexity
of performance management on multi-service platforms. The
ability to efﬁciently share network/compute resources is also
key to reducing the cost of deploying such services. By contrast
with today’s cloud computing platforms, our focus in this paper
is on provisioning slices of edge resources to meet mobile
users/devices requirements. In general, shared edge resources
will have smaller overall capacity resulting in reduced statistical
multiplexing and making efﬁciency critical. Perhaps similarly

to cloud computing platforms, providers/tenants will want to
make long-term provisioning commitments enabling predictable
costs and resource availability, yet beneﬁt, when possible, of
elastic resource allocations aligned with spatial variations in
their mobile workloads but not at the expense of other slices.
Thus a particularly desirable feature is to enable slice-level
provisioning agreements which achieve inter-slice protection,
load-driven elasticity and network efﬁciency.

These challenges distinguish our work from previous re-
search in areas including engineering, computer science and
economics. The standard framework used in communication
networks is utility maximization (see e.g., [29] and references
therein), which has led to the design of several transport and
scheduling mechanisms and criteria, e.g., the widely discussed
proportional fairness. When considering dynamic/stochastic net-
works, e.g., [4], [17], researchers have studied networks where
users are allocated resources based on utility maximization
and studied requirements for network stability for ‘elastic’ user
demands, e.g., ﬁle transfers. This body of work emphasizes user-
level resource allocations, without speciﬁcally accounting for
interactions among slices. Thus, it does not directly address the
requirements of network slicing.

Instead in this paper, we propose a novel approach, namely,
Share Constrained Slicing (SCS), wherein each slice is assigned
a share of the overall resources, and in turn, distributes its share
among its users. Then the user level resource allocation is deter-
mined by maximizing a sharing criterion. When SCS is applied
to a setting where each user only demands one resource, for
example, slices sharing wireless resources in cellular networks
[9], [10], [34], it can be viewed as a Fisher market where agents
(slices), which are share (budget) constrained, bid on network
resources, see, e.g., [25], and for applications [3], [9], [19].
However, those works do not deal with settings where users
require heterogeneous resources, and how to orchestrate slice-
level interactions on different resources is not clear yet.

When it comes to sharing on heterogeneous resources, a
simple solution is static partitioning of all resources according
to a service-level agreement, see, e.g., [21]. It offers each slice
a guaranteed allocation of the network resources thus in prin-
ciple provides ideal protection among slices. However, it falls
short from the perspective of providing load-driven elasticity
to a slice’s users, possibly resulting in either resource under-
utilization or over-booking. Other natural approaches include
full sharing [2], where users from all slices are served based on
some prioritizing discipline without prior resource reservation.
Such schemes may not achieve slice-level protection and are
vulnerable to surging user trafﬁcs across slices.

Additionally, many resource sharing schemes have been pro-
posed for cluster computing where heterogeneous resources are

 
 
 
 
 
 
involved, including Dominant Resource Fairness (DRF) [20],
Competitive Equilibrium from Equal Income (CEEI) [24] [31]
[33], Bottleneck Max Fairness (BMF) [5], etc. These allocation
schemes are usually based on modelling joint resource demands
of individual users, but lack of the notion of slicing, thus it is
not clear how to incorporate the need to enable slice-level long-
term commitments. In these works, inter-slice protection and
elasticity of allocations have not been characterized. Further-
more, most of these works are developed under the assumption
that users are sharing a centralized pool of resources. In this
paper we focus on a settings where resources are distributed,
and mobile users are restricted to be served by proximal edge
resources.

Contributions: The novelty of our proposed approach lies
in maintaining slice-level long-term commitments deﬁned by a
service-level agreement, while enabling user-level resource pro-
visioning which is driven by dynamic user loads. We consider
a model where users possibly require heterogeneous resources
in different proportions, and the processing rate of a user scales
linearly in the amount of resources it
is allocated. Such a
model captures tasks/services which speeds up in the allocated
resources, which is discussed further in the sequel.

We show that SCS can capture inter- and intra-slice fairness
separately. When viewed as a resource sharing criterion, SCS is
shown to satisfy a set of axiomatically desirable properties akin
to those in [22], and can be interpreted as achieving a tunable
trade-off among inter-slice fairness (which can be seen as a
proxy of protection), intra-slice fairness, and overall utilization.
Fairness is connected to load-driven elasticity through share
constrained weight allocation. The merits of SCS are demon-
strated in both static and dynamic settings. In static settings,
we prove a set of desirable properties of SCS as a sharing
criterion, including slice-level protection and envyfreeness, and
we demonstrate the feasibility of using a simpler (dynamically)
weighted max-min as a surrogate resource allocation scheme for
the cases where the cost of implementing SCS is excessive. In
a dynamic settings, we consider the elastic trafﬁc model where
each user carries a ﬁxed workload, and leaves the system once
the work is processed. We model such system as a stochastic
queuing network, and establish its stability condition.

Finally, and perhaps surprisingly, we show via extensive
simulations that while SCS provides inter-slice protection, it
can also achieve improved average job delay and/or perceived
throughput, as compared with multiple variations of tradi-
tional (weighted) max-min fair allocations but without share-
constrained weight allocation. We provide a heuristic expla-
nation of such improvement that SCS can separate the busy-
periods of different slices, thus reduces inter-slice contention,
and validate the explanation through simulations.

Paper organization: This paper is organized as follows. In
Section II, we establish our model for network slicing on het-
erogeneous shared resources, and characterize SCS as satisfying
several axiomatically desirable properties for fairness criterion.
Then, in Section III, several properties of SCS involving slice-
level utility are discussed, including protection, envyfreeness,
and the feasibility of using a simpler weighted max-min as a
surrogate resource allocation scheme. In Section IV, for a setting
with stochastic loads and elastic user trafﬁc, we establish the
stability condition when SCS is applied as the service discipline.
Finally, in Section V, extensive simulations are conducted for

both simple settings where only one resource is shared amongst
slices, and complex settings which resembles a realistic edge
computing scenario, to demonstrate the surprising result that
SCS and/or the surrogate weighted max-min allocation can
achieve improved average job delay and/or perceived throughput
while provides inter-slice protection.

II. RESOURCE SHARING IN NETWORK SLICING

In this section we will brieﬂy introduce the overall frame-
work for resource allocation to network slices, namely, Share
Constrained Slicing (SCS) where each slice manages a possibly
dynamic set of users. Speciﬁcally, we will consider resource
allocation driven by the maximization of an objective function
geared at achieving a trade-off between overall efﬁciency and
fairness [22].

To begin, we consider the set of active users on each slice
to be ﬁxed. Let us denote the set of slices by V, the set of
resources by R, each with a capacity normalized to 1. Each slice
v supports a set of user classes, denoted by Cv, and the total
set of user classes is deﬁned as C := ∪v∈V Cv. For simplicity,
we let v(c) denote the slice which supports class c. We let Uc
denote the set of users of class c, and the users on slice v is
denoted by U v := ∪c∈Cv Uc. Also, the overall set of users is
U := ∪v∈V U v. For each user, possibly heterogeneous resources
are required to achieve certain processing rate. Let us denote
the processing rate seen by user u by λu. We also deﬁne the
resource demand vector of user class c as dc := (dr
c : r ∈ R),
where dr
c is the fraction of resource r required by user u ∈ Uc
for a unit processing rate, i.e., to achieve λu = 1, we need to
allocate fraction d1
c of the total amount of resource 1 to u, d2
c
of the total amount of resource 2 to u, and so on. If a user
class c does not use a given resource r then dr
c = 0. Note that
if two slices support users with the same requirements, we will
distinguish them by deﬁning two distinct user classes one for
each slice. In other words, it is possible to have more than one
user classes with exactly the same dc. Also, we let Rc denote
the set of resources required by users of class c, and in turn,
let the set Cr denote user classes using resource r. Among Cr,
the set of classes on slice v is Cv
r := Cr ∩ Cv. The number of
active users of class c at time t is denoted by a random variable
Nc(t), and that on slice v by N v(t). N v(t) =
c∈Cv Nc(t).
Realizations of these are denoted by lower case variables nc
and nv, respectively.

P

This model captures the services/applications where tasks
speed up with more allocated resources, e.g., a ﬁle download is
faster when allocated more communication resources, or com-
putation task that can be parallelized, e.g., typical MapReduce
jobs [18], and mobile data analytics when additional compute
resources are available [12]. For more complex applications in-
volving different types of stages, the stages conducting massive
data processing might be parallelizable, making it possible to
accelerate by allocating more resources. For example, in mobile
the most time-consuming and resource-
cloud gaming [28],
consuming stage is usually the cloud rendering where computing
cluster renders the frames of the game. The rendering procedure
can be accelerated by allocating more GPUs, and thus, can be
viewed as a quantized version of our model.

Example: Let us consider an example where there are
two autonomous vehicle service operators, say Slice 1 and
Slice 2, coexisting in the same area, and supported by two

2

share-constrained weight allocation if for each slice v,

wu = sv.

(1)

Xu∈U v
If we consider the weight of each class c as qc :=

u∈Uc wu,
c∈Cv qc = sv. As a result, a slice can increase
Eq. (1) implies
its users’ weight by purchasing more shares. Also, note that if
the number of users on a slice surges without increasing the
associated share, on average each of its users should be given
less weight. Two examples of SCWA are

P

P

P

1) equal intra-class weight allocation, where user weights
nc , for u ∈ Uc

are the same within a user class, i.e., wu = qc
with

c∈Cv qc = sv; and

2) equal intra-slice weight allocation, where user weights
are the same within a slice, i.e., wu = sv
nv , for u ∈ U v.
As a result, qc = sv(c)nc
. One can see that equal intra-
nv(c)
slice allocation is a further special case of equal intra-class
allocation. When each user only demands one resource,
such allocation emerges naturally as the social optimal,
market and Nash equilibrium when slices exhibit (price
taking) strategic behavior in optimizing their own utility,
see [8].

In turn, the resources are ultimately committed to users, so
a user-level resource allocation criterion is necessary. Let us
denote the user rate allocation by λ := (λu : u ∈ U). In this
paper, we assume equal intra-class weight allocation is used,
resulting in equal rate allocation within a user class. Thus a
class-level allocation criterion can be easily converted to a user-
level one. For simplicity, the aggregated rate allocation across
user classes is then denoted by φ = (φc : c ∈ C), where
φc := ncλu, u ∈ Uc, and the weight allocation across user
classes by q = (qc : c ∈ C). For each slice v, the weight
allocation (across user classes) is qv := (qc : c ∈ Cv), and
the rate allocation is φv := (φc : c ∈ Cv). In view of Eq.
(1), we deﬁne the normalized weight allocation for slice v as
˜qv := (˜qc := qc
sv : c ∈ Cv). The rate allocation across slices
is γ := (γv :=
c∈Cv φc : v ∈ V). The overall rate across
the system is λ := kλk1 = kφk1 = kγk1, where k · k1 is the
L1-norm. SCS is thus deﬁned as follows.

P

Deﬁnition 2. α−Share Constrained Slicing (α−SCS): Under
equal intra-class weight allocation with class weights q, a class-
level rate allocation φ corresponds to α−SCS if it is the solution
to the following problem

max
φ

{Uα(φ; q) :

Xc∈Cr

dr
cφc ≤ 1, ∀r ∈ R},

(2)

where α > 0 is a pre-deﬁned parameter and

Uα(φ; q) :=

(cid:26)

ePv∈V U
v∈V U v

v

)

;qv

α(φv
α = 1
α(φv; qv) α > 0 and α 6= 1,

where U v
is given by

α(φv; qv) represents the utility function of slice v and

P

U v

α(φv; qv) :=




P

φc
qc

c∈Cv qc log
c∈Cv qc

(φc/qc)1−α
(cid:17)
(cid:16)
1−α

α = 1

α > 0 and α 6= 1.

The criterion underlying SCS is different from class-level
(weighted) α−fairness proposed in [23] and [4], which is
deﬁned as follows.



P

Fig. 1: Example: network slicing in edge computing with
autonomous cars.

❳❳❳❳❳❳❳❳

Resource

User

user 1
user 2
user 3

1

0.4
0.3
0.3

2

0.4
0
0

3

0
0
0

4

0
0.5
0.5

5

0
0.5
0.5

Rate

λ1 = 0.4
λ2 = 0.5
λ3 = 0.5

TABLE I: Example resource allocation

edge computing nodes equipped with fronthaul connectivity
and computational resources (e.g., edge GPUs), as shown in
Fig. 1. Both nodes are connected to the same backhaul node.
Different resources at different
locations are indexed as in
the ﬁgure. There are 3 vehicles (users) in this area, each of
which corresponds to a user class. Users 1 and 2 are on Slice
1, and User 3 is on Slice 2, respectively. Each autonomous
vehicle can run either of two applications. User 1 is conducting
simple data transmission, with the resource demand vector
d1 = (1, 1, 0, 0, 0), meaning that User 1’s application involves
only connectivity resources, and to achieve a unit transmission
rate for User 1, the system needs to allocate all the connectivity
resources at both Node 1 and the backhaul. Meanwhile, User
2 and 3 are performing mobile data analytics, with demand
vectors d2 = d3 = (0.6, 0, 0, 1, 1), meaning that to achieve
a unit processing rate for Users 2 or 3, the system needs to
allocate 60% of the backhaul resource, all the fronthaul resource,
together with all the computational resource at Node 2. Then,
for example, if the resource allocation is as given in Table I,
the system can achieve user service/processing rates given by
λ1 = 0.4, λ2 = λ3 = 0.5.

Next, we introduce the concept of network share. We assign
each slice v a positive share sv representing the fraction of
overall resources to be committed to slice v. The share alloca-
tions across slices are denoted by s := (sv : v ∈ V). Without
v∈V sv = 1. In turn, each slice
loss of generality we assume
distributes its share sv across its users u ∈ U v according to a
P
Share-constrained weight allocation scheme, deﬁned as follows.

Deﬁnition 1. Share-constrained weight allocation (SCWA):
A weight allocation across users w := (wu : u ∈ U) is a

3

Deﬁnition 3. Class-level α−fairness: Under equal intra-class
weight allocation, given q, a class-level rate allocation φ
corresponds to (weighted) α−fairness if it is the solution to
Problem (2) with utility function of slice v given by

( P
P

U v

α(φv; qv) :=

c∈Cv qc log (φc) α = 1
(φc)1−α
c∈Cv qc
1−α

α > 0 and α 6= 1.

As shown in [23], α−fairness is equivalent to (weighted)
proportional fairness as α = 1 and unweighted maxmin fairness
as α → ∞, while the asymptotic characterization of α−SCS is
given as follows.

Corollary 1. α−SCS is equivalent to (weighted) proportional
fairness as α = 1, and weighted max-min fairness as α → ∞.
intra-class weight allocation, weighted
proportional fairness is deﬁned as the solution to the following
problem:

Here under equal

qc log φc :

max

φ (

Xc∈C

Xc∈Cr

dr
cφc ≤ 1, ∀r ∈ R

)

,

(3)

and weighted max-min fairness is deﬁned as the solution to the
following problem:

max

φ (

min
c∈C

φc
qc

:

Xc∈Cr
The persistence of weight

dr
cφc ≤ 1, ∀r ∈ R

.

(4)

)

Xc∈C

is important, especially when
α increases. Otherwise, the notion of share does not matter
when α is large, undermining inter-slice protection. To the best
of our knowledge, SCS is the ﬁrst variation of α−fairness
incorporating user weighting in a consistent manner.

Proof: When α = 1, one can see that the maximum is
assumes maximum. Due to
c : c ∈ C) is the

assumed when
c∈C qc log
the concavity, a rate allocation φ∗ := (φ∗
maximizer if and only if
qc
φ∗
c

c − φ∗

c ) ≤ 0,

(φ′

φc
qc

P

(cid:17)

(cid:16)

for any feasible φ′. Also, for α−SCS with weight q, when
α 6= 1, φ∗ is the maximizer if and only if

−α

φ∗
c
qc (cid:19)

(φ′

c − φ∗

c ) ≤ 0,

Xc∈C (cid:18)

for any feasible φ′. One can see that two optimality conditions
coincide when α = 1.

The asymptotic behavior when α → ∞ is a direct corollary

of the Lemma 3 in [23].

Let us deﬁne function fα(x; y) of two positive vectors x, y ∈
+ such that kxk1 = kyk1 = 1 as

Rn

fα(x; y) =




e−DKL(xky)

α = 1

1−α

1
α

i xi

yi
xi

α > 0, α 6= 1,

(5)

(cid:18)

P

(cid:16)

(cid:17)

(cid:19)



where DKL(·k·) represents the Kulback-Leibler (K-L) diver-
gence. The function fα(x; y) can be viewed as a measure of
how close a normalized resource allocation x is to a normalized
weight vector y in that, for example, when α = 1, it decreases
with the K-L divergence between x and y, thus assumes max-
imum when x = y, meaning that the rate allocation is aligned

with the speciﬁed weights. Thus fα(x; y) can be interpreted as
a measure of y−weighted fairness of allocation x.

One can easily show that fα(x; y) is continuous. Moreover,
for general α and a given y, the following claim can be shown
by setting the partial derivative of the associated Lagrangian to
0.

Proposition 1. fα(x; y) assumes maximum when the rate is
aligned with the weight when no constraint is imposed, i.e.,

fα(y; y) = max

fα(x; y)

(6)

x
One can show that for a given α, α−SCS criterion can be

factorized as follows.

Proposition 2. For the α−SCS criterion,

Uα(φ; q) = Eα(λ)

F inter
α (γ)F intra
where Eα(λ), F inter
α (γ) and F intra
α (φ; q) can be interpreted
(cid:1)
as the overall network efﬁciency,
inter-slice and intra-slice
fairness, respectively.

α (φ; q)

(7)

(cid:0)

,

α

In Eq. (7), the efﬁciency is captured by a concave non-

decreasing function of λ given by

Eα(λ) :=

(cid:26)

α = 1

λ
λ1−α
1−α α > 0 and α 6= 1.

The inter-slice fairness function is given by

F inter

α (γ) := fα(˜γ; s),

where ˜γ := (˜γv := γv/λ : v ∈ V) is the normalized aggregated
rate across slices. Let us deﬁne the normalized rate allocation
across user classes on slice v as ˜φv := ( ˜φc := φc
γv : c ∈ Cv).
The intra-slice fairness term is then given by

ePv∈V t

α(˜γ;s) log fα( ˜φv
v

;˜qv

)

v∈V tv

α(˜γ; s)(fα( ˜φv; ˜qv))α

1
α

α = 1

α 6= 1,

α(˜γ; s) can be viewed as the weight for the fairness of

(cid:17)

F intra

α (φ; q) :=




where tv
each slice v:

(cid:16)P



tv
α(˜γ; s) :=

v

sv( ˜γ
sv )1−α
v′∈V sv′ ( ˜γv′

sv′ )1−α

.

(8)

P

One can see that Eq. (7) captures a trade-off among overall
network efﬁciency, inter-slice fairness, which can be seen as
a proxy of inter-slice protection, and intra-slice fairness. The
signiﬁcance of fairness increases as α increases. When α → 0,
α−SCS is maximizing the overall rate allocated, regardless of
the weights. In order to achieve desirable resource utilization,
a sharing criterion should realize load-driven elasticity, i.e., the
amount of resources provisioned to a user class increases in the
number of its users. Under equal intra-slice weight allocation,
from Eq. (7) one can observe that, due to the fairness terms, the
relative resource allocation of a slice tends to be aligned with
˜qv = ( nc
nv : c ∈ Cv), i.e., its relative load distribution. Thus the
elasticity of α−SCS is achieved as a result of weighted fairness.
Speciﬁcally under SCS and parallel resource assumption, i.e.,
each user only uses one resource, |Rc| = 1, ∀c ∈ C, one can
show the following result.

Theorem 1. Under equal intra-slice weight allocation, assum-
ing |Rc| = 1, ∀c ∈ C, α−SCS is such that φc is a monotonically
increasing function of nc, when nc′ is ﬁxed for c′ 6= c.

4

.

Speciﬁcally in the setting of Theorem 1, each resource r
will provision its resource across user classes in proportion to
sv(c)nc
nv(c)
Such elasticity is key to achieving a sharing scheme that
is aware of the inter-slice protection, while still improves the
resource utilization by accommodating dynamic user loads on
different slices.

III. STATIC ANALYSIS

A. System model

In this section we will take a closer look at the characteriza-

tion of SCS slice level rate allocations.

The SCS criterion (Problem (2)) is equivalent to the solution

to the following problem

U v

α(φv; qv) :

max

φ (

Xv∈V

Xc∈Cr

dr
cφc ≤ 1, ∀r ∈ R

)

.

(9)

We shall explore two key desirable properties for a sharing
criterion, namely, protection and envyfreeness. In our setting,
protection means that no slice is penalized under SCS sharing
vs. static partitioning. Envyfreeness means that no slice is
motivated to swap its resource allocation with another slice
with a smaller share. These two properties together motivate
the choice of α−SCS sharing, and at least partially purchasing
a larger share in order to improve performance.

B. Protection

Formally, let us characterize protection among slices by how
much performance deterioration is possible for a slice when
switching from static partitioning to α−SCS sharing. Note that
under static partitioning, slices are decoupled, so inter-slice
protection is achieved possibly at the cost of efﬁciency. To be
speciﬁc, the rate allocation for slice v under static partitioning
is given by the following problem.

U v

α(φv; qv) :

max
φv 


Xc∈Cv

r

dr
cφc ≤ sv, ∀r ∈ R




,

(10)



From now on, for a given α, let us denote the rate allocation
: c ∈ Cv), and
for slice v under α−SCS by φv,S := (φS
c
that under static partitioning by φv,P := (φP
: c ∈ Cv). The
c
parameter α is suppressed when there is no ambiguity. The
following result demonstrates that α−SCS with α = 1 achieves
inter-slice protection in that any slice achieves a better utility
under α−SCS sharing.



Theorem 2. For a given q, when the resource allocation is
performed according to α−SCS, difference in slice v’s utility
compared to that under static partitioning is upper-bounded by
(when α 6= 1)

U α

v (φv,P ; qv) − U α

v (φv,S; qv) ≤

sv

˜qc(

Xc∈Cv

Xr∈Rc

cν∗
dr
r )

α−1
α −

qc(

α−1
α

cν∗
dr
r )

Xc∈C

Xr∈Rc

,

!

where ˜qc := qc/sv(c) is the normalized weight of class c, and
ν∗
r is the optimal dual variable associated with the capacity
constraint at resource r in Problem (9), also known as the
shadow price of resource r.

1−α

α

c∈Cv ˜qc(

the average of

r∈Rc dr
the (1 − 1
P

Remark: The right hand side characterizes how the pro-
r )1− 1
cν∗
can
tection changes with α.
be viewed as
α )−order mo-
P
ment of ‘charged’ resource usage of slice v’s user, while
α is that of the overall users. When
0 < α < 1, sharing tends to beneﬁt slices with greater average
P
user usages, at the cost of other slices, while when α > 1, slices
with smaller average user prices are preferred.
When α → 1, the utility of slice v, U α

r∈Rc dr

r )1− 1

c∈C qc(

v (φv; qv) = 1
1−α

cν∗

P

φc
qc

c∈Cv qc

tends to be non-changing with φ, so the
×
result in Theorem 2 seems to be trivial. However, due to the
P
1
factor
1−α , the utility function is not well-deﬁned at α → 1.
Thus the exact result for α need to be discussed on its own, as
in Theorem 3.

(cid:17)

(cid:16)

Also, note that when SCWA constraint Eq. (1) is voided,

another form of the theorem can be written as

U α

v (φv,P ; qv) − U α

v (φv,S; qv) ≤ wv(pv − sv

w0
wv

¯p0),

1− 1

cν∗
r

P
(cid:0)P

where wv :=
v, w0 :=
c∈Cv ˜qc

c∈Cv qc is the total weight of users of slice
c∈C qc is the total weight of all users, pv :=
P
α is the average 1 − 1
r∈Rc dr
α power of the
pv is the weighted
prices of slice v’s users, and ¯p0 :=
P
average of pv across all slices. One could see that, if wv is
not limited, as wv → ∞, as long as pv 6= ¯p0, the gap can
be arbitrarily bad, implying signiﬁcant utility loss when slice-
level sharing is used. In comparison, If we use SCWA, i.e.,
constrained by Eq. (1), the right hand side equals to sv(pv − ¯p0).
This quantity is small when sv is small, or slice v’s users do
not use many ‘expensive’ resources.

wv
w0

P

(cid:1)

v

Proof: Under sharing scheme, the rate allocation for each
slice v should be the same as the solution to the following
problem:

max
φv

U v

α(φv; qv)

such that

dr
cφc ≤

cφS
dr

c , ∀r ∈ R.

(11)

Xc∈Cv

r

Xc∈Cv

r

Problem (11) yields solution φv,S. In comparison, under static
partitioning scheme, the rate allocation for slice v is given by

max
φv

U v

α(φv; qv)

such that

dr
cφc ≤ sv, ∀r ∈ R,

(12)

Xc∈Cv

r

which can be regarded as a perturbed version of Problem (11),
and yields solution φv,P. It is a well known result in convex
optimization [7] that the change in the optimal objective function
value due to perturbation of the constraints can be bounded by:

v (φv,P; qv) − U α
U α

v (φv,S; qv) ≤

Xr∈R
The Lagrangian of Problem (11) is

ν∗
r 

Xc∈Cv

r



cφS
dr

.

c − sv
(13)


1
1 − α

Xc∈Cv
dr
cφc −

1−α

φc
qc (cid:19)
cφS
dr

c ).

qc

(cid:18)

Xc∈Cv

r

(14)

Lα(φv; ν) = −

+

νr(

Xr∈R

Xc∈Cv

r

5

 
Setting the partial derivative against φv to 0, we obtain the dual
function as:

Then if we have

r∈R ν∗

r = 1, the proof is complete. For

α = 1, the Lagrangian is given by

gα(ν) = −

1
1 − α

qc

Xc∈Cv

Xr∈Rc

1− 1
α

dr
cνr

!

dr
cqc

+

νr 


Xc∈Cv

r

Xr∈R

Xr′∈Rc

Also,

− 1
α

−

dr′
c νr′

!

cφS
dr

c 

.



Xc∈Cv

r

− 1
α

.

dr′
c ν∗
r′

!

(15)

and

φS
c = qc

Xr′∈Rc

By swapping the order of summation, one can show that

P
qc log φc +

L1(φv; ν) = −

νr(

dr
cφc −

cφS
dr

c ).

Xc∈Cv

Xr∈R

Xc∈Cv

r

Xc∈Cv

r

By setting the derivative against φv to 0, we have the dual
function as

g1(ν) = −

qc log

Xc∈Cv

qc
r∈Rc dr

cνr

+ sv −

νr

cφS
dr
c ,

Xr∈R

Xc∈Cv

r

P

φS
c =

qc
r∈Rc dr

cν∗
r

.

(20)

νr

dr
cqc

Xr∈R

Xc∈Cv

r

Xr′∈Rc

dr′
c νr′

1− 1
α

qc

Xc∈Cv

Xr∈Rc

dr
cνr

!

− 1
α

=

!

.

By strong duality, maximal dual should be minimal primal
function. And optimal dual is achieved at the shadow price ν ∗.
Thus,

P

g1(ν ∗) = −

qc log φS
c ,

Xc∈Cv

which gives us

Due to strong convexity of Problem (11), we know

gα(ν ∗) = −

1
1 − α

1−α

φS
c
qc (cid:19)

.

qc

(cid:18)

Xc∈Cv

Plugging in Eq. (15) we have

1− 1
α

qc

Xc∈Cv

Xr∈Rc

cν∗
dr
r

!

−

ν∗
r

cφS
dr

c = 0.

(16)

Xr∈R

Xc∈Cv

r

Note that if a resource is binding, the sum of resource allocated
should equal to 1. Otherwise it has 0 shadow price. Summing
above across v ∈ V, we have

1− 1
α

cν∗
dr
r

!

qc

Xc∈C

Xr∈Rc

Xr∈R

−

ν∗
r = 0.

(17)

sv −

ν∗
r

dr
cφS

c = 0.

(21)

Xr∈R

Xc∈Cv

r

r = 0.
Summing above across v ∈ V we have 1 −
Because if a resource is binding, the sum of rate allocated should
be equal to 1. Otherwise it has 0 shadow price. Plugging above
result into Eq. (19), the theorem is proved.

r∈R ν∗

P

C. Envyfreeness

Formally, envyfreeness is deﬁned under the assumption that,
for two slices v and v′, if they swap their allocated resources,
slice v’s associated utility will not be improved if sv′ ≤ sv.
Before swapping, the rate allocation for slice v is given by
φv,S, while after swapping with slice v′, its rate allocation is
determined by solving following problem:

Plugging in the right hand side of Eq. (13) to substitute
r , and also plugging in Eq. (15), the theorem is proved.

r∈R ν∗

max
φv

{U v

α(φv; qv) :

dr
cφc ≤

cφS
dr

c , ∀r ∈ R}.

P

Following is the result speciﬁcally for the case when α = 1.

Theorem 3. For a given q, when the resource allocation is
performed according to 1−SCS, slice v’s utility exceeds that
under static partitioning (Problem (10)), i.e.,

It

U v

(18)

Remark:

1 (φv,S; qv).
1 (φv,P ; qv) ≤ U v
is a straightforward observation that under
1 (φv; qv) is improved since
v∈V U v
α−SCS, the global utility
it can be viewed as relaxing the system constraints. However,
Theorem 3 asserts that this holds uniformly on a per slice basis.
Proof: Similar to the argument for general α, we have that
the gap between sharing and static partitioning satisﬁes Eq. (13).
Also, by solving the ﬁrst order condition, one can obtain that
φS
. By plugging in this expression and swapping
c ν∗
r
the order of summation we have

qc
Pr∈Rc dr

c =

P

U v

1 (φv,P ; qv) − U v

1 (φv,S; qv) ≤ sv(1 −

ν∗
r ),

(19)

where ν∗
dual variables associated with the capacity constraints.

r is the shadow price of resource r under SCS, or the

Xr∈R

r

Xc∈Cv
cφS
dr

Xc∈Cv′

r

c∈Cv′
r

Note that

c corresponds to the fraction of re-
source r provisioned to slice v′. Let us denote the solution to
such problem for slice v as φv↔v′
. Then we have following
result.

P

Theorem 4. The difference between the utility obtained by slice
v under α−SCS with SCWA, and that under static partitioning
within the resource provisioned to another slice v′ is upper-
bounded by the following inequality:

α(φv↔v′
U v

; qv) − U v

α(φv,S; qv) ≤

α−1
α

qc

Xc∈Cv′

Xr∈Rc

cν∗
dr
r

!

−

qc

Xc∈Cv

Xr∈Rc

cν∗
dr
r

!

α−1
α

.

Remark: As a special case, when α = 1, the right hand
side of the inequality becomes sv′ − sv, and thus a slice has no
incentive to swap its allocation with another with a less or equal
share, which implies SCS is envyfree. Envyfreeness implies that
α−SCS achieves desirable resource utilization in that the right
portion of resource is provisioned to the right slice.

6

 
 
 
 
 
 
 
 
 
Proof: Still by the sensitivity of convex optimization prob-

lem [7], we have

the shadow price for resource r when α = 1. According to the
deﬁnition we have

α(λv↔v′
U v

; qv) − U v

α(λv,S; qv) ≤

ν∗
r 

Xc∈Cv′

r



cφS
dr

c −

cφS
dr

c 

.



Xc∈Cv

r

(22)

Xr∈R

Then by substituting Eq. (16) the theorem is proved.

D. Using ∞−SCS as a surrogate for 1−SCS

From previous discussions, one can see that it is of particular
interest to use 1−SCS as the fairness criterion, for it achieves
strict protection and envyfreeness. When α = 1, α−SCS
becomes weighted proportional fairness, whose solution usually
involves iterative methods, and the complexity increases rapidly
with the number of user classes as well as the accuracy require-
ment, see, e.g., [26], making it hard to implement in large-scale.
In comparison, weighted max-min is relatively easy to imple-
ment in distributed manner, see [20] for example. Speciﬁcally a
progressive water-ﬁlling algorithm [26] has O(|C| maxc∈C |Rc|)
complexity. Thus, in our work we will discuss the feasibility of
using ∞−SCS, which is equivalent to a (dynamically) weighted
maxmin, as a surrogate to 1−SCS. If the resulted utility function
is not far from the optimum of 1−SCS criterion, we shall assert
∞−SCS achieves similar performance as 1−SCS.

For simplicity, we consider the original form of weighted-log

utility, given by

Ψ(φ; q) :=

qc log φc.

(23)

Xc∈C
Then for the overall utility achieved, we have following theorem.

Theorem 5. For a given weight allocation q, if dr
R, c ∈ C, we have

c ≥ 1, ∀r ∈

Ψ(φ∗,1; q) − Ψ(φ∗,∞; q) ≤

qcDc − 1,

(24)

Xc∈C

where φ∗,α := (φ∗,α
under α−SCS, and Dc :=

c

r∈Rc dr
c.

: c ∈ C) is the optimal rate allocation

Ψ(φ∗,1; q) − Ψ(φ∗,∞; q)

=

≤

=

qc(log φ∗,1

c − log φ∗,∞

c

)

qc

log

qc
r′∈Rc dr′

c ν∗
r′

c
X

c
X

P

qc

c′∈Cr(c)

P
qc log

− log





Xr∈R Xc∈ ˜Cr

  P
P



dr(c)
c′ qc′ 


c′∈Cr dr
c′qc′
r′∈Rc dr′
c ν∗

.

r′ !

The ﬁrst inequality follows from the form of solution of sharing
problem when α = 1, and the fact that φ∗,∞
,

r(c)
c′ qc′
since the worst rate user u could obtain is when there is no other
users get saturated before it at its bottleneck resource. Because
log x ≤ x − 1 we have

qc
Pc′∈Cr(c)

c ≥

d

Ψ(φ∗,1; q) − Ψ(λ∗,∞; q)

c′∈Cr dr
r′∈Rc dr′

c′qc′
c ν∗
r′

− 1

≤

=

≤

≤

≤

qc

Xr∈R Xc∈ ˜Cr

Xr∈R  

Xc′∈Cr

Xr∈R  

Xc′∈Cr

Xr∈R  

Xc′∈Cr

Xr∈R  

Xc′∈Cr

P
P
dr
c′ qc′

dr
c′ qc′

dr
c′ qc′

dr
c′ qc′

qc
r′∈Rc dr′

c ν∗
r′

− 1

P

qc
r′∈Rc dr′

c ν∗
r′

P

dr
cqc
r′∈Rc dr′

c ν∗
r′

− 1

− 1

P

!

Xc∈ ˜Cr

!

Xc∈Cr

Xc∈Cr

− 1.

!

!

The penultimate inequality holds true because dr
c ≥ 1, ∀c ∈
Cr. The last inequality comes from the capacity constraint, by
plugging in φ∗,1
c∈Cr dr
c ≤ 1, we
≤ 1. Then by swapping the order of

qc
Pr∈Rc dr

cφ∗,1

into

c ν∗
r

c =
r
d
c qc
Pr′ ∈Rc dr′

c ν∗
r′

P

have
c∈Cr
summation, we have

P

P

Remark: First note that the condition dr

c ≥ 1 can be easily
satisﬁed by rescaling the unit of rate without loss of generality.
Also by rescaling, one can show that such bound vanishes
when each user class is associated with only one resource, i.e.,
|Rc| = 1, ∀c ∈ C, and dr
c = 1. Such
bound implies that, the suboptimality due to using a surrogate
solution to achieve weighted proportional fairness depends on
the diversity in the users’ requirements on resources. Also, this
gap of suboptimality cannot be arbitrarily bad because under
c qc = 1, thus the right hand side of Eq.
SCWA, we have
(24) is at most maxc Dc − 1.

c are the same, e.g., dr

Proof: Note that when α → ∞, SCS approaches weighted
maxmin, which can be solved by a progressive water-ﬁlling al-
gorithm. Let us denote the resource where class c is bottlenecked
under weighted maxmin by r(c), and in turn, the set of users
being bottlenecked at resource r by ˜Cr . Let us deﬁne ν∗
r as

P

Xr∈R  

Xc′∈Cr

dr
c′qc′

!

=

qc

dr
c =

qcDc.

Xc∈C

Xr∈Rc

Xc∈C

IV. ELASTIC TRAFFIC MODEL

A. System model

In this section we switch gears to study a scenario where the
user trafﬁc is elastic, i.e., each user carries a certain amount of
work and leaves the system once it is ﬁnished. Speciﬁcally, for
a class-c user, we assume that its service requirement is drawn
from an exponential distribution with mean 1
µc independently,
and its arrival follows a Poisson process with intensity νc. Then
the trafﬁc intensity associated with user class c is given by ρc =
νc
µc .

Let us ﬁrst consider a given time instant, when the size of Uc
and U v are given by nc and nv respectively. Also, for simplicity

7

 
we assume equal intra-slice weight allocation, thus qc = sv(c)nc
.
nv(c)
Substituting qc into Problem (2), the α−SCS criterion can be
rewritten as follows.

max
φ

such that

sv(c)nc
nv(c)

α (φc)1−α
1 − α

(cid:17)

(25)

Xc∈C (cid:16)

φcdr

c ≤ 1, ∀r ∈ R.

B. Stability

Xc∈Cr

Problem (25) characterizes the rate allocation across classes
when the numbers of users in the network are ﬁxed. However,
it is natural to study the evolution of the system when user dis-
tributions are random processes. Note that while [4] studied the
stability condition for α−fairness when weights are introduced,
their weights do not depend on the dynamic distribution of users
in the network. By using the ﬂuid system theory established in
[16], [15] and [14], one can show that SCS stablizes the system
as long as no resource is overloaded.

Theorem 6. Assume that under equal intra-slice weight alloca-
tion, the rate allocation is given by Problem (25). Then, when
the following effective load conditions are satisﬁed:

ρcdr

c < 1, ∀r ∈ R,

(26)

Xc∈Cr

the network is stable.

Remark: Theorem 6 is signiﬁcant in that the system might
become transient under speciﬁc sharing criterion even when Eq.
(26) is satisﬁed, e.g., Example 1 in [4] when strict priorities
are designated in favor of the system throughput. Moreover,
Example 2 in the same literature demonstrates that even no strict
priority is designated, instability is still possible under Eq. (26).
Those examples implies the importance of SCS sharing and
associated weight allocation schemes.

The result in [4] is under the assumption that each user
has a ﬁxed weight. Thus the overall resources committed to
a slice increases with the number of its active users, possibly
compromising inter-slice protection. Theorem 6 shows that even
when inter-slice protection is maintained, SCS can still stablize
the system through efﬁcient utilization.

Proof: This can be proved by studying the “ﬂuid system”
the
associated with the service discipline proposed. Brieﬂy,
“ﬂuid system” associated with a queuing system is its asymp-
totic version when the transition frequency is very high and the
change of the queue length in one transition is inﬁnitesimal.
Such limiting is approached by rescaling the time axis. The
stability of the original queuing system can then be examined
by studying the associated “ﬂuid system”, see, for example, [15],
[14], and [16].

According to [15] and [14], if one can show that such ﬂuid
system gets empty eventually, the associated original queuing
system is positive recurrent. In view of this result, the outline
of the proof is as follows. Firstly we establish two functions
K(t) and H(t) such that K(t) ≥ H(t) ≥ 0, where H(t) only
takes 0 value when all the ﬂuid limits equal to 0. Then we ﬁnd
a lower bound on the negative drift rate of K(t) so that we can
conclude that K(t) → 0 eventually. Therefore H(t), together
with all the ﬂuid limits tend to 0 eventually.

Let us deﬁne the vector of users’ distribution as N(t) =

(Nc(t) : c ∈ C). Consider the set of “ﬂuid limits” deﬁned by:

x(t) = lim
ω→∞

N(ωt)
ω

, with

Nc(0) = ω,

(27)

Xc∈C

where x(t) := (xc(t) : c ∈ C) is the vector of ﬂuid limit
c∈C xc(0) = 1.
for each class. If such limit exists, we have
According to the Lemma 4.2 in [15], from Strong Law of
Large Number one can derive that, x(t) is deterministic and
the dynamic of such ﬂuid limits system is actually determined
by the rate allocation problem associated with the ﬂuid limits.
That is, x(t) follows the differential equations:

P

d
dt

xc(t) = νc − µc ˜φc(t), when xc(t) > 0,

(28)

where ˜φc(t) is the aggregated rate allocated to the ﬂuid limit of
class-c, which should be given by the following problem:

sv(c)xc(t)

xc′ (t) 

α

˜φ1−α
(t)
c
1 − α

(29)

max
˜φ:=( ˜φc:c∈C)

such that

Xc∈C



c′∈Cv

P
˜φc(t)dr


c ≤ 1, ∀r ∈ R.

Xc∈Cr

Let us assume that ˜φ(t) achieves the maximum of Problem
(29). Then the concavity of the objective function, together with
the ﬁrst-order optimality condition gives us

G′(ζ) · (ζ − Λ) ≤ 0,

where G(·) is the objective function of Problem (29), for any
feasible rate allocation vector ζ. Also note that, if the capacity
constraints Eq. (26) are satisﬁed by ρ, there exists ǫ > 0 such
that (1 + ǫ)ρ also satisﬁes Eq. (26). Plugging in (1 + ǫ)ρ as ζ
to the above inequality we have:

sv(c)xc(t)
c′∈Cv xc′ (t)

α

(cid:19)

ρ−α
c

(ρc − ˜φc(t))

Xc∈C (cid:18)

P
≤ −ǫ

sv(c)xc(t)
c′∈Cv xc′ (t)

Xc∈C (cid:18)

P

If we deﬁne function K(t) as

α

(cid:19)

α

!

ρ1−α
c

.

(30)

(ρc− ˜φc(τ ))
(ρc)α

dτ

α+1 kxv(0)kα+1,

(31)

K(t) :=

(sv)α

t
0

xc(τ )

P
c′∈Cv

xc′ (τ )

R
(sv)α|Cv|− α2

v∈V
P

+ 1
¯µ¯ρα

c∈Cv
P

v∈V
P

where ¯µ = maxc µc, and ¯ρ = maxc ρc are the maximal
processing rate and effective load across user types, respectively,
and we deﬁne the ﬂuid limit vector of slice v at time t as
xv(t) := (xc(t) : c ∈ Cv), with its Lk−norm denoted by
kxv(t)kk. We have that Eq. (30) is equivalent to

d
dt

K(t) ≤ −ǫ

Xc∈C (cid:18)

sv(c)xc(t)
c′∈Cv xc′(t)

α

(cid:19)

P

ρ1−α
c

.

(32)

8

 
The right hand side of the above inequality can be bounded

and

by:

t

Xc∈Cv Z

0 (cid:18)

P
α+1
yc(t):=(xc(t))
=========

xc(τ )
c∈Cv xc(τ )

α

(cid:19)

dxc(τ )

yc(t)

1
α + 1

yc(t)

yc(0)

Xc∈Cv Z

α






c′∈Cv
P

1

(yc′(τ ))

α+1

1

α+1 

− α

α+1

dyc(τ )

dyc(τ )

=

=

≥

=

=

=

1
α + 1

1
α + 1

α+1

1
α + 1
|Cv|− α2
α + 1
|Cv|− α2
|Cv|− α2

α+1

Xc∈Cv Z

yc(0) 

yc(t)



Xc∈Cv Z

yc(0)

yc(t)

(yc′ (τ ))

1
α+1

Xc′∈Cv
kyv(τ )k 1
α+1

!




dyc(τ )

− α
α+1

(cid:16)
(|Cv|αkyv(τ )k1)− α

(cid:17)

α+1 dyc(τ )

yc(0)

Xc∈Cv Z

kyv

(t)k1

kyv(0)k1
Z
(kyv(t)k1)
(cid:16)

(kyv(τ )k1)− α

α+1 d (kyv(τ )k1)

1

α+1 − (kyv(0)k1)

1
α+1

α+1 (kxv(t)kα+1 − kxv(0)kα+1) ,

(cid:17)

where the inequality comes from the relation between L1−norm
and L( 1
α+1 )−norm, and the following equality is by moving the
summation into the integral. Plugging the above inequality into
the deﬁnition of K(t), we have

t

xc(τ )

(sv)α

Xv∈V

0 

xc′ (τ ) 

Xc∈Cv Z
(sv)α|Cv|− α2

c′∈Cv
P
α+1 kxv(0)kα+1





α

dxc(τ )

Xv∈V
(sv)α|Cv|− α2

α+1 (kxv(t)kα+1 − kxv(0)kα+1)

(sv)α|Cv|− α2

α+1 kxv(0)kα+1

Xv∈V
(sv)α|Cv|− α2

α+1 kxv(t)kα+1.

K(t) ≥

1
¯µ¯ρα

+

1
¯µ¯ρα

≥

1
¯µ¯ρα

Xv∈V

+

1
¯µ¯ρα

1
¯µ¯ρα

=

Xv∈V
Let us deﬁne

H(t) :=

1
¯µ¯ρα

Xv∈V

(sv)α|Cv|− α2

α+1 kxv(t)kα+1.

(34)

Thus, we can conclude K(t) ≥ H(t) ≥ 0, where the non-
negativity of H(t) is straightforward, and H(t) = 0 only when
xc(t) = 0, ∀c ∈ C. Therefore, if we take

T =

F (0)

ǫsα

minρ1−α

bound min{1, (maxv |Cv|)1−α}

,

K(t) = H(t) ≡ 0 when t ≥ T , implying xc(t) ≡ 0 eventually
for all c ∈ C. Thus the system is positive recurrent.

V. SIMULATION RESULTS

One might think by introducing inter-slice protection, SCS ef-
fectively imposes additional constraints to the service discipline,
thus is compromised in users’ performance. However, this needs
not to be true, as we will demonstrate via extensive simulations

sv(c)xc(t)
c′∈Cv xc′ (t)

α

ρ1−α
c

(cid:19)

Xc∈C (cid:18)

P
≥ sα

minρ1−α
bound

v
X

Xc∈Cv (cid:18)

≥ sα

minρ1−α

bound min{1, (max
P
v

xc(t)
c′∈Cv xc′ (t)
|Cv|)1−α},

α

(cid:19)

where smin = minv sv, ρbound takes ¯ρ when α > 1 and takes
minc ρc when 0 < α < 1. The inequality is due to that for each
active slice (a slice is said to be active if
c∈Cv xc(t) > 0), we
have two possible cases:

P

1) When 0 < α ≤ 1, we have

α

≥

xc(t)

Xc∈Cv 



c′∈Cv
P

xc′ (t) 







Xc∈Cv

α

xc(t)

xc′ (t) 



c′∈Cv
P

= 1,

due to the concavity of power-α.

2) When α > 1, we have

xc(t)

Xc∈Cv 



c′∈Cv
P

xc′(t) 



α

=

c∈Cv
P

(cid:18)

c∈Cv
P

xα
c (t)

α ≥ |Cv|1−α.

xc(t)

(cid:19)

The inequality is due to that kxv(t)kα|Cv|1− 1
kxv(t)k1 when α > 1, see [32].

α ≥

Thus we found a lower bound for each v. By noting that there
should be at least one active user type before the ﬂuid system
gets emptied, we can get the last factor by taking the minimum
across all slices.

Thus, we have

d
dt

K(t) ≤ −ǫsα

K(t) ≤ K(0) − ǫsα

minρ1−α
minρ1−α

bound min{1, (max

v
bound min{1, (max

v

|Cv|)1−α}

|Cv|)1−α}t.

(33)

In order to ﬁnd a lower bound of K(t), we observe that for

each slice v ∈ V we have

ρ−α
c

(ρc − ˜φc(τ ))dτ

t

xc(τ )
c′∈Cv xc′ (τ )
t

α

(cid:19)

Xc∈Cv Z
≥

0 (cid:18)
1
¯µ¯ρα

P

Xc∈Cv Z

0 (cid:18)

P

xc(τ )
c′∈Cv xc′ (τ )

α

(cid:19)

dxc(τ ),

9

 
in this section. We compare the performance of SCS versus
several benchmarks, including:

1) Dominant Resource Fairness (DRF) [20], which is a vari-
ation of weighted maxmin fairness where users’ weights
are associated with their resource demands. Here to in-
corporate network slicing, we use its variation where a
intra-slice
user’s weight
weight allocation, i.e., wu = sv
Nv · δu, u ∈ U v, where
δu is the dominant share of user u and is given by
δu :=

is also associated with equal

, u ∈ Uc.

1
maxr∈R dr
c

2) (Discriminatory) Processor Sharing (DPS) [2], [13]. To
apply to the multi-resource case, we implement DPS as
a variation of maxmin fairness where user u’s weight is
wu = sv, u ∈ U v, without the notion of per-slice share
constraint and inter-slice protection.

Note that because SCS might be hard to scalably compute
for general α, we propose the use of ∞−SCS, as a surrogate
resource allocation scheme.

In our simulations, we focus on two performance metrics:
mean delay and mean throughput. The delay is deﬁned as the
sojourn time of each user, i.e., how long it takes for a user to
complete service. The throughput is deﬁned as the workload
divided by the sojourn time of each user. The performance
of different sharing schemes were compared in a range of
settings, from a simple single resource setting, to more complex
cases where different services/tasks are coupled together through
shared resources.

A. Single-resource cases

Since for more complicated network setup, the system per-
formance (for example, processing rate) is often determined
by resource allocations at certain ‘bottleneck’ resources, we
ﬁrst consider single-resource setting. Note that, under such
circumstances, SCS coincides with General Processor Sharing
(GPS) [30] as well as DRF because all classes of users c ∈ C are
associated with the same resource, and have the same demand.
To begin with, we consider a simple scenario where |V| = 2,
and each slice only supports one user class, so in this set-
ting, a user class corresponds to a slice. Two slices shares
one resource, referred to as Resource 1 with capacity 1, and
d1
1 = d1
2 = 1. Their trafﬁc models are assumed to be symmetric,
with mean arrival rates ν1 = ν2 = 0.45 and mean workloads
1
= 1. Their shares, however, are tuned to achieve
µ1
different performance trade-offs. The share of Slice 1, s1, ranges
from 0.01 to 0.99, while s2 = 1 − s1. The achieved mean user
perceived delay and throughput are illustrated in Fig. 2. One can
see that while the average delays are marginally better under
∞−SCS, ∞−SCS clearly outperforms DPS on the average
throughput. For example, when two slices have the same share
s1 = s2 = 0.5, SCS increases the throughput of users on both
slice by ∼10%.

= 1
µ2

= 1
µ2

This phenomenon was widely observed under different trafﬁc
assumptions. For example, when the trafﬁcs are asymmetric,
with mean arrival rates ν1 = 0.6, ν2 = 0.3 and mean workload
1
= 1, the results are illustrated in Fig. 3. Also, for
µ1
symmetric trafﬁcs with arrival rates of 0.45 and the workloads
are set to a constant 1, the results are shown in Fig. 4. In general,
while the mean delay achieved by SCS is marginally better than
DPS, the mean throughput achieved is improved signiﬁcantly.

Rate trade-off

SCS
DPS

0.4

0.5

Slice 1
(a)

Delay trade-off

0.6

0.7

DPS
SCS

0.7

0.6

0.5

2
e
c

i
l

S

0.4

0.3

0.2

0.2

0.3

2
e
c

i
l

S

8

7

6

5

4

3

2

1

2

3

6

7

8

4
5
Slice 1
(b)

Fig. 2: Performance trade-offs of single-resource case under
symmetric trafﬁc.

To explain the somewhat surprising result, we conjectured
that due to the inter-slice protection built
into SCS, under
stochastic trafﬁc, the slice with fewer customers tends to see
higher processing rate than other sharing criterion, as a result
the customers leave the system faster. Overall, SCS tends to
separate the busy periods of slices, so that the level of inter-slice
contention is reduced. We validated our conjecture by measuring
the busy period under the symmetric trafﬁc pattern, where the
arrival rates of both slices are the same, and are tuned from
0.05 to 0.45, with s1 = s2 = 0.5. Other parameters are the
same as in the setting in Fig. 2. We plot the fraction of times
when there is only one busy slice and both slices are busy, vs.
the effective trafﬁc intensity ρ = ν1
in Fig. 5. One can
µ1
see that, for both SCS and DPS, the time fraction when both
slices are busy increases with ρ, and that when only one slice
is busy ﬁrst increases when ρ is low due to underutilization,
but decreases when ρ is high because the inter-slice contention
becomes inevitable. However the time fraction when both are
busy is always smaller under SCS than that under DPS.

+ ν2
µ2

B. Multiple-resource cases

We also test the performance of SCS under a more complex
setting where a simple cellular networks with both fronthaul and
backhaul resources are simulated.

Let us consider a setting with 6 fronthaul resources, 3 back-
haul resources, and a cloud computing resource. This system
supports two slices, each containing 3 user classes. Slice 1
includes Classes 1,2 and 3, while Slice 2 includes Classes 4,

10

 
 
0.9

0.8

0.7

Rate trade-off

SCS
DPS

0.3

0.35

0.45

0.4
Slice 1
(a)

0.5

0.55

0.6

Delay trade-off

SCS
DPS

0.6

2

e
c

i
l

S

0.5

0.4

0.3

0.2

0.25

12

10

2
e
c

i
l

S

8

6

4

2

0

0.7

0.6

0.5

2

e
c

0.4

i
l

S

0.3

0.2

0.1

0.1

15

2

10

e
c

i
l

S

5

0

0

Rate trade-off

SCS
DPS

0.2

0.3

0.4
Slice 1
(a)

0.5

0.6

0.7

Delay trade-off

SCS
DPS

5

Slice 1
(b)

10

15

2

3

4

5

6

7

Slice 1
(b)

Fig. 3: Delay and throughput trade-offs of single-resource case
under asymmetric trafﬁc.

Fig. 4: Delay and throughput trade-offs of single-resource case
under symmetric M/D/1 trafﬁc model.

User
class

Class 1
Class 2
Class 3
Class 4
Class 5
Class 6

Demand vector

Mean
workload

Arrival
rate

5
6 , 0, 0, 0, 0, 0, 0.5, 0, 0, 0.217)
(
(0, 5
6 , 0, 0, 0, 0, 0.5, 0, 0, 0.217)
(0, 0, 1, 0, 0, 0, 0, 0.625, 0, 0.217)
(0, 0, 0, 1, 0, 0, 0, 0.625, 0, 0.217)
(0, 0, 0, 0, 1, 0, 0, 0, 0.625, 0.217)
(0, 0, 0, 0, 0, 1, 0, 0, 0.625, 0.217)

1
1
1
1
1
1

0.7
0.7
0.7
0.7
0.7
0.7

TABLE II: Example resource allocation

5 and 6. The association between user classes and resources
is demonstrated in Fig. 6, and the demand vectors, as well as
the arrival rates and mean workloads, are given in Table II.
Slice 1’s share is ranged from 0.1 to 0.9, while s2 = 1 − s1.
The achieved performance trade-offs under different sharing
criteria are illustrated in Fig. 7. One can see that both SCS and
DRF outperform DPS in throughput, with similar mean delays
under all 3 criteria. Similar results are observed in a range of
settings with different trafﬁc patterns and resource demands.
Moreover, in Fig. 8, we adjust the weighting schemes used in
DRF by voiding SCWA. Instead, wu = svδu, u ∈ U v, and the
resources are provisioned according to DPS with weight wu.
The results show that without SCWA, DRF is similar to DPS
in both throughput and delay. Therefore, we can conclude that
SCWA is the root cause of the desirable performance, and SCS
can even improve the system performance while providing inter-
slice protection.

n
o
i
t
c
a
r
F

0.35

0.3

0.25

0.2

0.15

0.1

0.05

0

0

Fraction of periods vs. 

SCS - only 1 busy
SCS - only 2 busy
SCS - both busy
DPS - only 1 busy
DPS - only 2 busy
DPS - both busy

0.2

0.4

0.6

0.8

1

Fig. 5: Busy period of slice 1 and 2 vs. load intensity.

Cloud computing 10

Backhaul 7

Backhaul 8

Backhaul 9

Type 1

Type 2

Type 3

Type 4

Type 5 Type 6

Fronthaul 1

Fronthaul 2

Fronthaul 3

Fronthaul 4

Fronthaul 5

Fronthaul 6

Fig. 6: Association between user classes and resources.

11

 
 
 
 
Rate trade-off

VI. CONCLUSIONS AND FUTURE WORK

0.5

0.4

2
e
c

i
l

0.3

SCS
DPS
DRF

S

0.2

0.1

0.1

0.15

0.2

0.35

0.4

0.45

0.25
0.3
Slice 1
(a)

14

12

10

2
e
c

i
l

S

8

6

4

2

Delay trade-off

SCS
DPS
DRF

2

4

6

8
Slice 1
(b)

10

12

14

Fig. 7: Performance trade-offs of multi-resource case.

Rate trade-off

SCS
DPS
DRF-weighted DPS

0.5

0.4

2

e
c

i
l

0.3

S

0.2

0.1

0.1

0.15

0.2

0.35

0.4

0.45

0.25
0.3
Slice 1
(a)

14

12

10

2

e
c

i
l

S

8

6

4

2

Delay trade-off

SCS
DPS
DRF-weighted DPS

2

4

6

12

14

16

8
10
Slice 1
(b)

Fig. 8: Performance trade-offs with DRF-weighted DPS.

This paper has explored a novel approach to resource allo-
cation for network slicing of distributed resources–SCS, pro-
viding inter-slice protection, load-driven elasticity and desirable
performance at the same time. SCS can be viewed as a key to
enabling low-complexity performance management in network
slicing, by exposing network shares to slice operators/tenants,
as a high-level resource management interface. This approach
can be further extended in two directions: i) if slices have highly
imbalanced spatial user distributions, it might be useful to let
slices specify different shares across different pools of resources,
e.g., regions corresponding to downtown, stadium and/or rural
area, see, e.g., [11]; and ii) slices may wish to request different
shares across types of resources, e.g., a slice may specify a
higher share of computational resource pool than that of the
communicational resources. For example, mobile cloud gaming
is computation intensive, thus the operator might want to reserve
more computing resources than connectivity. Finally, the share
abstraction provides a simple parametric “crude” model for
slice-level resource allocation which needs to interact with an
intra-slice performance management strategy.

REFERENCES

[1] A. Ahmed and E. Ahmed. A survey on mobile edge computing. In 2016
10th International Conference on Intelligent Systems and Control (ISCO),
pages 1–8, Jan 2016.

[2] E. Altman, K. Avrachenkov, and U. Ayesta. A survey on discriminatory

processor sharing. Queueing systems, 53(1-2):53–63, 2006.

[3] A. Banchs. User fair queuing: fair allocation of bandwidth for users. In

IEEE INFOCOM, volume 3, pages 1668–1677. IEEE, 2002.

[4] T. Bonald and L. Massouli´e. Impact of fairness on internet performance.
In ACM SIGMETRICS Performance Evaluation Review, volume 29, pages
82–91. ACM, 2001.

[5] T. Bonald and J. Roberts. Multi-resource fairness: Objectives, algorithms
and performance. In ACM SIGMETRICS Performance Evaluation Review,
volume 43, pages 31–42. ACM, 2015.

[6] F. Bonomi, R. Milito, J. Zhu, and S. Addepalli. Fog computing and its
In Proceedings of the ﬁrst edition of the

role in the internet of things.
MCC workshop on Mobile cloud computing, pages 13–16. ACM, 2012.

[7] S. Boyd and L. Vandenberghe. Convex optimization. Cambridge university

press, 2004.

[8] S. Brˆanzei, Y. Chen, X. Deng, A. Filos-Ratsikas, S. K. S. Frederiksen,

and J. Zhang. The ﬁsher market game: Equilibrium and welfare. 2014.

[9] P. Caballero, A. Banchs, G. de Veciana, and X. Costa-Pˆerez. Multi-tenant
loads.

radio access network slicing: Statistical multiplexing of spatial
IEEE/ACM Transactions on Networking, PP(99):1–15, 2017.

[10] P. Caballero, A. Banchs, G. de Veciana, and X. Costa-Prez. Multi-tenant
radio access network slicing: Statistical multiplexing of spatial
loads.
IEEE/ACM Transactions on Networking, 25(5):3044–3058, Oct 2017.
[11] P. Caballero, G. de Veciana, A. Banchs, and X. Costa-Perez. Optimiz-
ing Network Slicing via Virtual Resource Pool Partitioning (Extended).
https://www.dropbox.com/s/hso0yqupo5wfwwl/Extended VRPP.pdf.
[12] Y. Cao, H. Song, O. Kaiwartya, B. Zhou, Y. Zhuang, Y. Cao, and X. Zhang.
Mobile edge computing for big-data-enabled electric vehicle charging.
IEEE Communications Magazine, 56(3):150–156, March 2018.

[13] N. Chen and S. Jordan. Throughput in processor-sharing queues. IEEE

Transactions on Automatic Control, 52(2):299–305, 2007.

[14] J. Dai et al. A ﬂuid limit model criterion for instability of multiclass
queueing networks. The Annals of Applied Probability, 6(3):751–757,
1996.

[15] J. G. Dai. On positive harris recurrence of multiclass queueing networks: a
uniﬁed approach via ﬂuid limit models. The Annals of Applied Probability,
pages 49–77, 1995.

[16] J. G. Dai and S. P. Meyn. Stability and convergence of moments for
multiclass queueing networks via ﬂuid limit models. IEEE Transactions
on Automatic Control, 40(11):1889–1904, 1995.

[17] G. de Veciana, T.-J. Lee, and T. Konstantopoulos. Stability and per-
IEEE/ACM

formance analysis of networks supporting elastic services.
Transactions on Networking, 9(1):2–14, 2001.

[18] J. Dean and S. Ghemawat. Mapreduce: simpliﬁed data processing on large

clusters. Communications of the ACM, 51(1):107–113, 2008.

12

 
 
 
 
[19] M. Feldman et al. The proportional-share allocation market for computa-

tional resources. IEEE TPDS, 20(8):1075–1088, 2009.

[20] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, and
I. Stoica. Dominant resource fairness: Fair allocation of multiple resource
types. In Nsdi, volume 11, pages 24–24, 2011.

[21] T. Guo and R. Arnott. Active lte ran sharing with partial resource
reservation. In Vehicular Technology Conference (VTC Fall), 2013 IEEE
78th, pages 1–5. IEEE, 2013.

[22] T. Lan, D. Kao, M. Chiang, and A. Sabharwal. An axiomatic theory
In 2010 Proceedings IEEE

of fairness in network resource allocation.
INFOCOM, pages 1–9, March 2010.

[23] J. Mo and J. Walrand. Fair end-to-end window-based congestion control.
IEEE/ACM Transactions on Networking, 8(5):556–567, Oct 2000.
[24] H. Moulin. Fair division and collective welfare. MIT press, 2004.
[25] N. Nisan, T. Roughgarden, E. Tardos, and V. V. Vazirani. Algorithmic

game theory, volume 1. Cambridge University Press Cambridge, 2007.

[26] M. Pi´oro and D. Medhi. Routing, ﬂow, and capacity design in communi-

cation and computer networks. Elsevier, 2004.

[27] M. Satyanarayanan. The emergence of edge computing. Computer,

50(1):30–39, 2017.

[28] O. Soliman, A. Rezgui, H. Soliman, and N. Manea. Mobile cloud gaming:
In International Conference on Mobile Web and

Issues and challenges.
Information Systems, pages 121–128. Springer, 2013.

[29] R. Srikant and L. Ying. Communication networks: an optimization,
control, and stochastic networks perspective. Cambridge University Press,
2013.

[30] M. J. van Uitert. Generalized processor sharing queues. Eindhoven

University of Technology, 2003.

[31] H. R. Varian. Equity, envy, and efﬁciency. 1973.
[32] Wikipedia contributors. Norm (mathematics) — Wikipedia,
encyclopedia, 2018. [Online; accessed 21-December-2018].

the free

[33] H. P. Young. Equity: in theory and practice. Princeton University Press,

1995.

[34] J. Zheng, P. Caballero, G. de Veciana, S. J. Baek, and A. Banchs. Statistical
IEEE/ACM

multiplexing and trafﬁc shaping games for network slicing.
Transactions on Networking, 26(6):2528–2541, Dec 2018.

13

