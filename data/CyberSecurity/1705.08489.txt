Securing Real-Time Internet-of-Things
Chien-Ying Chen∗, Monowar Hasan∗ and Sibin Mohan
Dept. of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL, USA
Email: {cchen140, mhasan11, sibin}@illinois.edu

1

8
1
0
2
c
e
D
0
1

]
I

N
.
s
c
[

2
v
9
8
4
8
0
.
5
0
7
1
:
v
i
X
r
a

Abstract—Modern embedded and cyber-physical systems are
ubiquitous. A large number of critical cyber-physical systems
have real-time requirements (e.g., avionics, automobiles, power
grids, manufacturing systems, industrial control systems, etc.).
Recent developments and new functionality requires real-time
embedded devices to be connected to the Internet. This gives
rise to the real-time Internet-of-things (RT-IoT) that promises
a better user experience through stronger connectivity and
efﬁcient use of next-generation embedded devices. However RT-
IoT are also increasingly becoming targets for cyber-attacks
which is exacerbated by this increased connectivity. This paper
gives an introduction to RT-IoT systems, an outlook of current
approaches and possible research challenges towards secure RT-
IoT frameworks.

I. INTRODUCTION

Nowadays smart embedded devices (e.g., surveillance cam-
eras, home automation systems, smart TVs, in-vehicle info-
tainment systems, etc.) are connected to the Internet – this
rise in the Internet-of-things (IoT) links together devices/ap-
plications that were previously isolated. On the other hand,
embedded devices with real-time properties (e.g., strict timing
and safety requirements) require interaction between cyber
and physical worlds. These devices are used to monitor and
control physical systems and processes in many domains, e.g.,
manned and unmanned vehicles including aircraft, spacecraft,
unmanned aerial vehicles (UAVs), self-driving cars; critical
infrastructures; process control systems in industrial plants;
smart technologies (e.g., electric vehicles, medical devices,
etc.) to name just a few. Given the drive towards remote
monitoring and control, these devices are being increasingly
interconnected, often via the Internet, giving rise to the Real-
Time Internet-of-things (RT-IoT). Since many of these systems
have to meet stringent safety and timing requirements, any
problems that deter from the normal operation of such systems
could result in damage to the system, the environment or pose
a threat to human safety. The drive towards remote monitoring
and control facilitated by the growth of the Internet, the rise in
the use of commercial-off-the-shelf (COTS) components, stan-
dardized communication protocols and the high value of these
systems to adversaries are making cyber-security a design
priority for such systems. Security breaches are not uncommon
in critical IoT applications, especially considering the recent
spate of IoT-centric attacks ( e.g., the Marai botnet, attacks
on the Dyn DNS provider, DoS attacks from IoT devices
[1], [2]) as well as others centered on safety-critical systems
(e.g., Stuxnet [3], BlackEnergy [4], attack demonstrations by
researchers on automobiles [5], [6] and medical devices [7].)

*These authors contributed equally to this work.

Successful cyber attacks against such systems could lead to
problems more serious than just loss of data or availability
because of their critical nature [8], [6]. Attacks on one or
more of these types of systems can have catastrophic results,
leading to loss of life or injury to humans, negative impacts
on the system and even the environment.

Enabling security in RT-IoT is often more challenging
than generic IoT systems due to the additional real-time
constraints. The focus of this paper is to introduce the prop-
erties/constraints and security threats for RT-IoT (Sections II-
III), summarize security solutions specially designed for such
safety-critical domains (Section IV) and highlight the research
challenges (Section V-A). While there exit some surveys [9],
[10], [11], [12], [13] on security and privacy issues in general-
purpose IoT systems, to the best of our knowledge, there is
no comprehensive summary in the context of RT-IoT security.

II. REAL-TIME INTERNET-OF-THINGS : AN OVERVIEW

At their core, RT-IoT largely intersect with real-time cyber-
physical systems [14]. RT-IoT systems can be considered as
a wide inner-connected network, in which nodes can be con-
nected and controlled remotely. Table I summarizes some of
the common properties/assumptions related to RT-IoT systems.
In this section, we intend to outline the elements of RT-
IoT as well as the scope of security issues covered in this
paper. Figure 1 gives some common scenarios where RT-IoT
applications can be implemented.

Fig. 1: An overview of RT-IoT around everyday living. Dotted lines and
radiate symbols indicate the wireless connectivity supported by the devices.
Each RT-IoT device executes periodic real-time tasks (say τi,j – that denotes
the j-th activation of any task τi) required for safe operation of the physical
system.

A. Stringent Timing/Safety Requirements and Resources Con-
straints

Many RT-IoT devices (e.g., sensors, controllers, UAV, au-
tonomous vehicles, etc.) will have severely limited resources
(e.g., memory, processor, battery, etc.) and often require con-
trol tasks to complete within a few milliseconds [15]. RT-IoT
nodes, apart from a requirement for functional correctness,
require that temporal properties be met as well. These temporal
properties are often presented in the form of deadlines. The

!","!",$!",%!$,"!%,"!$,$Power GridSmart HomeSmart Industrial Control SystemAvionic System!&,': Jobs of Periodic TasksRTS ScheduleAutomotive SystemRTS ScheduleRTS ScheduleRT ScheduleRTS ScheduleRTS ScheduleRTS ScheduleRTS ScheduleRTS Schedule 
 
 
 
 
 
usefulness of results produced by the system drops on the
passage of a deadline. If the usefulness drops sharply then
we refer to the system as a hard real-time system (e.g.,
avionics, nuclear power plants, anti-lock braking systems in
automobiles, etc.) and if it drops is a more gradual manner then
they are referred to as soft real-time systems (e.g., multimedia
streaming, automated windshield wipers, etc.) [16].

TABLE I: Properties of Majority RT-IoT Nodes

Implemented as a system of periodic/sporadic tasks
Stringent timing requirements

•
•
• Worst-case bounds are known for all loops
•
•
• Memory and processing power is often limited
•

No dynamically loaded or self modiﬁed codes
Recursion is either not used or statically bounded

Communication ﬂows with mixed timing criticality

B. Heterogeneous Communication Trafﬁc

Many conventional RTS typically consist of several inde-
pendently operating nodes with limited or no communication
capabilities. However with the emergence of RT-IoT, cyber-
physical nodes not only communicate over closed industrial
communication networks but are also often connected via
the Internet. Since most real-time applications would need to
trigger events based on speciﬁc data conditions, a real-time
communication channel with guaranteed QoS (e.g., throughput
and data processing requirements, delay guarantees, etc.)
would also be necessary to support such applications [17],
[18].

Another property of RT-IoT is that they often include trafﬁc
ﬂows with mixed criticality, i.e., those with varying degrees
of timing (and perhaps even bandwidth and availability) re-
quirements: (a) high priority/criticality trafﬁc that is essential
for the correct and safe operation of the system; examples
could include sensors for closed loop control and actual control
commands in avionics, automotive or power grid systems;
security systems in home automation (b) medium criticality
trafﬁc that is critical to the correct operation of the system,
but with some tolerances in delays, packet drops, etc.; for
instance, navigation systems in aircraft, system monitoring
trafﬁc in power substations, communication messages ex-
changed between electric vehicles and power grid or home
charging station, trafﬁc related to home automation equipment
such as water sprinklers, heating, air conditioning, lighting
devices, food preparation appliances etc.; (c) low priority
trafﬁc – essentially all other trafﬁc in the system that does
not really need guarantees on delays or bandwidth such as
engineering trafﬁc in power substations, multimedia ﬂows in
aircraft, notiﬁcation messages from smart home equipment,
etc. Typically, in many safety-critical RT-IoT, the properties of
all high-priority ﬂows are well known, while the number and
properties of other ﬂows could be more dynamic (e.g., consider
the on-demand video situation where new ﬂows could arise
and old ones stop based on the viewing patterns of passengers
in a commercial aircraft).

C. Real-Time Scheduling Model

Many such systems are implemented using a set of periodic
(e.g., ﬁxed temporal septation between consecutive instances)

2

or sporadic (e.g., the tasks that can make an execution request
at any time, but with a minimum inter-invocation interval) tasks
[19, Ch. 1][20]. For instance, a sensor management task that
monitors the conveyor belt in a manufacturing system needs to
be periodic but the tasks that monitor the arrival of automated
cars at trafﬁc intersections are sporadic. Another example is
an engine control unit (ECU) in a modern vehicle in which
the task that controls the valve in the electronic throttle body
(ETB) is periodic while the task that handles commands from
the in-vehicle computer is sporadic. Application tasks in the
RT-IoT nodes are often designed based on the Liu and Layland
model [21], [22] that contains a set of tasks, Γ where each task
τi ∈ Γ has the parameters: (Ci, Ti, Di), where Ci is the worst-
case execution time (WCET), Ti is the period or minimum
inter-arrival time, and Di is the deadline, with Di ≤ Ti.

In the multicore context real-time task scheduling can be
viewed as solving an allocation problem (e.g., on which
processor a task should execute) depending on design criteria
[23]– e.g., (i) No migration: tasks are allocated to a processor
and no migration is permitted; (b) Task-level migration: the
jobs of a task may execute on different core; however, each
job can only execute on a single core. (c) Job-level migration:
The jobs of a task migrate to and execute on different cores;
however, parallel execution of a job is not permitted.

Schedulability tests [24], [25], [23], [26] are used to deter-
mine if all tasks in the system meet their respective deadlines.
If they do, then the task set is deemed to be ‘schedulable’ and
the system, safe.

D. CPU Architectures and System Development Model

Despite the fact that most RT-IoT applications are designed
using platforms equipped with a single-core CPU, the trend
towards multicore systems can be seen as many COTS devices
nowadays are built on top of a multicore environment [23].
For some speciﬁc applications (e.g., avionics systems), there
exist regulations that restrict the use of additional cores. In
such cases, the additional cores that do not execute real-time
or safety critical tasks can be utilized to provide layers of
security to the system. We have leveraged the use of multicore
platforms in the real-time domain and developed security
solutions [27], [28], [29], [30], [31], [32] as discussed in
Section IV-A.

It is also common that multiple vendors are involved in
the development of RT-IoT systems. Such a system is said to
be developed under the multi-vendor development model [33].
In this model, each vendor designs/controls several separate
tasks. Figure 2 demonstrates an electronic control unit (ECU)
for an avionics system (on an unmanned aerial vehicle) that
uses the multi-vendor development model. While this demon-
strative example focuses on the avionics domain other RT-IoT
systems (e.g., automotive, home automation, etc.) could also
be created using a similar model (albeit loosely deﬁned).

III. SECURITY THREATS FOR RT-IOT

RT-IoT systems face threats in various forms depending
on the system and the goals of an adversary. In a system
developed using vendor-based model, one of the involved

3

through code injection attacks conceptually consists of two
steps [34]. First, the attacker sends instruction snippets (e.g.,
a valid machine code program) to the device that is then stored
somewhere in memory by the software application receiving
it. Such instruction snippets are referred to as gadgets. In
the second step, the attacker triggers a vulnerability in the
application software, i.e., real-time OS (RTOS) or task codes to
divert the control ﬂow. Since the instruction snippets represents
a valid machine code program, when the program execution
jumps to the start address of the data, the malicious code is
executed. As we illustrate in Section IV our recent solutions
[27], [28], [29], [30], [31], [32], [35], [36], [37] can be
used to detect integrity violations through a combination of
hardware/software mechanisms.

2) Side-Channel Attacks: The adversary may learn impor-
tant information by side or covert-channel attacks [38] by
simply lodging themselves in the system and extracting sensi-
tive information. A side-channel attack manipulates previously
information from the
unknown channels to acquire useful
victim. Memory/cache access time [39], power consumption
traces [40], schedule preemptions [41], electromagnetic (EM)
emanations [42] and temperature [43] etc. are examples of
some typical side-channels used by attackers. These attack
surfaces are particularly applicable to attacking RT-IoT nodes
that execute real-time tasks due to the deterministic behav-
iors in such systems. A demonstrative cache-timing attack is
presented in Section III-B2 and Section IV-B1 illustrates our
recent approaches [44], [33] to mitigate information leakage
that used timing-based attacks on storage-channels.

3) Attacks on Communication Channels: RT-IoT elevates
the Internet as the main communication medium between the
physical entities. However, Internet, as a insecure commu-
nication medium, introduces a variety of vulnerabilities that
may put the security and privacy of RT-IoT systems under
risk. Threats to communication includes eavesdropping or
interception, man-in-the-middle attacks, falsifying, tampering
or repudiation of control/information messages [45]. From
the perspective of RT-IoT, defending against communication
threats is not an easy task. This is because it is challenging to
distinguish rogue trafﬁc from the legitimate trafﬁc (especially
for the critical/high-priority ﬂows) without degrading the QoS
(e.g., bandwidth and end-to-end delay constraints). Threats to
communications are usually dealt by integrating cryptographic
protection mechanisms [46], [47]. However this increases the
WCET of the real-time tasks and may require modiﬁcation of
existing schedulers. Many cryptographic operations are also
computationally expensive to execute especially on limited
resources available in embedded RT-IoT devices. Therefore
existing cryptographic approaches may not be a preferable op-
tion for many RT-IoT systems. In Section IV-B3 we illustrate a
solution to integrate security mechanisms that can also be used
for dealing with communication threats but does not require
modiﬁcation of existing real-time tasks.

4) Denial-of-Service (DoS) Attacks: Due to resource con-
straints (e.g., low memory capabilities, limited computation re-
sources, etc.) and stringent timing requirements, RT-IoT nodes
are vulnerable to DoS attacks. The attacker may take control of
the real-time task(s) and perform system-level resource (e.g.,

Fig. 2: A high-level design of a UAV that exempliﬁes the multi-vendor
development model. In this demonstrative system, three vendors are involved
in building the ECU system – Vendor 1 comprises tasks that process image
data from a surveillance camera attached to the ECU; Vendor 2 is in
charge of ﬂight control tasks interacting with the UAV; Integrator handles
communication between the system and a base station.

vendors can act maliciously. This (potentially unveriﬁed/un-
trusted) vendor could embed malicious functions in its tasks.
Bad coding practices could also leave vulnerabilities even if
the involved vendors are not malicious. leveraging such system
vulnerabilities adversaries can execute malicious codes (Sec-
tion III-A1), infer critical system information (Section III-A2)
and/or perform denial of service attacks (Section III-A4).
In a system that has network connectivity,
the adversary
could target the communication interfaces (Section III-A3).
Due to a lack of authentication in many of these systems,
the communication channels could easily be intercepted and
forged.

A. Attacks on RT-IoT

We classify the attack methodologies on RTS based on
the control over computational processes and the functional
objective of the attack. One way to acquire control over a
target system could be the injection of malicious code (e.g.,
malware) or by reusing legitimate code for malicious purposes
(e.g., code-injection attacks). Besides, since RT-IoT nodes
can communicate over unreliable mediums such as Internet,
the system is also vulnerable to network-level attacks. Other
than trying to aggressively crash the system (e.g., using DoS
attacks) the adversary may silently lodge itself in the system
and extract sensitive information (e.g., side-channel attacks).
The side-channel attacks are based on observing properties
(e.g., execution time, memory usage patterns, task schedule,
power consumption, etc.) of the system. This information may
later be used by the attacker to launch further attacks. In the
rest of this section, we summarize the common attack surfaces
for RT-IoT systems.

1) Integrity Violation with Malicious Code Injection: An
intelligent adversary can get a foothold in the system. For
example, an adversary may insert a malicious task that respects
the real-time guarantees of the system to avoid immediate
detection and/or compromise one or more existing real-time
tasks. The attacker may use such a task to manipulate sensor
inputs and actuator commands (for instance) and/or mod-
ify system behavior in undesirable ways. Integrity violation

UAVVendor 1IntegratorVendor 2Encryption TaskEncoderTaskIO OperationTaskMissionPlannerLawsTaskNetworkMangerSensorTaskActuatorTask(from camera)(to base station)Unprotected TaskProtected TaskCPU, disk, memory, etc.) exhaustion. A more severe type
of the DoS attack is the distributed denial-of-service (DDoS)
attack where a large number of malicious/compromised nodes
simultaneously attack the physical plant. In particular, when
critical tasks are scheduled to run, an attacker may capture
I/O or network ports and perform network-level attacks to
tamper with the conﬁdentiality and integrity (viz., safety) of the
system. Again the defense mechanisms developed for generic
IT or embedded systems do not consider timing, safety and
resource constraints of RT-IoT and are not easily adaptable
without signiﬁcant modiﬁcations. As described in Section
IV-A4 and IV-B3, our recent work [32], [35], [36], [37] may
be used to defend against DoS attacks.

But ﬁrst, in order for those attacks to be successful, recon-
naissance is one of the early steps that an attacker needs to
carry out. We illustrate this in the following (to demonstrate
an attack mechanism).

B. Reconnaissance: Attack Preparation

Reconnaissance, essentially, is the ﬁrst step for launching
other successful attacks and, at the very least, the attacker
gains important information about the system’s internals.

1) ScheduLeak:

In initial work [48], we developed an
algorithm, “ScheduLeak”, to show the feasibility of a schedule-
based side-channel attack targeting real-time embedded sys-
tems with a multi-vendor development model introduced in
Section II-D. The adversary could be one of the vendors
or an attacker who compromises a vendor. The ScheduLeak
algorithm utilizes an observer task that has the lowest priority
in the victim system to observe busy intervals. A “busy
interval” is a block of time when one or more tasks are
executing – an adversary cannot determine what tasks are
running when by just measuring or observing the busy intervals
as they are.

The ScheduLeak algorithm can be represented as a function
R(Γ, W ) = J, where W is a set of observed busy intervals
and J is the inferred schedule information that can be used
to pinpoint the possible start time of any particular victim
task. Such a function is illustrated by Fig. 3. By using
the ScheduLeak algorithm, an attacker can deconstruct the
observed busy periods (with up to 99% success rate if tasks
have ﬁxed execution times) into their constituent jobs and
precisely pinpoint the instant when a task is scheduled.

2) Targeted Attacks: It’s worth mentioning that the effec-
tiveness of side-channel attacks is enhanced when combined
with the reconnaissance step we just introduced. For example,
in the demonstrative ECU system introduced in Section II-D,
let us assume code inserted into Vendor 2 would like to
identify whether the surveillance camera controlled by the
I/O Operation Task is enabled. The attacker can launch a
ScheduLeak algorithm to infer exact start times of the IO
Operation Task and carry out a cache-timing attack to gauge
cache usage when an I/O Operation Task is scheduled. Figure 4
shows the result of such a cache-timing attack. By launching
a ScheduLeak attack and knowing when the I/O Operation
Task is scheduled to execute, the attacker probes the cache
usage only when the task is active. The result indicates that

4

the attacker is able to identify the instant when the camera
is on (i.e., when a large amount of data is processed by I/O
Operation Task).

IV. SECURING RT-IOT: HOST-BASED APPROACHES

In what follows we summarize our initial attempts to
provide security in RT-IoT nodes. We refer to these approaches
as host-based solutions since they primarily focus on securing
an individual RT-IoT node. These approaches can be classiﬁed
into two major classes: (i) solutions that require custom hard-
ware support to provide security and (ii) the solutions at the
scheduler/software level that do not require any architectural
modiﬁcations. Table II summarizes these security mechanisms
for RT-IoT systems.

A. Security with Hardware Support

The key idea of providing security without compromising
the safety of the physical system is built on the Simplex frame-
work [51]. Simplex is a well-known real-time architecture that
utilizes a minimal, veriﬁed controller (e.g., safety controller) as
backup when the complex, high-performance controller (e.g.,
complex controller) is not available or malfunctioning. The
goal of the Simplex method is to guarantee that even though a
safety-critical system is controlled by a complex controller, the
physical system would remain safe. We have used the idea of
Simplex in the context of RT-IoT security [27], [28], [29], [30],
[32]. The key concept of using Simplex-based architecture for
security is to use a minimal simple subsystem (say a trusted
core) to monitor the properties (i.e., timing behavior [27],
[28], memory access [29], system call trace [30], behavioral
anomalies [32], etc.) of an untrusted entity (e.g., monitored
core) that is designed for more complex tasks and/or exposed
to less secure mediums (e.g., network, Internet, I/O channels,
etc.).

1) Secure System Simplex Architecture (S3A): As men-
tioned in Section II, the worst-case, best-case and average-
case behaviors for most RT-IoT nodes are calculated ahead of
time to ensure that all resource and schedulability requirements
will be met during system operation. S3A [27] utilizes this
knowledge of deterministic execution proﬁle of the system
and use to detect the violation of predicted (e.g., uncompro-
mised) system behavior. S3A is one of our earliest efforts
to use another (FPGA-based, in this case) trusted hardware
component that monitors the behavior (e.g., execution time
and the period) of a real-time control application running
on a untrustworthy main system. The goal of this Simplex-
based architecture is to detect an infection as quickly as
possible and then ensure that the physical system components
always remain safe. Using an FPGA-based implementation
and considering inverted pendulum (IP) as the physical plant
we demonstrated that S3A can detect intrusions in less than 6
µs without violating safety requirements of the actual plant.
2) SecureCore Framework: As illustrated in Fig. 5 the
idea of SecureCore architecture is to utilize the redundancy
in multicore chips to create a trusted entity (e.g., a ‘secure’
core) that can continuously monitor the system behavior (e.g.,
code execution pattern [28], memory usage [29], system call

(a) Busy intervals observed by attacker’s observer task.

5

Fig. 3: An example of the schedules produced from a task set of three tasks [48]. The ScheduLeak algorithm can recover the precise schedules from the
observed busy intervals.

(b) Schedules reconstructed by the ScheduLeak algorithm.

Reference

Approach

Attack Surface

Overhead/Costs

TABLE II: Summary of Security Solutions for RT-IoT

Simplex-based
security [27], [28],
[29], [30], [31]

Security by
platform-level reset
[32], [49]

Cache ﬂushing
[44], [33]

Schedule
randomization
[50]

Security task
integration for
legacy RT-IoT [35],
[37]

Adaptive security
task integration
[36]

Use veriﬁed/secure hardware module to
monitor system behavior (e.g., timing [28]
and execution pattern [27], memory access
[29], system call usage [30], control ﬂow
[31])

Periodically and/or asynchronously
(e.g., upon detection of a malicious
activity) restart the platform and load
an uncompromised OS image
Flush the shared medium (e.g., cache)
between the consecutive execution of
high-priority (security sensitive) and low-
priority (potentially vulnerable) tasks
Randomize the task execution order (i.e.,
schedule) to reduce the predictability

Execute monitoring/intrusion detection
tasks with a priority lower than real-
time task to preserve the real-time task
parameters (e.g., period, WCET and
execution order)

Execute monitoring/intrusion detection
tasks with a lowest priority most of
the time (e.g., during normal system
operation) – however change the mode of
operation execute with a higher priority
(for a limited amount of time) if any
anomalous behavior is suspected

Code injection attacks

Require custom hardware or
monitoring unit

Code injection, side
channel and DoS attacks

Extra hardware to ensure safety
during periodic/asynchronous
restart events

Side-channel (cache)
attacks

Overhead of cache ﬂushing
reduces task-set schedulability

Side-channel attacks

Extra context switch

Code injection, side-
channel, DoS and/or
communication attacks
depending on the what
monitoring tasks are used

Code injection, side-
channel, DoS and/or
communication attacks
depending on the what
monitoring tasks are used

Running security task with
lower priority may cause longer
detection time due to high
interference (e.g., preemption)
from real-time tasks

False positive detection may
cause unnecessary mode
switches

Fig. 4: A demonstration of a cache-timing attack [48]. The X-axis is sample
points and Y-axis shows both cache usage inference (round dots) and real
memory usage amount (the solid line). It shows that a successful cache-timing
attack can precisely infer the memory usage of the victim task.

trace [30]) of a real-time application on an untrustworthy
entity (e.g., monitored core). The SecureCore is protected
by hypervisor-based approaches (e.g., by isolating memory
regions and I/O device consolidation). The secure monitor (a
software process) in the SecureCore uses the on-chip hardware
to observe the states (e.g., I/O activities,
monitoring unit
memory usages, etc.) of monitored cores and checks the
system behavior at runtime.

The initial SecureCore architecture [28] uses a statistical
learning-based mechanism for proﬁling the correct execution
behavior of the target system and uses these proﬁles to detect

Fig. 5: An illustration of SecureCore framework. The trusted core is used to
monitor the behavior of the complex (and potentially vulnerable) core used
for executing application/control tasks.

malicious code execution. Given the probability distribution
P (e) of a legitimate execution instance, the secure monitor
compares P (e) with a predeﬁned minimum required proba-
bility θ — if P (e) is below the threshold probability (e.g.,
P (e) < θ) the execution instance to is considered as malicious.
The SecureCore framework is also extended [29] to proﬁle
memory behavior (referred to as memory heat map (MHM))
and then detect deviations from the normal memory behavior

010203040506070800KB20KB40KB60KB80KB100KB Real Memory Usage Cache Usage InferenceCache Usage Samples0%20%40%60%80%100%Cache Usage InferenceReal Memory UsageOn-chipMonitoringHWMonitored CoreSecureCoreSecureMonitorHypervisorOSOSOn-chip Monitoring HW Unit•Observes the state of monitored cores, I/O activities, physical states, etc.•Invisible to all but SecureCore, non-intrusiveSecure Monitor•Software process that performs monitoring and detection using observed behaviorHypervisor-based SecureCore Protection•Resource virtualization: memory space separation, I/O device consolidation...patterns. MHM represents how many times a particular mem-
ory region was accessed during a time interval. We proposed
machine learning algorithms to characterize the information
contained in the MHMs and then detect deviations from the
normal memory behavior patterns. We have also extended
SecureCore architecture to detect anomalous executions using
a distribution of system call frequencies. Speciﬁcally we have
proposed [30] to use clustering algorithms (e.g., global k-
means clustering with the Mahalanobis distance) to learn the
legitimate execution contexts (by means of distribution of
system call frequencies) of real-time applications and then
monitor them at run-time to detect intrusions.

3) Control Flow Monitoring: We then proposed hardware-
based approach for checking the integrity of code ﬂow of
real-time tasks [31]. In particular, we add an on-chip control
ﬂow monitoring module (OCFMM) with a dedicated memory
unit
that directly hooks into the processor and tracks the
control ﬂow of the tasks. The control ﬂow graph (CFG) of
tasks is produced from the program binary and loaded into
the OCFMM memory in advance (e.g., during system boot).
The detection module inside OCFMM compares the control
ﬂow of the running program with the stored one (e.g., CFG
proﬁles that are loaded into the dedicated memory at boot
time) during program execution. At run-time (e.g., during
execution of a given block) CFG proﬁles for the next-possible
blocks are pre-fetched. The decision module continuously
scans the current block and validates the execution ﬂow by
comparing the current address of the program counter (PC)
against the possible, previously fetched destination addresses.
If any mismatch occurs, the detection module raises a detection
ﬂag that indicates a possible breach.

4) Security via Platform-level Reset: In traditional com-
puting systems (e.g., servers, smart phones, etc.), software
problems are often resolved by restarting either the appli-
cation process or the platform [52], [53]. However, unlike
those conventional computing systems restart-based recovery
mechanisms are not straightforward in RT-IoT due to the
real-time constraints as well as interactions of the control
system with the physical world (for example, a UAV can
quickly be destabilized if its controller restarts). In initial work
[32] we proposed a restart-based concept to improve security
guarantees for RT-IoT. This Simplex-based framework, that
we refer to as ReSecure, is speciﬁcally designed to improve
security of safety-critical RT-IoT systems. In particular, we
propose to restart the platform periodically/asynchronously
and load a fresh image of the applications and OS from
a read-only media after each reboot with the objective of
wiping out the intruder or malicious entity. The ReSecure
architecture (see Fig. 6) produces a veriﬁed system (by using a
safety unit) despite the use of an unveriﬁed complex controller
(e.g., complex unit). OS/Firmwire in complex unit is exposed
to external (possible attack) surfaces and can fail. Decision
module predicts if the future states are safe. Watchdog (WD)
and periodic timers restart the complex unit (and reload OS
image from read-only memory) upon fail-stop.

Our primary focus here is to ensure the safety of the system
despite the presence of malicious entity. The main idea is
that, if we restart the system frequently enough, it is less

6

Fig. 6: The ReSecure framework [32]: safety unit is the bare-metal veriﬁed
component, complex unit
is not veriﬁed. The decision module switches
between the controllers to provide overall system safety.

likely that the attacker will have time to re-enter the system
and cause meaningful damage (such as data breaches and
jeopardizing safety) to the system. After every restart, there
will be a predictable down time (during the system reboot),
some operational time (before system is compromised again)
and some compromised time (until the compromise is detected
or the periodic timer expires). The length of each one of the
above intervals depends on the type and conﬁguration of the
platform, adversary models, complexity of the exploits, etc. As
a general rule, the effectiveness of the restarting mechanism
increases: (i) as the time to re-launch the attacks increases, or
(ii) the time to detect attacks and trigger a restart decreases. We
also evaluate the expected lack of availability due to restarts
and the expected damage from the attacks/exploits given a
certain restart conﬁguration.

In later work [49], we introduced the secure execution
interval (SEI) – a period of time after each restart and
before the untrusted applications begin to execute, when the
execution environment
is not yet contaminated and hence
security is guaranteed. During SEI, the system executes trusted
code to determine the next restart time based on the current
discrete state of the physical system. When necessary, a safety
controller can override the control of the system (during SEI)
to guide the system back to a safe state. In addition, we
introduced a root of trust (RoT) – an isolated hardware timer
responsible for enforcing the restart process by issuing the
restart signal at designated times (computed by the trusted
code in SEI). RoT is designed to be programmable only
once in each execution cycle and only during SEI. Since it
is inaccessible outside of SEI and works independently, the
triggering of the restart process is not affected even when the
system is compromised. An example our framework operating
in a UAV system is illustrated in Fig. 7. The UAV operates
normally within its safe ﬂight zone and the safety controller
does not need to be activated during SEI. Once the attacker
compromises the system after the second restart (the orange
area), the UAV ﬂying towards its unsafe zone. Before the UAV
reaches the unsafe zone, the hardware timer is up in RoT and
triggers a restart. The safety controller (in SEI) takes over the
control and brings the UAV back to the safe zone. Once the
UAV returns to a predeﬁned safe zone threshold, SEI ends and
hands the control backs to the applications.

RTOSDecision ModuleSafety UnitComplex UnitComplex ControllerWD TimersRESETPINMonitoring UnitPeriodicTimersSafety ControllerSensors-User Input-Network Connection-External Peripherals-…Read-Only Memory7

Fig. 7: An example of a UAV system operating under the ReSecure framework [49]. The black line coming out from the UAV indicates the distance before
it gets out of the safe ﬂight zone. The red arrows annotate the triggering of the restarting points by the RoT. The blue arrows annotate the exit of the SEI
(and that the next restart time is scheduled in RoT). We use different colors to illustrate the different phases of the system operation – (a) white: the main
ﬂight controller is in charge and system is not compromised; (b) yellow: the system is restarting; (c) green: SEI is active, the safety controller is running and
the next restart time is being calculated; (d) orange: the system is compromised and the adversary is in charge; (e) blue/gray: the time spans when the (RoT)
interface is available and unavailable, respectively.

B. Security without Architectural Modiﬁcations

Despite the fact that architectural modiﬁcation can improve
the security posture of RT-IoT nodes, those approaches require
an overall redesign and may not be suitable for systems devel-
oped using COTS components. We now review the some of
the approaches that we recently proposed to enhance security
in RT-IoT without custom hardware support.

1) Dealing with Side-Channel Attacks: As introduced in
Section III-B2, we demonstrated that an attacker can carry
out a cache-timing attack to indirectly estimate memory usage
behavior. It is due to the lack of isolation for shared resources
across different tasks in most COTS-based RT-IoT systems.
The overlap between tasks happens when the system transi-
tions from one task to another. Therefore, capturing security
constraints between tasks becomes essential for preventing
side-channel attacks.

In previous work [44], we proposed to integrate security in
RT-IoT by introducing techniques to add constraints to tasks
scheduled with ﬁxed-priority real-time schedulers. Based on
user-deﬁned security levels for each task, the scheduler ﬂushes
shared cache when the system is transitioning from a high
security task (i.e., a task demanding higher conﬁdentiality) to
a low security task (i.e., an insecure task potentially compro-
mised). Let us consider the set of security levels for tasks, S,
that forms a total order. Hence, any two tasks (τi, τj) may
have one of the following two relationships when considering
their security levels, si, sj ∈ S: (i) si ≺ sj, meaning that τi
has higher security level than τj or (ii) sj ≺ si.

We proposed the idea of mitigating information leakage
among tasks of varying security levels, by transforming se-
curity requirements into constraints on scheduling algorithms.
The approach of modifying or constraining scheduling al-
gorithms is appealing because, (a) it
is a software based
approach and hence easier to deploy compared to hardware
based approaches and (b) it allows for reconciling the security
requirements with real-time or schedulability requirements.
Consider a simple case with two periodic tasks, a high priority
task H and a low priority task L scheduled by a ﬁxed-priority
scheduling policy. Assume that sH ≺ sL; hence, information
from H must not leak to L. These tasks must be scheduled on
a single processor, P , so that both deadlines (DH , DL) are
satisﬁed. If L (or any part thereof) executes immediately after
(any part) or all of H, then L could “leak” data from resources
recently used by H. The main intuition is that a penalty must
be paid for each shared resource in the system every time tasks

switch between security levels. In this case, the cache must be
ﬂushed before a new task is scheduled. Hence, we proposed
the use of an independent task, called the Flush Task for this
purpose.

In subsequent work [33], we relaxed many of the restrictions
(e.g.,
the requirement of total ordering of security levels)
and proposed a new, more general model to capture security
constraints between tasks in a real-time system. This includes
the analysis for the schedulability conditions with both pre-
emptive and non-preemptive tasks. We proposed a constraint
named noleak to capture whether unintended information
sharing between a pair of tasks must be forbidden. Using
this constraint we can prevent the information leakage via
implicitly shared resources. For any two tasks τi and τj: if
noleak(τi, τj) = True, then information leakage from τi to
τj must be prevented; if noleak(τi, τj) = False, no such
constraints need to be enforced. We showed that the system
remains schedulable (e.g., all the tasks can meet their deadline)
under the proposed constraints without signiﬁcant performance
impact.

2) Schedule Randomization: One way to protect a system
from certain attacks (e.g.,
the schedule-based side-channel
attack mentioned in Section III-B1), is to randomize the task
schedule to reduce the deterministic observability of periodic
RT-IoT applications. By randomizing the task schedules we
can enforce non-determinism since every hyper-period1 will
show different order (and timing) of execution for the tasks.
Unlike traditional systems, randomizing task schedules in RT-
IoT is not straightforward since it leads to priority inver-
sions [54] that, in turn, may cause missed deadlines – hence,
putting the safety of the system at risk.

Hence, we proposed TaskShufﬂer [50], a randomization
protocol for ﬁxed-priority scheduling algorithm, to achieve
such randomness in task schedule. For instance, by picking
a random task instead of the one with the highest-priority
at each scheduling point, subject to the deadline constraints.
The degree of randomness is ﬂexible in TaskShufﬂer. Based
on the system’s needs, TaskShufﬂer implements the following
randomization schemes:

• Randomization (Task Only): This is the most basic form
of randomization in contrast to other schemes introduced
below. We randomly pick a task to execute whenever

1Hyper-period is the smallest interval of time after which the periodic
patterns of all the tasks repeats itself – typically deﬁned as the least common
multiple of the periods of the tasks.

Safe Flight ZoneRoTInterfaceprogrammable?Timea task arrives or ﬁnishes its job, i.e., at the scheduling
points. The effectiveness against the schedule-based side-
channel attack is limited since the busy intervals in this
scheme remains the same.

• Randomization with Idle Time Scheduling: In addition
to the randomness provided in the basic scheme, we
include the idle task (e.g., the dummy task executed by
an RTOS when other real-time tasks are not running)
at each scheduling point. It eliminates the periodicity of
busy intervals (from hyper-period’s point of view). This
scheme makes it harder to produce effective results from
the schedule-based side-channel attack.

• Randomization with Idle Time Scheduling and Fine-
grained Switching: To push the randomization to an ex-
treme, one could choose to randomize the schedule every
tick. That is, the scheduler will randomly pick a task
to execute, subject to the deadline constraints, in every
tick interrupt. This way, we gain the most randomness
for the schedule. Figure 8 illustrates an instance of the
randomized schedule for an simple taskset with three
tasks. However, it greatly increases the overheads and
thus may not be applicable for all use cases.

(a)

(b)
Fig. 8: Examples of the schedule randomization protocol with three tasks: (a)
vanilla ﬁxed priority scheduling (e.g., schedules without randomization); (b)
TaskShufﬂer (ﬁne-grained scheduling with randomizing idle times). Blocks
numbered 0 to 2 are the execution of periodic tasks while blocks numbered
3 indicate idle time (i.e., the idle task). The following taskset parameters
are used in the illustration: τ0(5, 1, 5), τ1(8, 2, 8), τ2(20, 3, 20) where each
task τi(Ci, Ti, Di), 0 ≤ i ≤ 2 is characterized by WCET (Ci), period (Ti)
and deadline (Di). Each row represents a hyperperiod and the ﬁgure shows
the schedule of 20 hyperperiod. For vanilla scheduling, task schedules are
repeating each hyperperiod. In contrast, TaskShufﬂer scrambles the schedule
across hyperperiod and thus make it harder to predict a particular task
execution instance.

IoT systems with real-time properties are predictable by
design. This very determinism can become a vulnerability
in the hands of smart adversaries and it becomes easier to
carry out adversarial actions such as side-channel attacks [55],
[56], DoS (making critical resources unavailable at important
times) or even the recently developed timing-inference attacks
[55]. TaskShufﬂer can reduce the determinism that is visible to

8

external entities while still meeting real-time guarantees. With
such randomization, even if an observer is able to capture the
exact schedule for a (limited) period of time (for instance, for
a few hyperperiods), TaskShufﬂer will schedule tasks in a way
that succeeding hyperperiod will show different orders (and
timing) of execution for the tasks.

3) Integrating Security for Legacy RT-IoT: As we have
described in Section III-B1, an adversary can extract important
information while still remaining undetected and it is essential
to have a layered defense and integrated resilience against
such attacks into the design of RT-IoT. However, any security
mechanisms have to co-exist with real-time tasks in the system
and have to operate without impacting the timing and safety
constraints of the control logic. Besides, the embedded nature
of these systems limits the availability of computational power
(e.g., memory or processor) required for resource-extensive
monitoring mechanisms. This creates an apparent
tension
between security requirements (e.g., having enough cycles for
effective monitoring and detection) and the timing and safety
requirements. For example, a critical parameter is to determine
how often and how long should a monitoring and intrusion
interfere
detection task execution to be effective but not
with real-time control or other safety-critical
tasks. While
this tension could potentially be addressed for newer systems
at design time, this is especially challenging for retroﬁtting
legacy systems where the control tasks are already in place and
perhaps cannot be modiﬁed. Any hardware and/or software-
level modiﬁcations to those legacy system parameters is costly
since it will go through several veriﬁcation and validation
steps and may increase system downtime [15]. Most of the
security solutions for RT-IoT proposed in literature either
require custom hardware [27], [28], [29], [30], [31], [32],
[57], [49], modiﬁcation of the existing schedulers [46], [47],
extra instrumentations [57] or may need to change the tasks
parameters (e.g., execution order and/or run-time) [44], [33],
[50] and therefore not suitable for legacy systems. Integrating
monitoring and detection tasks for RT-IoT without custom
hardware support is an open problem.

Given the tension between security and timing requirements,
while integrating security mechanisms into a practical system,
ﬁnding the frequency of execution of the monitoring tasks is an
important design parameter that trades security requirements
with timing constraints. If the interval between consecutive
monitoring events is too large, the adversary may harm the
system (and remain undetected) between two invocations of
the security task. In contrast, if the security tasks are executed
very frequently then it may impact the schedulability of the
real-time tasks.

In preliminary work [35] we address the problem of de-
termining the frequency of execution (e.g., periods or inter-
monitoring interval) of the security tasks. Our approach to inte-
grate security without perturbing real-time scheduling order is
to execute security tasks at a lower priority tasks than real-time
tasks. We refer this scheme as opportunistic execution since
the security tasks are only allowed to execute opportunistically
only during slack times when no other real-time tasks are
running.

We propose to measure the security of the system by means

Limited Uncertainty in Real-Time Scheduling•Schedules are deterministic•Easier for adversary to predict when the victim would executeTaskShufflerHP	10112202311033330113302221013330311303333HP	20112202311033330113302221013330311303333HP	30112202311033330113302221013330311303333HP	40112202311033330113302221013330311303333HP	50112202311033330113302221013330311303333HP	60112202311033330113302221013330311303333HP	70112202311033330113302221013330311303333HP	80112202311033330113302221013330311303333HP	90112202311033330113302221013330311303333HP	100112202311033330113302221013330311303333HP	110112202311033330113302221013330311303333HP	120112202311033330113302221013330311303333HP	130112202311033330113302221013330311303333HP	140112202311033330113302221013330311303333HP	150112202311033330113302221013330311303333HP	160112202311033330113302221013330311303333HP	170112202311033330113302221013330311303333HP	180112202311033330113302221013330311303333HP	190112202311033330113302221013330311303333HP	200112202311033330113302221013330311303333HP	10332110223110333011302333302110211303333HP	21021323230033113330301132022113333001313HP	32212001311303333013303121023313021103333HP	40233101211230330133102232310133333013013HP	50123122330301313013312203302110313103333HP	63122013230311300331122302101330311333033HP	71132003233112030113320321323010313130333HP	83131030213202133133013201221303013330133HP	91310203332021130311333023202110333130133HP	101132030233021130131333023220113013313330HP	113302113210032313013130323130212033301133HP	123110332320012310311333330210212330313130HP	131301320213120330133120232031133303101333HP	143220101331023130113322023301133013313033HP	152221013033311300113332033212010311303333HP	160223101231031330113323230211303303133103HP	173212010231313300333110232303110233301133HP	183321001233201130331313031102323023311303HP	190131323022310130333101323201313203330113HP	203021201233301130331133033212100233301133TaskShuffler•Schedule randomization protocol•Random job selection by priority inversions•Guaranteed schedulabilityby bounded priority inversionsTaskShuffler9

apriori. The goal of this scheme therefore is to jointly ﬁnd the
core-to-task assignment and suitable periods for the security
tasks. However, ﬁnding such an assignment is NP-hard due to
combinatorial nature of the problem. Therefore we developed
a near-optimal low-complexity solution (called HYDRA) that
jointly ﬁnds the security tasks’ period and core assignments.
From our experiment we found that on average HYDRA (that
distributes security tasks across all available cores) can provide
27.23% faster intrusion detection rate (on a quad core system)
compared to the case when the security tasks are allocated a
dedicated core for while the real-time tasks are assigned to the
remaining cores.

V. DISCUSSION AND RESEARCH OPPORTUNITIES

A. Securing Legacy RT-IoT Systems

Since most RT-IoT nodes are resource-constrained em-
bedded devices, resource-intensive processing and complex
protocols (e.g., heavy cryptographic operations) for securing
those systems is unrealistic and may threaten the safety of such
systems – for instance a safety-critical task may miss deadline
in order to run computation-heavy security tasks. In addition
to execution frequency, another important consideration is
to determine how quickly can intrusions be detected. Thus
responsiveness vs. schedulability of critical tasks is another
important trade-off. This in itself is a research challenge that
needs to be investigated.

So far we have assumed that we are given a set of security
tasks and that each security task has a desired frequency of
execution for better security coverage. Security tasks so far
have been treated as being independent and preemptible. But
in practice, as previously discussed some security monitoring
may need atomicity or non-preemptive execution. Further,
security tasks may have dependencies where one task depends
on the output from one or more other tasks. For example, an
anomaly detection task may depend on the outputs of multiple
scanning tasks. Or, the scheduling framework may need to
follow certain precedence constraints for security tasks. For
example, in order to ensure integrity of monitoring security,
the security application’s own binary may need to be examined
ﬁrst before checking the system binary ﬁles. In such cases
we can not independently execute the security task and we
need to consider the problem of integrating security tasks
with dependencies between them. One approach could be use
a directed acyclic graph (DAG) to capture the dependencies
and constraints among security tasks. In this case, tightness
of achievable periodic monitoring described in Section IV-B3
may no longer be a reasonable metric. Constraints to en-
sure that the entire DAG is executed often enough should
be included and the optimization problem reformulated and
evaluated with different metrics.

B. Security for Multicore based RT-IoT Platforms

Most of the work [48], [44], [33], [35], [36] presented
so far has been in the context of single core processors –
they are the most common types of processors being used
in RT-IoT systems. However, as mentioned earlier, due to
increasing computational demands, multi-core processors are

Fig. 9: Flow of operations in Contego depicting different modes for the
security tasks.

of the achievable periodic monitoring. Let Ti be the period of
the security task that needs to be determined. Our goal here
is to minimize the perturbation between the achievable (i.e.,
unknown) period Ti and the desired (e.g., designer provided)
period T des
. We formulate a constraint optimization problem
and develop a polynomial-time solution that allows us to
execute security tasks with a frequency closer to the desired
values while respecting the temporal constraints of the other
real-time tasks.

i

If the security tasks always execute with lowest priority, they
suffer more interference (i.e., preemption from high-priority
real-time tasks) and the consequent longer detection time (due
to poor response time) will make the security mechanisms
less effective. In order to provide better responsiveness and
increase the effectiveness of monitoring and detection mech-
anisms, we then proposed a multi-mode model [36]. This
framework (called Contego) allows the security policies/tasks
to execute in different modes in different modes (i.e., passive
monitoring with lowest priority as well as exhaustive checking
with higher priority). By using this approach (see Fig. 9), for
instance, security routines can execute opportunistically when
the system is deemed to be clean (i.e., not compromised).
However if any anomaly or unusual behavior is suspected, the
security policy may switch to a ﬁne-grained checking mode
and execute with higher priority. The security routines may go
back to normal mode if: i) no anomalous activity is found; or
ii) the intrusion is detected and malicious entities are removed.
The aforementioned works however are developed for single
core systems only – integrating security mechanisms for legacy
multicore platforms (where designers have less ﬂexibility for
changing system architecture/parameter) is also a challenging
problem. In recent work [37] we developed a scheme for
multicore RT-IoT and ﬁnd a suitable assignment of security
tasks that ensures they can execute with a frequency close to
what a designer expects. We considered a multicore platform
comprised of M identical cores. One fundamental problem
while integrating security mechanisms in multicore platforms
is to determine which security tasks will be assigned to
which core and executed when. Although security tasks can
execute in any of the M available cores and any period
T des
is acceptable, the actual task-to-core
i
assignment and the periods of the security tasks are not known

≤ Ti ≤ T max

i

RT Task 1RT Task 2* Security Task 1: executes both Active and Passive Mode* Security Task 2: executes only Passive Mode.…..2.Anomaly detected, Perform additional checks(Switch to Active Mode)3.Active Mode (Security Tasks execute with higher priority than RT Task 2)4.Find everything normal or timeout(Switch back to Passive Mode)1.Passive Mode (Security Task executes with lowest priority)Time.…...…..SE Task 1Higher to lower priorityRT Task 1RT Task 2.…..SE Task 1Higher to lower prioritySE Task 2.…...…...…..Timebecoming increasingly relevant to real-time systems [58], [23].
With the increased number of cores, more computation can be
packed into a single chip – thus reducing power and weight
requirements – both of which might be relevant to many
RT-IoT systems. However multicore processors can increase
attack vectors, especially for side-channel attacks. First, two
or more tasks are running together and (most likely) sharing
low-level resources (e.g., last level caches). Hence, a task
running on one core can snoop on the other – and not just
when tasks follow each other. In fact, it has been shown that
leakage can occur with a much higher bandwidth in the case
of shared resources in multi-core processors [59]. Second,
when tasks execute together, a malicious task can increase
the “interference” faced by a critical task – for instance, the
malicious task can ﬂood the cache/bus with memory references
just when an important task (say, one that computes the control
loop) is running. This could cause the critical task to get
delayed and even miss its deadline. To prevent such problems,
designers of the systems need to enforce constraints that
protected tasks do not execute simultaneously with unprotected
ones on the multi-core chip.

The problem of integrating security tasks into legacy RT-IoT
systems is also interesting in the multicore context – perhaps
the security tasks can always be running (say on one of the
dedicated cores) instead of running opportunistically as is the
case for single core systems. Also it may be possible to to
take up more cores and execute ﬁne-grained sanity checks
(e.g., a complete system-wide scan) as it detects malicious
activity. Analyzing the impact of integrating security tasks
in a multicore legacy RT-IoT is an open problem worth
investigating.

C. Secure Communication with Timing Constraints

With the rise of RT-IoT, the edge devices are more fre-
quently exchanging control messages and data often with
unreliable mediums like the Internet. Therefore, in addition
to the host-based approaches [27], [28], [29], [30], [31], [50],
[44], [33] described earlier, there is a requirement for securing
communication channels to ensure authenticity and integrity
of control messages. While some of our previous work [32],
[35] can also be used to deal with network-level attacks,
designing a uniﬁed framework to protect edge devices as well
as communication messages (given the stringent end-to-end
delay requirements for high-critical trafﬁcs) is still an open
problem.

Most safety-critical RT-IoT systems often have separate
networks (hardware and software) for each of the different
types of ﬂows for safety (and security) reasons. This leads
to signiﬁcant overheads (equipment, management, weight,
etc.) and also potential for errors/faults and even increased
attack surface and vectors. Network-level nondeterminism, i.e.,
unpredictability in sensor reading, packet delivery/forward-
ing/processing further complicates the management of RT-IoT
systems. Existing protocols, e.g., avionics full-duplex switched
Ethernet (AFDX) [60], controller area network (CAN) [61],
etc. that are in use in many of real-time domains are either
proprietary, complex, expensive, require custom hardware or
they are also exposed to known vulnerabilities [62].

10

Given the limitations of existing protocols, leveraging the
beneﬁts of software-deﬁned networking (SDN) can also be
effective for RT-IoT systems. The advantage of using SDN
is that it is compatible with COTS components (and thus
suitable for legacy RT-IoT systems) and provides a centralized
mechanism for developing and managing the system. The
global view is useful to ensure QoS (e.g., bandwidth and delay)
and enforce security mechanisms (such as remote attestations,
secure key/message exchange, remote monitoring, etc.). While
SDNs provide a global view of the network and high-level
management capabilities (including resource allocation), cur-
rent standards used in traditional SDN (e.g., OpenFlow [63])
do not consider inherent timing and safety-critical nature of the
RT-IoT systems. In recent work [64] we tried to address this
problem through static ﬂow allocation and routing – we used
static path allocation and over-provisioning hardware resources
(e.g., dedicating one queue per real-time ﬂow) for meeting the
end-to-end delay requirements and providing isolation. This
limited the number of ﬂows that could be admitted and resulted
in underutilized network resources. Retroﬁtting the capabilities
of SDN in the RT-IoT domain requires further research. We
also need mechanisms to prioritize between ﬂows (say between
the critical real-time ﬂows or even across real-time and non
real-time ﬂows) and also schemes for multiplexing ﬂows on the
same queues in the SDN switches (to improve the efﬁciency
of the network) while still meeting the real-time constraints.

VI. RELATED WORK

There exists work that has investigated security in real-time
systems [46], [47], [65]. Many researchers have studied this
research area from different aspects. Information leakage via
side channels has been discussed in many works. Kadloor et al.
[66] and Gong et al. [67] introduced analysis and methodology
for quantifying side-channel leakage. Kelsey et al. [39], Osvik
et al. [68] and Page et al. [69] demonstrated the usability of
cache-based side-channels. Son et al. [41] and V¨olp et al.
[70] examined the exploitation of timing channels in real-time
scheduling. Bao et al. [71] introduce a scheduling algorithm
for soft real-time systems (where some tasks can miss dead-
lines) and provide a trade-off between thermal side-channel
information leakage and the number of deadline misses. Their
exists other work [56] that studies the robustness of AES secret
keys against differential power analysis (DPA) [72] attacks.

While the work above focuses on exploring vulnerabilities,
there exist work that aims to provide security to real-time
systems. Ghassami et al. [73] and V¨olp et al. [74] proposed
techniques to address leakage via shared resources. An online
job randomization scheme [75] is proposed by Kr¨uger et al.
for time-triggered real-time systems. Xie et al. [46] and
Lin et al. [47] presented security in real-time systems by
encrypting communication messages. Similar to the hardware-
assisted security mechanisms like ours (e.g., S3A, SecureCore,
ReSecure, etc.) researchers also propose architectural frame-
works [57] that dynamically utilizes slack times (e.g., the
time instance when no other real-time tasks is executing)
for run-time monitoring. There exists recent work [76], [77]
where authors proposed schemes to secure systems from

man-in-the-middle attacks, where an attacker can compromise
communication between system sensors and controllers.

Some recent work has raised security awareness in IoT
applications [10], [78], [79], [13], [80]. Some researchers aim
to add security properties to IoT. Pacheco et al. [81] introduced
a security framework that offers security solutions with smart
infrastructures. Kuusij¨arvi et al. [82] proposed to mitigate
IoT security threats with using trusted networks. Those work
primarily focuses on generic IoT applications, and do not
consider the additional real-time constraints required for RT-
IoT systems.

VII. CONCLUSION

The sophistication of recent attacks on RT-IoT requires
rethinking of security solutions for such systems. The goal
of this paper is to raise the awareness of real-time security
and bridge missing gaps in the current IoT context – securing
the IoT systems with real-time constraints. The techniques and
methodology presented here vary from different perspectives
– from hardware-assisted security to scheduler-level as well
as those for legacy systems. The designers of the systems and
research community will now be able to integrate and develop
upon these frameworks required to secure safety-critical RT-
IoT systems. We believe that the real-time and IoT worlds
are closely connected and will become inseparable in the near
future.

ACKNOWLEDGEMENT

The multiple security frameworks presented in this paper
is the result of a team effort. The authors would like to
acknowledge the contributions from our team members and
collaborators: Man-Ki Yoon, Fardin Abdi Taghi Abad, Rodolfo
Pellizzoni, Rakesh B Bobba, Lui Sha and Marco Caccamo.
This work is supported in part by grants from the National
Science Foundation (NSF CNS 14-23334, NSF CPS 1544901
and NSF SaTC 1718952), ONR (N00014-13-1-0707) and the
Dept. of Energy. Any opinions, ﬁndings, and conclusions or
recommendations expressed here are those of the authors and
do not necessarily reﬂect the views of sponsors.

REFERENCES

[1] C. Kolias, G. Kambourakis, A. Stavrou, and J. Voas, “DDoS in the IoT:
Mirai and other botnets,” Computer, vol. 50, no. 7, pp. 80–84, 2017.
[2] J. Westling, “Future of the Internet of things in mission critical appli-

cations,” 2016.

[3] N. Falliere, L. O. Murchu, and E. Chien, “W32. stuxnet dossier,” White

paper, Symantec Corp., Security Response, vol. 5, p. 6, 2011.

[4] R. M. Lee, M. J. Assante, and T. Conway, “Analysis of the cyber attack
on the ukrainian power grid,” SANS Industrial Control Systems, 2016.
[5] K. Koscher, A. Czeskis, F. Roesner, S. Patel, T. Kohno, S. Checkoway,
D. McCoy, B. Kantor, D. Anderson, H. Shacham et al., “Experimental
security analysis of a modern automobile,” in IEEE S&P, 2010, pp.
447–462.

[6] S. Checkoway, D. McCoy, B. Kantor, D. Anderson, H. Shacham,
S. Savage, K. Koscher, A. Czeskis, F. Roesner, T. Kohno et al.,
“Comprehensive experimental analyses of automotive attack surfaces,”
in USENIX Sec. Symp., 2011.

[7] S. S. Clark and K. Fu, “Recent results in computer security for medical

devices,” in MobiHealth, 2011, pp. 111–118.

[8] M. Abrams and J. Weiss, “Malicious control system cyber security
attack case study–maroochy water services, australia,” McLean, VA: The
MITRE Corporation, 2008.

11

[9] A.-R. Sadeghi, C. Wachsmann, and M. Waidner, “Security and privacy
challenges in industrial Internet of things,” in ACM/EDAC/IEEE DAC,
2015, pp. 1–6.

[10] I. B. Ida, A. Jemai, and A. Loukil, “A survey on security of IoT in the
context of eHealth and clouds,” in IEEE IDT, 2016, pp. 25–30.
[11] R. H. Weber, “Internet of things–new security and privacy challenges,”

Comp. law & sec. rev., vol. 26, no. 1, pp. 23–30, 2010.

[12] G. A. Fink, D. V. Zarzhitsky, T. E. Carroll, and E. D. Farquhar, “Security
and privacy grand challenges for the internet of things,” in IEEE CTS,
2015, pp. 27–34.

[13] S. Kraijak and P. Tuwanut, “A survey on IoT architectures, protocols,
applications, security, privacy, real-world implementation and future
trends,” in IET WiCOM 2015, 2015, pp. 1–6.

[14] J. Gubbi, R. Buyya, S. Marusic, and M. Palaniswami, “Internet of things
(iot): A vision, architectural elements, and future directions,” Future gen.
comp. sys., vol. 29, no. 7, pp. 1645–1660, 2013.

[15] M. Chiang and T. Zhang, “Fog and iot: An overview of research
opportunities,” IEEE IoT Journal, vol. 3, no. 6, pp. 854–864, 2016.

[16] J. W. S. Liu, Real-Time Systems. Prentice Hall, 2000.
[17] Y. Ge, X. Liang, Y. C. Zhou, Z. Pan, G. T. Zhao, and Y. L. Zheng,
“Adaptive analytic service for real-time internet of things applications,”
in IEEE ICWS, 2016, pp. 484–491.

[18] J.-E. Kim, T. Abdelzaher, L. Sha, A. Bar-Noy, R. Hobbs, and W. Dron,
“On maximizing quality of information for the internet of things: A
real-time scheduling perspective,” in IEEE RTCSA, 2016, pp. 202–211.
[19] G. Buttazzo, Hard real-time computing systems: predictable scheduling

algorithms and applications, 2011, vol. 24.

[20] A. K. Mok, “Fundamental design problems of distributed systems for
the hard-real-time environment,” Massachusetts Institute of Technology,
Tech. Rep., 1983.

[21] C. L. Liu and J. W. Layland, “Scheduling algorithms for multiprogram-
ming in a hard-real-time environment,” JACM, vol. 20, no. 1, pp. 46–61,
1973.

[22] R. I. Davis, “A review of ﬁxed priority and edf scheduling for hard
real-time uniprocessor systems,” ACM SIGBED Review, vol. 11, no. 1,
pp. 8–19, 2014.

[23] R. I. Davis and A. Burns, “A survey of hard real-time scheduling for
multiprocessor systems,” ACM CSUR, vol. 43, no. 4, p. 35, 2011.
[24] M. Joseph and P. Pandya, “Finding response times in a real-time system,”

The Comp. J., vol. 29, no. 5, pp. 390–395, 1986.

[25] N. Audsley, A. Burns, M. Richardson, K. Tindell, and A. J. Wellings,
“Applying new scheduling theory to static priority pre-emptive schedul-
ing,” SE Journal, vol. 8, no. 5, pp. 284–292, 1993.

[26] E. Bini and G. C. Buttazzo, “Schedulability analysis of periodic ﬁxed
priority systems,” IEEE Trans. on Comp., vol. 53, no. 11, pp. 1462–
1473, 2004.

[27] S. Mohan, S. Bak, E. Betti, H. Yun, L. Sha, and M. Caccamo, “S3A:
Secure system simplex architecture for enhanced security and robustness
of cyber-physical systems,” in ACM HiCoNS, 2013, pp. 65–74.
[28] M.-K. Yoon, S. Mohan, J. Choi, J.-E. Kim, and L. Sha, “SecureCore: A
multicore-based intrusion detection architecture for real-time embedded
systems,” in IEEE RTAS, 2013, pp. 21–32.

[29] M.-K. Yoon, S. Mohan, J. Choi, and L. Sha, “Memory heat map:
anomaly detection in real-time embedded systems using memory be-
havior,” in ACM/EDAC/IEEE DAC, 2015, pp. 1–6.

[30] M.-K. Yoon, S. Mohan, J. Choi, M. Christodorescu, and L. Sha,
“Learning execution contexts from system call distribution for anomaly
detection in smart embedded system,” in ACM/IEEE IoTDI, 2017, pp.
191–196.

[31] F. A. T. Abad, J. Van Der Woude, Y. Lu, S. Bak, M. Caccamo, L. Sha,
R. Mancuso, and S. Mohan, “On-chip control ﬂow integrity check for
real time embedded systems,” in IEEE CPSNA, 2013, pp. 26–31.
[32] F. Abdi, M. Hasan, S. Mohan, D. Agarwal, and M. Caccamo, “ReSecure:
A restart-based security protocol for tightly actuated hard real-time
systems,” in IEEE CERTS, 2016, pp. 47–54.

[33] R. Pellizzoni, N. Paryab, M.-K. Yoon, S. Bak, S. Mohan, and R. B.
Bobba, “A generalized model for preventing information leakage in hard
real-time systems,” in IEEE RTAS, 2015, pp. 271–282.

[34] A. Francillon and C. Castelluccia, “Code injection attacks on harvard-
architecture devices,” in ACM CCS. New York, NY, USA: ACM, 2008,
pp. 15–26.

[35] M. Hasan, S. Mohan, R. B. Bobba, and R. Pellizzoni, “Exploring
opportunistic execution for integrating security into legacy hard real-
time systems,” in IEEE RTSS, 2016, pp. 123–134.

[36] M. Hasan, S. Mohan, R. Pellizzoni, and R. B. Bobba, “Contego: An
adaptive framework for integrating security tasks in real-time systems,”
in IEEE ECRTS, 2017.

12

[64] R. Kumar, M. Hasan, S. Padhy, K. Evchenko, L. Piramanayagam,
S. Mohan, and R. B. Bobba, “End-to-end network delay guarantees for
real-time systems using sdn,” in IEEE RTSS, 2017.

[65] S. Son, C. Chaney, and N. Thomlinson, “Partial security policies
to support timeliness in secure real-time databases,” in Security and
Privacy, 1998. Proceedings. 1998 IEEE Symposium on, 1998, pp. 136–
147.

[66] S. Kadloor, N. Kiyavash, and P. Venkitasubramaniam, “Mitigating
timing side channel in shared schedulers,” CoRR, vol. abs/1302.6123,
2013. [Online]. Available: http://arxiv.org/abs/1302.6123

[67] X. Gong and N. Kiyavash, “Timing side channels

in shared
[Online]. Available:

queues,” CoRR, vol.
http://arxiv.org/abs/1403.1276

abs/1403.1276, 2014.

[68] D. A. Osvik, A. Shamir, and E. Tromer, “Cache attacks and counter-
measures: the case of aes,” in Crypt.’ Track at the RSA Conf., 2006, pp.
1–20.

[69] D. Page, “Theoretical use of cache memory as a cryptanalytic side-

channel.” IACR Crypt. ePrint Arc., vol. 2002, p. 169, 2002.

[70] M. V¨olp, C.-J. Hamann, and H. H¨artig, “Avoiding timing channels in

ﬁxed-priority schedulers,” in ACM ASIACCS, 2008, pp. 44–55.

[71] C. Bao and A. Srivastava, “A secure algorithm for task scheduling
against side-channel attacks,” in International Workshop on Trustworthy
Embedded Devices. ACM, 2014, pp. 3–12.

[72] P. Kocher, J. Jaffe, B. Jun, and P. Rohatgi, “Introduction to differential
power analysis,” Journal of Cryptographic Engineering, vol. 1, no. 1,
pp. 5–27, 2011.

[73] A. Ghassami, X. Gong, and N. Kiyavash, “Capacity limit of queueing
timing channel in shared fcfs schedulers,” in IEEE ISIT, pp. 789–793.
[74] M. V¨olp, B. Engel, C.-J. Hamann, and H. H¨artig, “On conﬁdentiality
preserving real-time locking protocols,” in IEEE RTAS, 2013, pp. 153–
162.

[75] K. Kr¨uger, M. V¨olp, and G. Fohler, “Vulnerability analysis and mit-
igation of directed timing inference based attacks on time-triggered
systems,” in ECRTS, vol. 106, 2018, pp. 22:1–22:17.

[76] V. Lesi, I. Jovanov, and M. Pajic, “Network scheduling for secure cyber-

physical systems,” in IEEE RTSS, 2017, pp. 45–55.

[77] V. Lesi, I. Jovanov, and M. Pajic, “Security-aware scheduling of embed-
ded control tasks,” ACM TECS, vol. 16, pp. 188:1–188:21, 2017.
[78] A. H. Ngu, M. Gutierrez, V. Metsis, S. Nepal, and M. Z. Sheng, “IoT
middleware: A survey on issues and enabling technologies,” IEEE IoT
Journal, vol. 4, no. 1, pp. 1–20, 2017.

[79] M. Mohsin, Z. Anwar, G. Husari, E. Al-Shaer, and M. A. Rahman,
“IoTSAT: A formal framework for security analysis of the Internet of
things (IoT),” in IEEE CNS, 2016, pp. 180–188.

[80] J. Wurm, K. Hoang, O. Arias, A.-R. Sadeghi, and Y. Jin, “Security
analysis on consumer and industrial IoT devices,” in IEEE ASP-DAC,
2016, pp. 519–524.

[81] J. Pacheco and S. Hariri, “IoT security framework for smart cyber

infrastructures,” in IEEE FAS*, 2016, pp. 242–247.

[82] J. smar, R. Savola, P. Savolainen, and A. Evesti, “Mitigating IoT security
threats with a trusted network element,” in IEEE ICITST, 2016, pp. 260–
265.

[37] M. Hasan, S. Mohan, R. Pellizzoni, and R. B. Bobba, “A design-space
exploration for allocating security tasks in multicore real-time systems,”
in IEEE DATE, 2018, pp. 225–230.

[38] Y. Zhou and D. Feng, “Side-channel attacks: Ten years after its publi-
cation and the impacts on cryptographic module security testing.” IACR
Cryptology ePrint Archive, vol. 2005, p. 388, 2005.

[39] J. Kelsey, B. Schneier, D. Wagner, and C. Hall, “Side channel crypt-

analysis of product ciphers,” in ESORICS, 1998, pp. 97–110.

[40] K. Jiang, L. Batina, P. Eles, and Z. Peng, “Robustness analysis of real-
time scheduling against differential power analysis attacks,” in IEEE
ISVLSI, 2014, pp. 450–455.

[41] J. Son and J. Alves-Foss, “Covert

timing channel analysis of rate
monotonic real-time scheduling algorithm in MLS systems,” in IEEE
IAW, 2006, pp. 361–368.

[42] D. Agrawal, B. Archambeault, J. R. Rao, and P. Rohatgi, “The EM side-
channel(s),” in International Workshop on Cryptographic Hardware and
Embedded Systems. Springer, 2002, pp. 29–45.

[43] H. Bar-El, H. Choukri, D. Naccache, M. Tunstall, and C. Whelan, “The
sorcerer’s apprentice guide to fault attacks,” Proceedings of the IEEE,
vol. 94, no. 2, pp. 370–382, 2006.

[44] S. Mohan, M.-K. Yoon, R. Pellizzoni, and R. B. Bobba, “Real-time
systems security through scheduler constraints,” in IEEE ECRTS, 2014,
pp. 129–140.

[45] G. Loukas, Cyber-physical attacks: A growing invisible threat.

Butterworth-Heinemann, 2015.

[46] T. Xie and X. Qin, “Improving security for periodic tasks in embedded

systems through scheduling,” ACM TECS, vol. 6, no. 3, p. 20, 2007.

[47] M. Lin, L. Xu, L. T. Yang, X. Qin, N. Zheng, Z. Wu, and M. Qiu, “Static
security optimization for real-time systems,” IEEE Trans. on Indust.
Info., vol. 5, no. 1, pp. 22–37, 2009.

[48] C.-Y. Chen, A. Ghassami, S. Nagy, M.-K. Yoon, S. Mohan, N. Kiyavash,
R. B. Bobba, and R. Pellizzoni, “Schedule-based side-channel attack in
ﬁxed-priority real-time systems,” Tech. Rep., 2015.

[49] F. Abdi, C.-Y. Chen, M. Hasan, S. Liu, S. Mohan, and M. Caccamo,
“Guaranteed physical security with restart-based design for cyber-
physical systems,” in ACM/IEEE ICCPS, 2018, pp. 10–21.

[50] M.-K. Yoon, S. Mohan, C.-Y. Chen, and L. Sha, “TaskShufﬂer: A
schedule randomization protocol for obfuscation against timing infer-
ence attacks in real-time systems,” in IEEE RTAS, 2016, pp. 1–12.
[51] L. Sha, “Using simplicity to control complexity,” IEEE Software, vol. 18,

no. 4, pp. 20–28, 2001.

[52] G. Candea, E. Kiciman, S. Zhang, P. Keyani, and A. Fox, “Jagr: An
autonomous self-recovering application server,” in IEE Auto. Comp.
Wkshp., 2003, pp. 168–177.

[53] G. Candea and A. Fox, “Recursive restartability: Turning the reboot

sledgehammer into a scalpel,” in IEEE HOTOS, 2001, pp. 125–130.

[54] L. Sha, R. Rajkumar, and J. P. Lehoczky, “Priority inheritance protocols:
An approach to real-time synchronization,” IEEE Trans. on comp.,
vol. 39, no. 9, pp. 1175–1185, 1990.

[55] C.-Y. Chen, R. B. Bobba, and S. Mohan, “Schedule-based side-channel
attack in ﬁxed-priority real-time systems,” University of Illinois, http:
//hdl.handle.net/2142/88344, Tech. Rep., 2015, [Online].

[56] K. Jiang, L. Batina, P. Eles, and Z. Peng, “Robustness analysis of real-
time scheduling against differential power analysis attacks,” in IEEE
Computer Society Annual Symposium on VLSI.
IEEE, 2014, pp. 450–
455.

[57] D. Lo, M. Ismail, T. Chen, and G. E. Suh, “Slack-aware opportunistic
monitoring for real-time systems,” in IEEE RTAS, 2014, pp. 203–214.
2016, White
Internet
[Online]. Available: https://www.windriver.com/whitepapers/

Paper.
iot-virtualization/1436-IoT-Virtualization-White-Paper.pdf

[58] “Virtualization

things,”

and

the

of

[59] Q. Ge, Y. Yarom, D. Cock, and G. Heiser, “A survey of microarchitec-
tural timing attacks and countermeasures on contemporary hardware,”
Journal of Crypt. Eng., pp. 1–27, 2016.

[60] C. M. Fuchs et al., “The evolution of avionics networks from ARINC

429 to AFDX,” NW Arch. & Serv., 2012.

[61] M. Farsi, K. Ratcliff, and M. Barbosa, “An overview of controller area
network,” Comp. & Cont. Eng. Journal, vol. 10, no. 3, pp. 113–120,
1999.

[62] T. Hoppe, S. Kiltz, and J. Dittmann, “Security threats to automotive can
networks–practical examples and selected short-term countermeasures,”
in SAFECOMP, 2008, pp. 235–248.

[63] N. McKeown, T. Anderson, H. Balakrishnan, G. Parulkar, L. Peterson,
J. Rexford, S. Shenker, and J. Turner, “Openﬂow: enabling innovation in
campus networks,” ACM SIGCOMM Comp. Comm. Rev., vol. 38, no. 2,
pp. 69–74, 2008.

