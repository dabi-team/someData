7
1
0
2

g
u
A
9

]

R
C
.
s
c
[

1
v
9
4
7
2
0
.
8
0
7
1
:
v
i
X
r
a

Rise of the HaCRS:
Augmenting Autonomous Cyber Reasoning Systems with Human Assistance

Yan Shoshitaishvili
Arizona State University
yan.shoshitaishvili@asu.org

Michael Weissbacher
Northeastern University
mw@ccs.neu.edu

Christopher Salls
UC Santa Barbara
salls@cs.ucsb.edu

Ruoyu Wang
UC Santa Barbara
fish@cs.ucsb.edu

Giovanni Vigna
UC Santa Barbara
vigna@cs.ucsb.edu

Lukas Dresel
UC Santa Barbara
lukas.dresel@cs.ucsb.edu

Christopher Kruegel
UC Santa Barbara
chris@cs.ucsb.edu

ABSTRACT
Software permeates every aspect of our world, from our homes to
the infrastructure that provides mission-critical services.

As the size and complexity of software systems increase, the
number and sophistication of software security flaws increase as
well. The analysis of these flaws began as a manual approach, but it
soon became apparent that a manual approach alone cannot scale,
and that tools were necessary to assist human experts in this task,
resulting in a number of techniques and approaches that automated
certain aspects of the vulnerability analysis process.

Recently, DARPA carried out the Cyber Grand Challenge, a com-
petition among autonomous vulnerability analysis systems designed
to push the tool-assisted human-centered paradigm into the territory
of complete automation, with the hope that, by removing the human
factor, the analysis would be able to scale to new heights. However,
when the autonomous systems were pitted against human experts it
became clear that certain tasks, albeit simple, could not be carried
out by an autonomous system, as they require an understanding of
the logic of the application under analysis.

Based on this observation, we propose a shift in the vulnerability
analysis paradigm, from tool-assisted human-centered to human-
assisted tool-centered. In this paradigm, the automated system or-
chestrates the vulnerability analysis process, and leverages humans
(with different levels of expertise) to perform well-defined sub-tasks,
whose results are integrated in the analysis. As a result, it is possible
to scale the analysis to a larger number of programs, and, at the same
time, optimize the use of expensive human resources.

In this paper, we detail our design for a human-assisted automated
vulnerability analysis system, describe its implementation atop an
open-sourced autonomous vulnerability analysis system that partici-
pated in the Cyber Grand Challenge, and evaluate and discuss the
significant improvements that non-expert human assistance can offer
to automated analysis approaches.

INTRODUCTION

1
Software has become dominant and abundant. Software systems
support almost every aspect of our lives, from health care to fi-
nance, from power distribution to entertainment. This growth has
led to an explosion of software bugs and, more importantly, soft-
ware vulnerabilities. Because the exploitation of vulnerabilities can

1

have catastrophic effects, a substantial amount of effort has been
devoted to discovering these vulnerabilities before they are found by
attackers and exploited in the wild.

Traditionally, vulnerability discovery has been a heavily manual
task. Expert security researchers spend significant time analyzing
software, understanding how it works, and painstakingly sifting it
for bugs. Even though human analysts take advantage of tools to
automate some of the tasks involved in the analysis process, the
amount of software to be analyzed grows at an overwhelming pace.
As this growth reached the scalability limits of manual analysis, the
research community has turned its attention to automated program
analysis, with the goal of identifying and fixing software issues on a
large scale. This push has been met with significant success, culmi-
nating thus far in the DARPA Cyber Grand Challenge (CGC) [27],
a cyber-security competition in which seven finalist teams pitted
completely autonomous systems, utilizing automated program anal-
ysis techniques, against each other for almost four million dollars in
prize money.

By removing the human factor from the analysis process, the
competition forced the participants to codify the strategy and or-
chestration tasks that are usually performed by experts, and, at the
same time, it pushed the limits of current vulnerability analysis tech-
niques to handle larger, more complex problems in an efficient and
resource-aware manner. These systems represented a significant step
in automated program analysis, automatically identifying vulnerabil-
ities and developing exploits for 20 of a total of 82 binary programs
developed for the event.

Despite the success of these systems, the underlying approaches
suffer from a number of limitations. These limitations became evi-
dent when some of the CGC autonomous systems participated in a
follow-up vulnerability analysis competition (the DEFCON CTF)
that included human teams. The autonomous systems could not
easily understand the logic underlying certain applications, and, as
a result, they could not easily produce inputs that drive them to
specific (insecure) states. However, when humans could provide
“suggestions” of inputs to the automated analysis process the results
were surprisingly good.

This experience suggested a shift in the current vulnerability
analysis paradigm, from the existing tool-assisted human-centered
paradigm to a new human-assisted tool-centered paradigm. Systems
that follow this paradigm would be able to leverage humans (with

 
 
 
 
 
 
Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

forward, we open-source our modifications to Mechanical
Phish.

• We experimentally evaluated the effectiveness of our tasklets
in aiding the vulnerability analysis process of our system
by leveraging the assistance of unskilled humans, showing
that significant contribution can be made without requiring
expert hackers.

In the next section, we will discuss the background of automated
program analysis and pinpoint the challenges that we hope to solve
with human-analyzed tasklets.

2 BACKGROUND
The field of vulnerability discovery has received a significant amount
of research attention. In this section, we will describe the current
state of the art of both automated and manual vulnerability discovery
techniques, show the challenges facing each of them, and position
our approach in the context of related work.

2.1 Fully Automated Analysis
Individual techniques have been developed for identification of vul-
nerabilities [6, 11, 25], automatic exploitation [1, 12, 20], and auto-
matic application protection [19, 28, 29]. However, until recently,
researchers did not focus on the integration of various techniques
into cohesive end-to-end systems. Over the last two years, DARPA
hosted the Cyber Grand Challenge which required contestants to
develop Cyber Reasoning Systems (CRSes). These are fully au-
tonomous machines capable of identifying, exploiting, and patching
vulnerabilities in binary code.

A Cyber Reasoning System represents the culmination of years
of research into automated binary analysis. However, being fully
autonomous, CRSes suffer from the limitations of their underlying
techniques. These limitations were reflected in the Cyber Grand Chal-
lenge results, in which only 20 out of the 87 vulnerable challenges
were successfully exploited by the machine contenders [7, 23].

2.2 Human-based Computation
While the assembly line pioneered the idea of splitting complex
physical tasks (such as the assembly of a car) into small, manageable
micro-tasks as early as the 12th century [5], the intellectual equiv-
alent was not explored until modern times. This concept was most
popularized with the Manhattan Project, in which specific computa-
tion micro-tasks were assigned to and carried out by human “comput-
ers” [8]. With the emergence of modern computing capability, these
micro-tasks came to be chiefly carried out by machines. As comput-
ers developed to the point where they could oversee such efforts, a
formal specification of the different roles that humans and computer
components can take on in computation emerged [15, 16, 21]. This
specification defines three roles:

Organization Agent. The organization agent is the overall intelli-
gence. It tracks the progress of work toward an overarching
goal, determines what should be done, and creates micro-
tasks. In the Manhattan Project, the organization agent was
the panel of scientists leading the research effort.
Innovation Agent. The innovation agent is the entity responsible
for carrying out micro-tasks defined by the organization

Figure 1: Tool-assisted Human-centered Analysis vs. Human-assisted
Tool-centered Analysis.

different level of expertise) for specific well-defined tasks (e.g., tasks
that require an understanding of the application’s underlying logic),
while taking care of orchestrating the overall vulnerability analysis
process.

This shift is somewhat similar to introduction of the assembly line
in manufacturing, which allowed groups of relatively unskilled work-
ers to produce systems (such as cars) that had, until then, remained
the exclusive domain of specially trained engineers. Conceptually,
an assembly line “shaves off” small, easy tasks that can be carried
out by a large group of people, in loose collaboration, to accomplish
a complex goal.

In this paper, we explore the application of this idea to vulnerabil-
ity analysis. More precisely, we develop an approach that leverages
tasklets that can be dispatched to human analysts by an autonomous
program analysis system, such as those used in the Cyber Grand
Challenge, to help it surmount inherent drawbacks of modern pro-
gram analysis techniques (see Figure 1). We explore the question of
how much our “program analysis assembly line” empowers humans,
otherwise unskilled in the field, to contribute to program analysis,
and we evaluate the improvement that external human assistance
can bring to the effectiveness of automated vulnerability analysis1.
Our results are significant: by incorporating human assistance into
an open-source Cyber Reasoning System, we were able to boost the
amount of identified bugs in our dataset by 55%, from 36 bugs (in
85 binaries) using fully-automated techniques to 56 bugs through
the use of non-expert human assistance.

In summary, this paper makes the following contributions:

• We introduce the design of a human-assisted automated
vulnerability analysis system, in which the result of well-
defined tasklets that are delegated to human actors are in-
tegrated in the (otherwise) autonomous analysis process.
These tasklets help automated analysis systems to bridge
the “semantic gap” in the analysis of complex applications.
• We implemented a prototype human-assisted autonomous
system on top of Mechanical Phish, a system that partici-
pated in the DARPA Cyber Grand Challenge, which was
open-sourced by its authors. To support the community
and drive the state of (semi-) automated program analysis

1In the rest of the paper, we refer to “automated vulnerability analysis” as the orchestra-
tion process, even though it might include tasks that are outsourced to humans.

2

Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

agent. In the Manhattan Project, the innovation agents were
the human “computers” solving computation tasks.
Selection Agent. The selection agent collates the results produced
by the innovation agents and determines which are valid.
In the Manhattan Project, this task was performed by the
scientists leading the effort.

Systems are described using three letters, depending on whether a
human or computer agent is responsible for each role. For example,
an HCH designation would imply a system with a human deciding
which tasks to execute, a computer executing them, and the human
deciding which of the results are useful. In a security context, this
might be the human specifying jobs to a symbolic execution engine,
and then analyzing its output to identify exploitable bugs in a piece
of software.

Over the last few years, the Internet has achieved enough satura-
tion to support complex combinations of human and computer agents.
For example, Amazon’s Mechanical Turk provides an API for auto-
matically specifying micro-tasks for human consumption [2], usually
used in a CHC context. In fact, we use Mechanical Turk for many of
our experiments in this paper. In a similar vein to Mechanical Turk,
specific-purpose platforms have been created to leverage human
effort in the pursuit of a single overarching goal. One such platform,
Galaxy Zoo [30], utilizes human-completed micro-tasks for the clas-
sification of astronomical images, while another, Foldit[10], aids
protein folding algorithms by having humans play “folding games.”

2.3 Human-Driven Automated Analysis
Because it is important to understand the interactions between man-
ual and automated processes in binary analysis systems, we provide
a few examples of their intersections outside of the context of our
work.

Fuzzing. Generational fuzzers, such as Peach [14], attempt to
create inputs conforming to a specification that a program is designed
to process. Mutational fuzzers, such as AFL [31], mutate previously-
known inputs to identify program flaws.

The most common way of creating these inputs and input specifi-
cations is manually, through human effort. This results in an HCH
system – a human creates the input specification, the computer per-
forms the fuzzing, and a human analyzes the results.

An example of successful human-computer cooperation in binary
analysis is the discovery of the Stagefright vulnerability in the An-
droid multimedia library. This vulnerability was found by repeating
the following steps [9]:

Organization - H. The analyst seeds a mutational fuzzer (in this

case, AFL), and starts it.

Innovation - C. The fuzzer identifies vulnerabilities in the target
application (in this case, the Android multimedia library).
Selection - H. The human collects the vulnerabilities and fixes them
so that future iterations of the full system will identify
deeper vulnerabilities.

By repeating this HCH process, the analyst was able to identify
many high-impact vulnerabilities inside the Android multimedia
library, requiring multiple patches and an eventual rewrite of the
entire library to fix [26].

3

2.4 Human-Assisted Automated Analysis
The Cyber Grand Challenge required a fully autonomous system
(CCC, by the definitions in Section 2.2). This necessitated the devel-
opment, by participating teams, of complex automation to handle the
organizational, innovation, and selection roles. However, we propose
that while the organizational and selection roles must be automated
to achieve high scalability, some human effort can still be used in
the innovation role to mitigate drawbacks currently impacting au-
tomated program analysis techniques. That is, our intuition is that
it is possible to create a Human-assisted Cyber Reasoning System
(HaCRS) that would sparingly use human assistance to improve its
performance.

HaCRS provides a principled framework for such an integration
of manual and automated analysis. It can be modeled as a C(C|H)C
system: it does most of its work fully autonomously, but relies on hu-
man intuition in the innovation phase, when the automated processes
get “stuck.” In this paper, we propose that limited human assistance
can be used in the scope of otherwise-automated binary analysis
systems. While this has been explored in the context of generating
inputs for Android applications, it has never been investigated in the
context of an other-wise autonomous Cyber Reasoning System [18].
In the next section, we will give an overview of our system, fol-
lowed by in-depth details and an evaluation of its improvement over
fully-autonomous systems from the Cyber Grand Challenge.

3 OVERVIEW
While DARPA’s Cyber Grand Challenge drove the integration of cut-
ting edge automated binary analysis techniques, it also revealed the
many limitations of these techniques. Our work on HaCRS extends
the concept of a Cyber Reasoning System by defining a method
for human interaction that compensates for many of these limita-
tions. Primarily, HaCRS is an autonomous Cyber Reasoning System.
However, when it identifies situations that can benefit from human
analysis, HaCRS dispatches self-contained tasklets and assigns them
to human assistants. These human assistants can vary in skill, from
abundant low-skill analysts to rare high-skill hackers.

Our HaCRS can dispatch a variety of tasklets to human assis-
tants, depending on changing requirements. Generally, each tasklet
includes a specific program that must be analyzed and a request for
specific information that the human can extract from this program.
These tasklets are created by a centralized orchestration component
and disseminated to the assistant through a Human-Automation Link
(HAL). In this paper, as an initial exploration of this idea, we focus
on human-assisted input generation, leaving the exploration of other
tasklets to future work.

The Cyber Reasoning System. HaCRS is based on Mechanical
Phish, an open-source Cyber Reasoning System that was
created by Shellphish, the hacking team of the SecLab of
UC Santa Barbara, and competed in the DARPA Cyber
Grand Challenge [22, 23]. Shellphish designed Mechani-
cal Phish as a set of discrete components, providing indi-
vidual analysis tasks, united by a central component that
handles the “overarching intelligence” [23]. This makes it
straightforward (though, unfortunately, non-trivial) to ex-
tend Mechanical Phish with other analysis techniques, such
as tasklet dispatching.

Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

To the interested reader, we describe the relevant design

details of Mechanical Phish in Section 4.

Human-Automation Link. We extend Mechanical Phish to request

According to the authors, this was done in an attempt to reduce the
complexity of the organizational components by freeing them from
the requirement of tracking their own prior decisions [22].

assistance, from non-expert humans, in principled ways.

Mechanical Phish includes several organizational components:

The prototype action that we explore in this paper is
input generation. In input generation, input testcases are
created through both automated and human-assisted tech-
niques to form a base set of testcases to use in vulnerability
discovery. We describe this task, the conveyance of task-
specific information in a human-friendly format, and the
use of the results in our Human-assisted Cyber Reasoning
System in Section 5.

Next, we will discuss relevant details of Mechanical Phish before
delving into the details of our tasklets. After this, we will evaluate
human performance in the execution of these tasklets against au-
tomated alternatives derived from the state-of-the-art in program
analysis.

4 THE CYBER REASONING SYSTEM
We based our implementation on the Cyber Reasoning System de-
veloped for the Cyber Grand Challenge and open-sourced by Shell-
phish [22]. While Mechanical Phish is composed of modules that
are spread over more than 30 different source code repositories, the
core design appears to be fairly straightforward [22].

In this section, we will describe Mechanical Phish in terms of
the computation framework discussed in Section 2.2. First, we will
discuss the type of software that Mechanical Phish is designed to
analyze. Then, we split the existing design into the Organization
Agent, Innovation Agent, and Selection Agent, as defined in Sec-
tion 2. Afterwards, in the next section, we will detail our extensions
on top of Mechanical Phish, and the specific points at which we
insert human interaction.

4.1 Program Analysis Targets
Mechanical Phish was built for participation in the Cyber Grand
Challenge. The Cyber Grand Challenge used a custom operating
system, DECREE, to ease the implementation load on participants.
To simplify analysis tasks, DECREE supports software written with
a text-based interface, using seven system calls, roughly equivalent
to the Linux system calls exit, write, read, select, mmap,
munmap, and getrandom.

Aside from this simplified environment, DECREE places no re-
strictions on the complexity of the software itself. As such, ap-
plications written for the Cyber Grand Challenge vary widely in
complexity, from text-based video games to “Computer-aided de-
sign“ software to web servers, and provide significant challenges to
the current state-of-the-art in program analysis. Additionally, it is
important to stress that all analysis done by HaCRS takes place on
binaries, and thus functions without the semantic hints present in
source code.

4.2 Organization Agents
The Mechanical Phish is a state-less Cyber Reasoning System,
where, for each decision, all of the information available to Me-
chanical Phish, such as the binaries to be analyzed and the currently-
available results of analysis components, is re-analyzed from scratch.

4

Task Creator. The task creator analyzes currently available results
and identifies tasks that should be created, and their pri-
orities. This component is actually a conglomeration of
individual, task-specific creators. Each task-specific creator
schedules its own tasks without input from other creators:
the only interaction between the creators of different tasks
happens when results of those tasks influence the current set
of analysis results (and, in turn, are used by the subsequent
tasks created by these creators).

Task Scheduler. Each task is assigned a priority by its creator. The
task scheduler analyzes task priorities and available system
resources and determines which tasks to schedule.
Environment Interaction. In order to inject data into Mechanical
Phish, and submit the results, interaction with the environ-
ment is required. This component handles the retrieval of
input into and exposure of output out of the system. While
in the CGC this interaction was very straightforward, Cyber
Reasoning Systems operating in other environments (for
example, in a real-world cyber warfare situation) might
require considerably complex agents for this task.

The first task that the system must carry out is the integration of
environment information (for example, which binaries are available
for analysis), after which the Innovation and Selection Agents can
run.

4.3 Selection Agents
The selection agents are responsible for the integration of the results
that are produced by the innovation agents. However, the Mechani-
cal Phish does not make a distinction between the innovation agents
and the integration agents in most cases. One exception is:

Vulnerability triaging. When crashes are identified by the vulner-
ability discovery component, they are triaged to determine
the feasibility of transforming them into exploits. This in-
formation is then used by the Task Creator to prioritize
exploitation tasks based on the crash.

Exploit selection. The exploits created by the Exploitation Agents
are checked against different variations of the target binaries
to verify that, for example, opponent systems did not patch
the vulnerability. Successful exploits are entered into the
database, to be submitted by the Environment Interaction
Agent.

Patch selection. Mechanical Phish implements a simple patch se-
lection criteria, preferring patches produced by advanced
(but more failure-prone) techniques than simple (but higher-
overhead) ones.

The results of these agents are used by the organizational compo-

nents to schedule further innovation tasks.

Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

Figure 2: The HaCRS configuration. HaCRS builds upon the vulnerability discovery component of the Mechanical Phish and expands it with a Human-
Automation Link to leverage non-expert human assistance in the vulnerability discovery process. Each subsystem of the vulnerability discovery
component, except for the fuzzer itself, has both an automated and a human-assisted alternative. The components with a dashed border were already
present in Mechanical Phish. We created the solid-bordered components for HaCRS.

Innovation Agents

4.4
The tasks that are created and scheduled by the Organization Agents
are carried out by the innovation agents. Specifically, Mechanical
Phish includes the following agents:

Vulnerability discovery. Mechanical Phish uses a combination of
fuzzing and symbolic execution to analyze target binaries.
These are implemented as separate agents that interact
through cross-pollination of dynamic test cases. Specifi-
cally, as proposed by Driller, a coverage-based fuzzer is
used in parallel with a symbolic tracing technique to pro-
duce inputs that maximize code coverage [25].

Exploitation. Several different exploitation agents are used by Me-
chanical Phish, depending on the types of vulnerabilities
that are discovered.

Patching. Mechanical Phish uses a complex patching agent, in
several different configurations, to patch the vulnerabilities
that it identifies in binary code.

These innovation agents process inputs and produce updates to
the system state. These updates are filtered through selection agents
before the system state accepts them.

5

4.5 Automated Vulnerability Discovery - Fuzzing
The fuzzing approach in the Mechanical Phish is based on a muta-
tional fuzzer known as American Fuzzy Lop [31]. This approach
requires, as input, a set of test cases that exercise some functionality
in the target binary. The seed quality, in terms of how well they
exercise the target program, has a scaling effect on the effectiveness
of AFL: the more coverage these test cases provide, the more code
AFL will be able to explore by mutating them. Unfortunately, the
creation of high-quality test case seeds is a complicated problem,
and this is generally seen as a human-provided input into a system.
For example, lacking human input, Mechanical Phish simply seeds
its fuzzer with an input comprised of the word “fuzz.”

These seeds are then mutated to explore more and more of the
code base and increase the chance of triggering bugs. Eventually,
however, the fuzzer will get stuck and be unable to exercise new
paths through the code of the target program. This can happen for
a number of reasons, but is most frequently caused by the inability
of the fuzzer’s random mutations to satisfy complex conditions,
introduced by checks in the program, upon input data.

Innovation (Vulnerability Discovery)Human-AutomationLinkOrganizationNon-ExpertsTask CreatorTask SchedulerAFL (Fuzzer)Symbolic Seed SynthesisDrillerDirected Symbolic ExecutionAutomated ProcessingSelectionTest-case DatabaseExpertsAccepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

4.6 Automated Vulnerability Discovery - Drilling
Driller proposed a mitigation for the stalling of the fuzzer due to the
inability to satisfy complex solutions. It uses concolic execution to
trace the paths that the fuzzer finds, identifies conditional checks
that the fuzzer fails to satisfy, and synthesizes inputs to satisfy these
conditions. Driller triggers its operation when the fuzzer gets “stuck”,
and is unable to find further testcases (it detects this by checking
AFL’s progress evaluation heuristics). Once this stall condition is
detected, Driller symbolically traces and attempts to mutate all test
cases that AFL has found into test cases that reach parts of code not
previously seen. These resulting test cases are then synchronized
back into the fuzzer, so that it can explore these newly-reached areas
of code.

By pairing fuzzing with concolic execution, Driller achieves better
results than the naive union of the individual underlying techniques.
However, Driller’s automated approach to symbolic input synthesis
has some drawbacks.

Driller’s synthesis works by diverting a path and forcing it to
satisfy a check that it would have otherwise avoided. There are
several limitations, inherent in Driller, that hamper its effectiveness
in certain situations. These include, but are not limited to:

SMT solver. Driller uses an SMT solver to solve negated path pred-
icates (constraints on the input values to the program that
must be satisfied in order to trigger the path in question) to
synthesize inputs that diverge from the original execution.
However, depending on the complexity of the path predi-
cates involved, the SMT solving process may not terminate.
While this represents a significant challenge for Driller,
the complexity of these predicates might not translate to
the complexity of interaction with the software. If this is
the case, a human assistant might be able to controllably
divert the path taken through the program, even when the
constraint solver cannot.

Inflexible path predicates. Depending on implementation details
in the program, earlier path predicates might prevent the
deviation of later path predicates. Such predicates are fre-
quently created by certain input transformation procedures.
For example, string-to-int translation (such as the atoi
function) takes different conditional branches, based on
the values in the input string, while converting an input
string to an integer. These conditional branches create path
predicates. Later, the program might perform some action
based on the value of this integer. When Driller attempts
to divert this decision to take a different action, the earlier
path predicates on the input string prevent this diversion.

Humans, of course, do not share this inflexible way of

reasoning about path predicates.

Semantic transitions versus control flow transitions. Driller can-
not understand the program semantically, and simply at-
tempts to deviate the control flow of the program. A human,
on the other hand, can identify much more intricate seman-
tic deviations (for example, winning, as opposed to losing,
a game), allowing for the triggering of whole new areas of
code to deal with these new semantic settings.

These limitations conspire to erode Driller’s ability to produce
deviating inputs in many cases. In the next section, we will discuss
how these limitations can be worked around with human assistance.

5 HUMAN ASSISTANCE
As we discuss in the previous section, automated input synthesis
techniques suffer from limitations that cause them to eventually get
stuck in the exploration of a program. Even Driller, which leverages
the power of symbolic execution to divert testcases, is only a partial
solution. This is because, while Driller can make major changes to
the input testcase it analyzes, it can only (by design and fundamental
limitation) achieve only minor deviations.

On the other hand, a human can leverage intuition and a semantic
understanding of the target program to achieve very large deviations,
potentially allowing further analyses to continue to make progress.
In this paper, we explore the integration of human assistance into
a Cyber Reasoning System as Innovation agents, keeping the Or-
ganizational and Selectional agents fully automated. We focus on
the vulnerability discovery stage of the analysis and explore ways to
integrate human effort to improve analysis efficiency.

Human assistance takes place over an interface (the Hardware
Abstraction Link, or HAL) which will be described later this section.
To maximize the effectiveness of this effort, HaCRS carries out a
number of analyses that enhance the data it is able to expose to
the humans. In this section, we describe how human assistants are
selected, the interface over which HaCRS and humans communicate,
and how the resulting data is used to enhance the vulnerability
detection ability of HaCRS.

5.1 Assistant Expertise
The style of human assistance differs according to the assistant’s
expertise level. For example, while HaCRS could reasonably ask an
expert human to analyze a control flow graph and identify potential
paths through it, a non-expert would be flabbergasted by such a
request. The information presented, and the interfaces which are
used, must be adapted to the chosen assistant’s level of expertise.

Since expert humans (i.e., binary analysts) are rare and expensive,
the integration of assistance from non-expert humans (i.e., an aver-
age internet citizen) is of particular interest. While they do not scale
to the extent of automated processes, non-expert humans scale con-
siderably easier than experts, due to their higher availability. When
more knowledge is required, semi-experts (i.e., undergraduates in
Computer Science) can be leveraged more readily than experts. Thus,
in this paper, we focus mainly on techniques to integrate non-expert
assistance, with a detour into semi-expert assistants for completion.
Over the decades that humans have been interacting with soft-
ware, the skill of performing such interaction has become gradually
instilled in the human population. As such, even non-experts are
well-trained to understand and drive computer software. Thus, we
can tailor HAL to non-experts by sticking to concepts that they can
grasp and avoiding complex program analysis concepts, as shown in
Table 1. For example, rather than ”triggering transitions”, we used
the term “triggering functionality”, which requires less technical
knowledge to understand. Additionally, we expose non-experts only
to the input and output log associated with prior interactions with

6

Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

Concept

Symbolic Equations
Control-Flow Graph
Execution Path
I/O (Text)
Semantic Meaning

Computer
✓
✓
✓
✓

Expert Non-Expert

✓
✓
✓
✓

✓
✓

Table 1: Program analysis concepts, as they are easily understood by au-
tomated techniques, expert humans, and non-expert humans. To be un-
derstandable to non-experts, the Human-Automation Link must avoid
complex program analysis topics.

the programs that the HaCRS is trying to analyze, and avoid any use
of program analysis terms in task descriptions.

5.2 Human-assisted Input Generation
HaCRS uses human assistance to break through the “semantic barri-
ers” that limit the effectiveness of automated analyses described in
Sections 4.5 and 4.6. It gives its human assistants a goal: generate an
input testcase that executes some amount of code in the target pro-
gram that has not been reached by previously-known testcases (i.e.,
those previously found by automated analyses or other humans).

Human assistants interact with the target program to generate
testcases, and these testcases are synchronized throughout HaCRS’
components.

Human-to-automation. Human-produced testcases are synchro-
nized to the automated program exploration components,
which proceed to mutate them in an attempt to trigger new
functionality.

Human-to-human. Humans can view and modify the testcases
produced by other human assistants. This enables a collec-
tive effort of the understanding and leveraging of program
semantics toward a higher code coverage. HaCRS
Automation-to-human. The resulting automation-mutated testcases
can then be shown to the human assistants (we term such
a testcase an “example testcase”), who can review them,
understand possible further improvements and changes that
can be made, and relay those changes back to the automa-
tion by producing human-modified testcases.

Testcase conversion. The synchronization of testcases from auto-
mated components to a human assistant poses a challenge: automated
systems, driven by either random input generation or input synthesis
via constraint solving, have no guarantee to produce printable char-
acters when the target program does not require it. Non-printable
testcases look like gibberish when shown to a human, which hinders
the human’s ability to reason semantically about what actions the
testcase is causing the target program to take.

To address this issue, we use the existing afl-tmin utility
shipped with AFL [31]. This utility is a testcase minimizer. It takes an
input testcase and uses lightweight dynamic techniques to a) remove
unnecessary input characters and b) convert as many characters
as possible to be printable, without changing the code coverage
achieved by the input. In practice, it achieves very good results on
programs with a text interface.

7

5.3 Automation-assisted Human Assistance
Simply presenting previously-discovered testcases to human assis-
tants enables an improvement over a base-case Cyber Reasoning
System (we show this in Section 6). However, since the communica-
tion between HaCRS and humans takes place over a well-defined
interface, HaCRS can provide extra information and capabilities to
enhance the humans’ abilities to complete the assistance task.

Interaction assistance. One such capability provided by HaCRS
is the automated re-formatting of input data. HaCRS traces each
program testcase to detect if input data must be provided in a specific
format. It achieves this by leveraging existing techniques in protocol
recovery [3, 4, 17]. Depending on configuration (and expertise of
human assistants), this information can either be presented to the
human assistants or utilized automatically to mutate human-created
inputs into a format understood by the application.

In our prototype, we mainly utilize these techniques to automati-
cally recover non-standard field delimiters used by the binaries in
our dataset, but they can also be used to support information packing
protocols, such as ASN1.

High-level guidance. Having enabled human interaction for bi-
naries with complex input data specifications, HaCRS turns to the
question of maximizing the ability of its humans to understand how
to interact with the target program. It does this by identifying and
categorizing constant string references in the binary.

HaCRS identifies static string references by analyzing its CFG,
and performs a static data flow analysis to categorizes these into
strings produced as output by the program and strings compared
against user input into the program. HaCRS identifies output strings
by detecting when they are passed into common output functions
(such as puts and printf). Input strings are considered to be
anything that is passed to a string comparison function. In the case
of statically-linked binaries, HaCRS can leverage the function iden-
tification functionality built into the Mechanical Phish, which de-
tects common functions in programs using pre-defined dynamic
test-cases [23]).

HaCRS provides a list of potential output strings in the target
program to help its human assistants, relaying which of these strings
have not yet been triggered (i.e., caused to be output by the program)
by other testcases. These can provide useful semantic information
regarding the untapped functionality of the target program.

While HaCRS focuses on text-based software, it is important
to keep in mind that analogous information can be recovered for
software with a graphical user interface. For example, a similar
analysis can identify GUI widgets, render them, and display them as
potential directions of exploration for human assistants.

Symbolic tokens. First, HaCRS creates suggestions for human
assistants for ways that testcases might be modified to divert pro-
gram flow. This is done through a process of symbolic tokenization.
HaCRS symbolically traces the target program in the context of
each testcase to recover constraints placed on the input by the target
program. It analyzes these constraints to identify contiguous bytes
on which the constraints are similar (in terms of the number of
constraint expressions and the types of arithmetic and boolean opera-
tions the constraint expressions are composed of). These contiguous
bytes represent tokens processed and reasoned about by the binary.

Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

HaCRS then identifies alternate values for each symbolic token. It
rewinds its symbolic trace to the address at which the first constraint
of the token was introduced, and performs a symbolic from that
point to retrieve other potential values. The symbolic exploration
runs until a timeout (we found 30 seconds to be a reasonable timeout
in our experiments). At the end of the timeout, the constraints of the
various resulting paths are solved to alternate values for the token.
These values are further refined by matching them against the input
strings retrieved previously, and HaCRS produces two different sets
of suggestions to its assistants: “educated guesses”, which are the
input strings that are prefix-matched by the recovered alternatives
and “brute-force guesses”, which are the raw alternatives themselves.
Note that, while the concept of generating alternatives for input is
shared with Driller, the goal is different. Driller generates alternative
testcases to drive execution down different paths. However, the
alternatives generated by this method are meant to be learned by
humans, understood, and reasoned about to produce new inputs
through human intuition and previously-learned experience.

Input type annotation. Programs process different inputs differ-
ently, and HaCRS exposes this to its assistants by highlighting input
bytes that are constrained by similar constraints (as with the sym-
bolic token analysis, we use constraint count and operation types to
compute constraint similarity). Input bytes highlighted with similar
colors in the input testcases will be bytes that have been treated
similarly to each other by the program, and may represent similar
type of data. Most importantly, this differentiates string input (such
as a command) against numeric input (which is passed to functions
such as atoi, which impose specific constraints on the data).

5.4 Human-Automation Link
The interface between the HaCRS and its human assistants must be
designed in such a way as to be understandable by both parties. To do
this, we created a Human-Automation Link (HAL) that exposes, to
the humans, only the concepts of program analysis that non-experts
might be familiar with. For the curious reader, we reproduce a mock-
up of the HAL interface in Figure 3.

The HAL interface in Figure 3 consists of the following elements:

Program description. When a description of the target program is
available, it can aid assistants in interacting with it. In the
case of Cyber Grand Challenge binaries, this description in-
cludes a very brief (usually four to five sentences) summary
of the program’s purpose, as written by the program authors.
In a real-world setting, human assistants can be provided
with the technical manual for the piece of software being
tested.

Tasklet instructions. The HaCRS provides human-readable instruc-
tions, which are presented to the assistant alongside each
tasklet.

Example interactions. The HaCRS provides logs of previous in-
teractions with the software, in the form of input and output
data. For the text-based software of DECREE OS, to help
assistants understand what data was originated from them
(program input) and what came from the program (program
output), the input and output are displayed in different col-
ors. A version of HaCRS for software with a graphical user

interface could instead have a video record of the interac-
tion, but this is not supported by our prototype.
CRS-Generated Suggestions. To help assistants understand how
to deviate from a test case, they can invoke the deviation
annotation interface. This interface displays data recovered
through the automated analyses described in Section 5.3 to
present the assistant with a better idea of how to make a
program behave differently than in the example testcase.

Interaction terminal. To facilitate the interaction between human
assistants and the target program, a terminal is presented
to interact with the software. Again, to help assistants un-
derstand differentiate user input from program output, the
input and output are displayed in different colors.
Tasklet goal and feedback. Any human-facing task must have an
understandable end goal to avoid confusion on the part of
the assistants. HaCRS requires its human assistants to trig-
ger previously-unseen functionality in the target programs.
To this end, it provides feedback to the assistant regarding
the amount of previously-unseen control flow transitions
that the assistant was able to trigger.

Along with this, it provides a display of untriggered
output strings, as described in Section 5.3. With their hu-
man ability to reason about semantic information, assistants
can leverage the bounty strings to better target untriggered
functionality in the program.

Each tasklet also has a timeout and an abort button: if the assistant
is unable to complete the tasklet before a timeout, or presses the
abort button, the tasklet is terminated. This acts as a guard against the
situation when the tasklet is not actually completable (for example,
if the remaining untriggered functionality is dead code).

In the next section, we will explore the implication of human
assistance by evaluating the performance of HaCRS against the
performance of the unaided Mechanical Phish.

6 EVALUATION
In this section, we evaluate the impact produced by our integration of
non-expert human effort into the Cyber Reasoning System paradigm.
We measure the result of this as a whole, in terms of the overall
number of vulnerabilities identified in our dataset, but also explore
certain low-level details of the system.

6.1 Dataset
As previously mentioned, Mechanical Phish was designed to op-
erate on binaries for DECREE, the operating system designed for
the DARPA Cyber Grand Challenge. A total of 250 binaries were
produced by DARPA for the Cyber Grand Challenge2. These bi-
naries vary in complexity, but are designed to mimic a wide range
of vulnerabilities and behaviors found in real-world software. Each
Cyber Grand Challenge binary is guaranteed to have at least one
vulnerability, and proof-of-concept exploits, along with high-quality
testcases, are provided for each. This makes it possible to measure,
with some degree of certainty (after all, previously-unknown vul-
nerabilities might also be present), the effectiveness of vulnerability

2DARPA recently funded the creation of a human-readable repository with information
on these applications, hosted at http://www.lungetech.com/cgc-corpus.

8

Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

While this requirement to filter the dataset to binaries designed
for human interaction is limiting, certain approaches do exist to
alleviate it. For example, IARPA funded a multi-year effort, dubbed
STONESOUP [13] that developed a number of approaches to gamify
software. Such approaches can be used to expand the amount of bina-
ries with which humans can assist, but they generally fail to recreate
the valuable semantic hints in software designed for humans. We
leave the integration of such program mutation into our interaction
assistance component as future work.

Even though a protocol might be text only, it might still be hard for
humans to understand. As an example of this, consider PDF, which
is a text-only file format that is designed to be parsed exclusively by
computer programs. To better understand the implications of human
assistance on the binaries in our dataset, we manually categorized
them according to the following qualities:
Technical expertise. We determined whether a program requires
technical expertise to be used. For example, some of the pro-
grams in the dataset are language interpreters or databases,
requiring users to be familiar with such Computer Sci-
ence concepts as programming languages. These programs
would be rated as requiring high technical expertise.

Semantic complexity. We attempted to identify whether actions
taken by the program yield themselves to high-level rea-
soning about the program’s intent. For example, a move
taken in a chess match would have high semantic complex-
ity, whereas an iteration of a compression algorithm would
not. Thus, a chess engine would be ranked as having high
semantic complexity, whereas a compression utility would
not.

CGC binaries are fairly small, and the small size of these binaries
makes them well-suited for such classification. Specifically, because
the binaries tend to be “single-purpose” (i.e., a recipe storage ap-
plication, as opposed to a web browser), most binaries do not have
different modules with different semantic complexity or technical
expertise requirements.

The binaries, by their various classifications, are presented in
Table 2. We expect human assistants to do best on binaries with a
high semantic complexity, and unskilled humans to do best with
binaries requiring a low technical expertise.

6.2 Human Assistants
HaCRS was designed to support different levels of assistant expertise,
from non-experts to experts. We evaluated the impact of both non-
expert and semi-expert assistants.

Non-experts. For the non-experts, We used Amazon’s Mechan-
ical Turk service to dispatch tasklets to humans with no required
Computer Science knowledge [2]. This provided HaCRS with an
API to interact with human intelligence in a scalable way, allowing
it to submit tasklets, as Mechanical Turk Human Intelligence Tasks
(HITs), without concerning itself with human availability.

Because we had finite funds for our experiments, we implemented
a human interaction cache. When the HaCRS would create tasklets
for non-expert human assistance, we would first check the interaction
cache to determine if this human assistance task had already been
requested in by a prior experiment. If it had, and if at least one of
the cached human testcases “solved” the tasklet (in the sense of

Figure 3: A diagram of the HaCRS user interface, showing differ-
ent components for seeding tasklets (all solid-bordered components),
drilling tasklets (dotted-bordered components), and seeking tasklets (d
ashed-bordered components).

detection techniques. As such, they have already been used in the
evaluation of various other scientific work [24, 25, 28].

Our dataset is the subset of DECREE programs that present a
human-usable text protocol or for which the interaction assistance
provided by HaCRS (as discussed in Section 5.3) was able to fa-
cilitate a human-usable text protocol. We selected these by auto-
matically detecting the presence of non-printable characters in the
author-provided testcases (we did not otherwise use these testcases
in the experiments). We filtered binaries in this way because, to our
human assistants, such protocols are understandable, and, therefore,
they allow for manual interaction. Among the CGC binaries, a total
of 85 binaries meet this criteria.

9

Tasklet Instructions-Program Description-Tasklet DirectionsExample Interactions1 2 3 4 5 6 7PAPER> PAPERTIEROCK> SCISSORSYOU LOSEFeedbackScore: 223/1225MINIMUM GOAL MET!Bonuses:- 10 more functions- Output "INVALID"✔ Output "YOU WIN!!!"✔ Output "EASTEREGG!!"TerminalPAPER> 0000EASTER EGG!!!PAPER> SCISSORSYOU WIN!!!CRS-GeneratedSuggestionsEducated Guesses:-ROCK-SCISSORS-LIZARD-SPOCKBrute Force:-~~~!@-0000Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

Semantic
Complexity

High

Technical
Expertise

Low

High

High

Low
Low

Low
High

Binaries

CADET_00001 CADET_00003 CROMU_00001 CROMU_00003 CROMU_00005 CROMU_00017
CROMU_00029 CROMU_00031 CROMU_00037 CROMU_00040 CROMU_00041 CROMU_00044
CROMU_00046 CROMU_00054 CROMU_00065 CROMU_00076 CROMU_00087 EAGLE_00005
KPRCA_00011 KPRCA_00017 KPRCA_00018 KPRCA_00022 KPRCA_00023 KPRCA_00026
KPRCA_00030 KPRCA_00042 KPRCA_00043 KPRCA_00049 KPRCA_00051 KPRCA_00052
KPRCA_00053 KPRCA_00055 KPRCA_00071 KPRCA_00079 NRFIN_00004
NRFIN_00005+ NRFIN_00065 TNETS_00002 YAN01_00001
CROMU_00002 CROMU_00008 CROMU_00009 CROMU_00010 CROMU_00011 CROMU_00014
CROMU_00015 CROMU_00021 CROMU_00022 CROMU_00023 CROMU_00035 CROMU_00042
CROMU_00048 CROMU_00051 CROMU_00071 CROMU_00083 CROMU_00096 CROMU_00098
KPRCA_00007 KPRCA_00013 KPRCA_00021 KPRCA_00028 KPRCA_00031 KPRCA_00036
KPRCA_00041 KPRCA_00045 KPRCA_00054 KPRCA_00068 LUNGE_00002
NRFIN_00001+ NRFIN_00009+ NRFIN_00054 NRFIN_00055 YAN01_00002
YAN01_00007 YAN01_00011
NRFIN_00008* NRFIN_00064 NRFIN_00069+ YAN01_00015
CROMU_00025* CROMU_00030* CROMU_00034* KPRCA_00010* KPRCA_00064*
NRFIN_00071

Table 2: The binaries in our dataset, grouped by semantic complexity of their operation and the required technical (Computer Science) expertise.
These binaries were filtered for receiving mostly printable input, but some of them (marked with *) decoded that into raw binary input, making
them suboptimal for human interaction. Others (marked with +) received their inputs in protocols which were automatically translated by HaCRS’
interaction assistance layer to be easily human-interactable. We expect humans to do best on binaries with a high semantic complexity, and unskilled
humans to do best with binaries requiring a low technical expertise.

triggering new code), the HaCRS would reuse it instead of paying
for a HIT. We used the human interaction cache whenever we were
running experiments on identical configurations of the Hardware-
Automation Link. This allowed us to re-run some of the experiments
throughout the design and development of the system and remain
within our budget.

In the end, between the different experiments to fully understand
our system, we spent about $2000 on Mechanical Turk HITs, result-
ing in 21268 unique testcases across our experiment. While this is
a large amount for a research lab, it would be trivial spending for a
nation state or large corporation looking to scale out their analyses.

Semi-experts. We recruited five undergraduate Computer Science
students, familiar with programming topics but not with program
analysis, to act as our semi-expert human assistants. These under-
graduates interacted with a random sampling of 23 binaries from our
dataset, generating a total of 115 testcases.

Ethics. As our experiments involve human assistants, we were
careful to ensure that ethical procedures were followed. We worked
with the Institutional Review Board of our institution to evaluate our
testing protocol. The IRB approved our experiments, and we were
careful to follow ethical guidelines throughout our work.

6.3 Human-Automation Link
As we proposed a number of optimizations to the Human-Automation
Link in Section 5.3, it is important to understand whether this actu-
ally enhances the effectiveness of human assistances. To determine
this, we performed two separate experiments in having non-experts
interact with programs in the HAL, with our optimizations in Sec-
tion 5.3 disabled in the first and enabled in the second.

For each binary, we dispatched tasklets to the human assistants
until they were unable to make further progress in code coverage,
given an hour-long timeout. We collated the results by the seman-
tic complexity of the binaries involved, and computed the median
number of testcases at which progress stopped being made.

Our improvements to the HAL allowed our assistants to contribute
a significantly higher amount of testcases than they were previously
able to. For semantically complex binaries, the number of testcases
was roughly double, but for binaries that were not semantically
complex, the improvement was considerably higher, approach a
three-fold increase in the number of successful testcase generations.
On further investigation, this makes sense – analyzing the testcases
generated by the human assistants, we were able to see them quickly
guess how to interact with semantically-complex programs, but
struggle with less complex ones. However, with the improved HAL
interface, they were given extra information that they could leverage
to provide high-quality testcases.

6.4 Comparative Evaluation
HaCRS improves the vulnerability detection process by injecting
human intuition into the Cyber Reasoning System. To understand
how effective this is, we analyze the impact that non-expert and
semi-expert assistance has on CRS effectiveness. To explore these
questions, we ran several different experiment configurations:
Non-expert humans. As a baseline to understand the ability of
humans to generate inputs for binary code, we disabled the
automated components of the Mechanical Phish and relied
solely on human assistants for testcase creation.
Semi-expert and non-expert humans. With the amount of semi-
experts at our disposal, it did not make sense to have them

10

Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

Configuration

Non-expert Humans

All Humans

Unassisted Fuzzing

Symbolic-assisted Fuzzing

Human-assisted Fuzzing

Human-assisted Symbolic-
assisted Fuzzing

Semantic
Complexity

Expertise
Required

Median
Code
Coverage

Median
#AT

Median
#HT

Binaries
Crashed

High
High
Low
Low

High
High
Low
Low

High
High
Low
Low

High
High
Low
Low

High
High
Low
Low

High
High
Low
Low

Low
High
Low
High
Total
Low
High
Low
High
Total
Low
High
Low
High
Total
Low
High
Low
High
Total
Low
High
Low
High
Total
Low
High
Low
High
Total

46.68%
48.83%
48.69%
16.81%
47.19%
46.83%
48.83%
48.69%
17.39%
47.19%
41.82%
43.32%
56.17%
17.46%
42.87%
42.90%
48.85%
56.07%
41.88%
44.91%
49.70%
60.45%
64.03%
17.46%
52.38%
48.98%
59.68%
64.03%
48.52%
53.45%

0
0
0
0
0
0
0
0
0
0
410
526
187
211
361
663
764
156
1500
649
326
472
125
207
308
369
485
121
641
403

137
150
168
297
151
137
150
168
298
151
0
0
0
0
0
0
0
0
0
0
136
126
35
9
84
69
11
46
5
34

0
0
0
0
0
0
1
0
0
1
12
14
1
1
28
14
17
2
3
36
21
24
2
1
48
23
28
2
3
56

Median
Time-to-
Crash
N/A
N/A
N/A
N/A
N/A
N/A
2815
N/A
N/A
2815
807
1278
143
7
897
1302
1426
62
390
1298
1378
1442
48
10
1334
1140
1855
47
584
1301

Table 3: The crashes found and code coverage achieved by different configurations of the automated and human components of HaCRS. The
full HaCRS configuration includes human non-expert, human semi-expert, and automated innovation agents. #AT, and #HT are the numbers of
automation-originated testcases and human-originated testcases, respectively, that were deemed “unique” by the Mechanical Phish’s testcase evalua-
tion criteria.

work alone. As such, we ran an integrated semi- and non-
expert experiment. To understand the impact of expertise,
we added the semi-experts to our assistant pool and reran
the human-only experiment. Testcases produced by non-
experts are presented to semi-experts as examples, and
testcases created by the semi-experts are synchronized into
the system and eventually presented to the non-experts.

Unassisted fuzzing (AFL). This configuration, with both symbolic
and human assistance disabled, achieves a baseline for com-
paring the other experiments to understand the relative gains
in code coverage and crashes.

Symbolic-assisted fuzzing (Driller). This is the reference configu-
ration of the Mechanical Phish: a fuzzer aided by a dynamic
symbolic execution engine, as proposed by Driller. We con-
sider this as the prior state-of-the-art configuration.

Human-assisted fuzzing. In this configuration, Driller is replaced
with our Human-Automation Link. Rather than symboli-
cally tracing fuzzer-generated testcases, we present them to
our human assistants and synchronize their testcases back
into the fuzzer. This configuration, together with the Driller
and AFL configurations, allow us to understand the relative
effectiveness of Drilling versus Human Assistance.
Human-assisted Symbolic-assisted fuzzing. This is the “complete”

configuration of HaCRS, all components, representing the
new state-of-the-art in Cyber Reasoning System.

The results of the experiment are presented in Table 3.

End-to-end system. The most obvious result is the improvement
in the number of vulnerabilities that were identified with the full
HaCRS configuration. By iteratively combining human assistance
and symbolic assistance to its internal fuzzer, the HaCRS was
able to identify an additional twenty bugs in different binaries over

11

Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

symbolically-assisted fuzzing (a whopping 55% improvement) and
twice as much as the base-case fuzzer alone. This result is significant:
non-expert humans, overwhelmingly likely to have no security or
program analysis training, are able to make real contributions toward
the analysis of binary software.

Comparison to Driller. In HaCRS, human assistants take on a
very similar role to Driller: they provide extra inputs that the fuzzer
can leverage to avoid stalling in its exploration of the target program.
Rather than making small control-flow diversions, human assistants
make semantic divergences based on their understanding of the op-
eration of the target program. This is reflected in the results – for
semantically-complex programs, the human assistants significantly
beat out Driller, achieving an improvement of up to 11.6% improve-
ment in coverage. However, for binaries that did not have semantic
complexity but required computing expertise, the human assistants
suffered, being unable to understand the concepts presented by the
program and intuit how to interact with it. This is where the combi-
nation of human and automated analysis shines – Driller picks up the
slack in these binaries, and the combination of human and symbolic
assistance achieves higher code coverage than either alone.

Impact of expertise. Interestingly, the inclusion of semi-experts
in our analysis did not seriously impact the achieved code coverage.
This is an example of the different scale achievable for experts and
semi-experts. While we were able to get just over 300 Mechanical
Turk workers to assist HaCRS, we were only able to recruit five
undergraduate students, and they could not make a strong impact on
the results (in fact, because the results are presented in aggregate,
there was almost no impact on the median measurements). However,
they did have localized success: due to their ability to intelligently
interact with more complex binaries, the experts were able to iden-
tify a bug in one of the applications without any human assistance.
Specifically, they triggered a bug in CROMU_00021, which imple-
ments a simple variable storage and arithmetic engine, but contains
an exploitable bug when a variable with a blank name is created.

6.5 Case Studies
In the course of our experiments, our human assistants achieved
some results that are interesting to explore more in-depth. This was
despite the fact that the human assistants were completely unskilled
in program analysis, and were recruited with absolutely no training.
Here, we delve deeper into these bugs, and discuss why human effort
helped with these specific binaries.

Coverage case study: CROMU_00008. This binary implements a
database with a SQL-inspired interaction interface. Proper use of this
binary required understanding the concepts of storing and retrieving
data records. Interestingly, our human assistants quickly developed
an understanding for how to do this, taking the suggested keywords
from the CRS suggestions and combining them into expressions the
program understood. They achieved a code coverage of 55.5%, com-
pared with 12.1% for the automated analyses. Manual investigation
into the delta between automation and human assistance revealed
that, as expected, the humans produced inputs that were meaningful
for the program, while the symbolic seed synthesis attempted to op-
timize for code coverage, triggering many meaningless states (such

12

as incorrect commands) without ever getting to the actual operation
of the program.

Coverage case study: KPRCA_00052. This binary is surprisingly
complicated: the assistant is presented with a pizza order menu sys-
tem. To properly navigate this system, the assistant must understand
how a pizza is made: the crust is chosen first, then the cheese, then
the toppings. This makes it very hard for the automated system to
explore this binary and, in fact, our automation achieved a 19%
code coverage over the course of the experiment, as opposed to 52%
achieved by human assistants.

Vulnerability-detection case study: KPRCA_00043. This binary
includes a lyrical storage engine that disallows certain words from
being provided as lyrics. Furthermore, these words are checked by a
bloom filter. Because this filter is implemented as a hash map, the
resulting symbolic memory references make it difficult for symbolic
execution to produce these words. The vulnerability consists of
an overflow in the lyrics buffer if enough words are entered that
trigger the bloom filter but then pass the secondary check against
the blacklist. For example, enough misspellings of the blacklisted
words can overflow the filter.

Interestingly, the binary includes a semantic hint – a depress-
ing message is printed when the program starts. We observed that
our assistants quickly picked up on this hint and produced inputs
containing blacklisted words, whereas the symbolic seed synthesis
produced gibberish and failed to trigger the blacklist. While both
approaches actually had a similar level of code coverage, we hypoth-
esized that the human-assisted inputs would be a better seed set for
a fuzzer to find the vulnerability. We verified this by running AFL
for an hour with the human-provided seeds, and for an hour with
the automation-created seeds. As expected, the former triggered the
vulnerability, while the latter did not.

Vulnerability-detection case study: NRFIN_00055. This binary
implements a complex mathematical calculator. In this case, the
assistants were given no guidance – simply an input prompt. Over
time, they figured out that mathematical expressions led to the out-
put of mathematical solutions, and their apparent knowledge of
mathematics came into play. Assistants submitted a number of equa-
tions, exploring different operations in semantically-valid inputs (i.e.,
proper use of parenthesis and so forth). By comparison, the symbolic
seed synthesis became overwhelmed by the number of paths in the
parsing engine, resulting in an inability to produce reasonable inputs.
Again, we suspected that the seeds provided by humans would be
more useful to a fuzzer, and tested this by an hour-long execution
of AFL. As with the previous case, AFL was able to mutate the
human-produced testcases into a crashing input by introducing a
modifier symbol missed by the assistants into one of their testcases,
resulting in a type confusion. The automatically-generated testcases
were less useful, and no crash was found from them within an hour.

7 CONCLUSION
The use of principled human-assistance in Cyber Reasoning Systems
constitutes a paradigm shift in our view of how binary analysis is
done. Instead of the dichotomy between human-led, semi-automated
systems (HCH, as discussed in Section 2) and fully automated sys-
tems (CCC), we propose a C(H|C)C system, where computers, which

Accepted submission #873 to ACM CCS 2017 (PREPRINT, NOT FINAL)

scale beyond human ability, make organizational calls and humans,
whose intuition has not yet been replicated, assist when able. This
system can utilize the insight of non-expert humans, who are more
abundant than expert humans and thus scale better. In the absense of
these humans, these systems are able to operate fully autonomously,
just at a lower effectiveness.

In this report, we have taken a first look at how non-experts im-
pact the automated vulnerability discovery pipeline. The results are
significant: humans, with no security training, were able to seriously
improve the bug detection rate of a state-of-the-art vulnerability
analysis engine. Further exploration is warranted. For example, hu-
mans can confirm or repudiate results of static analysis, combine
behavior observed in different testcases into one, and help verify
automatically-generated patches. All of this is challenging or simply
infeasible with modern techniques, but the use of human assistance
can greatly augment Cyber Reasoning Systems with these capabili-
ties regardless.

REFERENCES
[1] Thanassis Avgerinos, Sang Kil Cha, Alexandre Rebert, Edward J Schwartz, Mav-
erick Woo, and David Brumley. 2014. Automatic exploit generation. Commun.
ACM 57, 2 (2014), 74–84.

[2] Jeff Barr and Luis Felipe Cabrera. 2006. AI gets a brain. Queue 4, 4 (2006), 24.
[3] Juan Caballero, Pongsin Poosankam, Christian Kreibich, and Dawn Song. 2009.
Dispatcher: Enabling active botnet infiltration using automatic protocol reverse-
engineering. In Proceedings of the 16th ACM conference on Computer and com-
munications security. ACM, 621–634.

[4] Juan Caballero, Heng Yin, Zhenkai Liang, and Dawn Song. 2007. Polyglot:
Automatic extraction of protocol message format using dynamic binary analysis.
In Proceedings of the 14th ACM conference on Computer and communications
security. ACM, 317–329.

[5] Rondo E Cameron. 1993. A concise economic history of the world: from Pale-

olithic times to the present. Oxford University Press, USA.

[6] Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. 2012.
Unleashing mayhem on binary code. In Security and Privacy (SP), 2012 IEEE
Symposium on. IEEE, 380–394.

[7] DARPA. CFE File Archive. (????). http://repo.cybergrandchallenge.com/CFE/.
[8] Ana Rey de Castro. 2013. â ˘AIJThe Dissappearing Spoon and other true tales

In Proceedings of the ACM SIGOPS 22nd symposium on Operating systems
principles. ACM, 87–102.

[20] Daniel Kroening Sean Heelan. 2009. Automatic Generation of Control Flow
Hijacking Exploits for Software Vulnerabilities. Ph.D. Dissertation. University of
Oxford computing laboratory.

[21] Dafna Shahaf and Eyal Amir. 2007. Towards a Theory of AI Completeness.. In
AAAI Spring Symposium: Logical Formalizations of Commonsense Reasoning.
150–155.

[22] Shellphish. Shellphish - The Cyber Grand Challenge. (????). http://shellphish.net/

cgc.

[23] Shellphish. 2017. Cyber Grand Shellphish. (January 2017). http://phrack.org/

papers/cybergrandshellphish.html.

[24] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Andrew Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel,
et al. 2016. SOK:(State of) The Art of War: Offensive Techniques in Binary
Analysis. In Security and Privacy (SP), 2016 IEEE Symposium on. IEEE, 138–
157.

[25] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
Proceedings of the Network and Distributed System Security Symposium. https:
//doi.org/10.14722/ndss.2016.23368

[26] The Verge. Google rebuilt a core part of Android to kill the Stagefright vulnera-
bility for good. (????). http://www.theverge.com/2016/9/6/12816386/android-
nougat-stagefright-security-update-mediaserver.

[27] Mike Walker. 2016.

The DARPA Cyber Grand Challenge.

https://

www.cybergrandchallenge.com/. (August 2016).

[28] Ruoyu Wang, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.

2017. Ramblr: Making Reassembly Great Again.. In NDSS.

[29] Shuai Wang, Pei Wang, and Dinghao Wu. 2015. Reassembleable Disassembling..

In USENIX Security. 627–642.

[30] Kyle W Willett, Chris J Lintott, Steven P Bamford, Karen L Masters, Brooke D
Simmons, Kevin RV Casteels, Edward M Edmondson, Lucy F Fortson, Sugata
Kaviraj, William C Keel, et al. 2013. Galaxy Zoo 2: detailed morphological
classifications for 304 122 galaxies from the Sloan Digital Sky Survey. Monthly
Notices of the Royal Astronomical Society (2013), stt1458.

[31] Michal Zalewski. American Fuzzy Lop. (????). http://lcamtuf.coredump.cx/afl/.

[9] Joshua Drake.

from the periodic tableâ ˘A˙I, Sam Kean. Revista de Química 26, 1-2 (2013), 45.
Stagefright - Blackhat 2015 Slides.
//www.blackhat.com/docs/us-15/materials/us-15-Drake-Stagefright-Scary-
Code-In-The-Heart-Of-Android.pdf.

(????).

https:

[10] Christopher B Eiben, Justin B Siegel, Jacob B Bale, Seth Cooper, Firas Khatib,
Betty W Shen, Barry L Stoddard, Zoran Popovic, and David Baker. 2012. In-
creased Diels-Alderase activity through backbone remodeling guided by Foldit
players. Nature biotechnology 30, 2 (2012), 190–192.

[11] Patrice Godefroid, Michael Y Levin, David A Molnar, et al. 2008. Automated

Whitebox Fuzz Testing.. In NDSS, Vol. 8. 151–166.

[12] Shih-Kun Huang, Min-Hsiang Huang, Po-Yen Huang, Chung-Wei Lai, Han-Lin
Lu, and Wai-Meng Leong. 2012. Crax: Software crash analysis for automatic
exploit generation by modeling attacks as symbolic continuations. In Software
Security and Reliability (SERE), 2012 IEEE Sixth International Conference on.
IEEE, 78–87.
IARPA. STONESOUP Program. (????). https://www.iarpa.gov/index.php/
research-programs.

[13]

[14] Peach Inc. Peach Fuzzer: Discover unknown vulnerabilities.

(????).

http:

//peachfuzzer.com.

[15] Alexander Kosoruko. Social classification structures. optimal decision making in

an organization. (????).

[16] Alex Kosorukoff. 2001. Human based genetic algorithm. In Systems, Man, and
Cybernetics, 2001 IEEE International Conference on, Vol. 5. IEEE, 3464–3469.
[17] Zhiqiang Lin, Xuxian Jiang, Dongyan Xu, and Xiangyu Zhang. 2008. Auto-
matic Protocol Format Reverse Engineering through Context-Aware Monitored
Execution.. In NDSS, Vol. 8. 1–15.

[18] Aravind Machiry, Rohan Tahiliani, and Mayur Naik. 2013. Dynodroid: An input
generation system for android apps. In Proceedings of the 2013 9th Joint Meeting
on Foundations of Software Engineering. ACM, 224–234.

[19] Jeff H Perkins, Sunghun Kim, Sam Larsen, Saman Amarasinghe, Jonathan
Bachrach, Michael Carbin, Carlos Pacheco, Frank Sherwood, Stelios Sidiroglou,
Greg Sullivan, et al. 2009. Automatically patching errors in deployed software.

13

