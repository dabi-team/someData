Compositional
Cyber-Physical Systems
Theory

georgios bakirtzis

A dissertation submitted in partial fulfillment of the requirements

for the degree of Doctor of Philosophy at the University of Virginia.

To Charon for the one obol

Pr√©cis

A major impedance to engineering safe and secure cyber-physical systems is the
lack of formal relationships between different types of models necessary for de-
sign. These various models are necessary because of the coupled physical and
computational dynamics present in cyber-physical systems as well as the different
properties system designers want to assure about a system. Each of the individual
models has a set of rules describing what operations are allowed and which are
not, including how to compose elements together in a way that is correct. These
can mathematically be seen as algebras. However, the algebras in the engineering
of correct and complete requirements, the specification and validation of dynami-
cal behavior, and the identification of software and hardware architectures to carry
out the necessary functions are distinct and can potentially lead to designing-in
hazardous behavior in safety critical cyber-physical systems.

This dissertation builds a compositional cyber-physical systems theory to develop
concrete semantics relating the above diverse views necessary for safety and se-
curity assurance. In this sense, composition can take two forms. The first is com-
posing larger models from smaller ones within each individual formalism of re-
quirements, behaviors, and architectures which can be thought of as horizontal
composition‚Äîa problem which is largely solved. The second and main contribu-
tion of this theory is vertical composition, meaning relating or otherwise provid-
ing verified composition across requirement, behavioral, and architecture models
and their associated algebras. In this dissertation, we show that one possible solu-

ii

tion to vertical composition is to use tools from category theory. Category theory
is a natural candidate for making both horizontal and vertical composition for-
mally explicit because it can relate, compare, and/or unify different algebras.

Ultimately, category theory reframes the problem of abstraction, either in the
management of mathematical structures or system models by positioning a prob-
lem in its most natural domain. Category theory does not model the internal
structure of the objects it acts upon. Instead, a categorical formalism perceives
an object through its relationships with other objects and not by what the object
is individually. Indeed, in this context we focus on abstraction, which we see as
determining only what is essential in each layer of a given model. This allows us
to talk about how things are related instead of focusing on how things are. This
mindset as applied to systems theory gives rise to a circumspection of the system
where we do not examine a system by its individual elements but by looking at the
compositional structure of the system, which includes both the individual con-
stituents and their interconnections. This is all to say that through compositional
cyber-physical systems theory we can give concrete meaning to abstraction and
refinement in cyber-physical system models, which can assist with the specifica-
tion (and eventual validation) of increasingly complex systems.

Using this relational understanding of modeling we formalize categorically behav-
ior and architecture using the systems as algebras framework, where boxes are
subsystems and wires are connections between subsystems. This is a two step pro-
cess. First we define the interface of each box as well as the way in which the boxes
ought to be interconnected to compose the total system (chapter 2). Second, we
assume a behavioral formalism for each box that is congruent with the behavior of
other boxes based on the way they are interfaced and connected (chapter 3). We
apply this framework to safety through the means of contracts (chapter 4) and to
security through the means of tests and actions (chapter 5). Finally, we show how
these different algebras and categorical structures can be used to mathematically
implement verified composition (chapter 6).

iii

Ithaka gave you the marvelous journey.
Without her you wouldn‚Äôt have set out.
She has nothing left to give you now.

‚Äî C. P. Cavafy

Acknowledgments

Some say that a doctorate is a Herculean task. They are unequivocally wrong. It
is an Odyssean journey. A postmortem calculation reveals that there were many
challenges, similar to the Scylla and Charybdis and the Sirens. Instead of some
demigod power I possess, it was my company that helped me overcome those,
often by sacrificing something of themselves.

I cannot but start with my grandfather and physics professor, Anastasios. While
I was struggling with visualizing mathematics in my formative years, he adjusted
his teaching style to the laboratory, which was the only way that I could learn at
the time. He understood that mathematics is not the only way and made signifi-
cant effort to fix my intuition with wires, tubes, pendulums, and other such phys-
ical devices we could make and discuss in his basement. He spent an enormous
amount of time indulging an inept physical investigator, never once assuming I
should have known something or that I was too far behind to understand some
complicated physical reality.

I have to equally start with my other grandfather, Giorgos. I spent a lot of time
working alongside him at our family business. It was from him that I built my
work ethic, which has supported me through thick and thin almost like muscle
memory. It was there that I learned how to actually speak to people and felt the
sense of community the most.

They are both the reason I am a scholar.

v

My mother, Olga, gave me the opportunity to study in a different country far away
from home and equipped me with the belief that I could achieve my goals as long
as I truly wanted them. My father, Dimitris, followed my academic journey closely
and has often been the reminder that a person ought to have other interests and
when those interests are genuine, they ought to give some time from work to ex-
plore them. My sister, Evi, has been a constant emotional support, a grounding
presence, and the person that pulled me out and showed me the diverse reality
of experience outside of academia when I most needed it. My brother, Anasta-
sios, took the role of the practitioner and challenged me to ground my theoretical
results to the needs of my field. My aunt, Vennie, and uncle, Giorgos, gave me
a home in the New World and took me in as their own child. My aunt and god-
mother, Eleni, taught me real freedom from within. My grandmothers, Voula and
Rita, have always been there for support, interesting discussion, and lots of food.

Besides family, I have been greatly assisted by a plethora of friends. They are the
ones with which I have raised my wine glass and celebrated in plenty of good times.
Dimitris acts as my complaint box. Garrett is my pessimistic echo chamber. Tara
is my precious gemstone. Beck takes me to nature in earnest. Kayla shares my
love for wine. Emma was present for a while. Angelica tells it to me how it is.

In academia, I have to thank Carl Elks, who took a risk with me as I started gradu-
ate school. Then, peacefully giving the baton to Cody Fleming, who allowed me
all the freedom in the world to drink from the unending tank of knowledge by
removing all noise. David Evans discussed extensively my work and gave me di-
rection by asking all the right questions. This dissertation wouldn‚Äôt have been pos-
sible without my collaborators Fabrizio Genovese and Christina Vasilakopoulou.
David Spivak was always available to explain complicated mathematics when I
was lost. Edward Lee gave me advice when I needed it the most and he is part of
the reason I can continue being a scholar after this dissertation.

Most of all this journey was sustained by the influence of the Poet. Those who
give their soul for the rest of us to breathe freely within life‚Äôs continuous struggle.

vi

Contents

Pr√©cis ‚Ä¢ ii

0 DON‚ÄôT PANIC ‚Ä¢ 1

1 Prolegomena ‚Ä¢ 5

1.1 Cyber-physical systems pose new challenges ‚Ä¢ 5
1.2 Assurance is about models, not systems ‚Ä¢ 10
1.3 Cybersecurity is fundamental to safe behavior ‚Ä¢ 14
1.4 Compositionality is subtle ‚Ä¢ 17
1.5 Hypothesis ‚Ä¢ 21

2 Category theory for the mathematical engineer ‚Ä¢ 26
2.1 Categories relate different concepts ‚Ä¢ 26
2.2 Wiring diagrams are an algebraic graphical language ‚Ä¢ 35

3 Compositional systems modeling ‚Ä¢ 44

3.1 Modeling cyber-physical systems compositionally ‚Ä¢ 46
3.2 System behavior via algebras on the category W ‚Ä¢ 48

Linear time-invariant systems ‚Ä¢ 52
Functions (as a non-example) ‚Ä¢ 53

3.2.1 Moore machines ‚Ä¢ 49
3.2.2
3.2.3
3.2.4 Compositional state-space models ‚Ä¢ 54
System architecture via hierarchical decomposition ‚Ä¢ 60

3.3

vii

4 The algebra of safety contracts ‚Ä¢ 66
Static contracts ‚Ä¢ 66
Independent contracts ‚Ä¢ 70

4.1
4.2
4.3 Relation to assume-guarantee contracts ‚Ä¢ 71
4.4 Time in compositional systems modeling ‚Ä¢ 78

5 The algebra of security tests ‚Ä¢ 86

5.1 Attacks change system behavior ‚Ä¢ 88
5.2 The Yoneda lemma formalizes learning and hijacking ‚Ä¢ 90

5.2.1 Attacker learning (exploration) ‚Ä¢ 92
5.2.2 Attacker hijacking (exploitation) ‚Ä¢ 97

5.3 Yoneda reasoning models security posture ‚Ä¢ 99

6 On unification ‚Ä¢ 113

Bibliography ‚Ä¢ 119

Contents

viii

Nomenclature

ùíú, ‚Ñ¨, ùíû, ‚ãØ matrices

C

a generic category

ùê¥, ùêµ, ùê∂, ‚ãØ

objects in a category

id

identity morphism

ùëì or

ùëì
‚àí‚Üí

morphism in a category

ùëî ‚àò ùëì

composition (right to left)

Hom C [‚àí, ‚àí]

homomorphism within the category C

ùëã ‚äó ùëå

monoidal product (left to right)

ùêµ
ùëî
ùê∑

ùê¥
‚Ñé
ùê∂

ùëì

ùëò

‚âÖ

commutative diagram standing for equation ùëî ‚àò ùëì = ùëò ‚àò ‚Ñé

isomorphism

(V, ‚äó, ùêº)

a generic monoidal category

ùêπ or

ùêπ
‚àí‚Üí

functor

ix

ùêπ(ùê¥) or ùêπùê¥

functor application on objects

ùêπ(ùëì) or ùêπùëì

functor application on morphisms

Nat [‚àí, ‚àí]

natural transformation

C/ùê∂

slice category over object ùê∂

Set

Lin

√ó

the category of sets and functions

the category of linear spaces and linear maps

cartesian product of sets (or linear spaces)

Œî ‚à∂ ùëã‚Üíùëã√óùëã

duplication function

Cat

W

WLin

‚Ñ≥

‚Ñí

ùíû

‚Ñ¨

the category of categories and functors

the category of wiring diagrams (with types in Set)

the category of wiring diagrams (with types in Lin)

the algebra of Moore machines; a functor W‚ÜíCat

the algebra of ltis; a functor WLin‚ÜíCat

the algebra of (static) contracts

a generic behavior algebra; could be ‚Ñ≥ or ‚Ñí (among others)

(ùëã, ùëÜ)

system with ùëã ‚àà W and ùëÜ ‚àà ‚Ñ¨(ùëã)

ùêæ‚Ñ¨ùëã

Knowledge database of systems of type ‚Ñ¨(ùëã)

‚Ñ¨(ùëã)

Œò
‚àí‚Üí Set

test on ‚Ñ¨, ùëã

Nomenclature

x

‚ÄúI like the cover,‚Äù he said. ‚ÄúDon‚Äôt Panic.
It‚Äôs the first helpful or intelligible thing
anybody‚Äôs said to me all day.‚Äù

‚Äî Douglas Adams

0 DON‚ÄôT PANIC

Software kills [104].

From 1985 to 1987, the cancer treatment machine Therac-25 produced lethal
doses of radiation, unbeknownst to those operating it [101, 103, 105]. The differ-
ence from previous models? Its safety mechanisms were, for the first time, fully
controlled by software.

In 1991, a floating-point error drifted the internal clock of the U.S. Army‚Äôs Pa-
triot missile defense system by one third of a second, causing it to fail to intercept
an incoming Scud missile in Saudi Arabia [38]. Twenty-eight U.S. soldiers were
killed and roughly 100 others were injured.

In 1996, about 40 seconds into flight the Ariane-5 heavy-life space launch vehi-
cle veered off course, graphically dismantled in air, and exploded [100]. Part of
the software shipped with Ariane-5‚Äôs inertial reference system was reused from
Ariane-4 and were found to be responsible for the accident [131]. Scientists lost a
huge number of instrumentation that was going to be used for experiments that
took years to orchestrate.

In 2005, the Athens affair [140] showed the first glimpses of how hacking com-
puting resources can lead to unexpected at the time significant losses in the ‚Äúreal
world.‚Äù Network switches were infiltrated to redirect and duplicate phone call
signals to the perpetrators shadow phones. Among the tapped phones included
politicians, embassy workers, the head of ministry of defense etc. This was the

1

first attack on specialized equipment that not only we became aware of but was
publicized openly partially to indicate that a changing world was coming.

In 2010, Stuxnet caused the destruction of centrifuges for separating nuclear ma-
terial, crippling the Iranian nuclear program [92]. A potential future where secu-
rity could significantly violate safety was now in sight.

In 2015, CrashOverride caused a blackout in Ukraine [151]. In Kiev‚Äîthe capital
of Ukraine‚Äî700,000 people had no electricity in freezing temperatures.

In 2017, Triton was found to have taken control of the safety instrumentation sys-
tems of a petrochemical plant in Saudi Arabia [63]. A first! Malware with the sole
purpose of causing accidents.

In 2018 and 2019, two Boeing 737 max planes crashed due to a combination of
sensor, software, and design problems that caused the plane to repeatedly push
its nose downward in response to manual input from the pilot [164]. More than
300 people died.

Unfortunately, these accidents are not isolated and they are bound to increase
as we rely on software to control physical systems. The main takeaway from the
above examples is that introducing software means also introducing assumptions
that could be erroneous. If we draw an analogy, software does not fail because it
is in some sense the blueprint rather than the building. It is our specification and
mental models that program in hazardous behavior. This dissertation asserts that
part of improving the status quo in specification and validation can be assisted
with the use of models equipped with a formal theory of composition.

To design safe and secure systems engineers use expertise, intuition, and inertia
to decide how different analyses factor into higher-level, harder questions about
safety, security, and resiliency. However, the deciding factors that bring those
different analyses together is ad-hoc and in practice informal and that current
practice of, for example, using requirements documents to design safety critical
cyber-physical systems is insufficient and can lead to disastrous results.

DON‚ÄôT PANIC

2

It is recognized today that to manage and formalize that the various forms of ex-
pertise required to engineer cyber physical systems, it is imperative to use models
in addition to streamlining and tracing results from varied analyses methods. To
make this trace explicit we can formalize (some of ) that expertise by reconstruct-
ing existing workflows and best practices in compositional terms.

This agrees with the intuition of how we put systems together. Kalman [168] broke
it down to two fundamental elements.

1.

2.

Getting the physics right.

The rest is mathematics.1

This can be seen as the behavioral approach to systems theory, which was later
formalized by Willems [168]. However, the behavioral approach by itself is incom-
plete to develop a general theory of cyber-physical systems modeling. The motiva-
tion and main contribution of this dissertation is a compositional cyber-physical
system theory that, in addition to the behavioral approach to systems theory, is
capable of decomposing to candidate architectures of software and hardware and
an ability to restrict behavior in both behavior and architecture by formally repre-
senting requirements as contracts. Importantly, it addresses the above issues by
producing traceable models, which also makes them interoperable.

It is very unlikely we will figure out how to make systems 100 percent safe and
secure 100 percent of the time, but modeling practices are among the most effec-
tive tools we have. Developing further modeling capabilities through the use of
compositional methods, we can unlock software‚Äôs vast possibilities with greater
confidence that our systems will not cause harm.

1 The introduction of software does not really require an augmentation to these principles be-
cause software can be represented as a logical system and specified using graph-theoretic terms.

DON‚ÄôT PANIC

3

The sciences do not try to explain,
they hardly even try to interpret,
they mainly make models.

‚Äî John von Neumann

1

Prolegomena

Cyber-physical systems theory is not yet a science. The relationship between fun-
damental concepts has not been solidified, particularly across model domains.
This is not surprising, because engineers work differently than scientists: while
scientists build models for things, engineers use models to build things [94, 97]
(figure 1.1). Nevertheless, concrete theory in engineering requires both modes
of thinking. This criticism is not aimed at the individual fields manifesting con-
currently in cyber-physical systems, such as control, systems theory, or software
engineering. But even currently, when we have recognized this interplay between
disparate fields in cyber-physical systems, the individual research programs seem
to be conducted in their own silos. For this reason, the foremost problem facing
cyber-physical systems assurance today is one of unification‚Äîof the challenges,
for example between the codependence of security and safety in these systems,
and solutions, such as the lack of formal traceability between requirements, be-
haviors, and architecture. Unification towards a compositional cyber-physical sys-
tems theory is the subject of this dissertation.

1.1 Cyber-physical systems pose new challenges

Cyber-physical systems are composed of computing platforms, control systems,
sensors, and communication networks. These systems provide critical service ca-
pabilities in a number of engineering domains, including transportation, medical
devices, and power, to name a few. The design of cyber-physical systems poses

5

Figure 1.1: In scientific inquiry, the value of the model is how well it matches the system. In
engineering design, the value of a system is how well it matches the model (adapted from
Dexler [51]).

new challenges because of the intertwined nature of digital control with physical
processes and the environment. As autonomy and coordination between a multi-
tude of such systems becomes commonplace, there is an increasing need to for-
mally assure not only their individual behavior but also the emergent properties
that arise from the behavior of the composite system. One such emergent prop-
erty is safety, which could be further imperiled by insecurity in cyber-physical
systems. When cyber-physical systems exhibit unwanted behaviors, they can tran-
sition to hazardous states and then lead to accidents. To avoid such undesirable
outcomes it is necessary to provide evidence of correct behavior before deploy-
ment, during the design phase of the systems lifecycle. Design changes in later

Prolegomena

6

Physical System(objective study)Concrete Description(data)Abstract Model (theory)measurecomparePhysical System(useful product)Concrete Description(speciÔ¨Åcation)Abstract Model (design concept)producedesignScientiÔ¨Åc InquiryEngineering Designstages of the system lifecycle cost more and are less effective [150]. It is only pos-
sible to produce this evidence early‚Äîwhen a realized system is not yet available‚Äî
through the management and use of various models [22].

Undesirable behavior stemming from emergent properties has led to serious ac-
cidents [127]. For instance, a recent case, involves the first accidental death of a
pedestrian by an indecision made by an autonomous vehicle, in which the vehicle
chose not to stop in the face of an obstacle [106, 114, 124, 125]. A human supervi-
sor was present, but this consists of one of the ironies of automation: humans are
not good at keeping focus during such situations, but it is the automation itself
that forces the humans into those very situations [14, 160].

Even more troubling are instances where unsafe and uncontrolled behavior‚Äîthat
at times has led to casualties‚Äîis a direct result of an exploit [73, 120]. This is
supported by a series of notable and dangerous cyber-physical attacks including
Stuxnet [92], Havex [143], BlackEnergy [79], and CrashOverride [151]. Signifi-
cantly, Triton is the first known example of malware with the sole intention of
disabling safety systems to instigate accidents [63].1

As designers strive for unprecedented levels of autonomy in every day life, the
more engineering design problems become safety critical.2 To assure safe and se-
cure behavior we cannot rely only on a small number of experts that attempt to
mitigate security issues after the design solution has been finalized. Instead, se-
curity and safety have to become part of the engineering design process itself‚Äî
assessed and applied often and throughout but, significantly, starting from the
early phases of the system‚Äôs lifecycle (figure 1.2).

The design methodology of cyber-physical systems requires the study and appli-

1 In any given successful attack it is common to discuss the innovative portion of the exploit
chain, especially if the eventual target is part of the operational technology (ot) layer. But, the
bread and butter of every successful attack is still basic malware, utilities, and intrusion tactics,
techniques, and procedures that permeate in the information technology (it) layer [155].

2 Incidentally, a large number of sectors apply automation so rapidly to the point where it should

be considered unchecked and careless in addition to unprecedented.

Prolegomena

7

1 effectiveness

cost

2

80% of
decisions

Concept

Requirements

Design

Build

Operate

Figure 1.2: The ability to impact cost and performance is highest early in the system‚Äôs lifecy-
cle [56] (adapted from Strafaci [159]).

cation of several different areas (figure 1.3). These areas, such as control, have
been studied at length at the individual level. However, to date there is still a lack
of formal relation outside of each individual branch. The formal unification or oth-
erwise formal composition between the branches that are used to engineer cyber-
physical systems can lead to improvements in specification, managing the inher-
ent complexity of different models and methodologies, and ultimately to better
verification and validation of the systems we design and deploy. Additionally, the
formal compositional modeling and analysis of such systems will allow for modu-
larity and interoperability of system models. For example, an existing embedded
systems model that is explicitly decomposed from some simulated dynamical be-
havior can then be further augmented with further design choices by a mechanical
engineer to include more precise definitions and mathematical models of an ‚Äúair-
frame‚Äù model entity.

As a final observation, in practice there exists a gap between model solution, in-

Prolegomena

8

Economics in the Loop

‚Ä¢

Humans in the Loop

Environmentals in the Loop

Networked & Distributed

possibly with

Wireless Sensing & Actuation

w it h

p o s sib l y

Feedback
Systems

that are

Resilience

a r e

Cybersecurity

Privacy

‚Ä¢

Adaptive & Predictive

Intelligent

Real Time

Cyber-Physical
Systems

require

‚Ä¢

Malicious Attack

Intrusion Detection

i

m
p
e
r
i
l
s

Hazard Analysis

identifies

Unsafe Control Actions

Safety

Safety Constraint

Interoperability

Hybrid &
Heterogeneous
Models

Models
of Computation

Continuous
& Discrete

h

a

v

e

a

p

p

l

i

c

a

t

i

o

n

s

i

n

Losses

Clock Synchronization

Improved Design Tools

e
n
a
b
l
e
s

Specification,
Modeling,
& Analysis

of

‚Ä¢

Networking

Design Methodology

that supports

‚Ä¢

Scalability
& Complexity
Management

through

‚Ä¢

Robotics

Military

Consumer

Energy

Transportation

Infrastructure

‚Ä¢

Communications

Health Care

Smart Buildings

Manufacturing

Physical Security

Verification
& Validation

Assurance

Certification

Simulation

Stochastic Models

Modularity
& Composability

Synthesis

Interfacing with
Legacy Systems

Figure 1.3: A cyber-physical systems concept map showing what these systems are, what
they require, and where they are being used (adapted from Asare et al. [10]). Individual leaf
nodes in this context map have been studied in detail but formal relationships between leaf
node concepts are still sparse.

Prolegomena

9

cluding their associated simulations and formal guarantees as compared to the
eventual implementation of the system that will be manufactured, programmed,
and deployed. Addressing composition between different modeling paradigms
and tools is the first step for a fully interfaced toolkit that maintains simulation
results and formal guarantees from behavioral models, to architectural designs,
to finally synthesis on fabric. The definition of algebras and coalgebras within a
categorical model has the potential of addressing this interoperability problem.

Specifically, the point of developing a compositional cyber-physical systems the-
ory is to bridge together different models for the purpose of addressing the over-
lap between safety and security3 by eventually producing new modeling languages.
These modeling languages must have a strong notion of composition and increased
semantic relatedness. Category theory, the mathematics of mathematics, has a
number of appealing properties for this role. Namely that it is fundamentally based
on composition of structures and that the behavior of components is defined by
its relationship to other components instead of just examining components in iso-
lation.

1.2 Assurance is about models, not systems

A model is any representation of a system but the thing itself. This includes what
we might traditionally think of models but also intermediary representations that
seem like they are the thing itself but in reality they are not, for example, software.

Design is the well-formed solution to a set of constraints. These constraints are
defined through requirements. To construct a proposed design solution that ad-
heres to the concrete requirements we first need to consult with the persons in-
tending to use the system [130]. These persons are the stakeholders of the system
which at a minimum include the system designers themselves, the operators, and

3 As we deploy and further rely on cyber-physical systems for everyday tasks, this overlap be-

comes less narrow and more apparent.

Prolegomena

10

System

Mental Model

Model

Refactor

Analyze

Properties
of the System

Figure 1.4: The standard modeling approach is based on analyzing a realized system with the
goal of better understanding its behavior.

owners. It is those differing views that lead to solid requirements and, therefore,
to well-formed design solutions.

However, to reason about those differing views it is necessary to elicit information
through structured methods [39]. Otherwise, the differing views confuse rather
than elucidate. This leads to the fundamental challenge of design, which is to
create and evaluate elicitation strategies that are inclusive of all stakeholders‚Äôs
views, such that the behavior and misbehavior of a system is correctly classified.

Further, any such strategy has to be able to build strong and nuanced mental mod-
els of the needs and behaviors any potential solution provides. This is a task that
has been studied extensively when analyzing physical systems (figure 1.4). On the
other hand, the construction of clearly defined requirements and unacceptable
losses to those requirements has been less studied. The new reality and ubiqui-
tous use of cyber-physical systems depend upon the refinement of requirements
in the absence of a realized system (figure 1.5).

By using modeling techniques, it is possible to examine quickly, efficiently and
cost effectively the different behaviors or responses a systems might exhibit. In
terms of assurance that means that we can examine a reduced set of edge-cases

Prolegomena

11

System
Requirements

Mental Model

Model

Refactor

Analyze

Properties
of the Design Solution

Figure 1.5: The majority of flaws are introduced in the early-concept to requirements phases
of the system‚Äôs lifecycle [102]. If we move the goalpost earlier we can produce concrete and
helpful system specifications to assist in the implementation of safe and secure systems.

based on the expected behavior of the system. The purpose of models for assur-
ance is to test the assumptions and mental models that designers might have and
assist with creating requirements regarding mitigation, raising security barriers,
and/or adding resilience to address these cases [53].

In the same sense, design too is a form and type of model that captures interfaces,
connections, and dynamics. In that case, the model becomes the design or other-
wise the blueprint of the eventual system. This is a natural way to think, a design
is a model insofar as it represents a possible solution to the problem the system
ought to fix when it is built.

As an additional benefit, models can be treated as living documents, maintained
to reflect design choices and system revisions. Hence, they can be a valuable re-
source for the safety and cybersecurity specialists. Competent information tech-
nology (it) professionals have long stressed the need for documenting the system
designers‚Äôs intentions versus simply stating the architecture of, for example, a net-
work of computers [42]. Extending the current design practice to clearly define
the set of high-level requirements that are traced down to a formal specification of
a system documents all the what‚Äôs that can be reassessed and revised throughout

Prolegomena

12

practical
experiences

inform
practice

informal
claims

defensible
model

make
precise

formal
result

formal
claims

prove or
disprove

Figure 1.6: The formal informs the informal (adapted from Kuper [86]).

the system‚Äôs lifecycle.

In this dissertation, we consider a formal method to the problem of composition in
the modeling of cyber-physical systems. This formal method or model did not get
developed in the absence of informal experience (figure 1.6). This historic detour
to how the results presented in the subsequent chapters came to be is important
to understand the context in which composition in modeling and design solutions
became a central theme for our work.

Inconsistencies arise in much of the informal work necessary to design and assure
safety-critical cyber-physical systems. Attempting to formalize some of these in-
consistencies took us through a journey from linear logic to modal logic and then
to graph theory. Logical inferences then made sense to think as connections of
some form, which we get for free by using compositional methods, to use and de-
velop for the design and assessment of systems. From another perspective, many
of the concepts in system modeling were elusive from a philosophical perspec-
tive, for example, plagued by the question of what actually is a model? From this

Prolegomena

13

side too, capturing a formal notion of composition made sense because abstrac-
tions and refinements show up all over the place when modeling. But to define
their types in any kind of meaningful way that was either theoretically sound or
practically useful requires more than just putting lines between boxes. We can un-
derstand these things in a more systematic and rigorous way using compositional
methods.

1.3 Cybersecurity is fundamental to safe behavior

In cyber-physical systems the security of the machine is tightly coupled with safety.
This is due to the interaction of digital and often distributed systems with the
physical environment. Hence, as with safety, security is an emergent property of
a system [28, 40, 41, 169, 170], meaning that the safe or secure behavior of the
components, cannot be used individually or in isolation to investigate the overall
safety or security of the system [57, 135]. This is increasingly important for two
reasons: these machines are ubiquitous and they are expected to make complex
and timely decisions autonomously [123].

These decisions could be influenced by an attacker to cause physical harm. A suc-
cessful exploitation of a cyber-physical system can lead to highly undesirable and
unsafe behavior [108]. This is seen in several safety-critical domains that contain
serious and exploitable vulnerabilities, including medical systems [3, 4, 65, 84],
aviation [31, 74], automotive [43, 46, 77, 78, 81, 83], and electric power [85, 161],
to name a few.

A new notion and potential calculus in the security of cyber-physical systems is
then driven by the need to safely (and therefore securely) provide clearly defined
system behaviors. While security can be a means to protecting private informa-
tion, in the cojoint problem of security and safety, security is merely a tool to-
wards the safe operation of the systems expected service and not a means in itself.
Security for security‚Äôs sake is not only unresourceful but also ineffective. This is
because bolt-on security‚Äîsecurity that is applied after a system is designed and

Prolegomena

14

deployed‚Äîprovides narrow options in the form of mitigation strategies. Instead,
security by design that is cognizant of the systems‚Äôs expected service and its po-
tential unsafe behaviors, can better be implemented early, often, and throughout
a system‚Äôs lifecycle.

However, it is not always the case that designers work with newly constructed
systems. More often than not, system designers are asked to incorporate new
features and construct different behaviors using existing infrastructure or com-
ponents. Therefore, security approaches require understanding the coupling of
legacy hardware, firmware, and software (that might be more mature but poten-
tially have less security consideration4) with new, better understood and designed
subsystems as well as the interface between the two.

Indeed, security is the efficient use of resources to defend against reasonable
threats [27, 170]. What constitutes a reasonable threat in a cyber-physical system
can only be understood through its unsafe and undesirable behaviors that can be
induced by a successful exploit. Unfortunately, today, security is often practiced
in an unorganized piece-meal fashion, such that system‚Äôs are secured almost ex-
clusively through bolt-on solutions. These solutions by definition cannot avoid an
increasing number of physical hazards since they are applied after the fact.

But how do physical hazards manifest? The operation of a cyber-physical system
can be thought of as providing digital control; that is, computer states, through
physical inputs and outputs; that is, the physical states. Specifically, the system‚Äôs
computer states are a complex set of interrelated hardware, firmware, and soft-
ware states. Faults that occur in this layer include errors in sensor measurement,

4 It is often the case that stakeholders consider legacy software and hardware more secure than
newly designed and implemented software and hardware. The misunderstanding seems to stem
from the idea that the longer a system is in place, the less likely it is that vulnerabilities are go-
ing to survive. This notion is unequivocally wrong. For example, WinRAR contained a nineteen
year old vulnerability that allows an attacker to take full control of the victims computer [67].
For firmware‚Äîespecially in safety-critical applications‚Äîthe situation is worse because even if
patches exist; applying them might go against operational needs or patch distribution is han-
dled incorrectly by the vendor [25]. ShadowHammer, for instance, abuses ASUS‚Äôs own update
channel and private signing key to distribute malicious patches [66, 87].

Prolegomena

15

Figure 1.7: An activated erroneous state ( ) in the computer layer can propagate to violate a
physical state ( ). In the right context the violation of a physical state can lead to a hazardous
condition ( ), which may lead to an accident. If the context is not right the hazardous state
stays dormant ( ).

control algorithms, and state variables. The system‚Äôs physical states capture the
underlying concept, which includes the environmental conditions; that is, the ac-
tivated fault from the system‚Äôs computer states manifests in an unsafe control
action. It is those conditions that might lead to a hazardous state that can lead to
unacceptable losses and accidents (figure 1.7).

To understand how these state layers interact with each other consider the opera-
tion of an adaptive cruise control (acc). While driving the acc software might is-
sue an unintended acceleration command due to, for instance, calculating a wrong
value or timing issue. If this happens in the right context, for example, this fault
is activated while the vehicle is too close to the lead vehicle, the vehicle will not
maintain a safe distance. This is an activated hazardous state that might, in turn,
lead to a collision. The desirable behavior here is to always keep a safe distance

Prolegomena

16

`Computer StatesPhysicalStatesHazardous Statesfrom the lead vehicle, while the undesirable behavior is to unintentionally issue
an acceleration command while close to another vehicle.

Once there exists a set of desirable and undesirable behaviors as well as an initial
system design (or even a set of designs), it is important to specify them precisely.
That is where a more expressive language rather than code needs to be used. This
language is mathematics (or metamathematics) [90]. Through the language of
mathematics we can start reasoning in terms of behaviors or dynamics instead
of only implementations as is the case with only considering how to develop the
code for a particular system. Reasoning about behavior before implementation is
particularly important for cyber-physical systems, where code controls physical
processes, such as actuators.

Different implementations might be mapped to the same set of system require-
ments. The language of mathematics, being agnostic to implementation, is much
better equipped to evaluate and assure certain behaviors‚Äîeven when we assume
presence of attackers. Of course, the solution will eventually need to be coded to
behave as we expect so mathematics and code must work in tandem. Composi-
tional methods help with that too and code can be developed to implement the
mathematical definition in terms of dependently typed programming languages.

1.4 Compositionality is subtle

In system design and engineering at large, compositionality refers to putting a
system together from well-understood components to perform some behavior. In
computer science, it refers to something more formal which is that the behavior
of the whole program must follow from the inferences of each individual state-
ment in sequence. Even though the term compositionality is elusive, it generally
emerged to produce structure out of historically unstructured processes and that
holds true both for engineering and computer science.

In a program we can see this development of compositional structures with the

Prolegomena

17

introduction of better abstraction and refinement features in programming lan-
guages. These take the form of, for example, additional features in the form of
functions, classes, or even packages. By using these features programmers are
more likely to create modular software but crucially be able to create interfaces.
Today, programmers can work on huge programs without necessarily knowing
the inner workings of most of the functions they are incorporate into their own
code blocks. This has been such second nature that even short code might in-
clude libraries with thousands if not millions of lines of code being used without
the programmer having ever examined what those are. Compositionality in this
sense does not mean that any programmer will develop easy to understand and
modular code‚Äîthe opposite is often true‚Äîbut that they have the tools to do so
if they so desire.

In engineering, we have similar tools although the term compositionality is used
less frequently to describe them. For example, in control we might view the differ-
ent physical processes and systems in the form of a hierarchy (figure 1.8). This hi-
erarchy means different things to different people but holds one thing in common,
namely, the implicit existence of interfaces. A mechanical engineer might have
complete familiarity with the physical actuation and at the same time only know
the commands that come from a microcontroller. A computer engineer might in-
stead know the opposite; know exactly how to produce the commands to move
actuators but not how the physical dynamics of actuation actually work. Interfaces
are then the glue between different components and expertise. A proper interface
will help the mechanical engineer design an actuator while at the same time help-
ing a computer engineer with fabricating hardware and developing software for
the same actuator without necessarily knowing exactly how it works.

This is to say that compositionality is about remembering and forgetting [70], which
map directly to refinement and abstraction. Remembering means adding or recov-
ering more information about a particular component. Say something is wrong
with the actuator, then the expertise of the mechanical engineer ought to be used
to figure out why. But forgetting is equally important in designing increasingly

Prolegomena

18

Input

Level ùëõ
Subsystem

Output

Constraints

Feedback

Input

Level ùëõ ‚àí 1
Subsystem

Output

Feedback

Constraints

Input

Level 1
Subsystem

Output

Figure 1.8: Hierarchical control implies the feedback relationship from bottom to top and
constraint relationship from top to bottom (adapted from Mesarovic and Takahara [117]).

complex systems which requires us to see the forest instead of the trees; that is,
putting components together to form larger systems without necessarily being
experts in every component that compose the systems we build.

The opposing force to compositionality is that of emergent phenomena. A compo-
sitional model of a particular system must be sufficient to tell us how the behavior
of the whole is produced by the behavior of their parts and connections between
parts. It would be impossible to remove emergent phenomena and it is the case
that often they are desired to achieve a particular behavior. However, the point
of compositionality is not to eradicate emergence but rather to control it. Con-
trolling emergence through means of compositionality requires us to add more
information to models that are well understood. We will see for example, that in a
controls model we will require the use of trivial functions for sensor and controller

Prolegomena

19

even though we already know how to calculate the overall behavior without them
(by using the standard equations for dynamical behavior in those systems). That
is what we mean by controlling emergent effects, not removing or reducing but
rather being further mathematically explicit when needed to retain compositional
properties in our models.

Most engineering work in compositionality centers around one formalism, for ex-
ample, in hybrid systems [126], timed automata [34], linear temporal logic spec-
ifications [8], and contract theory [62]. Call this type horizontal composition;
within one mathematical model we compose the same types of models to pro-
duce larger ones. This is generally an accepted line of work within one field but a
perhaps more interesting rule would be vertical composition, which would relate
or otherwise be able to enforce a hierarchy among multiple such formalisms. One
way of achieving vertical composition is by using tools from category theory.

Category theory is instead the study of composition between mathematical struc-
tures. Logic and set theory created the scaffolding for the foundation of mathe-
matics. Instead, category theory focused on showing how different mathematical
concepts are related to each other. This mathematical study of relationship has
positioned category theory beyond pure mathematics, the most visible applica-
tion of which is in functional programming. This is to say that the earlier example
of compositionality in computer science has been made formally explicit through
the use of category theory. It goes further than that, there is a deep relationship
between the fundamental concepts of category theory (objects and morphisms)
and physics, logic, and computation‚Äîall of which are necessary to assure the be-
havior of cyber-physical systems (table 1.1). In this dissertation, we attempt to
bring those ideas to the engineering of cyber-physical systems.

The general problem with compositionality is that is it subtle and finicky and does
not always work in orthodox ways. This limitation can be partially overcome with
the mechanization of the theory presented in this dissertation. Work in human-
computer interaction and the increasing user friendliness of theorem provers give

Prolegomena

20

Table 1.1: Category theory is an appropriate tool for studying the flow of information
(adapted from Baez and Stay [12]).

Category Theory Physics

Logic

Computation

object
morphism

system proposition
process

proof

data type
program

us indication that it is possible to enforce composition in new modeling languages
regardless of how subtle doing so is when done with pen and paper. This does
not necessarily solve the fact that composition, as is with all engineering design
and code, is also an art. Therefore, the same problem persists as we have seen in
programming. The theoretical tools are there for us to make modular programs
but it is up to us to use them correctly.

1.5 Hypothesis

We thus far have described the problems we will consider in the abstract. It is
infeasible for one piece of work to address all the problems that were presented
above completely. The promise is that this dissertation touches on several differ-
ent problems in the design of cyber-physical systems, including models of compu-
tation, composability, assurance for safety and security (figure 1.3), but in order
to do so it borrows already developed theory. We do not see this as a limitation of
the approach but rather as a benefit, in the sense that we know that the distinct
theoretical models are already vetted and have been used in a practical setting. On
top of these methods we provide a framework of formal composition that uses the
algebras of each individual theory to provide vertical composition.

The hypothesis of this dissertation is that a compositional cyber-physical systems
theory is desireable both because it transforms existing theory into one common
language of composition within each mathematical model and because this com-
mon language can then be used to unify the associated model views across mathe-
matical models. Concretely we can describe the potential benefits of such a theory

Prolegomena

21

through a number of desireable properties that stem from the previous sections.

property 1

property 2

Provide a common language for different models used in the de-
sign of cyber-physical systems, for example, models used in the
leaf nodes of figure 1.3.

Use that common language specifically to both prove and illus-
trate how different formalisms that describe a subset of require-
ments, system behaviors, and system architectures can be uni-
fied; that is can vertically compose in addition to horizontally.

property 3

Elucidate how these horizontal and vertical composition rules
can be practically used in the context of safety and security.

We further hypothesize that these properties naturally emerge through a categor-
ical theory of cyber-physical systems. To provide evidence that this hypothesis is
correct we marry contract theory, linear time-invariant systems, and graph archi-
tectural models using category theory. We use these theories to construct safety
contracts and apply component-based security analysis using a running example
of an unmanned aerial vehicle (uav).

The main result of the dissertation is twofold. First, we develop different algebras
for requirements, system behaviors, and system architectures that preserve com-
position within each of the individual formalisms. Second, we develop the the-
oretical underpinning using fundamental concepts from category theory to pro-
vide verified composition or otherwise unify those distinct algebras in a way that
changes in one algebra reflect some change on the other algebra. This theoretical
machinery is both algebraic (and therefore mechanizable algorithmically) and can
be represented using graphical tools (which are a familiar syntax to systems engi-
neers) with the future goal of developing new modeling languages that preserve
the property of composition across all modeling paradigms required to effectively
engineer cyber-physical systems.

Prolegomena

22

Using category theory to model systems has the potential of unifying even fur-
ther paradigms that implement composition and often are as expressive as the
associated categorical structure.

Logic.
Logic-based approaches to cyber-physical system design, such as con-
tract composition in the KeYmaera X tool [121] or hybrid Event-B [24]. Express-
ing design problems in logical inference rules further assist with the separation of
computation and physics present in cyber-physical systems [111]. Logic has been
consistently used to combat the problem of specification mismatching throughout
the lifecycle of the system and its associated models [128]. Cyber-physical sys-
tems have also not gone through their ‚Äúproofs as programs‚Äù paradigm shift [26]
and, therefore, significant development can happen in this area by using other fla-
vors of logic than linear temporal logic, such as intuitionistic logic or linear logic.
Type theory [72] is also unexamined in the context of cyber-physical system de-
sign and it could arguably be used instead of category theory in this work.

Hybrid systems. Hybrid systems is a well-established version of computational
dynamical systems theory [7] or more recently model interfaces [141]. Ames (as
well as Tabuada et al. to some extent [162, 163]) did develop a categorical theory
of hybrid systems [9] and therefore the results of this program are immediately
transferable, in the sense that instead of linear time-invariant systems we could
very well use the algebra of hybrid systems instead.

Contracts. The theory of contracts has had significant development, especially
as applied to cyber-physical systems [30, 149], including notions of contract com-
position [136]. Recently there are also concrete applications in the form, for ex-
ample, of a toolkit on top of SysML [50], which will make contracts increasingly
accessible to system designers. Contracts have been implemented as an end-to-
end requirements engineering framework, but more importantly have also been
merged with linear temporal logic specifications that can compile down to con-
tracts [134]; this idea could also be implemented into our compositional cyber-
physical systems theory. Examples of synthesis from a contract-based design spec-

Prolegomena

23

ification [62], show that it is possible to use our generalized version of contracts to
adapt control synthesis tools [76, 145] with our notion of modeling and simulation.
Therefore, we would be able to not only have composition among requirements,
system behaviors, and system architectures but we would also be able to produce
a possible implementation that is compositionally constrained at any given level;
this would represent an improvement over approaches that only consider the com-
positional verification of architecture models [45].

Coalgebras. Algebras are one view of the behavioral approach to systems. An-
other is that of coalgebras [148], which can often better mathematically describe
processes. Both algebras and coalgebras can, for example, represent automata or
streams. The main benefit of coalgebras is that bisimulation in process formalisms,
say automata or streams, is precise enough for an algorithm to emerge immedi-
ately from the proof itself.

Prolegomena

24

People think of abstraction as stripping away meaning.
Abstraction does the opposite‚Äîit enriches meaning.

‚Äî Francis Su

2 Category theory for the mathematical engineer

In recent years category theory has gained attention in engineering, particularly
how it can be used at a practical setting [35, 88, 167, 171, 173]. Often, the question
that might plague the rogue engineer that decides to try category theory relate
to its utility. Let‚Äôs get it out of the way, the promise of applied category theory
is twofold. First, it claims to assist with unification. Supporting this statement is
straightforward, functorial semantics allow us to manipulate data in ways that set
theory or logic cannot but also still in ways that set theory and logic can. Second, it
claims to provide scalability. This statement is harder to support and it will require
future work, from developing tools familiar to engineers, to prototype implemen-
tations of categorical features and finally to validation through case studies.

Instead of describing category theory in full, we want the reader to focus on the
categorical toolkit used in the rest of the dissertation so we will only cover what is
later used directly. However, we refer to the many formal treatments on the topic,
including books such as Fong and Spivak [54], throughout.

2.1 Categories relate different concepts

The bread-and-butter of category theory are

1.

2.

categories (hypergraph structures),

functors (morphisms between categories), and

26

3.

natural transformations (morphisms of functors).

Definition 2.1.1 (Category). A category C is composed of the following data

objects a collection of objects, denoted obj C

morphisms for each pair of objects ùê¥, ùêµ, a collection of morphisms from ùê¥ to ùêµ,

denoted Hom C [ùê¥, ùêµ] 1

identity for each object ùê¥, a morphism ùê¥

idùê¥‚àí‚àí‚Üí ùê¥

composition for each ùê¥, ùêµ, ùê∂ objects, a composition 2 operation

‚àòùê¥,ùêµ,ùê∂ ‚à∂ Hom C [ùêµ, ùê∂] √ó Hom C [ùê¥, ùêµ] ‚Üí Hom C [ùê¥, ùê∂] .

To represent a category this data has to also respect the following relations for

each ùê¥

ùëì
‚àí‚Üí ùêµ, ùêµ

ùëî
‚àí‚Üí ùê∂, and ùê∂

‚Ñé
‚àí‚Üí ùê∑:

idùêµ ‚àòùëì = ùëì

ùëì ‚àò idùê¥ = ùëì

(‚Ñé ‚àò ùëî) ‚àò ùëì = ‚Ñé ‚àò (ùëî ‚àò ùëì),

meaning that composing with the identity function either from the left or the right
recovers the function itself (unitality) and the order of operations when compos-
ing functions does not matter as long as the order of operands is unchanged (as-
sociativity).

The simplest example of category, and the most important for engineering appli-
cations, is Set, the category whose objects are sets and morphisms are functions
between them. For each set ùê¥, idùê¥ is the identity function from ùê¥ to itself and

1 A morphism ùëì in Hom C [ùê¥, ùêµ] is usually denoted as ùê¥
2 We usually omit the subscripts and just write ùëî ‚àò ùëì to denote composition. Composition is
ùëî
‚àí‚Üí ùê∂. In the diagrammatic case, composition of

ùëì
also denoted diagrammatically as ùê¥
‚àí‚Üí ùêµ
morphisms is left-to-right instead of right-to-left when we syntactically write ùëî ‚àò ùëì.

ùëì
‚àí‚Üí ùêµ.

Category theory for the mathematical engineer

27

composition is function composition. The category of sets and functions is not
merely a way to manipulate a set of elements. It is, instead, a much more funda-
mental way of seeings sets as a whole where morphisms represent all functions
that can take place between any numbers of sets.

Plenty of familiar structures in mathematics can be seen as categories. For in-
stance, a monoid can be seen as a category with only one object, call it ‚àó. Any
element of the monoid is interpreted as a morphism ‚àó ‚Üí ‚àó. The identity on ‚àó
is the monoid unit, and composition is the monoid operation. Indeed, categories
can be thought of as generalized monoids with many objects. This might seem like
an obfuscating example but it is actually a simple algebraic structure and in prac-
tice monoids equipped with actions recover the formalisms we use to describe
any transition system.

Other familiar examples of categories include: groups and their homomorphisms,
vector spaces and linear maps between them, topological spaces and continuous
functions, and the category of states and transitions between them [49].

In general, the idea is that morphisms are transformations that preserve some
properties possessed by the objects; properties that we care about.

A standard diagrammatic way to express composites is ùëã
tions via commutative diagrams of the following form.

ùëì
‚àí‚Üí ùëå

ùëî
‚àí‚Üí ùëç and equa-

idùëã

ùëã

ùëì

ùëã

ùëì

ùëå

stands for ùëì ‚àò idùëã = ùëì

Definition 2.1.2 (Isomorphism). Given a category C, a morphism ùê¥

ùëì
‚àí‚Üí ùêµ is

ùëì‚àí1
‚àí‚àí‚Üí ùê¥ such that the following
called an isomorphism if there is a morphism ùêµ
square commutes, meaning that any two paths sharing the same start and end

Category theory for the mathematical engineer

28

points define the same morphism.

ùëì

ùê¥

ùêµ

idùê¥

ùëì‚àí1

idùêµ

ùê¥

ùêµ

ùëì

If there is an isomorphism ùê¥
write ùê¥ ‚âÉ ùêµ.

ùëì
‚àí‚Üí ùêµ, then we say that ùê¥ and ùêµ are isomorphic, and

Two isomorphic objects in a category behave exactly in the same way only with
respect to the structure captured by the category. For instance, ‚Ñù and ‚Ñù2 can be
seen both as objects in Set, the category of sets and functions, and as objects in
Vect‚Ñù, the category of real vector spaces and linear maps between them. They
are isomorphic in Set, since bijective functions satisfy isomorphism (definition
2.1.2) and ‚Ñù and ‚Ñù2 are in bijection. Nevertheless, they are not isomorphic in
Vect‚Ñù, since an isomorphism in this category has to be a linear bijection, which in
particular has to preserve dimension. What is happening here is that since Vect‚Ñù
keeps track of more structure than what Set does, our ability to tell objects apart
in Vect‚Ñù is finer than in Set.

Functors are morphisms between categories. Functors too should preserve the
properties we care about when we study categories. The properties that we care
about in categories are similar to those of functors; merely identities and compo-
sition (definition 2.1.1). This gives us some insight to the definition of functors.

Definition 2.1.3. Given categories C and D, a functor C
following information.

ùêπ
‚àí‚Üí D consists of the

Category theory for the mathematical engineer

29

‚Ä¢

‚Ä¢

A mapping obj C

ùêπ
‚àí‚Üí obj D (figure 2.1a).

For each ùê¥, ùêµ ‚àà obj C, a mapping (figure 2.1b)

Hom C [ùê¥, ùêµ]

ùêπ
‚àí‚Üí Hom D [ùêπùê¥, ùêπùêµ] .

‚Ä¢ We moreover require that the following two equations hold

ùêπ(idùê¥) = idùêπùê¥

ùêπ(ùëî ‚àò ùëì) = ùêπ(ùëî) ‚àò ùêπ(ùëì).

We will often omit parentheses when not strictly necessary. As such, we will write
ùêπùëì instead of ùêπ(ùëì) to denote the application of a functor ùêπ to a morphism ùëì.

Functors are structure preserving maps that allow us to connect different model
types by defining the particular semantics of transformations that are necessary
to change the domain of discourse within a particular category, say Set ‚Üí Set, or
between different categories, say C ‚Üí Set.

For example, there is a functor from Vect‚Ñù to Set that forgets structure. Any real
vector space is mapped to its underlying set, and any linear map between them is
mapped to its underlying function between sets.

As we will see shortly, a useful functor in category theory is the hom-functor: fix
an object ùê¥ in a category C. Then we can define a functor

Hom C[ùê¥,‚àí]
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí Set

C

Which sends every object ùêµ of C to the set of morphisms Hom C [ùê¥, ùêµ]. A mor-
phism ùêµ

ùëî
‚àí‚Üí ùê∂ is sent to the function

Hom C [ùê¥, ùêµ]

Hom C[ùê¥,ùëî]
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí Hom C [ùê¥, ùê∂] .

ùëì
‚àí‚Üí ùêµ is sent to ùê¥
Which acts by postcomposing; that is, a morphism ùê¥
Functoriality follows from the composition and identity axioms of C.

ùëì
‚àí‚Üí ùêµ

ùëî
‚àí‚Üí ùê∂.

The next fundamental concept of category theory is naturality.

Category theory for the mathematical engineer

30

(a) A functor maps objects.

(b) A functor also maps morphisms.

Figure 2.1: A functor is a structure-preserving map.

Definition 2.1.4 (Natural Transformation). Given functors C

transformation ùêπ

ùúÇ
=‚áí ùê∫ consists, for each object ùê¥ of C, of a morphism ùêπùê¥

ùêπ,ùê∫
‚àí‚àí‚Üí D, a natural
ùúÇùê¥‚àí‚àí‚Üí ùê∫ùê¥

in D such that, for each morphism ùê¥

ùëì
‚àí‚Üí ùêµ in C,

ùúÇùêµ ‚àò ùêπùëì = ùê∫ùëì ‚àò ùúÇùê¥

This is often expressed diagrammatically by saying that the following square has
to commute.

ùúÇùê¥

ùêπùê¥

ùêπùëì

ùê∫ùê¥

ùê∫ùëì

ùêπùêµ

ùúÇùêµ

ùê∫ùêµ

The information contained in a natural transformation or algebra map ùêπ

ùúÇ
=‚áí ùê∫ is

enough to guarantee that any commutative diagram made of images of things in C
via ùêπ can be turned into a diagram of images of things in C via ùê∫ without breaking
commutativity. The commutativity condition of ùúÇ means that it doesn‚Äôt matter in
which order we will walk through these arrows, the result will be the same.

Category theory for the mathematical engineer

31

ùêÇùêÇùêπ‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚ÜíùêÉidùê¥idùêµidùê∂idùëãidùëåùê¥ùêµùëãùê∂ùëåùêÇùêÇùêπ‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚ÜíùêÉùê¥ùêµùê∂ùëåùëãidùê∂idùê¥idùêµidùëãidùëåùêπùê¥

ùêπ‚Ñé

ùêπùëì

ùêπùêµ

ùêπùëî

ùúÇùê¥

ùúÇùêµ

ùêπùê∂

ùúÇùê∂

ùê∫ùê¥

ùê∫ùëì

ùê∫‚Ñé

ùê∫ùêµ

ùê∫ùëî

ùê∫ùê∂

The Yoneda lemma [33] is arguably the most important result in category theory.
Understanding the Yoneda lemma only requires the definitions above; categories
and functors and natural transformations. It follows from a clever observation:
ùêπ
‚àí‚Üí Set and an object ùê¥ of C. By definition, any natural
consider a functor C

transformation Hom C [ùê¥, ‚àí]

ùúÇ
=‚áí ùêπ has as components functions between sets

ùúÇùêµ‚àí‚àí‚Üí ùêπùêµ. Moreover, for each ùê¥

Hom C [ùê¥, ùêµ]
commute because ùúÇ is a natural transformation.

ùëì
‚àí‚Üí ùêµ, the following diagram must

Hom C [ùê¥, ùê¥]

ùúÇùê¥

ùêπùê¥

Hom C [ùê¥, ùëì]

ùêπùëì

Hom C [ùê¥, ùêµ]

ùêπùêµ

ùúÇùêµ

Lemma 2.1.1 (Yoneda Lemma). There is a bijection

Nat [Hom C [ùê¥, ‚àí] , ùêπ] ‚âÉ ùêπùê¥

Category theory for the mathematical engineer

32

where Nat [ùêπ, ùê∫] denotes the set of natural transformations between any two functors
ùêπ, ùê∫. The homomorphism, Hom C [‚àí, ‚àí], is a contravariant functor in the first compo-
nent and a covariant functor in the second. It can be proven that the bijection is natural
in ùêπ and ùê¥.

Isomorphic objects in a category behave as if they were the same. Repetitively
applying Yoneda lemma results in

ùêπùê¥ ‚âÉ Nat [Hom C [ùê¥, ‚àí] , ùêπ] ‚âÉ Nat [Hom C [ùêµ, ‚àí] , ùêπ] ‚âÉ ùêπùêµ

ùêπ
and, hence, ùê¥ ‚âÉ ùêµ if and only if ùêπùê¥ ‚âÉ ùêπùêµ for any C
‚àí‚Üí Set. So, with respect to
whatever it is that we want to capture by defining a category C, the Yoneda lemma
affirms that we can completely characterize an object ùê¥ by studying its images ùêπùê¥
for any functor ùêπ to Set. We shall see how the Yoneda lemma can be used to test
equivalence between system representations by using its essence, if two objects
agree under any possible test we can perform, then they behave the same.

There are also different types of categories. The ones useful to engineers are
called monoidal categories. Monoidal categories enable the study of parallel pro-
cesses by equipping a tensor product to the base category (definition 2.1.1). Addi-
tionally, for the study of compositional structures in engineering there are several
graphical representation of processes within a monoidal category [153].

Definition 2.1.5 (Monoidal Category). A monoidal category V is a category that
comes equipped with a monoidal product functor

V √ó V

‚äó
‚àí‚Üí V

which can be thought of as multiplication of objects and morphisms, or more
broadly as doing operations in parallel. We require that, for any objects ùëã, ùëå , ùëç,

(ùëã ‚äó ùëå ) ‚äó ùëç ‚âÉ ùëã ‚äó (ùëå ‚äó ùëç),

Category theory for the mathematical engineer

33

meaning that multiplying objects in any order gives isomorphic results.

We also require the existence of a distinguished object ùêº of V, called monoidal unit,
such that

ùêº ‚äó ùëã ‚âÉ ùëã ‚âÉ ùëã ‚äó ùêº

that is, ùêº acts like an identity for this multiplication.

All this data must satisfy certain axioms [75].

Widely used examples of monoidal categories include (Set, √ó, {‚àó}) with the carte-
sian product of sets and the singleton, as well as (Lin, ‚äóùëò, ùëò) with the tensor
product of ùëò-vector spaces. Moreover, (Cat, √ó, 1) with the cartesian product of
categories (similarly to that of sets) and the unit category with a single object and
single arrow forms a monoidal category. In fact, all these are examples of symmet-
ric monoidal categories, which come further equipped with isomorphisms

ùëã ‚äó ùëå ‚âÖ ùëå ‚äó ùëã,

for example, for two sets ùëã √ó ùëå ‚âÖ ùëå √ó ùëã via the mapping (ùë•, ùë¶) ‚Ü¶ (ùë¶, ùë•).

Now that we defined monoidal categories, that are nothing but categories together
with some additional structure for modeling parallel processes, we have to refine
our notion of functor accordingly such that it works in the parallel case of opera-
tions too.

Definition 2.1.6 (Lax Monoidal Functor). A lax monoidal functor between two
monoidal categories ùêπ ‚à∂ (V, ‚äóV, ùêºV) ‚Üí (W, ‚äóW, ùêºW) is a functor that preserves
the monoidal structure in a lax sense (meaning not up to isomorphism). It comes
equipped with two morphisms. A unitor

ùêπ(ùêºV)

ùúô0‚àí‚àí‚Üí ùêºW

Category theory for the mathematical engineer

34

and a laxator

ùêπùëã ‚äóW ùêπùëå

ùúôùëã,ùëå
‚àí‚àí‚àí‚Üí ùêπ(ùëã ‚äóV ùëå )

with ùëã, ùëå ranging over the objects of V, that express the relation between the
image of the tensor and the tensor of the images inside the target category W.
These also adhere to certain axioms [75].

Monoidal categories and lax monoidal functors also form a category of their own,
denoted MonCatlax.

2.2 Wiring diagrams are an algebraic graphical language

We can work within a monoidal category diagrammatically by, for example, using
the category W of labeled boxes and wiring diagrams. Wiring diagrams are a partic-
ularly interesting example of the congruence between category theory and model-
based design. Wiring diagrams have been independently created by category the-
orists [146, 157, 165] but surprisingly look and feel similar to engineering block
diagrams used as the basis diagrammatic framework for modeling, for example,
the unified modeling language (uml), the systems modeling language (SysML),
and a variety of tools from Mathworks including Simulink. These types of dia-
grams are increasingly part of various research directions in cps, for example
the Ptolemy project [36] or M√∂bius [115]. Engineering is a discipline where dia-
grammatic reasoning has long been considered an important element in managing
complexity. But several challenges persist, for example using SysML for the anal-
ysis of systems designs means a scarcity of simulation capabilities, an increased
modeling effort to capture different views of the system, and the need to maintain
all these differing views concurrently even as they evolve asynchronously. While
the approach using wiring diagrams has little tool support currently, as an intellec-
tual framework they overcome these limitations by augmenting this diagrammatic
reasoning with stronger mathematical semantics.

Category theory for the mathematical engineer

35

Additionally, the algebraic backend of wiring diagrams overcomes several chal-
lenges that arise in visual programming. Particularly, in Myers‚Äôs seminal work [122]
on taxonomies of visual programming, it is argued that visual programming lan-
guages have a number of issues in practice, some of which are enumerated in the
following points.

point 1

the visual representation is always significantly larger than the text
representation they replace

point 2

visual languages lack formal specifications

point 3

visualizations often are poor representations of the actual data

point 4

implementations lack portability of programs

Instead, within compositional cyber-physical systems theory, the wiring diagram
formalism is grounded on preserving portability through interoperability of wiring
diagrams and their algebras. We can equip several algebras to our wiring diagram
formalism and, therefore, there is a precise mathematical and computational in-
terpretation of those diagrams. This means that we can visualize the syntax and
semantics of the particular model we are working with both with diagrammatic
reasoning but also through a textual, mathematically precise definition. Through
this congruence between diagrammatic reasoning and computational algebra it is
possible to create hybrid languages, where at some level might look like SysML
diagrams but at another might look like formal verification languages like the archi-
tecture analysis & design language (aadl), and therefore being able to partially
combat the limitations of visual modeling languages.

Informally, the objects of this category are to be thought of as empty placeholders
for processes, so far only specifying the types of the input and output data that
they may receive. For example, an object ùëã is diagrammatically depicted as

Category theory for the mathematical engineer

36

‚Ñù
‚Ñï

ùëã

{‚ä§,‚ä•}

A process that can later be positioned inside this box is, for example, the function

ùëì(ùëü, ùëõ) = {

‚ä§ if ùëü = ùëõ

‚ä• if ùëü ‚â† ùëõ

.

To begin with, however, these boxes are uninhabited: they merely represent the
architecture of a possible system. The two input wires above can be represented
by a single wire typed ‚Ñù √ó ‚Ñï.

These interfaces, with finitely many input and output wires along with their asso-
ciated types, are essentially the building blocks for forming larger interfaces from
smaller ones, and this is what is captured by the morphisms in the category W.
‚Ñù is another box. Intuitively, since the type of the
For example, suppose
output wire of ùëå matches the type of one of the input wires of ùëã, they could be
linked along that wire

ùëå‚ÑÇ

‚ÑÇ

ùëå

‚Ñù

‚Ñù

‚Ñï

ùëã

{‚ä§,‚ä•}

to provide a new interface that receives two inputs, one complex and one natural
number, and outputs a true or false:

‚Ñù

ùëå

ùëç

ùëã

{‚ä§,‚ä•}

‚ÑÇ

‚Ñï

Category theory for the mathematical engineer

37

While combining interfaces together, we want to be able to express not only the
new interface they form, which in the above example is
{‚ä§,‚ä•}, but also keep
track of the intermediate wires. In our envisioned category, this will be expressed
as a morphism from ‚Äúùëã and ùëå ‚Äù into ùëç.

ùëç‚ÑÇ
‚Ñï

Definition 2.2.1 (Wiring Diagram Category). There is a category W with pairs
of sets ùëã = (ùëãin, ùëãout) as objects, thought of as the products of types of the input
and output ports of an empty box as in

ùëãin

‚ãÆ

ùëã ‚ãÆ

ùëãout

A morphism ùëì ‚à∂ ùëã ‚Üí ùëå in this category is a pair of functions (in reality, these
are not just arbitrary functions, rather generated by projections, diagonals and
switchings [156, Def. 3.3])

{

ùëìin ‚à∂ ùëãout √ó ùëåin ‚Üí ùëãin

ùëìout ‚à∂ ùëãout ‚Üí ùëåout

(2.1a)

(2.1b)

thought of as providing the flow of information in a picture as follows

ùëì ‚à∂ ùëã‚Üíùëå

ùëå

ùëã

which illustrates in diagrammatic view the system of equations (2.1a) and (2.1b),
where the forks correspond to duplication and black bullets correspond to discard-
ing. Information going through those wires can be anything insofar as the types
match between ports. The wires of the external input ports ùëåin can only go to the

Category theory for the mathematical engineer

38

internal input ports ùëãin (equation (2.1a)), whereas the wires of the internal output
ports ùëãout can either be directed to the external output ports ùëåout (equation (2.1a))
or fed back to the internal input ports ùëãin (equation (2.1a)).

This is a monoidal category, where the tensor product of any two labelled boxes
ùëã and ùëå is ùëã ‚äó ùëå = (ùëãin √ó ùëåin, ùëãout √ó ùëåout) that represents the parallel placement
of the two

(2.2)

‚ãÆ

ùëã

‚ãÆ

‚ãÆ

ùëå

‚ãÆ

with input and output the (cartesian) product of the respective sets.

For simplicity, we often abstract the pictures for objects, morphisms and tensor
in W to

ùëãin

ùëã

ùëãout

ùëå

ùëã

ùëã

ùëå

The composition in this category zooms two levels deep. For ùëì = (ùëìin, ùëìout) ‚à∂ ùëã ‚Üí
ùëå and ùëî = (ùëîin, ùëîout) ‚à∂ ùëå ‚Üí ùëç in the form of (2.1a), the new wiring diagram

ùëî ‚àò ùëì ‚à∂ ùëã ‚Üí ùëç

consists of the functions

((ùëî ‚àò ùëì)in ‚à∂ ùëãout √ó ùëçin ‚Üí ùëãin, (ùëî ‚àò ùëì)out ‚à∂ ùëãout ‚Üí ùëåout)

Category theory for the mathematical engineer

39

given by

(ùëî ‚àò ùëì)in(ùë•‚Ä≤, ùëß) = ùëìin(ùë•‚Ä≤, ùëîin(ùëìout(ùë•‚Ä≤), ùëß))
(ùëî ‚àò ùëì)out(ùë•‚Ä≤) = ùëîout(ùëìout(ùë•‚Ä≤)).

The identity morphism on ùëã is

(ùúã2 ‚à∂ ùëãout √ó ùëãin ‚Üí ùëãin, idùëãout ‚à∂ ùëãout ‚Üí ùëãout),

and the axioms of a category hold. Moreover, the monoidal unit is the box
and the axioms of a monoidal category can also be verified to hold [165].

{‚àó}

ùêº

{‚àó}

The category W as defined above is really Set-typed or labeled, namely the objects
and morphisms are described using sets. However, the formalism allows to label
the wires with any category equipped with finite products instead of (Set, √ó, {‚àó}).
For example, the types could be in linear spaces ‚Ñùùëõ or topological spaces (ùëã, ùúè) or
even more general time-related categories like lists of signals expressed as sheaves
on real-time intervals [152]. Not only do these different types accommodate sys-
tems with such inputs and outputs, but also often provide a passage between dif-
ferent models on the same system by functorially changing the types.

The construction of this category allows us to formally give meaning to arbitrary
wiring diagram pictures and as a result, coherently describe interconnections. As
an example, consider three processes ùëã, ùëå , and ùëç (figure 2.2a).

The involved labelled boxes are ùëã = (‚Ñù, ‚Ñù), ùëå = (‚Ñù, ‚Ñù) and ùëç = (‚Ñù3, ‚Ñù), which
connected in the depicted way form the composite interface ùê¥ = (‚Ñù3, ‚Ñù). Al-
though ùê¥‚Äôs inputs and outputs are to the ‚Äúoutside world,‚Äù they could also poten-
tially interconnect to other boxes themselves.

To implement the above as a morphism in the category W, we first ‚Äúalign‚Äù the
boxes such that the wires follow their input and output (figure 2.2b), which then
forms a morphism from the tensor product of the three boxes ùëã ‚äó ùëå ‚äó ùëç (the

Category theory for the mathematical engineer

40

ùëã

ùëå

‚Ñù

‚Ñù

ùê¥

ùëç

‚Ñù

‚Ñù

‚Ñù

‚Ñù

(a) A zoomed-in picture of a process A.

ùë§

ùë¢

ùë£

ùëã

ùëå

ùëç

ùë•

ùë¶

ùëß

Figure 2.2: An example wiring diagram as a morphism in the category W.

(b) View as a wiring diagram.

dotted box) with input ‚Ñù5 and output ‚Ñù3, to the outside box A = (‚Ñù3, ‚Ñù) with
explicit description

(ùëã‚äóùëå ‚äóùëç)out
‚èû‚é¥‚é¥‚èû‚é¥‚é¥‚èû
‚Ñù √ó ‚Ñù √ó ‚Ñù √ó

ùê¥in
‚èû‚é¥‚é¥‚èû‚é¥‚é¥‚èû
‚Ñù √ó ‚Ñù √ó ‚Ñù ‚Üí

(ùëã‚äóùëå ‚äóùëç)in
‚èû‚é¥‚é¥‚é¥‚é¥‚é¥‚èû‚é¥‚é¥‚é¥‚é¥‚é¥‚èû
‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù,

ùëìin ‚à∂

(ùë•, ùë¶, ùëß, ùë§, ùë¢, ùë£) ‚Ü¶ (ùë§, ùë¢, ùë•, ùë¶, ùë£)

ùëìout ‚à∂ ‚Ñù √ó ‚Ñù √ó ‚Ñù
‚èü‚éµ‚éµ‚èü‚éµ‚éµ‚èü
(ùëã‚äóùëå ‚äóùëç)out

,

‚Üí ‚Ñù‚èü
ùê¥out

(ùë•, ùë¶, ùëß) ‚Ü¶ ùëß

‚éß
‚é™
‚é™
‚é™

‚é®
‚é™
‚é™
‚é™
‚é©

.

(2.3)

The two functions, ùëìin and ùëìout, specify which wires are connected to which; ùëìin
maps the three internal outputs ùë•, ùë¶, ùëß together with the external inputs ùë§, ùë¢, ùë£
to the internal inputs, in the order determined by our, and ùëìout projects out of
the three internal outputs ùë•, ùë¶, ùëß the third one ùëß. We could choose a different
alignment of the internal boxes, which would result to a different, but essentially
equivalent, pair of functions. This would not affect our analysis.

To sum up, the category W provides a formal way of mathematically expressing
any configuration at hand, with sole focus on the interconnection of vacant build-
ing blocks. The rest of this dissertation uses these fundamental constructions of
categories, functors, and natural transformations in general and the wiring dia-

Category theory for the mathematical engineer

41

gram formalism in particular to develop and equip algebras for verifying the com-
position and formal relationship between requirements, behavioral models, and
system architectures.

Category theory for the mathematical engineer

42

Algebra is to the geometer what
you might call the Faustian offer.

‚Äî Michael Atiyah

3 Compositional systems modeling

We use the categorical formalism to unify between the disparate but necessary
models used to assure correctness in cyber-physical systems, including require-
ments, system behaviors, and system architectures. Currently, these views are
largely managed in an informal, piecemeal fashion, with no notion of formal trace-
ability between different types of models, which could lead to designing and imple-
menting systems that are ultimately unsafe due to inconsistencies between these
three views. Model-based design attempts to address some of the aforementioned
issues, but while it contains a notion of formal composition within each model
view, it lacks a notion of formal composition between different model types.

The need for compositional theories to support the design of cyber-physical sys-
tems is a consistent theme in cyber-physical systems literature both in the general
modeling sense¬†[32] and particularly in contract-based design¬†[30, 132]. First, the
model-based design of cyber-physical systems can be greatly assisted by the com-
position of different types of models, which would provide traceability between
the coupled physical and computational dynamics present in cyber-physical sys-
tems¬†[5]. Second, the application of formal composition makes precise abstrac-
tion and refinement, which are necessary in model-based engineering¬†[145]. Third,
by investing in a compositional modeling paradigm we are better able to identify
unsafe or uncontrolled interactions between subsystems¬†[147]. Category theory
and the wiring diagram formalism¬†[156] provide an appealing framework to build
and analyze compositional models of cyber-physical systems.

44

Wiring diagrams are a particularly interesting example of the congruence between
category theory and model-based design. Wiring diagrams have been indepen-
dently created by category theorists [146, 157, 165] but surprisingly look and feel
similar to engineering block diagrams used as the basis diagrammatic framework
for modeling, for example, the unified modeling language (uml), the systems
modeling language (SysML), the generic modeling environment (gme), and a
variety of tools from Mathworks including Simulink. These types of diagrams
are increasingly part of various research directions in cyber-physical systems, for
example the Ptolemy project¬†[36] or M√∂bius¬†[115]. Systems engineering is a dis-
cipline where diagrammatic reasoning has long been considered an important el-
ement in managing complexity. But several challenges persist, for example using
SysML for the analysis of systems designs means a scarcity of simulation capabil-
ities, an increased modeling effort to capture different views of the system, and
the need to maintain all these differing views concurrently even as they evolve
asynchronously. While the approach using wiring diagrams has little tool support
currently, as an intellectual framework they overcome these limitations by aug-
menting this diagrammatic reasoning with stronger mathematical semantics.

The general phases of system design are often implicitly compositional.

Requirements describe the what‚Äôs or inentions of system designers. They may
include the purpose of the systems the compose the whole as well as the
functions. Requirements are drafted early and modified throughout the sys-
tem lifecycle and they are used to create the architecture and the compo-
nents of the system.

Specification describes the how‚Äôs; that is, it gives a precise definition on the
what‚Äôs and serves as the contract between customer and system designers.

Architecture desribes the framework of the how‚Äôs, meaning how the system imple-
ments those specified functions. It includes a plan for the overall structure

Compositional systems modeling

45

of the system that will be used later to design the components that make up
the architecture.

Realization is the component design or selection. The component design effort
builds the components in conformance to the architecture and specifica-
tion, which often include both hardware and software modules.

System integration is a methodical process of realizing the architecture plan, in-
cluding how to implement concretely the functional behavior that then can
be tested for issues between requirements.

In this work we will go as far as architecture in the methodology and not consider
realization or system integration. Although, we have indication that the categor-
ical framework can assist with control and program synthesis that would tie all
parts of design together, we leave that as future work.

3.1 Modeling cyber-physical systems compositionally

Assessing the correct behavior of cyber-physical systems requires several model
views. Before discussing them, we must first clarify the meaning of the terminol-
ogy that we will use. We choose to use the terminology of requirements, system be-
havior, and system architecture to describe the different diagrammatic abstractions
of cyber-physical system models. We define requirements as constraints over sys-
tem behavior and system architecture.1 By system behavior we mean models of
the form of automata or state space models that describe the systems states‚Äôs evo-
lution. By system architecture we mean models of candidate implementations
that, in the case of cyber-physical systems, include hardware and software for
the embedded system portion of the cyber-physical system and motors, control

1 Requirements don‚Äôt only define constraints. There are permissible (what the system ought to
do) and restrictive (what the system ought not to do) types of requirements. We can capture
both in the contract framework but safety is associated with constraints so we will focus on that.

Compositional systems modeling

46

surfaces, actuators, and mechanical structure for the physical portion of the cyber-
physical system. In the following formalism in general, we will view the individ-
ual diagram pictures as architecture, and the particular semantics that go into
the boxes within this diagram as behavior, omitting the leading word ‚Äôsystem‚Äô
when only discussing about the diagrammatic representation. Contracts that con-
straint both behavior and architecture in this sense will represent a subset of sys-
tem safety requirements.

The categorical approach has the advantage of providing a compositional model-
ing and analysis, in which the composite system is completely and uniquely deter-
mined from its subsystems and their interconnections. This is achieved through
the implementation of the formalism in two parts. The first is a behavior algebra
that allows the hierarchical modeling between the abstraction of system behav-
ior and system architecture, in a zoom-in, zoom-out approach¬†[168], where each
view may have distinct inputs and outputs. The second is a contract algebra that
computes safety constraints to the system behavior.

An analogously high-level approach using monoidal categories and compositional
techniques has already found success in categorical quantum mechanics¬†[2, 44],
where it has become the de facto language to describe and manipulate quantum
processes diagrammatically. We posit that a similar innovation should take place
in the design and assessment of safety-critical cyber-physical systems, due to the
concerns raised by the intertwined nature of digital control with physical pro-
cesses and the environment. We will view distinct but related system models, per-
tinent to assuring the correct behavior of cyber-physical systems, as algebras of the
monoidal category of wiring diagrams.

The wiring diagram approach diverges from input-output models. While the dia-
grammatic syntax looks similar to such models, what is contained within the boxes
need not be a mathematical function. It can instead be any sort of process, from
very concrete descriptions like automata, to more abstract processes which could
be deterministic or non-deterministic, to mere requirements of a mathematically

Compositional systems modeling

47

unknown formula. Similarly, the arrows do not need to contain one piece of infor-
mation, for example the input and output of a function; rather, arrows can carry
arbitrary objects of a chosen category of types. Previous compositional modeling
methods for cyber-physical systems are often limited to sets and functions or in
the most general sense, relations. However, the state space of a controls system
need not be the set ‚Ñùùëõ, but could instead be a topological space like the line or
circle ùïä. The rich interplay between topology and category theory positions cate-
gory theory as a particularly good candidate for modeling dynamics, for example
see Hansen and Ghrist¬†[69] or earlier, in the more related area of hybrid systems,
Ames¬†[9] and Tabuada et al.¬†[162, 163].

3.2 System behavior via algebras on the category W

The category of wiring diagrams does not populate the boxes with actual systems,
for example, dynamical systems. This is instead done by developing extra struc-
ture on top of the boxes. By knowing the configuration of the component systems,
the behavior of the composite system can then be uniquely determined.

Categorically, this is described as an algebra on W (definition 2.2.1), namely a
lax monoidal functor ùêπ ‚à∂ (W, ‚äó, ùêº) ‚Üí (Cat, √ó, 1). The idea is that each algebra
assigns to a box ùëã = (ùëãin, ùëãout) a category ùêπùëã of systems that can be placed in the
box, and also assigns to a wiring diagram ùëì = (ùëìin, ùëìout) a functor ùêπùëì ‚à∂ ùêπùëã ‚Üí ùêπùëå
that, given a system ùë† inhabiting the internal box of a wiring diagram, produces the
composite system ùêπ(ùëì)(ùë†) inhabiting the external box.

ùêπ ‚à∂ W

ùëã=(ùëãin, ùëãout)
ùëì

ùëå =(ùëåin, ùëåout)

Cat

ùêπùëã

subsystems category

ùêπ(ùëì)

composite system functor

ùêπùëå

ùêπ(ùëì)ùë†‚ààùêπùëå

ùë†‚ààùêπùëã

Intuitively, the object assignment ùêπùëã and ùêπùëå gives semantics to arbitrary boxes
through the subsystems category while the composite system functor ùêπùëì assem-

Compositional systems modeling

48

bles the composite operations of the overall system behavior. The monoidal struc-
ture of the functor via the laxator ùúôùëã,ùëå ‚à∂ ùêπùëã √ó ùêπùëå ‚Üí ùêπ(ùëã ‚äó ùëå ) ensures that
for given systems inside parallely placed boxes, we can always determine a system
inhabiting their tensor product

ùúô(ùë†,ùë°)‚ààùêπ(ùëã‚äóùëå)

ùë†‚ààùêπùëã

ùë°‚ààùêπùëå

The categorical formulation allows us to use a number of algebras according to our
purposes. Below we describe two such algebras of discrete dynamical systems,
and later we will examine the algebra of contracts (chapter 4). There exist also
other algebras, describing systems behaviors that are not like difference equations,
such as, algebras for abstract total or deterministic machines¬†[156].

The diagrammatic representation via wiring diagrams for system modeling and
analysis is rather straightforward, particularly because wiring diagrams are simi-
lar to engineering block diagrams and, hence, the visual syntax is equivalent to
existing cyber-physical systems design tools. However, the current diagrammatic
representation is mathematically richer and more concrete‚Äîit also accounts for
actual composition computations as we will see below. Another important factor
specifically for cyber-physical systems is the richness of other possible algebras or
semantics that one can develop and assign in these boxes backed up by the notion
of the monoidal category.

3.2.1 moore machines

As an illustrative example on how to develop and use the behavior algebra on
an architecture in W, we will position the familiar Moore machines inside the
boxes ùëã, ùëå and ùëç of figure 2.2a. This is a simple yet useful demonstration of the
algebra machinery because Moore machines model discrete dynamical systems.
To concretely describe the systems composite, we first need to verify that Moore

Compositional systems modeling

49

machines form a W-algebra. Indeed, there is a monoidal functor

‚Ñ≥ ‚à∂ W ‚Üí Cat

which maps each (ùëãin, ùëãout) to the category ‚Ñ≥(ùëãin, ùëãout) where

‚Ä¢

objects are triples (ùëÜ, ùë¢, ùëü) where ùëÜ is the state space set, ùë¢ ‚à∂ ùëÜ √ó ùëãin ‚Üí ùëÜ is
the update function and ùëü ‚à∂ ùëÜ ‚Üí ùëãout is the readout function;

‚Ä¢ morphisms (ùëÜ, ùë¢, ùëü) ‚Üí (ùëÜ‚Ä≤, ùë¢‚Ä≤, ùëü‚Ä≤) are functions ùëì ‚à∂ ùëÜ ‚Üí ùëÜ‚Ä≤ between the
state spaces that commute with the update and readout functions, namely
ùëì(ùë¢(ùë†, ùë•)) = ùë¢‚Ä≤(ùëìùë†, ùë•) and ùëì(ùëü(ùë†)) = ùëü‚Ä≤(ùëìùë†).

Hence, ‚Ñ≥(ùëãin, ùëãout) this is the category of Moore machines with fixed input and
output alphabet ùëãin and ùëãout respectively. For example, an object of the category
ùëÄ({0, 1}, {0, 1}) with inputs and outputs the booleans, is the ‚Äúnot‚Äù finite state
machine

1

ùë†1
0

0

1

0

ùë†2
1

with state space ùëÜ = {ùë†1, ùë†2} and update and readout functions depicted in the
above state diagram, for example, ùë¢(ùë†1, 0) = ùë†2 (middle top edge) and ùëü(ùë†2) = 1
(bottom part of ùë†2-node).

Having defined the categories of systems that can inhabit boxes in wiring dia-
gram pictures for this specific Moore machine model, we proceed to define the
composite system functor ‚Ñ≥(ùëì) ‚à∂ ‚Ñ≥ùëã ‚Üí ‚Ñ≥ùëå , given a wiring diagram ùëì =
(ùëìin, ùëìout) ‚à∂ ùëã ‚Üí ùëå . Explicitly, this functor maps a Moore machine (ùëÜ, ùë¢, ùëü) with
input and output ùëãin, ùëãout to a Moore machine (ùëÜ, ùë¢‚Ä≤, ùëü‚Ä≤) with input and output

Compositional systems modeling

50

ùëåin, ùëåout having the same state space ùëÜ, but with new update and readout functions
formed as follows

ùë¢‚Ä≤ ‚à∂ ùëåin √ó ùëÜ ‚Üí ùëÜ,
ùëü‚Ä≤ ‚à∂ ùëÜ ‚Üí ùëåout,

ùë¢‚Ä≤(ùë¶, ùë†) = ùë¢(ùëìin(ùë¶, ùëü(ùë†)), ùë†)

(3.1)

ùëü‚Ä≤(ùë†) = ùëìout(ùëü(ùë†))

Finally, we need to specify the monoidal structure of ‚Ñ≥ by providing functors
‚Ñ≥(ùëã) √ó ‚Ñ≥(ùëå ) ‚Üí ‚Ñ≥(ùëã ‚äó ùëå ). Given two Moore machines (ùëÜùëã, ùë¢ùëã ‚à∂ ùëãin √ó ùëÜùëã ‚Üí
ùëÜùëã, ùëüùëã ‚à∂ ùëÜùëã ‚Üí ùëãout) and (ùëÜùëå , ùë¢ùëå ‚à∂ ùëåin √ó ùëÜùëå ‚Üí ùëÜùëå , ùëüùëå ‚à∂ ùëÜùëå ‚Üí ùëåout), we con-
struct a new Moore machine with space set ùëÜùëã √ó ùëÜùëå and update and readout
functions

ùë¢ ‚à∂ ùëãin √ó ùëåin √ó ùëÜùëã √ó ùëÜùëå ‚Üí ùëÜùëã √ó ùëÜùëå ,

ùë¢(ùë•, ùë¶, ùë†, ùë°) = (ùë¢ùëã(ùë•, ùë†), ùë¢ùëå (ùë¶, ùë°))

(3.2)

ùëü ‚à∂ ùëÜùëã √ó ùëÜùëå ‚Üí ùëãout √ó ùëåout,

ùëü(ùë†, ùë°) = (ùëüùëã(ùë†), ùëüùëå (ùë°))

It can been be verified that with the above assignments, Moore machines satisfy
the axioms of a wiring diagram algebra [156, ¬ß2.3]. We can therefore arbitrarily in-
terconnect such systems, in particular as in figure 2.2a, and produce a new such
system with a description only in terms of its components and their wiring. Sup-
ùëç , all with ‚Ñù-valued
pose we have Moore machines in the boxes ùëã , ùëå ,
wires, with state spaces ùëÜùëã, ùëÜùëå and ùëÜùëç and update and readout functions respec-
tively as in

{

ùëÜùëã √ó ‚Ñù

ùë¢ùëã‚àí‚àí‚Üí ùëÜùëã

ùëüùëã‚àí‚àí‚Üí ‚Ñù

ùëÜùëã

{

ùëÜùëå √ó ‚Ñù

ùë¢ùëå‚àí‚àí‚Üí ùëÜùëå

ùëüùëå‚àí‚àí‚Üí ‚Ñù

ùëÜùëå

{

ùë¢ùëç‚àí‚àí‚Üí ùëÜùëç

ùëÜùëç √ó ‚Ñù3
ùëüùëç‚àí‚Üí ‚Ñù.

ùëÜùëç

The algebra machinery described in formulas (3.1) and (3.2) for the specific wiring
diagram 2.3 produces the composite Moore machine which inhabits the outer box
ùê¥ with state space ùëÜùëã √ó ùëÜùëå √ó ùëÜùëç, readout function ùëü ‚à∂ ùëÜùëã √ó ùëÜùëå √ó ùëÜùëç ‚Üí ‚Ñù
given by (ùë†, ùë°, ùëù) ‚Ü¶ ùëüùëç(ùëù) and update function ùëÜùëã √óùëÜùëå √óùëÜùëç √ó‚Ñù3 ‚Üí ùëÜùëã √óùëÜùëå √óùëÜùëç
given by

(ùë†, ùë°, ùëù, ùë§, ùë¢, ùë£) ‚Ü¶ (ùë¢ùëã(ùë†, ùë§), ùë¢ùëå (ùë°, ùë¢), ùë¢ùëç(ùëù, ùëüùëã(ùë†), ùëüùëå (ùë°), ùë£)) .

Compositional systems modeling

51

In general, the composite system is produced using the algebra machinery, no
matter how complicated the systems or the wiring diagram is: given any type-
respecting interconnection involving arbitrary feedback loops or parallel/serial
arrangements, the monoidal functor will determine a result. Therefore, this func-
toriality alleviates some of the scalability issues present in other formalisms. As
we will see later, often some pre-existing knowledge of the desired behavior of
a composite system can possibly inform not only the components‚Äô behavior but
also the choice of wiring.

3.2.2 linear time-invariant systems

There is a sub-algebra of the algebra of Moore machines, for linear time-invariant
systems or linear discrete dynamical systems per Spivak¬†[156]. In fact, the Moore
machines model is an algebra of WSet, where the types of wires are sets and the
wiring diagrams are given by functions, whereas the linear time-invariant system
model is an algebra of WLin, where the types are given by Lin, the category of
linear spaces and linear maps.

Explicitly, there is a monoidal functor ‚Ñí ‚à∂ WLin ‚Üí Cat that assigns to any box
ùëãout a category ‚Ñí(ùëãin, ùëãout) of systems (ùëÜ, ùë¢ ‚à∂ ùëÜ √ó ùëãin ‚Üí ùëÜ, ùëü ‚à∂ ùëÜ ‚Üí ùëãout)
ùëãin
like before, but where all ùëÜ, ùëãin, ùëãout are linear spaces and both update and readout
functions ùë¢ and ùëü are linear functions expressed as

ùë¢(ùë†, ùë•) = ùíú ‚ãÖ ùë† + ‚Ñ¨ ‚ãÖ ùë• = (ùíú ‚Ñ¨) (

ùë†
ùë•

)

ùëü(ùë†) = ùíû ‚ãÖ ùë†

where ùíú, ‚Ñ¨ and ùíû are matrices of appropriate dimension. For example, if the
input, output and state spaces are ùëãin = ‚Ñùùëò, ùëãout = ‚Ñù‚Ñì and ùëÜ = ‚Ñùùëõ, then

ùíú ‚àà ùëõùëÄùëõ

‚Ñ¨ ‚àà ùëõùëÄùëò

ùíû ‚àà ‚ÑìùëÄùëõ

‚éß
‚é™

‚é®
‚é™
‚é©

represents a linear transformation ‚Ñùùëõ ‚Üí ‚Ñùùëõ

represents a linear transformation ‚Ñùùëò ‚Üí ‚Ñùùëõ

(3.3)

represents a linear transformation ‚Ñùùëõ ‚Üí ‚Ñù‚Ñì.

Compositional systems modeling

52

Now given an arbitrary wiring diagram ùëì = (ùëìin, ùëìout) ‚à∂ (ùëãin, ùëãout) ‚Üí (ùëåin, ùëåout)
as formalized in the system of equations (2.1a), where for ùëåin = ‚Ñùùëò‚Ä≤
and ùëåout =
‚Ñù‚Ñì‚Ä≤
both linear functions of the wiring diagram are also expressed as correspond-
ùëò(‚Ñ¨ùëì)ùëò‚Ä≤) and ùëìout = ‚Ñì‚Ä≤ùíûùëì
ing matrices ùëìin = (ùëò(ùíúùëì)‚Ñì
‚Ñì , the functor ‚Ñí(ùëì) maps
some system (ùëÜ, ùíú, ‚Ñ¨, ùíû) in
‚Ñù‚Ñì to the system
ùëã‚Ñùùëò

(ùëÜ, ùíú + ‚Ñ¨ ‚ãÖ ùíúùëì ‚ãÖ ùíû, ‚Ñ¨ ‚ãÖ ‚Ñ¨ùëì, ùíûùëì ‚ãÖ ùíû)

(3.4)

ùëå

‚Ñùùëò‚Ä≤

in
‚Ñù‚Ñì‚Ä≤. The earlier-used term sub-algebra precisely means that this formula
is a special case of equation (3.1) when the functions involved are of this specific
form.

Finally, the monoidal structure of this assignment ‚Ñí ‚à∂ WLin ‚Üí Cat is given by
functors ‚Ñí(ùëã)√ó‚Ñí(ùëå ) ‚Üí ‚Ñí(ùëã ‚äóùëå ) that map any two systems (ùëÜùëã, ùíúùëã, ‚Ñ¨ùëã, ùíûùëã)
and (ùëÜùëå , ùíúùëå , ‚Ñ¨ùëå , ùíûùëå ) inhabiting parallel boxes as in wiring diagram (2.2) give
rise to a parallel composite system

(ùëÜùëã √ó ùëÜùëå , (

ùíúùëã
0
0 ùíúùëå

) , (

‚Ñ¨ùëã
0
0 ‚Ñ¨ùëå

) , (

ùíûùëã
0
0 ùíûùëå

)) .

3.2.3 functions (as a non-example)

If we would like to populate the boxes of a wiring interconnection with mathemat-
ùëãout a function ‚Ñé ‚à∂ ùëãin ‚Üí ùëãout, there
ical functions, namely assign to some
is no natural way to make this assignment into an algebra W ‚Üí Cat. The main
reason this fails is the existence of the feedback loop.

ùëãin

ùëã

However, we can incorporate functions into other existing models, for example
Moore machines. It is possible to express a function ‚Ñé ‚à∂ ùëãin ‚Üí ùëãout as an object of
‚Ñ≥(ùëãin, ùëãout), with state space the domain ùëãin and update and readout functions
ùúã2 ‚à∂ ùëãin √ó ùëãin ‚Üí ùëãin projecting the second variable and ‚Ñé ‚à∂ ùëãin ‚Üí ùëãout applying
the said function. The resulting finite state machine at each round replaces the old
input with the new input, and outputs the function application on it. Analogously,
a linear function can be viewed as a linear time-invariant system if we set ùíú = 0

Compositional systems modeling

53

the zero matrix, ‚Ñ¨ = ùêº the unit matrix and ùíû = ‚Ñé the matrix represents the given
linear transformation.

As a result, functions can be indeed used to populate boxes, and wired with other
functions or Moore machines they produce a composite Moore machine using the
algebra ‚Ñ≥ ‚à∂ W ‚Üí Cat. It is also the case that sometimes, wiring two functions us-
ing the Moore machine algebra machinery, we end up with another function and
not a more general Moore machine‚Äîthis usually happens in serial-like wirings
without loops.

The take away message of these examples is the following: the starting point is the
category of wiring diagrams W with no processes inside the boxes. We can then
assign the behavior of Moore machines inside the boxes using the corresponding
W-algebra ‚Ñ≥, or the behavior of linear discrete dynamical systems using the sub-
algebra of linear time-invariant systems ‚Ñí, which recovers the standard model
of state-space representation in control albeit with a slightly different syntax. By
composing behaviors this way, we recover a block-diagonal state space model, a
useful representation for modeling the control portion of cyber-physical systems.

3.2.4 compositional state-space models

At the moment, we have illustrated a couple of examples of behavioral models
that can inhabit the boxes, but the algebraic machinery is not limited by those.
We could, for example, inhabit the boxes with hybrid systems, while at the same
time ensuring composition. In the absence of the time element, behaviors are to
be observed in an instantaneous way, for example, feedback loops do not produce
delay effects. Such issues shall be tackled when the wires carry time-sensitive
data.

We algebraically recover a standard controls model compositionally in the behavior
algebra of the form

ùë†ùëò+1 = ùíúùë†ùëò + ‚Ñ¨ùëêùëò,

Compositional systems modeling

54

ùëí

‚Ñù

ùëë

‚Ñù

‚Ñù

Sensor
ùêø

ùë†‚Ä≤

‚Ñù

‚Ñù

Controller
ùê∂

ùëê

Dynamics
ùê∑

ùë†

‚Ñù

ùëí

ùëë

ùë†‚Ä≤

ùëê

ùë†

ùêø

ùê∂

ùê∑

uav

ùëìin ‚à∂ ‚Ñù3 √ó ‚Ñù2 ‚Üí ‚Ñù5, (ùë†‚Ä≤, ùëê, ùë†, ùëí, ùëë) ‚Ü¶ (ùë†, ùëí, ùë†‚Ä≤, ùëë, ùëê)
ùëìout ‚à∂ ‚Ñù3 ‚Üí ‚Ñù, (ùë†‚Ä≤, ùëê, ùë†) ‚Ü¶ ùë†

Figure 3.1: The physical decomposition of the uav, where ùëë denotes the desired state, ùë†‚Ä≤ the
predicted state, ùëê the control action, ùë† the current state, and ùëí the environmental inputs.

‚Ä¢
where ùë†ùëò ‚àà ‚Ñùùëõ is the discrete time state, ùë†ùëò+1 (also denoted
ùë† or ùë¢(ùë†, ùëê) using the
earlier update function notation) is the subsequent time-step state and ùëêùëò ‚àà ‚Ñùùëõ
is the control signal/output, and

is the measurement, which is also in ‚Ñùùëõ. We assume ùíü = 0.

ùë¶ùëò = ùíûùë†ùëò + ùíüùëêùëò

We are going to illustrate the algebra machinery using longitudinal equations of
motion for a fixed-winged aircraft represented in the following state-space model¬†[119]

‚Ä¢
ùëé
‚éû
‚éõ
‚Ä¢
‚éü
‚éú
ùëû
‚éü
‚éú
‚éü
‚éú
‚Ä¢
ùúÉ
‚é†
‚éù

=

56.7

0
‚àí0.313
‚éõ
‚éú
‚àí0.0139 ‚àí0.426 0
‚éú
0
‚éù

56.7

0

ùëé
‚éõ
‚éú
ùëû
‚éú
ùúÉ
‚éù

‚éû
‚éü
‚éü
‚é†

‚éû
‚éü
‚éü
‚é†

+

0.232
‚éû
‚éõ
‚éü
‚éú
0.0203
‚éü
‚éú
0
‚é†
‚éù

(ùõø)

(3.5)

ùë¶ = (0 0 1)

ùëé
‚éû
‚éü
ùëû
‚éü
ùúÉ
‚é†

‚éõ
‚éú
‚éú
‚éù

,

where ùëé is the angle of attack, ùëû is the pitch rate, ùúÉ is the pitch angle and ùõø is
the elevator deflection angle. This behavior is the composite one, built up from the
subcomponents behavior and their wiring (figure 3.1).

Compositional systems modeling

55

Working with the linear time-invariant system algebra ‚Ñí ‚à∂ WLin ‚Üí Cat (section
3.2.2), suppose (ùëÜùêø, ùíúùêø, ‚Ñ¨ùêø, ùíûùêø), (ùëÜ ùê∂, ùíúùê∂, ‚Ñ¨ùê∂, ùíûùê∂) and (ùëÜùê∑, ùíúùê∑, ‚Ñ¨ùê∑, ùíûùê∑) are
three linear systems inhabiting the respective boxes of figure 3.1, with

ùë¢ùêø(ùë†ùêø, ùë†, ùëí) =ùíúùêø ‚ãÖ ùë†ùêø + ‚Ñ¨ùêø ‚ãÖ (ùë†, ùëí)
ùë¢ùê∂(ùë†ùê∂, ùëë, ùë†‚Ä≤) =ùíúùê∂ ‚ãÖ ùë†ùê∂ + ‚Ñ¨ùê∂ ‚ãÖ (ùëë, ùë†‚Ä≤)
ùë¢ùê∑(ùë†ùê∑, ùëê) =ùíúùê∑ ‚ãÖ ùë†ùê∑ + ‚Ñ¨ùê∑ ‚ãÖ (ùëê)

ùëüùêø(ùë†ùêø) =ùíûùêø ‚ãÖ ùë†ùêø

ùëüùê∂(ùë†ùê∂) =ùíûùê∂ ‚ãÖ ùë†ùê∂

ùëüùê∑(ùë†ùê∑) =ùíûùê∑ ‚ãÖ ùë†ùê∑.

Using the algebra machinery for the specific wiring diagram (figure 3.1) given by
matrix transformations

ùëìin =

0 0 1 0 0
‚éõ
‚éú
0 0 0 1 0
‚éú
‚éú
1 0 0 0 0
‚éú
‚éú
0 0 0 0 1
‚éú
0 1 0 0 0
‚éù

‚éû
‚éü
‚éü
‚éü
‚éü
‚éü
‚éü
‚é†
ùëìout = (0 0 1) = ùíûùëì

‚éß
‚é™
‚é™
‚é™
‚é™

‚é®
‚é™
‚é™
‚é™
‚é™
‚é©

= (5(ùíúùëì)3

5(‚Ñ¨ùëì)2)

we can compute the composite linear dynamical system that inhabits the box uav
from formula (3.4). Its state space is ùëÜùêø √ó ùëÜ ùê∂ √ó ùëÜùê∑, and its update and readout
linear functions are

ùë¢uav ‚à∂ ùëÜùêø √ó ùëÜ ùê∂ √ó ùëÜùê∑ √ó ‚Ñù2 ‚Üí ùëÜùêø √ó ùëÜ ùê∂ √ó ùëÜùê∑,

(ùë†ùêø, ùë†ùê∂, ùë†ùê∑, ùëë, ùëí) ‚Ü¶ (ùíúùêøùë†ùêø + ‚Ñ¨ùêø (

ùíûùê∑ùë†ùê∑
ùëí

) ,

ùíúùê∂ùë†ùê∂ + ‚Ñ¨ùê∂ (

ùíûùêøùë†ùêø
ùëë

) ,

ùíúùê∑ùë†ùê∑ + ‚Ñ¨ùê∑ùíûùê∂ùë†ùê∂)

ùëüuav ‚à∂ ùëÜùêø √ó ùëÜ ùê∂ √ó ùëÜùê∑ ‚Üí ‚Ñù

(ùë†ùêø, ùë†ùê∂, ùë†ùê∑) ‚Ü¶ ùíûùê∑ùë†ùê∑.

Compositional systems modeling

56

We assume, for simplicity, that the state spaces of the sensor and controller are in
‚Ñù2. Knowing that only the dynamics ùê∑ actually relate to the triplet (ùëé, ùëû, ùúÉ), we
deduce that ùëÜùê∑ is in ‚Ñù3 which results in a composite state space ùëÜuav in ‚Ñù2 √ó‚Ñù2 √ó
‚Ñù3 ‚âÖ ‚Ñù7. Moreover, from the shape of the boxes according to formula (3.4) we
deduce that the matrices ùíúùêø, ùíúùê∂, ‚Ñ¨ùêø and ‚Ñ¨ùê∂ are two-by-two, ùíûùêø and ùíûùê∂ are
one-by-two, whereas ùíúùê∑ is three-by-three, ‚Ñ¨ùê∑ is three-by-one and ùíûùê∑ is one-by-
three.

Unraveling the above update and readout functions of the composite linear time-
invariant system denoted by uav, the only output of the composite system behav-
ior is that of the dynamics ùê∑, because by formula (3.4)

ùíûuav = ùíûùëì ‚ãÖ ùíûùêø‚äóùê∂‚äóùê∑ = (0 0 1(ùíûùê∑)3) .

Hence for obtaining equation (3.5), in the specific example we deduce that ùíûùê∑ =
(0 0 1) meaning only ùúÉ is output to the outside world as desired.

For an element of the state space ‚Ñù7 of the form ( ‚Éóùë†ùêø,
two variables we obtain

‚Éóùë†ùê∑

‚Éóùë†ùê∂,

‚èûùëé, ùëû, ùúÉ), isolating the first

‚Ä¢
‚Éóùë†ùêø= ùíúùêø ‚Éóùë†ùêø + 2(‚Ñ¨ùêø)2 (

ùúÉ

‚èûùíûùê∑ ‚Éóùë†ùê∑
ùëí

) and

‚Ä¢
‚Éóùë†ùê∂= ùíúùê∂ ‚Éóùë†ùê∂ + 2(‚Ñ¨ùê∂)2 (

ùíûùêø ‚Éóùë†ùêø
ùëë

) ,

which could be viewed as some extra information of the composite system relating
to the behaviors of the sensor and controller, not appearing in equation (3.5) but
still part of the total system‚Äôs behavior.

Now isolating the last three variables we obtain a description

‚Ä¢
ùõº
‚éõ
‚Ä¢
‚éú
ùëû
‚éú
‚éú
‚Ä¢
ùúÉ
‚éù

‚éû
‚éü
‚éü
‚éü
‚é†

= 3(ùíúùê∑)3

ùõº
‚éû
‚éü
ùëû
‚éü
ùúÉ
‚é†

‚éõ
‚éú
‚éú
‚éù

+ 3(‚Ñ¨ùê∑)1ùíûùê∂ ‚Éóùë†ùê∂.

Compositional systems modeling

57

Comparing with the desired equation (3.5), the elevator deflection angle ùõø is the
output of the controller ùíûùê∂ùë†ùê∂ which matches the physical reality, and the ùíúùê∑,
‚Ñ¨ùê∑ are completely determined by the composite description, namely

ùíúùê∑ =

56.7

0
‚àí0.313
‚éõ
‚éú
‚àí0.0139 ‚àí0.426 0
‚éú
0
‚éù

56.7

0

‚éû
‚éü
‚éü
‚é†

‚Ñ¨ùê∑ =

0.232
‚éû
‚éõ
‚éü
‚éú
0.0203
‚éü
‚éú
0
‚é†
‚éù

.

The remaining data for ùíúùêø,ùê∂, ‚Ñ¨ùêø,ùê∂, ùíûùêø,ùê∂ depend on engineering and physical
parameters based on design choices.

We were thus able to partly reverse-engineer a given composite system behavior
described by equation (3.5), where for the given system architecture (figure 3.1)
we completely identified the behavior of the linear time-invariant system ùê∑ by
determining ùëÜùê∑, ùíúùê∑, ‚Ñ¨ùê∑, ùíûùê∑. We also obtained certain information about the
other two subcomponents ùê∂ and ùêø, for example, two possible behaviors could be
the linear functions (such as signal concatenations) ùë†‚Ä≤ = ùë† + ùëí for the sensor ùêø
and the linear function ùëê = ùë†‚Ä≤ + ùëë for the controller ùê∂. Expressing those as linear
time-invariant systems, we obtain the following description

(ùëÜùêø, ùíúùêø, ‚Ñ¨ùêø, ùíûùêø) = (‚Ñù2, (

0 0
0 0

) , (

1 0
0 1

) , (1 1)) ,

ùë¢ùêø( ‚Éóùë†ùêø, ùë†, ùëí) = (ùë† ùëí), ùëüùêø( ‚Éóùë†ùêø) = ùë†1

ùêø + ùë†2
ùêø

(ùëÜ ùê∂, ùíúùê∂, ‚Ñ¨ùê∂, ùíûùê∂) = (‚Ñù2, (

0 0
0 0

) , (

1 0
0 1

) , (1 1)) ,

ùë¢ùê∂( ‚Éóùë†ùê∂, ùë†‚Ä≤, ùëë) = (ùë†‚Ä≤ ùëë), ùëüùê∂( ‚Éóùë†ùê∂) = ùë†1

ùê∂ + ùë†2
ùê∂.

Then the composite system‚Äôs update function is explicitly computed, using for-

Compositional systems modeling

58

mula (3.4), as

‚éß
‚é™
‚é™
‚é™
‚é™
‚é™

‚é®
‚é™
‚é™
‚é™
‚é™
‚é™
‚é©

‚Ä¢
ùúÉ
‚Éóùë†ùêø= (

ùëí

)

‚Ä¢
‚Éóùë†ùê∂= (

ùêø + ùë†2
ùë†1
ùêø
ùëë

)

‚Ä¢
ùëé= ‚àí0.313ùëé + 56.7ùëû + 0.232ùë†1
‚Ä¢
ùëû= ‚àí0.0139ùëé ‚àí 0.426ùëû + 0.0203ùë†1
‚Ä¢
ùúÉ= 56.7ùëû

ùê∂ + 0.232ùë†2
ùê∂
ùê∂ + 0.0203ùë†2
ùê∂

ùê∂ and ùë†2

where ùë†1
ùê∂ are essentially the previous desired state ùë†‚Ä≤ and input ùëë, produc-
ing the deflection angle ùõø that appears in formula (3.5). The first two equations
give the functions of ùêø and ùê∂ (whose states are placeholders for their inputs at
each instance), whereas the last three give the dynamics ùê∑ as before. This shows
the interplay between what the system is sensing, what its desired operating state
is, and how it must react. If there were more information about the elevator de-
flection angle ùõø, that would restrict the possible behaviors for ùê∂ appropriately.

From a more categorical perspective, the above process is summarized as follows:
given an algebra ‚Ñí and a wiring diagram ùëì ‚à∂ ùêø‚äóùê∂‚äóùê∑ ‚Üí uav in WLin (figure 3.1),
as well as an object of the target category ‚Ñí(uav), namely a specific linear system
as in equation (3.5) inhabiting the outside box uav, the goal is to find an object
in the pre-image of the given system under the composite functor

‚Ñí(ùêø) √ó ‚Ñí(ùê∂) √ó ‚Ñí(ùê∑)

ùúôùêø,ùê∂,ùê∑
‚àí‚àí‚àí‚àí‚Üí ‚Ñí(ùêø ‚äó ùê∂ ‚äó ùê∑)

‚Ñí(ùëì)
‚àí‚àí‚àí‚Üí ‚Ñí(uav).

Such a problem certainly does not have a unique solution, namely a unique de-
scription of the three systems that form the composite, but for example in this
specific case due to the form the wiring diagram, the component system

(ùëÜùê∑, ùíúùê∑, ‚Ñ¨ùê∑, ùíûùê∑)

Compositional systems modeling

59

was completely determined by the composite behavior. Further work would aim
to shed light on possible shapes of wiring diagrams that have better identifiable
solutions under algebras of interest.

3.3 System architecture via hierarchical decomposition

We have shown how to model a behavioral response of the system as it pertains to
its physics. But how might we connect this behavioral understanding to a concrete
implementation, in particular how can we zoom-in on each of the boxes to create
an architectural implementation that will yield the wanted behaviors? Of course,
there is no one solution for how to implement a cyber-physical system, so how
might we categorically capture different architectural solution with an explicit re-
lationship to the wanted set of behaviors?

Starting with a cyber-physical system from a designer point of view, we now might
want to model a candidate system architecture. In general, decomposing a cyber-
physical system in certain sub-components and using a specific wiring between
them follows some choices based on the physical reality, experience, purpose and
access to particular components at the time. Having formalized an agnostic pro-
cess interface where various descriptions could live on as an object in the category
of wiring diagrams W, as well as arbitrary zoomed-in pictures of a system as a mor-
phism in W, we have now access to all necessary tools to realize the above system
architecture design process using the general notion of a slice category.

For any category C and a fixed object ùê∂ ‚àà C, the slice category C/ùê∂ has as objects
C-morphisms with fixed target ùê∂, for example ùëì ‚à∂ ùê¥ ‚Üí ùê∂, ùëî ‚à∂ ùêµ ‚Üí ùê∂, ‚ãØ. The
arrows in that category from some ùëì to some ùëî are C-morphisms ùëò ‚à∂ ùê¥ ‚Üí ùêµ
between the domains, making the formed triangle

ùê¥

ùëì

ùëò

ùê∂

ùêµ

ùëî

Compositional systems modeling

60

ùëã

ùê∑

ùêµ

ùê∂

ùê¥

ùëå

ùëç

Figure 3.2: A two-level zoomed-in picture of a process A.

commute, namely ùëî ‚àò ùëò = ùëì. This data forms a category, which also illustrates
the abstract nature of the initial category definition (definition 2.1.1): objects and
arrows can be of any sort (in this case objects are morphisms of a certain shape
in some fixed category, and arrows are also morphisms that satisfy a property) as
long as they satisfy the axioms of a category.

For our wiring diagram category W, where a morphism ùëì ‚à∂ ùëã ‚Üí ùëå can be thought
of as an implementation of an interface ùëå into sub-interface(s) ùëã wired in a specific
manner, the slice category W/ùëå of all arrows mapping into the chosen object ùëå
contains all possible design choices available to a system engineer. This formally
captures the possibility of implementing a system in multitudes of ways.

ùê¥

‚Ñù
‚Ñù
‚Ñù

Concretely, suppose we have a system with ‚Ñù3-inputs and ‚Ñù-outputs, namely in-
‚Ñù. How can we decompose it into sub-processes, and how
habiting a box
can they be interconnected to form the given system? All the possible decompo-
sitions can thus be thought of as the objects of the slice category W/ùê¥. For exam-
ple, (figure 2.2a) depicts one of these choices, namely the specific wiring diagram
ùëì ‚à∂ ùëã ‚äó ùëå ‚äó ùëç ‚Üí ùê¥.

Now suppose we make another implementation choice to further decompose the

Compositional systems modeling

61

box ùëã as in

ùëã

ùê∑

ùêµ

ùê∂

meaning we choose a specific wiring diagram ùëî ‚à∂ ùêµ ‚äó ùê∂ ‚äó ùê∑ ‚Üí ùëã. This consti-
tutes another level of zoom-in for the process in ùê¥, at least for the subcomponent
ùëã (figure 3.2). This allows us to implement the behavioral approach to modeling
systems by breaking the morphisms within the category of wiring diagrams into
any possible implementations. The implication of this statement is that eventu-
ally we might be able to synthesize actual hardware and software solutions using
composition along different model views. In this instance we show how a flavor
of formal requirements can be related to a behavioral model and finally to an ar-
chitecture, thereby putting all the pieces together for an algorithm that can syn-
thesize all this information into fabric. In terms of category theory this represents
the composite morphism ùëì ‚àò (ùëî ‚äó id ‚äó id), the dashed arrow in the following
commutative diagram

(ùêµ ‚äó ùê∂ ‚äó ùê∑) ‚äó ùëå ‚äó ùëç

ùëî‚äóid ‚äó id

ùëã ‚äó ùëå ‚äó ùëç

ùëì

ùê¥

where the top arrow uses the morphism ùëî as the implementation of ùëã and iden-
tity morphisms on ùëå and ùëç (as trivial implementations), and ùëì is the earlier ùê¥-
implementation (figure 2.2a). In the end, we can disregard the borders of the in-
terface ùëã and map directly from the subcomponents ùêµ ‚äóùê∂ ‚äóùê∑‚äóùëå ‚äóùëç to ùê¥ with-
out passing through ùëã at all if desired. As a result, we are free to use hierarchical
decomposition of processes for any sub-component (or for many simultaneously)
and each time, these architectural choices add one more composite morphism

Compositional systems modeling

62

Processor
ùëÉ2

ùê∂

Servos
ùëâ

ùêø

Processor
ùëÉ1

imu
ùêº1

imu
ùêº2

uav

ùê∑

Airframe
ùêπ

Aileron
ùëã

Rudder
ùëå

Throttle
ùëç

Elevator
ùëà

Figure 3.3: Any decomposition, including the previous one (figure 3.1) resides within the
slice category W/uav. In this case, the slice category contains all possible design decisions
that adhere to the behavioral model; we pick one such design choice.

to the resulting wiring diagram that expresses an implementation of the outmost
system process.

One of the important advantages of expressing system decompositions as a mor-
phism in the category W is that we can perform further zoomed-in decomposi-
tions as desired in a hierarchical way, and these are all realized as composite mor-
phisms in the wiring diagram category. We should examine here what we mean
by hierarchy in the context of system design. If we see the slice category as all pos-
sible architectural choices, we can also examine the opposite, namely that many
different architectures can relate to the same behavior. In that sense the behav-
ioral interpretation of the same concept is an authority level above and can be per-
ceived as a useful simplification of what all possible architectures could be. This
aligns with our normal understanding of hierarchy in system design [82] and it is
one way to make this process of simplification formally explicit.

For example, consider a possible uav architecture (figure 3.1). We may further
choose to implement the sensor box ùêø using two imu units ùêº1, ùêº2 and a processor
ùëÉ1 in a certain interconnection. Expressing this as a morphism with target ùêø (an
object in the slice category W/ùêø) namely ùëî ‚à∂ ùêº1 ‚äó ùêº2 ‚äó ùëÉ ‚Üí ùêø means that we can

Compositional systems modeling

63

compose this with the original one-level implementation ùëì to obtain a two-level
zoomed-in decomposition

(ùêº1 ‚äó ùêº2 ‚äó ùëÉ1) ‚äó ùê∂ ‚äó ùê∑

ùëî‚äóid ‚äó id
‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ùêø ‚äó ùê∂ ‚äó ùê∑

ùëì
‚àí‚Üí uav

that only ‚Äúopens-up‚Äù the box ùêø. We could moreover implement the control as
well as the dynamics box, and decompose them in a choice of subcomponents
and wires between them. An example where the control box is decomposed into
ùëÉ2 followed by ùëâ in a serial composition, and the dynamics box is decomposed into
four parallel boxes, ùëã, ùëå , ùëç and ùëä followed by ùêπ amounts to choosing a specific
‚Ñé ‚à∂ ùëÉ2 ‚äó ùëâ ‚Üí ùê∂ in W/ùê∂ and a specific ùëò ‚à∂ ùëã ‚äó ùëå ‚äó ùëç ‚äó ùëä ‚äó ùêπ ‚Üí ùê∑ in W/ùê∑.
Combining all these morphisms we have the composition (figure 3.3)

(ùêº1 ‚äó ùêº2 ‚äó ùëÉ1) ‚äó (ùëÉ2 ‚äó ùëâ) ‚äó (ùëã ‚äó ùëå ‚äó ùëç ‚äó ùëä ‚äó ùêπ)

ùëî‚äó‚Ñé‚äóùëò
‚àí‚àí‚àí‚àí‚àí‚Üí ùêø ‚äó ùê∂ ‚äó ùê∑

ùëì
‚àí‚Üí uav

that can be considered as a single morphism from the tensor of all second-level
sub-components to the box uav. Pictorially, this would be realized by erasing the
intermediate colored dashed boxes.

Compositional systems modeling

64

Finally, Stephen Albert said: ‚ÄúIn a guessing game to which
the answer is chess, which word is the only one prohibited?‚Äù
I thought for a moment and then replied: ‚ÄúThe word is chess.‚Äù

‚Äî Jorge Luis Borges

4 The algebra of safety contracts

The concept of a contract is another example of an algebra for the monoidal cat-
egory of labeled boxes and wiring diagrams W (definition 2.2.1). For any labeled
box ùëã = (ùëãin, ùëãout), a contract is defined to be a relation

ùëÖ ‚äÜ ùëãin √ó ùëãout

expressing the allowable tuples of input and output behaviors of a process. Such
a description is one among the most widespread abstract systems modeling no-
tions, see for example Mesarovic and Takahara¬†[118, ¬ß2]. We make a distinction
between the explicit defining process of a system; that is, the behavior assigned
to a wiring diagram, and the system behavior. However, abstractly a system is its
behavior and therefore modeling a system in the wiring diagram paradigm makes
those two notions equivalent. The distinction is however useful for separating the
behavior algebra from the contracts algebra, which are formally related but can be
used independently of each other.

4.1 Static contracts

The algebra of static contracts is a variation of the algebra originally developed
by Schultz et al.¬†[156, ¬ß4.5]. Explicitly, the functor ùíû ‚à∂ W ‚Üí Cat bound to ex-
press conditions on inputs and outputs in a time-less manner, assigns to a box
ùëãout the category ùíû(ùëãin, ùëãout) of binary relations; that is, subsets ùëñ ‚à∂ ùëÖ ‚Ü™

ùëãin

ùëã

66

ùëãin √ó ùëãout, with morphisms ùëì ‚à∂ ùëÖ ‚Üí ùëÉ being subset inclusions of the form

ùëãin √ó ùëãout

ùëÖ

ùëì

ùëÉ

For a given contract ùëÖùëã ‚äÜ ùëãin √ó ùëãout and a wiring diagram (ùëìin ‚à∂ ùëãout √ó ùëåin ‚Üí
ùëãin, ùëìout ‚à∂ ùëãout ‚Üí ùëåout), the application of the functor ùíû(ùëì) on ùëÖùëã is the contract
ùëÖùëå ‚äÜ ùëåin √ó ùëåout described by

ùëÖùëå ={(ùë¶1, ùë¶2) ‚àà ùëåin √ó ùëåout | ‚àÉùë•2 ‚àà ùëãout

such that (ùëìin(ùë•2, ùë¶1), ùë•2) ‚àà ùëÖùëã and ùëìout(ùë•2) = ùë¶2}.

(4.1)

This formula arises categorically via a pullback. The functor ùíûùëì ‚à∂ ùíû(ùëã) ‚Üí ùíû(ùëå )
for a wiring diagram ùëì ‚à∂ ùëã ‚Üí ùëå , described by interface formulas (2.1a), assigns
a contract ùëÖùëã ‚äÜ ùëãin √ó ùëãout on the inside box to a contract ùëÖùëã ‚äÜ ùëãin √ó ùëãout on the
outside box, following a two-step procedure:

ùëÉ

‚åü

ùëÖùëã

ùëÖùëå

ùëåin √ó ùëãout

ùëãin √ó ùëãout

(ùëìin,ùúã2)

(4.2)

1√óùëìout

ùëåin √ó ùëåout

First, we compute the pullback‚Äîa limit of a diagram of two morphisms with com-
mon codomain¬†[98, 5.1.16]‚Äîof the relation ùëÖùëã along the function (ùëìin, ùúã2) which
is defined by ùëåin √ó ùëãout ‚àã (ùë¶, ùë•‚Ä≤) ‚Ü¶ (ùëìin(ùë¶, ùë•‚Ä≤), ùë•‚Ä≤) ‚àà ùëãin √ó ùëãout. The explicit de-
scription of that pullback in Set is

ùëÉ = {(ùë¶, ùë•‚Ä≤) | (ùëìin(ùë¶, ùë•‚Ä≤), ùë•‚Ä≤) ‚àà ùëÖùëã}

namely those pairs of ùëå -inputs and ùëã-outputs which the bottom function actually
maps to elements of the contract ùëÖùëã. Second, we take the image factorization of

The algebra of safety contracts

67

the inclusion ùëÉ ‚äÜ ùëåin √ó ùëãout post-composed with the function 1 √ó ùëìout that maps
some (ùë¶, ùë•‚Ä≤) to the pair (ùë¶, ùëìout(ùë•‚Ä≤)). The image of a function is the subset of its
codomain where all elements of the domain get mapped to, namely for an arbitrary
ùëî ‚à∂ ùê¥ ‚Üí ùêµ, Im(ùëî) = {ùëè ‚àà ùêµ | ‚àÉùëé ‚àà ùê¥ such that ùëî(ùëé) = ùëè}. In the end, using
the above constructions of the two-step process exhibited in (4.2), the explicit de-
scription of the resulting contract is precisely equation (4.1). In various examples,
this composite contract may be expressed in more elementary terms depending
on the form of the component contracts ùëÖùëã and the given wiring diagram.

For the monoidal structure of the functor, suppose we have two parallel boxes
(2.2) with contracts ùëÖùëã ‚äÜ ùëãin√óùëãout and ùëÖùëå ‚äÜ ùëåin√óùëåout. The laxator ùúôùëã,ùëå ‚à∂ ùíû(ùëã)√ó
ùíû(ùëå ) ‚Üí ùíû(ùëã ‚äó ùëå ) induces a contract on the box (ùëãin √ó ùëåin, ùëãout √ó ùëåout) which is
merely the cartesian product

ùëÖùëã √ó ùëÖùëå ‚Ü™ ùëãin √ó ùëãout √ó ùëåin √ó ùëåout

‚âÖ
‚àí‚Üí ùëãin √ó ùëåin √ó ùëãout √ó ùëåout

that essentially switches the two middle variables,

ùúôùëã,ùëå (ùëÖùëã, ùëÖùëå ) = {(ùë•1, ùë¶1, ùë•2, ùë¶2) | (ùë•1, ùë•2) ‚àà ùëÖùëã and (ùë¶1, ùë¶2) ‚àà ùëÖùëå }.

As an example, suppose we ask that some process in ùëã (figure 2.2a) satisfies the
contract ùëÖùëã ‚äÜ ‚Ñù √ó ‚Ñù, some process in ùëå satisfies the contract ùëÖùëå ‚äÜ ‚Ñù √ó ‚Ñù
and some process in ùëç satisfies the contract ùëÖùëç ‚äÜ ‚Ñù3 √ó ‚Ñù. The fact that contracts
form an algebra on W ensures that the composite process in ùê¥ will necessarily sat-
isfy a contract formed only in terms of ùëÖùëã, ùëÖùëå and ùëÖùëç and their interconnection
(ùëìin, ùëìout), and specifically

ùëÖùê¥ ={(ùë§, ùë¢, ùë£, ùëß) ‚àà ‚Ñù4 | ‚àÉ(ùë•, ùë¶) ‚àà ‚Ñù2

such that (ùë§, ùë•) ‚àà ùëÖùëã, (ùë¢, ùë¶) ‚àà ùëÖùëå , (ùë•, ùë¶, ùë£, ùëß) ‚àà ùëÖùëç}.

(4.3)

The algebra machinery produces a contract that matches our intuition: whenever
the interconnected composite in figure 2.2a receives three real numbers (ùë§, ùë¢, ùë£)
as inputs, it must produce an output ùëß which is ùëÖùëç-allowable by (that is, related

The algebra of safety contracts

68

to) (ùë•, ùë¶, ùë£), for some real ùë• which is ùëÖùëã-allowable by ùë§ and some real ùë¶ which
ùëÖùëå -allowable by ùë¢. Not all inputs of this composite ùê¥ will have an allowable out-
put, and that completely depends on the contracts of components ùëã, ùëå and ùëç.

As another example, which highlights the strong connection between the contract
algebra machinery and the usual relation operators, consider a simple wiring dia-
gram with ‚Ñù-typed wires on the left, expressing serial composition of two boxes

ùë•

ùëã

ùë¶

ùëå

ùê¥

ùëß

ùë•

ùë¶

ùëß

ùëã

ùëå

This morphism ùëì ‚à∂ ùëã ‚äóùëå ‚Üí ùê¥ is described by (ùëìin(ùë¶, ùëß, ùë•) = (ùë•, ùë¶), ùëìout(ùë¶, ùëß) =
ùëß) according to its equivalent arrangement on the right, and given two contracts
ùëÖùëã and ùëÖùëå the formula (4.1) produces the composite contract

ùëÖùê¥ = {(ùë•, ùëß) | ‚àÉùë¶ such that (ùë•, ùë¶) ‚àà ùëÖùëã and (ùë¶, ùëß) ‚àà ùëÖùëå }

which is the usual composition of binary relations.

What is interesting about this algebra of contracts is that it is ‚Äúagnostic‚Äù to the
exact specification of the systems. This means that although categorically it is ex-
pressed the same way as, for example, Moore machines, it is of a quite different
flavor: we are not interested in giving explicit functions that describe the com-
posite process, but in expressing all the possible (input,output) pairs that can be
observed on it. This is very convenient especially when connecting systems of dif-
ferent models, for example, a Moore machine with an ‚Äúabstract machine‚Äù [156,
¬ß4]. Even if we cannot compose them in the previous sense, since they form dis-
tinct algebras (that is, they are described by different functors W ‚Üí Cat), we
can still compose and examine the requirements the composite satisfies, in this
relational sense.

The algebra of safety contracts

69

4.2 Independent contracts

We will also be interested in a subclass of static contracts, called independent, of
the form

ùêº = ùêº1 √ó ùêº2 ‚äÜ ùëãin √ó ùëãout.

These contracts capture cases like ‚Äúinputs are always in range ùêº1 and outputs are
always in range ùêº2, independently from one another‚Äù.1 Of course this is only a
special case of arbitrary relations ùëÖ ‚äÜ ùëãin √ó ùëãout, since not all subsets of cartesian
products are cartesian products of subsets, as a simple argument in the finite case
shows: |ùí´(ùëãin √ó ùëãout)| = 2ùëõ‚ãÖùëö whereas |ùí´(ùëãin)| ‚ãÖ |ùí´(ùëãout)| = 2ùëõ+ùëö. For example,
the contract {(ùë•, ùë¶) | ùë• < ùë¶} ‚äÜ ‚Ñù √ó ‚Ñù is not independent.

One could expect that these contracts form themselves an algebra, namely any
wiring composite of independent contracts will also be an independent, rather
than a general contract itself. However this is not the case in general: although the
ùëã ‚äÜ ùëãin √ó ùëãout and ùêºùëå = ùêº1
parallel placement of boxes with ùêºùëã = ùêº1
ùëã √ó ùêº2
ùëå ‚äÜ
ùëåin√óùëåout produces the independent contract (ùêº1
ùëã √óùêº2
ùëã √óùêº1
ùëå ) on ùëã ‚äóùëå , closure
ùëã √ó ùêº2
under feedback fails. Explicitly, for an independent contract ùêº1
ùëã ‚äÜ ùëãin √ó ùëãout
on ùëã, and a wiring diagram (ùëìin, ùëìout) ‚à∂ ùëã ‚Üí ùëå , the formula (4.1) produces the
simpler composite contract

ùëå )√ó(ùêº2

ùëå √ó ùêº2

ùëÖùëå = {(ùë¶1, ùë¶2) ‚àà ùëåin √ó ùëåout | ‚àÉùë•2 ‚àà ùêº2
ùëã
such that ùëìin(ùë¶1, ùë•2) ‚àà ùêº1

ùëã and ùëìout(ùë•2) = ùë¶2}

(4.4)

which shows that ùë¶1 and ùë¶2 are not independent in general, hence ùëÖùëå is not of
the form ùêº1

ùëå √ó ùêº2
ùëå .

In certain examples, ùëÖùëå can indeed be written as a product itself, for example,
when (ùëìin, ùúã2) is of the form ùëò √ó ùë† for two functions ùëò, ùë†. Even more interestingly,
due to the special form of morphisms in the wiring diagram category (where they

1 These independent contracts in reality are even more special than that: not only are input restric-
tions separate from output restrictions, but also each individual wire has an associated subset of
allowed values on it.

The algebra of safety contracts

70

are only made up from projections, diagonals and duplications) in our examples
below we will be able to write ùëÖùëå as an independent contract itself.2

4.3 Relation to assume-guarantee contracts

Systems theory and design has long recognized the need for a formal requirement
engineering through mathematical models and formal analysis techniques¬†[29].
As part of contract-based design, there have been multiple efforts to formalize
and analyze assume-guarantee contracts¬†[142] and incorporate them in the design
as a fundamental concept. We here discuss such examples and how they fit to the
previously described static contract model.

Given a box ‚Ñù
‚Ñù
Benveniste et al.¬†[29, ¬ß IV]) is

‚Ñù, an example of an assume-guarantee contract (adapted from

ùëÖ1 ‚à∂

‚éß
‚é™
‚é™

‚é®
‚é™
‚é™
‚é©

variables:

inputs ùë•, ùë¶; outputs ùëß

types:

ùë•, ùë¶, ùëß ‚àà ‚Ñù

assumptions:

guarantees:

ùë¶ ‚â† 0
ùë•
ùë¶

ùëß =

(4.5)

This explicitly makes the assumption that the environment (namely the inputs
coming either from the external world or from other component systems) will
never provide the input ùë¶ = 0, essentially leaving the behavior for that input
undefined. In our formalism, we can express this contract as

ùëÖ1 = {(ùë•, ùë¶, ùëß) | ùë¶ ‚â† 0 ‚àß ùëß =

ùë•
ùë¶

} ‚äÜ ‚Ñù √ó ‚Ñù √ó ‚Ñù

indicating the fact that the input ùë¶ = 0 will never occur on the input wire of
the box; and if it did, the contract is violated. A different choice we could make,

2 It can be shown that independent contracts indeed form an algebra on W due to the special

morphisms that generate it; the proof is beyond the scope of this section.

The algebra of safety contracts

71

assuming the initial assume-guarantee contract is really expressing a conditional
(‚Äúif-then‚Äù) requirement, is

ùëÖ‚Ä≤

1 = {(ùë•, ùë¶, ùëß) | ùë¶ ‚â† 0 ‚áí ùëß =

ùë•
ùë¶

} ‚äÜ ‚Ñù √ó ‚Ñù √ó ‚Ñù

which is a different subset of allowable values on the wires. For example, (3, 0, 25) ‚àà
ùëÖ‚Ä≤

1 whereas (3, 0, 25) ‚àâ ùëÖ1.

We now consider a standard assume-guarantee contract operator called contract
composition and system integration, and we realize it from the perspective of the
wiring diagram algebra machinery‚Äîconsequently a more general setting. Explic-
itly, the assume-guarantee contract composition operator as described for exam-
ple by Benveniste et al.¬†[29, ¬ß IV.B] or Le et al.¬†[93], takes two assume-guarantee
contracts ùëÖ1 = (ùê¥1, ùê∫1) and ùëÖ2 = (ùê¥2, ùê∫2) and produces a new assume-guarantee
contract ùëÖ1‚äóùëÖ2 (this is a completely different use of our earlier monoidal product
symbol ‚äó) with

ùê∫ùëÖ1‚äóùëÖ2 = ùê∫1 ‚àß ùê∫2
ùê¥ùëÖ1‚äóùëÖ2 = max{ùê¥ | ùê¥ ‚àß ùê∫2 ‚áí ùê¥1, ùê¥ ‚àß ùê∫1 ‚áí ùê¥2}

only when ùëÖ1 and ùëÖ2 are compatible, namely ùê¥ùëÖ1‚äóùëÖ2 ‚â† ‚àÖ. Since ùê¥ùëÖ1‚äóùëÖ2 is the
weakest assumption such that the two referred implications hold, if non-empty it
ensures that there exists some environment in which the two contracts properly
interact: when put in the context of a process that satisfies the first contract, the as-
sumption of the second contract will be met and vice-versa. This definition looks
‚Äúsymmetric,‚Äù since it considers a certain compatibility of output guarantee/input
assumption in both directions, but in reality this is not quite the case.

One issue with the above assume-guarantee contract composition is that the names
of the variables and not only the types of the wires need to match, in order to con-
nect along them¬†[29, 133]. For example, the contract ùëÖ1 as in formula (4.5) can be

The algebra of safety contracts

72

composed with the contract on ‚Ñù

‚Ñù

ùëÖ2 ‚à∂

‚éß
‚é™
‚é™

‚é®
‚é™
‚é™
‚é©

variables:

inputs ùë¢; outputs ùë•

types:

ùë¢, ùë• ‚àà ‚Ñù

assumptions: ‚ä§

guarantees:

ùë• > ùë¢

not along any wire, as could be deduced by noticing that all wire types are ‚Ñù, but
specifically along the wire with variable name ùë•. Pictorially, we can realize them
as inhabiting boxes wired as

ùë¢

ùë¶

ùë•

ùëß

and using the formulas (4.3) we obtain

ùê¥ùëÖ1‚äóùëÖ2 = max{ùê¥ | (ùê¥ ‚àß (ùë• > ùë¢) ‚áí ùë¶ ‚â† 0) ‚àß (ùê¥ ‚àß (ùëß = ùë•/ùë¶) ‚áí ‚ä§)} = (ùë¶ ‚â† 0)
ùê∫ùëÖ1‚äóùëÖ2 = (ùë• > ùë¢) ‚àß (ùëß = ùë•/ùë¶).

On the other hand, composing ùëÖ1 and ùëÖ2 using the static contract algebra (sec-
tion 4.1) for the above wiring diagram (ùëìin(ùë•, ùëß, ùë¢, ùë¶) = (ùë¢, ùë•, ùë¶), ùëìout(ùë•, ùëß) = ùëß),
we obtain the composite contract

ùëÖ = {(ùë¢, ùë¶, ùëß) ‚àà ‚Ñù3 | ‚àÉùë• ‚àà ‚Ñù such that ùë¶ ‚â† 0 ‚àß ùë• > ùë¢ ‚àß ùëß = ùë•/ùë¶},

which could be written in assume-guarantee form as ùê¥ = {(ùë¢, ùë¶) | ùë¶ ‚â† 0} and
ùê∫ = {ùëß | ‚àÉùë• > ùë¢ such that ùëß = ùë•/ùë¶}. The contract algebra machinery does not
present this variable-match problem, since it does not prevent us from composing
along the second input wire of ùëã1 or even do first ùëã1 and then ùëã2 in the opposite
order, since all types of wires are real numbers. In all these cases, it would be
possible to compute appropriate composite contracts in this uniform way.

The algebra of safety contracts

73

The second issue, which can also be seen from the above calculation, is that the
assume and guarantee of the composite contract include information that mix the
variables of the resulting input and output wires. For example, using the assume-
guarantee formalism, the variables of ùëÖ1 ‚äó ùëÖ2 are set to be {ùë¢, ùë¶} for inputs and
{ùë•, ùëß} for outputs, therefore this operation behaves as if the intermediate wires of
a system composition can be extracted as extra output wires to the outside world

ùë•

ùë¢

ùë¶

ùëß

This ‚Äúchoice‚Äù does not agree with the wiring diagram formalism, and moreover
is somewhat ad-hoc given that it could potentially add arbitrary many wires to
the composite system, essentially according to the result of the contract composi-
tion. Adding extra wires is of course possible for the algebra formalism, but corre-
sponds to a choice of architecture on how we decide to wire the subcomponents
together, rather than a necessity that arises from dealing with contracts.

Finally, the assume-guarantee formalism asks that compositions (ùëÖ1 ‚äó ùëÖ2) ‚äó ùëÖ3
and ùëÖ1 ‚äó(ùëÖ2 ‚äóùëÖ3) give equivalent contracts, and that so do ùëÖ1 ‚äóùëÖ2 and ùëÖ2 ‚äóùëÖ1.
In the contract algebra formalism, the first statement follows for any W-algebra:
consider a possible wiring of three boxes, each inhabited with a contract (and/or
a behavior formalism)

ùê¥

ùëã1

ùëç

ùëã3

ùëå

ùëã2

First composing the contracts ùëÖ1 and ùëÖ2 and then the result with ùëÖ3 comes from

The algebra of safety contracts

74

the application of the functor ùíû ‚à∂ W ‚Üí Cat on a wiring diagram morphism

(ùëã1 ‚äó ùëã2) ‚äó ùëã3 ‚Üí ùëå ‚äó ùëã3 ‚Üí ùê¥

whereas the other way around comes from the application of the functor ùê∂ on the
morphism

ùëã1 ‚äó (ùëã2 ‚äó ùëã3) ‚Üí ùëã1 ‚äó ùëç ‚Üí ùê¥

which both express the same morphism ùëã1 ‚äó ùëã2 ‚äó ùëã3 ‚Üí ùê¥ in W as an implemen-
tation of ùê¥ (section 3.3).

Regarding the second statement about ùëÖ1 ‚äó ùëÖ2 and ùëÖ2 ‚äó ùëÖ1, in the assume-
guarantee formalism this can indeed be proved due to the symmetric formula-
tion of composition described by formula (4.3) as observed earlier. However, this
refers more to the earlier variable-sharing clause (which would not allow the com-
position along arbitrary wires therefore in arbitrary order) and less to composition
intuition: changing the order of two boxes and expecting the same behavior or re-
quirements is something highly non expected, from a categorical but also a design
point of view due to the input-output directionality. As a result, commutativity
in this assume-guarantee setting is slightly misleading, since it is just a technical
term relevant to the constructed formula (it does not really have an effect on the
operation) rather to an actually commuting composition which is not expected to
hold‚Äîand does not, in the algebra formalism.

We will use the algebra of static contracts ùíû ‚à∂ W ‚Üí Cat, where all requirements
are expressed as subsets of the cartesian product of input and output types. Con-
sider the original system decomposition to sensor, controller, and dynamics boxes
(figure 3.1) and suppose we have certain contracts on these components given by

ùëÖùêø ‚äÜ ‚Ñù2 √ó ‚Ñù, ùëÖùê∂ ‚äÜ ‚Ñù2 √ó ‚Ñù, ùëÖùê∑ ‚äÜ ‚Ñù √ó ‚Ñù.

These contracts could be any subsets, from the extreme case of equality which
means that all combinations of inputs and outputs are allowed, to some specific
requirement imposed to the example at hand, or in certain cases some maximal

The algebra of safety contracts

75

contract dictated by a discrete dynamical system (governed by a difference equa-
tion) that actually inhabits the box.

The contract algebra applies to the wiring diagram of figure 3.1 and based on the
formula (4.1) produces a contract ùëÖUAV ‚äÜ ‚Ñù2 √ó ‚Ñù on the composite system, with
the following explicit description

‚Ñù3 ‚äá ùëÖUAV ={(ùëé1, ùëé2, ùëé3) ‚àà ‚Ñù3 | ‚àÉ(ùë•, ùë¶) ‚àà ‚Ñù2 such that

(ùëé3, ùëé1, ùë•) ‚àà ùëÖùêø, (ùë•, ùëé2, ùë¶) ‚àà ùëÖùê∂, (ùë¶, ùëé3) ‚àà ùëÖùê∑}.

Further, we could assume that all contracts are independent, namely they can be
written as products of subsets of each wire type independently, like

ùëÖùêø = ùëÖ1

ùêø √ó ùëÖ2

ùêø √ó ùëÖ3

ùêø, ùëÖùê∂ = ùëÖ1

ùê∂ √ó ùëÖ2

ùê∂ √ó ùëÖ3

ùê∂, ùëÖùê∑ = ùëÖ1

ùê∑ √ó ùëÖ2
ùê∑

where all components are subsets of ‚Ñù meaning the allowed values on each wire
are completely unrelated to one another. Then the composite contract (4.4) takes
the following, also independent contract form

ùëÖuav = {

ùêø √ó ùëÖ2
ùëÖ2

ùêø ‚à© ùëÖ2
ùê∑)

ùê∂ √ó (ùëÖ1
‚àÖ

if ùëÖ3

if ùëÖ3

ùêø ‚à© ùëÖ1
ùêø ‚à© ùëÖ1

ùê∂ ‚â† ‚àÖ and ùëÖ3
ùê∂ = ‚àÖ or ùëÖ3

ùê∂ ‚à© ùëÖ1
ùê∂ ‚à© ùëÖ1

ùê∑ = ‚àÖ

ùê∑ ‚â† ‚àÖ

The above formula expresses that the allowable tuples that can be observed on
the composite system are the ùêø- and ùê∂-external input contracts for the two in-
put wires, along with an intersection of contracts for the output wire, subject
to whether there exists a scenario where the contracts of the intermediate wires
match: if their intersection is non-empty, there exist appropriate values that work
for both contracts and the total system ‚Äúruns.‚Äù Otherwise the composed con-
tracts are incompatible and the composite system fails to adhere to a contract,
namely there is no guarantee about its observable input and output values (ex-
pressed by the empty set contract) and possibly the whole process fails.

We now proceed to a similar process to what we have seen before (section 3.2),
which in a sense reverse-engineered the behavior of the subcomponents, given a

The algebra of safety contracts

76

composite behavior of the total system using the system behavior algebra machin-
ery. In this setting, given a specific desired requirement ùëÖuav on the composite
system, we will identify possible contracts on the components that produce that
specific composite; once again we do not expect unique solution to this problem.

Suppose the envisioned composite contract on the behavioral representation of
our example uav (figure 3.1) is

ùëÖuav = [0, 100] √ó [‚àí20, +20] √ó [‚àí35, +35].

This contract represents a possible requirement that the desired uav pitch is no
more or less than 20 degrees and the plane really must not pitch more or less than
35 degrees for a hypothetical safe flight. As hypothetical environmental condi-
tions, we assume air speed does not exceed 100 km/h.

Comparing the above composite contract against equation (4.3), we can first of
all deduce that

ùëÖ2

ùêø = [0, 100]

ùëÖ2

ùê∂ = [‚àí20, +20]

namely the external inputs for ùêø and ùê∂ are necessarily constrained by the ranges
of the given composite contract on those wires. Moreover we have that ùëÖ1
ùê∑ =
[‚àí35, 35] and also that necessarily the intersections ùëÖ3
ùê∑ are
non-empty‚Äîsince the composite contract is indeed non-empty. All these inter-
sections correspond to specific wiring connections or splittings we performed be-
tween subcomponents for the initial uav‚Äôs implementation.

ùêø ‚à©ùëÖ2
ùê∂ ‚à© ùëÖ1

ùê∂ and ùëÖ3

ùêø ‚à© ùëÖ1

Given these restrictions, we are free to choose contracts that satisfy them, for
example

ùê∑ = [‚àí35, +35], ùëÖ1
ùëÖ2

ùêø = ùëÖ3

ùêø = ùëÖ1

ùê∂ = ùëÖ3

ùê∂ = ùëÖ1

ùê∑ = ‚Ñù

The above choices are made to also dispose of bad scenarios for the given intercon-
ùê∑ and ùëÖ1
nection of the boxes. For example, choosing the opposite contracts for ùëÖ2
ùêø
would be mathematically correct because their intersection is still [‚àí35, 35], but
could lead to a real value of, say, 40 degrees entering the sensor ùêø, which would

The algebra of safety contracts

77

then violate its contract (that said ‚Äúall my inputs on the first wire will be less
than 35‚Äù). Although in general, processes can be wired together as long as types
match, in the contract algebra setting it is implied (by the algebra machinery) that
the only values passing through an interconnected wire are those in the intersec-
tions of the individual (independent) contracts‚Äîso long as the composite system
does not ‚Äúbreak.‚Äù It is important to realize that the contract algebra describes the
observable inputs and outputs on a running composite machine, rather than en-
sures that the process runs: this has to be safeguarded by the designer also. This
discussion relates to developing ‚Äútotal‚Äù or ‚Äúdeterministic‚Äù contracts.

4.4 Time in compositional systems modeling

Thus far, we are able to compositionally express the process of building larger sys-
tems from smaller, depending on their interconnections. In the earlier examples,
this process is somewhat static and more related to the classical model of com-
putation, for example, given functions, we express their composite function that
given some inputs values produces a specific output value. How would we express
that composite as a system that over time, it receives and produces sequences of in-
puts and outputs via its interactions of subsystems and the environment? This in
particular entails moving to a reactive model of computation, a key characteristic
of cyber-physical systems [6, ¬ß1.2].

For this reason, any sufficiently capable modeling language needs to address the
notion of time. A major challenge in modeling is the cojoint verification of com-
putational models, which are deterministic, and physical models, which are not
necessarily deterministic [96]. To incorporate time into our model in such a way,
we need to change the type of information that the wires hold from a mere set like
‚Ñù to something else that captures the necessary time-related structure.

Previously we restricted the definition of the category of labeled boxes and wiring
diagrams W, to the category Set, where ùëãin, ùëãout are sets; that is, objects in the cat-
egory Set, and ùëìin, ùëìout are functions; that is, morphisms in Set. Therefore there

The algebra of safety contracts

78

is a clear sense in which the category W depends on the category Set, pointed
out also at that time. Let us change our perspective and consider a new category
WùëÅ which is described using a different category than sets and functions Graph
of (directed, multi-) graphs [158, Chapter 4]. Explicitly, the objects are given by
a set of vertices ùëâ, a set of edges ùê∏ and a source ùë† and target ùë° function

ùê∏

ùë†

ùë°

ùëâ

and morphisms are pairs of functions (ùëì, ùëî) that map vertices to vertices and
edges to edges by respecting their sources and targets; that is, making both squares
commute, meaning in this case that ùëî(ùë†(ùëí)) = ùë†‚Ä≤(ùëì(ùëí)) and ùëî(ùë°(ùëí)) = ùë°‚Ä≤(ùëì(ùëí)) for
any edge ùëí ‚àà ùê∏.

ùê∏

ùëì

ùê∏‚Ä≤

ùë†

ùë°

ùë†‚Ä≤

ùë°‚Ä≤

ùëâ

ùëî

ùëâ ‚Ä≤

The motivation for labeling wires with graphs rather than with sets like before is
to capture all possible ‚Äústreams‚Äù of data that can flow through a wire during any
discrete interval of time [0, ùëõ] as paths of length ùëõ.

ùëãùê∫

Therefore, at time 0 when the observer looks at a Graph-labeled box
ùêª,
both wires have a 0-path length on them namely a vertex of each graph: it is as if
ùëã = (ùëâ ùê∫, ùëâ ùêª) in the previous Set-labeled notation. At time 1, each wire has a
path of length one, namely an edge consisting of two vertices: the one correspond-
ing to clock-tick 0 and the other corresponding to clock-tick 1. As every time-unit
passes by, one edge (starting at the latest vertex) and one vertex (the new edge‚Äôs
target) are added, and the total information flowing on the wire from time 0 is
packaged in the form of a path of the graph labeling that wire.

Hence, the data flowing on the wires at any given interval [0, ùëõ] can be thought of
as ùëõ+1 elements of the vertex set connected by ùëõ continuous edges. An important
characteristic of this formalism is that, given a path of length ùëõ for the time [0, ùëõ]

The algebra of safety contracts

79

and a path of length ùëö for the time [ùëõ, ùëõ + ùëö] that share their end and start vertex
respectively, their concatenation is a path of length ùëõ + ùëö arising on the time
interval [0, ùëõ + ùëö]. Another is that given a path over some period of time say
[0, 7] and a chosen sub-interval say [2, 5] of it, we can always restrict in a coherent
way to a path of length 3. These traits, although straightforward in this graph-
time framework, come from the initial sheaf formulation of the time-model [152]
which necessary to extend to the continuous time-model.

To understand the equivalent sheaf formulation of time on the wires, consider a
category DInterv of discrete intervals. Its objects are natural numbers ùëõ, thought
of as lengths of discrete time intervals ùëõ = [ùëé, ùëè] if ùëé, ùëè ‚àà ‚Ñï with ùëé ‚â§ ùëè and
ùëè ‚àí ùëé = ùëõ. In this category, [3, 5] = [36, 38] = [0, 2] because all those intervals
are represented by the object 2. Morphisms ùëù ‚à∂ ùëö ‚Üí ùëõ are all ùëù ‚â§ ùëõ ‚àí ùëö ‚àà ‚Ñï,
thought of as ‚Äútranslations-by-ùëù‚Äù

0

ùëù

ùëù + ùëö

ùëõ

These morphisms are the ways of positioning a smaller interval within a larger
interval, for example, the morphism 2 ‚à∂ 5 ‚Üí 8 expresses the interval inclusion
[2, 7] ‚äÜ [0, 8] of a 5-length interval within an 8-length interval starting at its sec-
ond clock-tick.

Any graph ùê∫ can equivalently be viewed as a functor

ÃÇùê∫ ‚à∂ DIntervop ‚ü∂ Set

ÃÇùê∫(ùëõ) of length-ùëõ-paths of ùê∫, thought of
that maps any discrete length ùëõ to the set
the set of all possible signals that may flow on the wire at any interval of length ùëõ.
Any interval inclusion ùëù ‚à∂ ùëö ‚Üí ùëõ is mapped to a function ÃÇùê∫(ùëù) from ùëõ-signals
to ùëö-signals that cuts off the longer path at the ùëù-th vertex as described earlier.
ÃÇùê∫(3), and there is a well-defined function
Below, the path ùëì.ùëî.‚Ñé belongs to the set
ÃÇùê∫(1) ‚à∂
ÃÇùê∫(3) ‚Üí ÃÇùê∫(2) which slices a given 3-path to a 2-path starting at 1, namely
ùëî.‚Ñé ‚àà ÃÇùê∫(2):

The algebra of safety contracts

80

ùëì

‚Ä¢

ùëî

1

‚Ä¢

0

‚Ñé

‚Ä¢

2

‚Ä¢

3

This operation ÃÇùê∫ is in fact not only a functor, but also can be represented as a
sheaf [113]. Informally, this ensures that any ùëõ-signal also understood as the path
ùë• = ùëé1 ‚Üí ‚ãØ ‚Üí ùëéùëõ over an interval of length ùëõ, and any ùëö-signal ùë¶ = ùëè1 ‚Üí
‚ãØ ‚Üí ùëèùëö that happen to agree on their left and right restriction, namely ùëéùëõ = ùëè1,
can be glued into a (ùëö + ùëõ)-signal ùë• ‚ãÜ ùë¶, their concatenation.

Wiring diagrams can in fact be viewed in this new time-sensitive category WùëÅ
with objects pairs of graphs (ùëãin = ùê∫, ùëãout = ùêª) and morphisms pairs of graph
transformations. This is due to the existence of the ‚Äòcomplete graph‚Äô functor

ùêæ ‚à∂ Set

Graph

ùê¥

(ùê¥ √ó ùê¥ ‚áâ ùê¥)

(4.6)

on the labels of the wires, that maps every set ùê¥ to the graph ùêæ(ùê¥) with vertices
the elements of ùê¥ and edges pairs of elements in ùê¥, namely there exists a unique
arrow from each vertex to another. The source and target functions ùê¥2 ‚Üí ùê¥
are the two projections on the first and second variable, and the paths of lengths
ùëõ of the graph ùêæ(ùê¥) are precisely tuples in ùê¥ùëõ+1. A possible ‚Äúsection‚Äù of data
flowing on a wire labeled with ‚Ñù as earlier would now look like (ùëé0, ùëé1, ‚Ä¶ , ùëéùëõ) ‚àà
‚Ñùùëõ+1 for a time interval of length ùëõ. At any specific time unit ùëñ, only one ùëéùëñ would
be transmitted at that time, but all its history is available (as well as its future
possibilities determined by the whole graph).

If we think about the boxes having wires typed with those graphs or equivalently
discrete interval sheaves, in particular we recover ‚Äúwindow frames‚Äù of other stan-

The algebra of safety contracts

81

dard time models [80]. Therein, time is encapsulated using a product space

ùëã[‚ãÖ] = ‚àè
ùëò‚ààùêº

ùëã

over a time interval ùêº = [ùëé, ùëè] of natural numbers with ùëé ‚â§ ùëè. To connect that
to our setting, if ùëõ = ùëè ‚àí ùëé is the length of that interval, indeed ùëã[‚ãÖ] = ùëã ùëõ+1 is
the product of ùëã over all possible natural numbers in the interval, counting both
endpoints ùëé and ùëè. Therefore, this approach provides the same ùëõ-paths of a graph
ÃÇùê∫(ùëõ) of a discrete interval
ùê∫ = ùêæ(ùëã) coming from a set ùëã, or equivalently sets
ÃÇùê∫. However, there is no operation of restricting signals over larger intervals
sheaf
into signals over smaller subintervals, or the gluing condition, both of which are
indispensable for our current formalism.

This change of wire types gives us the flexibility to include time, but can also
make the algebras on WùëÅ more involved. For example, Schultz et al. [152, 5.1.1]
describe a mapping from the W-algebra of Moore machines to a WùëÅ-algebra of
discrete machines, which transforms any Moore machine

(ùëÜ, ùë¢ ‚à∂ ùëÜ √ó ‚Ñù ‚Üí ùëÜ, ùëü ‚à∂ ùëÜ ‚Üí ‚Ñù)

to a process whose inputs over time-lengths ùëõ are lists (ùëé0, ‚Ä¶ , ùëéùëõ) in ‚Ñùùëõ as de-
scribed above, and whose outputs are lists in ‚Ñùùëõ of the form

(ùëè, ùëü(ùë¢(ùë†0, ùëé0)), ùëü(ùë¢(ùë†1, ùëé1)), ‚Ä¶)

namely all the outputs of the updated state by the given inputs, step-by-step.

As another example, the contracts introduced earlier, in the absence of time pro-
vide the boxes with a constant behavior ùëÖ ‚äÜ ùëãin √ó ùëãout. Without Moore machine
objects, we can still make a static contract into a time contract by applying the
functor ùêæ from equation (4.6) to both input/output wires but also to the relation

ùêæùëÖ ‚äÜ ùêæùëãin √ó ùêæùëãout

The algebra of safety contracts

82

which says that in any time interval of length ùëõ, ùëÖùëõ+1 ‚äÜ ùëã ùëõ+1
and so
all instantaneous input and output pair will be related via ùëÖ. An example of such
a time contract for a box with inputs and outputs in ‚Ñù could be ‚Äúmy inputs are
within range [2, 3] and I will transmit outputs within range [10, 11].‚Äù An allowable
signal or section over, say, the interval [0,3] would be

in √ó ùëã ùëõ+1

out

(2, 2.5, 2.7, 3, 10, 11, 11, 11) ‚äÜ [2, 3]4 √ó [10, 11]4

(4.7)

However, we can also consider new algebras on WùëÅ that don‚Äôt come from static
ones like the above examples of Moore machines and contracts. For example, gen-
eral time contracts do not have to be of the above restricted form. Indeed, moti-
vated by the above generalization, we can define an algebra

TimeContr ‚à∂ WùëÅ ‚Üí Cat

that to each Graph-labeled box
ùëãùê∫
as sheaves ùê∫, ùêª ‚à∂ DIntervop ‚Üí Set, assigns a subfunctor of ùê∫ √ó ùêª

ùêª where ùê∫ and ùêª can equivalently be viewed

ùê∂ ‚äÜùëì ùê∫ √ó ùêª ‚à∂ DIntervop ‚Üí Set

This only means that for every discrete interval of time ùëõ ‚àà DInterv, the contract
of allowable behaviors over that interval is any subset

ùê∂(ùëõ) ‚äÜ ùê∫(ùëõ) √ó ùêª(ùëõ)

(4.8)

Moreover, for any time inclusion ùëö ‚Üí ùëõ, the restriction of an allowable ùëõ-behavior
is still an allowable behavior over the smaller ùëö. Notice how we could have asked
for ùê∂ to be a subsheaf of ùê∫ √ó ùêª; that is, to also have the gluing property, but
that could create unreasonable characteristics on the contract machinery. For ex-
ample, the concatenation of two allowable behaviors could potentially violate a
time-sensitive contract [152, ¬ß4.5].

An example of such a flexible time contract for a process with input graph and
output graphs ùêæBool; that is, streams of booleans, could be ‚Äúif I receive two trues

The algebra of safety contracts

83

in a row, I will output a false within 5 seconds.‚Äù The allowable behaviors by such
a contract over an interval of length ùëõ are formally expressed as
ùê∂(ùëõ) ={(ùëé0, ‚Ä¶ , ùëéùëõ, ùëè0, ‚Ä¶ , ùëèùëõ) ‚àà Boolùëõ+1 √ó Boolùëõ+1 |

for all ùëñ ‚â• 0, if ùëñ + 6 ‚â§ ùëõ and ùëéùëñ = ùëéùëñ+1 = ùëá then

there exists a ùëó such that ùëñ + 2 ‚â§ ùëó ‚â§ ùëñ + 6 and ùëèùëñ = ‚ä•}

Notice the strong similarity between the sets of signals of a time contract de-
scribed by equation (4.8) and a standard expression of a dynamical system [80],
as well as an input-output specification, as a relation between input and output
signals

Œ£, ùúô ‚äÜ ùê∫ùëõ+1 √ó ùêªùëõ+1

when the inputs and outputs come from fixed sets. A system satisfies ùúô just when
Œ£ ‚äÜ ùúô. The contracted behaviors in our approach are of this form for any fixed ùëõ,
but we also have the freedom to restrict to smaller intervals and the extra, reason-
able requirement that any restricted behavior is still part of the contract.

Furthermore, relatively to the assume-guarantee contracts expressed as a pair of
contracts (ùúôùëé, ùúôùëî) ‚äÜ ùê∫ùëõ+1√óùêªùëõ+1 such that Œ£‚à©ùúôùëé ‚äÜ ùúôùëî, in set-theoretic notation
this corresponds to Œ£ ‚äÜ (ùúôùëé ‚áí ùúôùëî) therefore it can form a new contract of the
previous form. For example, a contract that says ‚Äúif I receive inputs within [2,3]
I will transmit outputs within [10,11]‚Äù where ùúôùëé = [2, 3] √ó ‚Ñù can be thought
of as the assumption and ùúôùëî = ‚Ñù √ó [10, 11] as the guarantee in the standard
notation [80], can here be expressed as

ùê∂(ùëõ) ={(ùëé0, ‚Ä¶ , ùëéùëõ, ùëè0, ‚Ä¶ , ùëèùëõ) ‚àà ‚Ñùùëõ+1 √ó ‚Ñùùëõ+1 |

for all ùëñ, if ùëéùëñ ‚àà [2, 3] then ùëèùëñ+1 ‚àà [10, 11]}

Compared to its static version from equation (4.7), in this case ‚Äúunsatisfied as-
sumptions do not trigger an obligation to satisfy a guarantee.‚Äù Also, the (ùëñ + 1)-
index of the output in the contract above is in a sense optional (meaning that the
output is not necessarily instantaneous) and relates to the real-time computation
feature of cyber-physical systems [6].

The algebra of safety contracts

84

There is nothing as practical
as a good theory.

‚Äî Kurt Lewin

5 The algebra of security tests

It is possible to use the algebra of contracts to model security requirements and
potentially synthesize them in a traceable manner [144]. However, it is desirable
to discuss security as its own entity with its own analysis methods. Of course, any
of the theory we will develop in this section can work in tandem with security
contracts and, more generally, it ought to be seen as a complimentary view to
other methods in the field of model-based security.

In the past decade there has been significant effort in adding formal underpin-
nings to security¬†[91, 139]. This trajectory is evidenced by the NSF/IARPA/NSA
workshop on the science of security, which underlines that there are three areas
in need of innovation: metrics, formal methods, and experimentation¬†[52]. In ad-
dition, there is still increasing need for defining (in)security as a modeling prob-
lem¬†[11, 19, 129]. We develop a formal method for modeling attacker actions at the
abstraction level of component-level system models. Specifically, the categorical
result of the Yoneda lemma is used to formally show that if two different architec-
tural implementations of a system agree on every test, then they are behaviorally
equivalent. The implication of this result is that an attacker can still effectively ex-
ploit a system, even with an inaccurate knowledge base of the architecture, using
rewiring and/or rewriting attacks.

Security engineering has moved from the paradigm of securing a list of assets to
modeling in graphs of networked components [16], which is more congruent with
attacker behavior¬†[89]. These graphs are useful for analyzing the system‚Äôs secu-

86

rity posture¬†[17]; however, we can improve them further using added structure
that comes with categorical models of component-level system models, which
are by definition compositional; a useful property for security modeling¬†[48]. The
functorial semantics that come with this category-theoretic modeling framework
also explicitly relate several views that are essential for the modeling and analysis
of cyber-physical systems, where continuous and discrete behaviors interrelate to
produce a total behavior. The following formal method is applicable to informa-
tion technology systems too but the added complexity of cyber-physical systems
is useful as a demonstration and to examine formally, in the future, how attacks
can lead to hazards and misbehaviors.

Particularly, this structure comes in the form of formal decomposition rules be-
tween system behavior and system architecture, which improves upon current prac-
tice where system behavior is disjoint from system architecture. Additionally, this
approach provides for early security modeling, where engineering decisions are
most effective¬†[18, 159], by operating on models instead of implementations. This
is possible because categorical semantics reside in a higher level of abstraction
than, for example, attack graphs¬†[154], which work best after source code is avail-
able. The implementation of this category-theoretic modeling method is what al-
lows us to use the Yoneda lemma to show the impact of exploitable vulnerabilities
from an attacker perspective over a system model, which can be incomplete or
even partially erroneous compared to the system under attack.

This chapter develops the foundations of security within compositional cyber-
physical systems theory¬†[20], a flavor of what Lee calls dynamical computational
systems theory¬†[95]. Formal composition rules could overcome some of the new
challenges cyber-physical systems introduce to security¬†[37, 64]. Specifically our
contributions are in the domain of formal methods for security to assist model-
based design of cyber-physical systems using category theory. These contribu-
tions are still bound by well-known problems of the foundations and general sci-
ence of security, such as the lack of a well-defined common language¬†[71].

The algebra of security tests

87

In this chapter we first describe how fundamental concepts in category theory,
such as functors to the category of sets, can be interpreted as testing procedures,
which we previously used in the context of modeling safety requirements (chap-
ter 4), system behaviors (section 3.2), and architectures (section 3.3). Addition-
ally, results like the Yoneda lemma can be used to infer similarities between sys-
tems given the similarities between their test outcomes. Second, we use these
insights to model the most common phases of an attack, that consist of learning
first, and on the attack itself afterwards, thereby modeling from the attacker per-
spective formally. Third, we extend the approach to cyber-physical systems by
wiring diagrams and their algebras (chapter 3) to provide compelling examples
of how our mathematical formalization works in practice, which gives rise to a
categorical formal methods for cyber-physical systems security.

5.1 Attacks change system behavior

Having fixed some system, by an attack we mean any procedure intended to change
the system behavior. This definition is very broad, and ranges from privilege es-
calation in a computer system to sabotaging a car. We consider an attacker any
actor who performs any such process to degrade a systems behavior.

Traditionally, attacking a system is considered to be an art, and as such it requires
a certain degree of heuristics. Our goal is to formalize these heuristics mathemat-
ically, using the attacker point of view.

From an intuitive standpoint, it makes sense to divide an attack into two distinct
phases: learning, where the attacker gathers information about the target system
in the hope to find a weakness, and hijacking, where the attacker leverages on a
given weakness changing the behavior of some component, which reverberates on
the system as a whole. The particulars of how these phases are exercised and how
they feedback with each other depend on the capabilities and goal of the attacker
(in defender terms this would be detailed in the threat model).

The algebra of security tests

88

To model the first phase, we need a mathematical description of what probing a
system for information means. To model the second phase, we need to mathemat-
ically express the fact that the attacker can act on a system to change it.

Crucially, there is an intermediate step between these two phases, which we do
not describe. We do not describe explicitly how the weakness is turned into an
exploiting procedure to change the behavior of some subsystem. Instead, we only
describe how the weakness is found, and how the exploiting procedure reverber-
ates in the system as a whole. The reason why this assumption is acceptable is
twofold. First, turning a weakness into a viable exploit is heavily dependent on im-
plementation details, for example, the Spectre and Meltdown exploits¬†[109], and
our mathematical framework is too general to capture these details successfully.
Second, the largest class of attacker actions involves already developed exploits,
either internally or through a marketplace, deployed in some sequence to degrade
the behavior of the system, without necessarily the attacker precisely knowing
how they work¬†[1].

For instance, an attacker may find out by testing (phase 1) that a given laptop uses
some particular model of WiFi card. The attacker can then purchase ‚Äì if it exists
‚Äì an exploit for the given card, and deploy it. At this point, the behavior of the
system as a whole will change (phase 2), for example by giving to the attacker the
possibility to run any code on the machine. This example is taken straight out of
real experience¬†[116].

Importantly, we make the claim that an attacker is able to hijack a system even
having a incomplete view of it, as long as the system and the attacker‚Äôs mental
model are behaviorally equivalent. Mathematically, this relies on the assumption
that the exploit being used is invariant under isomorphism of behavior.

assumptions
In practice, this means the following: we represent behaviors
of systems using the concept of categorical semantics (chapter 2). This categori-
cal semantics can be more or less granular, depending on how low-level we want
our descriptions to be. For instance, consider specifying behavior in terms of au-

The algebra of security tests

89

tomata. We can represent automata as theoretical objects, but we can also take
into account their implementation details, meaning that we not only describe the
system behavior under some formalism but are also able to relate it to concrete el-
ements; as a reductionist example, an automaton can be implemented in either a
system-on-chip or a field-programmable gate array (fpga). These would amount
to different choices of categorical semantics.

Two automata may be isomorphic in the former setting but not in the latter: this
could result in having two different implementations of the same theoretical con-
cept (for example, this is the case in considering the same automaton implemented
in two different programming languages). An attack exploiting the automaton de-
sign will be isomorphism-invariant in both settings: such an attack exploits the
idea that it is possible to start from a state of a given automaton and end up in an-
other state via a legitimate sequence of moves. An attack exploiting the automaton
implementation (for example, some weakness of the programming language the
automaton is implemented in) will be isomorphism-invariant only in the latter set-
ting: at the theoretical level, our categorical semantics simply is not able to ‚Äúsee‚Äù
implementation differences.

This is important, because it amounts to saying that ‚Äúan attack can be carried
out even if the attacker has an erroneous view of the system, as long as it is be-
haviorally equivalent to the system itself‚Äù holds only if the categorical semantics
developed for application is granular enough to faithfully model the level of gen-
erality on which a given exploit acts.

5.2 The Yoneda lemma formalizes learning and hijacking

In our effort to formalize attacker actions, we embrace the perspective of the at-
tacker. For us, an attacker is simply an actor wanting to influence or change the
behavior of some given system. We do not distinguish between attacks aiming at
taking control of the system (as it is common in computer hacking) and attacks
aiming at just influencing its behavior to obtain a particular effect (as in sabotage).

The algebra of security tests

90

To describe the full cycle of an attack, we split it into two main phases:

phase 1

phase 2

Learning (exploration), or information gathering which is concerned
with probing/eavesdropping the system to discern its behavior. We
further divide this activity into general learning, where the attacker
focuses on gathering a general understanding of the system at hand,
and specific learning, where the attacker probes the system to under-
stand some specific component design choices.

Hijacking (exploitation), where the attacker, having learned enough
information to understand the weak spots of a system, deploys an
exploit which takes advantage of a found architectural flaw to influ-
ence the behavior of the system in some way the attacker desires.

Example 5.2.1. Consider an attacker wanting to take control (or to sabotage) a
uav. The attacker starts by learning; that is, gathering information, about the tar-
get uav (phase 1). General learning here can be the attacker trying to understand
if the uav has a gps module on board. In case the answer is positive, specific
information gathering consists in understanding how the gps module communi-
cates with surrounding units.

This general-specific pattern of learning can be arbitrarily repeated: the attacker
could now focus on the gps module itself to understand if some particular kind
of integrated circuit is used in its schematic.

Once learning is completed, the exploit can be deployed (phase 2). In our example,
this may be rewriting the firmware of the gps module over the air or, supposing
that the attacker has physical access to the uav, manually rewiring the module
or replacing some integrated circuit in it.

One key assumption is that we do not specifically model how a given exploit is

The algebra of security tests

91

developed but only how it is administered, and give a compositional recipe to
describe how this change of behavior propagates to the whole system. In prac-
tice, this means postulating that the attacker already has access to a knowledge
database of tools made to take advantage of a given structural flaw in a given
(sub)system. This postulate is not preposterous: indeed, an attacker can hijack a
system without personally creating the exploit. This is common in hacking, where
zero day exploits ‚Äì that is, exploits of a given flaw that are still unknown to the pub-
lic, including the target manufacturer ‚Äì can be commonly bought over the web¬†[1].

5.2.1 attacker learning (exploration)

First we model general learning. Assuming the perspective of an attacker, we want
to model what an attacker does to understand the kind of system being dealt with.
In practice this includes things such as scanning a computer for open ports, fire-
wall and operating system running on it, probing a piece of hardware to obtain
information about the integrated circuits being used, etc.

‚Ñ¨
‚àí‚Üí Cat, represent wiring diagrams
Algebras on W take the form of functors W
together with a semantics linking any diagram to the category describing its possi-
ble behaviors. It follows that while a wiring diagram is just an object ùëã in W, ‚Ñ¨ùëã
is instead a category: objects are taken to be general behavior assignments for ùëã,
while morphisms are taken to be mappings between them that preserve properties
we care about. When focusing on a system we are not just fixing a wiring diagram
ùëã, but also one of the many possible behaviors in the category ‚Ñ¨ùëã. Hence,

a system is a pair (ùëã, ùëÜ), with ùëã an object of W and ùëÜ an object of ‚Ñ¨ùëã.

We suppose we have access to ùëã (this amounts to saying that we are able to dis-
tinguish the type of inputs and outputs that our system has) and to ‚Ñ¨ùëã (we know
what type of system we are dealing with), but not to ùëÜ (we do not know the spe-
cific behavior of the system at hand). The first goal of the attacker is to infer ùëÜ to
the degree that an attack is viable.

The algebra of security tests

92

First things first, we select a subset of the objects of ‚Ñ¨ùëã, denoted ùêæ‚Ñ¨ùëã (from
‚Äúknown‚Äù), representing the systems that the attacker knows or is familiar with.
The knowledge base ùêæ‚Ñ¨ùëã should not, in general, lift to a functor W ‚Üí Cat, since
we do not assume the attacker knowledge to be compositional. For the same rea-
son, given that there will be an injection ùêæ‚Ñ¨ùëã ‚Ü™ ‚Ñ¨ùëã, which represents how the
smaller universe of systems known by the attacker embed in some bigger universe
of the systems being considered. We do not necessarily assume the attacker to
have knowledge of this embedding.

‚Ñ¨
‚àí‚Üí Cat and an
Definition 5.2.1 (Knowledge Database). Given a W-algebra W
object ùëã in W, a knowledge database for ‚Ñ¨, ùëã is a subset ùêæ‚Ñ¨ùëã of the objects of ‚Ñ¨ùëã.

Next, we consider functors ‚Ñ¨ùëã

Œò
‚àí‚Üí Set. These are interpreted as tests, or probes:

‚Ä¢

‚Ä¢

‚Ä¢

Given ùëÜ in ‚Ñ¨ùëã, ŒòùëÜ represents the information we get in probing ùëÜ with a test
Œò. For instance, ùëÜ may represent a machine on a network, while ŒòùëÜ could
represent the output one gets by running nmap on ùëÜ.

ùëì
‚àí‚Üí ùëÜ‚Ä≤ is a morphism of ‚Ñ¨ùëã, then Œòùëì is a way to transform the infor-
If ùëÜ
mation in Œòùê¥ to information in Œòùêµ. This expresses the fact that our tests
are well suited to detect the properties we care about, that are preserved by
morphisms of ‚Ñ¨ùëã.

In this interpretation functoriality holds on the nose: transforming a sys-
tem by ‚Äúdoing nothing‚Äù (identity morphism) should give the same test out-
come (functor identity law). Moreover, composing transformations should
amount to composing outcomes of the testing.

We package all this information as follows:

The algebra of security tests

93

Definition 5.2.2 (Security Test). Given a W-algebra W
in W, a test for ‚Ñ¨, ùëã is a functor ‚Ñ¨ùëã ‚Üí Set.

‚Ñ¨
‚àí‚Üí Cat and an object ùëã

Again, the attacker does not have access to ùëÜ but has access to ŒòùëÜ for some tests Œò.
This represents the ability of the attacker to perform tests on the system. These
tests can be thought of as a persistent reconnaissance mission, which often is the
step that takes the longest time and resources of the attacker. The goal of the
attacker is to prove in some sense that ùëÜ ‚âÉ ùëÜ‚Ä≤, for some ùëÜ‚Ä≤ in ùêæ‚Ñ¨ùëã. This amounts
to say that the system ùëÜ is an instance of a system ùëÜ‚Ä≤ the attacker is familiar with.
Given our assumption, we can then postulate that the attacker knows an exploit
for ùëÜ‚Ä≤ to move to phase 2.

We make the assumption that, for any ùëÜ‚Ä≤ ‚àà ùêæ‚Ñ¨ùëã, the attacker has access to ùëÜ‚Ä≤.
This assumption is natural, since ùëÜ‚Ä≤ is by definition in the knowledge base of the
attacker. In particular, we assume that the attacker is able to perform any test to
any known system, hence

for any ùëÜ‚Ä≤ ‚àà ùêæ‚Ñ¨ùëã and ‚Ñ¨ùëã

Œò
‚àí‚Üí Set, the attacker has access to ŒòùëÜ‚Ä≤.

The Yoneda lemma says that if ŒòùëÜ ‚âÉ ŒòùëÜ‚Ä≤ for all Œò, then ùëÜ ‚âÉ ùëÜ‚Ä≤. Let us try to
interpret what this means in our framework, considering some corner cases.

‚Ä¢

‚Ä¢

Suppose that for some object ùëÜ in ‚Ñ¨ùëã there is an object ùëÜ‚Ä≤ in ùêæ‚Ñ¨ùëã such that
ùëÜ ‚âÉ ùëÜ‚Ä≤. If the attacker has access to ŒòùëÜ for any Œò, then the attacker will be
able to conclude ùëÜ ‚âÉ ùëÜ‚Ä≤ from ŒòùëÜ ‚âÉ ŒòùëÜ‚Ä≤. That is, if the attacker is free to
perform any form of testing and possesses a vast knowledge database, then
ùëÜ can be determined with absolute precision.

If the attacker has access to any Œò, but there is no ùëÜ‚Ä≤ in ùêæ‚Ñ¨ùëã such that ùëÜ ‚âÉ ùëÜ‚Ä≤,
then the attacker won‚Äôt be able to conclude ùëÜ ‚âÉ ùëÜ‚Ä≤: Tests can be arbitrarily
precise, but the attacker has no ability to interpret them.

The algebra of security tests

94

‚Ä¢

If there is an object ùëÜ‚Ä≤ in ùêæ‚Ñ¨ùëã such that ùëÜ ‚âÉ ùëÜ‚Ä≤, but the attacker has no ac-
cess to all Œò, then it won‚Äôt be able to conclude with certainty that ùëÜ ‚âÉ ùëÜ‚Ä≤,
because the Yoneda lemma does not hold in this setting. Still, after perform-
ing enough tests, the attacker may be prone to infer that ùëÜ ‚âÉ ùëÜ‚Ä≤ if ŒòùëÜ ‚âÉ ŒòùëÜ‚Ä≤
for enough Œò ran. This inference comes with a degree of uncertainty, which
is exactly what makes information gathering an art more than a science.

That is, the Yoneda lemma provides a formal justification of the fact that testing a
system extensively is enough to sufficiently characterize its behavior. We call this
heuristic Yoneda reasoning.

Some tests are more informative than others. For instance, the ‚Äúterminal test‚Äù
Œò sending any ùëã to the singleton set {‚àó} is maximally uninformative: the result
of this test is the same for any system. On the contrary, a functor that is injective
on objects lifts to a test that yields the conclusion ùëã = ùëå from ‚Ñ¨ùëã = ‚Ñ¨ùëå . Fur-
ther formalizing the possible spectrum of tests, hopefully weighting them with
probability distributions to model their reliability, is an ongoing direction of fu-
ture work. Now we suppose that the attacker pinned down the target system ùëÜ
with some precision. The next step of an attack is harvesting information about
the architectural design choices implementing the system. That is, after we know
how ùëÜ works, we need to find out what ùëÜ is made of.

Previously, we saw that a system is made of an object ùëã in W together with an
object ùëÜ of ‚Ñ¨ùëã, for some W-algebra ‚Ñ¨ ‚à∂ W ‚Üí Cat.

Now we consider the category of architectural choices for ùëã, that is, the slice category

W/ùëã. Objects of this category are morphisms ‚®Çùëñ ùëãùëñ
morphisms of wiring diagrams making the following triangle commute.

ùúô
‚àí‚Üí ùëã, while morphisms are

The algebra of security tests

95

‚®Çùëñ ùëãùëñ

ùúô

ùëì

ùëã

‚®Çùëó ùëãùëó

ùúì

Architectural choices form a category, so we can repeat the reasoning done in the
last section using W/ùëã as the category on which we probe. Again using Yoneda,
the attacker is able to ascertain that a given system (ùëã, ùëÜ) is actually made of sub-
systems (ùëãùëñ, ùëÜ ùëñ), tensored and wired together by ùúô. At this stage the attacker still
does not know anything about the ùëÜ ùëñ, so the process must be repeated cyclically.

Summarizing, phase 1 is modeled as follows:

1.

The attacker uses tests on ‚Ñ¨ùëã and Yoneda-reasoning to find the system ùëÜ
representing the semantics of ùëã.

2.

The attacker uses tests on W/ùëã and Yoneda-reasoning to find the wiring

‚®Çùëñ ùëãùëñ

ùúô
‚àí‚Üí ùëã representing the implementation of ùëã.

3.

4.

5.

The attacker repeats step 1 on any ‚Ñ¨ùëãùëñ of interest to find the precise behav-
ior of the subsystem marked with ùëãùëñ.

The attacker repeats step 2 on W/ùëãùëñ to obtain more information about the
subsystems making up ùëãùëñ.

These steps are iterated cyclically until the attacker has gathered enough
information to move to exploiting.

In practice, tests will not have to be materially re-run on every ‚Ñ¨ùëãùëñ: it is very
likely that the attacker has only access to ŒòùëÜ‚Äîevery (ùëãùëñ, ùëÜ ùëñ) being a subsystem of
(ùëã, ùëÜ) that may not necessarily be exposed to external testing. Nevertheless, it will

The algebra of security tests

96

Œò‚Ñ¨ùúô
always be the case that Œò(‚Ñ¨ ‚®Çùëñ ùëãùëñ)
‚àí‚àí‚àí‚Üí Œò‚Ñ¨ùëã, meaning that the outputs of tests
over every ùëÜ ùëñ will have to be reconstructed from tests over ùëÜ. This adds another
layer of uncertainty for the attacker, who has to devise tests for which the mapping
Œò‚Ñ¨ùúô acts as transparently as possible. Again, this backs up intuition, going back
to example 5.2.1, if some system (ùëã, ùëÜ) comprises a subsystem (ùëãùëñ, ùëÜ ùëñ) (say, a gps
module), then we could devise a test on ‚Ñ¨ùëã such that in ŒòùëÜ the behavior of the
subsystem ùëÜ ùëñ is made apparent. Similarly, when running nmap on a system we
can get extra information about which services are running behind which port, for
example, nginx behind port 80. By probing the system as a whole, the attacker
is getting information about its subsystems.

5.2.2 attacker hijacking (exploitation)

Now suppose that the attacker has a good grasp of the system behavior and archi-
tecture, and model the last step, in which the system is hijacked and exploited.

We distinguish between two main kinds of attacks:

1.

2.

Rewriting attacks, where the behavior of a (sub)system is changed. Practical
examples of this are, for instance, exploiting a vulnerability in a WiFi card to
rewrite its firmware, and using this change of behavior to progress towards
obtaining administrative privileges over the whole machine;

Rewiring attacks, that are concerned with modifying the way subsystems
communicate with each other.

Definition 5.2.3 (Rewriting Attack). Given a W-algebra ‚Ñ¨, a rewriting attack for

The algebra of security tests

97

‚Ñ¨ is a monoidal natural transformation

W

‚Ñ¨

‚Ñ¨

Cat

ùúÇ

Cat

In a rewriting attack we do not change the possible behaviors that are assigned
to wiring diagrams, but we reshuffle them. If (ùëã, ùëÜ) was our system, then ùëÜ is an
object of ‚Ñ¨ùëã, which is in turn an object of Cat. We then see that ùúÇùëã is a morphism
‚Ñ¨ùëã ‚Üí ‚Ñ¨ùëã in Cat, that is, a functor ‚Ñ¨ùëã ‚Üí ‚Ñ¨ùëã. Applying it to ùëÜ we get that the
behavior of our new system is ùúÇùëãùëÜ.

The fact that ùúÇ is natural monoidal yields a compositional description of an attack.
In modifying the behavior of a given subsystem, we can infer how the behavior of
the whole system changes.

Definition 5.2.4 (Rewiring Attack). Given a W-algebra ‚Ñ¨, a rewiring attack for ‚Ñ¨
is a functor

W

‚Ñé

W

‚Ñ¨

Cat

Here ‚Ñé represents a reshuffling of the wirings and boxes. The new behavior can
then be obtained by considering the composition ‚Ñ¨ ‚àò ‚Ñé. If we started with system
(ùëã, ùëÜ), now the behavior of the hijacked system is (‚Ñéùëã, (‚Ñ¨ ‚àò ‚Ñé)ùëã). Again, the
nature of this attack is compositional: It describes how altering systematically a
wiring in W resonates through all the systems modeled by ‚Ñ¨.

The algebra of security tests

98

Processor
ùëÉ2

ùê∂

Servos
ùëâ

ùêø

Processor
ùëÉ1

imu
ùêº1

imu
ùêº2

gps
ùê∫

uav

ùê∑

Airframe
ùêπ

Aileron
ùëã

Rudder
ùëå

Throttle
ùëç

Elevator
ùëà

Figure 5.1: The hierarchical decomposition from behavior to candidate system architecture
is formally contained within the slice category C/ùëê in which there exist all possible design
decisions that adhere to the behavioral model as defined in the abstraction above the system
architecture. We segment here to subsystems following a behavior decomposition to sensors
ùêø, controller ùê∂, and dynamics ùê∑. Split wires indicate function duplication, Œî.

Both rewriting and rewiring attacks form categories. This conforms with our intu-
ition that attacks can be performed in batches, or stacked one on top of each other,
which in categorical terms means that we can consider the nature of attacks as be-
ing compositional.

5.3 Yoneda reasoning models security posture

We demonstrate the use of the Yoneda lemma as a possible model for security
tests and exploitation method over a system model of a uav from the perspective
of attacker actions (example 5.2.1).

The uav is composed of a sensor unit (denoted ùêø, in red), of a controller unit
(denoted ùê∂, in blue), and and of a dynamics unit (denoted ùê∑, in yellow) (figure 5.1).
Each of this unit is itself composed of various subsystems. There are multiple
possible system architectures that can implement this higher level behavior. We
assume that the attacker is familiar with the general class of vehicle cyber-physical
systems. For illustrative purposes we focus on one possible but relatively simple

The algebra of security tests

99

ùê∂‚Ä≤

ùêø‚Ä≤

ùê∑‚Ä≤

Figure 5.2: The attacker‚Äôs understanding of the system after the first cycle of learning.

system architecture.

Let‚Äôs start with the minimum observability possible‚Äîfor the attacker the uav is
just a black box with three inputs and one output, which we denote by the box
uav. The first step of the attack is gathering information about its behavior.

Our systems-as-algebras model (section 3.2) represents the assignment of behav-
iors to wiring diagrams with a functor

‚Ñ¨ ‚à∂ W ‚Üí Cat.

In our running example, ‚Ñ¨(uav) denotes the category of all the possible behav-
iors that we can assign to the uav box. Thus, our uav is a pair (uav, ùëÜ) with ùëÜ
an object of ‚Ñ¨(uav) representing the particular uav model at hand.

In general information gathering, the attacker uses Yoneda reasoning to infer ùëÜ.
To do so, the attacker must be able to perform a set of tests on the system ùëÜ. Any
of such tests is a functor

Œò ‚à∂ ‚Ñ¨(uav) ‚Üí Set

and the result of the test Œò applied to ùëÜ is denoted ŒòùëÜ (in category theory practice,
it is customary to avoid parentheses whenever possible). In our particular case, Œò
may be a test that analyzes the aerodynamics of the uav during flight.

The more informative Œò is, and the bigger the number of Œò‚Äôs the attacker can
have access to, the more it will be likely to infer ùëÜ. If the attacker finds that ùëÜ ‚âÉ ùëÜ‚Ä≤

The algebra of security tests

100

ùê∂‚Ä≤

ùê∑‚Ä≤

ùêø‚Ä≤

ùëÉ‚Ä≤

ùêº‚Ä≤

ùê∫‚Ä≤

Figure 5.3: The architecture of the sensory system as understood by the attacker, which is
in reality erroneous but behaviorally equivalent. The attacker found that there is one imu
(when in reality there are two) and a gps.

for some ùëÜ‚Ä≤ in their knowledge database, ùêæ‚Ñ¨(uav), then the attacker will know how
the uav behaves.

In practice, it is very unlikely for the attacker to have access to every test Œò. This
entails that the attacker will not be able to infer with certainty that ùëÜ ‚âÉ ùëÜ‚Ä≤: most
likely, the attacker will be prone to infer ùëÜ ‚âÉ ùëÜ‚Ä≤ with a certain degree of confidence.
As such, the outcome of testing is probabilistic more than deterministic.

Assuming that the attacker inferred ùëÜ ‚âÉ ùëÜ‚Ä≤ for some system ùëÜ‚Ä≤ in their knowledge
database, the particular design choices making up the uav are still unknown to
them. Applying Yoneda reasoning again to the category W/uav, they may be able
to infer some of these design choices. For instance, it could be possible to infer
an initial understanding of what the uav is composed of (figure 5.2).

The attacker sees the system as decomposed into boxes ùêø‚Ä≤, ùê∂‚Ä≤ and ùê∑‚Ä≤, which will
be behaviorally equivalent to ùêø, ùê∂ and ùê∑, respectively. The inner workings of such
boxes are still unknown to the attacker, that we now assume focuses on under-
standing the sensory system, ùêø‚Ä≤. This amounts to repeat the same cycle of Yoneda

The algebra of security tests

101

ùê∂‚Ä≤

ùê∑‚Ä≤

ùêø‚Ä≤ùêø‚Ä≤

ùëÉ‚Ä≤

ùêº‚Ä≤

ùê∫‚Ä≤

Figure 5.4: The compromised uav, with gps firmware hacked and input wires to the imu
units swapped.

reasoning focusing on tests that target ùêø in particular. After running these test, the
attacker sees a first approximation of the uav (figure 5.3).

The initial understanding of the attacker is slightly erroneous, because the two
separated imu units in uav have been conflated into one. Still, the two wiring
diagrams are behaviorally equivalent. This both reflects the fact that on one hand
Yoneda reasoning is probabilistic in nature, and on the other that identification of
system happens only up to behavioral equivalence.

Now, suppose the attacker decides to do two things: rewriting the firmware of the
gps module ùê∫, and cutting its feedback input. The first is a rewriting attack and
the second is a rewiring attack.

The rewriting attack is represented by a monoidal natural transformation ùúÇ ‚à∂
ùúÇùëã‚àí‚àí‚Üí ‚Ñ¨ùëã. The compo-
‚Ñ¨ ‚Üí ‚Ñ¨. This means that for each box ùëã, ùúÇùëã is a functor ‚Ñ¨ùëã
nents on the wiring diagrams ùêº‚Ä≤, ùëÉ‚Ä≤, ùê∂‚Ä≤ and ùê∑‚Ä≤ are just the identity functors‚Äîthese
boxes are mapped to themselves unchanged. On ùê∫‚Ä≤, the functor ùúÇùê∫‚Ä≤ ‚à∂ ‚Ñ¨ùê∫‚Ä≤ ‚Üí
‚Ñ¨ùê∫‚Ä≤ is instead different from the identity. If ùëî is the object of ‚Ñ¨ùê∫‚Ä≤ represent-
ing the particular gps unit used in the system (uav, ùëÜ), then ùúÇùê∫‚Ä≤ùëî represents

The algebra of security tests

102

Processor
ùëÉ2

ùê∂

Servos
ùëâ

ùêø

Processor
ùëÉ1

imu
ùêº1

imu
ùêº2

gps
ùê∫

uav

ùê∑

Airframe
ùêπ

Aileron
ùëã

Rudder
ùëå

Throttle
ùëç

Elevator
ùëà

Figure 5.5: The uav (figure 5.1), after the attack.

the gps module with its firmware rewritten. The behavior of ùúÇ on the compos-
ite boxes ùêø‚Ä≤, ùê∂‚Ä≤, ùê∑‚Ä≤ and their composition can be inferred from the fact that ùúÇ is a
natural transformation, and hence the naturality squares have to commute.

The rewiring attack, instead, is an endofunctor W ‚Üí W, which we set to be iden-
tity on objects. On morphisms, it remaps the wiring of ùê∫‚Ä≤ inside the box ùêø‚Ä≤ (fig-
ure 5.3) such that there is no wire coming from the outside (figure 5.4). In se-
quence, we can represent the effect of both attacks as changes in boxes and wires
within uav, as perceived by the attacker. The resulting wiring diagram is com-
pletely determined from the initial attacker learning wiring diagram (figure 5.3)
by the fact that behavior assignment is functorial; compositionally allows us to
infer the behavior of the composite after having replaced ùê∫‚Ä≤ and having swapped
the wirings of the imu units.

The resulting wiring diagram (figure 5.4) represents how the attacker presumes
the system will behave after the exploit is deployed, assuming the system was
correctly profiled in phase 1. Since phase 1 has margin for error, the attacker can re-
probe the system to assure that the perceived behavior is compatible with reality.
This further round of testing is necessary to assert with confidence that the exploit
has been deployed correctly.

The algebra of security tests

103

uav

ùê∂‚Ä≤

ùê∑‚Ä≤

ùêø‚Ä≤

ùëÉ‚Ä≤

ùêº‚Ä≤

ùê∫‚Ä≤

environment

Figure 5.6: Feeding counterfeit gps signals to the uav hijacks the box ‚Äùenvironment‚Äù.

In this example, we postulated that the attacker was indeed able to correctly gather
information about the uav. Formally, we expressed this by stating that what we
consider to be the actual uav (figure 5.1) and the attacker‚Äôs understanding of
what the uav is (figure 5.3) are behaviorally equivalent. Because functors pre-
serve isomorphisms, we are able to describe how the attack impacts the real uav
(figure 5.5).

One other attack we can model in this framework is feeding a counterfeit gps
signal to the uav to compromise it. This sort of attack is documented ‚ÄúCAPEC-
627: Counterfeit gps Signals‚Äù and is considered difficult to realize. The wiring
diagrams formalism gives us an idea of why: feeding a counterfeit gps signal does
not involve modifying the gps module in any way. What changes is the informa-
tion traveling on the gps wires which communicates with the outside world.

So, to understand this attack properly, one needs to model how the uav inter-
acts with the environment it is in (figure 5.6). Here, by the box ‚Äúenvironment‚Äù
we mean a process that given the uav position in space and time returns the data
sensed by the imu and gps units. In this sense, we see that spoofing a gps sig-

The algebra of security tests

104

gcs

uav

ùê∂‚Ä≤

ùê∑‚Ä≤

ùêø‚Ä≤

ùëÉ‚Ä≤

ùêº‚Ä≤

ùê∫‚Ä≤

Figure 5.7: Social engineering attacks may hijack the ground control station (gcs).

nal does not amount to intervening on the uav, but on the environment itself.
Attackers rarely have the capacity to control the environment within a region of
space and time‚Äîradio waves from the gps satellites in this particular case‚Äîthat
is big enough to influence the behavior of the single uav.

To conclude, we present another possible attack, performed by means of social
engineering. As with the previous example, social engineering does not exploit
the uav itself, but instead takes advantage of the human factor surrounding it.
Examples of this may include bribing whoever programs the uav goals, or making
the control tower believe that a given order has been officially issued from whoever
is in command, for example, as defined in ‚ÄúCAPEC-137: Parameter Injection.‚Äù

As in the previous case, the behavior of the uav as a wiring diagram is unchanged.
Instead, what changes is the information traveling on the first input wire of the
uav box. From our perspective, this requires again to put the uav into context
(figure 5.7). An attack based on social engineering will consist in rewriting the box
gcs, which abstracts away a possible ground control station.

We can implement the categorical semantics of cyber-physical security modeling
for the uav algorithmically (Listing 5.1 & 5.2).

The algebra of security tests

105

Listing 5.1: Modeling attacker learning

-- Define category of wiring diagrams

W : Category

W

= Definition 2.2.1

-- Define functor for UAV modeling
‚Ñ¨ : Functor W ‚Üí Cat
‚Ñ¨ = assignment of UAV behavior (LTIS) to boxes

-- Model UAV as a 2-input 1-output W-box
UAV : W
UAV = (2,1)

-- Knowledge database
ùêæ‚Ñ¨(UAV): List ‚Ñ¨(UAV)
ùêæ‚Ñ¨(UAV) = attacker knowledge for systems of type UAV

-- Compare tests with target S
CompareTests : (Functor ‚Ñ¨(UAV) ‚Üí Set) ‚Üí ‚Ñ¨(UAV) ‚Üí Bool
CompareTests ŒòùëÜ‚Ä≤ = Œò(ùêæ‚Ñ¨(UAV)(ùëÜ‚Ä≤)) ‚âÉ Œò(ùëÜ)

-- Yoneda reasoning
for each Œò : Functor ‚Ñ¨(UAV) ‚Üí Set
filter (CompareTests Œò) K

: W

-- Running security tests reveals the following boxes
ùêø‚Ä≤, ùê∂‚Ä≤ , ùê∑‚Ä≤
ùêø‚Ä≤, ùê∂‚Ä≤ = (2,1), ùê∑‚Ä≤ = (1,1)
diagram : Morphism W (ùêø‚Ä≤ ‚äó ùê∂‚Ä≤ ‚äó ùê∑‚Ä≤) ‚Üí UAV
diagram = (in, out)

where
in : Morphism Set UAVùëñùëõ √ó (ùêø‚Ä≤
ùëúùë¢ùë° √ó ùê∂‚Ä≤
in u1 u2 l c d = (u2, d, u1, c)
out : Morphism Set (ùêø‚Ä≤
ùëúùë¢ùë° √ó ùê∑‚Ä≤
out l c d = d

ùëúùë¢ùë° √ó ùê∂‚Ä≤

ùëúùë¢ùë° √ó ùê∑‚Ä≤

ùëúùë¢ùë°) ‚Üí (ùêø‚Ä≤

ùëñùëõ √ó ùê∂‚Ä≤

ùëñùëõ √ó ùê∑‚Ä≤

ùëñùëõ)

ùëúùë¢ùë°) ‚Üí UAVùëúùë¢ùë°

The algebra of security tests

106

Listing 5.2: Modeling hijacking

-- By iterating learning further decompose ùêø‚Ä≤
ùêº‚Ä≤, ùê∫‚Ä≤ , ùëÉ‚Ä≤
ùêº‚Ä≤, ùê∫‚Ä≤ , ùëÉ‚Ä≤ = (2,1)

: W

Ldiagram : Morphism W (ùêº‚Ä≤ ‚äó ùê∫‚Ä≤ ‚äó ùëÉ‚Ä≤) ‚Üí ùêø‚Ä≤
Ldiagram = (in, out)

where

ùëñùëõ √ó (ùêº‚Ä≤

in : Morphism Set (ùêø‚Ä≤
in l1 l2 i g p = (l1, l2, l1, l2, i, g)
ùëúùë¢ùë°) ‚Üí ùêø‚Ä≤
out : Morphism Set (ùêº‚Ä≤
out i g p = p

ùëúùë¢ùë° √ó ùê∫‚Ä≤

ùëúùë¢ùë° √ó ùê∫‚Ä≤

ùëúùë¢ùë° √ó ùëÉ‚Ä≤

ùëúùë¢ùë° √ó ùëÉ‚Ä≤

ùëúùë¢ùë°

ùëúùë¢ùë°) ‚Üí (ùêº‚Ä≤

ùëñùëõ √ó ùê∫‚Ä≤

ùëñùëõ √ó ùëÉ‚Ä≤

ùëñùëõ))

-- Rewriting attack
ùúÇ : NatTrans (Functor W ‚Üí Cat) ‚Üí (Functor W ‚Üí Cat)

-- ùúÇ is the identity on everything but G'
ùúÇ ùê∫‚Ä≤ : Morphism ‚Ñ¨ùê∫‚Ä≤ ‚Üí ‚Ñ¨ùê∫‚Ä≤
ùúÇ ùê∫‚Ä≤ = firmware rewriting

-- Rewiring attack
Lattack : Morphism W (ùêº‚Ä≤ ‚äó ùê∫‚Ä≤ ‚äó ùëÉ‚Ä≤) ‚Üí ùêø‚Ä≤
Lattack = (in, out)

where

ùëñùëõ √ó (ùêº‚Ä≤

in : Morphism Set (ùêø‚Ä≤
in l1 l2 i g p= (l1, l2, l1, 0, i, g)
ùëúùë¢ùë°) ‚Üí ùêø‚Ä≤
out : Morphism Set (ùêº‚Ä≤
out i g p = p

ùëúùë¢ùë° √ó ùê∫‚Ä≤

ùëúùë¢ùë° √ó ùê∫‚Ä≤

ùëúùë¢ùë° √ó ùëÉ‚Ä≤

ùëúùë¢ùë° √ó ùëÉ‚Ä≤

ùëúùë¢ùë°

ùëúùë¢ùë°) ‚Üí (ùêº‚Ä≤

ùëñùëõ √ó ùê∫‚Ä≤

ùëñùëõ √ó ùëÉ‚Ä≤

ùëñùëõ)

Rewiring : Functor W ‚Üí W

Rewiring Ldiagram = Lattack

-- The modified behavior of the hijacked UAV
behavior : ‚Ñ¨(UAV)
behavior = ùúÇ UAV (‚Ñ¨(Rewiring (UAV))) (ùëÜ‚Ä≤)

The algebra of security tests

107

Based on how we defined Yoneda reasoning, we identify sev-

limitations
eral limitations. These limitations can be overcome by enriching over metric spaces,
which we will also discuss. The main point of this section is to set a strong theoret-
ical footprint of category theory and the diagrammatic reasoning that emerges in
the application of securing cyber-physical systems. Making the results probabilis-
tically concrete is a potential future topic that can be based on the above formal
methods.

One such limitation can be inspected from the resulting algorithm (Listing 5.1).
As output we may have that Yoneda reasoning returns no result (the list being
filtered from K is empty, meaning that the attacker does not have entries in the
knowledge database that adequately model the target system), but we may also
have that it returns more than one (the list being filtered from K having more than
one element, meaning that the test performed were not fine-grained enough to
pinpoint the target system with deterministic accuracy). This is mainly due to the
nature of the tests performed. Indeed, some tests could be more informative than
others; sending any system in ‚Ñ¨(uav) to the one-element set defines a functor
to Set and hence a valid test, which is though maximally uninformative since the
test outcome will be the same on all systems; on the other hand, any injective-on-
objects functor Œò allows us to conclude with certainty that ŒòùëÜ = ŒòùëÜ‚Ä≤ implies
ùëÜ = ùëÜ‚Ä≤, and is hence maximally granular. The formalism as we presented it has
no way to express which subset of the tests we can perform allows to individuate
the target system unambiguously.

Indeed, there are tests with different degrees of expressiveness, and the Yoneda
lemma does not account for this; we are able to conclude ùëÜ ‚âÉ ùëÜ‚Ä≤ using Yoneda
lemma if and only if ùëÜ and ùëÜ‚Ä≤ agree on all tests, including the maximally useless
ones. This is why we speak of Yoneda reasoning as a heuristic and not as a deter-
ministic procedure.

Looking at things more abstractly, the ultimate reason for this shortcoming lies in
the fact that in our definition of category we considered homsets to be sets; that

The algebra of security tests

108

is, we speak of the set Hom ùíû [ùê¥, ùêµ] of all possible morphisms from ùê¥ to ùêµ in some
category ùíû. Sets have very little structure, and in such an environment we cannot
formulate the Yoneda lemma to be more expressive.

In a probabilistic setting, what we would like to have is a version of Yoneda rea-
soning that gives an interval of confidence relating ŒòùëÜ ‚âÉ ŒòùëÜ‚Ä≤ and ùëÜ ‚âÉ ùëÜ‚Ä≤ for any
possible test Œò. In other words, we want to attach to each Œò a measure of how
informative Œò is in our context.

This is certainly doable by resorting to enriched category theory, which is a gener-
alization of category theory where homsets can have more structure. In particu-
lar, we can reformulate our theory using categories enriched over metric spaces.
This gives a natural way of talking about distances between sets and this can be
used to ultimately define a measure on the tests we can perform. In the context
of enriched category theory, the Yoneda lemma can be reformulated in what it
is informally known as ninja Yoneda lemma¬†[110], which takes into account this
additional structure. We can use this to define a version of Yoneda lemma that
has a notion of confidence in the tests we perform over the cyber-physical system
model and, therefore, have some granularity of what it means for two systems to
be behaviorally equivalent under some (informative) tests.

benefits While we showed some limitations with regard to the flexibility of
the model, it is important to point out that the same flexibility can be beneficial.
Different formalisms can inhabit the boxes defining a systems behavior, from Petri
nets, to transition systems, to ordinary differential equations. The development
of our formalisms will allow us to speak about all these representations within one
framework. For example, applications to security modeling using Petri nets¬†[99]
is currently congruent with research in category theory and Petri nets¬†[13, 58‚Äì
60] and could be leveraged to make the application of the preceding formalism
more concrete as a model of (mis-)behavior. Similarly, both models of security
violations in automata¬†[166] and continuous controller behavior¬†[137] can be rep-
resented within our framework and, therefore, allow for a plethora of analyses

The algebra of security tests

109

within one model.

However, in order to drill further in the possible directions of describing different
types of continuous, for example false sensor data, or discrete, for example tran-
sitioning the system to a hazardous state, misbehaviors caused by exploitation
we require a first formulation of security modeling categorically and algebraically.
Relaxing some of the unrealistic assumptions we made is then a matter of incor-
porating developing work from category theory.

Additionally, this security framework is part of a alternate paradigm of systems
modeling that has its foundations in categorical modeling. In this framework it is
possible to provide formal traces requirements, behaviors, and architectures¬†[20]
but also describe a vast amount of dynamical systems with applications to robotics,
event-based systems, and hybrid systems, to name a few¬†[47, 55, 107, 172].

Finally, we addressed the theoretical underpinnings of security modeling in cate-
gory theory. But, the recent surge of categorical modeling languages and software,
such as Catlab¬†[68] or idris-ct¬†[61] or algebraic databases¬†[152], can be used to cre-
ate modeling tools and security assessment methods based on our work practical
within compositional cyber-physical systems theory.

We developed a categorical semantics for cyber-physical systems security mod-
eling that is able to determine that two system representations are behaviorally
equivalent provided that they agree on every test. The implication of this state-
ment is that it is possible to model attacker actions without necessarily needing to
give the attacker full observability on the system under attack. Additionally, we
model two types of attacks on the incomplete but erroneous view of the attacker
and show its impact on (what we consider to be) the real system. These attacks
can do either of two things: (1) rewriting some system component or (2) rewiring
an input or output from or to a component. This model is particularly useful for
cyber-physical systems, where in the future we would like to say how a particular
attack can change system behavior and, therefore, potentially transition it to a haz-
ardous state. Overall, we model how the attacker learns about a system and how

The algebra of security tests

110

an attacker then might attempt to hijack the system from the knowledge that they
were able to gather in a formal, unified way. Finally, the categorical formalism
can be considered foundational, in the sense that in addition to the contributions
above it can subsume already developed formalisms for modeling attacker actions,
for example attack graphs, or augment the information contained in the model by
using security frameworks.

The algebra of security tests

111

My last request: Everything I leave behind me ‚Ä¶ in
the way of diaries, manuscripts, letters (my own and
others‚Äôs), sketches and so on, to be burned unread.

‚Äî Franz Kafka

6 On unification

Having manifested the wiring diagram formalism for behavior, architecture and
requirements of a uav, we now summarize and further discuss how this categor-
ical interpretation of cyber-physical systems models leads to unification of these
aspects of system design and analysis.

Starting with some cyber-physical process ùëå , we usually model its behavior, math-
ematically described for example via some equations, and also the requirements it
satisfies or should satisfy. We earlier discussed Moore machines and linear time-
invariant systems; there can be other algebras of system behavior,1 so here we
generically speak of the ‚Äúbehavior algebra‚Äù which is any one of them, using the
notation ‚Ñ¨. As we saw, categorically these are certain objects ùêµùëå ‚àà ‚Ñ¨(ùëå ) of the
category of all the possible behaviors (section 3.2), and similarly the requirements
are objects ùëÖùëå ‚àà ùíû(ùëå ) of the category of all contracts that could be associated to
such a process, via lax monoidal functors

‚Ñ¨, ùíû ‚à∂ W ‚Üí Cat.

To formally discuss and capture the behavior and requirements in terms of subpro-
cesses, the designer first chooses some valid architecture of ùëå which is categori-
cally expressed by choosing a morphism ùëì ‚à∂ ùëã ‚Üí ùëå in the category W, namely an
element of the slice category W/ùëå (section 3.3). Then the behavior algebra and

1 For example, machines serve as an all-inclusive general system notion that allows us to compose

systems of different description [156, ¬ß 4].

113

requirements algebra, independently, produce assignments

ùëã

ùëì

ùëå

‚Ñ¨(ùëã)

‚Ñ¨(ùëì)

‚Ñ¨(ùëå )

ùíû(ùëã)

ùíû(ùëì)

ùíû(ùëå )

(6.1)

The designer then decides on ‚Äúpre-image‚Äù objects ùêµùëã ‚àà ‚Ñ¨(ùëã) and ùëÖùëã ‚àà ùíû(ùëã)
which, under these functors on the right-hand side, produce the original compos-
ite behavior and requirement on ùëå . As we saw, there could be multiple choices
for ùêµùëã and ùëÖùëã. Also, the designer can decompose even further to subprocesses,
on which the analysis carries on in the same formal way. Moreover, they may
choose to go back and change the architecture to some alternative implementa-
tion ùëî ‚à∂ ùëç ‚Üí ùëå , if that is physically sensible and allows to easier obtain the end
results. Later on, using algorithms such tests could assist in deciding on the most
optimal solutions.

The main contribution is we now sketch some additional connections between
these two independent algebras of behavior and requirements, which further clar-
ify their formal relation.

First of all, there is an algebra map2 ùõº ‚à∂ ‚Ñ¨ ‚áí ùíû which assigns to each specific
physical behavior of a process ùêµùëå ‚àà ‚Ñ¨(ùëå ), the maximally satisfied contract by it,
ùõºùëå (ùêµùëå ) ‚àà ùíû(ùëå ). Informally, if a box
‚Ñù is inhabited by the function ùëì(ùë•) =
ùëã‚Ñù
6ùë•, its maximally satisfied contract is in effect {(ùëé, 6ùëé) | ùëé ‚àà ‚Ñù} ‚äÜ ‚Ñù2. However,
the system also satisfies the contracts ‚Ñù √ó 6‚Ñù or ‚Ñù √ó 3‚Ñù, or even ‚Ñù √ó ‚Ñù as the

2 Formally, this is a monoidal natural transformation between the two lax monoidal func-

tors¬†[112].

On unification

114

maximum such. The fact that the assignment ‚Ñ¨(ùëå ) ‚àã ùêµùëå ‚Ü¶ ùõºùëå (ùêµùëå ) ‚àà ùíû(ùëå )
is an algebra map signifies in particular that the above mappings (6.1) are part of
a commutative square relating system behavior and requirements for a specific
wiring diagram ùëì ‚à∂ ùëã ‚Üí ùëå

‚Ñ¨(ùëã)

ùõºùëã

ùíû(ùëã)

‚Ñ¨(ùëì)

ùíû(ùëì)

‚Ñ¨(ùëå )

ùõºùëå

ùíû(ùëå )

Intuitively, this says that for a given system decomposition into subcomponents,
first composing the behaviors of the internal boxes using the behavior algebra and
then talking about the contract that composite satisfies is the same as first comput-
ing the maximal contracts the components satisfy individually and then compos-
ing using the contract algebra. This provides extra flexibility for passing between
different models, not only for this specific algebra map example but also for other
maps relating different algebras that may be established.

Another way to combine the behavior ‚Ñ¨ and requirements ùíû algebra is to con-
struct a new algebra of contracted behaviors that, to each process placeholder ùëå
assigns a pair of a physical behavior along with some contract it satisfies. This
allows us to compose using both algebras simultaneously and choosing which in-
formation to look at; this abstract algebra is already defined [156, Prop. 4.5.5] for
a specific behavior algebra and provides a tool that allows us to essentially relate
two algebras via some desired condition inside their product.

We have addressed a unification between requirements and system behaviors. An-
other unification present in this dissertation is that of system behavior and archi-
tecture in the form of traceable decompositions between a specific behavioral for-
malism and a candidate architecture that implements this formalism in hardware
and software. This is implemented categorically through the notion of slice cat-
egory, where all design choices reside. This means that we still need the exper-
tise of systems designers to construct a correct system architecture. The traces

On unification

115

between system behavior and system architecture (de)compose properly as long
as the candidate system architecture constitutes a viable solution to the particular
design problem of controlling a process.

Finally, there is composition between analyses techniques. Using the scaffolding
of verified composition between requirements, system behaviors, and systems ar-
chitectures it is possible to assure a subset of safety properties via contracts. Then,
using the system architecture it is possible to do a security analysis via tests using
the system architecture. This can take the form of finding attack patterns, weak-
nesses, and vulnerabilities in a hypothetical scenario and then using that informa-
tion to mitigate possible hazardous states by knowing which parts of the system
are most vulnerable to attackers.

The result of this theoretical foundation is precisely this unification between dis-
tinct models that can then be used to better assure the safety and security of the
system as a whole only by examining the relationships between its parts and in-
terfaces. This does not mean we eradicate emergent behavior but that we have a
strategy of controlling the effects of emergent behavior.

Concretely, the contributions of this thesis are as follows:

contribution 1

contribution 2

contribution 3

A type-oriented algebraic defition of contract theory and a
compositional model of linear time-invariant systems using
the ideas of functorial semantics.

A unification between safety requirements and system be-
haviors within contract theory and control using the funda-
mental notion of the natural transformation.

A hierarchical way of decomposing to architectures using
the notion of the slice category that can then be used to do
component-based security analysis.

On unification

116

Category theory is often called abstract nonsense. Yet, we show that category the-
ory can be used to solve a significant and practical problem in cyber-physical sys-
tems. By studying how different notions of a system relate with each other instead
of what each individual notion is, it is possible to construct semantics that could
lead to unification of modeling paradigms, under one formalism, which could then
allow metrics to propagate throughout the requirements generation, behavioral
description, and architecture implementation stages of a systems lifecycle. In the
future this could be streamlined by the creation of new tools based on categorical
notions of system models.

Telos.

On unification

117

Endnotes

Chapter 0: The general idea for this chapter is adapted from Paruchuri [138] and
partially includes content from an article I wrote for Increment [15].

Chapter 1: The chapter partially contains material from an article written with
Subrahmanian and Fleming [23].

Chapter 2: The title of the chapter is inspired by a similar one by Spivak [158].
Part of this chapter was written collaboratively with Fleming, Genovese and Vasi-
lakopoulou [20, 21].

Chapter 3 & 4: The chapter is edited from work conducted and coauthored with
Fleming and Vasilakopoulou [20].

Chapter 5: The chapter is edited from work conducted and coauthored with Flem-
ing and Genovese [21].

Chapter 6: The chapter is edited from work conducted and coauthored with Flem-
ing and Vasilakopoulou [20].

118

Bibliography

[1]

[2]

L. Ablon, M. C. Libicki, and A. A. Golay. Markets for cybercrime tools and
stolen data: Hackers‚Äô bazaar. Technical Report RR-610-JNI, Rand Cor-
poration, 2014. URL https://www.rand.org/pubs/research_
reports/RR610.html.

In
S. Abramsky and B. Coecke. Categorical quantum mechanics.
Handbook of Quantum Logic and Quantum Structures. Elsevier, 2009.
doi:10.1016/B978-0-444-52869-8.50010-4.

[3] H. Alemzadeh, C. Di Martino, Z. Jin, Z. T. Kalbarczyk, and R. K.
Iyer. Towards resiliency in embedded medical monitoring devices.
In
Proceedings of the 42nd Annual IEEE/IFIP International Conference on
Dependable Systems and Networks Workshops (DSN 2012). IEEE, 2012.
doi:10.1109/DSNW.2012.6264662.

[4] H. Alemzadeh, R. K. Iyer, Z. Kalbarczyk, and J. Raman. Analysis of safety-
critical computer failures in medical devices. IEEE Security & Privacy, 2013.
doi:10.1109/MSP.2013.49.

[5]

F. Allg√∂wer, J. B. de Sousa, J. Kapinski, P. Mosterman, J. Oehlerk-
ing, P. Panciatici, M. Prandini, A. Rajhans, P. Tabuada, and P. Wenzel-
burger. Position paper on the challenges posed by modern applications to
cyber-physical systems theory. Nonlinear Analysis: Hybrid Systems, 2019.
doi:10.1016/j.nahs.2019.05.007.

119

[6]

[7]

[8]

R. Alur. Principles of Cyber-Physical Systems. The MIT Press, 2015. ISBN
0262029111, 9780262029117.

R. Alur, T. A. Henzinger, G. Lafferriere, and G. J. Pappas.
crete abstractions of hybrid systems.
doi:10.1109/5.871304.

Dis-
Proceedings of the IEEE, 2000.

R. Alur, S. Moarref, and U. Topcu. Compositional and symbolic synthesis
of reactive controllers for multi-agent systems. Information and Computa-
tion, 2018. doi:10.1016/j.ic.2018.02.021.

[9] A. D. Ames. A categorical theory of hybrid systems. PhD thesis, University

of California, Berkeley, 2006.

[10] P. Asare, G. Bakirtzis, R. Bernard, D. Broman, E. Lee, G. Prinsloo,
M. Torngren, and S. Sunder. Cyber-physical systems ‚Äì a concept map.
URL https://cyberphysicalsystems.org or https://perma.
cc/NQ6T-AVH5, 2020.

[11] A. Avizienis, J.-C. Laprie, B. Randell, and C. E. Landwehr. Basic concepts
and taxonomy of dependable and secure computing. IEEE Transactions on
Dependable and Secure Computing, 2004. doi:10.1109/TDSC.2004.2.

[12]

J. Baez and M. Stay. Physics, topology, logic and computation: A rosetta
stone. In New Structures for Physics. Springer, 2011. doi:10.1007/978-3-642-
12821-9_2.

[13]

J. C. Baez and J. Master. Open Petri nets. Mathematical Structures in Com-
puter Science, 2020. doi:10.1017/S0960129520000043.

[14] L. Bainbridge. Ironies of automation. Automatica, 1983. doi:10.1016/0005-

1098(83)90046-8.

[15] G. Bakirtzis. Responsible development for the physical world. URL

https://perma.cc/97BM-D8Z6, 2021. Increment.

Bibliography

120

[16] G. Bakirtzis, B. T. Carter, C. R. Elks, and C. H. Fleming. A model-based ap-
proach to security analysis for cyber-physical systems. In Proceedings of the
2018 Annual IEEE International Systems Conference (SysCon 2018). IEEE,
2018. doi:10.1109/SYSCON.2018.8369518.

[17] G. Bakirtzis, B. J. Simon, A. G. Collins, C. H. Fleming, and C. R. Elks. Data-
IEEE
driven vulnerability exploration for design phase system analysis.
Systems Journal, 2020. doi:10.1109/JSYST.2019.2940145.

[18] G. Bakirtzis, C. Vasilakopoulou, and C. H. Fleming. Compositional cyber-
physical systems modeling. In Proceedings of the 2019 Applied Category The-
ory Conference (ACT 2020), EPTCS, 2020. doi:10.4204/EPTCS.333.9.

[19] G. Bakirtzis, G. L. Ward, C. J. Deloglos, C. R. Elks, B. M. Horowitz, and
C. H. Fleming. Fundamental challenges of cyber-physical systems security
modeling. In Proceedings of the 50th IFIP/IEEE International Conference on
Dependable Systems and Networks (DSN). IEEE, 2020. doi:10.1109/DSN-
S50200.2020.00021.

[20] G. Bakirtzis, C. H. Fleming, and C. Vasilakopoulou. Categorical seman-
tics of cyber-physical systems theory. ACM Transactions on Cyber-Physical
Systems, 2021.

[21] G. Bakirtzis, F. Genovese, and C. H. Fleming. Yoneda hacking: The algebra

of attacker actions. arXiv:2103.00044 [cs.CR], 2021.

[22] G. Bakirtzis, T. Sherburne, S. C. Adams, B. M. Horowitz, P. A. Beling,
and C. H. Fleming. An ontological metamodel for cyber-physical system
safety, security, and resilience coengineering. Software and Systems Model-
ing, 2021.

[23] G Bakirtzis, E. Subrahmanian, and C. H. Fleming. Compositional thinking

in cyber-physical systems theory. Computer, 2021.

Bibliography

121

[24] R. Banach, M. J. Butler, S. Qin, and H. Zhu. Core hybrid Event-B II: mul-
tiple cooperating hybrid Event-B machines. Science of Computer Program-
ming, 2017. doi:10.1016/j.scico.2016.12.003.

[25] Z. Basnight, J. Butts, J. Lopez Jr., and T. Dube. Firmware modification
attacks on programmable logic controllers. International Journal of Critical
Infrastructure Protection, 2013. doi:10.1016/j.ijcip.2013.04.004.

[26]

J. L. Bates and R. L. Constable. Proofs as programs. ACM Transactions on
Programming Languages and Systems, 1985. doi:10.1145/2363.2528.

[27] S. M. Bellovin. Thinking Security: Stopping Next Year‚Äôs Hackers. Addison-

Wesley, 2015. ISBN 9780134699462.

[28] S. M. Bellovin and D. G. Conway. Security as a systems property. IEEE

Security & Privacy, 2009. doi:10.1109/MSP.2009.134.

[29] A. Benveniste, B. Caillaud, D. Nickovic, R. Passerone, J.-B. Raclet,
P. Reinkemeier, A. L. Sangiovanni-Vincentelli, W. Damm, T. A. Hen-
zinger, and K. G. Larsen. Contracts for system design. Research Report,
RR-8147, INRIA, 2012.

[30] A. Benveniste, B. Caillaud, D. Nickovic, R. Passerone, J.-B. Raclet,
P. Reinkemeier, A. L. Sangiovanni-Vincentelli, W. Damm, T. A. Hen-
zinger, and K. G. Larsen. Contracts for system design. Foundations and
Trends in Electronic Design Automation, 2018. doi:10.1561/1000000053.

[31] C. Biesecker.

hacking, DHS says.

Boeing 757 testing shows airplanes vulnerable to
URL https://web.archive.org/web/

20200623051237/https://www.aviationtoday.com/

2017/11/08/boeing-757-testing-shows-airplanes-

vulnerable-hacking-dhs-says/

or

https://perma.cc/

KEE4-GLBV, 2017. Avionics.

Bibliography

122

[32] S. Bliudze, S. Furic, J. Sifakis, and A. Viel. Rigorous design of cyber-
physical systems ‚Äì linking physicality and computation. Software and Sys-
tems Modeling, 2019. doi:10.1007/s10270-017-0642-5.

[33] G. Boisseau and J. Gibbons. What you needa know about Yoneda: Profunc-
tor optics and the Yoneda lemma (functional pearl). Proceedings of the ACM
on Programming Languages, 2018. doi:10.1145/3236779.

[34] P. Bouyer and A. Petit. Decomposition and composition of timed automata.
In Proceedings of the 26th International Colloquium on Automata, Languages
and Programming (ICALP 1999), Lecture Notes in Computer Science, 1999.
doi:10.1007/3-540-48523-6_18.

[35] S. J. Breiner, B. S. Pollard, and E. Subrahmanian. Workshop on applied
category theory: Bridging theory and practice. Special publication (nist sp)
- 1249, NIST, 2020.

[36]

J. Buck, S. Ha, E. A. Lee, and D. G. Messerschmitt. Ptolemy: A frame-
work for simulating and prototyping heterogeneous systems. In Readings
in hardware/software co-design. ACM, 2001. ISBN 1558607021.

[37] A. A. C√°rdenas, S. Amin, and S. Sastry.

Research challenges for
the security of control systems.
In Proceedings of the 3rd USENIX
Workshop on Hot Topics in Security (HotSec 2008). USENIX Association,
2008. URL http://www.usenix.org/events/hotsec08/tech/
full_papers/cardenas/cardenas.pdf.

[38] R. V. Carlone, M. Blair, S. Obenski, and P. Bridickas. Patriot missile de-
fense: Software problem led to system failure at Dhahran, Saudi Arabia.
Technical Report IMTEC-92-26, 1992.

[39] B. T. Carter, G. Bakirtzis, C. R. Elks, and C. H. Fleming. A systems ap-
proach for eliciting mission-centric security requirements. In Proceedings

Bibliography

123

of the 2018 Annual IEEE International Systems Conference (SysCon 2018).
IEEE, 2018. doi:10.1109/SYSCON.2018.8369539.

[40] B. T. Carter, S. C. Adams, G. Bakirtzis, T. Sherburne, P. A. Bel-
ing, B. M. Horowitz, and C. H. Fleming.
A preliminary design-
phase security methodology for cyber-physical systems. Systems, 2019.
doi:10.3390/systems7020021.

[41] B. T. Carter, G. Bakirtzis, C. R. Elks, and C. H. Fleming. Systems-theoretic
security requirements modeling for cyber-physical systems. Syst. Eng.,
2019. doi:10.1002/sys.21504.

[42] B. Chapman. What are your intentions?

;login:, 2001.

URL

https://web.archive.org/web/20200923140116/https:

//www.usenix.org/system/files/login/articles/1794-

chapman.pdf.

[43] S. Checkoway, D. McCoy, B. Kantor, D. Anderson, H. Shacham,
S. Savage, K. Koscher, A. Czeskis, F. Roesner, and T. Kohno. Com-
prehensive experimental analyses of automotive attack surfaces.
In
Proceedings of the 20th USENIX Security Symposium. USENIX, 2011. URL

https://web.archive.org/web/20200709100229/https:

//static.usenix.org/events/sec11/tech/full_papers/

Checkoway.pdf.

[44] B. Coecke.

Quantum picturalism.

Contemporary physics, 2010.

doi:10.1080/00107510903257624.

[45] Darren Cofer, Andrew Gacek, Steven Miller, Michael W Whalen, Brian
LaValley, and Lui Sha. Compositional verification of architectural models.
In Proceedings of the 4th International Symposium on NASA Formal Methods
(NFM 2012), Lecture Notes in Computer Science, 2012. doi:10.1007/978-
3-642-28891-3_13.

Bibliography

124

[46] Computest. The connected car: Ways to get unauthorized access and po-
tential implications. Technical report, 2018. URL https://perma.cc/
R3W3-CR6R.

[47]

J. Culbertson, P. Gustafson, D. E. Koditschek, and P. F. Stiller. Formal
composition of hybrid systems. arXiv 1911.01267 [math.CT], 2020.

[48] A. Datta, J. Franklin, D. Garg, L. Jia, and D. K. Kaynar. On adver-
IEEE Security & Privacy, 2011.

sary models and compositional security.
doi:10.1109/MSP.2010.203.

[49] Z. Diskin, T. Maibaum, and K. Czarnecki. A model management imper-
ative: Being graphical is not sufficient, you have to be categorical. In Pro-
ceedings of the 11th European Conference on Modelling Foundations and Appli-
cations (ECMFA), 2015. doi:10.1007/978-3-319-21151-0_11.

[50]

I. Dragomir, I. Ober, and C. Percebois. Contract-based modeling and ver-
ification of timed safety requirements within SysML. Software & Systems
Modeling, 2017. doi:10.1007/s10270-015-0481-1.

[51] K. E. Drexler. Radical abundance: How a revolution in nanotechnology will

change civilization. PublicAffairs, 2013. ISBN 1610391144.

[52] D. Evans.
curity.
https://sos.cs.virginia.edu/, 2008.

NSF/IARPA/NSA workshop on the science of se-

https://web.archive.org/web/20200705152357/

[53] C. H. Fleming, C. R. Elks, G. Bakirtzis, S. C. Adams, B. T. Carter, P. A.
Beling, and B. M. Horowitz. Cyber-physical security through resiliency: A
systems-centric approach. Computer, 2021.

[54] B. Fong and D. I. Spivak. An invitation to applied category theory: seven

sketches in compositionality. Cambridge University Press, 2019.

Bibliography

125

[55] B. Fong, A. Speranzon, and D. I. Spivak. Temporal landscapes: A graphical

temporal logic for reasoning, 2019. arXiv:1904.01081 [math.LO].

[56] F. R. Frola and C. O. Miller.

quisition.

Logistics Management

System safety in aircraft ac-
Institute,

https:

1984.

//web.archive.org/web/20190220001915/https:

//apps.dtic.mil/dtic/tr/fulltext/u2/a141492.pdf

or https://perma.cc/QYV7-C5BY.

[57] M. Gell-Mann.

Complexity at

large.

Complexity,

1996.

doi:10.1002/cplx.6130010502.

[58] F. Genovese and J. Herold.

Executions in (semi-)integer Petri nets
are compact closed categories.
In Proceedings of the 15th Interna-
tional Conference on Quantum Physics and Logic (QPL), EPTCS, 2019.
doi:10.4204/EPTCS.287.7.

[59] F. Genovese and J. Herold. The mathematical specification of the statebox

language. arXiv 1906.07629 [cs.PL], 2019.

[60] F. Genovese, A. Gryzlov, J. Herold, M. Perone, E. Post, and A. Videla.
arXiv

Computational Petri nets: Adjunctions considered harmful.
1904.12974 [math.CT], 2019.

[61] F. Genovese, A. Gryzlov, J. Herold, A. Knispel, M. Perone, E. Post, and
A. Videla. idris-ct: A library to do category theory in idris. In Proceedings
of the 2019 Applied Category Theory Conference (ACT 2019), EPTCS, 2020.
doi:10.4204/EPTCS.323.16.

[62] K. Ghasemi, S. Sadraddini, and C. Belta. Compositional synthesis via a
convex parameterization of assume-guarantee contracts. In Proceedings of
the 23rd ACM International Conference on Hybrid Systems: Computation and
Control (HSCC ‚Äô20), 2020. doi:10.1145/3365365.3382212.

Bibliography

126

[63] M. Giles. Triton is the world‚Äôs most murderous malware, and it‚Äôs spread-
ing. URL https://perma.cc/5QS8-U37C, 2019. MIT Technology
Review.

[64]

J. Giraldo, E. Sarkar, A. A. C√°rdenas, M. Maniatakos, and M.Kantarcioglu.
Security and privacy in cyber-physical systems: A survey of surveys. IEEE
Design & Test, 2017. doi:10.1109/MDAT.2017.2709310.

[65] D. Goodin.
shocks.

Hack causes pacemakers to deliver life-threatening
URL https://web.archive.org/save/https:

//arstechnica.com/information-technology/2018/08/

lack-of-encryption-makes-hacks-on-life-saving-

pacemakers-shockingly-easy/ or https://perma.cc/XL9C-
AEEB, 2018. Ars Technica.

[66] GReAT and AMR.
ply chain attack.

Operation ShadowHammer: a high-profile sup-
URL https://web.archive.org/web/

20200922135758/https://securelist.com/operation-

shadowhammer-a-high-profile-supply-chain-attack/

90380/ or https://perma.cc/H84J-JXEG, 2019. Kaspersky.

[67] N. Grossman. Extracting a 19 year old code execution from WinRAR. URL

https://web.archive.org/web/20200923134543/https:

//research.checkpoint.com/2019/extracting-code-

execution-from-winrar/ or https://perma.cc/C4LX-AMZV,
2019. Check Point Research.

[68] M. Halter, E. Patterson, A. Baas, and J. Fairbanks. Compositional scien-
tific computing with catlab and semantic models, 2020. arXiv:2005.04831
[math.CT].

[69]

J. Hansen and R. Ghrist. Opinion dynamics on discourse sheaves.
arXiv:2005.12798 [math.DS], 2020.

Bibliography

127

[70]

J. M. Hedges. Towards compositional game theory. PhD thesis, Queen Mary
University of London, 2016.

[71] C. Herley and P. C. van Oorschot. SoK: Science, security and the elu-
sive goal of security as a scientific pursuit. In Proceedings of the 2017 IEEE
Symposium on Security and Privacy (S&P). IEEE Computer Society, 2017.
doi:10.1109/SP.2017.38.

[72] B. P. Jacobs. Categorical Logic and Type Theory. North-Holland, 2001. ISBN

978-0-444-50853-9.

[73]

J. Jang-Jaccard and S. Nepal.
cybersecurity.
doi:10.1016/j.jcss.2014.02.005.

A survey of emerging threats in
Journal of Computer and System Sciences, 2014.

[74] C. Johnson. CyberSafety: On the interactions between cybersecurity and
the software engineering of safety-critical systems. Achieving System Safety,
2011. doi:10.1007/978-1-4471-2494-8_8.

[75] A. Joyal and R. Street. Braided tensor categories. Advances in Mathematics,

1993. doi:10.1006/aima.1993.1055.

[76] M. Mazo Jr., A. Davitian, and P. Tabuada. PESSOA: A tool for embedded
controller synthesis. In Proceedings of the 22nd International Conference on
Computer Aided Verification (CAV 2010), Lecture Notes in Computer Sci-
ence. Springer, 2010. doi:10.1007/978-3-642-14295-6_49.

[77] Keenlab. Experimental security assessment of BMW cars: A summary re-
port. URL https://web.archive.org/web/20200728030925/

https://keenlab.tencent.com/en/whitepapers/

Experimental_Security_Assessment_of_BMW_Cars_by_

KeenLab.pdf or https://perma.cc/QUE4-3P6C.
report, 2018.

Technical

Bibliography

128

[78] K. B. Kelarestaghi, M. Foruhandeh, K. Heaslip, and R. Gerdes.

Intelli-
gent transportation system security: Impact-oriented risk assessment of in-
vehicle networks. IEEE Intelligent Transportation Systems Magazine, 2019.
doi:10.1109/MITS.2018.2889714.

[79] R. Khan, P. Maynard, K. McLaughlin, D. M. Laverty, and S. Sezer. Threat
analysis of BlackEnergy malware for synchrophasor based real-time control
and monitoring in smart grid. In Proceedings of the 4th International Sym-
posium for ICS & SCADA Cyber Security Research 2016 (ICS-CSR 2016).
eWiC, 2016. doi:10.14236/ewic/ICS2016.7.

[80] E. S. Kim, M. Arcak, and S. A. Seshia. A small gain theorem for para-
metric assume-guarantee contracts. In Proceedings of the 20th International
Conference on Hybrid Systems: Computation and Control (HSCC ‚Äô17), 2017.
doi:10.1145/3049797.3049805.

[81] P. Koopman. Practical experience report: Automotive safety practices vs.
accepted principles. In Proceedings of 37th International Conference on Com-
puter Safety, Reliability, and Security (SAFECOMP 2018). Springer, 2018.
doi:10.1007/978-3-319-99130-6_1.

[82] H. Kopetz. Simplicity is Complex: Foundations of Cyber-Physical System De-

sign. Springer, 2019. doi:10.1007/978-3-030-20411-2.

[83] K. Koscher, A. Czeskis, F. Roesner, S. Patel, T. Kohno, S. Checkoway,
D. McCoy, B. Kantor, D. Anderson, H. Shacham, and S. Savage. Experi-
mental security analysis of a modern automobile. In 2010 IEEE Symposium
on Security and Privacy (S&P 2010). IEEE, 2010. doi:10.1109/SP.2010.34.

[84] D. B. Kramer, M. Baker, B. Ransford, A. Molina-Markham, Q. Stewart,
K. Fu, and M. R. Reynolds. Security and privacy qualities of medical
devices: An analysis of FDA postmarket surveillance. PLoS One, 2012.
doi:10.1371/journal.pone.0040200.

Bibliography

129

[85] N. Kshetri and J. M. Voas. Hacking power grids: A current problem. Com-

puter, 2017. doi:10.1109/MC.2017.4451203.

[86] L. Kuper. Gilbert and Lynch‚Äôs ‚ÄúBrewer‚Äôs conjecture and the feasi-
bility of consistent, available, partition tolerant web services‚Äù. URL

https://web.archive.org/web/20190314192644/https:

//raw.githubusercontent.com/lkuper/CMPS290S-2018-

09/master/presentations/2018-10-01-cap.pdf

or

https://perma.cc/MEU6-SMZP, 2018. Lecture notes.

[87] Kaspersky Lab. Operation ShadowHammer: new supply chain attack
threatens hundreds of thousands of users worldwide. URL https://
perma.cc/5QQ4-7T4Y, 2019. Kaspersky.

[88] L. A. Lambe. Category theory for engineers. Technical Report MSSRC-
TR-01-262-2018, 2018. URL https://web.archive.org/web/

20200921150033/https://www.nasa.gov/sites/default/

files/atoms/files/mssrc_uah_nasa_30-09-2018.pdf.

[89]

J. Lambert. Defenders think in lists. Attackers think in graphs. As long as
this is true, attackers win. https://perma.cc/6NZ2-A2HY, 2015.

[90] L. Lamport. Specifying systems: The TLA+ language and tools for hardware
and software engineers. Addison-Wesley, 2002. ISBN 0-3211-4306-X.

[91] C. E. Landwehr. Cybersecurity: From engineering to science. Next Wave,

2012.

[92] R. Langner. Stuxnet: Dissecting a cyberwarfare weapon. IEEE Security &

Privacy, 2011. doi:10.1109/MSP.2011.67.

[93] T. T. H. Le, R. Passerone, U. Fahrenberg, and A. Legay. Contract-based
requirement modularization via synthesis of correct decompositions. ACM
Transactions on Embedded Computing Systems, 2016. doi:10.1145/2885752.

Bibliography

130

[94] E. Lee.

Modeling in engineering and science.

URL https:

//web.archive.org/web/20200728030357/http://

platoandthenerd.org/blog/modeling-in-engineering-

and-science or https://perma.cc/V7D3-TVHB, 2018. Plato and
the Nerd.

[95] E. A. Lee. Cyber-physical systems ‚Äì Are computing foundations adequate.
Position Paper for NSF Workshop on Cyber-Physical Systems: Research
Motivation, Techniques and Roadmap, 2006.

[96] E. A. Lee. Fundamental limits of cyber-physical systems modeling. ACM
Transactions on Cyber-Physical Systems, 2016. doi:10.1145/2912149.

[97] E. A. Lee and M. Sirjani. What good are models? In Proceedings of the 15th
International Conference on Formal Aspects of Component Software (FACS
2018), Lecture Notes in Computer Science, 2018. doi:10.1007/978-3-030-
02146-7_1.

[98] T. Leinster. Basic Category Theory. Cambridge University Press, 2014.

doi:10.1017/CBO9781107360068.

[99] V. Lesi, Z. Jakovljevic, and M. Pajic. Security analysis for distributed IoT-

based industrial automation. arXiv:2006.00044, 2020.

[100] N. Leveson. Systemic factors in software-related spacecraft accidents.
In Proceedings of the AIAA Space 2001 Conference and Exposition, 2001.
doi:10.2514/6.2001-4763.

[101] N. G. Leveson. Safeware: System safety and computers. Addison-Wesley,

1995. ISBN 978-0-201-11972-5.

[102] N. G. Leveson. Engineering a safer world: Systems thinking applied to safety.

MIT Press, 2011. ISBN 9780262016629.

Bibliography

131

[103] N. G. Leveson.

The Therac-25: 30 years later.

Computer, 2017.

doi:10.1109/MC.2017.4041349.

[104] N. G. Leveson. Are you sure your software will not kill anyone? Commu-

nications of the ACM, 2020. doi:10.1145/3376127.

[105] N. G. Leveson and C. S. Turner. An investigation of the Therac-25 acci-

dents. Computer, 1993. doi:10.1109/MC.1993.274940.

[106] S. Levin and J. C. Wong. Self-driving Uber kills Arizona woman in first fa-
tal crash involving pedestrian. URL https://perma.cc/AX2D-A8A6,
2018. Guardian.

[107] S. Libkind.

An algebra of

resource sharing machines, 2020.

arXiv:2007.14442 [math.CT].

[108] H. Lin, H. Alemzadeh, D. Chen, Z. T. Kalbarczyk, and R. K. Iyer. Safety-
critical cyber-physical attacks: analysis, detection, and mitigation. In Pro-
ceedings of the Symposium and Bootcamp on the Science of Security (HotSoS
2016). ACM, 2016. doi:10.1145/2898375.2898391.

[109] M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, J. Horn, S. Man-
gard, P. Kocher, D. Genkin, Y. Yarom, M. Hamburg, and R. Strackx. Melt-
down: reading kernel memory from user space. Communications of the
ACM, 2020. doi:10.1145/3357033.

[110] Fosco Loregian. Coend calculus. arXiv 1501.02503 [math.CT], 2019.

[111] S. Lunel, S. Mitsch, B. Boyer, and J.-P. Talpin. Parallel composition
and modular verification of computer controlled systems in differential dy-
namic logic. In Proceedings of the Third World Congress of Formal Methods
(FM 2019), Lecture Notes in Computer Science, 2019. doi:10.1007/978-3-
030-30942-8_22.

Bibliography

132

[112] S. Mac Lane. Categories for the working mathematician. Springer, 1998.

ISBN 978-1-4757-4721-8.

[113] S. MacLane and I. Moerdijk. Sheaves in geometry and logic: a first introduction

to topos theory. Springer, 1992. doi:10.1007/978-1-4612-0927-0.

[114] A. Marshall and A. Davies. Uber‚Äôs self-driving car saw the woman it killed,
report says. URL https://perma.cc/9MP4-MSZ4, 2018. Wired.

[115] G. Masetti, S. Chiaradonna, F. Di Giandomenico, B. Feddersen, and
W. H. Sanders. An efficient strategy for model composition in the
m√∂bius modeling environment. In Proceedings of the 14th European Depend-
able Computing Conference (EDCC 2018). IEEE Computer Society, 2018.
doi:10.1109/EDCC.2018.00029.

[116] David Maynor. OS X kernel-mode exploitation in a weekend. Technical

report, Errata Security, 2007.

[117] M. D. Mesarovic and Y. Takahara. General systems theory: mathematical

foundations. Academic press, 1975. ISBN 9780080956220.

[118] M. D. Mesarovic and Y. Takahara. Abstract Systems Theory. Springer, 1989.

ISBN 978-3-540-46038-1.

[119] B. Messner, D. Tilbury, R. Hill, and J. D. Taylor. Control tutorials

for Matlab and Simulink: Aircraft pitch.

https://web.archive.

org/web/20200509164711/http://ctms.engin.umich.

edu/CTMS/index.php?example=AircraftPitch&section=

SystemModeling, 2020.

[120] V. C. Moreno, G. Reniers, E. Salzano, and V. Cozzani.

Analy-
sis of physical and cyber security-related events in the chemical and
process industry.
Process Safety and Environmental Protection, 2018.
doi:10.1016/j.psep.2018.03.026.

Bibliography

133

[121] A. M√ºller, S. Mitsch, W. Retschitzegger, W. Schwinger, and A. Platzer.
Tactical contract composition for hybrid system component verifica-
tion. International Journal on Software Tools for Technology Transfer, 2018.
doi:10.1007/s10009-018-0502-9.

[122] B. A. Myers. Taxonomies of visual programming and program visualiza-
tion. Journal of Visual Languages & Computing, 1990. doi:10.1016/S1045-
926X(05)80036-9.

[123] National Research Council.
physical systems education.
doi:10.17226/21762.

Interim report on the 21st century cyber-
The National Academies Press, 2015.

[124] National Transportation Safety Board.

Preliminary report highway
hwy18mh010. Technical report, 2018. URL https://perma.cc/
57YP-YMKW.

[125] National Transportation Safety Board. Collision between vehicle con-
trolled by developmental automated driving system and pedestrian. Tech-
nical report, 2019. URL https://perma.cc/57LG-Z4YE.

[126] A. Nejati, S. Soudjani, and M. Zamani. Compositional abstraction-based
synthesis for continuous-time stochastic hybrid systems. European Journal
of Control, 2021. doi:10.1016/j.ejcon.2020.04.001.

[127] P. G. Neumann. Computer-related risks. Addison-Wesley, 1994.

ISBN

020155805X.

[128] L. V. Nguyen, K. A. Hoque, S. Bak, S. Drager, and T. T. Johnson. Cyber-
physical specification mismatches. ACM Transactions on Cyber-Physical Sys-
tems, 2018. doi:10.1145/3170500.

[129] D. M. Nicol, W. H. Sanders, and K. S. Trivedi. Model-based evaluation:
From dependability to security. Transactions on Dependable and Secure Com-
puting, 2004. doi:10.1109/TDSC.2004.11.

Bibliography

134

[130] D. Norman. The design of everyday things: Revised and expanded edition. Basic

Books (AZ), 2013. ISBN 9780465050659.

[131] B. Nuseibeh. Soapbox: Ariane 5: Who dunnit?

IEEE Software, 1997.

doi:10.1109/MS.1997.589224.

[132] P. Nuzzo and A. L. Sangiovanni-Vincentelli. Hierarchical system design
with vertical contracts. In Principles of Modeling - Essays Dedicated to Ed-
ward A. Lee on the Occasion of His 60th Birthday, Lecture Notes in Computer
Science. Springer, 2018. doi:10.1007/978-3-319-95246-8_22.

[133] P. Nuzzo, A. L. Sangiovanni-Vincentelli, D. Bresolin, L. Geretti, and
T. Villa. A platform-based design methodology with contracts and related
tools for the design of cyber-physical systems. Proceedings of the IEEE, 2015.
doi:10.1109/JPROC.2015.2453253.

[134] P. Nuzzo, M. Lora, Y. A. Feldman, and A. L. Sangiovanni-Vincentelli.
CHASE: contract-based requirement engineering for cyber-physical
In Proceedings of the 2018 Design, Automation &
system design.
Test
IEEE, 2018.
doi:10.23919/DATE.2018.8342122.

in Europe Conference & Exhibition (DATE 2018).

[135] T. O‚ÄôConnor and H. Y. Wong. Emergent properties. In Edward N. Zalta,
editor, The Stanford Encyclopedia of Philosophy. Metaphysics Research Lab,
Stanford University, summer 2015 edition, 2015.

[136] C. Oh, E. Kang, S. Shiraishi, and P. Nuzzo. Optimizing assume-guarantee
contracts for cyber-physical system design. In Proceedings of the Design, Au-
tomation & Test in Europe Conference & Exhibition (DATE 2019). IEEE, 2019.
doi:10.23919/DATE.2019.8715284.

[137] M. Pajic, J. Weimer, N. Bezzo, P. Tabuada, O. Sokolsky, and G. J. Pap-
In Proceedings of

pas. Robustness of attack-resilient state estimators.

Bibliography

135

the ACM/IEEE International Conference on Cyber-Physical Systems (ICCPS).
IEEE Computer Society, 2014. doi:10.1109/ICCPS.2014.6843720.

[138] V. Paruchuri. Questioning 42: Toward conceptualizing namespace compro-
mise using human-scale security protocols-current technological, anthro-
pological, economic and legal deficits. Master‚Äôs thesis, Dartmouth College,
2016.

[139] D. Pavlovic. Towards a science of trust.

In Proceedings of the 2015 Sym-
posium and Bootcamp on the Science of Security (HotSoS 2015). ACM, 2015.
doi:10.1145/2746194.2746197.

[140] V. Prevelakis and D. Spinellis. The Athens affair. IEEE Spectrum, 2007.

doi:10.1109/MSPEC.2007.376605.

[141] J.-B. Raclet, √â. Badouel, A. Benveniste, B. Caillaud, A. Legay, and
R. Passerone. A modal interface theory for component-based design. Fun-
damenta Informaticae, 2011. doi:10.3233/FI-2011-416.

[142] √ç.

and
√ç. Romeo, A. L. Sangiovanni-Vincentelli, C.-W. Lin,
E. Kang.
In Proceed-
Quotient for assume-guarantee contracts.
ings of the 16th ACM/IEEE International Conference on Formal Meth-
ods and Models for System Design (MEMOCODE 2018). IEEE, 2018.
doi:10.1109/MEMCOD.2018.8556872.

[143] J. Rrushi, H. Farhangi, C. Howey, K. Carmichael, and J. Dabell. A quan-
titative evaluation of the target selection of Havex ICS malware plugin. In
Proceedings of the 2015 Industrial Control System Security Workshop (ICCS
2015). ACSAC, 2015. URL https://perma.cc/CZ77-VLAQ.

[144] I. Ruchkin, A. Rao, D. de Niz, S. Chaki, and D. Garlan.

Elimi-
nating inter-domain vulnerabilities in cyber-physical systems: An anal-
In Proceedings of the 1st ACM Workshop on
ysis contracts approach.

Bibliography

136

Cyber-Physical Systems-Security and/or PrivaCy (CPS-SPC 2015), 2015.
doi:10.1145/2808705.2808714.

[145] M. Rungger and P. Tabuada.

Abstracting and refining robustness
for cyber-physical systems.
In Proceedings of the 17th International
Conference on Hybrid Systems: Computation and Control (HSCC), 2014.
doi:10.1145/2562059.2562133.

[146] Dylan Rupel and David I. Spivak. The operad of temporal wiring
diagrams: formalizing a graphical language for discrete-time processes.
arXiv:1307.6894, 2013.

[147] J. Rushby. Composing safe systems. In Revised Papers from the International
Workshop on Formal Aspects of Component Software (FACS 2011). Springer,
2011. doi:10.1007/978-3-642-35743-5_2.

[148] J. J. M. M. Rutten. Universal coalgebra: a theory of systems. Theoreti-
cal Computer Science, 2000. doi:10.1016/S0304-3975(00)00056-6. URL
https://doi.org/10.1016/S0304-3975(00)00056-6.

[149] A. L. Sangiovanni-Vincentelli, W. Damm, and R. Passerone. Taming Dr.
Frankenstein: Contract-based design for cyber-physical systems. European
Journal of Control, 2012. doi:10.3166/ejc.18.217-238.

[150] M. Saravi, L. Newnes, A. R. Mileham, and Y. M. Goh. Estimating cost at
the conceptual design stage to optimize design in terms of performance and
cost. In Proceedings of the 15th ISPE International Conference on Concurrent
Engineering. Springer, 2008. doi:10.1007/978-1-84800-972-1_11.

[151] B. Schneier. Click Here to Kill Everybody: Security and Survival in a Hyper-
connected World. W. W. Norton & Company, 2018. ISBN 978-0393608885.

[152] P. Schultz, D. I. Spivak, and C. Vasilakopoulou. Dynamical systems and
sheaves. Applied Categorical Structures, 2019. doi:DOI:10.1007/s10485-
019-09565.

Bibliography

137

[153] P. Selinger. A survey of graphical languages for monoidal categories. In New

structures for physics. Springer, 2010. doi:10.1007/978-3-642-12821-9_4.

[154] O. Sheyner, J. Haines, S. Jha, R. Lippmann, and J. M. Wing. Au-
In Proceed-
IEEE, 2002.

tomated generation and analysis of attack graphs.
ings 2002 IEEE Symposium on Security and Privacy.
doi:10.1109/SECPRI.2002.1004377.

[155] J. Slowik. Evolution of ICS attacks and the prospects for future disruptive
events. URL https://perma.cc/8UDH-XVPR, 2018. Dragos.

[156] D. Spivak. The steady states of coupled dynamical systems compose ac-

cording to matrix arithmetic. arXiv:1512.00802 [math.CT], 2016.

[157] D. I. Spivak. The operad of wiring diagrams: formalizing a graph-
recursion, and plug-and-play circuits.

language for databases,

ical
arXiv:1305.0297, 2013.

[158] D. I. Spivak. Category theory for the sciences. MIT Press, 2014.

ISBN

9780262028134.

[159] A. Strafaci. What does BIM mean for civil engineers. CE News, Transporta-

tion, 2008. URL https://perma.cc/84C6-WFEF.

[160] B. Strauch.
these years.
doi:10.1109/THMS.2017.2732506.

Ironies of automation: Still unresolved after all
on Human-Machine Systems, 2018.

Transactions

[161] J. E. Sullivan and D. Kamensky. How cyber-attacks in Ukraine show
the vulnerability of the U.S. power grid. The Electricity Journal, 2017.
doi:10.1016/j.tej.2017.02.006.

[162] P. Tabuada. Controller synthesis for bisimulation equivalence. Systems &

Control Letters, 2008. doi:10.1016/j.sysconle.2007.11.005.

Bibliography

138

[163] P. Tabuada, G. J. Pappas, and P. U. Lima. Composing abstractions of hy-
brid systems. In Proceedings of the 5th International Workshop on Hybrid Sys-
tems: Computation and Control (HSCC 2002), Lecture Notes in Computer
Science. Springer, 2002. doi:10.1007/3-540-45873-5_34.

[164] G. Travis. How the Boeing 737 Max disaster looks to a software developer.

IEEE Spectrum, 2019.

[165] D. Vagner, D. I. Spivak, and E. Lerman. Algebras of open dynamical sys-
tems on the operad of wiring diagrams. Theory and Applications of Categories,
2015.

[166] Y. Wang and M. Pajic. Supervisory control of discrete event systems
in the presence of sensor and actuator attacks.
In Proceedings of the
2019 IEEE 58th Conference on Decision and Control (CDC). IEEE, 2019.
doi:10.1109/CDC40024.2019.9029767.

[167] M. D. Watson, B. L. Mesmer, and P. A. Farrington. Engineering elegant
systems: Theory of systems engineering. Technical Report NASA/TP‚Äì
20205003644, 2020.

[168] J. C. Willems.

The behavioral approach to open and inter-
IEEE Control Systems Magazine, 2007.

connected systems.
doi:10.1109/MCS.2007.906923.

[169] W. Young and N. G. Leveson. Systems thinking for safety and security.
In Proceedings of the 29th Annual Computer Security Applications Conference
(ACSAC 2013). ACM, 2013. doi:10.1145/2523649.2530277.

[170] W. Young and N. G. Leveson. An integrated approach to safety and
security based on systems theory. Communications of the ACM, 2014.
doi:10.1145/2556938.

Bibliography

139

[171] G. Zardini, N. Lanzetti, A. Censi, E. Frazzoli, and Marco Pavone. Co-
design to enable user-friendly tools to assess the impact of future mobility
solutions. arXiv 2008.08975 [eess.SY], 2020.

[172] G. Zardini, D. I. Spivak, A. Censi, and E. Frazzoli. A compositional
sheaf-theoretic framework for event-based systems.
In Proceedings of
the 2020 Applied Category Theory Conference (ACT 2020), EPTCS, 2020.
doi:10.4204/EPTCS.333.10.

[173] G. Zardini, D. Milojevic, A. Censi, and E. Frazzoli. A formal approach to

the co-design of embodied intelligence. arXiv 2011.10756 [cs.RO], 2021.

Bibliography

140

