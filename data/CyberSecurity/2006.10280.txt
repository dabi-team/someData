0
2
0
2

t
c
O
8
2

]

R
C
.
s
c
[

2
v
0
8
2
0
1
.
6
0
0
2
:
v
i
X
r
a

CoinWatch: A Clone-Based Approach For Detecting
Vulnerabilities in Cryptocurrencies

Qingze Hum,† Wei Jin Tan, Shi Ying Tey, Latasha Lenus
Singapore University of Technology and Design,
†qzhum1996@gmail.com

Yun Lin
National University of Singapore,
dcsliny@nus.edu.sg

Ivan Homoliak
FIT, Brno University of Technology,
ihomoliak@ﬁt.vutbr.cz

Jun Sun
Singapore Management University,
sunjunhqq@gmail.com

Abstract—Cryptocurrencies have become very popular in re-
cent years. Thousands of new cryptocurrencies have emerged,
proposing new and novel techniques that improve on Bitcoin’s
core innovation of the blockchain data structure and consensus
mechanism. However, cryptocurrencies are a major target for
cyber-attacks, as they can be sold on exchanges anonymously and
most cryptocurrencies have their codebases publicly available.
One particular issue is the prevalence of code clones in cryptocur-
rencies, which may amplify security threats. If a vulnerability is
found in one cryptocurrency, it might be propagated into other
cloned cryptocurrencies. In this work, we propose a systematic
remedy to this problem, called COINWATCH (CW). Given a
reported vulnerability at the input, CW uses the code evolution
analysis and a clone detection technique for the indication of
cryptocurrencies that might be vulnerable. We applied CW on
1094 cryptocurrencies using 4 CVEs and obtained 786 true
vulnerabilities present in 384 projects, which were conﬁrmed with
developers and successfully reported as CVE extensions.

I. INTRODUCTION

Bitcoin is designed to be a peer-to-peer electronic cash
system, introducing an innovative consensus mechanism and
incentives for participants. All participants in the consensus
protocol must run a full node. Bitcoin has inspired hundreds
of cryptocurrencies utilizing blockchain technology to serve
as a decentralized means of transferring crypto-assets. There
were 98 cryptocurrencies introduced in 2016, 412 introduced
in 2017, and 726 introduced in 2018. Given that Bitcoin’s
codebase [1] is publicly available, developers may easily fork
its repository from GitHub and make custom modiﬁcations,
which they might later publish as their own cryptocurrency.
In this way, many cryptocurrencies might become popular and
adopted by the public. However, many cryptocurrencies are
also “popular” due to various high proﬁle security incidents [2],
[3], [4], [5].

Detecting and patching the vulnerabilities manually is pro-
hibitively costly. Due to the decentralized nature of cryptocur-

© 2020 IEEE. Personal use of this material is permitted. Permission from
IEEE must be obtained for all other uses, in any current or future media,
including reprinting/republishing this material for advertising or promotional
purposes, creating new collective works, for resale or redistribution to servers
or lists, or reuse of any copyrighted component of this work in other works.

Figure 1: A histogram of forked projects from Bitcoin and their clone
ratios as compared to Bitcoin v0.17.0.

rencies, whenever a patch is created, individual miners have to
patch their own nodes independently. In the case of the inﬂation
bug in Bitcoin, the vulnerability was ﬁxed by only 31.65%
of all nodes [6] even after a full year from the disclosure.1
The inﬂation bug [7] was discovered in September 2018 and
allowed the inﬂation of the total Bitcoin supply. Upon analysis,
it was found that this vulnerability had been present since
2017 but has been patched only in 2019. Nevertheless, this
vulnerability is shared by 31 cryptocurrencies that emerged
as modiﬁcations of Bitcoin clones. Patching the vulnerability
across all such cryptocurrencies is of paramount importance
for their ﬁnancial stability.

Our empirical study shows that 786 cryptocurrencies were
directly or indirectly forked from a version of Bitcoin. Figure 1
depicts the histogram of code similarity (i.e., clone ratio)
of cryptocurrencies against
the Bitcoin codebase. In most
of the cases, the clone ratio is below 30%; however, some
of them have this ratio even higher than 50%. Therefore,
once a vulnerability is discovered in one cryptocurrency,
the vulnerability is very likely to be propagated among its
clones. Editing cloned codebases is a common phenomenon

1Note that as of 30th September 2020, the ratio of updated nodes is even
worse and is equal to 14.42%. See https://luke.dashjr.org/programs/bitcoin/
ﬁles/charts/security.html?201817144.

 
 
 
 
 
 
in software engineering and maintenance. Nevertheless, the
popularity of forking codebases of cryptocurrencies makes the
problem unique in that: (1) the clones are spread across a vast
number of projects, which makes overall clone management
difﬁcult, (2) the code among cryptocurrency projects is of
high similarity, and (3) the ﬁnancial impact of neglecting a
propagated vulnerability might be extremely costly.

In this work, we propose COINWATCH (CW), a clone-
based approach that indicates propagated vulnerabilities across
cryptocurrencies. At the input, CW takes the code fragment
relevant to a known vulnerability in a target cryptocurrency and
the code repositories of monitored cryptocurrencies. First, CW
analyzes when the vulnerability of the target cryptocurrency
was introduced within its incremental code history (e.g., Git).
Next, CW goes through the suspicious cryptocurrencies and
infers whether they were forked before the vulnerability was
introduced. In the positive case, CW conducts clone detection
to ﬁnd out whether the given vulnerability has been already
ﬁxed and if not it reports a warning.

We have built a proof-of-concept tool for CW, which to
the date scans 1094 cryptocurrencies and compares them to
Bitcoin, serving as the target cryptocurrency. For evaluation
purposes, we selected the top four cryptocurrency-oriented
CVEs in terms of severity. In sum, CW reported 786 prop-
agated vulnerabilities across 384 cryptocurrencies, achieving
a true positive rate of 89.7%. We notiﬁed the developers of
affected cryptocurrencies and reported vulnerabilities found to
NVD NIST. In turn, we obtained 4 CVE extensions: CVE-
2018-17144, CVE-2016-10724, CVE-2016-10725, and CVE-
2019-7167, which are described at https://github.com/JinBean/
CVE-Extension/.

II. AN ILLUSTRATING EXAMPLE

In this section, we illustrate how CW works while taking

CVE-2018-17144 as an example.

A. CVE-2018-17144 Explained

This vulnerability is a result of reachable assertion weakness
CWE-617 [8], and it enables the crashing of any node in
the network by crafting a transaction that double spends (see
Figure 2), which causes a DoS of all nodes that receive a mined
block containing such a transaction. The vulnerability was
ﬁxed in Bitcoin release 0.16.3 on Sep 18, 2018. We depict the
vulnerable period of this vulnerability across various Bitcoin
clones in Table I.

B. Using COINWATCH

Given the CVE description and details about a vulnerability,
the codebase of the target cryptocurrency (i.e., Bitcoin) is ana-
lyzed for the speciﬁc code segments causing the vulnerability:
1) the bug-ﬁxing commit (b8f8019) is identiﬁed in GitHub,
2) the bug-introducing commits (eecffe5, 5083079, 3533fb4)

are identiﬁed in GitHub,

3) the ﬁrst cut of potentially vulnerable cryptocurrencies is
generated based on the fork dates of input candidates.

Cryptocurrency

Timeframe (MM/DD) Months Vulnerable

Argentum
Chaincoin
CreativeCoin
DigiByte
EliCoin
Irlecoin
Litecoin
Lynx
Machinecoin
MatrixCoin
Methuselah
MinexCoin
MktCoin
PlatinCoin
Quasarcoin
United Bitcoin
Unitus

12/16-11/18
12/16-10/18
12/16-11/18
12/16-9/18
2/18-11/18
6/18-present
12/16-9/18
12/6-10/18
4/17-10/18
12/16-10/18
4/18-10/18
7/17-4/19
10/17-present
7/18-2/20
11/17-present
12/16-9/18
4/17-11/18

23
22
23
21
9
not ﬁxed
21
22
18
22
6
21
not ﬁxed
19
not ﬁxed
21
19

Table I: Vulnerable period of CVE-2018-17144 across Bitcoin clones.

Hence,
if a cryptocurrency was created before the bug-
introducing commits in its “parent,” it is unlikely that it will
contain the bug.

In the next step of CW, the code segment that patches
the vulnerability is identiﬁed. Given this information, CW
performs a test using clone detection to check for the existence
of the vulnerable code (and the ﬁx) within all monitored cryp-
tocurrencies. The results mark vulnerable cryptocurrencies:
they contain the code with the vulnerability but not the ﬁx.

C. Applying CW on CVE-2018-17144

The full detection process consists of scanning the codebase
of all monitored cryptocurrencies (1094) from our dataset
while searching for the code that causes the vulnerability. On
completion, CW reports a candidate set of suspicious cryp-
tocurrencies that might be vulnerable with a high likelihood.

PigeonCoin. On 26 September 2018, PigeonCoin was at-
tacked [9] due to CVE-2018-17144, resulting in a loss of
235 million PGN (i.e., $15,000 USD). The ﬁx [10] of the
vulnerability was only uploaded to their GitHub repository on
27 September 2018: 9 days after it was added to Bitcoin. If
CW had monitored the PigeonCoin, the vulnerability would be
discovered and ﬁxed before its exploitation.

Figure 2: Propagated code of DoS vulnerability (CVE-2018-17144).

Figure 3: Overview of COINWATCH.

III. COINWATCH

A. Overview

The overall workﬂow of CW is shown in Figure 3. First,
a target CVE [11] is provided at input together with data
publicly obtainable from its structured details. After picking
a target CVE, CW performs a code evolution analysis of
the parent project to obtain bug ﬁxing and bug introducing
commits. The bug introducing and ﬁxing commits are then
manually annotated to minimize the code responsible for the
vulnerability and the ﬁx, respectively. Then, CW generates a
detection test for a clone detector. Before running the clone
detector, the list of monitored projects is ﬁltered based on
the date of the fork to narrow down the search space by
pruning unrelated and unaffected projects. Then, at the heart of
CW is the clone detector, which, given the ﬁltered codebases
of monitored cryptocurrencies, identiﬁes and reports cloned
projects that are likely to be affected by the vulnerability.

B. Details

CVE Parsing. After a new vulnerability in the parent project
is reported, the CW triggers its execution. First, CW parses
the input CVE and extracts details about CVE: (1) the date
of publishing, (2) keywords from the description using a
text mining for short texts [12], (3) external links pointing
to resources of the version control system (e.g., issues, pull
requests, release notes), and (4) the list of cryptocurrencies
affected by the CVE along with the programming language
they were written in. Then, CW performs a check whether
the vulnerability is dependent on the code speciﬁc to the

: I: Issues that match criteria
: S: Regex string

Input
Input
Output: Gb := ∅: Git commits with bugs
Output: Gf := ∅: Git commits with ﬁxes

1 foreach i in I do
2

foreach c in i.commits do

3

Gf := Gf ∪ RE.match(S, c)

end

4
5 end
6 foreach cf in Gf do
7
8 end
9 return Gf , Gb

Gb := Gb ∪ getPrevCommits(cf);

cryptocurrency since some vulnerabilities may originate from
used underlying protocols (e.g., TLS). Finally, the software
release versions corresponding to the bug and the ﬁxes are
extracted using web scrapping techniques and utilized for a
code evolution analysis that takes into account the incremental
code history of a project.

Code Evolution Analysis. CW uses the code evolution of
a target project (e.g., Bitcoin) to discover the commit IDs
containing both the ﬁx and the bug. CW sets the entry
point as the release date of the vulnerability and proceeds
back in time while iterating over the issues, until it links
the ﬁxing commit(s) with the input CVE. To track down
the commit ID, CW utilizes the SZZ algorithm proposed by
Sliwerski, Zimmermann, and Zeller [13]. SZZ algorithm was
developed as an approach to identify bug-introducing commits
in a software repository. By leveraging on the issue-tracking
system of GitHub, we improve the accuracy using the git-
blame command for ﬁnding the bug-introducing commits.
An open implementation of the SZZ algorithm called SZZ
Unleashed [14] provides insight on how to apply it in practice.
In this work, we built on the SZZ algorithm and extend
it for our purpose to identify bug-ﬁxing and bug-introducing
commits. Using regular expression matching (lines 1 to 5 of
Algorithm 1, we search through all issues that have been ﬁxed,
resolved, closed, or labeled as a ”bug”. CW uses keywords
such as ”CVE”, ”CVE-ID” and extracted keywords from
the CVE details as the string pattern for regular expression
matching. This allows CW to locate the bug-ﬁxing commits,
which are stored at Gf . To ﬁnd the bug-introducing commit
Gb, CW uses git-blame functionality, which annotates the line
of code with information from the revision that modiﬁed the
line as the last one (i.e., getPrevCommits()). We emphasize

: Vc: set of monitored projects
Input
: Gb, Gf : bug-introducing and ﬁxing commits
Input
Output: Vvuln: set of potentially vulnerable projects

1 foreach p in Vc do
2

if p.repoF orkDate ≥ minDate(Gb) ∧

p.repoF orkDate ≤ maxDate(Gf ) then

3

Vvuln := Vvuln ∪ p;

end

4
5 end
6 return Vvuln

Algorithm 1: An extended SZZ algorithm.

Algorithm 2: Initial ﬁltering of monitored projects.

CVE Parserand Web ScraperCode EvolutionAnalysisClone Detector(e.g., Simian)List of (Likely)AffectedCryptocurrenciesCVE Parsing & Linking it with Commit(s)Identification of Vulnerable CodeDetection ProcessBug Introducing& Bug FixingCommitsInitial FilteringFilterBased onthe Dateof ForkTransformation ofVulnerable Codeto a Detection TestManual Anotationof Vulnerable CodeCodebase of Parent (Target)CryptocurrencyCodebases ofall Monitored Cryptocurrenciesthat CW takes a conservative approach to pick the oldest date
for the bug-introducing commit and the newest date for the
bug-ﬁxing commit. This method allows us to track down both
bug-introducing and bug-ﬁxing commits, with which we can
estimate the time-frame of the presence of the bug in any
codebase. We use this time-frame as a window representing
its propagation within a project that was created by forking
the target project.
Identiﬁcation of Vulnerable Code. After obtaining bug ﬁxing
and bug introducing commits, CW requires manual annotation
of the code in these commits (i.e., the code responsible for
the vulnerability and the ﬁx). This requires understanding
the cause of the vulnerability; however, this manual effort is
only a one-time action (per vulnerability), while all monitored
projects are checked automatically later. Next, CW transforms
the annotated code to a detection test suitable for a clone
detector.
Filtering of Monitored Projects. We provide a simple method
for the initial ﬁltering of monitored cryptocurrencies in Algo-
rithm 2, which is based on the timestamp of forking these
projects from the parent project. Letting Vc be the set of
monitored cryptocurrency projects, if p ∈ Vc is created after
Gb.date and before Gf .date, we consider Vc for further
analysis. Otherwise, if the repository of p was created before
the bug was introduced or after the bug was ﬁxed, we ignore
this case since the bug had not existed at the time of forking
the project. The list of candidate projects forms our ﬁrst cut
of potentially vulnerable projects. Algorithm 2 uses the output
of Algorithm 1 to identify the dates when the vulnerability
was created and presented until by checking the timestamps
associated with the particular commit IDs.
Detection Process. Finally, using the generated detection tests,
CW applies the clone detector to ﬁnd clones of the parent
project in the monitored list of cryptocurrencies, which are then
analyzed using Gf and Gb to indicate such cloned projects that
are potentially vulnerable.

IV. IMPLEMENTATION

Experiment Setup. All
the experiments we performed ran
on the machine with a quad-core i7-7500U CPU clocked at
2.70GHz and equipped with 16 GB of memory. We conducted
a simulation experiment where we applied CW on the versions
of projects dating before the version where the vulnerability
was disclosed. The simulation experiment evaluated whether
some cryptocurrencies might have been ﬁxed earlier if our
approach has been adopted. To instantiate a clone detector,
we chose Simian [15], a similarity analyzer that identiﬁes
duplication in C++ code as well as other tools that use text-
based string comparison to identify type I clones. The Type
I clones represent the situation when code fragments in a
particular code-base are the same, omitting the comments
and indentations [16], [17]. Note that Type II clones are
syntactically similar code fragments, which are usually created
from Type I clones by renaming variable names or modifying
data types. Finally, Type III clones are created due to additions,

deletions, or modiﬁcations of code fragments in Type I or Type
II clones.
Testing Simian. Before we conducted any clone detection
experiment, we ﬁrst ran a test to verify that Simian is capable of
accurate detection of cloned code within the full code structure.
Therefore, we performed a positive test and compared a cloned
repository of Bitcoin-0.17 with a portion of its own code. This
identiﬁed the correct ﬁle and line numbers of the entire code
snippet. We then performed a negative test with a code that
did not exist within Bitcoin-0.17. We found that to minimize
false positives, we had to set the code line threshold to the
exact length of each snippet of vulnerable code. This ensures
that only cryptocurrencies containing the full code causing the
vulnerability are detected. However, doing so increased the
chance of false negatives; due to the time-sensitive nature of
cryptocurrencies and a large attack surface, we adopted this
setting since it is more important to detect truly vulnerable
projects than to miss potentially vulnerable ones.
Identifying Vulnerable Code. Using the CVE database speciﬁc
to Bitcoin [18] (i.e., the parent project), we reviewed Bitcoin’s
CVEs to select vulnerabilities that are contained in its codebase
versions in the range (cid:104)2016, 2018(cid:105), a time frame where many
alternative cryptocurrencies were created. Once a CVE was
selected for analysis, CW searched for the bug ﬁxing and
bug introducing commits. Then, we manually annotated the
code segments of these commits, which are related to the
vulnerability and the ﬁx, based on which, CW generated
detection tests for Simian. Next, CW parsed information from
the Bitcoin version where the vulnerability was introduced in
and the version it was eventually ﬁxed at.
Clone Detection in Monitored Projects. We wrote Python
scripts that scraped coingecko.com to collect a dataset of the
names of all existing cryptocurrencies, the link of their GitHub
repositories, and the language that the cryptocurrency was
written in. Out of the 1970 cryptocurrencies that we had, 43
were listed with a broken GitHub link or were just links to
websites. We then used Git to clone all valid repositories. Since
we wanted to identify vulnerabilities from Bitcoin clones, we
removed all cryptocurrencies that had not used C++. We were
then left with 1094 cryptocurrencies. The folder structure for
the analysis is comprised of one main folder, which we will call
the comparison folder. Inside the comparison folder were two
more folders; the ﬁrst containing the vulnerable code and the
second containing the code of the cryptocurrency we wanted
to compare against. Python scripts were used to automate the
moving of the code from our database into the comparison
folder, running the Simian clone detection, and then moving the
code back. This was done iteratively for each cryptocurrency
in the database. Simian produced an XML ﬁle after every
iteration containing the results of the clone detection. The
XML ﬁle contains the ﬁle path of each detected clone, the
number of lines detected, and the processing time, as seen
in Figure 4. Another script then ran to parse each of the
Simian outputs, which gave us the list of suspicious vulnerable
cryptocurrencies. To support the validity of our methodology,

(cid:7)
<simian version="2.5.10">

<check ignoreCharacterCase="true" ignoreCurlyBraces="true" ignoreIdentifierCase="true" ignoreModifiers="true" ignoreStringCase="true"

threshold="6">

<set lineCount="6" fingerprint="5eb7165c145ded7b7469ac9ac53e677b">

<block sourceFile="\simian\bin\coin\bitcoin-0.16.3\src\test\skiplist_tests.cpp" startLineNumber="24" endLineNumber="31"/>
<block sourceFile="\simian\bin\coin\Dogecoin\src\test\skiplist_tests.cpp" startLineNumber="25" endLineNumber="32"/>

</set>
<set lineCount="6" fingerprint="4ceb8650e14442de03bb7eb1b8f9b9b4">

<block sourceFile="\simian\bin\coin\bitcoin-0.16.3\src\key.cpp" startLineNumber="203" endLineNumber="211"/>
<block sourceFile="\simian\bin\coin\Dogecoin\src\key.cpp" startLineNumber="72" endLineNumber="80"/>

</set>
<set lineCount="6" fingerprint="7b80d7542d174e7bdb2e532d6a96e1bb">

<block sourceFile="\simian\bin\coin\bitcoin-0.16.3\src\test\script_tests.cpp" startLineNumber="1282" endLineNumber="1289"/>
<block sourceFile="\simian\bin\coin\Dogecoin\src\test\script_tests.cpp" startLineNumber="964" endLineNumber="971"/>

</set>
...

<summary duplicateFileCount="348" duplicateLineCount="34092" duplicateBlockCount="2369" totalFileCount="455" totalRawLineCount="160822"

totalSignificantLineCount="94838" processingTime="1624"/>

</check>

</simian>
(cid:10)(cid:6)

(cid:4)

(cid:5)

Figure 4: An example of XML output from Simian.

we also experimented with Zcash (and its CVEs) serving as a
parent project (see vulnerability CVE-2019-7167).
Responsible Disclosure. Finally, before disclosing vulnerabili-
ties in the cloned projects, we ﬁled 4 CVE extensions with
MITRE. Once the CVEs were accepted, we informed the
developers of these projects about the vulnerability and the
ﬁx recommended in the CVE description.

V. EVALUATION

We evaluated CW through various experiments. The ex-
periments were designed to answer the following research
questions (RQs):

• RQ1: Are clones prevalent in cryptocurrencies?
• RQ2: Can we accurately detect propagated vulnerabilities

through clones?

• RQ3: Are the propagated vulnerabilities real problems?

RQ1 examines our hypothesis, i.e., clones are prevalent in
cryptocurrencies, and therefore identifying vulnerabilities by
tracking clones is an important problem. RQ2 evaluates the
accuracy of our approach. RQ3 is designed to question the
usefulness of CW in practice and reports on true positive and
false positive rates.

A. RQ1: Clone Prevalence

To answer RQ1, we systematically applied CW to the latest
versions of the cryptocurrencies within our dataset scraped
from Coingecko as of October 2018.2 In total, there were
initially 2079 cryptocurrencies as of Oct 2018, and 4389
cryptocurrencies as of Apr 2019. We note that a large number
of new cryptocurrencies were created in this short period of
time. There are also different types of cryptocurrencies; e.g,
2431 of them are ERC-20 tokens [19], which we consider as
out-of-scope.3 Out of the remaining 2079 cryptocurrencies that

we scraped, 1094 cryptocurrencies are written in C++, the same
programming language as Bitcoin is written in. The breakdown
of the remaining cryptocurrencies can be found in Table II.

As we conjecture that

these cryptocurrencies are clones
of various versions of Bitcoin, using CW, we systematically
apply Simian to compare each of these cryptocurrencies with
different versions of Bitcoin. Part of the results are summarized
in Table III, where the second column shows the overall
number of lines of code (LOC) in the project and the following
columns show the clone ratio of each cryptocurrency in respect
to different versions of Bitcoin. The clone ratio is deﬁned as
follows:

ratioclone =

K
T

,

(1)

where K is the number of LOC cloned from Bitcoin and T is
the total number of LOC. Note that Table III shows the clone
ratio of a subset of 14 cryptocurrencies that were among the
top 50 by the market capitalization as of the time of making
the experiment. The average clone ratio was found to be
30.7%. However, if we compare the highest clone ratio among
all versions of the same set of cryptocurrencies written in
C++, the average clone ratio increases to 46.6%. Furthermore,
multiple cryptocurrencies have a clone ratio of more than 90%.
Hence, we conclude that code clones are indeed prevalent in
cryptocurrencies.

Language

The Number of Projects

C++
Javascript
C
Go
Python
Java
Others

1094
334
65
65
36
30
455

2https://www.coingecko.com/en
3Note that ERC-20 tokens are built on the Ethereum platform and contain
a standardized smart contract code that is parametrized by particular tokens.

Table II: Distribution of programming languages across cryptocur-
rencies considered in our work.

Cryptocurrency

LOC Bitcoin 0.17.0 Bitcoin 0.16.3 Bitcoin 0.15.2 Bitcoin 0.14.2 Bitcoin 0.13.2 Bitcoin 0.12.0 Bitcoin 0.11.2

Bitcoin Cash
Bitcoin Diamond
DogeCoin
Monero
Zcash
Dash
DigiByte

68,545
51,102
38,073
57,232
51,509
65,104
63,769
Electroneum 37,040
96,066
EOS
57,014
Litecoin
Nano
26,987
Qtum 112,867
62,200
Steem 108,561

Ravencoin

26.0%
55.6%
33.2%
0.0%
21.1%
40.24%
90.90%
0.00%
0.00%
76.73%
0.00%
37.52%
63.33%
0.01%

32.2%
70.2%
40.8%
0.0%
24.4%
47.23%
69.32%
0.00%
0.00%
98.17%
0.00%
48.18%
81.09%
0.02%

34.2%
77.2%
43.9%
0.0%
25.1%
52.52%
60.81%
0.00%
0.00%
86.11%
0.00%
42.68%
82.41%
0.02%

27.3%
98.1%
55.2%
0.0%
33.8%
63.93%
42.02%
0.00%
0.00%
58.55%
0.00%
28.82%
55.93%
0.02%

20.3%
73.6%
67.1%
0.0%
42.2%
46.25%
30.94%
0.00%
0.00%
43.75%
0.00%
21.48%
41.22%
0.02%

17.2%
56.2%
77.5%
0.0%
46.0%
38.62%
24.14%
0.00%
0.00%
33.27%
0.00%
16.30%
31.45%
0.02%

13.1%
42.3%
91.6%
0.0%
40.7%
28.64%
18.85%
0.00%
0.00%
25.83%
0.00%
12.68%
24.27%
0.07%

Table III: Percentage of cloned code as compared to various Bitcoin versions.

Vulnerability

Parent
Project

# Investigated
Projects

TPR

FPR

CVE-2018-17144 Bitcoin
CVE-2016-10724 Bitcoin
CVE-2016-10725 Bitcoin
CVE-2019-7167
Zcash

31
422
422
1

100.0% 0.00%
89.3% 10.7%
89.3% 10.7%
100.0% 0.00%

Table IV: A summary of the results obtained by CW.

B. RQ2: Accuracy of COINWATCH

To answer this question, we systematically apply CW to
multiple vulnerabilities discovered in recent years and see
whether they are propagated to other cryptocurrencies. We fo-
cus on such vulnerabilities due to the following reasons. First,
these are high-proﬁle vulnerabilities. Second, these vulnerabil-
ities are reported between the years 2016 to 2018, in which
we evinced a boom of a vast number of cryptocurrencies. A
vulnerability propagates itself across clones since it is not yet
discovered at the time when the parent project is cloned. The
propagation of a vulnerability is highly dependent on when
the source code was cloned and how long the vulnerability
has existed before it was ﬁxed. If a cryptocurrency forked the
code during the time frame when the bug was presented in the
source code, there is a high chance of the clone containing
vulnerable code. As a result, we found out that CW is capable
of accurate detection of vulnerabilities in cloned projects as
proven by ﬁling 4 CVE extensions.
Case Study. In the following, we focus on CVE-2018-17144.
Among 985 pre-ﬁltered cryptocurrencies monitored using CW,
we found that as of October 2018, 31 cryptocurrencies had
Type I clones of a vulnerable code found in Bitcoin and hence
were exposed to this vulnerability. We monitored the situation
after we alerted vulnerable projects and our CVE extension
was published at NVD. In February 2019, the results from
CW suggest that 22 of the 31 cryptocurrencies have patched
the vulnerability, while in June 2020 there were still 4 projects
unﬁxed. This implies that attackers had at least a month’s time
frame from the time the CVE was announced in September
2018 to attack the 31 vulnerable cryptocurrencies, exposing
up to $35, 585, 594 market capital (as of 07 October 2018).

Moreover, in February 2019 and June 2020, attackers could
still attack the remaining 9 and 4 unﬁxed cryptocurrencies,
respectively.

C. RQ3: Is a clone equal to a vulnerability?

To answer this question, we investigate how many of the
candidate cryptocurrencies that are discovered using CW are
indeed vulnerable. This is a challenging problem since we must
be able to determine whether the affected code is reached
or not, and whether its execution would result in the same
reported vulnerability as in the target project. Therefore, we
attempt to answer the question in two ways. First, we manually
examined all the patches of 4 CVEs (that we extended) and
cross-checked them with cryptocurrencies reported by CW.
For each patch, we checked if the vulnerable cloned code was
already modiﬁed (by maintainers) in the most recent version
of the project, and if so, whether it was modiﬁed in a way
similar to the ﬁx of the CVE in the parent project. In the
positive case, we considered a discovery made by CW on a
particular cryptocurrency as a true vulnerability. The second
way we answer the question was manual checking with the
developers/maintainers of the project.

True Positives VS False Positives. The summary of our
results is presented in Table IV. In the case of CVE-2018-
17144, due to an extremely severe consequence of this double-
spending vulnerability, many popular cloned cryptocurrencies
quickly applied the ﬁx after the CVE was released, e.g. Dash,
Ravencoin, Bitcoin Cash, etc. This is not the case for low-
proﬁle vulnerabilities or for smaller cryptocurrencies, which
are less diligent in keeping their codebases updated. Pigeoncoin
is an example of a cryptocurrency that suffered from this vul-
nerability, and which was also exploited. We analyzed different
releases of Pigeoncoin and found that it contained the double-
spending vulnerability from its ofﬁcial launch on 07 April 2018
until 27 September 2018. The reason for the bug ﬁx on 27
September was the attack made on it. If CW were to monitor
Pigeoncoin at the time the Bitcoin patch was released, we could
have identiﬁed the vulnerability and prevented the attack. In
the case of CVE-2018-17144 and CVE-2019-7167, there were

Figure 5: Propagated code for DoS vulnerability in Bitcoin Diamond.

Figure 6: Propagated code for DoS vulnerability in Bitcoin Stash.

no false positives since all candidate cryptocurrencies reported
were conﬁrmed to contain these vulnerabilities.

On the other hand, CW reported a few false positives as
well. For example, although we initially found out that 422
cryptocurrencies had enabled the alert system (causing CVE-
2016-10724 and CVE-2016-10725 in the parent project), 45
cryptocurrencies reported at the output of CW did not reference
it during compilation and thus are not vulnerable. Due to this,
the true positive rate of CW was deteriorated to 89.3% for
these particular vulnerabilities.
Type II and III Clones and Possible False Negatives. Type II
and III clones come into play when the codebase is edited by
changing the way certain functions work or are named. One
example of a Type III clone that we identiﬁed was presented
in Bitcoin Diamond Version 0.14.0 and 0.13.0. The code can
be seen in Figure 5. Bitcoin Diamond modiﬁed its function
CheckTransaction() to include new arguments that are speciﬁc
to Bitcoin Diamond itself. An example of Type II clone was
identiﬁed in Bitcoin Stash as seen in Figure 6, where the
CheckTransaction() function was renamed to CheckRegular-
Transaction(). These clones cannot be detected using Simian
as the clone detector, and they require more sophisticated tools
which we will consider in our future work. We contacted the
development team of these two projects regarding the possible
vulnerabilities but did not get the response; hence, we cannot
conﬁrm whether these two cases represent false negatives.

VI. DISCUSSION

Scope of Clones. The results presented in this paper are
related mainly to Bitcoin, as it
is currently the dominant
cryptocurrency and has the most number of forks from its
GitHub repository. However, there are other cryptocurrencies
written in different programming languages (or are close-
sourced) that are similar to Bitcoin but would not be detected as
Type I clones. There is a trade-off between false positives and
false negatives if we use more complex types of code clone
detection techniques such as the ones searching for Type II
or Type III clones. In some cases we would have to conduct

a decompilation of binaries and do the analysis on abstract
syntax trees of assembly rather than a veriﬁcation of source
code for match. This is the direction that we will investigate
in our future work.
Manual Annotation. A semi-automated nature of CW is
another limitation, which stems from the manual annotation
of the vulnerable code and ﬁx within the bug ﬁxing and bug
introducing commits. However, this is a one-time action per
vulnerability and can be performed in a relatively short time,
while later CW continues automatically in checking the full list
of monitored projects. In our future work, we plan to design
simple heuristic methods that can automate this step.
Non-Standard Assumptions. CW assumes that if a cryptocur-
rency project was forked after the bug was introduced in the
parent project and before the bug was ﬁxed, it is likely to
suffer from the vulnerability. However, we note that sometimes
forked projects may cherry-pick commits from their parents
or apply patches mitigating some security issues, which we
currently do not distinguish in CW. However, we emphasize
that such selected projects represent only the ﬁrst cut of
potentially vulnerable candidate projects and if they contain a
ﬁx, the clone detector will mark them as safe. In the worst case,
if the ﬁx is presented in a modiﬁed form that is not matched
by the clone detector, they are reported as false positives – this
causes a notiﬁcation to the maintainers, who just ignore it.

VII. RELATED WORK

Security of Cryptocurrencies. The security of cryptocur-
rencies has been undermined by several high proﬁle incidents.
Bitcoin [20] itself has been described to be vulnerable to
several attacks such as double-spending [21], transaction mal-
leability [22], networking attacks [23] [24], attacks targeting
mining [25] [26] [27], and others [2] [3]. As a research
topic, Bitcoin’s security is attractive due to a broad number of
use cases proposed for its underlying technology, blockchain.
Bitcoin has inspired several cryptocurrencies to build and
improve different aspects of its code to increase its transaction
throughput (eg. Bitcoin Cash) or provide greater anonymity
(eg. Bitcoin Private). The intense scrutiny of Bitcoin’s security
has led to a gap in research on the effects of vulnerabilities
from Bitcoin propagating to other cryptocurrencies that have
copied parts of Bitcoin’s code. These cryptocurrencies also
store value but are not as valuable as Bitcoin and thus do
not have as many developers and resources to build a body of
research around their security. Therefore, we developed CW
to address the security problem of propagated vulnerabilities
from Bitcoin while focusing on real-world attacks that have
been identiﬁed and ﬁxed within Bitcoin’s code.
Clones among Cryptocurrencies. Some cryptocurrencies fork
existing repositories and launch their own cryptocurrencies
with a speciﬁc focus. As these cryptocurrencies are changing
only a portion of the forked codebase before launching, a large
portion of their code is cloned from the speciﬁc version it was
forked from. Prior work suggests that code clones increase
maintenance effort [28] [29], might cause bugs (Li et. al

analyzed Linux, FreeBSD, Apache [30]), and signal errors in
other parts of a codebase. It is known that clone genealogy
information can be used to identify clones that may beneﬁt
new approaches and clone management [31]. Based on the
ﬁndings of the authors of [31], aggressive code refactoring
might not be necessary for code clones that are volatile and
that the technique of refactoring needs to be complemented by
other code maintenance approaches. Prior research analyzing
package dependencies [32] utilizes a systematic approach of
measuring the attack surface exposed by individual vulnera-
bilities through component level dependency analysis. In this
work, cloned cryptocurrencies do not utilize Bitcoin as a
package but the concept that the attack surface is dependent
on code utilized from elsewhere. The authors of [33] analyzed
code diversity in the cryptocurrency projects basing on the
source code similarity. The intention of the authors was to
examine the extent to which new cryptocurrencies provide
innovations.

Code Clone Detection. Basic code clone detection tech-
niques are performed using several tools and generally follow
a 6-step process [34] to generate clone pairs. Code cloning can
be used for the detection of code refactoring, greater efﬁciency
of development, etc. However, this methodology has been used
for other purposes due to the large volume of open-source
code that can be analyzed, such as detecting vulnerabilities.
For example, Viertel et al. [35] utilized this technique for
detecting vulnerabilities in codebases of Java-written projects,
in a similar fashion than CW does. A similar environment
is represented by smart contracts in Ethereum or other smart
contract platforms. Early work focused on ﬁnding semantic
clones in smart contracts that contained vulnerabilities in the
smart contract logic is presented in [36]. A tool detecting previ-
ously discovered smart contract vulnerabilities through clones
was proposed, and can quickly identify other smart contracts
that are semantically equivalent (and thus might contain the
same set of vulnerabilities). The automatic classiﬁcation of
Ponzi smart contracts based on code clones was proposed
in [37], and it bases on the fact that related smart contracts have
fundamentally similar programming logic. Clone detection was
also performed after transferring the code into an abstract
form such as strings [38], tokens [39], and abstract syntax
trees (AST) [40]. An efﬁcient heuristic technique basing on
edit distance and AST for pair-wise comparison of smart
contract byte codes was proposed in [41]. Techniques such
as line comparison based on dot plots [42], comparing whole
ﬁles [43], pattern recognition of code characteristics through
clustering [44], ﬁnding clones within a syntactic unit through
post-processing [39], and pre-processing [45] are also used
for clone detection.

VIII. CONCLUSION

In this work, we proposed COINWATCH, an approach that
monitors a speciﬁed set of cryptocurrency projects for the
presence of vulnerabilities disclosed in their parent projects.
We applied COINWATCH on 1094 monitored cryptocurrencies

using 4 CVEs at the input, and we identiﬁed 786 true vul-
nerable projects, which were conﬁrmed with developers and
successfully reported as CVE extensions. Our results show that
many attacks could have been prevented should COINWATCH
has been monitoring the attacked projects.

In future work, we plan to extend code clone detection to
Type II and III clones to increase the detection performance as
well as eliminate a need for a manual step of annotating the
code within bug ﬁxing and introducing commits.

REFERENCES

[1] B. Core. (2019) Bitcoin codebase at github version control system.

[Online]. Available: https://github.com/bitcoin/bitcoin

[2] I. Homoliak, S. Venugopalan, Q. Hum, and P. Szalachowski, “A security
reference architecture for blockchains,” in 2019 IEEE International
Conference on Blockchain (Blockchain).

IEEE, 2019, pp. 390–397.

[3] J. Bonneau, A. Miller, J. Clark, A. Narayanan, J. A. Kroll, and E. W.
Felten, “Sok: Research perspectives and challenges for bitcoin and
cryptocurrencies,” in 2015 IEEE Symposium on Security and Privacy,
2015, pp. 104–121.

[4] W. Wang, D. T. Hoang, Z. Xiong, D. Niyato, P. Wang, P. Hu, and
Y. Wen, “A survey on consensus mechanisms and mining management in
blockchain networks,” arXiv preprint arXiv:1805.02707, pp. 1–33, 2018.
[5] M. Conti, E. S. Kumar, C. Lal, and S. Ruj, “A survey on security and
privacy issues of bitcoin,” IEEE Communications Surveys & Tutorials,
vol. 20, no. 4, 2018.

[6] A. Zmudzinski. (2019) Research: 60% of all bitcoin full-nodes are still
vulnerable to inﬂation bug. [Online]. Available: https://cointelegraph.
com/news/research-60-of-all-bitcoin-full-nodes-are-still-vulnerable-to-
inﬂation-bug

[7] B. Core. (2018) Cve-2018-17144 full disclosure. [Online]. Available:

https://bitcoincore.org/en/2018/09/20/notice/

[8] Mitre.

(2019) Cwe-617: Reachable assertion.

[Online]. Available:

https://cwe.mitre.org/data/deﬁnitions/617.html

[9] R. Esteves. (2018) Pigeoncoin (pgn) hacked due to bitcoin protocol
bug, copycat coins in danger? [Online]. Available: https://www.newsbtc.
com/2018/10/06/pigeoncoin-pgn-hacked-due-to-bitcoin-protocol-bug-
copycat-coins-in-danger

[10] Pigeoncoin.

(2018)

Update

[On-
validation.cpp
https://github.com/Pigeoncoin/pigeoncoin/commit/

(#21).

line]. Available:
cc4885cc8e176e4e68a6ef966638b6728191c853

[11] MITRE Corporation, “Common Vulnerabilities and Exposures (CVE),”

2020. [Online]. Available: https://cve.mitre.org/

[12] C. Carretero-Campos, P. Bernaola-Galv´an, A. Coronado, and P. Carpena,
“Improving statistical keyword detection in short texts: Entropic and
clustering approaches,” Physica A: Statistical Mechanics and its Appli-
cations, vol. 392, no. 6, pp. 1481–1492, 2013.

[13] J. ´Sliwerski, T. Zimmermann, and A. Zeller, “When do changes induce
ﬁxes?” in ACM sigsoft software engineering notes, vol. 30, no. 4. ACM,
2005, pp. 1–5.

[14] M. Borg, O. Svensson, K. Berg, and D. Hansson, “Szz unleashed: An
open implementation of the szz algorithm-featuring example usage in
a study of just-in-time bug prediction for the jenkins project,” arXiv
preprint arXiv:1903.01742, 2019.

[15] S. Harris. (2003) Simian – similarity analyser. [Online]. Available:

https://www.harukizaemon.com/simian

[16] C. K. Roy, M. F. Zibran, and R. Koschke, “The vision of software
clone management: Past, present, and future (keynote paper),” in 2014
Software Evolution Week-IEEE Conference on Software Maintenance,
Reengineering, and Reverse Engineering (CSMR-WCRE).
IEEE, 2014,
pp. 18–33.

[17] C. K. Roy, “Detection and analysis of near-miss software clones,” in
IEEE,

2009 IEEE International Conference on Software Maintenance.
2009, pp. 447–450.

[18] Bitcoin.it.

(2019) Bitcoin common vulnerabilities and exposures.

[Online]. Available: https://en.bitcoin.it/wiki/Common Vulnerabilities
and Exposures

[19] V. B. Fabian Vogelsteller.

(2015) Eip 20: Erc-20 token standard.

[Online]. Available: https://eips.ethereum.org/EIPS/eip-20

[20] S. Nakamoto et al., “Bitcoin: A peer-to-peer electronic cash system,”

Communications of the ACM, 2008.

[21] G. O. Karame, E. Androulaki, A. Capkun, Srdjan, J. A. Kroll, and E. W.
Felten, “Double-spending fast payments in bitcoin,” in Proceedings of
the 2012 ACM conference on Computer and communications security,
2012, pp. 906–917.

[22] C. Decker and R. Wattenhofer, “Bitcoin transaction malleability and
mtgox,” in European Symposium on Research in Computer Security,
2014, pp. 313–326.

[23] E. Heilman, A. Kendler, A. Zohar, and S. Goldberg, “Eclipse attacks on
bitcoin’s peer-to-peer network,” in 24th {USENIX} Security Symposium
({USENIX} Security 15), 2015, pp. 129–144.

[24] M. Apostolaki, A. Zohar, and L. Vanbever, “Hijacking bitcoin: Routing
attacks on cryptocurrencies,” in 2017 IEEE Symposium on Security and
Privacy (SP), 2017, pp. 375–392.

[25] I. Eyal and E. G. Sirer, “Majority is not enough: Bitcoin mining is
vulnerable,” Communications of the ACM, vol. 61, no. 7, pp. 95–102,
2018.

[26] A. Sapirshtein, Y. Sompolinsky, and A. Zohar, “Optimal selﬁsh mining
strategies in bitcoin,” in International Conference on Financial Cryptog-
raphy and Data Security, 2016, pp. 515–532.

[27] I. Eyal, “The miner’s dilemma,” in 2015 IEEE Symposium on Security

and Privacy, 2015, pp. 89–103.

[28] A. Monden, D. Nakae, T. Kamiya, S.-i. Sato, and K.-i. Matsumoto,
“Software quality analysis by code clones in industrial legacy software,”
in Proceedings Eighth IEEE Symposium on Software Metrics, 2002, pp.
87–94.

[29] M. Mondal, C. K. Roy, M. S. Rahman, R. K. Saha, J. Krinke, and K. A.
Schneider, “Comparative stability of cloned and non-cloned code: An
empirical study,” in Proceedings of the 27th Annual ACM Symposium
on Applied Computing security, 2012, pp. 1227–1234.

[30] Z. Li, S. Lu, S. Myagmar, and Y. Zhou, “Cp-miner: Finding copy-paste
and related bugs in large-scale software code,” IEEE Transactions on
software Engineering, vol. 32, no. 3, pp. 176–192, 2006.

[31] M. Kim, V. Sazawal, D. Notkin, and G. Murphy, “An empirical study of
code clone genealogies,” in ACM SIGSOFT Software Engineering Notes,
vol. 30, no. 5, 2005, pp. 187–196.

[32] S. Zhang, X. Zhang, X. Ou, L. Chen, N. Edwards, and J. Jin, “Assessing
attack surface with component-based package dependency,” in Interna-
tional Conference on Network and System Security, 2015, pp. 405–417.
[33] P. Reibel, H. Yousaf, and S. Meiklejohn, “Short paper: An exploration
of code diversity in the cryptocurrency landscape,” in International
Conference on Financial Cryptography and Data Security.
Springer,
2019, pp. 73–83.

[34] C. K. Roy, J. R. Cordy, and R. Koschke, “Comparison and evaluation
of code clone detection techniques and tools: A qualitative approach,”
Science of computer programming, vol. 74, no. 7, pp. 470–495, 2009.

[35] F. P. Viertel, W. Brunotte, D. Str¨uber, and K. Schneider, “Detecting se-
curity vulnerabilities using clone detection and community knowledge.”
in SEKE, 2019, pp. 245–324.

[36] H. Liu, Z. Yang, C. Liu, Y. Jiang, W. Zhao, and J. Sun, “Eclone:
Detect semantic clones in ethereum via symbolic transaction sketch,” in
Proceedings of the 2018 26th ACM Joint Meeting on European Software
Engineering Conference and Symposium on the Foundations of Software
Engineering, 2018, pp. 900–903.

[37] W. Chen, Z. Zheng, J. Cui, E. Ngai, P. Zheng, and Y. Zhou, “Detecting
ponzi schemes on ethereum: Towards healthier blockchain technology,”
in Proceedings of the 2018 World Wide Web Conference on World Wide
Web, 2018, pp. 1409–1418.

[38] J. H. Johnson, “Substring matching for clone detection and change

tracking.” in ICSM, vol. 94, 1994, pp. 120–126.

[39] Y. Higo, Y. Ueda, T. Kamiya, S. Kusumoto, and K. Inoue, “On software
maintenance process improvement based on code clone analysis,” in
International Conference on Product Focused Software Process Improve-
ment, 2002, pp. 185–197.

[40] R. Koschke, R. Falke, and P. Frenzel, “Clone detection using abstract
syntax sufﬁx trees,” in 2006 13th Working Conference on Reverse
Engineering, 2006, pp. 253–262.

[41] P. Hartel, I. Homoliak, and D. Reijsbergen, “An Empirical Study into the
Success of Listed Smart Contracts in Ethereum,” IEEE Access, vol. 7,
pp. 177 539–177 555, 2019.

[42] M. Rieger, “Effective clone detection without language barriers,” Ph.D.

dissertation, Verlag nicht ermittelbar, 2005.

[43] U. Manber et al., “Finding similar ﬁles in a large ﬁle system.” in Usenix

Winter, vol. 94, no. 5, 1994, pp. 1–10.

[44] E. Merlo, G. Antoniol, M. Di Penta, and V. F. Rollo, “Linear complexity
object-oriented similarity for clone detection and software evolution anal-
yses,” in 20th IEEE International Conference on Software Maintenance,
2004. Proceedings., 2004, pp. 412–416.

[45] J. R. Cordy, T. R. Dean, and N. Synytskyy, “Practical

language-
independent detection of near-miss clones,” in Proceedings of the 2004
conference of the Centre for Advanced Studies on Collaborative research,
2004, pp. 1–12.

