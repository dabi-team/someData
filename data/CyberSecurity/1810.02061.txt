8
1
0
2

t
c
O
5

]

R
C
.
s
c
[

2
v
1
6
0
2
0
.
0
1
8
1
:
v
i
X
r
a

1

Design and Evaluation of A Data
Partitioning-Based Intrusion Management
Architecture for Database Systems

Muhamad Felemban, Yahya Javed, Jason Kobes, Thamir Qadah
Arif Ghafoor, and Walid Aref

Abstract—Data-intensive applications exhibit increasing reliance on Database Management Systems (DBMSs, for short). With the
growing cyber-security threats to government and commercial infrastructures, the need to develop high resilient cyber systems is
becoming increasingly important. Cyber-attacks on DBMSs include intrusion attacks that may result in severe degradation in
performance. Several efforts have been directed towards designing an integrated management system to detect, respond, and recover
from malicious attacks. In this paper, we propose a data Partitioning-based Intrusion Management System (PIMS, for short) that can
endure intense malicious intrusion attacks on DBMS. The novelty in PIMS is the ability to contain the damage into data partitions,
termed Intrusion Boundaries (IBs, for short). The IB Demarcation Problem (IBDP, for short) is formulated as a mixed integer nonlinear
programming. We prove that IBDP is NP-hard. Accordingly, two heuristic solutions for IBDP are introduced. The proposed architecture
for PIMS includes novel IB-centric response and recovery mechanisms, which executes compensating transactions. PIMS is prototyped
within PostgreSQL, an open-source DBMS. Finally, empirical and experimental performance evaluation of PIMS are conducted to
demonstrate that intelligent partitioning of data tuples improves the overall availability of the DBMS under intrusion attacks.

Index Terms—Database systems, Intrusion management, Cost-driven optimization, Intrusion detection

(cid:70)

1 INTRODUCTION
Data-intensive applications exhibit increasing reliance on
efﬁcient and scalable Database Management Systems
(DBMSs). Examples of these applications are abound in
the domain of banking, manufacturing, health care, and
enterprise applications [1]. Since data is the most valuable
asset in organizations, it is crucial to design attack-resilient
DBMSs to protect the conﬁdentiality, integrity, and avail-
ability of the data in the presence of Cyber attacks [2], [3].
Although research in database security has made signiﬁcant
progress in protecting from Cyber attacks, applications and
infrastructures are still exposed to a large number of vul-
nerabilities. Even a single intrusion can cause catastrophic
cascading effects due to data dependency and application
interoperability. Therefore, a holistic approach for designing
an intrusion management mechanism that includes intru-
sion detection, response, and recovery is needed [4], [5].

An Intrusion Detection System (IDS) is integrated with
the DBMS to prevent Cyber attacks. The objective of an
IDS is to monitor and detect illegal access and malicious
actions that take place in the database. However, an IDS is

• Muhamad Felemban, Yahya Javed, Thamir Qadah, and Arif Ghafoor
are with the School of Electrical and Computer Engineering at Purdue
University, West Lafayette, IN 47906..

• Walid Aref is with the School of Computer Science at Purdue University,

West Lafayette, IN 47906..

•

Jason Kobes is with Northrop Grumman

not designed to repair the damages caused by successful
attacks. IDS is often integrated with intrusion response and
recovery mechanisms to alleviate the damage caused by
the malicious attacks [4]. Several efforts have been directed
towards developing dynamic damage tracking approach to
perform on-the-ﬂy damage repair, for example intrusion-
tolerant database systems [5], [6]. However, such systems
have limitations in the ability to maintain high availability
under severe intrusion attacks. One of the limitations for
these systems is the prolonged recovery time due inter-
transaction dependency.

Motivating Example: Fig. 1 gives an example scenario for
a Banking system with three benign users (B,C, and D), and a
malevolent user (A). User A executes a malicious transaction that
updates accounts X and Y with incorrect amounts of money as
illustrated in Fig. 1. Then, Users B and C withdraw from accounts
X and Y , respectively. IDS detects the malicious transaction
executed by User A and triggers an alert to the database security
administrator that temporarily blocks the incoming transactions
and starts the recovery procedure. Meanwhile, User D attempts
to access account Z. However, this request is denied until the
damage is recovered. When the recovery transaction is ﬁnished,
the accounts of Users A and B are compensated, i.e., withdraws
money from account X and credits account Y .

In the above example, the recovery time depends on the
number of dependent transactions that are executed before
the IDS detects the malicious transaction. Consequently, the
availability of the DBMS is impaired when the recovery
procedure takes a long duration. Therefore, it is impor-
tant to contain the damage once malicious transactions are
detected. Containment of the damage can be achieved by
tracking the inter-transaction dependencies and devising a

 
 
 
 
 
 
2

(a) Transaction history H1

(b) Precedence graph

Fig. 2: Transaction history and PG.

respectively. The set of tuples that are read and updated
by a transaction ti are denoted by Ri and Wi, respectively.
Formally, ti is deﬁned as follows [8]:

1)
2)

3)
4)

ti ⊆ {wi[o], ri[o]|o ∈ D} ∪ {ai, ci}
if wi[o], ri[o] ∈ ti, then either wi[o] <i ri[o] or
ri[o] <i wi[o]
ai ∈ ti if and only if ci /∈ ti, and
for any operation p ∈ ti, p <i t where t is either ai
or ci (whichever in ti)

where ai and ci denote the abort and commit operations of
ti, respectively. In essence, Condition (1) deﬁnes the types
of operations in ti. Condition (2) requires that the order of
execution of Read and Write operations on a data item is
speciﬁed by <i. Condition (3) says that ti either commits or
aborts, while Condition (4) speciﬁes that commit (or abort)
must follow all other operations.

i=1ti and <H ⊇ ∪m

For a set of m transactions T = {t1, t2, ..., tm}, a com-
plete history H over T is a partial order with the ordering
relation <H , where H = ∪m
i=1 <i. In other
words, the execution history represented by H involves all
transactions in T and matches all operation orderings that
are speciﬁed within each transaction. Two transactions ti
and tj in H are dependent if (i) ti is directly followed by
tj, i.e., ti <H tj, and (ii) Wti ∩ Rtj (cid:54)= ∅. The dependency
between ti and tj is read ”tj depends on ti”. In general, tj
depends on ti if (i) ti <H tk1 <H . . . <H tkn <H tj, and (ii)
(Wti − ∪l=1,..,nWtkl

) ∩ Rtj (cid:54)= ∅.

The dependencies among T in the history H is modeled
using the transaction Precedence Graph (PG) [8]. PG is a
directed graph P G = {V, E}, where V is a set of nodes;
each node representing a committed transaction in H, and
E is a set of edges; each edge representing a dependency
between two transactions. In other words, an edge between
two transactions ti and tj exists if tj depends on ti. Fig.
2(a) illustrates a History H1 over T = {t1, t2, t3, t4}. H1’s
corresponding PG is in Fig. 2(b). t2 depends on t1 because
t1 updates o2 that is later read by t2. Similarly, t3 depends
on t1 and t4 depends on t3.

Fig. 1: Motivating example.

fast conﬁnement strategy to contain the damage.

In this paper, we propose a new real-time response
and recovery architecture, termed Partition-based Intrusion
Management System (PIMS), for DBMSs. We assume that
existing IDS, e.g., [4], [7], can be integrated with PIMS.
PIMS is based on an adaptive access and admission control
mechanism that responds to intrusions by selectively block-
ing segments of data that have been affected by the intru-
sion. The access control mechanism provides a ﬁne-grained
control policy to allow graceful degradation of database
services in order to maintain a desired level of availability
while the system is undergoing through impending attacks.
The unique feature of PIMS is the deployment of a data
partitioning technique to conﬁne the damage and improve
the availability of the system.

The contribution of this paper is summarized as fol-
lows. First, we propose the concept of Intrusion Boundary
(IB) that deﬁnes the extent of the damage over the set of
transactional workload. We formulate the IB demarcation
as an optimization problem as a Mixed Integer Non-Linear
Programming model (MINLP). The output of the optimiza-
tion problem is a balanced IB assignment of transactions to
partitions with minimum overlapping. We prove that the IB
demarcation problem is NP-hard. Accordingly, we introduce
two heuristics to provide a polynomial time solution. Fi-
nally, we introduce response and recovery mechanisms that
use the proposed IB assignment to improve the intrusion
response and recovery in terms of availability and response
time.

The rest of the paper is organized as follows. Section 2
presents relevant background. Section 3 presents the deﬁ-
nition and formulation of the IB demarcation problem, its
hardness proof, and present two new heuristics. Section 4
describes the design and implementation of PIMS. The per-
formance evaluation and the experimental results of PIMS
are presented in Section 5. The related work is presented in
Section 6. Finally, Section 7 concludes the paper.

2 BACKGROUND
In this section, we present the database and transaction
model and explain the threat model. In addition, we present
an overview of the state-of-the-art malicious transaction
recovery mechanisms in DBMSs.

2.1 Database and Transaction Model
A database is a set of n tuples denoted by D =
{o1, o2, . . . , on}, where oi refers to a tuple. A transaction ti is
a partially ordered set of operations, with a partial ordering
relation <i [8]. The read and write (update) operations on
a tuple, say o ∈ D, of ti are denoted by ri[o] and wi[o],

2.2 Threat Model

In this paper, our focus is on the data corruption caused by
transaction-level attacks in the DBMS. These attacks can be
manifested either through masquerade access or by exploit-
ing application vulnerabilities, e.g., SQL injection, Cross Site

Banking	DatabaseBACDSystem	is	downDBSAIncorrect	balanceIncorrect	balanceTimeUserTransaction14:05:34A	(Malicious)Updates	account	X	=	X+100Updates	account	Y	=	Y	-20014:05:37BWithdraws	from	account	X14:05:39CWithdraws		from	account	Y14:06:04DBSAShuts	down	DBand	startstransaction	recovery	procedure14:06:15DBlockedfrom	checking	account	Z14:08:24DBSAMalicious	transaction	recoveredScripting (XSS), and Cross-Site Request Forgery (CSRF) [9].
A transaction, say tm, is malicious if it tampers the database
by updating one or more tuples with incorrect data. In this
context, a malicious transaction corrupts the data due to
either an attack or through a user fault. A transaction, say
ta, is affected if ta directly (or indirectly) depends on a
malicious or an affected transaction, i.e., Wtm ∩ Rta (cid:54)= ∅
(or Wtj ∩ Rta (cid:54)= ∅ such that Wtm ∩ Rtj (cid:54)= ∅∀tj ∈ T ). All
malicious and affected transactions are invalid transactions.
The execution of an invalid transaction takes the DBMS into
an invalid state. For example, assume that Transaction t1 in
Fig. 2(b) is malicious. Then, both t2 and t3 are affected trans-
actions. We assume that a malicious transaction does not
depend on other transactions, i.e., a malicious transaction
cannot be an affected transaction. Furthermore, we assume
that we can undo the effects of committed transactions.

Throughout the rest of the paper, we deal with integrity
attacks in which either an authorized or non-authorized
user intentionally tampers with the data by injecting wrong
values into some tuples. This attack can temporarily impair
the availability of the DBMS during the recovery period.
We rely on the existence of an IDS to detect the malicious
transactions [7]. Note that the IDS alarm is received after
the malicious transactions commit. We assume that the
presence of an access control policy is sufﬁcient to prevent
any conﬁdentiality attacks. Moreover, we assume that there
are security countermeasures to prevent other availability
attacks, e.g., Denial-of-Service (DoS) [3].

3

3 INTRUSION BOUNDARY DEMARCATION USING
DATA PARTITIONING
In this section, we present a data-level model to repre-
sent intra-transaction and inter-transaction dependencies.
Accordingly, we deﬁne the IB demarcation problem, and
formulate it as MINLP optimization problem. Finally, we
prove the problem’s hardness and present two efﬁcient
heuristics to solve the IB demarcation problem.

3.1 The IB Demarcation Problem

The objective of the IB demarcation problem is to partition
the tuples into k partitions, i.e., IBs, with minimum overlap.
The advantage of the IB demarcation is to conﬁne the dam-
age into a single IB, and thus increases the data availability
in the presence of attacks. Notice that, the overlap among
partitions depends on the inter-transaction dependency. For
workloads with independent transactions, the demarcation
results in non-overlapping IBs. On the other hand, for
workloads with high inter-transaction dependencies the IB
demarcation results in overlapping IBs. The IB demarcation
is deﬁned as follows.

(Intrusion Boundary Demarcation Problem
Deﬁnition 3.1.
(IBDP)) Given the set of transactions T over a set of n tuples,
IBDP is to assign the transactions into k IBs such that the overlap
among the IBs is minimized and the sizes of the IBs are almost
equal.

2.3 Recovery from Malicious Transactions

3.1.1 Problem Formulation

Handling the recovery of malicious transactions requires
undoing the committed malicious and affected transactions.
There are two common approaches to undo committed
transactions: rollback and compensation. The rollback ap-
proach is to roll back all the operations performed by the
committed transaction to a point that is free of damage
[10]. On the other hand, the compensation approach seeks
to selectively undo committed transactions without rolling
back the state of the DBMS into a previous state [11].

PIMS is relevant to the work in [5], [6], in which a
real-time approach tracks the inter-transaction dependency,
marks the affected transactions, and repairs the damage. The
recovery is perfromed in two stages: damage assessment
and damage repair. In the damage assessment stage, the
complete and correct set of affected transactions is iden-
tiﬁed. This stage is challenging because the assessment is
conducted on-the-ﬂy while the system is processed other
concurrent transactions. Due to transaction dependency, the
damage might spread. Therefore, the damage assessment is
terminated whenever there are no more transactions that
cause spread of the damage. Once the damage assessment
stage is completed, all the identiﬁed affected transaction
are repaired by rolling them back without affecting the
other transactions in the system. PIMS’s recovery approach
is different than [5], [6] in a sense that PIMS aggressively
terminates the damage spread by stopping the execution of
the concurrent transactions momentarily during the damage
assessment process. Moreover, PIMS adopts data partition-
ing scheme that provides a proactive damage conﬁnement
mechanism by designating a group of tuples to prevent the
spread of the damage into the entire database.

The demarcation of IBs is controlled by the dependencies
among the tuples that are accessed by multiple transac-
tions. We formulate IBDP as a dual-objective MINLP. The
ﬁrst objective function focuses on damage containment that
minimizes the overlap among IBs. In order to deﬁne this
objective function, we deﬁne the set of Boundary Tuples
(BT) as follows.

Deﬁnition 3.2. (Boundary tuple) A tuple, say o ∈ D, termed a
boundary tuples if o is assigned to two or more IBs. The set of
boundary tuples in the IB assignment is denoted by BT . Observe
that BT ⊆ ST .

It is sufﬁcient to minimize the number of boundary
tuples in order to minimize the overlap among IBs. Thus,
the objective function can be deﬁned as follows.

f1(B) =

n
(cid:88)

i=1

bi

(1)

where B is the boundary tuples vector that indicates if a
tuple is boundary, i.e., bk=1 if the ith tuple is a boundary
tuple, and 0, otherwise (notice that |B| = n). The intuition be-
hind minimizing the number of boundary tuples is to limit
the damage propagation across IBs. However, Equation 1 is
oblivious to the number of IBs that share a boundary tuple.
This number is termed the degree of sharing. A boundary
tuple that is shared between 2 IBs has less risk of damage
propagation as compared to a boundary tuple that is shared

among multiple IBs. The degree of sharing is incorporated
in Equation 1 in the following way.

f1(B, TuIB ) =



bi



k
(cid:88)

j=1

n
(cid:88)

i=1



TuIB ij − 1



(2)

where TuIB is the IB assignment matrix for the tuples,
i.e., TuIB ij = 1 if the ith tuple is assigned to the jth IB,
and 0, otherwise. The sum (cid:80)k
j=1 TuIB ij is the number of
IBs to which the ith tuple is assigned, whereas the sum
(cid:80)n

i=1 TuIB ij is the size of the jth IB.
The second objective function focuses on the overall
availability. The goal of this objective function is to prevent
skewed IB assignment by balancing the sizes of the IBs. For-
mally, the objective of balancing the sizes of IBs is deﬁned
as follows.

f2(TuIB ) =

(cid:118)
(cid:117)
(cid:117)
(cid:117)
(cid:116)

k
(cid:88)

k
(cid:88)

(cid:32) n
(cid:88)

i=1

j>i

(cid:96)=1

TuIB (cid:96)i −

(cid:33)2

TuIB (cid:96)j

(3)

n
(cid:88)

(cid:96)=1

Let TrIB be the IB assignment matrix for the transactions,
i.e., TrIB ij = 1 if the ith transaction is assigned to the jth
IB, and 0, otherwise. Similarly, Let TuTr be a binary matrix
representing the association of tuples to the transactions,
i.e., TuTr ij = 1 if the ith tuples is accessed by the jth
transaction, and 0, otherwise. Although a transaction might
span multiple IBs, each transaction must be fully contained
within a single IB. The intuition is that by containing a
transaction within an IB, the damage is conﬁned in that IB if
the transaction is detected as malicious. Accordingly, IBDP
is formulated as MINLP using objective functions f1 and f2
as follows.

f1(B, TuIB ) + f2(TuIB )

Minimize
TuIB,TrIB,B

subject to

k
(cid:88)

j=1

2 −

TuIB ij − 1 ≤ kbi, ∀i ∈ {1, . . . , n} (4)

k
(cid:88)

j=1

TuIB ij ≤ k(1 − bi),

∀i ∈ {1, . . . , n}
n
n
(cid:88)
(cid:88)

TuTr i(cid:96) −

i=1
1 − TrIB (cid:96)j

i=1

TuTr i(cid:96) ∗ TuIB ij ≥

∀(cid:96) ∈ {1, . . . , m}, j ∈ {1, . . . , k}

k
(cid:88)

j=1
n
(cid:88)

TrIB ij = 1 ∀i ∈ {1, . . . , m}

TuIB ij ≥ 1 ∀j ∈ {1, . . . , k}

i=1
T uIBij ∈ {0, 1}, T rIBij ∈ {0, 1},
bi ∈ {0, 1}

(5)

(6)

(7)

(8)

(9)

The outputs of the optimization problem are the IB
assignment matrix of the tuples TuIB , the IBs assignment

4

matrix of the transactions TrIB , and the set of boundary
tuples B. Constraints (4) and (5) collectively check if a tuple
is assigned to multiple IBs. Accordingly, the constraints set
bi = 1 if the ith tuple is boundary, and 0, otherwise. Full
containment of a transaction within a single IB is checked
by constraints (6) and (7). In particular, a transaction t(cid:96) is
assigned to the jth IB only if all the tuples access by t (cid:96) are
assigned to the jth IB. Constraint (8) forces the size of each
IB to be at least one tuples, while constraint (9) forces TuIB ,
TrIB , and B to be binary matrices.

Theorem 3.1. IBDP is NP-hard.

3.2 Heuristics for IB Demarcation

We introduce two efﬁcient greedy-based heuristics to solve
IBDP. All algorithms take the set of transaction and the
number of IBs as input. The output is a transaction-to-IB
assignment. The algorithms start with an empty IB assign-
ment and iteratively assign transactions to IBs based on
greedy decisions that optimize the objective functions. The
ﬁrst heuristic is Best-Fit Assignment (BFA) that reduces the
number of boundary tuples produced by the IB assignment.
The intuition of the assignment is that BFA assigns the
transaction to the IB that shares the largest number of
shared tuples. The second heuristic is Balanced Assignment
(BA) that assigns transactions such that the sizes of all IBs
are almost equal. This is achieved by assigning, at each
iteration, the transaction to the IB that is the smallest in size.
Detailed discussion about each algorithm is presented in the
following sections.

3.3 Best-Fit Assignment (BFA)

BFA is listed in Algorithm 1. The algorithm starts with the
empty IB assignment set S and empty assigned transactions
set A (Line 1). Then, the transactions are sorted based on
the number of internal tuples in descending order (Line
2). The sorted transaction set is stored in Set T . Then,
the algorithm initially assigns the ﬁrst k transactions to
the empty IBs (Lines 3-9). As a result, the overlap among
the IBs is minimized. This is correct because the ﬁrst k
transactions in T have the least number of shared tuples.
For the remaining transactions in T , each transaction t is
assigned to the IB that shares the largest number of shared
tuples with t (Lines 10-19). In particular, the set of assigned
transactions that overlap with t is stored in N T (Line 11).
Then, the IBs of each transaction in N T is stored in N IB
(Line 12). N IB contains the set of all IBs that share tuples
with t. If the set N IB is not empty, t is assigned to the IB
that has the largest number of shared tuples with t (Line
14-16). Otherwise, t is assigned to the smallest IB in S.
Lemma 3.1. The complexity of BFA is O(nm2 + knm).

Proof. BFA sorts the set of transactions based on the number
of internal tuples in each transaction (Line 3). Sorting Set T
has a runtime complexity of O(m log m). The loop in Lines
3-9 assigns a single transaction to each empty IB. Thus, the
loop has a runtime complexity of O(k). Then, BFA assigns
transactions to the best-ﬁt IB (Lines 10-19). The runtime
complexity of ﬁnding the set N T and N IB is O(nm) (Lines
11 and 12). Finding ibmax, the IB that has the largest number

Algorithm 1: Best Fit Assignment

Input: k
Output: S = {ib1, ..., ibk}

1. S = ∅, A = ∅
2. T ←Sort transactions based on the number of internal

tuples in descending order

5

5.

6.

7.

12.

13.

14.

15.

16.

17.

3. for i = 1..k do
4.

t ← largest transaction in T
ibi = {t}
S = S ∪ {ibi}
Add t to A
Remove t from T

8.
9. end
10. for t ∈ T do
11.

Find N T the set of assigned transaction that overlap
with t
Find N IB the set of IBs that overlap with t
if N IB (cid:54)= ∅ then

Find ibmax ∈ N IB that has the largest number of
tuples shared with t
ibmax = ibmax ∪ t

else

Assign t to the smallest ib

end

18.
19. end
20. return S

of tuples shared with t, and assigning t in Lines 13-18 has
a runtime complexity of O(nk). The runtime complexity for
assigning all the transactions is O(m(nm+nk)). The overall
complexity of BFA is O(m log m + k + nm2 + knm), i.e.,
approximately O(nm2 + knm).

4 THE ARCHITECTURE OF PIMS
In this section, we introduce the architecture of PIMS. The
proposed architecture for PIMS is given in Fig. 3. PIMS is
composed of ﬁve components: the IBDP solver, the trans-
actions log, the Admission Controller (AC), the Response
Subsystem (RES), and the Recovery Subsystem (REC). In
addition, PIMS maintains a Corrupted Tuples Table (CTT)
to track the status of the damage caused by the malicious
transactions. The IBDP solver generates the IB assignment as
discussed in the previous section. The transactions log stores
information about the read/write operations of transactions.
The log is essential for the recovery procedure to con-
struct compensating transactions. The functionality of AC
includes parsing the transactions, regulating the admission
of transactions to DBMS, and maintaining the IB assignment
table. AC determines whether to block or allow incoming
transactions depending on the status of the damage and the
assigned IB. When a committed transaction is identiﬁed as
malicious, RES extracts the commit and detection times of
the malicious transaction, approximates the set of corrupted
tuples immediately, and stores it in CTT. Although the
approximated set can include uncorrupted tuples, the ob-
jective is to reduce the risk of executing benign transactions
that might propagate the damage unwillingly. Then, REC
analyzes the inter-transaction dependency in transactions
log and identiﬁes the correct and complete set of affected
transactions. The correct set of affected transactions means
that no transactions are falsely identiﬁed as affected, while

Fig. 3: PIMS Architecture.

the complete set means that the set contains every affected
transactions caused by the attack. We refer to this set as the
set of Affected Transactions (AT). When AT is identiﬁed,
the benign tuples are removed from CTT, and consequently
can be accessed by the requesting transactions immediately.
On the other hand, the corrupted tuples are blocked and
will be recovered by the compensating transactions. The
recovered tuples are removed from CTT gradually in order
to increase the system availability. In the following sections,
we present detailed information about the functionality of
each component.

4.1 Transactions Log

In order to obtain accurate information about the extent
of the damage caused by the malicious transaction, the
read/write operations of all transactions need to be logged.
However, conventional undo/redo logs and DBMS triggers
only record write operations. To address this issue, we have
implemented a read/write log that records the transaction
ID, the tuple ID, the before-image (the previous value),
the after-image (the current value), and the time-stamp for
each read and update operation. The transactions log is
implemented in the DBMS kernel to reduce the overhead of
logging. The transactions log is maintained as a table in the
DBMS for efﬁcient retrieval by PIMS. The transactions log is
used by AC to check if a transaction reads from corrupted
tuples, and by RES to identify AT.

4.2 The Admission Controller (AC)

AC has three subcomponents: the Parser, the IB Manager
(IBM), and the Transaction Mediator (TM). The parser ex-
tracts the read/write set from transactions. IBM maintains
in the IB table information about the IBs including the set of
boundary tuples and the transaction-to-IB assignment. The
functionality of IBM is to manage the access to the boundary
tuples. In essence, the updated boundary tuples are locked
by IBM until IDS reports the status of the updating trans-
action. If the transaction is identiﬁed as malicious, then the
locked boundary tuples are added to CTT. Otherwise, the
locked boundary tuples are released. One problem is that
IDS only triggers an alarm when a malicious transaction is
detected. We assume that IDS has a detection delay of ∆
ms. The boundary tuples are locked for a sufﬁcient time
after which the updating transaction can never be detected
as malicious. We set PIMS to wait for 1.5 ×∆ ms before

Application	(Workload)Log	table/CTTDatabase(PostgreSQL)PIMSIntrusion	DetectionIBDP	SolverResponse	SubsystemResponse	ManagerDamage	ContainmentRecovery	SubsystemDependency	AnalyzerDamage	AssessmentCompensation	ManagerDamageCleansingRepair	ManagerAdmission	ControllerDBMSTransactions	MediatorLog	IB	TableIBManagerParserAlgorithm 2: Admission control

Algorithm 3: Intrusion Response

6

Input: ti
Output:

Wait until the requested BT is released

1. RWti ← the read/write tuples set ti
2. while RWti ∩ BT (cid:54)= ∅ do
3.
4. end
5. while RWti ∩ CT T (cid:54)= ∅ do
6.

Wait until request tuples in CTT are recovered and

released

7. end
8. /* Wait until lock is acquired
9. Acquire lock on IBti
10. Execute ti
11. Release lock on IBti

Input: tm, td
m
Output: Updated CT T
m ← get commit time of tm

1. tc
2. Find IBtm the set of IBs spanned by tm
3. for tuples updated between tc
m do
4.

if tuple is assigned to an IB ∈ IBtm then

m and td

5.

Add tuple to CT T

end

6.
7. end

*/

releasing the boundary tuples. The objective of locking the
boundary tuples after update is to assure that the damage
does not propagate to other IBs. We refer to the process of
locking the boundary tuples as delayed access mechanism.

TM checks if the transaction’s read/write set contains
any tuple that exists in CTT or BT. If a tuple in the read set
exists in CTT, the transaction is suspended. On the other
hand, if a tuple in the write set exists in CTT, then the
transaction is executed, and the tuples are removed from
CTT and are excluded from subsequent undo and redo oper-
ations. AC is signaled on two events: 1) the corrupted tuples
are recovered, or 2) the recovery procedure is completed.
When signaled, TM executes the suspended transaction if
its read tuples are all recovered. Otherwise, the transaction
remains suspended until a new signal is received from RES
or REC. If the transaction’s read/write set contains a tuple
that exists in BT, then the transaction is suspended until the
tuples are released by IBM.

Before executing the transaction, AC acquires the locks
associated with the assigned IB(s). The lock is to ensure that
no concurrent recovery procedure is running on the IB(s).
The lock is released by AC when the transaction is executed
successfully. The overall procedure for admission control is
listed in Algorithm 2. Notice that multiple instances of the
admission controller can be executed using multiple threads
to increase transaction concurrency. We rely on the available
Concurrency APIs to queue the incoming transactions when
TM threads are busy waiting for signals.

4.3 The Response Subsystem (RES)
RES is activated when a transaction tm is detected as mali-
cious by IDS. The objective of RES is to prevent subsequent
benign transactions from reading corrupted tuples that are
updated by tm, and thus control the spread of the damage.
RES collects the time information about tm from IDS and
the transactions log, i.e., the commit timestamp tc
m and the
detection timestamp td
m. Moreover, RES extracts IBtm , the
set of IBs that are spanned by tm, from the IB table. Conse-
quently, RES adds all tuples in IBtm that have been updated
between tc
m to CTT. Notice that the tuples that
are updated between tc
m but not assigned to IBtm
are not added to CTT. Thus, PIMS provides more accurate
damage conﬁnement as compared to ITDB, which blocks
all tuples on temporal basis only. Nevertheless, CTT might
contain uncorrupted tuples updated by benign transactions

m and td

m and td

Algorithm 4: Intrusion Recovery

Input: tm, IBtm
Output: Updated CTT

1. Acquire recovery lock in every IB ∈ IBtm
2. Block new transactions in IBtm
3. Wait for currently running transaction in IBtm to commit
4. Find the set of affected transaction ATtm
5. Find the S set of all updated tuples by tm and ta ∈ AT
6. Resume new transaction in IBtm
7. for o ∈ CT T do
if o /∈ S then
8.

9.

Remove o from CTT and ﬂag as valid

end

10.
11. end
12. Resume transactions to IBtm
13. /* Phase I
14. Undo tm
15. for Ta ∈ ATtm do
Undo Ta
16.
17. end
18. /* Phase II
19. for Ta ∈ ATtm do
Redo Ta
20.
21. end

*/

*/

that are independent from tm. Once enough information
about the inter-transaction dependencies between tm and
subsequent transactions is gathered, PIMS removes the un-
corrupted tuples from CTT as explained in the next section.
The procedure of RES is summarized in Algorithm 3.

4.4 The Recovery Subsystem (REC)

REC is the core component of PIMS that identiﬁes AT
and executes compensating transactions for the corrupted
tuples. The compensating transactions perform two opera-
tions: undo and redo. The undo operation unwinds the effect
of the malicious transaction and each transaction in AT.
By performing the undo operation, the state of the DBMS
returns to the state just before the malicious transaction
is executed. However, the update operations performed
by the subsequent benign transactions are lost. The redo
operation preserves the lost updates by re-executing each
transaction in AT. Notice that the malicious transaction is
not re-executed because its updates are undesirable.

The overall algorithm for REC is listed in Algorithm 4.
REC is activated once the response procedure is ﬁnished.
Thus, the response and recovery transactions are executed
serially. Serializing the response and recovery procedures
is essential since the recovery mechanism uses CTT that
is updated by the response subsystem. REC temporarily
blocks new transactions to prevent new transactions from

reading the corrupted tuples while REC identiﬁes AT. This is
achieved by acquiring locks on IBtm . Incoming transactions
are blocked by AC. Notice that the active transactions are
not preempted. When all active transactions are committed,
the Dependency Analyzer scans the transactions log starting
from tc
m through the current timestamp in order to ﬁnd AT.
The write set of each transaction in AT is extracted and is
added to CTT. The Damage Assessment subsystem removes
the uncorrupted tuples that have been initially added by
RES from CTT.

At this point, CTT contains the correct and complete
set of the corrupted tuples caused by tm. The Compensation
Manager (CM) executes a sequence of compensating trans-
actions that gradually repair the damage. Damage repair is
performed in two phases. In Phase 1, CM executes compen-
sating transactions that unwind the effect of the malicious
and affected transactions. CM uses the transactions log table
to ﬁnd the correct version of the corrupted tuples. In partic-
ular, CM updates the corrupted tuples with the values of the
most recent versions before the execution of the malicious
transaction. The compensating transactions are executed in
the order at which the malicious and affected transactions
are committed. At the end of this phase, Damage Cleansing
(DC) removes the recovered tuples from CTT and signals
AC to resume any blocked transactions.

In the second phase, CM executes compensating transac-
tions that re-execute each transaction in AT in the same or-
der at which they are committed. The information required
to re-execute the transactions, e.g., old balance, is main-
tained in the transactions log. Once an affected transaction
is re-executed successfully, DC removes the set of recovered
tuples from CTT and signals AC.

4.5 Managing Multiple Malicious Transactions

The advantage of partitioning the tuples into IBs is to
execute concurrent response and recovery procedures on
different IBs. The reason is that all transactions in AT are
guaranteed to be contained in IBtm . As a result, concurrent
recovery procedures do not perform conﬂicting operations
while recovering the corrupted tuples. Multiple instances
of response and recovery procedures are executed using
multiple threads. In the case when multiple malicious trans-
actions are detected within the same IB, the recovery pro-
cedures need to be coordinated to avoid out-of-order exe-
cution of the recovery operations. The strategy is to execute
the recovery procedures for the malicious transactions in the
same order in which they are detected.

5 PERFORMANCE EVALUATION
In this section, performance evaluation of the proposed
PIMS framework is presented. First, we discuss the synthetic
workload used for the performance evaluation. Then, we
evaluate the performance of the proposed IB demarcation
heuristics. Finally, we conduct extensive system evaluation
of PIMS using synthesized workloads, and present the per-
formance results.

5.1 Synthetic Transactional Workload

Several benchmarks have been developed to evaluate the
performance of OLTP systems, e.g., TPC-C [15], SmallBank

7

[16], and YCSB [17]. However, no benchmark has been
developed to evaluate the performance of intrusion manage-
ment systems in OLTP. In order to evaluate the performance
of PIMS, we have developed a malicious transaction work-
load benchmark that generates long chains of dependent
transactions. These long chains of dependent transactions
amplify the potential damage that can be caused by the
malicious transactions. In essence, executing dependent
transactions shortly after malicious transactions induce the
spread of damage. Thus, the proposed benchmark allows
the assessment of the capability of the intrusion manage-
ment systems to conﬁne and recover the damage without
degrading the performance of the DBMS.

The proposed benchmark simulates a banking money-
transfer application. In essence, the benchmark consists of
a single data table, Checking, that has two attributes: id and
balance. The benchmark has three types of money transfer
transactions: distribute, collect, and many-to-many transfer. A
distribute transaction transfers money from a single account
to N other accounts; A collect transaction transfers money
from M accounts to a single account; A many-to-many
transactions transfers money from N accounts to another
M accounts. The benchmark is implemented on an OLTP-
benchmark testbed for relational databases [18].

We now explain the process of generating a workload
of m transactions. We use four parameters to characterize
the workload: 1) the inter-transaction dependency proba-
bility threshold β, 2) the maximum number of dependent
transactions T xmax, 3) the amount of transferred money γ,
and 4) the maximum transaction size Sizemax. First, the
inter-transaction dependency is modeled using PG. PG is
constructed using the Erd ¨os-Renyi model [19], in which an
edge has probability p of existence. The degree of inter-
transaction dependency is controlled by grouping transac-
tions into small groups. Within each group, a pair of transac-
tions are dependent if p is greater than β. Semantically, each
group models money transfer transactions within a city,
state, or country. In order to avoid fully connected graphs
within the group of transactions, the number of allowed
dependent transactions is limited to T xmax. In other words,
a transaction can be dependent to no more than T xmax
transactions. Once a PG is created, tuples are assigned to
the transactions as follows. The size of each transactions is
determined using a uniform distribution with a range of
[2,Sizemax]. The transaction type is randomly selected from
distribute, collect, or many-to-many. Each transaction shares
a single tuple with the set of its dependent transactions.
The value of γ is chosen from a uniform distribution with
range of [0.01,0.1]. Accordingly, the query is generated.
Each transaction contains a single query. We generate 4
workloads with different sizes, mainly, 5000, 10000, 15000,
and 20000 transactions. For each workload, we vary the
value of β to be 0.25, 0.5, and 0.75.

5.2 Evaluation of the IB Demarcation Heuristics

In this section, we evaluate the performance of the proposed
heuristics using a synthetic transactional workload. We
compare the performance of the proposed heuristics with
two assignment techniques: Random Assignment (RA) and
Skewed Assignment (SA). In RA, transactions are assigned

8

to the IBs randomly. In SA, transaction are randomly as-
signed to the IBs following an 80-20 rule, i.e., 80% of the
transactions are assigned to 20% of the IBs. SA is used to
emphasize the importance of the size balancing objective
(Equation 3). We use two metrics to evaluate the perfor-
mance of the heuristics: the total number of boundary tuples
(Equation 2), and the assignment fairness index. The fairness
index is used to assess the performance in terms of size
balancing among IBs. The fairness index is an adaptation of
the Jain’s fairness index [20] in the following way.

(a) Number of boundary tuples

(b) Fairness index

J (IB1, IB2, . . . , IBk) =

((cid:80)k
k · (cid:80)k

i=1 |IBi|)2
i=1 |IBi|2

(10)

Fig. 4: Effect of k on a workload of 5000 transaction with
α = 0.75.

where |IBi| is the number of transactions assigned to the
ith IB.

In the ﬁrst experiment, we vary the number of IBs, k,
using a workload of 5000 transactions, and β = 0.75. The
number of boundary tuples increases as k increases (refer
to Fig. 4(a)). The reason is that as k increases, the number
of contained transactions in each IB is reduced. As a result,
the overlap among IBs increases and thus increases the total
number of boundary tuples. We observe that BFA produces
a less number of boundary tuples compared to BA and
RA. The reason is that BFA performs a greedy decision to
reduce the number of boundary tuples when assigning a
transaction to IBs. Moreover, BA performs better than RA
because BA attempts to balance the sizes of the IBs. Notice
that SA produces less boundary tuples than BFA for k <10,
but more boundary tuples when k>10. The reason is that,
when the number of IBs is small, e.g., for k=5 and k=10, 80%
of the transactions are assigned only to 1 IB and 2 IBs, re-
spectively. Thus, most of the inter-transaction dependencies
are contained in at most 2 IBs. BFA and BA produce fair
assignment as in Fig. 4(b). SA performs the worst by design,
while RA performs better when the number of transactions
is large and the number of IBs is small because the random
assignment tends to be fair.

In the next experiment, we vary the number of transac-
tions and the value of β while generating the IB assignment
with k = 10. We observe that increasing the number of
transactions increases the number of boundary tuples as
in Fig. 5(a). The reason is that increasing the number of
transactions increases the number of shared tuples among
transactions. Notice that the set of boundary tuples is a
subset of the shared tuples. Similarly, increasing the value
of β increases the number of boundary tuples as in Fig. 5(b).
The reason is that as the value of β increases, the number of
dependent transactions increases. As a result, the number of
shared tuples increases.

5.3 PIMS Performance Evaluation

The experiments are conducted on a Dell Power Edge R420
server with 6-core Intel E5-2620v3 CPU, 120 GB of RAM, and
Ubuntu Server 16.0 LTS OS. We use PostgreSQL 9.5. PIMS is
implemented using Java and is connected to PostgreSQL us-
ing JDBC. We use 8 workers (threads) for the admission con-
troller and an unlimited pool of threads for the response and
recovery procedures. Before each experiment, the Checking
table is populated with 100,000 tuples of unique IDs and
initial balance of $10,000. We use a B-tree index on the

(a) Effect of the number transactions

(b) Effect of β

Fig. 5: Effect of the number of transactions and value of β
on a workload 5000 transaction with α = 0.75.

Checking table to improve the query execution time. We
assume that the transactions are submitted according to a
Poisson distribution with an arrival rate of λ. Furthermore,
malicious transactions are injected into the workload using
a uniform distribution over time. The number of malicious
transactions is based on the attack intensity π that is a
percentage of the total number of transactions.

We evaluate the performance of PIMS using four met-
rics: 1) the number of affected transactions, 2) the num-
ber of blocked transactions, 3) the average recovery time,
and 4) the average response time. The number of blocked
transactions indicates the performance of PIMS in terms
of availability, while the number of affected transactions
indicates the cost of damage. The average response time
is computed based on the response times of all committed
transactions. We compare the performance of PIMS using
the proposed heuristics, i.e., BFA and BA, with RA and
SA. We refer to PIMS with k>1 as ”PIMS k”. We often use
PIMS k BFA, PIMS k BA, PIMS k RA, and PIMS k SA to
differentiate between the assignment techniques as needed.
The performance of PIMS is compared against PIMS 1
(denoted by One IB) and ITDB [21]. We use a workload of
5000 transactions to conduct the experiments, unless stated
otherwise. In each experiment, we run PIMS with k values
of 5, 10, 15, and 20. We do not notice any improvement in
the performance beyond 20 IBs.

5.3.1 Read Log Overhead

In this experiment, we study the overhead of logging the
transaction read/write operations. Figs. 6(a) and 6(b) give
the throughput and response time with logging (PIMS)
and without logging (no logging) for various values of λ.
Notice that the throughput in both cases match the trans-
action arrival rate. However, logging read/write operations

 0 10 20 30 40 50 60 70 80 90 100 110 5 10 15 20Value of objective functionkBFARA 0.995 0.9955 0.996 0.9965 0.997 0.9975 0.998 0.9985 0.999 0.9995 1 5 10 15 20Fairness indexkBFARA 0 2000 4000 6000 8000 10000 12000 14000 16000 18000 5000 10000 15000 20000Number of boundary tuplesNumber of transactionsBFABARASA 0 1000 2000 3000 4000 5000 0.25 0.5 0.75Number of boundary tuplesβBFABARASA9

(a) Throughput

(b) Response time

(a) Affected transactions

(b) Blocked transactions

Fig. 6: Overhead of logging read operations.

adds 30% overhead to the response time. This overhead is
inevitable because PIMS relies on the transactions log to
identify AT, and generate the compensating transactions.

5.3.2 Effect of Attack Intensity

In this experiment, we compare the performance of PIMS
and OneIB with ITDB as the attack intensity π increases.
We use k = 10 and ∆ = 100 ms to plot the results using
BFA and BA assignments. Refer to Fig. 7. We observe that
the extent of the damage increases as the attack intensity
increases. In particular, the number of affected transactions
increases as the number of malicious transactions increases.
This is intuitive because increasing the number of malicious
transactions increases the number of affected transactions
with the same inter-transaction dependency. However, the
average time to recover the damage remains constant as
in Fig. 7(c). Observe that the number of affected transac-
tions and the average recovery time for PIMS 10 BFA and
PIMS 10 BA are less than OneIB and ITDB. The reason is
that PIMS employs the delayed access mechanism that takes
a proactive approach to block the incoming transactions that
can potentially spread the damage. However, the disadvan-
tage of the delayed access mechanism is the increase in
the number of blocked transactions and average response
time as in Fig. 7(b) and 7(d). PIMS BFA has less response
time as compared to PIMS BA because BFA generates lower
number of boundary tuples. Notice that the delayed access
mechanism is not active in the case of OneIB and ITDB
because there are no boundary tuples, and thus the response
time is lower than PIMS.

Notice that, in general, increasing the number of af-
fected transactions increases the number of compensating
transactions to be performed. Consequently, the average
recovery time increases. Similarly, increasing the number of
blocked transactions increases the average response time.
Even though OneIB and ITDB almost have the same num-
ber of affected transactions with the same attack intensity,
OneIB encounters less recovery time as compared to ITDB.
The reason is that ITDB needs multiple passes on the trans-
actions logs to ﬁnd AT [5], while OneIB needs a single pass
because it temporarily blocks transactions. However, the
overhead of blocking incoming transactions is an increase
in the number of blocked transactions and response time in
OneIB as compared to ITDB.

We note that

the proposed response and recovery
methodology, i.e., PIMS, reduces the number of affected
transactions by at least 33% as compared to ITDB. Con-
sequently, the average recovery time is reduced by 50%,

(c) Average recovery time

(d) Average response time

Fig. 7: Effect of π with ∆ = 100 ms and λ = 10.

Fig. 8: Throughput of PIMS and OneIB for different values
of (π) with ∆ = 100 ms and λ = 10.

i.e., 150 ms in PIMS 10 BFA as compared to 300 ms in
ITDB with 750 malicious transactions. The downside is that
PIMS incurs a larger number of blocked transactions due
to blocking the transactions that request to read boundary
tuples. The increase in the response time is around 60% as
compared to ITDB. Nevertheless, the average response time
for PIMS does not exceed 50 ms when the attack intensity is
15%. Fig. 8 gives the throughput of PIMS and OneIB as the
attack intensity increases for ∆ = 100 ms and λ = 10. We
note that PIMS and OneIB match the transaction arrival rate
λ, and thus does not incur any overhead on the throughput.

5.3.3 The Effect of The Number of IBs

In this experiment, we evaluate the performance of PIMS
with various values of k, i.e., 1, 5, 10, 15, and 20. We compare
the results of PIMS BFA and PIMS BA with oneIB. More-
over, we study the performance of PIMS RA and PIMS SA
to demonstrate the effectiveness of the proposed heuristics.
Fig. 9 gives the performance of PIMS with ∆ = 100 ms,
λ = 10, and π = 10%, i.e., 500 malicious transactions. From
Fig. 9, increasing k improves the performance of PIMS. In
particular, the number of affected transactions is reduced
by at least 5%, 18%, 26%, and 48% using SA, BFA, BA, and
RA, respectively. Consequently, the average recovery time
decreases as k increases. However, PIMS incurs at least 20%,
37%, 50%, and 63% of response time overhead in SA, BFA,
BA, and RA, respectively, as Fig. 9(d) illustrates. The reason
is due to the increase in the number of boundary tuples.

 0 10 20 30 40 5010203040Throughput (Tx/second)λNo loggingPIMS 0 2 4 6 8 1010203040Average response time (ms)λNo loggingAIMS 0 100 200 300 400 5001%5%10%15%Number of affected transactionsπPIMS_10_BFAPIMS_10_BA OneIBITDB 0 200 400 600 800 10001%5%10%15%Number of blocked transactionsπPIMS_10_BFAPIMS_10_BA OneIBITDB 0 50 100 150 200 250 300 350 4001%5%10%15%Average recovery time (ms)πPIMS_10_BFAPIMS_10_BA OneIBITDB 0 5 10 15 20 25 30 35 401%5%10%15%Average response time (ms)πPIMS_10_BFAPIMS_10_BA OneIBITDB 0 2 4 6 8 10 12 141%5%10%15%Throughput (Tx/seconds)πPIMS_10_BFAPIMS_10_BAOneIB ITDB10

(a) Affected transactions

(b) Blocked transactions

(a) Affected transactions

(b) Blocked transactions

(c) Average recovery time

(d) Average response time

(c) Average recovery time

(d) Average response time

Fig. 9: Effect of k with λ = 10, ∆ = 100 ms, and π = 10%
malicious intensity.

Fig. 10: Effect of the delayed access mechanism with ∆ =
100 ms, λ = 10, and π = 10%.

We note that the increase in the response time overhead is
marginal as the value of k increases beyond 10.

Although PIMS BFA has the least reduction in recovery
time as compared to PIMS BA and PIMS RA, PIMS BFA
has the minimum response time overhead. We note that
PIMS SA has less response time than PIMS BFA when k <
10 because the number of boundary tuples generated by SA
is less than BFA as explained in Section 5.2. However, the
response time of PIMS SA increases dramatically for k>10
as the assignment skewness is higher. On the other hand,
PIMS RA outperforms PIMS BFA and PIMS BA in terms
of reducing the number of affected transactions, and thus
the recovery time. PIMS RA incurs the highest overhead
in response time. In conclusion, we note that PIMS BFA
and PIMS BA produce a balanced performance in terms of
recovery and response time as compared to PIMS RA and
PIMS SA over a wide range of k values.

In the next experiment, we study the effect of the delayed
access mechanism on the performance of PIMS. We compare
the performance of PIMS BFA, PIMS BA, PIMS RA, and
PIMS SA with delay and without delay. From Fig. 10(a), the
number of affected transactions is larger when the delayed
access mechanism is off. The reason is that the damage
propagates across the IBs. However, the shortcoming of the
delayed access mechanism is the increase in the response
time overhead as in Fig. 10(d). The reason is the increase
in the number of blocked transactions due to blocking
boundary tuples. The overhead is more noticeable in the
case of PIMS RA as compared to PIMS BFA. In conclusion,
the delayed access mechanism allows to contain the damage
and reduce the recovery time in the case of PIMS BFA and
PIMS BA. Moreover, PIMS with delayed access mechanism
maintains a reasonable response time overhead, and thus
improves the overall availability.

6 RELATED WORK
Security measures in DBMSs includes the protection of
data conﬁdentiality, integrity, and availability [3], [22]. A
broad span of research addresses the protection of data
conﬁdentiality in DBMSs including authorization, e.g., [23],
access control, e.g., [24], encryption, e.g., [25], and infer-
ence and disclosure control, e.g., [26]. The integrity risk
data in DBMSs is jointly prevented by using access control
mechanisms and semantic integrity constraints to verify
the correctness of the database state after updates [3]. The
availability of data is protected by providing fault-tolerance
[27], replication [28], and intrusion detection techniques [29].
In the case of successful intrusion attacks, the effects of
the committed transactions are undesirable. The methodol-
ogy of undoing a committed transaction can be generally
handled by one of two approaches: rollback or compen-
sation. The rollback approach is achieved by rolling back
all desirable and undesirable activities to a point that is
free from damage [10]. On the other hand, compensation
approach unwinds the effect of selective committed trans-
actions by executing special compensating transactions. The
compensation operations are either action-oriented or effect-
oriented [11]. In this paper, we follow an effect-oriented
compensation approach to recover from the damage caused
by the malicious and affected transactions.

Several solutions have been proposed for intrusion re-
covery in database-backed applications. A generic intrusion-
tolerant architecture for web-servers uses redundancy and
diversiﬁcation principles proposed in [30]. In [31], WARP
is proposed to recover from intrusions in web-applications
by rolling back the database and replaying subsequent
legitimate actions to correct the state of the DBMS. In [32],
an intrusion recovery tool for database-backed applications
running in Platform-as-a-Service clouds is proposed. The
tool uses machine learning techniques to associate the ap-
plication requests to the DBMS statements, and then uses
existing recovery algorithms to recover from the damage

 0 50 100 150 200 250 300 1 5 10 15 20Number of affected transactionskPIMS_BFAPIMS_BAPIMS_RAPIMS_SA 0 200 400 600 800 1000 1 5 10 15 20Number of all blocked transactionskPIMS_BFAPIMS_BAPIMS_RAPIMS_SA 0 50 100 150 200 1 5 10 15 20Average recovery time (ms)kPIMS_BFAPIMS_BAPIMS_RAPIMS_SA 0 10 20 30 40 50 60 1 5 10 15 20Average response time (ms)kPIMS_BFAPIMS_BAPIMS_RAPIMS_SA 0 50 100 150 200 250 300 350 4005101520Number of affected transactionskPIMS_BFAPIMS_BAPIMS_RAPIMS_SAPIMS_BFA no delayPIMS_BA no delayPIMS_RA no delayPIMS_SA no delay 0 200 400 600 800 1000 12005101520Number of all blocked transactionskPIMS_BFAPIMS_BAPIMS_RAPIMS_SAPIMS_BFA no delayPIMS_BA no delayPIMS_RA no delayPIMS_SA no delay 0 50 100 150 200 2505101520Average recovery timekPIMS_BFAPIMS_BAPIMS_RAPIMS_SAPIMS_BFA no delayPIMS_BA no delayPIMS_RA no delayPIMS_SA no delay 0 10 20 30 40 50 605101520Average response timekPIMS_BFAPIMS_BAPIMS_RAPIMS_SAPIMS_BFA no delayPIMS_BA no delayPIMS_RA no delayPIMS_SA no delayin the DBMS. PIMS is designed as a middle-layer between
the DBMS and the application that performs automatic in-
trusion response and recovery in the DBMS independently
from the running applications.

Previous work in intrusion recovery in DBMSs can be
broadly classiﬁed into two categories: transaction-level and
data-level approaches. In the transaction-level approach, the
general direction is to selectively rollback or compensate for
the damaged tuples. In [5], a suite of recovery algorithms
is proposed to unwind the effect of malicious transactions
for ofﬂine and online recovery. In [6], [21], the authors
present ITDB and DTQR, respectively, that implement the
recovery algorithms in [5] on top of a Commercial-Off-
The-Shelf DBMS. In [33], a damage assessment and repair
system, termed Phoenix, is introduced. The core component
in Phoenix is the inter-transaction dependency tracking
that maintains such persistent dependency information at
run-time. On the other hand, data-dependency approach
provides a ﬂexible recovery at the object-level. In [12], a
damage assessment technique using data dependency anal-
ysis is proposed to obtain precise information about the set
of corrupted data. PIMS uses a hybrid approach between
data-level dependency and transaction-level approach to
track the damage. In particular, the damage assessment
is performed at the data-level, while the response and
recovery procedures are performed at the transaction-level.
Moreover, PIMS addresses the problem of prolonged online
recovery procedure in [5].

Date partitioning schemes are used to improve the avail-
ability and scalability of the DBMS. In [34], a workload-
aware approach for partitioning the data is proposed. The
partitioning approach models the data objects as a graph
that is then partitioned into k balanced partitions such that
the number of distributed transactions is minimized. In
[35], a scalable workload-aware data placement that uses
hyper-graph compression techniques to deal with large-
scale datasets is proposed. Online partitioning techniques
adaptively partition data based on emerging hotspots,
workload skews, and load spikes. In [36], a methodology
for using automatic data partitioning that prefers partitions
with independent transactions is proposed. In [37], E-store is
proposed that provides an elastic planning and reconﬁgura-
tion system to mitigate the challenges paired with workload
skews. None of the above partitioning scheme considers
the security aspects of DBMS. The IB demarcation scheme
partitions the workload with the objective to improve the
availability by conﬁning the damage caused by intrusion
attacks.

7 CONCLUSION
In this paper, the problem of response and recovery of
successful intrusion attacks on a DBMS is addressed. We
propose PIMS, a data partitioning-based intrusion manage-
ment system for DBMSs, that can endure intense malicious
intrusion attacks. A new ﬁne-grained dependency model
that captures the intra-transaction and inter-transaction de-
pendencies is introduced. We introduce a data partitioning
scheme, termed IBs, with the objective to limit the extent
of the damage into partitions. We formulate the IB demar-
cation problem as a cost-driven optimization problem and

11

prove that IBDP is NP-hard, and propose efﬁcient heuristic
solutions. We present the architecture of PIMS and conduct
various experiments to evaluate its performance. We show
that although PIMS incurs response time overhead, the
reduction in the number of affected transactions and the
recovery time is up to 48% and 52%, respectively.

ACKNOWLEDGMENT
This work is supported by Northrop Grumman.

REFERENCES

[1] CL Philip Chen and Chun-Yang Zhang. Data-intensive applica-
tions, challenges, techniques and technologies: A survey on big
data. Information Sciences, 275:314–347, 2014.

[2] Gary Stoneburner, Alice Y Goguen, and Alexis Feringa. Risk
management guide for information technology systems. NIST
Report, 2002.

[3] Elisa Bertino and Ravi Sandhu. Database security-concepts, ap-
IEEE Trans. on Dep. and Sec. Comp.,

proaches, and challenges.
2(1):2–19, 2005.

[4] Ashish Kamra and Elisa Bertino. Design and implementation of
an intrusion response system for relational databases. IEEE Trans.
on Knowl. and Data Eng., 23(6):875–888, 2011.

[5] Paul Ammann, Sushil Jajodia, and Peng Liu. Recovery from
IEEE Trans. on Knowl. and Data Eng.,

malicious transactions.
14(5):1167–1185, 2002.

[6] Peng Liu, Jiwu Jing, Pramote Luenam, Ying Wang, Lunquan Li,
and Supawadee Ingsriswang. The design and implementation of
Journal of Intelligent Information
a self-healing database system.
Systems, 23(3):247–269, 2004.

[7] Bilal Shebaro, Asmaa Sallam, Ashish Kamra, and Elisa Bertino.
In Proc. of the 16th EDBT,

Postgresql anomalous query detector.
pages 741–744. ACM, 2013.

[8] Philip A Bernstein, Vassos Hadzilacos, and Nathan Goodman.
Concurrency control and recovery in database systems. 1987.
Satish M Srinivasan and Raghvinder S Sangwan. Web app secu-
rity: A comparison and categorization of testing frameworks. IEEE
Software, 34(1):99–102, 2017.

[9]

[10] C Mohan, Hamid Pirahesh, and Raymond Lorie. Efﬁcient and
ﬂexible methods for transient versioning of records to avoid locking by
read-only transactions, volume 21. ACM, 1992.

[11] Henry F Korth, Eliezer Levy, and Abraham Silberschatz. A formal
approach to recovery by compensating transactions. University of
Texas at Austin, Department of Computer Sciences, 1990.

[12] Brajendra Panda and Kazi Asharful Haque. Extended data depen-
dency approach: a robust way of rebuilding database. In Proc. of
the 2002 ACM symp. on Applied comp., pages 446–452. ACM, 2002.
[13] Kristy Browder and M Davidson. The virtual private database in

oracle9ir2. Oracle Tech. White Paper, Oracle Corporation, 500, 2002.

[14] Art Rask, Don Rubin, and Bill Neumann. Implementing row-and
cell-level security in classiﬁed databases using sql server 2005. MS
SQL Server Technical Center, 2005.

[15] Transaction Performance Coundeling. Tpc-c benchmark (revision

5.9.0). June 2007.

[16] Mohammad Alomari, Michael Cahill, Alan Fekete, and Uwe
Rohm. The cost of serializability on platforms that use snapshot
isolation. In 2008 IEEE 24th ICDE, pages 576–585. IEEE, 2008.
[17] Brian F Cooper, Adam Silberstein, Erwin Tam, Raghu Ramakrish-
nan, and Russell Sears. Benchmarking cloud serving systems with
ycsb. In Proc. of the 1st ACM symposium on Cloud computing, pages
143–154. ACM, 2010.

[18] Djellel Eddine Difallah, Andrew Pavlo, Carlo Curino, and Philippe
Cudre-Mauroux. Oltp-bench: An extensible testbed for bench-
Proc. of the VLDB Endowment,
marking relational databases.
7(4):277–288, 2013.

[19] Paul Erdos and Alfr´ed R´enyi. On the evolution of random graphs.

Publ. Math. Inst. Hung. Acad. Sci, 5(1):17–60, 1960.

[20] Raj Jain, Arjan Durresi, and Gojko Babic. Throughput fairness
index: An explanation. Technical report, Dep. of CIS, The Ohio
State University, 1999.

[21] Kun Bai and Peng Liu. A data damage tracking quarantine and
recovery (dtqr) scheme for mission-critical database systems. In
Proc. of the 12th EDBT, pages 720–731. ACM, 2009.

12

[22] G Stonebumer NIST, A Goguen, and A Fringa. Risk management
guide for information technology systems. Recommendations of the
National Institute of Standards and Technology, 2002.

[23] Surajit Chaudhuri, Tanmoy Dutta, and S Sudarshan. Fine grained
authorization through predicated grants. In 2007 IEEE 24th ICDE,
pages 1174–1183. IEEE, 2007.

[24] Ravi Sandhu, Edward Coyne, Hal Feinstein, and Charles Youman.
Role-based access control models. Computer, 29(2):38–47, 1996.
[25] Muhammad I Sarfraz, Mohamed Nabeel, Jianneng Cao, and Elisa
Bertino. Dbmask: ﬁne-grained access control on encrypted rela-
In Proc. of the 5th ACM Conference on Data and
tional databases.
Application Security and Privacy, pages 1–11. ACM, 2015.

[26] Yu Chen and Wesley W Chu. Protection of database security
In Intelligence and Security

via collaborative inference detection.
Informatics, pages 275–303. Springer, 2008.

[27] I. Gashi, P. Popov, and L. Strigini. Fault tolerance via diversity for
IEEE
off-the-shelf products: A study with sql database servers.
Trans. on Dep. and Sec. Comp., 4(4):280–294, Oct 2007.

[28] Marta Pati ˜no-Martinez, Ricardo Jim´enez-Peris, Bettina Kemme,
and Gustavo Alonso. Middle-r: Consistent database replication at
the middleware level. ACM Trans on Comp. Sys. (TOCS), 23(4):375–
423, 2005.

[29] Aleksandar Milenkoski, Marco Vieira, Samuel Kounev, Alberto
Avritzer, and Bryan D Payne. Evaluating computer intrusion
detection systems: A survey of common practices. ACM Computing
Surveys (CSUR), 48(1):12, 2015.

[30] Ayda Saidane, Vincent Nicomette, and Yves Deswarte. The design
of a generic intrusion-tolerant architecture for web servers. IEEE
Trans. on Dep. and Sec. Comp., 6(1):45–58, 2009.

[31] Ramesh Chandra, Taesoo Kim, Meelap Shah, Neha Narula, and
Nickolai Zeldovich. Intrusion recovery for database-backed web
In Proc. of the Twenty-Third ACM Symposium on
applications.
Operating Systems Principles, pages 101–114. ACM, 2011.

[32] David R Matos Miguel L Pardal and Miguel Correia. Rectify:
In Proc. of the 18th

Black-box intrusion recovery in paas clouds.
International Middleware Conference. ACM, 2017.

[33] Tzi-cker Chiueh and Shweta Bajpai. Accurate and efﬁcient inter-
transaction dependency tracking. In 2008 IEEE 24th ICDE, pages
1209–1218. IEEE, 2008.

[34] Carlo Curino, Evan Jones, Yang Zhang, and Sam Madden. Schism:
a workload-driven approach to database replication and partition-
ing. Proc. of the VLDB Endowment, 3(1-2):48–57, 2010.

[35] Abdul Quamar, K Ashwin Kumar, and Amol Deshpande. Sword:
scalable workload-aware data placement for transactional work-
In Proc. of the 16th International Conference on Extending
loads.
Database Technology, pages 430–441. ACM, 2013.

[36] Alexandru Turcu, Roberto Palmieri, Binoy Ravindran, and Sachin
Hirve. Automated data partitioning for highly scalable and
strongly consistent transactions. IEEE Trans. on Par. and Dist. Sys.,
27(1):106–118, 2016.

[37] Rebecca Taft, Essam Mansour, Marco Seraﬁni, Jennie Duggan,
Aaron J Elmore, Ashraf Aboulnaga, Andrew Pavlo, and Michael
Stonebraker. E-store: Fine-grained elastic partitioning for dis-
tributed transaction processing systems. Proc. of the VLDB En-
dowment, 8(3):245–256, 2014.

