Coding Schemes for Securing Cyber-Physical Systems Against
Stealthy Data Injection Attacks

Fei Miao, Student Member, IEEE, Quanyan Zhu, Member, IEEE, Miroslav Pajic, Member, IEEE, and
George J. Pappas, Fellow, IEEE.

1

6
1
0
2

y
a
M
9
2

]

R
C
.
s
c
[

1
v
2
6
9
8
0
.
5
0
6
1
:
v
i
X
r
a

Abstract— This paper considers a method of coding the sensor
outputs in order to detect stealthy false data injection attacks.
An intelligent attacker can design a sequence of data injection to
sensors and actuators that pass the state estimator and statistical
fault detector, based on knowledge of the system parameters.
To stay undetected, the injected data should increase the state
estimation errors while keep the estimation residues small. We
employ a coding matrix to change the original sensor outputs to
increase the estimation residues under intelligent data injection
attacks. This is a low cost method compared with encryption
schemes over all sensor measurements in communication net-
works. We show the conditions of a feasible coding matrix under
the assumption that the attacker does not have knowledge of the
exact coding matrix. An algorithm is developed to compute a
feasible coding matrix, and, we show that in general, multiple
feasible coding matrices exist. To defend against attackers who
estimates the coding matrix via sensor and actuator measure-
ments, time-varying coding matrices are designed according to
the detection requirements. A heuristic algorithm to decide the
time length of updating a coding matrix is then proposed.

I. INTRODUCTION

Cyber-physical systems (CPSs) integrate computation and
communications to interact with physical processes. Many
applications are considered as CPSs, including high conﬁdence
medical devices, energy conservation, environmental control,
and safety critical infrastructures–such as water supply sys-
tems, electric power, and communication systems [2]. There-
fore, security is a critical aspect of these systems, and CPSs
involve additional challenges in control layer. The problem
of secure control is deﬁned, and reasons for mechanisms of
information security, sensor network security alone are not
sufﬁcient for the security of CPSs are analyzed [3]. The key
challenges of CPSs securities are summarized in [4].

Novel attack-detection algorithms in cyber security area can
be designed, by understanding how attacks affect state estima-
tion and control of the system. Two algorithms to maximize the

This material is based on research sponsored by DARPA under agreement
number FA8750-12-2-0247. The U.S. Government is authorized to reproduce
and distribute reprints for Governmental purposes notwithstanding any copy-
right notation thereon. The views and conclusions contained herein are those
of the authors and should not be interpreted as necessarily representing the
ofﬁcial policies or endorsements, either expressed or implied, of DARPA or
the U.S. Government. Part of he results in this work appeared at the 53rd
Conference on Decision and Control, Los Angeles, CA, USA, December
2014 [1].

F. Miao and G. J. Pappas are with the Department of Electrical
and Systems Engineering, University of Pennsylvania, Philadelphia,
PA, USA 19014. Q. Zhu is with the Department of Electrical and
Computer Engineering, New York University, Brooklyn, NY, USA 11201.
M. Pajic is with the Department of Electrical and Computer Engineering,
Duke University, Durham, NC, USA 27708. Email: {miaofei,
pappasg}@seas.upenn.edu,{quanyan.zhu}@nyu.edu,
{miroslav.pajic}@duke.edu

utility of encrypted devices placed to increase system security
are proposed to reduce the cost of communication cost in
power grids [5]. Tools are developed to protect state-estimation
components from stealthy attacks from an intelligent attacker
with a partial model of the system [6].

Researchers have explored fault detection,

isolation and
reconﬁguration (FDIR) methods to ensure systems’ safety and
robustness [7]. Although active techniques have been designed
to tackle various types of attacks, fundamental limitations
still exist [8]. With a limited number of sensor and actu-
ator compromised by the attacker,
i.e., some elements of
the injection vector is restricted to be zero, resilient state
estimators have been designed by previous work. Fawzi et al.
propose estimation and control schemes of noise free linear
systems [9]. Pajic et al. present a robust state estimation
method in presence of attacks to no more than half of the
sensors for systems with noise and modeling errors [10].
In contrast, we examine a different case where the attacker
can inject an arbitrary vector to the communication between
sensors and the estimator/detector/controller component, thus
no element of the injection vector is constrained to be zero.

The monitoring system can detect malicious behaviors in
general. Coding and decoding schemes to estimate the state
of a scalar stable stochastic linear system with noisy mea-
surements are designed in [11]. A distributed methodology for
detecting and isolating multiple sensor faults in interconnected
CPS is proposed in [12]. A class of false data injection attacks
against state estimators in power grid is analyzed in [13]. Se-
quential detection techniques of sensor networks are discussed
in [14]. Miao et al. design stochastic game approaches for
replay attacks detections [15] and secure control of CPSs [16].
However, with knowledge of the system model, an intelli-
gent cyber attacker is able to carefully design a data injection
sequence, such that the state estimation error increases without
triggering the alarm of the monitor [17], [18]. Manandhar et al.
design the Euclidean detector to overcome the limitation of χ2
detector for fault detection in smart grid [19]. However, the de-
sign of Euclidean detector is based on the voltage signal model
of smart grid and whether it works for a general linear system
model has not been shown yet. In this work, we consider the
detection problem of false data injection attacks for a general
linear system model. To address the computational overhead
of encryptions on embedded architectures [20], we propose an
alternative low cost method to code the sensor measurements
for detection. With the coding scheme, no additional detector
is required for the system to detect stealthy data injected by
an attacker with the knowledge of system model. Compared
with error-correcting coding schemes [21], the sensor outputs

 
 
 
 
 
 
2

coding approaches proposed in this work aim to change the
value transmitted over the communication channel instead of
correcting errors on bit level. Moreover, the coding scheme
proposed in this work does not require additional bits for
each plaintext message of the sensor measurements, while
an encryption method introduces communication overhead
for each sensor message transmitted in the communication
channel [22]. We assume that the coding matrix is distributed
between sensors and the estimator/detector of the system
correctly like an secret encryption key [23], and measurement
of individual sensor is not corrupted before coded. With
the coding matrix, the values sent over the communication
channel are changed, without additional bits for encryption
overhead [21], and the scheme is low-cost compared with the
scheme of encrypting all sensor outputs.

The contributions of this work are summarized as follows:
1) The main contribution of this work is a low cost method
of coding sensor outputs to detect stealthy false data
injection attacks. We show that the system can detect the
original stealthy sensor injections by coding the sensor
outputs according to certain conditions.

2) We also design an algorithm to compute such coding
matrices, and show that in general, multiple feasible
coding matrices exist.

3) When the attacker can estimate the coding scheme
according to several measurements of sensor and ac-
tuator values, we show that it is difﬁcult to get the
exact coding matrix in general. Moreover, in this case,
the system can either change a new coding matrix or
randomly use a set of coding matrices within a time
length before the attacker has enough measurements for
a good estimation. We design a heuristic algorithm to
decide the time length of updating a coding matrix.
The paper is organized as follows. In Section II we describe
the system and attack models. The conditions that a feasible
coding matrix should satisfy are presented in Section III. An
algorithm to ﬁnd a feasible coding matrix based on rotation
matrix is developed in Section IV. A time-varying coding
scheme is designed in Section V. Section VI shows illustrative
examples. Conclusions are given in Section VII.

II. SYSTEM AND ATTACK MODEL

We will introduce a discrete-time linear time-invariant (LTI)
system model, a data injection attack model, and the attacked
system model in this section. The system architecture is shown
in Figure 1.

Figure 1. System diagram, where the system is equipped with an estimator,
a detector and a controller. The attacker can inject arbitrary false data vector
k to sensor outputs and ua
ya
k to actuator inputs.

A. Linear system model

Assume that the CPS is composed of a discrete time LTI

system with the following form:

xk+1 = Axk + Buk + wk,

yk = Cxk + vk,

(1)

Rm is the
Rn is the system state vector, uk ∈
where xk ∈
Rp is the sensor observations at time k.
control input, and yk ∈
We do not have speciﬁc restrictions for the linear control input
uk here, since the choice of a linear controller does not affect
the detection of false data injection, and we will explain the
reason later. We assume that wk ∼
N (0, R)
are identical independent (i.i.d.) Gaussian noises.

N (0, Q) and vk ∼
The optimal Kalman ﬁlter used to estimate state ˆxk
k = APkAT + Q,
1,

1 = Θ, Pk+1
|

k is:
|

|−

1 = 0, P0
ˆx0
|−
kC T (CPk+1
Kk+1 = Pk+1
|
|
Pk+1 = (I
Kk+1C)Pk+1
zk+1 = yk+1 −
k = Aˆxk + Buk,
ˆxk+1
|

−

C(Aˆxk + Buk),

kC T + R)−
k,
|

ˆxk+1 = ˆxk+1
|

k + Kkzk+1.

Under the assumption that (A, B) is stabilizable, (A, C) is
detectable, we get a steady state Kalman ﬁlter, with the error
covariance matrix P and Kalman gain matrix K:

P (cid:44) lim
k
→∞

Pk

1, K (cid:44) P C T (CP C T + R)−
−

k
|

1.

∼

k P −

Without attacks, the estimation residue zk follows a Gaus-
(0, CP C T +R). Deﬁne the quantities gk
sian distribution N
as gk = zT
1zk, where P is the error covariance matrix of
Kalman ﬁlter, then gk satisﬁes a χ2 distribution with p degrees
of freedom. A χ2 failure detector considers the standardized
2 zk for a monitoring system, and
residue sequence ηk = P −
assumes that there exists a δη such that limk
δη.
We denote α as the threshold for detecting a fault, meaning
that the alarm is triggered when gk > α.

Eηk(cid:107) ≤

→∞ (cid:107)

1

B. False data injection attack model

The system model under sensor data injection attack is

described as (2)

x(cid:48)k+1 = Ax(cid:48)k + B(u(cid:48)k + ua

k) + wk,

y(cid:48)k = Cx(cid:48)k + ya

k + vk,

(2)

k ∈

Rp, ua

Rm are arbitrary vectors injected
where ya
k ∈
to sensor outputs, actuator inputs by the attacker at time k
respectively. When ua
k = 0, only sensor values are changed
by the attacker. Assume the adversary has knowledge of the
system model described in Section II-A, and is able to inject
data over communication network between sensors and the
estimator/detector/controller.

Without attack, according to the system dynamics and the

deﬁnition of Kalman ﬁlter, the estimation error is

ek (cid:44) xk −
ek+1 = (A

ˆxk,

−

KCA)ek −
KCA) is stable and Ewk = Evk = 0,
When matrix (A
the expectation of estimation error converges to 0 with a
0. Meanwhile, the
static Kalman ﬁlter, i.e., limk

Kvk + (I

KC)wk.

E[ek]

−

−

→∞

→

EstimatorDetector Controller ukuk-1...yk=Cxk+vkXk+1=Axk+Buk+wkLTIS1S2Spa1amAttackerchange ykto yk'yk/yk'Attacker...yaky'k=Cxk+yak+vka2uakuk/uk'residual zk stays in the subspace that does not trigger the alarm
with a high probability.

To illustrate how the sensor injection sequence ya

k will affect
the estimation and monitoring system, we examine how the
estimation error and residue will change with ya
k. Denote the
estimation residuals of attacked system as

z(cid:48)k = y(cid:48)k+1 −

C(Aˆx(cid:48)k + Bu(cid:48)k),

where ˆx(cid:48)k is the state estimation of the compromised system.
Similarly, we deﬁne the estimation error under attack as
(cid:44) x(cid:48)k −

ˆx(cid:48)k,

e(cid:48)k

The probability that the sensor injection sequence ya
0, 1, . . . is detectable is given by

k, k =

P r(g(cid:48)k = (z(cid:48)k)T P −

1z(cid:48)k > α for any k).

The difference between the normal and the compromised

systems can be captured by:

∆ek (cid:44) e(cid:48)k −

ek, ∆zk (cid:44) z(cid:48)k −

zk.

(3)

The dynamics of the above difference vectors satisfy
KCA)∆ek −

∆ek+1 = (A
∆zk+1 = CA∆ek + ya

Kya
k + CBua
k,

k+1 + (B

−

−

KCB)ua
k,

(4)

Hence the difference vectors between normal and compro-
mised systems, ∆zk(ya, ua), ∆ek(ya, ua), are functions of the
injection sequences ya (cid:44) (ya
0 , ya
1, . . . ). To
simplify the notations, we concisely denote these vectors as
∆zk, ∆ek, respectively.

1 , . . . ), ua (cid:44) (ua

0, ua

The objectives of the attacker include increasing the esti-
mation error e(cid:48)k without triggering the alarm, and destabilizing
the system with inﬁnite state estimation error e(cid:48)k in the long
run. Note that these types of attacks on control systems have
been illustrated in the recent years. For instance, the estimated
trajectories of Unmanned Ground Vehicle (UGV) [10] and Un-
manned Aerial Vehicle (UAV) navigation systems [18] under
stealthy data injection attacks (e.g., by GPS spooﬁng) deviate
from the actual trajectories of the autonomous vehicles before
being detected. Thus the attacker’s objective is equivalent to
increasing
∆ek(cid:107)2 (the difference between estimation error
(cid:107)
of the normal and compromised systems) to inﬁnity without
∆zk(cid:107)2 much as time goes by. Since computing the
increasing
detecting statistic of compromised system g(cid:48)k is to integrate a
Gaussian distribution on an ellipsoid, the stealthy requirement
can be approximated by keeping
z(cid:48)k(cid:107)2 small. Residues of the
normal system zk are bounded, and the attacker should keep
the change of residues bounded make the injection stealthy. It
means the following inequality should hold

(cid:107)

(cid:107)

M,

∆zk(cid:107)2 ≤
(cid:107)
where M is a residue norm change threshold designed by
the attacker. The compromised estimation residue should be
close to that of the normal system, to deceive the monitoring
system. 1 When ya
k can be an arbitrary vector, a necessary and

(5)

1The relation between the scale or norm of the injection sequence and the

alarm trigger threshold α is shown in Theorem 1 in [18].

3

sufﬁcient condition for a stealthy injection ya
k that can increase
∆zk(cid:107)2 bounded
z(cid:48)k(cid:107)2,
x(cid:48)k(cid:107)2 to inﬁnity while keep
e(cid:48)k(cid:107)2,
(cid:107)
(cid:107)
(cid:107)
span(I), i.e.,
is derived in [18], [17]. The condition that Cv
∈
there exists y∗ satisfying y∗ = Cv is always satisﬁed by the
attack model (2). Hence, we have the following proposition.

(cid:107)

Proposition 1. There exists a stealthy sequence ya
k, k =
0, 1, . . . , given the attacked system model (2), if and only if
matrix A has an unstable eigenvalue λ and the corresponding
span(Qoa), where Qoa is the
eigenvector v, such that v
KCA, K).
controllability matrix associated with the pair (A

∈

−

III. CODING SENSOR OUTPUTS FOR DETECTING STEALTH
SENSOR DATA INJECTION

Existing statistical detectors, active monitor schemes (design
some additive control input ud
k) and fault detection ﬁlters
have limitations, that even actuators are not compromised,
they cannot detect stealthy sensor data injection attacks. It
is necessary to design some inexpensive techniques to com-
pensate for the vulnerability of the system under intelligent
sensor data injection attacks. It has been shown that by only
compromising sensors, attackers can induce inﬁnite estimation
error without being detected under monitoring systems like a
χ2 detector [18]. Therefore, we ﬁrst discuss the case of stealthy
sensor false data injection attacks in this section.

A. Limitations of existing approaches

The limitation of active monitor approach: Under the
assumption that actuators work appropriately for the attacked
system (2), the challenge here is whether adding ud
k to the
pre-designed linear control input uk (such as optimal LQG
control) can help to detect stealthy sensor data injections. For
instance, consider a new control input

˜uk = uk + ud
k,

(6)

where ud
k is some random authentication signal or a constant
value. It is worth noting that active monitor approaches do
not help for detecting sensor data injection attacks described
in model (2) .

Lemma 1. There exists no active monitor in the form (6) that
can increase the detection probability of a stealthy sensor data
injection sequence, for the system (1) equipped with a Kalmen
Filter and a χ2 detector.

Proof: We denote the difference between estimation
residual and estimation error of the normal and compromised
system for the system with the controller (6) as ∆˜zk+1
and ∆˜ek+1, respectively. By the deﬁnition of ∆˜zk+1 and
∆˜ek+1 and a similarly calculation process to get (4), we have
∆˜ek = ∆ek, and ∆˜zk+1 = CA∆˜ek + ya
k. Any
additional control input ud
k will be eliminated by the deduction
of ˜zk+1 and ˜z(cid:48)k+1 to get ∆zk+1. The active control input does
not increase the norm of ∆˜zk+1 compared with ∆zk+1, which
means there exists no linear form of ˜uk as described above
that can increase

k+1 + CBua

k for the system (2).

∆zk+1(cid:107)2 under ya
(cid:107)

4

The limitations of active monitors for a uniﬁed LTI model
are explained in Theorem 4.7 of [8] 2. From this perspective,
different linear controllers are equivalent under stealth sensor
data injection attacks, and we do not restrict the controller
model for designing our detection techniques.

The limitation of fault detection ﬁlter: Besides Kalman ﬁl-
ter, observer-based fault detection ﬁlters for LTI systems with
unknown error have been developed. The design requirements
usually include robustness to unknown inputs and sensitivity
to faults. Such ﬁlters generate a different residue from zk
of Kalman ﬁlter. Consider the following form of residual
generator and residual evaluator (including a threshold and
a decision logic unit, see [25] for details) [25]:

ˆyk),

ˆyk = C ˆxk,
Rn and ˆyk ∈

ˆxk+1 = Aˆxk + Buk + H(yk −
ˆyk),
rk = V (yk −
Rp represent the state and output
where ˆxk ∈
estimation vectors, respectively, and rk is the residual signal.
This fault detector shares the same limitation with Kalman
ﬁlter, i.e., the intelligent sensor data injection attack is stealth
for the ﬁlter described as (7), since the residue is still observer
based difference between yk and ˆyk.

(7)

B. Coding sensor outputs to detect stealth data injection

∆zk(cid:107)2 ≤
(cid:107)

Since existing monitoring systems cannot detect intelligent
false data injection attacks, and encryption method has a con-
straint of signiﬁcant computation overhead, we propose a de-
sign of coding the sensor outputs to detect stealth sensor data
injection attacks. An intelligent attacker designs the sequence
ya
M ,
k carefully to keep the change of residue
where M is a constant. Thus, the objective of a detecting
∆zk(cid:107)2 as fast as possible
approach is equivalent to increasing
(cid:107)
under a stealthy data injection sequence, and
∆zk(cid:107)2 should
(cid:107)
increase to inﬁnity as time goes to inﬁnity.
The necessary and sufﬁcient conditions for stealth false
sensor data injection in Corollary 1 assume that
the at-
tacker knows (A, B, C, K). Parameters A and B are related
to physical dynamics that may not be altered, while C is
related to the sensor measurements, corresponding speciﬁc
physical states. Without changing the physical setup, we still
can manipulate the sensor outputs. To violate the attacker’s
design, we consider the method of transforming sensor outputs
as shown in Figure 2–instead of sending the output vector
yk = Cxk + vk to the estimator/controller/detector, sensors
transmit the value

Yk = Σ(Cxk + vk), C

Rp

n,

×

∈

(8)

2A different case when adding exogenous Gaussian distribution control

input can detect replay attacks is discussed in [24].

Rp

×

∈

p is an invertible matrix. We assume that the
where Σ
measurement of individual sensor is not corrupted yet before
coding, and injection sequence appears in the communication
between sensors to the estimator/controller/detector. One can
think of Σ as an inexpensive code, and compare Σ with an
encryption key. By encrypting only the coding matrix channel
once, the coding approach saves encryption cost compared
with encrypting all sensor outputs for every time k.

We assume that the attacker does not know the matrix Σ
at least before estimating the matrix based on knowledge of
matrices (A, B, C, K) and sensor and actuator values, since
the coding matrix Σ is not ﬁxed by the physical model of
the system and can be time-varying, calculated in polynomial
time when a new coding matrix is needed (an algorithm will
be proposed in the next section). We assume that the attacker
cannot access the coding matrix directly if he/she only applies
eavesdropping techniques to the unencrypted communication
channel and the process of distributing Σ is protected. We
will propose a time-varying coding scheme later in this work.
When the attacker has designed a sequence of stealthy attack
signal ya
k for the original system without the knowledge of the
coding matrix Σ, the false sensor value after coding changes
to:

Y (cid:48)k = ΣCxk + ya

k + Σvk.

(9)

Since Σ is an invertible matrix, when the state estimator

receives Yk or Y (cid:48)k, the encoded packet is decoded as

˜y(cid:48)k = Σ−

1Y (cid:48)k = yk + Σ−

1ya
k,

(10)

→ ∞

And we still use the same Kalman ﬁlter and χ2 detector on
the decoded sensor outputs. Similar as the deﬁnitions of ∆ek
and ∆zk (4) for sensor outputs before coding, we deﬁne ∆e(cid:48)k
and ∆z(cid:48)k as the change of state estimation and residue for
coded sensor outputs without attack (8) and under attack (9),
respectively. With Σ, a stealth data injection designed for (1)
(with parameters (A, B, C, K)),
∆z(cid:48)k(cid:107)2 increases to inﬁnity
(cid:107)
as k
under certain conditions. In the following theorem,
we show the sufﬁcient conditions that Σ should satisfy for any
stealth sequence of ya
k, k = 0, 1, . . . that satisﬁes Theorem 1.
Theorem 1. Given an attacked system model (2), assume
that (A, C) is detectable, ua
k = 0, and the attacker designs
a sequence of sensor data injection ya
k, k = 0, 1, . . . , based
span(Qoa), where Qoa is the
on one unstable eigenvector v
controllability matrix associated with the pair (A
KCA, K).
If there exists an invertible matrix Σ, and the direction of ΣCv
is not the same with that of Cv, i.e.,

−

∈

(Cv)(cid:48)ΣCv
Cv
ΣCv
(cid:107)
then after injecting ya
k the estimation residue change satisﬁes
, by coding sensor outputs (8) with Σ.
∆z(cid:48)k(cid:107)2 → ∞
limk

→∞ (cid:107)

(cid:107)2 (cid:54)

(cid:107)2(cid:107)

= 1,

(11)

Figure 2. System diagram when coding sensor outputs with a matrix Σ that
satisﬁes the conditions of Theorem 1. The attacker can inject arbitrary false
data vector ya

k to sensor outputs.

Proof: Given a system under data injection attacks as (2),
we assume that the system has one unstable eigenvector v
with corresponding eigenvalue λ. According to the deﬁnition
in equation (3), the dynamics of ∆ek, ∆zk satisfy (4) with

Encoderua
k = 0. For coded sensor outputs (9), after decoding
k+1,

KΣ−

1ya

∆e(cid:48)k+1 = (A
∆z(cid:48)k+1 = CA∆e(cid:48)k + Σ−

KCA)∆e(cid:48)k −
1ya
k+1,

−

(12)

M1.

ck =

(cid:107)
→ ∞

sequence ya

∞
(cid:15)1k(cid:107)2 ≤

, any stealthy injection

The proof of Theorem 1 in [18] shows that under a stealthy
sensor data injection sequence, the only component of ∆ek
that goes to inﬁnity eventually depends on the unstable eigen-
vector, denoted as ckv, limk
, and ∆ek can be
→∞
decomposed as ∆ek = ckv + (cid:15)1k,
To keep ∆zk bounded as k
k must satisfy
ckλCv + (cid:15)2k,

M2, k = 0, 1, 2, . . . ,
(cid:15)2k(cid:107)2 ≤
where M2 is a constant such that
∆zk(cid:107)2 ≤
(cid:107)

We assume that the attacker does not know Σ, and designs
an injection sequence for the original system (1) as described
in (13). Similarly as ∆ek, the only component of ∆e(cid:48)k that
can goes to inﬁnity is ckv, since matrix A is not changed by
the coding matrix Σ. However, with any ya
k in (13), ∆z(cid:48)k can
be decomposed as

M for all k.

ya
k+1 =

(13)

−

(cid:107)

∆z(cid:48)k = ckλ(Cv

−

Σ−

1Cv) + (cid:15)3k, k = 0, 1, 2, . . . ,

(14)

−

Cv

.
→ ∞

where (cid:15)3k is a bounded vector components of ∆z(cid:48)k. When
Σ satisﬁes equation (11), ΣCv
,
= 0. With ck → ∞
as k
∆z(cid:48)k(cid:107) → ∞
(cid:107)
We call a matrix Σ that satisﬁes the conditions of Theo-
rem 1 a feasible coding matrix. Theorem 1 shows that even
the attacker knows system parameters (A, B, C, K), without
changing the physical structure or altering A, B, we can
utilize the sensor data to get different residues for detecting.
Leveraging sensor outputs is the key reason to detect a
stealth sensor data injection. It is worth noting that here we
do not constrain speciﬁc structure of the matrix Σ besides
conditions in Theorem 1. For an LTI system, ΣC is simply a
linear transform of the original sensor measurement. When A
has several unstable eigenvectors satisfying Corollary 1, the
following lemma extends the result of Theorem 1.

−

Lemma 2. Given an attacked system (2) with (A, C) de-
tectable and a set of unstable eigenvectors v1, . . . , vu ∈
span(Qoa), where Qoa is the controllability matrix associated
KCA, K), if Σ is an invertible matrix, and
with the pair (A

(cid:107)

(15)

= 1,

(cid:107)2(cid:107)

(cid:107)2 (cid:54)

(C ˜v)(cid:48)ΣC ˜v
C ˜v
ΣC ˜v
for any linear combinations of v1, . . . , vu – ˜v, then Σ is a
feasible coding matrix to increase
∆z(cid:48)k(cid:107)2 for any stealth data
(cid:107)
injection to attacked system (2).
Proof: When matrix A has a set of unstable eigenvectors
v1, . . . , vu with corresponding eigenvalues λ1, . . . , λu, similar
as the proof of Theorem 1, a stealthy injection sequence takes
the form

u
(cid:88)

ya
k =

cikλiCvi + (cid:15)2k,

(cid:15)2k(cid:107)2 ≤
(cid:107)
and the change of residual is deﬁned as

i=1

∆z(cid:48)k =

u
(cid:88)

i=1

cikλi(Cvi −

Σ−

1Cvi) + (cid:15)3k,

M2, k = 0, 1, 2, . . . ,

u
(cid:88)

= C(

i=1

cikλivi)

−

u
(cid:88)

Σ−

1C(

i=1

5

cikλivi), k = 0, 1, 2, . . . .

Hence, we consider ˜v = (cid:80)u

i=1 cikλivi as a linear combi-
nation of all the unstable eigenvectors, the conclusion holds
with the coding matrix Σ satisfying all the constraints.

Remark 1. When the attacker is able to learn Σ by analyzing
sensor outputs and actuator inputs, the system can send a new
Σ before the attacker ﬁgures out the current applied coding
matrix. The process of learning Σ from the perspective of an
attacker will be discussed in Section V.

C. When sensor and actuator packets are both injected

We will derive the condition for a feasible coding matrix
when the attacker can mount deception attacks to both sensor
packets and actuator packets.

k, ua

k), k = 0, 1, . . . , that ua

k, then after injecting (ya

Theorem 2. Given an attacked system model (2), assume that
the attacker designs a sequence of stealthy sensor and actuator
data injection (ya
k is bounded and
drives the estimation error to inﬁnity limk
.
∆ek(cid:107)2 → ∞
→∞ (cid:107)
1ya
If there exists an invertible matrix Σ such that ya
= 0
k (cid:54)
k −
for any ya
k) the estimation residue
change satisﬁes limk
, by coding sensor
outputs (8) with Σ.

k, ua
∆z(cid:48)k(cid:107)2 → ∞
Proof: The dynamics of change of estimation error, resid-
uals between the normal and compromised system is described
as (4), where ya
k, ua
k is the injected sequence to sensor and
actuator packets, respectively. Since
M for all
k+1, ua
k = 0, 1, . . . , any pair of (ya

∆zk+1(cid:107)2 ≤
(cid:107)
k) must satisfy

→∞ (cid:107)

Σ−

CBua

ya
k+1 =

−

k + (cid:15)k,

CA∆ek −
For bounded ua
k,
that
ya
.
∆ek(cid:107)2 → ∞
limk
k(cid:107)2 → ∞
When coded sensor values are injected as (9), and the estimator
decodes the value as

the injection sequence satisﬁes

to make sure limk

(cid:15)k(cid:107)2 ≤

→∞ (cid:107)

→∞ (cid:107)

M.

(16)

(cid:107)

˜y(cid:48)k = Σ−

1Y (cid:48)k = Cxk + vk + Σ−

1ya
k,

the coded system with the original design of Kalman ﬁlter is
k+1, ua
equivalent to be injected by a sequence of pair (Σ−
k).
It is worth noting that the actuator data is not coded, and ua
k
keeps the same for both the original and coded system. The
dynamics of the change of estimation error, residuals between
the normal and compromised coded system are as following

1ya

∆e(cid:48)k+1 = (A
∆z(cid:48)k+1 = CA∆e(cid:48)k + Σ−

KCA)∆e(cid:48)k −
1ya

1ya
KΣ−
k+1 + (B
k+1 + CBua
k.

−

KCB)ua
k,

−

Without loss of generality, we assume that ∆e0 = 0, then

∆ek =

∆e(cid:48)k =

k
(cid:88)

j=1

k
(cid:88)

j=1

KCA)k

j(

−

(A

−

Kya

j + (B

−

KCB)ua
j
−

1),

−

(A

−

KCA)k

j(

−

KΣ−

−

1ya

j + (B

KCB)ua
j
−

1).

−

(cid:54)
6

Plug in the expression of ∆e(cid:48)k in the equation of ∆z(cid:48)k+1, with
CBua
CA∆ek + (cid:15)k, we have

k =

−

ya
k+1 −
k
(cid:88)

j=1

+ (B
−
k
(cid:88)

j=1
1
+ (Σ−

=CA

∆z(cid:48)k+1 =CA

(A

KCA)k

−

KΣ−

1ya
j

j(

−

−

KCB)ua
j
−

1) + Σ−

1ya

k+1 + CBua
k

(17)

(A

KCA)k

jK(I

−

Σ−

1)ya
j

−

−

I)ya

k+1 + (cid:15)k.

Hence, for Σ
limk

→∞ (cid:107)

−
= I,
∆z(cid:48)k(cid:107)2 → ∞

ya
limk
k+1(cid:107)2 → ∞
for ∆z(cid:48)k deﬁned in (17).

→∞ (cid:107)

, we have

IV. ALGORITHM TO COMPUTE A CODING MATRIX

In this section we propose an algorithm to compute a set of
feasible coding matrices for the case there exists a sequence
of sensor data injections to cause unbounded state estimation
error, i.e., the system has unstable eigenvectors of A.

−

1C ˜v

→ ∞
C ˜v
−
(cid:107)

∆z(cid:48)k(cid:107)2 as k
(cid:107)
1Cv
(cid:107)2 or
Σ−

, which is equivalent
Σ−

The coded sensor values should increase the difference
between estimation residue of the normal and attacked sys-
to keep
tem –
(cid:107)2 for multiple unsta-
Cv
(cid:107)
ble eigenvectors nonzero, by the proof of Theorem 1 and
Lemma 2. The system satisﬁes that (A, C) is detectable, then
with an invertible coding matrix Σ and the decoded sensor
value ˜y(cid:48)k deﬁned in (10), ˜y(cid:48)k = yk when ya
k = 0. Hence, the
state estimator still converges to the true state without attacks
and the coding scheme does not sacriﬁce the performance of
state estimator.

For multiple unstable eigenvectors, when we do not know
the exact linear combination result of ˜v applied by the attacker
to design the injection sequence, we can not guarantee that Σ
works for the exact injected sequence ya
k by ﬁnding a feasible
coding matrix with respect to a speciﬁc vector v. According to
Theorem 1 and Lemma 2, the coding matrix should work for
any possible injection sequence ya
k designed based on unstable
eigenvectors of the system matrix A. Hence, we consider to
ﬁnd a coding matrix based on the concept of a rotation matrix
without speciﬁc knowledge about the value of injected data to
sensors.

n rotation matrix, with
Deﬁnition 1. A Givens rotation is a n
1’s on the diagonal, 0’s elsewhere, except the intersections of
the ith and jth rows and columns corresponding to a rotation
in the (i, j) plane in n dimensions. It takes the following form

×

∈

The product G(i, j, θ)x represents a counterclockwise rota-
Rp in the i, j plane of θ radians. Hence,
tion of the vector x
only the i-th and j-th elements of x will be changed. Given
system model (1), there are multiple ways to choose a rotation
matrix as a coding matrix in general. If a rotation matrix can
guarantee that the direction of any possible stealthy injection
is changed, it must rotate all nonzero elements in the vector
space

span(Cv1, . . . , Cvu)

(19)

The following algorithm provides a design process of a

rotation matrix given system matrix A.

≤

< pl ≤

p1 < p2 · · ·

Algorithm 1 : Compute a feasible coding matrix Σ
Input: System model parameters A, C, unstable eigenvalues
and eigenvectors λi, vi, i = 1, . . . , u of A.
Rp for all unsta-
Initialization: Calculate vectors Cvi ∈
ble eigenvectors i = 1, . . . , u. Construct the standard basis
Rp for the vector space deﬁned
(ep1 , ep2, . . . , epl ), epj ∈
as (19), where 1
p, and epj is a vector
with the pj-th element as 1 and all the other elements as 0.
Deﬁne rotation step as r = 1, uncovered unstable dimension
set as S =
Iteration: When S
If more than two elements are left in the set S: randomly
2 ], rotation dimension
picking up a rotation radian θ
;
S, let S = S
pi, pj}
pi, pj ∈
Else: randomly picking a rotation radian θ
form distribution, rotation dimension pi ∈
.
and pj (cid:54)
pi}
Get the rotation matrix Gr = G(pi, pj, θ) as deﬁned in (18).
Let r = r + 1.
Return: A feasible transform matrix Σ = G1G2 . . . Gr.

.
p1, p2, . . . , pl}
{
= φ

2 ] with uni-
1, . . . , p
}

(0, π
∈
S, pj ∈ {

= pi, let S = S

(0, π

\ {

\ {

∈

The existence condition of a feasible coding matrix designed
as a rotation matrix is then explained in the following lemma.

Lemma 3. When the dimension of matrix C of the system (1)
satisﬁes that p
2, there always exists a feasible givens
rotation matrix Σ that satisﬁes the condition of Theorem 1
or Lemma 2 for the system.

≥

Proof: According to the deﬁnition of a Givens matrix (18)
and the process of calculating a feasible rotation matrix, when
2, we apply Algorithm 1. Since every rotation has an
p
≥
2 ] and there are no two rotations in the same
angle θ
plane, vector ΣCv is not in the same direction with Cv. Hence,
Algorithm 1 provides a feasible rotation matrix.

(0, π

∈

· · ·
. . .

· · ·

· · ·


1
...



0


...



0


...


0

0
...
c
...
s
...
0

· · ·

0
...

s
· · · −
...
. . .
c
...
0

· · ·

· · ·



0
...



0


...



0


...


1

· · ·

· · ·

· · ·
. . .

· · ·

,

(18)

The coding scheme proposed in this work is a low cost
approach from computation perspective. Speciﬁcally, the pro-
posed coding scheme requires only O(n3 +p3) multiplications
and additions, where n and p denote the number of plant
states and sensors respectively. As we clarify now in the new
version of the manuscript (in Section IV), this is signiﬁcantly
lower than the computation cost for even basic encryption and
coding schemes that involve computation of highly complex
non-linear primitives [26], [20], [21].

The coding scheme proposed in this work is also a low
cost approach from communication perspective. The coding

G(i, j, θ) =

· · ·
where c = cos θ, s = sin θ.

(cid:54)
(cid:54)
scheme proposed in this work does not require additional bits
for each plaintext message of the sensor measurements, while
an encryption method introduces communication overhead
for each sensor message transmitted in the communication
channel [22]. The sensor outputs coding approaches proposed
in this work aim to change the value transmitted over the
communication channel instead of correcting errors on bit level
compared with error-correcting additional coding bits [21].
Hence, the communication overhead of the proposed scheme
in this work is relatively low.

Remark 2. The rotation matrix Σ calculated by Algorithm 1 is
a sparse matrix in general, since a rotation matrix has many 0
elements, and Algorithm 1 is a polynomial heuristic algorithm.
This means the coding process is computationally efﬁcient.

For systems with structural constraints,

two potential
schemes can be considered. One is that the structure of Σ
is also limited and we design a coding matrix Σ with an addi-
tional constraint that some components Σ must be 0 because of
the sparsity of the sensors the system equipped with. Another
scheme is distributed coding that multiple coding matrices are
applied for the whole system. This is a revenue for future
work.

V. TIME-VARYING CODING SCHEME WHEN THE
ATTACKER ESTIMATES THE CODING MATRIX

The coding scheme in this work is effective for the cases that
sensor values are not manipulated by the attacker before they
are coded by matrix Σ. We also assume that the attacker does
not know when the system starts to apply Σ for transforming
sensor output values, and aims to inject a stealthy sequence
ya
k to the sensor communication channel with respect to the
original system. If the attacker is powerful enough to update
the system model and acquire the knowledge of the coding
design after some time steps, the system should constantly
apply a time-varying coding scheme, and the time length for
updating the coding matrix depends on the learning ability of
the attacker and detecting requirements of the system.

Each time the system updates the coding matrix, it will
cost the attacker some time to ﬁgure out the transformed
sensor outputs values. Since it is sufﬁciently fast to compute
a feasible transform based on the algorithm, the system can
even generate new coding matrices during the running process.
Before the attacker learns Σ or the coded observer parameter
ΣC, the false data injection sequence is not stealthy for the
coded system. We assume that the attacker cannot directly
acquire the coding matrix during its communication process,
similar as the secrecy requirement of a key for encryption
the sensors and
sensor nodes [22], [23]. We assume that
controller are synchronized, which is a standard assumption
in safety-critical control systems. Thus, with the same notion
of time, both sensors and the controller can use the same
random generator to (re)generate the coding matrix or exploit
some of the existing schemes for secret key distribution. In
addition,
they will be able to synchronously switch from
using one matrix to the newly created/obtained ones. Various
protocols of key distributions have been proposed according
to the properties of the systems [22], [27].

7

A. The time length an attacker needs to learn Σ

To learn the matrix Σ that distributed secured between
sensors and the controller/estimator/detector, we assume that
the attacker is able to eavesdrop the sensor outputs and actuator
inputs via the communication channel for estimating Σ, instead
of directly capturing the matrix Σ. Since ya
k is designed by
the attacker, the sensor information received by the attacker is
then the true sensor measurements under the coding scheme
Yk = Σyk. System dynamics from the perspective of an
attacker are

xk =Akx0 +

1
k
(cid:88)
−

j=0

Ak

j
−

1(Buj + wj),

−

Yk = ˜CAkx0 +

k
1
(cid:88)
−

j=0

˜CAk

−

j

−

1(Buj + wj) + ya

k + vk,

(20)

×

∈

Rp

where ˜C = ΣC. When the attacker does not have any
p,
knowledge about the structure of the coding matrix Σ
there are p2 variables for estimating Σ. Meanwhile, in general
initial state x0 can only be acquired via estimation, and there
are n variables additionally in (20). Without loss of generality,
we initialize k = 0 as the time that attacker starts to observe
the system’s sensor outputs and actuator inputs to update the
knowledge of the system coding scheme. It is worth noting that
for designing a sequence of stealthy injection data, the attacker
needs to know the model of the system, including the estimator
and statistics detector, while the values of sensor outputs or
actuator inputs are not necessary for the attacker. When the
attacker starts to record sensor and actuator communicational
packets at an arbitrary time k,
the corresponding system
state x0 can not be directly retrieved by the attacker. Hence,
Σ

Rn are variables to be estimated.

∈
We examine a simpler case to estimate the the coding matrix
ﬁrst—how many steps of sensor values the attacker need to
measure for the following noise-free LTI system

p and x0 ∈

Rp

×

xk+1 =Axk + Buk,

¯yk = Cxk.

(21)

The sensor outputs coded by Σ at time k are

¯Yk = ˜CAkx0 +

1
k
(cid:88)
−

j=0

˜CAk

j
−

1Buj,

−

¯Yk ∈

Rp.

(22)

We deﬁne the attacker’s observation YΣ,N during time k =
0, 1, . . . , N when the system applies Σ, and the corresponding
noise-free measurements ¯YΣ,N as

YΣ,N = (cid:2)Y0|

Y1| · · · |

YN

(cid:3) ,

¯YΣ,N = (cid:2) ¯Y0|

¯Y1|

. . .

(cid:3) .

¯YN
|

The observed sensor values from the perspective of the attacker
are bilinear equations with respect to Σ and x0. Consider the
noise-free dynamics of sensor measurements as the following

¯YΣ,N = ΣC

(cid:104)

x0

· · ·

AN x0 + (cid:80)N

1
j=0 AN
−

j

1Buj

−

−

(cid:105)

,
(23)

where [ ¯Y1, . . . , ¯YN ],
[u0, . . . , uN ] is eavesdropped by the
attacker and (A, B, C) is within the knowledge space of the
attacker. To write the above equation as a standard form of

8

bilinear equations regarding to vectors, we denote the coding
matrix Σ as

Σ =






Σ11 Σ12
...
...
Σp1 Σp2

· · ·
. . .




 =

Σ1p
...
Σpp






σ1
...
σp




 ,

×

×

×

∈





Rp

p, i

Rp(N +1) (d

}
(N +1) (YΣ,N )

is the i-th row of matrix Σ.
(N +1) as

· · ·
R1
where σi ∈
1, . . . , p
∈ {
We also vectorize ¯YΣ,N ∈
Rp
¯d
Rp(N +1))
∈
∈


[ ¯Y0]1
...
[ ¯Y0]p
...
[ ¯YN ]p

¯d1
...



¯dp


...


¯dp(N +1)
]j means the j-the element of a vector, and ¯di ∈
·

R.
where [
Then equation (23) can be written as the following p(N + 1)
equations

vec( ¯YΣ,N ) =

Rp(N +1),

























(24)

=

∈

σiCx0 = [ ¯Y0]i = ¯di,


σi(CAk)x0 + σi

C

k
1
(cid:88)
−

j=0

Ak

j
−

1Buj

−


 = [ ¯Yk]i = ¯dpk+i,

In particular, deﬁne coefﬁcient matrices

T0 = C, Tk = CAk, S0 = 0, Sk = C

(25)

1
k
(cid:88)
−

j=0

Ak

−

j

1Buj,

−

for k = 1, . . . , N . For the case of a noise-free system, the
attacker is possible to solve the bilinear problem (25) only
after observing enough time steps of ¯Yk.

Remark 3. By the property of bilinear equations [28], the
1 measurements
attacker needs at least N
of sensor and actuator values to calculate the exact coding
matrix Σ and true initial state x0 when there is no noise.

max
{

} −

n, p

≥

With noises in practical, we have

σiCx0 + [v0]i = [Y0]i = di,



σi(CAk)x0 + σi

C

Ak

−

j

−

1(Buj + wj)

 + [vk]i



k
1
(cid:88)
−

j=0

=[Yk]i = dpk+i,

i = 1, . . . , p, k = 1, . . . , N,

(26)

where [Yk]i and di are deﬁned similar as [ ¯Yk]i an ¯di
in
vectorization (24). Under the assumption that both wk, vk are
i.i.d. Gaussian noise, for any k, their expectations satisfy



E

σi(C

k
1
(cid:88)
−

j=0



Ak

−

j

1wj) + [vk]i
−

 = 0.

Then the noise-free and noisy sensor values satisfy that
EYΣ,N = ¯YΣ,N .

Hence, when the attacker observes noisy sensor outputs
YΣ,N , the objective of retrieving the coding matrix Σ without
the knowledge of x0 is equivalent to ﬁnding σ1, . . . , σp, x0

that ﬁt for the noise-free equation set (25). With even Gaussian
noise, it becomes difﬁcult to numerically ﬁnd an exact solution
of the true coding matrix, and the problem is then to minimize
the total error between the left and right sides of the equations.
The problem of estimating Σ, x0 is described as Problem 1.

Problem 1. The problem of estimating Σ, x0 in the minimum
mean square error perspective is deﬁned as the following
bilinear programming problem

minimize
σ1,...,σp,x0

N
(cid:88)

p
(cid:88)

(cid:107)

k=0

i=1

subject to

rank(Σ =

σiTkx0 + σiSk −




dpk+i(cid:107)2

(27)




σ1
...
σp


) = p.

When there exists an invertible matrix Σ that satisﬁes the
equations deﬁned in (26),
the above bilinear optimization
problem (27) has an optimal cost 0. However, the optimal
solution Σ∗ does not need to be the true coding matrix Σ,
since there is noise and the objective function of problem (27)
does not include noise of each time step.

The rank constraint of problem (27) is non-convex, and in
practice the attacker does not know how many measurements
return the best estimation before calculating Σ∗ given all ex-
isting measurements. Hence, we design the following heuristic
algorithm for the attacker, which ignores the rank constraint
ﬁrst, and checks whether Σ is full rank every step till a feasible
solution is reached.

Algorithm 2 Algorithm of estimating Σ for the attacker
Inputs: System’s parameter (A, B, C), design of Kalman
Filter K, the threshold α of χ2 detector, algorithm stopping
condition–estimation error (cid:15).
Initialization: Initialize the value of estimation error Er > (cid:15),
and the estimation of coding matrix ˆΣ as a n identical matrix.
While Er > (cid:15) or ˆΣ = I.
1). Read one new sensor and actuator observation, and update
parameters of problem (27);
2). Solve problem (27). If the optimal solutions σ∗1, . . . , σ∗p
satisfy the full rank constraints, let Er be the value of the
optimal cost, and ˆΣ = Σ∗ = (cid:2)(σ∗1)T . . . (σ∗p)T (cid:3)T
Return: Estimation result of ˆΣ.

.

Remark 4. It is worth noting that a bilinear equation usually
has multiple solutions, and Algorithm 2 returns different
optimal solutions ˆΣ under different sensor and actuator mea-
surements time N . Under this situation, it is not clear for
the attacker to decide how many time steps to measure and
which optimal solution to choose, even when the optimal cost
of problem (27) is 0. Even for a simple two dimensional
system A, multiple solutions exist and do not converge to one
estimation after 20 steps of measurements, which we will show
in simulation.

To summarize,

there are two main challenges for the
the ﬁrst one
attacker to estimate the true coding matrix,
is because multiple solutions exist for bilinear equations or

bilinear optimization problems. The second one comes from
the noise in the communication channel, that even the attacker
ﬁnd a feasible solution to the bilinear equation set (26), it is
only an unbiased estimation instead of the true coding matrix.

B. When the estimated ˆΣ

= Σ

k, where ya

After the attacker estimates a coding scheme ˆΣ and con-
siders it as the true coding matrix the system is applying, the
easiest way to keep stealthy is to inject ˆΣya
k is a
stealthy data injection designed for the original system without
coding. However, as discussed above, when there exists noise,
the attacker is not able to calculate the exact coding matrix the
system is applying. When ˆΣ
= Σ, the injection sequence ˆΣya
k
can only extend the time length before detected and cannot
pass the detector. Then the system needs to evaluate how long
the attacker needs to measure the sensor outputs and how
long the attacker can stay stealthy by applying a new injection
sequence, in order to decide the time length of changing the
coding matrix.

Deﬁnition 2. An estimated coding matrix ˆΣ calculated by the
attacker is called a feasible estimation of Σ that keeps the
attacker stealthy for time k = 0, . . . , T while causing e error,
if and only if for all sequence of injections ˆΣya
k designed by
the attacker according to the estimated coding matrix ˆΣ, the
dynamics of ∆e(cid:48)k, ∆z(cid:48)k satisfy that

9

time increasing proportion for an estimated ˆΣ(N ) calculated
after measuring time N as

α(NΣ) =

Ts( ˆΣ(N )ya
k)
−
Ts(ya
k)

Ts(ya
k)

,

(30)

where ˆΣ(N ) is estimated from N steps measurements of
sensor and actuator values. As we will show in Section VI,
α(NΣ) increases with an increasing NΣ for a ﬁxed Σ in
general. When the attacker is able to estimate the coding
matrix and inject ( ˆΣ(N )ya
k) to stay stealthy for a longer time,
the system needs to apply a new coding matrix before the
attacker has enough measurements to estimate an ˆΣ(N ) that
reaches the threshold ˜α(NΣ) of the increasing time proportion
α(NΣ). From the perspective of the system, a heuristic way to
decide the time length NΣ of changing Σ is as Algorithm 3.

Algorithm 3 Heuristic Algorithm for choosing NΣ
Inputs:Coded system’s parameter (A, B, C, K, Σ), χ2 detec-
tor threshold α, time step ts for increasing NΣ, threshold
proportion ˜α(NΣ).
Initialization:Initialize the value of ˆΣ as an identical matrix,
let NΣ = 0, calculate α(NΣ)
While α(NΣ) < ˜α(NΣ)
1). Estimate ˆΣ with ts steps of new sensor and actuator values,
and update α(NΣ).
2). Let NΣ = NΣ + ts, and save sensor and actuator values
for next iteration.
Return: Measurement time length NΣ for estimating Σ.

−

KCA)∆ek −
1 ˆΣya

∆e(cid:48)k+1 = (A
∆z(cid:48)k+1 = CA∆ek + Σ−
∆ek(cid:107)2 ≥

max
k=1,...,T (cid:107)

e, max

k=1,...,T (cid:107)

k+1,

KΣ−

1 ˆΣya

k+1,

∆zk(cid:107)2 ≤

(28)

M,

VI. ILLUSTRATIVE EXAMPLES

where Σ is the true coding matrix the system is applying.

A. Coding scheme detect stealthy data injection

Deﬁne the time length of keeping stealthy with injection

sequence ya

k, k = 1, . . . , Ts, for a system (1) as

Ts(ya

k) = inf
k {

k :

∆zk(ya
k)

(cid:107)2 > M

.

}

(cid:107)

(29)

k) > Ts(ya

The attacker increases the time length of keeping stealthy
when Ts( ˆΣya
k). However, the attacker does not have
a guarantee about Ts( ˆΣya
k) without the knowledge of the true
coding matrix, since ∆zk( ˆΣya
k) is affected by both Σ and ˆΣ.
There exists a trade-off between the time N the attacker takes
to measure sensor and actuator values to estimate a better
ˆΣ and the time the attacker starts to apply a new injection
sequence ˆΣya
k. If the measuring time N is large, it is possible
that the system already triggers the alarm before the attacker
successfully recovers the coding scheme. If the attacker does
not have enough measurements for a good estimation and then
applies the estimated ˆΣ to design a new injection sequence
ˆΣya
k) will not be much larger than Ts(ya
k) and the
malicious behavior will still be detected quickly by the system.
It is worth noting that the system can not decide whether
Σ is easy to be estimated by the attacker by only checking
(cid:107)2, k = 1, . . . , Ts( ˆΣya
∆zk(ya
∆zk(ya
(cid:107)2 stays in
k). When
k)
k)
(cid:107)
(cid:107)
a small range for a long time and Ts( ˆΣya
k) is large, the reason
may be the original injection sequence ya
k also has a large
time length of keeping stealthy Ts(ya
k). Deﬁne the stealthy

k, Ts( ˆΣya

We show the effects of coding sensor outputs by examples
of two-dimensional LTI systems. Consider a detectable 2-
dimensional linear system with parameters:

A =

(cid:20)0.8
0.5

(cid:21)

0
1

, B =

(cid:21)

(cid:20) 1
0.5

, C =

(cid:20)2
0

(cid:21)

0.5
1

, D = 0,

(cid:21)

≥

−

−

ya
0 , k

(cid:20)1
2

0.5
1

and Σ2 =

(cid:21)
1
−
0

where A has an unstable eigenvalue λ = 1 and eigenvector v =
0 = [0.0588 0.0588]T ,
[0 1]T . One stealth attack sequence is: ya
ya
2. Multiple
1 = [0.1286
2 −
solutions of feasible coding matrices that satisfy Theorem 1
exist in general. For instance, for the above system, Σ1 =
(cid:20) 2

0.9706]T , yk = ya
k
−

are both feasible.
∆zk(cid:107)2,
(cid:107)

0.5
−
Figure 3 shows the comparison result of

∆z(cid:48)k(cid:107)2
(cid:107)
when there is injection attacks for the original and coded
∆z(cid:48)k(cid:107)2 increases with time k after coded by
systems, and
(cid:107)
Σ1, while without coding
Figure 4
∆zk(cid:107)2 is bounded.
(cid:107)
shows that for the sensor outputs transformed by Σ2, ∆z(cid:48)k
increases with time k, while the original system ∆zk stays
inside a bounded range. For the transformed sensor outputs,
the change of the estimation error ∆e(cid:48)k increases even slower
than ∆ek under data injection attack as shown in Figure 5.
By comparing the change of estimation error ∆ek and ∆e(cid:48)k,
we show that estimation error of a coded system does not
necessarily increase faster than the original system.

(cid:54)
(cid:54)
10

B. When the attacker tries to estimate the coding matrix

0.5
0.5 0.7

−

In this example,

the system applies the coding matrix
designed based on Algorithm 1, a scaled rotation matrix
4 in the (1, 2) plane
2
. When the attacker estimates Σ according

4 ) with a rotation radian θ = π

G(1, 2, π
(cid:20) 0.7

∗
Σ =

(cid:21)

to N = 20 steps of sensor and actuator measurements via
Algorithm 2, the estimated result is ˆΣ and the attacker designs
a new injection sequence ˆΣya
(cid:20) 2.80
0.89

k based on ˆΣ
(cid:21)

0.15
−
0.05

ˆΣ =

.

−

k. Assume the threshold for

In Figure 6, we compare the residue change for: the orig-
inal system under injection sequence ya
k, the coded system
under data injection ya
k, and the coded system under injection
sequence ˆΣya
∆zk(cid:107)2 is set as
(cid:107)
M = 2, in Figure 6 we can see that the attack will be detected
after injecting a sequence of data ya
k (designed for the original
system) for 12 seconds to the coded system, i.e., Ts(ya
k) = 12.
In contrast, Ts( ˆΣya
k) = 50 seconds, however, ˆΣ is estimated
via N = 20 seconds of measurements of sensor and actuator
values. Hence, the attacker does not have enough time to get
such ˆΣ before being detected.

C. Number of measurements to estimate the coding matrix

(cid:107)

(cid:107)

Figure 7 shows how the estimation of ˆΣ changes with the
number measurement steps N . In general, when N increases,
the difference between ˆΣ and Σ decreases, and the norm of
∆zk(cid:107)2 increases slower with sensor injection
residue change
sequence ˆΣya
k. However, as shown in Figure 7, for both
∆zk(cid:107)2 are almost the same, hence,
N = 25 and N = 200,
the attacker does not infer a better coding matrix to keep
stealthy with a greater measurement time. Comparing the time
of keeping stealthy with estimated coding matrix, we have
Ts( ˆΣya
k) = 30 for N = 5,
and approximately Ts( ˆΣya
k) = 51 for N (cid:62) 25. From the
perspective of the system, if we set the threshold ˜α(NΣ) = 1.5
in this case, and Ts( ˆΣ(N )ya
k )
12 = 1.5, by
−
−
Ts(ya
k )
the heuristic Algorithm 3, the system can change the coding
matrix every 5 seconds.

k) = 20 for N = 2, Ts( ˆΣya

= 30

Ts(ya
k )

12

Figure 4. Comparison of norm of residue change between the original system
and coded system, ∆zk and ∆z(cid:48)

k, for Σ2 that satisﬁes Theorem 1.

Figure 5.
original system and coded system, ∆ek and ∆e(cid:48)
Theorem 1.

Comparison of norm of estimation error change between the
k, for Σ2 that satisﬁes

Figure 6. Comparison of norm of estimation residue change between the
original system—∆zk, coded system—∆z(cid:48)
k when the system applies Σ and
the attacker injects ya
k designed for the original system, and the sensor data
injection sequence designed with estimated coding matrix— ∆zsk when
the attacker injects ˆΣya
k and the true coding matrix is Σ. When M = 2,
Ts(ya

k ) = 12 seconds, Ts( ˆΣya

k ) = 50 seconds.

VII. CONCLUSION

In this work, we have proposed a method of coding sensor
outputs to detect stealthy data injection attacks that designed
by an intelligent attacker with system model knowledge. We

Figure 3. Comparison of (cid:107)∆zk(cid:107)2 of the original system and (cid:107)∆z(cid:48)
the coded system with Σ1.

k(cid:107)2 of

Figure 7. Comparison of norm of estimation residue change when the attacker
designs a sensor injection sequence according to ˆΣ estimated with different
measurement number N . When attacker injects ˆΣya
k and the system applies
coding, the detection time, i.e., the time (cid:107)∆zsk(cid:107)2 (cid:62) 2 is labeled for different
measurement time N : N = 2, Ts( ˆΣya
k ) = 30. For
N = 25 and N = 200, Ts( ˆΣya

k ) = 20; N = 5, Ts( ˆΣya
k ) are almost the same value: 51.

show the conditions of a feasible coding scheme to detect
a stealthy injection sequence with statistical detectors, and
develop an efﬁcient algorithm to compute such feasible coding
matrices. The sensor coding scheme is valid for the scenarios
where the attacker is capable to estimate the coding matrix
via measuring sensor outputs and actuator inputs. Simulation
examples show that the adaptive injection sequence designed

020406080100010203040Time∥∆zk∥2,|∆z′k∥2Comparisonof∥∆zk∥2and∥∆z′k∥2underattack   the original systemthe coded system02040608010005101520Time∥∆zk∥2,∥∆z′k∥2Comparisonof∥∆zk∥2and∥∆z′k∥2underattack  the original systemthe coded system0204060801000102030Time∥∆ek∥2,∥∆e′k∥2Comparisonof∥∆ek∥2and∥∆e′k∥2underattack  the original system the coded system0204060801000246810  X: 12Y: 2Residue change with estimated coding matrixX: 50Y: 2TimeNorm of residue changeOrigianl systemCoding before attacker’s estimationAttack with estimated coding matrix020406080100048  X: 51Y: 2X: 30Y: 2X: 20Y: 2Time∥∆zsk∥2Comparisonof∥∆zsk∥2fordiﬀerentNN=2N=5N=25N=200based on an estimated coding matrix cannot pass the detector
without knowledge of the coding matrix applied by the system
in general. In the future, we will explore a coding scheme for
a system with structural constraints.

REFERENCES

[1] F. Miao, Q. Zhu, M. Pajic, and G. Pappas, “Coding sensor
outputs for injection attacks detection,” in IEEE 53rd Annual
Conference on Decision and Control (CDC), 2014, pp. 5776–
5781.

[2] K.-D. Kim and P. R. Kumar, “Cyber-physical systems: A
perspective at the centennial,” Proceedings of the IEEE, pp.
1287–1308, 2012.

[3] A. Cardenas, S. Amin, and S. Sastry, “Secure control: Towards
survivable cyber-physical systems,” in 28th International Con-
ference on Distributed Computing Systems Workshops, 2008,
pp. 495–500.

[4] A. Cardenas, S. Amin, B. Sinopoli, A. Giani, A. Perrig, and
S. Sastry, “Challenges for securing cyber physical systems,”
in Workshop on future directions in cyber-physical systems
security, 2009.

[5] G. D´an and H. Sandberg, “Stealth attacks and protection
schemes for state estimators in power systems,” in 2010 First
IEEE International Conference on Smart Grid Communications
(SmartGridComm), 2010, pp. 214–219.

[6] A. Teixeira, S. Amin, H. Sandberg, K. Johansson, and S. Sastry,
“Cyber security analysis of state estimators in electric power
systems,” in 2010 49th IEEE Conference on Decision and
Control (CDC), 2010, pp. 5991–5998.

[7] I. Hwang, S. Kim, Y. Kim, and C. Seah, “A survey of fault
detection, isolation, and reconﬁguration methods,” Control Sys-
tems Technology, IEEE Transactions on, vol. 18, no. 3, pp. 636–
653, 2010.

[8] F. Pasqualetti, F. D¨orﬂer, and F. Bullo, “Attack detection and
identiﬁcation in cyber-physical systems,” IEEE Transactions on
Automatic Control, vol. 58, no. 11, pp. 2715–2729, Nov 2013.
[9] H. Fawzi, P. Tabuada, and S. Diggavi, “Secure estimation and
control for cyber-physical systems under adversarial attacks,”
IEEE Transactions on Automatic Control, vol. 59, no. 6, pp.
1454–1467, 2014.

[10] M. Pajic, J. Weimer, N. Bezzo, P. Tabuada, O. Sokolsky, I. Lee,
and G. Pappas, “Robustness of attack-resilient state estimators,”
in 2014 ACM/IEEE International Conference on Cyber-Physical
Systems (ICCPS), 2014, pp. 163–174.

[11] S. Dey, A. Chiuso, and L. Schenato, “Remote estimation with
noisy measurements subject to packet loss and quantization
noise,” IEEE Transactions on Control of Network Systems,
vol. 1, no. 3, pp. 204–217, Sept 2014.

[12] V. Reppa, M. Polycarpou, and C. Panayiotou, “Distributed
sensor fault diagnosis for a network of interconnected cyber-
physical systems,” IEEE Transactions on Control of Network
Systems, vol. 2, no. 1, pp. 11–23, March 2015.

[13] Y. Liu, P. Ning, and M. K. Reiter, “False data injection attacks
against state estimation in electric power grids,” in Proceedings
of the 16th ACM Conference on Computer and Communications
Security. ACM, 2009, pp. 21–32.

[14] A. Nayyar and D. Teneketzis, “Signaling in sensor networks for
sequential detection,” IEEE Transactions on Control of Network
Systems, vol. 2, no. 1, pp. 36–46, March 2015.

[15] F. Miao, M. Pajic, and G. Pappas, “Stochastic game approach
for replay attack detection,” in IEEE 52nd Annual Conference
on Decision and Control (CDC), Dec 2013, pp. 1854–1859.

[16] F. Miao and Q. Zhu, “A moving-horizon hybrid stochastic game
for secure control of cyber-physical systems,” in IEEE 53rd
Annual Conference on Decision and Control (CDC), Dec 2014,
pp. 517–522.

[17] Y. Mo and B. Sinopoli, “False data injection attacks in control

11

systems,” in First Workshop on Secure Control Systems, CPS
Week, 2010.

[18] W. C.Kwon and I. Hwang, “Security analysis for cyber-physical
systems against stealthy deception attacks,” in Amerian Control
Conference (ACC), June 2013.

[19] K. Manandhar, X. Cao, F. Hu, and Y. Liu, “Detection of faults
and attacks including false data injection attack in smart grid
using kalman ﬁlter,” IEEE Transactions on Control of Network
Systems, vol. 1, no. 4, pp. 370–379, Dec 2014.

[20] P. Ganesan, R. Venugopalan, P. Peddabachagari, A. Dean,
F. Mueller, and M. Sichitiu, “Analyzing and modeling en-
cryption overhead for sensor network nodes,” in 2nd ACM
International Conference on Wireless Sensor Networks and
Applications, 2003, pp. 151–159.

[21] H. Imai and S. Hirakawa, “A new multilevel coding method
using error-correcting codes,” Information Theory, IEEE Trans-
actions on, vol. 23, no. 3, pp. 371–377, May 1977.

[22] U. M. Maurer, “Secret key agreement by public discussion
from common information,” IEEE Transactions on Information
Theory, vol. 39, no. 3, pp. 733–742, May 1993.

[23] H. Chan and A. Perrig, “Security and privacy in sensor net-
works,” Computer, vol. 36, no. 10, pp. 103–105, Oct 2003.
[24] Y. Mo and B. Sinopoli, “Secure control against replay attacks,”
in Communication, Contro, and Computing, 47th Annual Aller-
ton Conference on, 2009, pp. 911–918.

[25] M. Zhong, S. X. Ding, J. Lam, and H. Wang, “An LMI approach
to design robust fault detection ﬁlter for uncertain LTI systems,”
Automatica, vol. 39, no. 3, pp. 543 – 550, 2003.

[26] O. Goldreich, Foundations of Cryptography: Volume 2, Basic
New York, NY, USA: Cambridge University

Applications.
Press, 2004.

[27] R. C. Merkle, “Protocols for public key cryptosystems,” in
Security and Privacy, 1980 IEEE Symposium on, April 1980,
pp. 122–122.

[28] S. Cohen and C. Tomasi, “Systems of bilinear equations,”
Computer Science Department, Stanford University, Tech. Rep.
CS-TR-97-1588, Tech. Rep., 1997.

Fei Miao (S’13)
received the B.Sc. degree in
Automation from Shanghai Jiao Tong University,
Shanghai, China in 2010. Currently, she is work-
ing toward the Ph.D. degree in the Department of
Electrical and Systems Engineering at University of
Pennsylvania. Her research interests include data-
driven real-time control frameworks of large-scale
interconnected cyber-physical systems under model
uncertainties, and resilient control frameworks to
address security issues of cyber-physical systems.
She was a Best Paper Award Finalist at the 6th

ACM/IEEE International Conference on Cyber-Physical Systems in 2015.

12

Quanyan Zhu (S’04-M’12) is an assistant profes-
sor in the Department of Electrical and Computer
Engineering at New York University. He received
the B. Eng. in Honors Electrical Engineering with
distinction from McGill University in 2006,
the
M.A.Sc. from University of Toronto in 2008, and
the Ph.D. from the University of Illinois at Urbana-
Champaign (UIUC) in 2013. From 2013-2014, he
was a postdoctoral research associate at the Depart-
ment of Electrical Engineering, Princeton University.
He is a recipient of many awards including NSERC
Canada Graduate Scholarship (CGS), Mavis Future Faculty Fellowships,
and NSERC Postdoctoral Fellowship (PDF). He spearheaded and chaired
INFOCOM Workshop on Communications and Control on Smart Energy Sys-
tems (CCSES), Midwest Workshop on Control and Game Theory (WCGT),
and 7th Game and Decision Theory for Cyber Security (GameSec). His
current research interests include resilient and secure interdependent critical
infrastructures, energy systems, cyber-physical systems, and smart cities.

Miroslav Pajic (S06-M13) received the Dipl. Ing.
and M.S. degrees in electrical engineering from the
University of Belgrade, Serbia, in 2003 and 2007, re-
spectively, and the M.S. and Ph.D. degrees in electri-
cal engineering from the University of Pennsylvania,
Philadelphia, in 2010 and 2012, respectively. He is
currently an Assistant Professor in the Department
of Electrical and Computer Engineering at Duke
University. He also holds a secondary appointment in
the Computer Science Department. Prior to joining
Duke, Dr. Pajic was a Postdoctoral Researcher in the
PRECISE Center, University of Pennsylvania, from 2012-2015. His research
interests focus on the design and analysis of cyber-physical systems and
in particular real-time and embedded systems, distributed/networked control
systems, and high-conﬁdence medical devices and systems. Dr. Pajic received
various awards including the 2011 ACM SIGBED Frank Anger Memorial
Award, the Joseph and Rosaline Wolf Award for Best Electrical and Systems
Engineering Dissertation from Penn,
the 2014
ACM/IEEE International Conference on Cyber-Physical Systems (ICCPS),
and the Best Student Paper award at the 2012 IEEE Real-Time and Embedded
Technology and Applications Symposium (RTAS).

the Best Paper Award at

George J. Pappas (S’90-M’91-SM’04-F’09) re-
ceived the Ph.D. degree in electrical engineering
and computer sciences from the University of Cal-
ifornia, Berkeley, CA, USA, in 1998. He is cur-
rently the Joseph Moore Professor and Chair of the
Department of Electrical and Systems Engineering,
University of Pennsylvania, Philadelphia, PA, USA.
He also holds a secondary appointment with the
Department of Computer and Information Sciences
and the Department of Mechanical Engineering and
Applied Mechanics. He is a Member of the GRASP
Lab and the PRECISE Center. He had previously served as the Deputy
Dean for Research with the School of Engineering and Applied Science. His
research interests include control theory and, in particular, hybrid systems,
embedded systems, cyber-physical systems, and hierarchical and distributed
control systems, with applications to unmanned aerial vehicles, distributed
robotics, green buildings, and bimolecular networks. Dr. Pappas has received
various awards, such as the Antonio Ruberti Young Researcher Prize, the
George S. Axelby Award, the Hugo Schuck Best Paper Award, the George
H. Heilmeier Award, the National Science Foundation PECASE award and
numerous best student papers awards at ACC, CDC, and ICCPS.

