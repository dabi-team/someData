1
2
0
2

r
p
A
0
2

]

R
C
.
s
c
[

1
v
6
0
8
9
0
.
4
0
1
2
:
v
i
X
r
a

DeepHunter: A Graph Neural Network Based
Approach for Robust Cyber Threat Hunting

Renzheng Wei1,2, Lijun Cai1, Aimin Yu1, and Dan Meng1

1 Institute of Information Engineering, Chinese Academy of Sciences, Beijing, China
2 School of Cyber Security, University of Chinese Academy of Sciences, Beijing,
China
{weirenzheng,cailijun,yuaimin, mengdan}@iie.ac.cn

Abstract. Cyber Threat hunting is a proactive search for known attack
behaviors in the organizational information system. It is an important
component to mitigate advanced persistent threats (APTs). However,
the attack behaviors recorded in provenance data may not be completely
consistent with the known attack behaviors. In this paper, we propose
DeepHunter, a graph neural network (GNN) based graph pattern match-
ing approach that can match provenance data against known attack be-
haviors in a robust way. Speciﬁcally, we design a graph neural network
architecture with two novel networks: attribute embedding networks that
could incorporate Indicators of Compromise (IOCs) information, and
graph embedding networks that could capture the relationships between
IOCs. To evaluate DeepHunter, we choose ﬁve real and synthetic APT
attack scenarios. Results show that DeepHunter can hunt all attack be-
haviors, and the accuracy and robustness of DeepHunter outperform the
state-of-the-art method, Poirot.

Keywords: Cyber Threat Hunting · Robustness · Provenance Analysis
· Graph Neural Network · Graph Pattern Matching.

1

Introduction

Threat hunting is a proactive search for intruders who are lurking undetected
in the organizational information system. A typical task for a threat hunter is
to match system events against known adversarial behavior gained from CTI
(Cyber Threat Intelligence). Threat hunting is increasingly becoming an impor-
tant component to mitigate the Advanced Persistent Threats (APTs), as large
enterprises or organizations seek to stay ahead of the latest cyber threats and
rapidly respond to any potential attacks.

Existing threat hunting tools (e.g., Endpoint Detection and Response tools,
namely EDR) rely on matching low-level Indicators of Compromise (IOCs) or
TTP rules (i.e., adversarial Tactics, Techniques, and Procedures). However, sim-
ple rules matching methods are prone to high volumes of false alarms, which
leads to the “threat alert fatigue” problem. To overcome this problem, recent
works [11, 14, 28] start to focus on the relationship between IOCs or the cor-
relation among threat alerts. One approach [14] to hunt the ransomware takes

 
 
 
 
 
 
2

R. Wei et al.

advantage of the sequential relationship among IOCs, but the mined sequential
patterns typically can not capture long-term attack behaviors.

Recent research suggests that the provenance graph can incorporate the
long-term historical context and facilitate threat investigation. Based on the
provenance graph, many works [11, 28] have made advancements to improve the
performance of threat hunting. For example, RapSheet [11] leverages dependency
relations in the provenance graph to correlate the threat alerts generated by
EDR tools, then drops the alerts that do not conform to the APT “kill chain”.
Poirot [28] improves the accuracy of threat hunting by designing a graph pattern
matching algorithm to search the provenance graph for the query graph that
represents the known attack behavior.

Although the provenance graph can greatly facilitate threat hunting tasks,

there still exist several limitations in the existing approaches:

– Expert knowledge needed. Existing threat hunting tools or methods need
analysts with expert knowledge on known attacks and target systems (e.g.,
Windows, Linux, macOS, etc.). For example, one needs to estimate the num-
ber of entry points of APT attacks when setting Poirot’s threshold.

– Eﬃciency. The size of the provenance graph is very large because of the
presence of long-term attacks. So the provenance graph-based approaches
(i.e., graph matching/searching algorithms) must be eﬃcient.

– Lack of robustness (most important). In practice, real attack activities
recorded in provenance data are not completely consistent with the known
attack behaviors due to auditing/monitoring systems, attack mutations, and
random noise. For example, one or more attack steps in CTIs might disap-
pear in the provenance graph. This sort of inconsistency weakens the ability
of provenance graph-based methods [11, 28, 29] to correlate threat alerts.
Even worse, the attack provenance graphs might be disconnected, which will
bring errors into path-based approaches, i.e., Poirot [28]. We will detail this
scenario in section 3.3.

In recent years, graph neural networks (GNNs) have shown great success
in handling graph data. Inspired by that, our idea is to view the threat hunt-
ing task as a graph pattern matching problem and leverage the powerful GNN
model to estimate the matching score between the provenance graph and the
given query graph. The graph neural networks have several advantages on the
graph pattern matching problem: (1) The graph neural networks naturally excel
at eﬃciency, since modern GPUs can largely accelerate matrix computations by
parallel processing. (2) No additional expert knowledge about attacks and tar-
get systems is needed, as the graph neural network is trained in an end-to-end
manner. What we need is to learn a GNN-based graph pattern matching model
that could extract robust graph patterns that are resistant to the inconsistency
mentioned earlier. Basically, if both the node attributes (i.e., IOC information)
and the graph structures (i.e., dependency relations between IOCs) in the query
graph are largely matched in the provenance graphs, the model should output a
high matching score and raise alarms.

DeepHunter: A GNN-based Approach for Robust Threat Hunting

3

Unfortunately, there is no oﬀ-the-shelf GNN-based architecture that can be
simply applied to solve our problem due to two reasons. First, indicators are
the entity with multiple attributes (i.e., ﬁle names, IP addresses, ports, process
names, etc.). Diﬀerent attributes may have diﬀerent importance to the graph
pattern matching task. Second, the two input graphs for graph pattern match-
ing have diﬀerent characteristics: The query graph is small and noise-free; The
provenance graph is bigger and contains redundant nodes, as the provenance
graph represents low-level system events.

To solve these problems in threat hunting, we propose two novel graph neural
network structures: the attribute embedding network and the graph embedding
networks. The attribute embedding network encodes attributes into vectors. In
particular, we add the attention mechanism to the attribute embedding network.
So it could assign higher weights to those attributes that are important to the
graph matching task. The graph embedding networks are used for represent-
ing graph structures. To better represent distinct input graphs, we employ two
diﬀerent graph embedding networks to encode them, respectively. Speciﬁcally,
we design one graph embedding network to represent the provenance graph and
adopt GCN [19] to represent the query graph. At last, we utilize a powerful
relation learning network (i.e., NTN [41]), instead of the traditional Siamese
network, to learn a metric for computing the matching score. With this new de-
sign practice, we could build the GNN model for graph pattern matching, which
is robust against diﬀerent degrees of inconsistency between the query graph and
the provenance graph in threat hunting.

We implemented our proposed technique as DeepHunter, a GNN-based
graph pattern matching model for threat hunting. To evaluate the accuracy and
robustness of DeepHunter, we choose 5 APT attack scenarios with diﬀerent de-
grees of inconsistency. Particularly, one of these scenarios (Q5) contains discon-
nected attack provenance graphs. Experimental results show that DeepHunter
can identify all of the attack behaviors in 5 APT scenarios, and it is resis-
tant to various degrees of inconsistency and the disconnected attack provenance
graphs. The robustness of DeepHunter outperforms the state-of-the-art APT
threat hunting method, Poirot. Moreover, DeepHunter could ﬁnd attacks that
Poirot can not identify under the speciﬁc complex attack scenario, Q5+ETW.
We also compare DeepHunter with other graph matching approaches, includ-
ing a non-learning approach and GNN-based approaches. Results show that the
performance of DeepHunter is superior to these methods.

In summary, this paper makes the following contributions:

– We propose DeepHunter, which is a GNN-based graph pattern matching
approach for cyber threat hunting. DeepHunter can tolerate the inconsis-
tency between the real attack behaviors recorded in provenance data and
the known attack behaviors to some extent.

– We design a graph neural network architecture with two novel networks: at-
tribute embedding networks and graph embedding networks. These two net-
works could capture complex graph patterns, including IOC information and
the relationships between IOCs.

4

R. Wei et al.

– We choose 5 APT attack scenarios with diﬀerent degrees of inconsistency
between the provenance graph and the query graph, including 3 real-life
APT scenarios and 2 synthetic APT scenarios, to evaluate our approach.
– Our evaluation illustrates that DeepHunter outperforms the state-of-the-
art APT threat hunting approach (i.e., Poirot) in accuracy and robustness.
Meanwhile, DeepHunter, as a graph pattern matching model, is superior to
other graph matching methods (i.e., non-learning-based and GNN-based) in
the threat hunting task.

2 Related Work

2.1 Threat Hunting Approaches

In this work, we mainly focus on the threat hunting methods. Poirot [28] is a
related work to DeepHunter. We will introduce and compare it with DeepHunter
in the evaluation (section 7.2). RapSheet [11] is an approach that could improve
EDR’s threat hunting ability using the provenance graph analysis. But Rap-
Sheet [11] requires complete paths remained in the provenance graph to correlate
alerts. Obviously, the disconnected attack provenance graphs will undermine the
performance of RapSheet.

For APT detection and investigation, both Holmes [29] and NoDoze [12] cor-
relate alerts using the provenance graphs. To hunt stealthy malware, ProvDe-
tector [44] proposes a graph representation learning approach to model process’
normal behavior in provenance graphs. However, these methods assume an ac-
curate normal behavior database for reducing false alarms. We know that the
normal behavior model may create a risk of the poisoning attack due to concept
drift as benign usage changes. Additionally, all of these methods are path-based
approaches. So their robustness could be inﬂuenced by the disconnected prove-
nance graphs.

Some methods use IOCs or threat alerts as a clue to identify attack behaviors
(i.e., zero-day attack [43] and C&C [32]). However, these methods overlook the
relationship between indicators or alerts. So it could bring high false positives.

2.2 Provenance Graph Analysis

Provenance graph analysis is widely applied to the APT attack detection [46],
forensic analysis [16], and attack scenario reconstruction [15, 35], etc. Recent
works [13, 29] seek to bridge the semantic gap between low-level system events
and high-level behaviors. Many recent works (i.e., Morse [16], BEEP [21], MPI [25],
and OmegaLog [13], etc.) are proposed to address the dependency explosion
problem in provenance graphs. StreamSpot [26] views the provenance graph as
a temporal graph with typed nodes and edges, then proposes a graph sketching
algorithm for anomaly detection.

DeepHunter: A GNN-based Approach for Robust Threat Hunting

5

2.3 Graph Matching Approaches

Graph pattern matching and graph similarity computation have been studied
for many real applications, such as the binary function similarity search [22] and
the hardware security [7]. In the past few decades, many graph matching metrics
were deﬁned, e.g., graph edit distance, graph isomorphism, etc. In this paper,
we evaluate the non-learning based WL kernel as a graph matching method.
Recently, many graph neural networks have been proposed for graph pattern
matching. We compare three of them in the evaluation.

3 Background and Motivation

In this section, we ﬁrst introduce the background knowledge of the provenance
graph and the query graph. (Section 3.1). Then, we brieﬂy illustrate several
common motivating situations where the threat hunting approach calls for high
robustness (Section 3.2). Finally, taking an APT attack scenario with discon-
nected attack graphs as an example, we illustrate how this scenario aﬀects exist-
ing methods and explain why DeepHunter can resist this situation (Section 3.3).

3.1 Background

Provenance Graph. Provenance graph is generally a directed acyclic graph
(DAG) [9], where the nodes represent system entities, and the edges represent
the dependency relation between these entities. There are two types of nodes in
provenance graphs: subjects, which represent processes, and objects, which rep-
resent other system entities such as ﬁles, Windows registry, and network sockets,
etc. Subject node’s attributes include process name, command line arguments.
Object node’s attributes include ﬁle names, IP addresses, ports, etc. Table 1
shows the nodes and edges we consider in this work. Provenance graph can
represent dependencies between system events.

Table 1. A summarization of nodes and edges in provenance graphs and query graphs.

Subject type Object type

Attributes

Relations

Process

Process
File
Socket
Registry

Name, Augments
File name

Fork/Clone
Read, Write
Src/dst IP, Src/dst port Recv, Send

Key name

Write

6

R. Wei et al.

Query Graph. The query graph Gq in our work can be constructed by manu-
ally or automatically [17, 24, 48] extracting IOCs together with the relationships
among them from CTIs (including human-written reports or other threat intel-
ligence feeds with structured standard formats (e.g., STIX [31], OpenIOC [6]
and MISP [30])). Both nodes and edges of the query graph are the same as the
provenance graph, as shown in Table 1. We set the node’s or edge’s attributes
to null if CTIs do not include the corresponding information.

3.2 Motivating Situations

To motivate our work, we introduce several common situations that could lead to
inconsistency or disconnected provenance graphs, which will weaken the existing
methods’ threat hunting ability. Firstly, provenance systems (e.g., Spade [8])
that are developed for recording system events in the application layer may
overlook certain attack activities. For instance, Spade does not trace system
activities until user space is started. Hence, if the attack occurred before the
tracing of Spade, an incomplete attack provenance graph would be generated.
Fortunately, the whole-system provenance trackers (like Hi-Fi [36], LPM [4],
and CamFlow [33]) can overcome this problem. Because these whole-system
provenance trackers begin recording system activities in the early boot phase as
the IN IT process starts.

Secondly, even if the whole-system provenance system is applied, some tar-
geted attacks could also lead to inconsistency or disconnected attack prove-
nance graphs. Taking the microarchitectural side-channel attack as an example,
there is no connection between the attacker process and the victim process in
the provenance graph. Coordinated attacks could generate disconnected attack
provenance graphs as well. If attackers control multiple entry points of a com-
promised system and coordinate to achieve an operational goal, each entry point
may correspond to an isolated attack graph.

Finally, attack mutations (or inaccurate CTIs) are another reason that incurs
the inconsistency or disconnected attack provenance graphs. In the next section,
we present an APT scenario with attack mutations to illustrate its inﬂuence to
threat investigation.

3.3 An APT Attack Scenario

Recently, cryptocurrency mining malware is one of the most prevalent threats in
the wild. Fig. 1 describes a typical cryptominer’s progression, including the Eter-
nalBlue exploitation stage, the persistence stage, and the cryptocurrency mining
stage. At its exploitation stage, wininit is responsible for conﬁguring and recon-
naissance scans. svchost exploits the EternalBlue vulnerability for propagation.
At the persistence stage (persistence I), spoolsv.exe creates an executable binary
and adds its path to the “run keys” in the Windows registry. At the last stage,
the cryptominer process minner.exe is started.

Now, let’s consider what happens if the attacker changes the persistence tech-
niques. For example, the attacker adopts an alternative persistence technique II

DeepHunter: A GNN-based Approach for Robust Threat Hunting

7

Fig. 1. Query graph of synthetic APT attack scenarios illustrated in section 3.3.

(persistence via WMI in Fig. 1). WMI is a preinstalled system tool and it can
achieve ﬁleless attacks [10, 27]. We further assume that the running provenance
system (not a whole-system provenance system) can not capture the dependency
between the spoolsv.exe process and the scrons.exe process (which is the host
process of WMI script). Hence, the connection between the EternalBlue exploita-
tion stage and the cryptocurrency mining stage is broken in attack provenance
graphs.

Note that the query graph used by analysts is the EternalBlue exploitation
stage, the cryptocurrency mining stage, and the upper part of the persistence
stage (persistence technique I) in Fig. 1. So the behavior recorded in the attack
provenance graph is inconsistent with the given query graph. Besides, the attack
provenance graph is disconnected. This situation makes both threat hunting and
forensic investigation more diﬃcult. In Section 7.2, we will show that this attack
mutation can seriously impair the existing threat hunting approach (i.e., Poirot).
Additionally, existing provenance graph-based threat correlation methods, like
[11, 12, 29], will deﬁnitely lose the correlation between the alerts of the exploita-
tion stage and the alerts of the cryptocurrency mining stage. And the path-based
anomaly scores (e.g., rareness score [12, 44] and threat score [11]) may also be
aﬀected by disconnected attack provenance graphs.

In contrast, DeepHunter is robust against this attack mutation. Intuitively,
although there exist the inconsistencies and the disconnected attack graphs in
this scenario, most node attributes and the main graph structures are preserved.
DeepHunter can learn robust graph patterns from training data which are resis-
tant to the inconsistencies. We detail the design of DeepHunter in section 5.

4 Design Overview and Challenges

4.1 Graph Pattern Matching for Cyber Threat Hunting

We aim to determine if a provenance graph and a given query graph represent
the same attack behaviors for a threat hunting task. In this work, we formu-
late the threat hunting task as a graph pattern matching problem. Given a
query graph Gq, the output is a matching score s of (Gq, Gi
p ∈ S =
{G1
p }, S is the set of provenance graphs. Our goal is to learn a

p), where Gi

p, . . . , GN

p, G2

%SYSTEMDRIVE%\ProgramData\*.exespoolsv.exewininit.exe%registry%\Run\*.exepropagationminner.exeEternalBlue ExploitationCryptocurrency miningx.dllPersistencesvchost.exex.dll…x.x.x.x:80x.x.x.x:80…scrons.exesvchost.exePersistence via WMIx.x.x.x:80xx…xxIII8

R. Wei et al.

graph matching model M, where M(Gp, Gq) = 1 indicates that the provenance
graph Gp and the query graph Gq represent the identical behavior; otherwise,
M(Gp, Gq) = −1 indicates that they are diﬀerent. The graph pattern matching
model M must meet three requirements: 1○ No expert knowledge needed; 2○
High eﬃciency (Graph pattern matching is NP-complete in the general case.);
3○ High robustness.

As aforementioned, using a graph neural network to extract graph patterns
and further compute matching scores is particularly appealing, since it can learn
a graph matching model without expert knowledge. Also, once the graph match-
ing model is learned, the matching score can be eﬃciently computed, and thus
we no longer rely on any expensive graph pattern matching algorithms.

4.2 Challenges & Solutions

It has been demonstrated that graph neural networks can learn complex graph
patterns for downstream tasks, such as binary code similarity detection [47] and
memory forensic analysis [42]. In this work, we need the graph neural network
to extract graph patterns for matching two graphs. In particular, the graph pat-
terns should be composed of node attributes and graph structures. We show the
challenges of designing graph neural networks and our corresponding solutions
as follows.

Challenge 1 How to represent node attribute information eﬀectively? There
are multiple node types in graphs, each node has many attributes, and diﬀerent
attributes may have diﬀerent importance to the graph pattern matching task.
Previous work [26] considers the provenance graph as a heterogeneous graph and
searches the heterogeneous graph following the meta-paths. However, construct-
ing the meta-path needs expert knowledge on the target systems.

We propose the attribute embedding network (detailed in section 5.1) to rep-
resent the node’s attributes. We treat the node type (e.g., process, ﬁle, socket,
etc.) as one of a node’s attributes and employ the attention mechanism to au-
tomatically learn which attributes contribute most to the graph matching task.

Challenge 2 How to represent graph structures eﬀectively? Previous graph
pattern matching models [3, 22, 45] utilize the same neural network structure
to represent both input graphs. But the characteristics of two input graphs for
threat hunting are distinct, as mentioned in section 1.

We adopt two diﬀerent graph neural networks: One is GCN for the query
graph, and the other is specially designed to represent the provenance graph
structure. We introduce them as the graph embedding networks, as detailed in
section 5.2.

DeepHunter: A GNN-based Approach for Robust Threat Hunting

9

5 DeepHunter’s Graph Pattern Matching Model

5.1 Attribute Embedding Network for Encoding Node’s Attributes

The goal of the attribute embedding network is to obtain the input feature h0
u
for each node u, which incorporates u(cid:48)s attributes information. Speciﬁcally, we
ﬁrst generate an embedding vi for each attribute i of the node u (as depicted
on the left of Fig. 2), and then compute u(cid:48)s input feature h0
u by aggregating u(cid:48)s
attribute embeddings (as depicted on the right of Fig. 2).

Fig. 2. The process of generating input features.

To obtain the attribute embedding vi, inspired by the path embedding method
of ProvDetector [44], we view a path in the provenance graph as a sentence and
then adopt an unsupervised NLP model ( word2vec [20]). Speciﬁcally, we ﬁrst
translate paths in the provenance graphs into sentences which consist of at-
tributes. For example, the colored nodes n1, n2, and the edge e between them
in the provenance graph of Fig. 2 can be translated into a sentence as follows:
Process conhost reads ﬁle netsh.exe in C : \\W indows\\System32. Then we
feed the sentences into a word2vec model to learn the vector representation vi
for each attribute i.

We represent a node u(cid:48)s input feature as the aggregation of its attribute em-
beddings vi. Common aggregation functions include sum and average. However,
for the graph pattern matching task, the importance of each node attribute may
be diﬀerent. Hence, we use the attention mechanism to learn the weight for each
attribute of a node. Speciﬁcally, we compute node u(cid:48)s input feature h0

u by

(cid:88)

h0
u =

αivi,

i∈Au

(1)

where Au is the attribute set of the node u, αi is the weight of the i−th attribute,
vi is the embedding of attribute i.

5.2 Graph Embedding Networks for Encoding Graph Structures

Graph embedding networks aim to represent graph structures of both the query
graph and the provenance graph. There are two stages in the graph embedding
networks: the node-level embedding stage and the graph-level embedding stage.
We use two diﬀerent graph embedding networks to encode the provenance graph
Gp and the query graph Gq respectively.

Type: fileName: netsh.exeLocation: C:\\...Type: processName: conhost“process”“conhost”“netsh”Provenance GraphPath TranslationAttribute EmbeddingAttribute Embedding Network“file”filenetsh.exeC:\\...“C:\\...”Input FeaturesNodes… … Attribute Embeddings Generation.Agg0120uhe1n2n10

R. Wei et al.

Stage 1: Node-level Embedding. It is the node embedding method that
leads to the diﬀerence between the query graph embedding network and the
provenance graph embedding network. We adopt the existing graph convolu-
tional network (GCN) [19] to embed the nodes in the query graph. Because the
query graph is usually small and noise-free, which can be handled by GCN. To
embed the nodes in the provenance graphs, we design a provenance graph em-
bedding network structure (shown in Fig. 3) which is capable of dealing with the
redundant nodes while remaining the key information for matching the query
graph. The provenance graph node embedding network is detailed as follows.

Fig. 3. Provenance graph node-level embedding network structure.

Firstly, we design a GNN layer, called attention aggregator, which could
aggregate information from neighbors for the target node. Note that, for a node
u in the provenance graph, diﬀerent neighbors may have diﬀerent importance
for graph matching when incorporating their node features into node u. In par-
ticular, the redundant neighbors should be assigned a lower importance value to
reduce their impact on u(cid:48)s hidden representation hu, while the nodes that can
match the corresponding ones in the query graph should be assigned a higher
importance value. For this purpose, we adopt another attention mechanism that
can learn weights for neighbors of node u. Formally, the hidden representation
hu outputted by the layer k can be computed via a neural aggregation function
that is achieved by

u = M LP ((cid:15)(k)hk−1
hk

u +

(cid:88)

v∈Nu

αvhk−1
v

),

(2)

where hk
u is the output of layer k of the provenance graph embedding network,
and it is the hidden representation of node u; αv is the attentional weight of
node v (v ∈ Nu, where Nu is the set of node u(cid:48)s neighbors).

To aggregate the information into hu from distant nodes, we then add more
layers deﬁned by Eq. 2. The number of layers, K, means that the GNN can ag-
gregate information from u’s K − hops neighbors. However, simply adding layers
may squash exponentially-growing information (including noise) into ﬁxed-size
vectors. To address this issue, we adopt the Layer-wise Dense-connected Aggre-
gator which is proposed by [45]. This strategy is formulated as follows:

uMLP11v2v3v231uhAttention Aggregator 1Kuh1Kuh0uh10vh20vh30vhAttention Aggregator 2Attention Aggregator KLayer-wise Dense-connected Aggregator2uhNode-level Embedding StageDeepHunter: A GNN-based Approach for Robust Threat Hunting

11

hK+1
u

= M LP ([h0

u; h1

u; . . . hK

u ]),

(3)

where [·; ·] is the feature concatenation operation.

Stage 2: Graph-level Embedding. Now we obtain the node embedding h for
each node in both the query graph and the provenance graphs. How to gener-
ate a low-dimensional embedding vector for a graph using node embeddings? In
this work, we adapt the Global Context-Aware Attention strategy proposed in
SimGNN [3] to obtain the graph-level embedding hG. Intuitively, nodes that are
similar to the global context will be assigned larger weights, which allows the cor-
responding node embeddings to contribute more to the graph-level embedding.
Diﬀerent from SimGNN, we normalize the weights into 1, because we do not want
the graph size to aﬀect the calculation of the matching score. Hence, we replace
the sigmoid function in SimGNN with a softmax function σ(z)i = ezi
j=1 ezj . This
graph-level embedding is formally represented by the following equation:

(cid:80)K

hG =

=

(cid:88)N

u=1

(cid:88)N

u=1

σ(huc)hu

σ(hu tanh((

1
N

(cid:88)N

m=1

hm)W ))hu,

(4)

where N is the number of nodes in a graph, tanh(·) is a activation function, W
is the trainable parameters.

5.3 GNN-based Architecture for Graph Pattern Matching

Based on the attribute embedding network and the graph embedding network,
DeepHunter’s graph pattern matching model could learn robust graph patterns.
The framework of DeepHunter’s graph pattern matching model is shown in
Fig. 4. It consists of two branches. The upper branch of Fig. 4 deals with CTI
information, and the lower one is for provenance data. At the beginning of each
branch, the query graph and the provenance graph are constructed. Then both
of them are fed into our GNN-based models.

Fig. 4. The framework of DeepHunter’s graph pattern matching model.

Attribute Embedding NetworkProvenance Graph Node-level Embedding Graph EmbeddingSAttribute Embedding NetworkQuery Graph Node-level Embedding (GCN)NTNDNNGraph-level Embedding Graph-level Embedding qGhpGh12

R. Wei et al.

Given the output of two branches, hGq and hGp , many existing graph match-
ing models adopt the Siamese architecture [5] to learn the relation between them.
However, the Siamese architecture that directly computes the inner product of
hGq and hGp is too simple to model the complex relation. Instead, we employ
Neural Tensor Network (NTN), which is a powerful relation learning network,
to replace the inner product operation. We compare NTN and the traditional
Siamese architecture in section 7.3.

After the NTN layer, we connect multi-layer dense neural networks (DNNs)
and output the graph matching score s. At last, to compute the loss, we compare
s against the ground-truth label using the following mean squared error loss
function:

L =

(cid:88)

(ˆs − s(hGpi

, hGqi

))2,

(5)

(Gpi ,Gqi )∈D

where D = {(Gp1, Gq1 ), (Gp2 , Gq2 ), ...} is the training dataset.

We train the proposed model in an end-to-end way. We leverage stochastic
gradient descent to estimate parameters. After a number of training epochs, the
loss value will be small and stable, the accuracy of validation data will be high,
which demonstrates that the model is trained well.

6

Implementation

6.1 Provenance Graph Reduction

In practice, due to hosting long-term system logs is prohibitively expensive,
analysts attempt to reduce the provenance graph and yet preserve the quality
of threat hunting [11]. In this work, we prune the provenance graph as follows.
First, we leverage the MITRE ATT&CK TTPs and the IOCs to generate
suspicious events. Speciﬁcally, DeepHunter uses the EDR tool (i.e., BLUES-
PAWN [40]), which provides matching rules to detect MITRE ATT&CK TTPs.
Besides, DeepHunter also matches the IOCs (extracted from threat intelligence,
such as APT reports) using regular expressions. The events identiﬁed by both
the EDR tool and the IOC matching are regarded as suspicious events.

We then propose the provenance graph reduction algorithm (Algorithm 1),
which could prune the provenance graphs based on the suspicious events. In-
spired by Poirot [28], we select seed nodes from the nodes that match the IOCs.
For example, suppose IOC α has x matched nodes in provenance graphs, IOC
β has y matched nodes, and IOC γ has z matched nodes. If z = min{x, y, z},
then these z nodes are seed nodes. We start from a seed node and execute
adaptiveBF S searching on the provenance graphs. A suspicious subgraph gen-
erated by the graph reduction algorithm could cover all IOCs’ alerts.

The adaptiveBF S is an adapted Breadth-First Search (BFS) algorithm.
Speciﬁcally, during BFS on the provenance graph, only the nodes related to
suspicious events and the process node could be visited.

DeepHunter: A GNN-based Approach for Robust Threat Hunting

13

Algorithm 1: Provenance Graph Reduction Algorithm

Input: Provenance Graphs: Gp, Indicators Set: I, Matched Nodes Set: P ;
Output: Suspicious Subgraphs: SuspGraphs
Function ExpandSearch(SeedN odes, Susp):

foreach node ∈ SeedN odes do

start node ← node; subgraph ← adaptiveBF S(start node, P );

Susp ← ComposeGraph(Susp, subgraph);

if Susp contains all indicators in I then

Add Susp to SuspGraphs

else

remain nodes ← seed nodes from P that are not matched with

any indicators in I; ExpandSearch(remain nodes, Susp);

end

end
return SuspGraphs

Obviously, the suspicious subgraphs generated by our provenance graph re-
duction algorithm contain lots of false positives (the threat alert fatigue prob-
lem). Therefore, it is still necessary for analysts to use our graph pattern match-
ing model (Section 5) to calculate the matching score.

6.2 Training Data Generation

Training DeepHunter requires a large number of positive samples (Gpi, Gqi)
(M(Gpi, Gqi) = 1) and negative samples (Gpi, Gqi) (M(Gpi , Gqi) = −1). The
query graph can be considered as a summarization of its corresponding prove-
nance graph. Therefore, we use the graph summarization techniques to generate
the matched query graph Gq for each provenance graph Gp. We also add random
noise to improve the robustness. We detail the training data generation method
as follows.

Firstly, we extract a subgraph as Gpi from the provenance graphs. Speciﬁ-
cally, we start from a process node and use DFS on the provenance graph. We
limit the length of the paths, which is less than 4. Then we reﬁne the Gpi using
two graph summarization rules as follows:

– Merge process nodes that have the same process name;
– Remove duplicate paths. If two paths are duplicates (i.e., two sequences of

node name are equal), only one is reserved.

Then we add noise to Gpi by:

– randomly dropping edges or object nodes on Gpi;
– randomly removing one or more attributes of a node.

After the above two steps, we generate a Gqi for the Gpi. So (Gqi, Gpi) is a

positive sample for training.

14

R. Wei et al.

Table 2. APT attack scenarios description and the source of query graphs.

Scenario

Short Description

Q1+CADETS A Nginx server was exploited and a malicious ﬁle was
downloaded and executed. The attacker tried to inject
into sshd process, but failed.

Query Graph
Source

DARPA TC 3
reports

Q2+TRACE The Firefox process was exploited and established a
connection to the attacker’s operator console. The at-
tacker downloaded and executed a malicious ﬁle.

DARPA TC 3
reports

Q3+TRACE A Firefox extension (a password manager) was ex-
ploited. A malicious ﬁle was downloaded and executed
to connect out to the C&C server.

DARPA TC 3
reports

Q4+ETW Detailed in section 3.3.

Q5+ETW The attack mutation of scenario Q4.

Fig. 1 with per-
sistence I
Fig. 1 with per-
sistence II

At last, we construct the negative sample (Gqj , Gpi) by randomly combining
Gpi and Gqj , where i (cid:54)= j. By doing this, we simulate the situation where most of
the node attribute information and the main graph structure of Gpi is preserved
in Gqi.

7 EVALUATION

7.1 Attack Scenarios and Experimental Setup

To evaluate the eﬃcacy of DeepHunter, we utilize provenance data which contain
5 APT attack scenarios, including 3 real-life APTs(DARPA TC engagement 3)
and 2 synthetic APTs. For each of the attack scenarios, the corresponding query
graph is also provided. To simulate real-world threat hunting, the query graphs
we used in the evaluation are either generated by the third-party or constructed
based on the public APT reports. The description of APT scenarios and the
source of corresponding query graphs are shown in Table 2.

Inconsistency Scores. Before evaluating robustness, we deﬁne three incon-
sistency scores to quantify the degree of the inconsistency between the query
graph and the corresponding provenance graph. Speciﬁcally, we compute graph
edit distance (GED) and the number of missing nodes and missing paths.
GED measures the cost that transforms Gq into Gp. We adopt a graph match-
ing toolkit [18, 39] to calculate GED and normalize [37] the GED scores for
diﬀerent graph sizes. The missing node of the query graph is the node that we
cannot ﬁnd its alignments in provenance graphs. The missing path means that
for an edge from node i to j in the query graph, there is no path from the nodes
aligned to i to the nodes aligned to j in provenance graphs. Table 3 shows the

DeepHunter: A GNN-based Approach for Robust Threat Hunting

15

inconsistency scores of the scenarios in Table 2. We can see from Table 3 that
the chosen scenarios contain diﬀerent degrees of inconsistency.

Table 3. Inconsistency scores of diﬀerent scenarios. The values in parentheses on the
second and third columns are the number of missing nodes and paths, respectively.

Scenario Missing Nodes (%) Missing Paths (%) GED

Q1+CADETS
Q2+TRACE
Q3+TRACE
Q4+ETW
Q5+ETW

0
0
0
3.8%(1)
21.4%(6)

0
6.25%(1)
16%(4)
4%(1)
20%(7)

0.192
0.303
0.504
0.454
0.557

Experimental Setup. The provenance data from DARPA are collected by
two provenance systems: CADETS [1] and TRACE [2]. Besides, we synthesized
attacks in scenarios Q4+ETW and Q5+ETW on Windows 7 32 bit systems. The
provenance data of Q4+ETW and Q5+ETW, including benign system activities
and attack behaviors, were collected by our ETW-based provenance system.

We employed the gensim [38] Python library to obtain the attribute embed-
dings vi (detailed in section 5.1). We implemented the proposed graph neural
network model using PyTorch [34]. We trained whole neural network-based mod-
els using 2 Nvidia Tesla P4 GPU. Other experiments (e.g., provenance graph
construction, graph reduction, etc.) are conducted on a server with two Intel
Xeon E5-2630 v3 CPUs and 128 GB memory running CentOS system.

Datasets. We generated a dataset for each provenance system and named the
dataset after the provenance system. We used the graph reduction method illus-
trated in section 6.1 to prune the provenance graph. The generated subgraphs
(i.e., test graphs) were manually labeled based on the corresponding reports’
timestamp. We also generated training graph pairs using the method detailed in
section 6.2. The characteristics of our datasets are shown in Table 4.

Table 4. The characteristics of graph datasets used in our evaluation.

Dataset Raw Graph Size

# of Test Graphs

Benign

Attack

# of Training Graphs

CADETS
TRACE
ETW

904 MB
22.5GB
40GB

10
9
105

1
6
10

150,000
150,000
300,000

16

R. Wei et al.

Fig. 5. Axis x: graph edit distance between Gq and Gp of each scenario in Table 2;
Axis y: matching scores between Gq and Gp of each scenario.

7.2 Robustness

We evaluate the impact of inconsistency on DeepHunter and the state-of-the-art
Poirot. We also analyze why Poirot fails in scenario Q5+ETW which contains
disconnected attack provenance graphs.

State-of-the-art Poirot. Poirot is a heuristic graph pattern matching algo-
rithm that can compute the graph alignment score between the query graph
and the provenance graph. Poirot searches for aligned nodes in the provenance
graphs according to the inf ormation f lows in the query graph. During the
search, Poirot omits the paths that are impossible to be adopted by attackers.

Experimental Results. We compare DeepHunter with Poirot using all sce-
narios in Table 2. The matching scores calculated by Poirot, DeepHunter, and
other GNN-based graph matching models are shown in Fig. 5. We can see that all
matching scores calculated by DeepHunter are greater than the threshold (which
is 0.5). This result shows that the accuracy of DeepHunter can be guaranteed in
scenarios where there exist various degrees of inconsistency.

Moreover, as the degree of the inconsistency increases, all matching scores
decrease. But the curve of DeepHunter is more stable. On the contrary, the curve
of Poirot drops faster than the GNN-based graph matching models. Even worse,
the matching score calculated by Poirot is less than its threshold in the most
inconsistent scenario Q5+ETW , which means that Poirot fails to identify this
attack.

Additionally, we detail the false positive results of DeepHunter and Poirot in
Table 5. The results can demonstrate that the high robustness of DeepHunter is
not built upon false positives.

0.20.30.40.50.60.7GED0.200.330.400.500.600.801.00Matching ScoresRobustnessDeepHunterPoirotMatchGNetSimGNNGMNDeepHunter: A GNN-based Approach for Robust Threat Hunting

17

Table 5. False positive results of DeepHunter and Poirot.

Dataset

CADETS TRACE ETW

# of Test Graphs
# of FPs(DeepHunter)
# of FPs(Poirot)

11
0
0

15
0
1

115
1
2

Why Poirot Fail? When searching on the disconnected attack provenance
graphs in Q5+ETW, the paths which start from nodes belonging to the Eter-
nalBlue exploitation stage to nodes belonging to the cryptocurrency mining stage
can not be found. So the graph alignment score computed using the Equation
(2) in Poirot becomes smaller (The inf luence scores of the missing paths are
all equal to 0. And the denominator of Equation (2), |F (Gq)|, which is the num-
ber of f lows in the query graph, remains unchanged). As a result, this type of
inconsistency in Q5+ETW leads to the invalidation of Poirot. On the contrary,
DeepHunter does not rely on complete connectivity remained in the provenance
graph. As long as most node attribute information and the main graph structure
information between the query graph and the traceability graph are matched,
DeepHunter can recognize that the two graphs represent the same attack behav-
ior. Therefore, DeepHunter has a more robust cyber threat hunting ability.

7.3 Comparison with Other Graph Matching Models

We compare DeepHunter with a non-learning graph matching approach and
other GNN-based graph matching models. Note that these GNN-based mod-
els are not speciﬁcally designed for threat hunting. We evaluate all the graph
matching approaches using the AUC value, since it is a strict metric. If a small
mistake is made, the error would be obvious.

DeepHunter vs. Non-learning Approach. We compare DeepHunter with
the Weisfeiler Lehman (WL) kernel, a non-learning method for calculating the
graph similarity. We set the number of iteration of the WL kernel from 1 to
10 and put the best results in Table 6. The result of the WL kernel is not
desirable because it is designed for graph isomorphism testing. In contrast, the
graph matching in a threat hunting task is more similar to determining whether
a query graph can be regarded as an abstraction of the provenance graph.

DeepHunter vs. GNN-based Graph Matching Models. We compare Dee-
pHunter’s graph matching model with other GNN-based graph matching net-
works: MatchGNet [45], SimGNN [3] and GMN [23]. MatchGNet proposed a
Hierarchical Attentional Graph Neural Encoder (HAGNE) which could embed
the provenance graph. Given the graph-level embeddings, MatchGNet employs
the Siamese network to learn the similarity metric. We believe that the Siamese
network is not enough to learn the complex relationship between the two graphs.

18

R. Wei et al.

Hence, we substitute the Siamese network of MatchGNet with the NTN layer.
We call the modiﬁed model MatchGNet-NTN. By the comparison between Dee-
pHunter and MatchGNet-NTN, the eﬀectiveness of our graph embedding net-
works can be testiﬁed. As can be seen in Table 6, the performance of DeepHunter
outperforms MatchGNet and MatchGNet-NTN.

We also evaluate the eﬀectiveness of the attribute embedding network. In-
stead of the attribute embedding network, we directly use the one-hot encoding
of attributes as the node’s input feature. We call this model DeepHunter-wo-
AEN. Table 6 shows that DeepHunter-wo-AEN is inferior to DeepHunter, which
demonstrates the attribute embedding network is necessary for our graph match-
ing task.

At last, we evaluate the other two graph matching networks: SimGNN and
GMN. Like DeepHunter, SimGNN also leverages GNN to represent input graphs
and then utilizes NTN to learn the similarity between two graph-level embed-
dings. But the graph neural networks in SimGNN are not speciﬁcally designed
for representing the provenance graphs. Besides, SimGNN believes that if there
is a diﬀerence in the size of the two input graphs, then the two graphs are not
similar. GMN takes into account the node correlation across graphs to model
the relation. The results of SimGNN and GMN are shown in Table 6. We can
see that the performance of DeepHunter is superior to both SimGNN and GMN.

Table 6. AUC values of graph matching models on three datasets.

Dataset
DeepHunter
MatchGNet [45]
MatchGNet-NTN
MatchGNet-wo-AEN
SimGNN [3]
GMN [22]
WL kernel

CADETS TRACE ETW
0.951 0.916
0.805
0.880
0.844
0.932
0.820
0.891
0.805
0.906
0.830
0.846
0.301
0.492

1
1
1
1
1
1
1

8 Conclusions

We propose DeepHunter, a GNN-based graph pattern matching approach for
cyber threat hunting. More importantly, DeepHunter is robust against the in-
consistency between real attack behaviors recorded by provenance data and
known attack behaviors to some extent. Our extensive evaluations show that
DeepHunter can tolerate various scenarios with diﬀerent inconsistency scores,
including disconnected attack provenance graphs. In our synthetic APT attack
scenario, DeepHunter is superior to the state-of-the-art APT threat hunting
approach Poirot. Our research showcased a successful application of the graph
neural network on the threat hunting task.

DeepHunter: A GNN-based Approach for Robust Threat Hunting

19

References

2. Trace:

1. Causal, adaptive, distributed, and eﬃcient tracing system (cadets). https://www.
cl.cam.ac.uk/research/security/cadets/ (2018), accessed 21st September 2020
cy-
https://archive.sri.com/work/projects/
ac-

berattacks.
trace-preventing-advanced-persisten-threat-cyberattacks
cessed 21st September 2020

Preventing

persistent

advanced

(2018),

threat

3. Bai, Y., Ding, H., Bian, S., Chen, T., Sun, Y., Wang, W.: Simgnn: A neural network
approach to fast graph similarity computation. In: Proceedings of the Twelfth ACM
International Conference on Web Search and Data Mining. pp. 384–392 (2019)
4. Bates, A., Tian, D.J., Butler, K.R., Moyer, T.: Trustworthy whole-system prove-
nance for the linux kernel. In: 24th {USENIX} Security Symposium ({USENIX}
Security 15). pp. 319–334 (2015)

5. Bromley, J., Guyon, I., LeCun, Y., S¨ackinger, E., Shah, R.: Signature veriﬁcation
using a” siamese” time delay neural network. In: Advances in neural information
processing systems. pp. 737–744 (1994)

6. FireEye: https://openioc.org (2018), openIOC
7. Fyrbiak, M., Wallat, S., Reinhard, S., Bissantz, N., Paar, C.: Graph similarity
and its applications to hardware security. IEEE Transactions on Computers 69(4),
505–519 (2019)

8. Gehani, A., Tariq, D.: Spade: support for provenance auditing in distributed envi-
ronments. In: ACM/IFIP/USENIX International Conference on Distributed Sys-
tems Platforms and Open Distributed Processing. pp. 101–120. Springer (2012)
9. Gibson, T., Schuchardt, K., Stephan, E.G.: Application of named graphs towards
custom provenance views. In: Workshop on the Theory and Practice of Provenance
(2009)

10. Graeber, M.: Abusing windows management instrumentation (wmi) to build a
persistent, asyncronous, and ﬁleless backdoor. Black Hat. Las Vegas, NV, USA
(2015)

11. Hassan, W.U., Bates, A., Marino, D.: Tactical provenance analysis for endpoint de-
tection and response systems. In: Proceedings of the IEEE Symposium on Security
and Privacy (2020)

12. Hassan, W.U., Guo, S., Li, D., Chen, Z., Jee, K., Li, Z., Bates, A.: Nodoze: Com-

batting threat alert fatigue with automated provenance triage. In: NDSS (2019)

13. Hassan, W.U., Noureddine, M.A., Datta, P., Bates, A.: Omegalog: High-ﬁdelity
attack investigation via transparent multi-layer log analysis. In: Proc. NDSS (2020)
14. Homayoun, S., Dehghantanha, A., Ahmadzadeh, M., Hashemi, S., Khayami, R.:
Know abnormal, ﬁnd evil: frequent pattern mining for ransomware threat hunting
and intelligence. IEEE transactions on emerging topics in computing (2017)
15. Hossain, M.N., Milajerdi, S.M., Wang, J., Eshete, B., Gjomemo, R., Sekar, R.,
Stoller, S., Venkatakrishnan, V.: {SLEUTH}: Real-time attack scenario recon-
struction from {COTS} audit data. In: 26th {USENIX} Security Symposium
({USENIX} Security 17). pp. 487–504 (2017)

16. Hossain, M.N., Sheikhi, S., Sekar, R.: Combating dependence explosion in forensic
analysis using alternative tag propagation semantics. In: 2020 IEEE Symposium
on Security and Privacy (SP). IEEE (2020)

17. Husari, G., Al-Shaer, E., Ahmed, M., Chu, B., Niu, X.: Ttpdrill: Automatic and
accurate extraction of threat actions from unstructured text of cti sources. In:
Proceedings of the 33rd Annual Computer Security Applications Conference. pp.
103–115 (2017)

20

R. Wei et al.

18. Kaspar, R.: https://github.com/dzambon/graph-matching-toolkit (2018),

mig-logcleaner-resurrected

19. Kipf, T.N., Welling, M.: Semi-supervised classiﬁcation with graph convolutional

networks. arXiv preprint arXiv:1609.02907 (2016)

20. Le, Q., Mikolov, T.: Distributed representations of sentences and documents. In:

International conference on machine learning. pp. 1188–1196 (2014)

21. Lee, K.H., Zhang, X., Xu, D.: High accuracy attack provenance via binary-based

execution partition. In: NDSS (2013)

22. Li, Y., Gu, C., Dullien, T., Vinyals, O., Kohli, P.: Graph matching networks for
learning the similarity of graph structured objects. In: Chaudhuri, K., Salakhutdi-
nov, R. (eds.) Proceedings of the 36th International Conference on Machine Learn-
ing. Proceedings of Machine Learning Research, vol. 97, pp. 3835–3845. PMLR,
Long Beach, California, USA (09–15 Jun 2019), http://proceedings.mlr.press/
v97/li19d.html

23. Li, Y., Gu, C., Dullien, T., Vinyals, O., Kohli, P.: Graph matching networks for
learning the similarity of graph structured objects. arXiv preprint arXiv:1904.12787
(2019)

24. Liao, X., Yuan, K., Wang, X., Li, Z., Xing, L., Beyah, R.: Acing the ioc game:
Toward automatic discovery and analysis of open-source cyber threat intelligence.
In: Proceedings of the 2016 ACM SIGSAC Conference on Computer and Commu-
nications Security. pp. 755–766 (2016)

25. Ma, S., Zhai, J., Wang, F., Lee, K.H., Zhang, X., Xu, D.: {MPI}: Multiple per-
spective attack investigation with semantic aware execution partitioning. In: 26th
{USENIX} Security Symposium ({USENIX} Security 17). pp. 1111–1128 (2017)
26. Manzoor, E., Milajerdi, S.M., Akoglu, L.: Fast memory-eﬃcient anomaly detection
in streaming heterogeneous graphs. In: Proceedings of the 22nd ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining. pp. 1035–
1044 (2016)

27. Micro, T.: https://blog.trendmicro.com/trendlabs-security-intelligence/
(2017),
cryptocurrency-miner-uses-wmi-eternalblue-spread-filelessly/
cryptocurrency Miner Uses WMI and EternalBlue To Spread Filelessly, Accessed
May 4, 2020

28. Milajerdi, S.M., Eshete, B., Gjomemo, R., Venkatakrishnan, V.: Poirot: Aligning
attack behavior with kernel audit records for cyber threat hunting. In: Proceedings
of the 2019 ACM SIGSAC Conference on Computer and Communications Security.
pp. 1795–1812 (2019)

29. Milajerdi, S.M., Gjomemo, R., Eshete, B., Sekar, R., Venkatakrishnan, V.: Holmes:
real-time apt detection through correlation of suspicious information ﬂows. In: 2019
IEEE Symposium on Security and Privacy (SP). pp. 1137–1152. IEEE (2019)
30. MISP: https://www.misp-project.org/ (2019), open Source Threat Intelligence

Platform & Open Standards For Threat Information Sharing

31. Mitre: https://stixproject.github.io (2018), structured Threat Information

eXpression (STIX)

32. Oprea, A., Li, Z., Yen, T.F., Chin, S.H., Alrwais, S.: Detection of early-stage en-
terprise infection by mining large-scale log data. In: 2015 45th Annual IEEE/IFIP
International Conference on Dependable Systems and Networks. pp. 45–56. IEEE
(2015)

33. Pasquier, T., Han, X., Goldstein, M., Moyer, T., Eyers, D., Seltzer, M., Bacon, J.:
Practical whole-system provenance capture. In: Proceedings of the 2017 Sympo-
sium on Cloud Computing. pp. 405–418 (2017)

DeepHunter: A GNN-based Approach for Robust Threat Hunting

21

34. Paszke, A., Gross, S., Massa, F., Lerer, A., Bradbury, J., Chanan, G., Killeen,
T., Lin, Z., Gimelshein, N., Antiga, L., Desmaison, A., Kopf, A., Yang, E.,
DeVito, Z., Raison, M., Tejani, A., Chilamkurthy, S., Steiner, B., Fang, L., Bai,
J., Chintala, S.: Pytorch: An imperative style, high-performance deep learning
library. In: Wallach, H., Larochelle, H., Beygelzimer, A., d'Alch´e-Buc, F., Fox, E.,
Garnett, R. (eds.) Advances in Neural Information Processing Systems 32, pp.
8024–8035. Curran Associates, Inc. (2019), http://papers.neurips.cc/paper/
9015-pytorch-an-imperative-style-high-performance-deep-learning-library.
pdf

35. Pei, K., Gu, Z., Saltaformaggio, B., Ma, S., Wang, F., Zhang, Z., Si, L., Zhang, X.,
Xu, D.: Hercule: Attack story reconstruction via community discovery on correlated
log graph. In: Proceedings of the 32Nd Annual Conference on Computer Security
Applications. pp. 583–595 (2016)

36. Pohly, D.J., McLaughlin, S., McDaniel, P., Butler, K.: Hi-ﬁ: collecting high-ﬁdelity
whole-system provenance. In: Proceedings of the 28th Annual Computer Security
Applications Conference. pp. 259–268 (2012)

37. Qureshi, R.J., Ramel, J.Y., Cardot, H.: Graph based shapes representation and
recognition. In: International Workshop on Graph-Based Representations in Pat-
tern Recognition. pp. 49–60. Springer (2007)

38. ˇReh˚uˇrek, R., Sojka, P.: Software Framework for Topic Modelling with Large Cor-
pora. In: Proceedings of the LREC 2010 Workshop on New Challenges for NLP
Frameworks. pp. 45–50. ELRA, Valletta, Malta (May 2010), http://is.muni.cz/
publication/884893/en

39. Riesen, K., Emmenegger, S., Bunke, H.: A novel software toolkit for graph edit dis-
tance computation. In: International Workshop on Graph-Based Representations
in Pattern Recognition. pp. 142–151. Springer (2013)

40. Smith,

J.:

https://libraetd.lib.virginia.edu/public_view/5138jf509

(2021), accessed March 4, 2021

41. Socher, R., Chen, D., Manning, C.D., Ng, A.: Reasoning with neural tensor net-
works for knowledge base completion. In: Advances in neural information process-
ing systems. pp. 926–934 (2013)

42. Song, W., Yin, H., Liu, C., Song, D.: Deepmem: Learning graph neural network
models for fast and robust memory forensic analysis. In: Proceedings of the 2018
ACM SIGSAC Conference on Computer and Communications Security. pp. 606–
618 (2018)

43. Sun, X., Dai, J., Liu, P., Singhal, A., Yen, J.: Using bayesian networks for proba-
bilistic identiﬁcation of zero-day attack paths. IEEE Transactions on Information
Forensics and Security 13(10), 2506–2521 (2018)

44. Wang, Q., Hassan, W.U., Li, D., Jee, K., Yu, X., Zou, K., Rhee, J., Chen, Z.,
Cheng, W., Gunter, C., et al.: You are what you do: Hunting stealthy malware via
data provenance analysis. In: Proc. of the Symposium on Network and Distributed
System Security (NDSS) (2020)

45. Wang, S., Chen, Z., Yu, X., Li, D., Ni, J., Tang, L.A., Gui, J., Li, Z., Chen, H., Yu,
P.S.: Heterogeneous graph matching networks for unknown malware detection. In:
Proceedings of the 28th International Joint Conference on Artiﬁcial Intelligence.
pp. 3762–3770. AAAI Press (2019)

46. Xiong, C., Zhu, T., Dong, W., Ruan, L., Yang, R., Chen, Y., Cheng, Y., Cheng, S.,
Chen, X.: Conan: A practical real-time apt detection system with high accuracy
and eﬃciency. IEEE Transactions on Dependable and Secure Computing (2020)

22

R. Wei et al.

47. Xu, X., Liu, C., Feng, Q., Yin, H., Song, L., Song, D.: Neural network-based graph
embedding for cross-platform binary code similarity detection. In: Proceedings of
the 2017 ACM SIGSAC Conference on Computer and Communications Security.
pp. 363–376 (2017)

48. Zhu, Z., Dumitras, T.: Chainsmith: Automatically learning the semantics of ma-
licious campaigns by mining threat intelligence reports. In: 2018 IEEE European
Symposium on Security and Privacy (EuroS&P). pp. 458–472. IEEE (2018)

