9
1
0
2

r
a

M
5
2

]

R
C
.
s
c
[

2
v
4
7
0
0
0
.
5
0
8
1
:
v
i
X
r
a

1

Checking is Believing: Event-Aware Program
Anomaly Detection in Cyber-Physical Systems

Long Cheng, Member, IEEE, Ke Tian, Danfeng (Daphne) Yao, Senior Member, IEEE,
Lui Sha, Fellow, IEEE, and Raheem A. Beyah, Senior Member, IEEE

Abstract—Securing cyber-physical systems (CPS) against malicious attacks is of paramount importance because these attacks may
cause irreparable damages to physical systems. Recent studies have revealed that control programs running on CPS devices suffer
from both control-oriented attacks (e.g., code-injection or code-reuse attacks) and data-oriented attacks (e.g., non-control data
attacks). Unfortunately, existing detection mechanisms are insufﬁcient to detect runtime data-oriented exploits, due to the lack of
runtime execution semantics checking. In this work, we propose Orpheus, a new security methodology for defending against
data-oriented attacks by enforcing cyber-physical execution semantics. We ﬁrst present a general method for reasoning cyber-physical
execution semantics of a control program (i.e., causal dependencies between the physical context/event and program control ﬂows),
including the event identiﬁcation and dependence analysis. As an instantiation of Orpheus, we then present a new program behavior
model, i.e., the event-aware ﬁnite-state automaton (eFSA). eFSA takes advantage of the event-driven nature of CPS control programs
and incorporates event checking in anomaly detection. It detects data-oriented exploits if a speciﬁc physical event is missing along with
the corresponding event dependent state transition. We evaluate our prototype’s performance by conducting case studies under
data-oriented attacks. Results show that eFSA can successfully detect different runtime attacks. Our prototype on Raspberry Pi incurs
a low overhead, taking 0.0001s for each state transition integrity checking, and 0.063s∼0.211s for the cyber-physical contextual
consistency checking.

Index Terms—Cyber-physical systems, Data-oriented attacks, Program anomaly detection, Cyber-physical execution semantics.

(cid:70)

1 INTRODUCTION

C YBER-physical systems (CPS) consist of a tightly coupled

integration of computational elements and physical compo-
nents. The computational elements rely on sensors to monitor
the physical environment and make control decisions to affect
physical processes with feedback loops [2]. These systems are
widely used to operate critical infrastructure assets, such as electric
power grid, oil and natural gas distribution, industry automation,
medical devices, automobile systems, and air trafﬁc control [3].
In the industrial control domain, CPSs are instantiated as the
Industrial Control Systems (ICS), Distributed Control Systems
(DCS), or Supervisory Control and Data Acquisition (SCADA)
systems [4]. Though CPS and IoT (Internet of Things) are deﬁned
with different emphasis and have no standard deﬁnitions agreed
upon by the research community, they have signiﬁcant overlaps.
In general, CPS emphasizes the tightly coupled integration of
computational components and physical world. While IoT has an
emphasis on the connection of things with networks. If an IoT
system interacts with the physical world via sensors/actuators, we
can also classify it as a CPS [5].

The tight coupling with physical space of CPS brings new
security and safety challenges. Control programs running on CPS
devices monitor physical environments by taking sensory data as
input and send control signals that affect physical systems [6].
They are critical to the proper operations of CPS, as anomalous
program behaviors can have serious consequence, or even cause
devastating damages to physical systems [7]. For example, the
Stuxnet [8] attack allows hackers to compromise the control sys-
tem of a nuclear power plant and manipulate real-world equipment
such as centrifuge rotor speeds, which can be very dangerous.

A preliminary version of this work appeared in [1].

According to ICS-CERT’s report [9], there have been continuously
increasing number of cyber attacks targeting critical infrastructure.
Therefore, securing CPS against malicious attacks becomes of
paramount importance in the prevention of potential damages to
physical systems.

Recent studies [7], [10], [11], [12], [13], [14] have shown that
control programs suffer from a variety of runtime software ex-
ploits. These attacks can be broadly classiﬁed into two categories:

• Control-oriented attacks exploit memory corruption vulnerabil-
ities to divert a program’s control ﬂows, e.g., malicious code
injection [15] or code reuse attacks [11]. Control-oriented at-
tacks in conventional cyber systems (i.e., without cyber-physical
interactions) have been well studied [16]. It is possible that
existing detection approaches [17], [18], [19], [20], [21], [22]
are extended to defend against control-oriented attacks in CPS.
• Data-oriented attacks manipulate program’s internal data vari-
ables without violating its control-ﬂow integrity (CFI), e.g.,
non-control data attacks [23], control-ﬂow bending [22], data-
oriented programming [24]. Data-oriented attacks are much
more stealthy than attacks against control ﬂows. Because ex-
isting CFI-based solutions are rendered defenseless under data-
oriented attacks, such threats are particularly alarming. We
mainly focus on runtime software exploits, and thus sensor data
spooﬁng attacks [25], [26] in the physical domain are out of the
scope in this work.

Since many control decisions are made based on particular
values of data variables in control programs [7], data-oriented
attacks could potentially cause serious harm to physical systems in
a stealthy way. We further categorize data-oriented attacks against
control programs into two types. i) Attacks on control branch,

 
 
 
 
 
 
which corrupt critical decision making variables at runtime to
execute a valid-yet-unexpected control-ﬂow path (e.g., allowing
liquid to ﬂow into a tank despite it is full [27] or preventing
a blast furnace from being shut down properly as in the recent
German steel mill attack [28]). ii) Attacks on control intensity,
which corrupt sensor data variables to manipulate the amount of
control operations, e.g., affecting the number of loop iterations to
dispense too much drug [7]).

In many instances, CPS can be modeled as event-driven
control systems [29], [30]. We refer to events as occurrences of
interest that come through the cyber-physical observation process
or emitted by other entities (e.g., the remote controller), and trigger
the execution of corresponding control actions. Defending against
CPS data-oriented attacks is challenging due to the following rea-
sons. First, data-oriented exploits can achieve attack goals without
incurring illegal control ﬂows, thus providing opportunities for
attackers to evade all control ﬂow integrity based detections [24].
Second, CPS programs normally rely on external sensor events to
make control decisions. This physical event-driven nature makes it
difﬁcult to predict runtime program behaviors in CPS. Hence, an
anomaly detection system needs to check the runtime integrity
of program behaviors from both cyber and physical domains.
Unfortunately, there exist very few defenses [7], [31] and they are
ineffective to prevent both attack types due to the lack of runtime
execution semantics checking.

Goals and Contributions. In this paper, we focus on a new
type of runtime attacks that result in inconsistencies between the
physical context/event and program execution, where executed
control ﬂow paths do not correspond to the observed events.
These attacks do not necessarily violate any control ﬂow integrity,
so existing techniques based on control ﬂow checking are not
effective. We point out the need for an event-aware control-
program anomaly detection, which reasons about program behav-
iors with respect to cyber-physical interactions, e.g., whether or
not to open a valve is based on the current ground truth water
level of a tank [27]. None of existing program anomaly detection
solutions [16] has the event-aware detection ability. They cannot
detect attacks that cause inconsistencies between program control
ﬂow paths and the physical environments.

We address the problem of securing control programs against
data-oriented attacks, through enforcing the execution semantics
of control programs in the cyber-physical domain. Speciﬁcally,
our program anomaly detection enforces the consistency among
control decisions, values of data variables in control programs,
and the physical environments. Our main technical contributions
are summarized as follows.
• We describe a new security methodology, named Orpheus, that
leverages the event-driven nature in characterizing CPS control
program behaviors. We present a general method for reasoning
cyber-physical execution semantics of a control program, in-
cluding the event identiﬁcation and event dependence analysis1.
• As an instantiation of Orpheus, we present a new event-aware
ﬁnite-state automaton (eFSA) model to detect anomalous control
program behaviors particularly caused by data-oriented attacks
in CPS. By enforcing runtime cyber-physical execution seman-
tics, eFSA detects subtle data-oriented exploits when physical
event are inconsistent with the corresponding event-dependent
state transitions. While our exposition of Orpheus is on an FSA
model at the system call level, the design paradigm of Orpheus

1. Accompanying materials of this work are available at goo.gl/Wkrdzz

2

can be used to augment many existing program behavior mod-
els, such as the n-gram model [32] or HMM model [33].

• We implement a proof-of-concept prototype on Raspberry Pi
platforms, which have emerged as popular devices for building
CPS applications [7], [34], [35]. Our prototype features: i) A
gray-box FSA model that examines the return addresses on
the stack when system calls are made, and thus signiﬁcantly
increases the bar for constructing evasive mimicry attacks. ii)
An LLVM-based event dependence analysis tool
to extract
event properties from programs and correlate the physical event
with runtime program behaviors, which we refer to as cyber-
physical execution semantics. iii) A near-real-time anomaly
detector using named pipes, with both local and distributed
event veriﬁers to assess the physical context.

• We conduct a thorough evaluation of eFSA’s performance
through real-world CPS case studies. Results show that our
approach can successfully detect different runtime data-oriented
attacks reproduced in our experiments. Our prototype of the
runtime anomaly detector takes ∼0.0001s to check each state
transition in eFSA model, ∼0.063s for the local event veriﬁca-
tion, and ∼0.211s for the distributed event veriﬁcation.

2 BACKGROUND AND ATTACK MODEL
In this section, we introduce the CPS background, and describe
the attack model and assumptions of this work. We use examples
to illustrate our new detection capabilities.

2.1 CPS Background

Fig. 1: An abstract view of the event-driven CPS architecture. CPS
is exposed with a large attack surface and attacks can be launched
across all components in the system.

Fig. 1 shows an abstract view of the CPS system architecture,
which is also in line with the architecture of modern Industrial
Control Systems (ICS). In industrial control domain, the control
program is often referred to as control logic, and the ﬁrmware on
PLC (i.e., ﬁeld device) acts as a kind of operating system [36].
In general, it is composed of the following components: 1) a
physical process (e.g., industrial plant or smart home); 2) sensors
that measure the physical environment; 3) actuators that trig-
ger physical changes in response to control commands sent by
the control program; 4) control programs running on embedded
devices that supervise and control physical processes by taking
sensory data as input and making local control decisions; 5) a
remote control server (which is optional), letting users remotely
monitor and control the physical process. CPS communicates
with the physical process through sensors and actuators, where
physical environments are sensed and events (e.g., coming from
the environment or emitted by other entities) are detected, and
then actuation tasks are executed through a set of actuators.

Embedded devices (a.k.a. ﬁeld devices) in CPS are situated in
the ﬁeld, where their operating systems are typically embedded

SensorsPhysical ProcessActuatorsEventsControl Programs on Field DevicesCPS Control CenterElectrical distribution, manufacturing, industrial control, automobile systems, …EmbeddedLinux, PLC firmware, …Breakers, switches,pumps, motors, valves, …Local ControlLinux/Windows variants [37] or PLC ﬁrmware [36]. Traditionally,
embedded control systems were not considered prominent attack
targets due to their isolation from potential attack sources. How-
ever, the historical isolation has begun to break down as more and
more embedded devices are connected to business networks and
the Internet in the trend of IoT, making CPS control programs
increasingly vulnerable [37].

2.2 Attack Model and Assumptions

In this paper, we make the following security assumptions:
• Capabilities of the adversary. We assume that the adversary
has successfully authenticated CPS ﬁeld devices (or the control
server) under her control to the local network, and is able
to launch runtime software exploits which may be unknown
or known but unpatched at the time of intrusion. We are not
concerned how attackers gained entry into the devices and
launch different attacks, but focus on uncovering abnormal
program execution behaviors after that [21]. This is a typical
assumption in existing anomaly detection works.

• CPS platform. We assume the initial state (i.e., the training
stage) of the application is trustworthy, which is a general
requirement of most behavior-based intrusion detection sys-
tems [31]. We also assume the runtime monitoring module (run-
ning on the host) is trusted and cannot be disabled or modiﬁed.
This assumption is reasonable because it can be achieved by
isolating the anomaly detector (monitoring module) from the
untrusted target program with hardware security support such
as Intel’s TrustLite or ARM’s TrustZone [7]. At the time of
detection, the user space is partially or fully compromised, but
the operating system space has not been fully penetrated yet,
and thus it is still trusted [10].

• Our focus. We focus our investigation on runtime software
exploits, and thus sensor data spooﬁng attacks in the physical
domain [26] are out of the scope. We assume sensor mea-
surements are trustable. We limit our attention to data-oriented
attacks that involve changes of system call usage. Other data-
related attacks that do not impact observable program behavior
patterns (e.g., modiﬁcation of non-decision making variables)
are beyond the scope of this work. System call can be used
as an ideal signal for detecting potential intrusions, since a
compromised program can generally cause damage to the victim
system only by exploiting system calls [38]. Despite system call
based monitoring is widely used for detecting compromised pro-
grams, we aim at developing a CPS-speciﬁc anomaly detection
system by augmenting an existing program behavior model with
physical context awareness.

2.3 New Detection Capabilities

Our new detection capability is detecting data-oriented attacks
in CPS control programs, including hijacked for/while-loops or
conditional branches. These stealthy attacks alter the underly-
ing control program’s behaviors without tampering control-ﬂow
graphs (CFGs). We illustrate our new detection capabilities using
a smart syringe pump as an example 2. The control program reads
humidity sensor values as well as takes remote user commands,
and translates the input values/commands into control signals to its
actuator. Partial code is shown in Listing 1. Suppose a stack buffer
overﬂow vulnerability exists in the recvRemoteCommand()

2. https://hackaday.io/project/1838-open-syringe-pump

3

function (line 3). When the vulnerable function is invoked, an
attacker is able to corrupt the sensor variables (e.g., pressure,
temperature, and humidity) in the program. Our approach
reasons about control programs’ behaviors w.r.t physical environ-
ments, and is able to detect the following attacks:

• Attacking control branch. An attack affecting the code in
lines 5 and 7 of Listing 1 may trigger push-syringe or
pull-syringe regardless of physical events or remote re-
quests. It corrupts control variables that result in event function
push_event or pull_event returning True. Such an
attack leads to unintended but valid control ﬂows.

• Attacking control intensity. An attack may directly or indirectly
corrupt a local state variable (e.g., steps in line 18 of List-
ing 1) that controls the amount of liquid to dispense by the
pump. Such an attack may cause the syringe to overpump than
what is necessary for the physical system. Range-based anomaly
detection would not work, as the overwritten variable may still
be within the permitted range but incompatible with the current
physical context. Such an attack (i.e., manipulating the control
loop iterations) does not violate the program’s CFG either.

1 void loop(...) {
2

readSensors(&pressure,&temperature,&humidity);

3 (cid:13) recvRemoteCommand();/*buffer overflow

vulnerability*/

4

...

5 A if(push_event()==True)/*Attack control branch*/

push_syringe();

6
7 A else if (pull_event()==True)
8
9 }
10 bool push_event() {
11

pull_syringe();

//decide whether push_event is triggered
if(humidity>HUMIDITY_THRESHOLD)

12

13

return True;

return False;

14
15 }
16 void push_syringe() {
17
18 A steps=humidity-HUMIDITY_THRESHOLD;
19

//calculate the steps value

for(int i=0; i<steps; i++){/*Attack control

intensity*/
digitalWrite(motorStepPin,HIGH);
delayMicroseconds(usDelay);
digitalWrite(motorStepPin,LOW);

20

21

22

}

23
24 }

Listing 1: Examples of data-oriented attacks in a simpliﬁed
smart syringe pump application. An attacker could purposely
(a) trigger control actions by manipulating the return value
of push_event or pull_event, and (b) manipulate
the number of loop iterations in push-syringe without
violating the control program’s CFG.

Existing solutions cannot detect these attacks, as the detection
does not incorporate events and cannot reason about program
behaviors w.r.t. physical environments. C-FLAT [7], which is
based on the attestation of control ﬂows and a ﬁnite number of
permitted execution patterns, cannot fully detect these attacks.
Similarly, recent frequency- and co-occurrence-based anomaly
detection approaches (e.g., global trace analysis [39] and system
call frequency distribution (SCFD) [31]) cannot detect such either
type of attacks, as their analyses do not model runtime cyber-
physical context dependencies.

4

Fig. 2: Workﬂow of Orpheus event-aware anomaly detection framework, which augments an existing program behavior model with
cyber-physical contextual integrity.

2.4 Deﬁnition of Events

Without loss of generality, we deﬁne two types of events in control
programs: binary events and control-intensity events. In this work,
the physical context refers to these physical events that trigger a
particular execution path in a CPS program.
• Binary events return either True or False, which are deﬁned
in terms of pre-speciﬁed status changes of physical environ-
ments and provide notiﬁcations to the control program (e.g.,
push_event or pull_event in Listing 1). Note that though
sensor values such as temperature or humidity have continuous
attributes that would lead to a large input space, binary events
have a binary outcome which indicates a pre-speciﬁed status
change is triggered. Such events are commonly pre-deﬁned
and used in CPS/IoT’s trigger-action programming ("if, then")
model [30], [40].

• Control-intensity events correspond to the sensor-driven control
actions within a for/while loop, e.g., sensor values affect the
amount of control operations of push-syringe in Listing 1.
is
We consider each loop iteration as a discrete event. It
challenging to identify control-intensity events since they are
not explicitly declared in control programs. We present a general
event identiﬁcation method in Sec. 4.1.

3 Orpheus ANOMALY DETECTION FRAMEWORK

3.1 Motivation

Runtime software attacks by exploiting memory corruption vul-
nerabilities constitute a major attack vector against CPS [41] [42].
This is because, low-level memory-unsafe languages (e.g., C/C++)
are widely used in embedded systems for speed performance
purposes. As launching control-oriented attacks become increas-
ingly difﬁcult due to many deployed defenses against control-ﬂow
hijacking, data-oriented attacks are considered an appealing attack
technique for system compromise.

Data-oriented attacks can purposely change the underlying
CPS program behaviors and drive the system to unexpected states
in a stealthy way, and thus posing a serious security threat to CPS.
From the example in Listing 1, we observe that runtime control
ﬂows of CPS program are dependent on the external physical
context. A data-oriented attack could lead to an inconsistency
between the physical context and program control ﬂow. This mo-
tivates us to leverage the intrinsic physical context dependency in
CPS control programs as a channel to detect anomalous program
behavior in CPS. Our key idea is to enforce physical context
constraints over existing program behavior models, and check

the consistency between runtime program behavior and external
execution semantics.

3.2 Design Overview

Fig. 2 shows the workﬂow of Orpheus event-aware anomaly
detection framework, which is a learning-based program anomaly
detection and composed of two stages: training/learning (where
program behavior models are built based on normal program
traces) and monitoring/testing (where a new trace is compared
against the model built in the training phase). In particular, to cap-
ture the cyber-physical context dependency of control programs,
the training stage in Orpheus encompasses both static program
analysis and dynamic proﬁling.

There are four main steps in the training phase. In step (cid:172)
(Sec. 4.1), Orpheus identiﬁes both binary events and control-
intensity events involved in the control program. In step (cid:173)
(Sec. 4.2), it performs the program dependency analysis to gen-
erate event-annotated CFG, which identiﬁes the instructions/state-
ments associated with binary events, and control-intensity loops
associated with control-intensity events. In step (cid:174) (Sec. 5.1),
Orpheus constructs the normal program behavior model either
based on static analysis or dynamic proﬁling, which we refer to
as a basic program behavior model in Orpheus. The next step (cid:175)
(Sec. 5.2) is important. It augments the basic model with event
constraints and obtains the event-aware program behavior model.
Steps (cid:176) and (cid:177) are the monitoring phase (Sec. 6). In step (cid:176),
the anomaly detector (which can be located in the secure world
in ARM TrustZone to provide a trusted execution environment
for trace collection [7] [43]) monitors the program’s execution
and collects runtime traces. The basic program behavior model
normally aims at detecting control-oriented attacks. Our main
contribution lies in the event awareness enhancement on top of
the basic model. In the monitoring phase, whenever an event-
dependent control-ﬂow path is encountered in step (cid:177), the event
veriﬁer checks the consistency between runtime behavior and pro-
gram execution semantics, e.g., whether a speciﬁc physical event
associated with an event-dependent control-ﬂow path is observed
in the physical domain. An anomaly is marked if there exists any
deviation from the normal behavior model, or a mismatch between
the physical context and program control-ﬂow path.

3.3 Program Behavior Model Choices

Program behavior modeling has been an active research topic
over the past decade and various models have been proposed
for legacy applications [16]. Existing models can be classiﬁed

EventAugmentationControl ProgramTraining PhaseEvent IdentificationEvent Dependence Analysis13254Event-aware Behavior Model 13254Monitoring PhaseAbnormalNormalRun-time Tracing1Event VerifierProgram Behavior Modelling,e.g., FSA, HMM, n-gram.234AnomalyDetectorEvent Verification65into two categories: i) local model (e.g., n-gram model [32],
hidden markov model (HMM) based approach [33], ﬁnite-state
automaton (FSA) model [44]); and ii) long-range model (e.g., fre-
quency distribution based models [31], [39], [45]). Local anomaly
detection inspects short-range segments of program execution
traces to detect anomalies such as control-ﬂow violations. Long-
range anomaly detection examines longer system behaviors (e.g.,
a complete program behavior instance) than the local anomaly
detection, which can detect frequency anomalies. Among these
models, system-call based monitoring is widely used for detecting
compromised programs, in comparison to library/function-calls.

N-gram based model deﬁnes the normal program behavior for
a process by using short sequences of system-calls. In the training
phase, it builds a n-gram database by sliding a window of length
n over the system-call traces of normal program executions. An
anomaly is detected if a new n-gram is observed in the testing
sequence (i.e., test for membership in the database). Although
short-range ordering of system-calls have a high probability of
being perturbed when abnormal activities occur, it is vulnerable to
mimicry attacks [46]. An attacker may insert a malicious code,
issuing system-calls accepted by a normal behavior model yet
still carries out the same malicious action. Instead of using short
sequences and being limited by length, state-based models use
ﬁnite state machine (FSM) to express possible sequences, where
the PC information (i.e., program counters which are the return
addresses of system-calls) are often used in these models.

The design paradigm of Orpheus is to augment physical event
constraints on top of an existing program behavior model. For
example, automaton/state-based models can be enhanced with
event checking on event-dependent state transitions. For the n-
gram model [32], we identify event-dependent n-grams in the
training phase and apply the event checking when observing any
event-dependent n-gram in the monitoring phase. In addition,
control-ﬂow integrity [18], [35] can also be augmented with event
checking before executing control ﬂow transfers. We leave the
option of choosing the underlying basic program behavior model
open to system developers, which may depend on the speciﬁc re-
source constraints on CPS platforms. For example, compared with
the n-gram model, tracing PC information in FSA/HMM during
program execution incurs an extra runtime overhead, which we
will demonstrate in Sec. 8. We instantiate the Orpheus framework
using the FSA model [44] in Sec. 5.

4 REASONING ABOUT CYBER-PHYSICAL EXECU-
TION SEMANTICS

In this section, we present a general method for reasoning about
cyber-physical execution semantics of a control program through
static analysis, including the event identiﬁcation and dependence
analysis.

4.1 Event Identiﬁcation

In order to discover the triggering relationship between external
events and internal program control ﬂows, we ﬁrst identify what
events are involved in a control program. For pre-deﬁned binary
events, it is not difﬁcult to identify these events (e.g., given event
functions declared in an event library or header ﬁle, we scan the
source code or executable binary). The main challenge is to iden-
tify: i) control intensity events/loops, and ii) non-predeﬁned binary
events. Our LLVM-based [47] event identiﬁcation algorithm can

automatically extract these events and only requires knowledge of
sensor-reading APIs and actuation APIs on the embedded system.
They are pre-speciﬁed sources and sinks3 in our static analysis.

5

Algorithm 1: Identifying control-intensity events

1 Input: Program P ; Sensor-reading API set AP Isens;

Actuation API set AP Iactu

2 Output: Control-intensity event/loop set Eci

3 Eci ← ∅;
4 Gpdg = ConstructPDG(P ) /*construct the program dependence

graph*/;

5 LoopBrSet = getLoopBranchSet(P ) /*get all the conditional

branch instructions with loops*/;

6 for BranchInst=getNextInst(LoopBranchSet) do
7

Sbdd = BackwardDataDependence(Gpdg, BranchInst);
/*Backward data dependent statements on BranchInst*/;
Sf cd = ForwardControlDependence(Gpdg, BranchInst);
/*Forward control dependent statements on BranchInst*/;
if (Sbdd ∩ AP Isens (cid:54)= ∅ & Sf cd ∩ AP Iactu (cid:54)= ∅) then

Eci= Eci∪ Event(BranchInst,Sbdd,Sf cd);

8

9

10

11

12
13 end

According to the deﬁnition of a control-intensity event in
Sec. 2.1, it contains a loop statement (e.g., for/while loop) in
which sensor values affect the amount of control operations. Our
key idea is to search for a loop statement that is data-dependent
on any sensor-reading API, and at least an actuation API is
control-dependent on this loop statement. The search is performed
through backward data dependence analysis and forward control
dependence analysis. Algorithm 1 describes our static analysis
for identifying control-intensity events. We ﬁrst obtain the LLVM
Intermediate Representation (IR) of a control program P using
the Clang compiler [47], and construct the program dependence
graph (PDG), including both data and control dependencies (Line
4). The control dependence graph is at the basic block level4, while
the data dependency graph is at the granularity of instructions.
Then, we obtain all conditional branch instructions with loops,
by searching the conditional "br" instruction, which takes a single
"i1" value and two "label" values in LLVM IR (Line 5). For each
conditional branch with a loop, we conduct the backward inter-
procedural dataﬂow analysis to ﬁnd any prior data dependence
on sensor-reading APIs (Line 7). Then, we conduct the forward
inter-procedural control-dependence analysis on the true branch
of the conditional instruction to ﬁnd actuation APIs, e.g., APIs in
WiringPi library or functions writing GPIO pins [49] (Line 9). If
a loop statement is data-dependent on external sensor data, and
triggers a certain control action, we identify a control-intensity
event/loop (Line 11). In each iteration, we record the identiﬁed
control-intensity event and control intensity loop (Line 12), which
is the output of the event identiﬁcation process.

A more speciﬁc example of our event identiﬁcation is illus-
trated in Fig. 3 corresponding to the C-based control program
in Listing 1. The ﬁgure shows a control-intensity event/loop
represented by LLVM IR after the data dependence and control
dependence analysis ((cid:182)). We then locate a conditional branch in-
struction with a loop ((cid:183)). This conditional branch uses the variable
steps, which is data dependent on a sensor-reading API ((cid:184)). On
its true branch, we ﬁnd an actuation API digitalWrite and
thus we identify the loop as a control-intensity event ((cid:185)).

3. Source and sink are terms in a dataﬂow/taint analysis. The source is where

data comes from, and the sink is where it ends in a program [48].

4. In program analysis, a basic block is a linear sequence of instructions

containing no branches except at the very end.

Algorithm 2: Event dependence analysis for binary events

1 Input: Event-triggered basic block BBeta; Control ﬂow graph

Gcf g of program P ;

6

2 Output: Eb: events that trigger the execution of BBeta
3 Eb ← ∅;
4 BBcur = BBeta;
5 Function FindEventDependence (BBcur, Gcf g, Eb)
6

for BBtmp= getNextBB(Gcf g) do
if (BBtmp.toid == BBcur) then

Etmp=extractEvent(BBtmp) ;
if Etmp (cid:54)= ∅ & Eb ∩ Etmp = ∅ then

Eb= Eb ∪ Etmp;
BBcur = BBtmp;
FindEventDependence (BBcur, Gcf g, Eb);

end
return;

7

8

9

10

11

12

13

14

Fig. 4: Event dependence analysis for nested events

identiﬁes statements triggered by a particular event during multiple
rounds of program executions. It is worth mentioning that our
event identiﬁcation and dependence analysis is a general approach
for reasoning cyber-physical execution semantics, independent of
speciﬁc program anomaly detection models.

5 eFSA: AN INSTANTIATION OF Orpheus

In this section, we describe details about how to build the event-
aware ﬁnite-state automaton (i.e., eFSA) model, a system call level
FSA-based instantiation of the Orpheus framework. eFSA captures
the event-driven feature of CPS programs to detect evasive attacks.

5.1 Formal Description of eFSA

We construct the ﬁnite-state automaton (FSA) [44] model, which
is based on tracing the system calls and program counters (PC)
made by a control program under normal execution. Each distinct
PC (i.e., the return address of a system call) value indicates a
different state of the FSA, so that invocation of same system
calls from different places can be differentiated. Each system
call corresponds to a state transition. Since the constructed FSA
uses memory address information (i.e., PC values) in modeling
program behaviors (called the gray-box model), it is more resistant
to mimicry attacks than other program models [16], [51].

In an execution trace, given the kth system call Sk and
the PC value pck from which Sk was made, the invocation of
Sk results in a transition from the previous state pck−1 to pck
which is labeled with Sk−1. Fig. 5(a) shows a pictorial example
program corresponding to Listing 1 at the system-call level, where
system-calls are denoted by S0,. . . ,S6, and states are represented

Fig. 3: An example of identifying control-intensity events

We also design a similar procedure for identifying non-pre-
deﬁned binary events. An example of such event is when the hu-
midity exceeds a user-designated value, an event predicate returns
True. In this procedure, we search for the conditional branch
either "br" or "switch" instruction without a loop, and then perform
the same data/control dependence analysis. In particular, we need
to analyze both true and false branches of a "br" instruction,
because both branches may contain control actions and we also
consider the not-happening case (i.e., the branch without triggering
any control action) as an implicit event.

4.2 Event Dependence Analysis

Our event dependence analysis generates an event-annotated CFG,
i.e., approximating the set of statements/instructions that connect
events and their triggered actions. During the event identiﬁcation,
we identify individual events that are involved in a control pro-
gram. For the control-intensity event/loop, we directly associate it
with the whole loop that contains the sensor-driven control action.
A challenge arises when dealing with nested binary events. We
address the nested events challenge using a bottom-up approach
for recursive searching for event dependencies.

Algorithm 2 describes our event dependence analysis for
nested binary events. Given a binary-event triggered basic block
BBeta, we backward traverse all its control dependent blocks until
reaching the root in a recursive manner, and extract corresponding
branch labels (i.e., True or False). In the recursive function
FindEventDependence (Line 5), once we ﬁnd a basic block
on which BBcur is control dependent (Line 7), we check whether
it contains any external event (Line 9). If yes, we add this event
together with its branch label to Eb (Line 10). The condition
Eb ∩ Etmp = ∅ avoids potential loops when including new events
into Eb. Then, we recursively search any upstream event that
BBcur depends on (Line 12).

Fig. 4 illustrates an example of our event dependence analysis
corresponding to Listing 1. Block 7 (i.e., the basic block with
label 7) is control dependent on Block 4 in the True branch
of pull_event (called true-control-dependent). By backward
traversing the control dependence graph, we ﬁnd Block 4 is
further false-control-dependent on push_event in Block 0.
Then, we know Block 7 is control dependent on a composite event
[push_event∧pull_event]. In this example, we also ﬁnd Blocks
3 control dependent on push_event, and Block 9 is control
dependent on [push_event ∧ pull_event]. We ﬁnally identify
three event-dependent basic blocks, and obtain the corresponding
event-annotated CFG.

In addition to the static analysis approach, an alternative for
event dependence analysis is using dynamic slicing [50], which

<label>:9call void @digitalWrite(i32 6, i32 1)......%6 = load i32* %i, align 4%7 = load i32* @steps, align 4%8 = icmpslti32 %6, %7bri1 %8, label %9, label %14TF<label>:14ret voidAny sensor reading API Data dependenceAny actuation API LoopControl dependence❶❷❸❹❷❸Locating conditional branch instruction Backward data dependence analysisForward control dependence analysisConstructing PDG ❹<label>:0        ...%1 = call i32 @push_event()%2= icmpne i32 %1, 0bri1 %2, label %3, label %4<label>:4%5= call i32 @pull_event()%6= icmpne i32 %5, 0bri1 %6, label %7, label %9TF<label>:3 call void @push_syringe()<label>:9…TF<label>:7call void @pull_syringe()!"#ℎ_&'&()⋀!"++_&'&()dependent	!"#ℎ_&'&()dependent	!"#ℎ_&'&()⋀!"++_&'&()dependent	by integers (i.e., line numbers). Suppose we obtain three exe-
cution sequences, S0
S6
11 , S0
S6
11 , and
1
S6
S6
S0
11 , the learnt FSA model is shown in Fig. 5(b),
11
1
where each node represents a state and each arc represents a state
transition.

S5
10

S5
10

S5
10

S5
10

S3
7

S2
6

S2
6

S4
9

S1
3

S1
3

S3
7

S1
3

S1
3

S4
9

1

Fig. 5: System-call based ﬁnite-state automaton (FSA) model: (a)
the example program of Listing 1 at the system-call level; (b) the
corresponding FSA model.

Our eFSA model extends FSA with external context con-
straints, where event-dependent state transitions in FSA are la-
beled with event constraints. We formally deﬁne the eFSA model
as a six-tuple: (S, Σ, s0, F, E, δ). S is a ﬁnite set of states which
are PC values, and Σ is a ﬁnite set of system calls (i.e., input
alphabet). s0 is an initial state, and F is the set of ﬁnal states.
E represents a ﬁnite set of external events, which can affect the
underlying execution of a control program. δ denotes the transition
function mapping S ×Σ×E to S. Note that a state transition may
come with multiple physical events (referred to as a composite
event). Thus, the input alphabet can be expressed as a cartesian
product: E = E1 × E2 × · · · × En, where the input E consists of
n concurrent physical events. In particular, we consider the non-
occurrence (not-happening) of one or more events as an implicit
event in eFSA.

Fig. 6: An example of the eFSA model, where E1 represents
push_event, E2 represents pull_event, and CIL represents
the control-intensity event/loop.

P C

Fig. 6 shows an example of eFSA model corresponding to the
FSA example in Fig. 5, where an event dependent transition is
labeled by "[ System Call
]|Events". In this example, there are two
binary events and one control-intensity event. Through the event
dependence analysis, we identify that lines 5-7 (where S2 and S3
are invoked) and line 9 (where S4 is invoked) are dependent on the
binary events E1 and E2, respectively. To avoid redundancy, we
associate a binary event to the ﬁrst state transition in FSA that is
dependent on it. In Fig. 6, we identify binary-event dependent state
transitions [ S1
6 ]|E1, [ S1
S2
S4
9 ]| E1 ∧ E2, and a control-intensity-
3
event dependent control intensity loop [ S2
S3
7 ]|CIL. It also con-
6
S5
tains an implicit event dependent transition [ S1
10 ]|(E1 ∧ E2).
3

3

7

5.2 From Event-Annotated CFG to eFSA

To construct an eFSA model, we need to identify event-dependent
state transitions at the system call level in FSA. Towards this
end, we apply the event dependence analysis results (described
in Sec. 4.1 and 4.2) to transform instruction-level dependencies
in LLVM IR to the state transition dependencies in FSA. Such a
mapping might be achieved through static analysis, e.g., passing
over the parse tree to search for system call invocations. How-
ever, a static analysis based approach requires the modiﬁcations
of gcc compiler or system call stubs, and even requires hand-
crafted modiﬁcations for library functions [52], [53]. In eFSA,
we adopt a dynamic proﬁling based approach to discover event
dependent state transitions. We ﬁrst transform instruction-level
event dependencies in LLVM IR to statement-level dependencies
in source code with line numbers. Then, we map line numbers
and ﬁle names to return addresses (e.g., by using the addr2line
tool) that are collected in the dynamic proﬁling phase when the
FSA model is constructed. In this way, we obtain the system call
level event-dependent state transitions in FSA. Subsequently, we
augment the event-driven information over the underlying FSA,
and ﬁnally construct the eFSA model.

5.3 Security Policies in eFSA

eFSA expresses causal dependencies between physical events and
program control ﬂows. By checking execution semantics (i.e.,
enforcing cyber-physical security policies) at runtime, eFSA im-
proves the robustness against data-oriented attacks by increasing
the difﬁculties that an attack could bypass the anomaly detection.
For state transitions that are dependent on binary events, the
cyber-physical policy enforcement is to make sure the return
values of binary events reﬂects the ground truth sensor measure-
ments. For control intensity loops that are dependent on control-
intensity events, our approach is based on the control intensity
analysis, which models the relationship between the observable
information in cyber space (i.e., system-calls) and sensor values
in physical space. eFSA then enforces the policy that the observed
control intensity should be consistent with the trend of sensor
value changes.

5.4 Control Intensity Analysis

The main challenge for detecting runtime control intensity anoma-
lies lies in that, given system call traces of a control program,
we need to map the control
intensity to its reﬂected sensor
measurements, where only the number of loop iterations in a
control intensity loop is available. To this end, we ﬁrst obtain
the number of system calls invoked in each loop iteration. Then,
we model the relationship between sensor measurements and the
amount of system calls in a control intensity loop through a
regression analysis.

Execution Window Partitioning and Loop Detection: Typically,
control programs monitor and control physical processes in a
continuous manner, where the top-level component of a program
is composed of an inﬁnite loop. For instance, an Arduino pro-
gram [54] normally consists of two functions called setup()
and loop(), allowing a program consecutively controls the
Arduino board after setting up initial values. We deﬁne an ex-
ecution window as one top-level loop iteration in a continuous
program, and a behavior instance as the program activity within
an execution window. The term execution window is equivalent
to the scan cycle in industrial control domain [34]. We partition

S0;while(…){S1;if(push_event())for(…humidity…){S2; S3;}else if(pull_event())for(…){S4;}S5;S6;}13246578109396S3S0S1S1S51S6S211S4S0,…,S6denote system calls(a)(b)71110S3S1Binary eventControl-intensityloopBinary eventS4396S3S0S1S1S51S6S211S4710S3S4S1!"#!$%|CILinﬁnite execution traces into a set of behavior instances based on
the execution window. The underlying FSA model helps identify
loops since it inherently captures program loop structures. We ﬁrst
identify the starting state in the top-level loop of a FSA. Then,
once a top-level loop back edge is detected, a behavior instance is
obtained.

Regression Analysis: The purpose of the regression analysis
is to quantify the relationship between sensor measurements and
system call amount in a control intensity loop. Given the number
of system calls invoked in each loop iteration, one straightforward
approach is through manual code analysis. In this work, we present
an approach for automating this process. During the identiﬁcation
of control-intensity events in Sec. 4.1, we know what sensor types
(i.e., sensor reading APIs) are involved in a control intensity
loop. In the training phase, we collect normal program traces
together with the corresponding sensor values. Then, we perform
a simple regression analysis to estimate the relationship between
the system call amount (i.e., outcome) and sensor measurements
(i.e., explanatory variables) for each control intensity loop. For
example, suppose a control intensity loop is triggered by the
change of humidity sensor value (details are in Sec. 8.4). We
observe that an increase of humidity results in more iterations
of the control intensity loop, where each loop iteration incurs 3
system calls. Thus, we can reversely derive the changes of physical
environment by observing the number of iterations in a control
intensity loop.

6 EFSA-BASED DETECTION

In this section, we present how an eFSA-based anomaly detector
detects anomalies particularly caused by data-oriented attacks, and
discuss about the design choices of event veriﬁcation.

6.1 Runtime Monitoring and Detection

Fig. 7: eFSA-based anomaly detection

Our anomaly detector traces system calls as well as the cor-
responding PC values during the execution of a control program.
As shown in Fig. 7, the anomaly detection is composed of an
event veriﬁer and two checking steps: i) state transition integrity
checking against the basic FSA model, and ii) event consistency
checking against the event veriﬁcation in the eFSA-based anomaly
detector, which is our new contribution.
• Event-independent state transition. For each intercepted sys-
tem call, we check if there exists an outgoing edge labelled
with the system call name from the current state in FSA. If
not, an anomaly is detected. If the current state transition is not
event-dependent, we move the current state of the automaton
to the new state. This basic state-transition checking has been
shown to be effective against common types of control-oriented
attacks (e.g., code injection attacks or code-reuse attacks [15])
which violate control ﬂow integrity of the model.

8

• Event-dependent state transition. In case of an event de-
pendent state transition according to the eFSA model, we ﬁrst
perform the above basic state-transition checking. More im-
portantly, with the help of the event veriﬁcation (discussed in
Sec. 6.2), we then check the consistency between the runtime
execution semantics and program’s behavior, i.e., whether a
speciﬁc physical event associated with this event-dependent
state transition is observed in the physical domain. This step
can detect stealthy data-oriented attacks that follow valid state
transitions but are incompatible with the physical context. An-
other important aspect is the selection of event checkpoints. To
avoid redundant checking, we set the checkpoint for a binary
event at its ﬁrst event-dependent state transition. For a control-
intensity event, we perform the event checking after it jumps
out of the control intensity loop.

6.2 Event Veriﬁcation Strategies

The objective of event veriﬁcation is to detect event spooﬁng
caused by runtime data-oriented software exploits. Event veriﬁ-
cation is highly application speciﬁc, and it is actually orthogonal
to the eFSA model itself. We describe several possible approaches
for verifying physical context.
• Local event veriﬁcation: which is able to detect the inconsis-
tency between program runtime behavior and cyber-physical
execution semantics. For example, the monitor re-executes a
binary-event function to conﬁrm the occurrence of the event. To
detect control intensity anomalies, the monitor retrieves sensor
measurements and compares them against the derived sensor
values from system call traces. There may exist false posi-
tives/negatives due to sensor’s functional failures in practice.
• Distributed event veriﬁcation: which assesses the physical
context by exploiting functionally and spatially redundancy
of sensors among co-located embedded devices. Since sensor
data normally exhibit spatio-temporal correlation in physical
environments, it increases the detection accuracy by involving
more event veriﬁcation sources.

• Physical model based veriﬁcation: which is complementary
to the runtime event veriﬁcation. Cyber-physical inconsistency
may be detected based on physical models [55]. For example,
one may utilize ﬂuid dynamics and electromagnetics as the
basic laws to create prediction models for water system [56]
and power grid [57]. Based on the prediction models and
predeﬁned threat constraints, these methods can then check
whether the predicted environment values are consistent with
a control system’s behavior.

7 IMPLEMENTATION

To demonstrate the feasibility of our approach, we have imple-
mented a prototype with around 5K lines in C/C++, Bash and
Python codes, including the trace collection and preprocessing,
event identiﬁcation and dependence analysis, eFSA model con-
struction, and runtime anomaly detection modules. Our prototype
uses multiple off-the-shelf tools and libraries in Linux.

We choose Raspberry Pi 2 with Sense HAT as the main
experimental platform, which is a commonly used platform for
building embedded control applications [7], [34], [35]. Sense Hat,
an add-on board for Raspberry Pi, provides a set of environmental
sensors to detect physical events including pressure, temperature,
humidity, acceleration, gyroscope, and magnetic ﬁled. During the

Event VerifierUnknown Program TracesState Transition CheckingEvent Consistency CheckingLocal verificationDistributed verificationDetect control-based anomaliesDetect execution semantic anomaliesNormalPhysical model training phase, we collect program traces on Raspberry Pi and
perform the eFSA model construction on a Linux Desktop (Ubuntu
16.04, Intel Xeon processor 3.50GHz and 16GB of RAM). In the
monitoring phase, the anomaly detector is deployed on Raspberry
Pi to detect runtime control-based or data-oriented attacks. In
the following, we present key implementation aspects in our
prototype.

Dynamic Tracing. We use the system tool strace-4.13 to
intercept system call of a running control program. To obtain the
PC value from which a system call was invoked in a program, we
need to go back through the call stacks until ﬁnding a valid PC
along with the corresponding system call. We compile strace
with -libunwind support, which enables stack unwinding and
allows us to print call stacks on every system call.

Event Identiﬁcation and Dependence Analysis. Our event
identiﬁcation and dependence analysis tool is implemented within
the Low Level Virtual Machine (LLVM)5 compiler infrastructure,
based on an open source static slicer6 which builds dependence
graph for LLVM bytecode. An advantage of using LLVM-based
event dependence analysis is that, our tool is compatible with
multiple programming languages since LLVM supports a wide
range of languages. Our event identiﬁcation module identiﬁes the
line numbers in source code where an event is involved. Then,
the event dependence analysis outputs the line numbers of event
dependent statements.

Anomaly Detector with Event Veriﬁcation. In our prototype,
we implement a proof-of-concept near-real-time anomaly detector
using named pipes on Raspberry Pi, including both local and
distributed veriﬁcations (corroboration with single or multiple
external sources). We develop a sensor event library for Raspberry
Pi Sense Hat in C code, based on the sensor reading modules
in experix7 and c-sense-hat8. The event
library reads
pressure and temperature from the LPS25H sensor, and reads
relative humidity and temperature from the HTS221 sensor, with
maximum sampling rates at 25 per second. Our local event veriﬁer
calls the same event functions as in the monitored program, and lo-
cally check the consistency of event occurrence. In the distributed
event veriﬁer, we deploy three Raspberry Pi devices in an indoor
laboratory environment. We develop a remote sensor reading
module which enables one device to request realtime sensor data
from neighbouring devices via the sockets communication.

8 EXPERIMENTAL VALIDATION

We conduct CPS case studies, and evaluate eFSA’s detection
capability against runtime data-oriented attacks. Our experiments
aim to answer the following questions:

• What is the runtime performance overhead of eFSA, including
the model training overhead, system-call tracing overhead and
detection latency (Sec. 8.2)?

• Whether eFSA is able to detect different data-oriented attacks

(Sec. 8.3 and 8.4)?

• How feasible is the event-aware n-gram model as an alternative
instantiation of the Orpheus framework (Sec. 8.5)? Whether
eFSA can be generalized to detect network event injection
attacks (Sec. 8.6)?

5. http://llvm.org/
6. https://github.com/mchalupa/dg
7. http://experix.sourceforge.net/
8. https://github.com/davebm1/c-sense-hat

9

8.1 CPS Case Studies

Solard9. It is an open source controller for boiler and house
heating system that runs on embedded devices. The controller
collects data from temperature sensors, and acts on it by con-
trolling relays via GPIO (general purpose input/output) pins on
Raspberry Pi. Control decisions are made when to turn on or off
of heaters by periodically detecting sensor events. For example,
CriticalTempsFound() is a pre-deﬁned binary event
in
Solard. When the temperature is higher than a speciﬁed threshold,
the event function returns True.
SyringePump10. It was developed as an embedded application for
Arduino platform. Abera et al. [7] ported it to Raspberry Pi. The
control program originally takes remote user commands via serial
connection, and translates the input values into control signals
to the actuator. SyringePump is vulnerable since it accepts and
buffers external inputs that might result in buffer overﬂows [7]. We
modify the syringe pump application, where external inputs are
sent from the control center for remote control, and environmental
events drive the pump’s movement. Speciﬁcally, in the event that
the relative humidity value is higher than a speciﬁed threshold, the
syringe pump movement is triggered. In addition, the amount of
liquid to be dispensed is linearly proportional to the humidity value
subtracted by the threshold. Such sensor-driven syringe pumps are
used in many chemical and biological experiments such as liquid
absorption measurement experiment.

8.2 Training and Runtime Performance

In the training phase, we collect execution traces of Solard and
SyringePump using training scripts that attempt to simulate pos-
sible sensor inputs of the control programs. By checking Solard
and SyringePump’s source codes, our training scripts cover all
execution paths.

We ﬁrst measure the time taken for training models in our
prototype, where the main overhead comes from the event de-
pendence analysis. Table 1 illustrates eFSA’s program analysis
overhead in the training phase. For comparison purpose, we deploy
the LLVM toolchain and our event dependence analysis tool on
both Raspberry Pi and Desktop Computer (Intel Xeon processor
3.50GHz and 16GB of RAM). From Table 1, Raspberry Pi takes
much longer time (more than 150 times) than desktop computer
to complete the program dependence analysis task. It only takes
0.745s and 0.0035s for event dependence analysis of Solard (46.3
kb binary size) and SyringePump (17.7 kb binary size) on a
desktop computer, respectively. Since Solard and SyringePump
run in a continuous manner and thus generate inﬁnite raw traces.
The model training overhead is measured by how much time
it takes for training per MByte raw trace. Results show that it
takes less than 0.2s to process 1 MByte traces on the desktop
computer. The number of states in Solard’s and SyringePump’s
eFSA is 34 and 65, respectively (not including system-calls in the
initialization before entering the main function).

Solard
SyringePump

Event Dependence Analysis

Desktop Computer
0.745s
0.0035s

Raspberry Pi 2
109.975s
1.726s

TABLE 1. Average delay overhead in training phase

9. https://github.com/mrpetrov/solarmanpi
10. https://github.com/control-ﬂow-attestation/c-ﬂat

Next, we measure the performance overhead incurred by
eFSA’s anomaly detector on Raspberry Pi, including the system-
call
tracing overhead and anomaly detection overhead. The
system-call tracing overhead has no difference between FSA and
eFSA, which incurs 1.5x∼2x overhead in our case studies. To
comprehensively measure the runtime system-call tracing over-
head, we further experimentally compare the tracing overhead on
Raspberry Pi using three utility applications (i.e., tcas (1608 test
cases), replace (5472 test cases), and schedule (2650 test
cases)) from the Software-artifact Infrastructure Repository (SIR)
benchmark suite [58]. Fig. 8 shows the results, which measure
the elapsed time between the entry and exit points in the three
utility applications. The baseline refers to the execution time
without tracing. The runtime performance overhead of strace
shows around 96% slowdown on average. When tracing the
callstack information on every system-call, it yields around 112%
slowdown. We discuss the tracing overhead limitation in Sec. 9.

Fig. 8: System-call tracing overhead on Raspberry Pi

Table 2 reports the runtime anomaly detection latency results.
The average delay for each state transition (i.e., each intercepted
system call) checking out of more than 1000 runs is around
0.0001s. It takes 0.063s on average to perform the local event
checking. The end-to-end latency for the distributed event check-
ing from each co-located device can be broken down into two
main parts: i) network communication around 0.042s, and ii)
sensor reading delay around 0.0582s. In our experiment, we
deploy two co-located devices, and thus the total distributed event
checking delay is around 0.212s. It is expected that the overhead
of distributed event checking is linearly proportional to the number
of event veriﬁcation sources.

Delay (Raspberry Pi 2)
FSA State Transition Checking
Local Event Veriﬁcation
Distributed Event Veriﬁcation

Mean
0.00013293s
0.06279120s
0.21152867s

Standard Deviation
0.00004684s
0.00236999s
0.03828739s

TABLE 2. Runtime detection overhead in the monitoring phase

8.3 Detecting Attacks on Control Branch

In this experiment, we evaluate eFSA’s security guarantees against
control branch attacks.

8.3.1 Solard

In Solard, we engineer a buffer overﬂow vulnerability and ma-
nipulate the temperature sensor values to maliciously prevent
the heater from being turned off. This cyber-physical attack is
similar to the recent real-world German steel mill attack [28],
which may result in a blast furnace explosion. In this experiment,
we attach the Raspberry Pi on an electric kettle (i.e., 1-Liter
water boiler). The control program keeps monitoring temperature
values. When the temperature is lower than 50◦C, it turns on the
heater. And when the temperature is higher than 60◦C, where
CriticalTempsFound() is supposed to return True, it turns

10

Fig. 9: An instance of Solard experiment

off the heater. In the monitoring phase, when we detect an event-
dependent state transition in eFSA model, the local event veriﬁer
performs event consistency checking.

always False.

In every scan cycle,

Fig. 9 illustrates an instance of the Solard experiment. We
corrupt the temperature sensor values in the range of 40∼45◦C,
which falsiﬁes the return value of CriticalTempsFound()
eFSA ob-
to be
serves a state transition dependent on the not-happening of
CriticalTempsFound() (i.e., an implicit event), and thus
the event veriﬁer checks the instantaneous temperature value. In
our experiment, because the Raspberry Pi does not physically
interact with the electric kettle, the ground truth temperature
keeps increasing up to more than 80◦C in Fig. 9. However,
eFSA successfully raises an alarm at the ﬁrst moment when it
ﬁnds a mismatch between the execution semantics (temperature
exceeding 60◦C) and program behavior.

We did encounter sensor measurement failures, e.g., isolated
dots as shown in Fig. 9. On average, the false sensor measurement
rate is lower than 1% in our experiments. This means that the
detection rate and false positive/negative rate would depend on
sensors’ functional reliability in practice. Existing methods, such
as data fusion [59] can be applied to enhance the detection
accuracy.

8.3.2 SyringePump
In SyringePump, we set the threshold to 40rH, i.e., when the rel-
ative humidity value is higher than 40rH, it drives the movement
of syringe pump by sending control signals to dispense liquid. The
buffer overﬂow attack manipulates the humidity sensor values to
purposely trigger event-push control actions without receiving
an external event or environmental trigger. Such an attack leads to
unintended but valid control ﬂows.

Fig. 10 illustrates an example of the experiment. The remote
user command corrupts the humidity sensor value to be 48.56rH,
which falsiﬁes the return value of event-push to be True. In
case of any event-driven state transition according to eFSA, the
event veriﬁer checks consistency between the runtime execution
semantics (e.g., the instantaneous humidity value) and program
internal state. As shown in Fig. 9, eFSA raises an alarm when it
ﬁnds a mismatch between the execution semantics and program
behavior.

8.4 Detecting Attacks on Control Intensity

In this experiment, we demonstrate that eFSA is able to detect con-
trol intensity attacks with only system call traces. In SyringePump,
we set the threshold that triggers the movement of syringe pump

 0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8replacetcasscheduleExecution time (ms)BaselineStrace w/o callstackStrace w/ callstackElapsedTime(10mins)20406080100Temperature(◦C)Temperature<50◦C:turnontheheaterTemperature>60◦C:turnofftheheaterAnomalyDetectedbyeFSAFaultyValues(GroundTruth)TemperatureMeasurementsbytheEventVeriﬁerValuesofTemperatureVariableManipulatedbyanAttacker11

8.5 Event-Aware N-gram Model

To show the feasibility of augmenting the n-gram model with event
awareness, we conduct the case study of the event-aware n-gram
model, which is an alternative instantiation of the Orpheus frame-
work. Given the execution traces of SyringePump in the training
phase, we construct the n-gram model of system-call sequences
(n∈[2,· · ·,10]). For the 2-gram model, there are 35 different 2-
grams. write-write is an event-dependent 2-gram. However,
15 non-event-dependent write-write system-call sequences
are also observed during the monitoring phase, which makes the
event checking no longer effective due to the ambiguity. This is
because, without the PC (return address) information associated
with each system-call, we cannot differentiate the invocation of
the same system-calls from different places in the program. As
a result, we need to increase the length of the n-gram until the
event-dependent n-gram is unique in the model. But there is
no guarantee we can always ﬁnd the unique event-dependent n-
gram with increasing the value of n. In SyringePump, we ﬁnd
a unique event-dependent 4-gram write-write-nanosleep-
nanosleep, where the model contains 60 different 4-grams.
During the monitoring phase, our anomaly detector performs the
event checking whenever this event-dependent 4-gram is observed.
Nevertheless, with the increase of n, the size of the n-gram model
also increases. For example, when we increase n to 10, the size of
the n-gram model is increased to 96, which is larger than the size
of eFSA. From this case study, we demonstrate that it is desirable
to use the program counter (PC) information in the basic pro-
gram behavior model, which signiﬁcantly increases the resistance
against control-ﬂow attacks, but also resolves ambiguities in our
event-aware anomaly detection.

8.6 Extension of eFSA

Control programs running on embedded devices may receive
network events from the control center, and then execute actuation
tasks. Though eFSA mainly detects software-exploit based physical
event spooﬁng, it is also applicable to network event-triggering
scenarios. For example, a ground control station (GCS) sends a
command to control an unmanned aerial vehicle (UAV) to change
its ﬂight mode. In this case, we consider each type of control
command as a speciﬁc event, and the eFSA model of a UAV
program is augmented with both physical sensing and network
command events. Such an eFSA model can detect false command
injection attacks against the UAV by checking the consistency of
system call traces at a UAV and its GCS, ensuring their system
call invocations conforming to the network API semantics [60].

To demonstrate the applicability of eFSA for detecting net-
work event inconsistency in CPS, we conduct an experiment on
AR.Drone11, which is a remote controlled quadrocopter. Different
from the Solard and SyringePump case studies running on Rasp-
berry Pi, AR.Drone runs on a customized mainboard with embed-
ded Linux. AR.Drone allows a connection to the Telnet port which
leads to a root shell, and thus we are able to deploy the strace
tool to collect system call traces of the UAV control program.
In AR.Drone, the system call types involved in the process that
handles remote commands are quite limited and the program logic
is rather simple. Thus, we can easily construct the corresponding
eFSA model by taking advantage of network protocol interactions

11. https://www.parrot.com/us/drones/parrot-ardrone-20-elite-edition

Fig. 10: An instance of SyringePump experiment

to be 30rH. The corrupted humidity value determines the amount
of liquid to be dispensed, which equals to the humidity value
subtracted by 30rH in this test. In the training stage, we obtain
the number of system calls invoked in each loop iteration. Then,
we model the relationship between sensor measurements and the
amount of system calls in a control intensity loop. Through control
intensity analysis, we know the number of system calls with no
event occurrence is 40 per scan cycle, and each loop iteration (i.e.,
dispensing a unit of liquid) in the control intensity loop corre-
sponds to 3 system-calls write-nanosleep-nanosleep, as
shown in Fig. 11.

Fig. 11: Control intensity loop in eFSA of SyringePump

Fig. 12(a) shows the value changes of the humidity variable
and system call amount per scan cycle of SyringePump. The
normal humidity value ﬂuctuates between 34 rH and 38rH. As
a result, the amount of liquid to be dispensed is subsequently
changed, which is reﬂected by the number of system calls in each
control loop. We manipulate the humidity values to be 20rH and
48rH, respectively. In the monitoring phase, by observing the
number of system calls in each control loop, we can reversely
derive the changes of physical environment based on our control
intensity regression model as shown in Fig. 12(b). In this test, if
the difference between the derived value and the sampled average
value from event veriﬁer is larger than 3rH, we consider it an
anomaly. By checking the humidity measurements from two co-
located devices (i.e., denoted as devices 1 and 2), our distributed
event veriﬁer detects that the program’s runtime behaviors are
incompatible with physical contexts. Thus, eFSA successfully
detects the control intensity attacks.

(a) Humidity and system call traces

(b) eFSA’s detection

Fig. 12: An instance of SyringePump experiment with a sampling
rate of 5 minutes

0x12a4write0x14b40x11a00x11b4writenanosleepnanosleep0246810121420253035404550HumidityManipulatedValueManipulatedValues02468101214IndexofExecutionWindow020406080100ofsystemcallsElapsedTime(75mins)2530354045505560HumidityAnomalyDetectedbyeFSAAnomalyDetectedbyeFSACo-locatedDevice1Co-locatedDevice2DerivedfromTraceswithout program dependency analysis. Sample traces are included
in the accompanying materials for this paper12.

Since AR.Drone runs with an open Wi-Fi, and we know the
communication protocol between UAV and the GCS [61], we can
easily launch a false command injection attack, which could be
used to send malicious operational data such as status or control
command. We use a laptop (as an attacker) to send fake control
commands to the AR.Drone. Meanwhile, we monitor the network
trafﬁc at GCS using the Wireshark tool. The event veriﬁer could
ﬁnd inconsistencies between eFSA’s state transitions and network
events captured at GCS, and thus detect this type of attacks. In
this experiment, we do not intend to use eFSA to raise an alarm at
the time of intrusion, instead we aim at detecting the anomalous
behavior as a post-mortem analysis.

9 LIMITATION

Although our work is focused on providing new security capabil-
ities in control-program anomaly detection against data-oriented
attacks, in this section, we examine the limitations of our imple-
mentation and discuss how our method can be deployed in the
near future.

Bare-metal CPS Devices: Our anomaly detection system
works on the granularity of system calls and it leverages dynamic
tracing facilities such as the strace tool, which requires the
operating system support. An important reason behind our choice
is that, the new generation of embedded control devices on the
market are increasingly coming with operating systems [35], [37].
For example, Raspberry Pi devices with embedded Linux OS have
been used as ﬁeld devices in many CPS/IoT applications [62].
Linux-based PLCs for industrial control have emerged to replace
traditional PLCs [63] for deterministic logic execution. However,
embedded devices may still operate in bare-metal mode [7], where
we can not utilize existing tracing facilities to collect system call
traces. For traditional PLCs, our security checking can be added
to the program logic. We can also apply the event checking idea
to an anomaly detection system at the level of instructions. We
may instrument the original control program with event checking
hooks by rewriting its binary, e.g., inserting hooks at the entry of
event-triggered basic blocks. We consider it as the future work
to extend our design paradigm for ﬁne-grained anomaly detection
with binary instrumentation.

Tracing Overhead and Time Constraints: Though system
call traces are a common type of audit data in anomaly detection
systems, we would like to point out that the conventional software-
level system call tracing incurs unnegligible performance overhead
to the monitored process [64]. It holds for time-insensitive embed-
ded control applications, e.g., smart home automation, but would
be a technical challenge for time-sensitive applications. While we
employ the user-space strace software to collect system calls in
our prototype, tracing tools are orthogonal to our detection design.
For performance consideration, alternative tracing techniques may
be adopted in replacing strace to improve the tracing perfor-
mance [39]. For example, it is possible to improve the performance
for system call
the
cost of increased deployment effort. With the recently unveiled
Intel’s Processor Trace (PT) and ARM’s CoreSight techniques,
hardware tracing infrastructures are increasingly embedded in
modern processors, which can achieve less than 5% performance

interposition by modifying the kernel at

12. Sample system call traces are provided at goo.gl/Wkrdzz

12

overhead [65]. The recent work, Ninja [66], offers a fast hardware-
assisted tracing on ARM platforms. The overhead of instruction
tracing and system call tracing are negligibly small. Therefore, we
anticipate that future tracing overhead will be signiﬁcantly reduced
as the hardware-assisted tracing techniques are increasingly used.
Lack of CPS Benchmark Programs: Lack of CPS bench-
mark programs is one of the challenges in CPS security research
to perform sound evaluation. It is partly because of the diversity
of CPS hardware platforms, and the hardware-dependent nature
of CPS programs. In addition, safety-critical CPS programs are
rarely open-source. As a result, existing CPS security research
work mainly conducted limited case studies [7] [43] [67], instead
of a large scale experimental evaluation. We therefore leave the
comprehensive evaluation of our approach for future work as more
CPS benchmark programs are available. We also would like to
exploit the symbolic execution in our control intensity analysis,
which may statically derive the relationship between sensor values
and the number of control loop iterations. Symbolic execution and
fuzzing techniques are also useful to increase code-coverage in the
training phase for collecting traces of normal program executions.
Limitation of Detection Capability: From our case studies,
we demonstrate that enforcing cyber-physical execution semantics
in CPS program anomaly detection is effective to detect both
types of data-oriented attacks. The necessary condition is that the
observed program behavior at system-call level is incompatible
with the current physical context. Simply corrupting non-control
data in a program’s memory space may be undetectable if the
attack does not result in inconsistencies between the physical
context and program execution, which is out of the scope in
this work. Another limitation of our design is that we only
detect program anomalies at the system-call level. CPS devices
may send control signals by directly writing registers without
issuing any system-call, rendering the system-call based detection
not working. To overcome this limitation, the Orpheus design
paradigm can be extended to the instruction level for ﬁne-grained
anomaly detection.

Anomaly Detection as a Service: Embedded devices are
resource-constrained compared with general-purpose computers.
To reduce detection overhead, the anomaly detection may be
performed at a remote server. We envision deployment involv-
ing partnerships between hardware vendors and security service
providers (similar to ZingBox IoT Guardian [68]), where the
security provider is given access to embedded platforms and helps
clients to diagnose/conﬁrm violations. The client-server architec-
ture resonates with the remote attestation in embedded systems,
which detects whether a controller is behaving as expected [7],
[69]. For detection overhead reduction, the remote server may
choose when and how frequently to send assessment requests to
a control program for anomaly detection. It is also possible to
selectively verify a subset of events for the scalability purpose,
e.g., only safety-critical events speciﬁed by developers are in-
volved. While the event veriﬁer implementation is not completely
automated, our event identiﬁcation and dependence analysis tool
does automate a large portion of event code extraction and eases
the developer’s burden. We leave automatically generating event
veriﬁcation functions for the anomaly detector as an important part
of our future work.

10 RELATED WORK
Due to the diversity of CPS applications, existing anomaly
detection solutions are proposed to detect speciﬁc attacks for

Research Work

Yoon et al. [31]

Feng et al. [74]

Zimmer et al. [10]

C-FLAT [7]

FT-RMT [67]

Hadziosmanovic et al. [56]

NoisePrint [75]

Category
Program behavior model
(cyber)
Network trafﬁc analysis
(cyber)
Timing analysis model
(cyber)
Program behavior model
(cyber)
Redundant execution
analysis (cyber)
Range-based model
(physical)
Noise ﬁngerprinting
(physical)

Cardenas et al. [4]

Physical laws

SRID [25]

C2 [76]

eFSA (Our work)

Physical laws

Control policies
(physical)
Cyber-physical model

Approach

Security Guarantee

Validation

Syscall frequencies

Frequency-based program control ﬂow anomaly

Raspberry Pi testbed

Machine learning based trafﬁc analysis

Trafﬁc alteration

Trafﬁc data from a gas pipeline
system

Static/dynamic timing analysis

Code injection attacks

Simulation/Testbed

13

Program analysis and instrumentation

Control-oriented attacks and limited
non-control-data attacks

Redundant controller and computation

CPS faults or attacks

Attribute values extracted from
network trafﬁc
Pattern recognition in sensor and
process noise dynamics
Linear model derived from training
data
Correlation analysis of system
variables.

User speciﬁed control policies

Event-aware FSA

Raspberry Pi testbed

Simulate steer-by-wire application
on embedded Linux
Trafﬁc data from water treatment
plants

False data injection attacks

Sensor spooﬁng attacks

Two real-world CPS testbeds

False data injection attacks

False data injection attacks

Control signal violation

Data-oriented attacks

Simulation

Simulation

Raspberry Pi testbed

Raspberry Pi testbed

TABLE 3. Comparison of representative CPS anomaly detection approaches

speciﬁc applications, such as smart infrastructures [3], unmanned
aerial vehicles [70], medical devices [71], automotive [72], [73],
industrial control process [4], [34], [55]. The majority of research
efforts in this area thus far have concentrated on behavior model-
based anomaly detection [55], and can be generally classiﬁed into
two categories: 1) cyber model (e.g., program behavior model,
network trafﬁc analysis, or timing analysis); 2) physical model
(e.g., range-based model or physical laws). Our proposed eFSA
analyzes both the cyber and physical properties of CPS, as well as
their interactions. Thus, we refer to it as the cyber-physical model.
Table 3 compares representative CPS anomaly detection solutions.
• Program behavior model. Regarding the CPS anomaly detection
based on program behavior models in the cyber domain, Yoon et
al. [31] proposed a lightweight method for detecting anomalous
executions using the distribution of system call frequencies.
The frequencies are for individual system calls, i.e., 1-grams.
The authors in [20] proposed a hardware based approach
for control-ﬂow graph (CFG) validation in runtime embedded
systems. McLaughlin et al. [34] presented the Trusted Safety
Veriﬁer (TSV) to verify safety-critical code executed on pro-
grammable controllers, such as checking safety properties like
range violations and interlocks of PLC programs. C-FLAT [7]
instruments target control programs to achieve the remote at-
testation of execution paths of monitored programs, and the
validity of control ﬂow paths is based on static analysis. Given
an aggregated authenticator (i.e., ﬁngerprint) of the program’s
control ﬂow computed by the prover, the veriﬁer is able to
trace the exact execution path and thus can determine whether
application’s control ﬂow has been compromised. C-FLAT [7] is
the most related work to our approach. Both C-FLAT and eFSA
target at designing a general approach for detecting anomalous
executions of embedded systems software. However, C-FLAT
is insufﬁcient to detect data-oriented attacks due to the lack
of runtime execution context checking. It can only partially
detect control intensity attacks with the assumption of knowing
legal measurements of the target program. However, if the legal
measurement covers a large range of sensor values, attacks can
easily evade its detection because it does not check runtime
consistency between program behavior and physical context.
• Trafﬁc-based model. Control systems exhibit relatively simpler
network dynamics compared with traditional IT systems, e.g.,
ﬁxed network topology, regular communication patterns, and
a limited number of communication protocols. As a result,
implementing network-based anomaly detection systems would
be easier than traditional mechanisms. Feng et al. [74] presented

an anomaly detection method for ICS by taking advantage of
the predictable and regular nature of communication patterns
that exist between ﬁeld devices in ICS networks. In the training
phase, a base-line signature database for general packages is
constructed. In the monitoring phase, the authors utilize Long
Short-Term Memory (LSTM) network based softmax classiﬁer
to predict the most likely package signatures that are likely
to occur given previously seen package trafﬁc. The anomaly
detector captures trafﬁc anomalies if a package’s signature is not
within the predicted top k most probable signatures according
to the LSTM-based model.

• Timing-based model. Several studies utilized timing information
as a side channel to detect malicious intrusions. The rationale
is that execution timing information is considered an important
constraint for real-time CPS applications, and mimicking timing
is more difﬁcult than mimicking the execution sequence. To
this end, Zimmer et al. [10] used the worst-case execution
time (WCET) obtained through static analysis to detect code
injection attacks in CPS. Such timing-based detection technique
is realized by instrumenting checkpoints within real-time appli-
cations. Sibin et al. [77] focused on detecting intrusions in real-
time control systems. Yoon et al. [78] presented SecureCore,
a multicore architecture using the timing distribution property
of each code block to detect malicious activities in real-time
embedded system. Lu et al. [21] investigated how to reduce
timing checkpoints without sacriﬁcing detection accuracy in
embedded systems.

• Redundant execution analysis. Munir et al. [67] presented an in-
tegrated approach for the design of secure and dependable auto-
motive CPS by conducting the steer-by-wire (SBW) case study.
To provide fault tolerance (FT) to SBW applications, they pro-
posed the FT-RMT (redundant multi-threading) scheme, which
executes safety-critical computations on redundant threads and
detects an error if observing a mismatch between the two
threads’ output. However, introducing redundant controllers into
CPS incurs high cost such as increased code size and reduced
performance. In addition, under our threat model, attackers may
be able to compromise redundant controllers to evade detection.
• Range based model. Enforcing data ranges is the simplest
method to detect CPS anomalies in the physical domain. As
long as sensor readings are outside a pre-speciﬁed normal range,
the anomaly detector raises an alarm. Hadziosmanovic et al.
[56] presented a non-obtrusive security monitoring system by
deriving models for PLC variables from network packets as the
basis for assessing CPS behaviors. For constant and attribute

series, the proposed detection approach raises an alert if a value
reaches outside of the enumeration set. However, range-based
detection suffers from a low detection rate because it neglects
the program’s execution context, e.g., if the legal measurement
covers a large range of sensor values, attacks can easily evade
its detection.

• Sensor and process noise ﬁngerprinting. Ahmed et al. [75]
proposed the NoisePrint, a CPS attack detection method based
on process noise patterns (e.g., ﬂuid sloshing in a storage tank)
of the system. The intuition behind NoisePrint is that, sensor
and process noise variations exhibit unique patterns among
different processes. Therefore, it is hard for attackers to repro-
duce or control these noise variations, making them an ideal
side information for CPS anomaly detection. In the training
phase, a combined ﬁngerprint dictionary for sensor and process
noise is built under regular operations. Under sensor spooﬁng
attack, noise pattern deviates from the ﬁngerprinted pattern is
considered an anomaly. However, this approach requires an
accurate noise measurement, which is subject to the ambient
background noise in a process plant.

• Physical laws. The idea of using physical models to deﬁne
normal operations for anomaly detection is that, system states
must follow immutable laws of physics. Wang et al. [25]
derived a graph model to defeat false data injection attacks in
SCADA system. It captures internal relations among system
variables and physical states. Cho et al. [72] presented a brake
anomaly detection system, which compares the brake data with
the norm model to detect any vehicle misbehavior (e.g., due
to software bugs or hardware glitches) in the Brake-by-Wire
system. Other examples include utilizing ﬂuid dynamics and
electromagnetics as the basic laws to create prediction models
for water system [56] and power grid [57], respectively. Based
on the prediction models and predeﬁned threat constraints,
these methods check whether sensor readings are consistent
with the expected behaviors of a control system. Cardenas et
al. [4] proposed a physical model based detection method by
monitoring the physical system under control, and the sensor
and actuator values. The authors also proposed automatic re-
sponse mechanisms by estimating the system states. Urbina et
al. [55] discussed the limitations of existing physics-based
attack detection approaches, i.e., they cannot limit the impact
of stealthy attacks. The authors proposed a metric to measure
the impact of stealthy attacks and to study the effectiveness of
physics-based detection.

• Control policies. Physical model can also be speciﬁed by control
policies. The main purpose of the policies is to improve the
survivability of control systems, i.e., without losing critical
functions under attacks. For example, McLaughlin et al. [76]
introduced a policy enforcement for governing the usage of CPS
devices, which checks whether the policy allows an operation
depending on the state of the plant around the time the operation
was issued. The policies specify what behaviors should be
allowed to ensure the safety of physical machinery and assets.
• Cyber-physical model. Such a model captures the cyber-
physical context dependency of control programs. Our proposed
eFSA characterizes control-program behaviors with respect to
events, and enforces the runtime consistency among control
decisions, values of data variables in control programs, and the
physical environments. Thus, it is able to detect inconsistencies
between the physical context and program execution.

14

As shown in Table 3, cyber models and physical models
have different security guarantees. The former targets at detecting
CPS control program anomalies in the cyber domain. While the
latter mainly focuses on detecting false data injection attacks in
the physical domain [57]. The cyber-physical interaction (i.e.,
interactions between cyber components and physical components)
in CPS makes it challenging to predict runtime program behaviors
through static analysis of the program code or model training. Ex-
isting cyber models [7], [31] are effective against control-oriented
attacks, however, insufﬁcient to detect data-oriented attacks. An
effective CPS program anomaly detection needs to reason about
program behaviors with respect to cyber-physical interactions,
e.g., the decision of opening a valve has to be made based on
the current water level of the tank. ContexIoT [30] provides
context identiﬁcation for sensitive actions in the permission grant-
ing process of IoT applications on Android platforms. Though
both ContextIoT and eFSA consider execution contextual integrity,
ContextIoT does not support the detection of data-oriented attacks.
Distinctive from existing works in this area, our Orpheus
focuses on utilizing the event-driven feature in control-program
anomaly detection and our program behavior model combines
both the cyber and physical aspects. Consequently, physics-based
models, which can be inherently integrated into our approach
to enhance security and efﬁciency, do not compete but rather
complement our scheme. Stuxnet attack [8] manipulated the nu-
clear centrifuge’s rotor speed, and fooled the system operator by
replaying the recorded normal data stream during the attack [36].
Since eFSA’s detection is independent on the history data, it makes
Stuxnet-like attacks detectable in eFSA by detecting runtime incon-
sistencies between the physical context (runtime rotor speed) and
the control program’s behavior. In addition, attackers may exploit
hardware vulnerabilities [79] to manipulate data in memory so as
to launch attacks on control branch or control intensity. eFSA is
also able to detect anomalies caused by such hardware attacks.

11 CONCLUSION
In this work, we presented Orpheus, a new security mechanism for
CPS control programs in defending against data-oriented attacks,
by enforcing cyber-physical execution semantics. As an FSA-
based instantiation of Orpheus, we proposed the program behavior
model eFSA, which advances the state-of-the-art program behavior
modelling. To the best of our knowledge, this is the ﬁrst program
behavior model that integrates both cyber and physical proper-
ties to defend against data-oriented attacks. We implemented a
proof-of-concept prototype to demonstrate the feasibility of our
approach. Real-world case studies demonstrated eFSA’s efﬁcacy
against different data-oriented attacks. As for our future work, we
plan to integrate physics-based models into our approach, design
robust event veriﬁcation mechanisms, and extend the Orpheus
design paradigm to support actuation integrity for ﬁne-grained
anomaly detection at the instruction level without the need of
tracing facilities. We also plan to investigate the scalability of our
approach on program size and complexity.

ACKNOWLEDGMENTS
This work has been supported by the Ofﬁce of Naval Research un-
der Grant ONR-N00014-17-1-2498, National Science Foundation
under Grant OAC-1541105, and Security and Software Engineer-
ing Research Center (S2ERC), a NSF sponsored multi-university
Industry/University Cooperative Research Center (I/UCRC).

REFERENCES

[1] L. Cheng, K. Tain, and D. D. Yao, “Enforcing cyber-physical execution
semantics to defend against data-oriented attacks,” in ACSAC, 2017.
[2] A. B. Sharma, F. Ivanˇci´c, A. Niculescu-Mizil, H. Chen, and G. Jiang,
“Modeling and analytics for cyber-physical systems in the age of big
data,” SIGMETRICS Perform. Eval. Rev., vol. 41, no. 4, pp. 74–77, 2014.
[3] S. Sridhar, A. Hahn, and M. Govindarasu, “Cyber-physical system
security for the electric power grid,” Proceedings of the IEEE, vol. 100,
no. 1, pp. 210–224, 2012.

[4] A. A. Cárdenas, S. Amin, Z.-S. Lin, Y.-L. Huang, C.-Y. Huang, and
S. Sastry, “Attacks against process control systems: Risk assessment,
detection, and response,” in ASIACCS, 2011.
“Cyber-Physical Systems,” www.cpse-labs.eu/cps.php, [Accessed 09-12-
2017].

[5]

[6] R. Mitchell and I.-R. Chen, “A survey of intrusion detection techniques
for cyber-physical systems,” ACM Comput. Surv., vol. 46, no. 4, pp.
55:1–55:29, Mar. 2014.

[7] T. Abera, N. Asokan, L. Davi, J. Ekberg, T. Nyman, A. Paverd,
A. Sadeghi, and G. Tsudik, “C-FLAT: control-ﬂow attestation for em-
bedded systems software,” in CCS, 2016.

[8] D. Kushner, “The real story of Stuxnet,” IEEE Spectrum, vol. 50, no. 3,

[9]

pp. 48 – 53, 2013.
“The Industrial Control Systems Cyber Emergency Response Team,”
https://ics-cert.us-cert.gov/, [Accessed 09-12-2017].

[10] C. Zimmer, B. Bhat, F. Mueller, and S. Mohan, “Time-based intrusion

detection in cyber-physical systems,” in ICCPS, 2010.

[11] J. Habibi, A. Gupta, S. Carlsony, A. Panicker, and E. Bertino, “MAVR:
Code reuse stealthy attacks and mitigation on unmanned aerial vehicles,”
in ICDCS, 2015, pp. 642–652.

[12] D. D. Chen, M. Egele, M. Woo, and D. Brumley, “Towards automated
dynamic analysis for Linux-based embedded ﬁrmware,” in NDSS, 2016.
[13] L. Garcia, F. Brasser, M. H. Cintuglu, A.-R. Sadeghi, O. Mohammed,
and S. A. Zonouz, “Hey, my malware knows physics! attacking PLCs
with physical model aware rootkit,” in NDSS, 2017.

[14] T. Nyman, G. Dessouky, S. Zeitouni, A. Lehikoinen, A. Paverd,
N. Asokan, and A. Sadeghi, “Hardscope: Thwarting DOP with hardware-
assisted run-time scope enforcement,” CoRR, vol. abs/1705.10295, 2017.
[Online]. Available: http://arxiv.org/abs/1705.10295

[15] A. Francillon and C. Castelluccia, “Code injection attacks on Harvard-

architecture devices,” in CCS, 2008.

[16] X. Shu, D. D. Yao, and B. G. Ryder, “A formal framework for program

anomaly detection,” in RAID, 2015.

[17] V. Kiriansky, D. Bruening, and S. P. Amarasinghe, “Secure execution via

program shepherding,” in USENIX Security, 2002.

[18] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-ﬂow in-

tegrity,” in CCS, 2005.

[19] A. Francillon, D. Perito, and C. Castelluccia, “Defending embedded

systems against control ﬂow attacks,” in SecuCode, 2009.

[20] F. A. T. Abad, J. V. D. Woude, Y. Lu, S. Bak, M. Caccamo, L. Sha,
R. Mancuso, and S. Mohan, “On-chip control ﬂow integrity check for
real time embedded systems,” in 2013 IEEE 1st International Conference
on Cyber-Physical Systems, Networks, and Applications, 2013.

[21] S. Lu and R. Lysecky, “Analysis of control ﬂow events for timing-based
runtime anomaly detection,” in Proceedings of Workshop on Embedded
Systems Security, 2015.

[22] N. Carlini, A. Barresi, M. Payer, D. Wagner, and T. R. Gross, “Control-
ﬂow bending: On the effectiveness of control-ﬂow integrity,” in USENIX
Security, 2015.

[23] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer, “Non-control-data

attacks are realistic threats,” in USENIX Security, 2005.

[24] H. Hu, S. Shinde, S. Adrian, Z. L. Chua, P. Saxena, and Z. Liang,
“Data-oriented programming: On the expressiveness of non-control data
attacks,” in IEEE S&P, 2016.

[25] Y. Wang, Z. Xu, J. Zhang, L. Xu, H. Wang, and G. Gu, “Srid: State
relation based intrusion detection for false data injection attacks in
scada,” in ESORICS, 2014.

[26] R. Tan, H. H. Nguyen, E. Y. S. Foo, X. Dong, D. K. Y. Yau, Z. Kalbar-
czyk, R. K. Iyer, and H. B. Gooi, “Optimal false data injection attack
against automatic generation control in power grids,” in ICCPS, 2016.

[27] S. Adepu, S. Shrivastava, and A. Mathur, “Argus: An orthogonal de-
fense framework to protect public infrastructure against cyber-physical
attacks,” IEEE Internet Computing, vol. 20, no. 5, pp. 38–45, 2016.

[28] “German

Steel Mill Meltdown,”

securityintelligence.com/

german-steel-mill-meltdown-rising-stakes-in-the-internet-of-things/,
[Accessed 09-12-2017].

[29] P. Derler, E. A. Lee, S. Tripakis, and M. Törngren, “Cyber-physical

system design contracts,” in ICCPS, 2013.

15

[30] Y. J. Jia, Q. A. Chen, S. Wang, A. Rahmati, E. Fernandes, Z. M. Mao,
and A. Prakash, “ContexIoT: Towards Providing Contextual Integrity to
Appiﬁed IoT Platforms,” in NDSS, 2017.

[31] M.-K. Yoon, S. Mohan, J. Choi, M. Christodorescu, and L. Sha,
“Learning execution contexts from system call distribution for anomaly
detection in smart embedded system,” in Proceedings of the Second In-
ternational Conference on Internet-of-Things Design and Implementation
(IoTDI), 2017, pp. 191–196.

[32] C. Warrender, S. Forrest, and B. Pearlmutter, “Detecting intrusions using

system calls: alternative data models,” in IEEE S&P, 1999.

[33] K. Xu, D. Yao, B. Ryder, and K. Tian, “Probabilistic program modeling

for high-precision anomaly classiﬁcation,” in CSF, 2015.

[34] S. McLaughlin, D. Pohly, P. McDaniel, and S. Zonouz, “A trusted safety

veriﬁer for process controller code,” in NDSS, 2014.

[35] J. Tan, H. J. Tay, U. Drolia, R. Gandhi, and P. Narasimhan, “PCFIRE:
Towards provable preventative control-ﬂow integrity enforcement for
realistic embedded software,” in 2016 International Conference on Em-
bedded Software (EMSOFT), 2016, pp. 1–10.

[36] L. Garcia, F. Brasser, M. H. Cintuglu, A.-R. Sadeghi, O. Mohammed,
and S. A. Zonouz, “Hey, My Malware Knows Physics! Attacking PLCs
with Physical Model Aware Rootkit,” in NDSS, 2017.

[37] M. Schwartz, J. Mulder, A. R. Chavez, and B. A. Allan, “Emerging
techniques for ﬁeld device security,” IEEE Security and Privacy, vol. 12,
no. 6, pp. 24–31, 2014.

[38] M. Darren, V. Fredrik, V. Giovanni, and K. Christopher, “Anomalous
system call detection,” ACM Trans. Inf. Syst. Secur., vol. 9, no. 1, pp.
61–93, 2006.

[39] X. Shu, D. Yao, and N. Ramakrishnan, “Unearthing stealthy program
attacks buried in extremely long execution paths,” in CCS, 2015.
[40] B. Ur, E. McManus, M. Pak Yong Ho, and M. L. Littman, “Practical

trigger-action programming in the smart home,” in CHI, 2014.

[41] A. A. Clements, N. S. Almakhdhub, K. S. Saab, P. Srivastava, J. Koo,
S. Bagchi, and M. Payer, “Protecting bare-metal embedded systems with
privilege overlays,” in 2017 IEEE Symposium on Security and Privacy
(SP), 2017, pp. 289–303.

[42] E. G. Chekole, S. Chattopadhyay, M. Ochoa, and G. Huaqun, “Enforcing
full-stack memory-safety in cyber-physical systems,” in Engineering
Secure Software and Systems, M. Payer, A. Rashid, and J. M. Such,
Eds. Springer International Publishing, 2018, pp. 9–26.

[43] Z. Sun, B. Feng, L. Lu, and S. Jha, “OEI: operation execution integrity
for embedded devices,” CoRR, vol. abs/1802.03462, 2018. [Online].
Available: http://arxiv.org/abs/1802.03462

[44] R. Sekar, M. Bendre, D. Dhurjati, and P. Bollineni, “A fast automaton-
based method for detecting anomalous program behaviors,” in IEEE
S&P, 2001.

[45] X. Shu, D. D. Yao, N. Ramakrishnan, and T. Jaeger, “Long-span program
behavior modeling and attack detection,” ACM Transactions on Privacy
and Security, vol. 20, no. 4, pp. 1–28, Sep. 2017.

[46] D. Wagner and P. Soto, “Mimicry attacks on host-based intrusion detec-

tion systems,” in CCS, 2002.

[47] “LLVM,” http://llvm.org/, [Accessed 09-12-2017].
[48] E. J. Schwartz, T. Avgerinos, and D. Brumley, “All you ever wanted to
know about dynamic taint analysis and forward symbolic execution (but
might have been afraid to ask),” in IEEE S&P, 2010.

[49] “GPIO access library for RPI,” wiringpi.com/, [Accessed 09-12-2017].
[50] X. Zhang, R. Gupta, and Y. Zhang, “Precise dynamic slicing algorithms,”

in ICSE ’03, 2003.

[51] D. Gao, M. K. Reiter, and D. Song, “On gray-box program tracking for

anomaly detection,” in USENIX Security, 2004.

[52] D. Wagner and D. Dean, “Intrusion detection via static analysis,” in IEEE

S&P, 2001.

[53] L. C. Lam and C. Tzi-cker, “Automatic extraction of accurate application-

speciﬁc sandboxing policy,” in RAID, 2004.

[54] “Arduino,” www.arduino.cc/, [Accessed 09-12-2017].
[55] D. I. Urbina, J. A. Giraldo, A. A. Cardenas, N. O. Tippenhauer, J. Valente,
M. Faisal, J. Ruths, R. Candell, and H. Sandberg, “Limiting the impact
of stealthy attacks on industrial control systems,” in CCS, 2016.

[56] D. Hadžiosmanovi´c, R. Sommer, E. Zambon, and P. H. Hartel, “Through
the eye of the PLC: Semantic security monitoring for industrial pro-
cesses,” in ACSAC, 2014.

[57] Y. Liu, P. Ning, and M. K. Reiter, “False data injection attacks against

state estimation in electric power grids,” in CCS, 2009.

[58] “Software-artifact

Infrastructure Repository,” http://sir.unl.edu/,

[Ac-

cessed 09-12-2017].

[59] M. Bahrepour, N. Meratnia, and P. J. M. Havinga, “Sensor fusion-based
event detection in wireless sensor networks,” in Annual International

Mobile and Ubiquitous Systems: Networking Services, MobiQuitous,
2009.

[60] Y. Zhuang, E. Gessiou, S. Portzer, F. Fund, M. Muhammad, I. Beschast-
nikh, and J. Cappos, “Netcheck: Network diagnoses from blackbox
traces,” in USENIX NSDI, 2014, pp. 115–128.

[61] N. M. Rodday, R. d. O. Schmidt, and A. Pras, “Exploring security

vulnerabilities of unmanned aerial vehicles,” in NOMS, 2016.

[62] “Opto 22 connects real-world industrial devices to millions of Raspberry
Pi,” www.prweb.com/releases/2016/11/prweb13853953.htm, [Accessed
09-12-2017].

[63] “The REX Control System for Raspberry Pi,” www.rexcontrols.com/,

[Accessed 09-12-2017].

[64] H. Feng, J. Gifﬁn, Y. Huang, S. Jha, W. Lee, and B. Miller, “Formalizing
sensitivity in static analysis for intrusion detection,” in IEEE S&P, 2004.
[65] V. Adrien, E.-J. Naser, and D. M. R., “Hardware-assisted software event
tracing,” Concurrency and Computation: Practice and Experience, 2017.
[66] Z. Ning and F. Zhang, “Ninja: Towards transparent tracing and debugging

on arm,” in USENIX Security, 2017.

[67] A. Munir and F. Koushanfar, “Design and analysis of secure and depend-
able automotive cps: A steer-by-wire case study,” IEEE Transactions on
Dependable and Secure Computing, 2018.

[68] “ZingBox: Enabling the Internet of Trusted Things,” www.zingbox.com/,

[Accessed 09-12-2017].

[69] J. Valente, C. Barreto, and A. A. Cárdenas, “Cyber-physical systems

attestation,” in DCOSS, 2014.

[70] R. Mitchell and I.-R. Chen, “Adaptive intrusion detection of malicious
unmanned air vehicles using behavior rule speciﬁcations,” IEEE Trans-
actions on Systems, Man, and Cybernetics: Systems, vol. 44, no. 5, pp.
593–604, 2014.

[71] R. Mitchell and I. R. Chen, “Behavior rule speciﬁcation-based intrusion
detection for safety critical medical cyber physical systems,” IEEE
Transactions on Dependable and Secure Computing, vol. 12, no. 1, pp.
16–30, 2015.

[72] K.-T. Cho, K. G. Shin, and T. Park, “CPS approach to checking norm

operation of a brake-by-wire system,” in ICCPS, 2015.

[73] I. Rouf, R. Miller, H. Mustafa, T. Taylor, S. Oh, W. Xu, M. Gruteser,
W. Trappe, and I. Seskar, “Security and privacy vulnerabilities of in-
car wireless networks: A tire pressure monitoring system case study,” in
USENIX Security, 2010.

[74] C. Feng, T. Li, and D. Chana, “Multi-level anomaly detection in industrial
control systems via package signatures and LSTM networks,” in DSN,
2017.

[75] C. M. Ahmed, M. Ochoa, J. Zhou, A. P. Mathur, R. Qadeer, C. Murguia,
and J. Ruths, “Noiseprint: Attack detection using sensor and process
noise ﬁngerprint in cyber physical systems,” in Proceedings of the 2018
on Asia Conference on Computer and Communications Security, ser.
ASIACCS ’18, 2018, pp. 483–497.

[76] S. McLaughlin, “CPS: Stateful policy enforcement for control system

device usage,” in ACSAC, 2013, pp. 109–118.

[77] S. Mohan, S. Bak, E. Betti, H. Yun, L. Sha, and M. Caccamo, “S3A:
Secure system simplex architecture for enhanced security and robustness
of cyber-physical systems,” in HiCoNS, 2013.

[78] M.-K. Yoon, S. Mohan, J. Choi, J.-E. Kim, and L. Sha, “Securecore: A
multicore-based intrusion detection architecture for real-time embedded
systems,” in RTAS, 2013.

[79] V. van der Veen, Y. Fratantonio, M. Lindorfer, D. Gruss, C. Maurice,
G. Vigna, H. Bos, K. Razavi, and C. Giuffrida, “Drammer: Deterministic
rowhammer attacks on mobile platforms,” in CCS ’16, 2016, pp. 1675–
1689.

Long Cheng is currently an assistant professor of computer science
at Clemson University, USA. He received his second PhD in Computer
Science from Virginia Tech USA in 2018, and the ﬁrst PhD from Beijing
University of Posts and Telecommunications China in 2012. He worked
as a Research Scientist at the Institute for Infocomm Research (I2R),
Singapore from 2014 to 2015, and a Research Fellow at Singapore
University of Technology and Design from 2012 to 2014. His research
interests include system and network security, cyber forensics, cyber-
physical systems (CPS) security, Internet of Things, mobile comput-
ing, and wireless networks. He received the Best Paper Award from
IEEE Wireless Communications and Networking Conference (WCNC)
in 2013, the Erasmus Mundus Scholar Award in 2014, and the Pratt
Fellowship at Virginia Tech in 2017.

16

Ke Tian is currently a data scientist at Microsoft. His experience is on
leveraging Machine Learning and Anomaly Detection to address cyber
security challenges. He received his PhD degree from the Department
of Computer Science at Virginia Tech in 2018. He received his bachelor
degree majoring information security from University of Science and
Technology of China in 2013. His research interests are in cybersecurity,
mobile security and machine learning.

Danfeng (Daphne) Yao is an associate professor of computer science
at Virginia Tech. In the past decade, she has been working on designing
and developing data-driven anomaly detection techniques for securing
networked systems against stealthy exploits and attacks. Her expertise
also includes mobile security. Dr. Yao received her Ph.D. in Computer
Science from Brown University. Dr. Yao is an Elizabeth and James
E. Turner Jr. ’56 Faculty Fellow and L-3 Faculty Fellow. She received
the NSF CAREER Award in 2010 for her work on human-behavior
driven malware detection, and the ARO Young Investigator Award for
her semantic reasoning for mission-oriented security work in 2014. She
has several Best Paper Awards (e.g., ICNP ’12, CollaborateCom ’09,
and ICICS ’06) and Best Poster Awards (e.g., ACM CODASPY ’15). She
was given the Award for Technological Innovation from Brown University
in 2006. She held multiple U.S. patents for her anomaly detection
technologies. Dr. Yao is an associate editor of IEEE Transactions on
Dependable and Secure Computing (TDSC). She serves as PC mem-
bers in numerous computer security conferences, including ACM CCS
and IEEE S&P. She has over 85 peer-reviewed publications in major
security and privacy conferences and journals.

Lui Sha received the Ph.D. degree in computer science from Carnegie
Mellon University, Pittsburgh, PA, USA, in 1985. He is currently a Donald
B. Gillies Chair Professor of Computer Science with the University of
Illinois at Urbana Champaign, Champaign, IL, USA. His work on real-
time computing is supported by most of the open standards in real-
time computing and has been cited as a key element in the success
of many national high-technology projects including GPS upgrade, the
Mars Pathﬁnder, and the International Space Station.

Raheem Beyah is the Motorola Foundation Professor and Associate
Chair for Strategic Initiatives and Innovation in the School of Electri-
cal and Computer Engineering at Georgia Tech, where he leads the
Communications Assurance and Performance Group (CAP). His re-
search interests include network security, wireless networks, network
trafﬁc characterization and performance, and security visualization. He
received the National Science Foundation CAREER award in 2009 and
was selected for DARPA’s Computer Science Study Panel in 2010. He
is a member of AAAS, ASEE, a lifetime member of NSBE, a senior
member of IEEE, and an ACM Distinguished Scientist.

