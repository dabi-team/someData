2
2
0
2

y
a
M
9
1

]

R
C
.
s
c
[

1
v
3
9
4
9
0
.
5
0
2
2
:
v
i
X
r
a

Dockerized Android: a container-based platform to
build mobile Android scenarios for Cyber Ranges

Daniele Capone
SecSI srl
Napoli, Italy
daniele.capone@secsi.io

Francesco Caturano
Dept. of Electrical Engineering and Information Technology
University of Napoli Federico II
Napoli, Italy
francesco.caturano@unina.it

Angelo Delicato
SecSI srl
Napoli, Italy
angelo.delicato@secsi.io

Gaetano Perrone
Dept. of Electrical Engineering and Information Technology
University of Napoli Federico II
Napoli, Italy
gaetano.perrone@unina.it

Simon Pietro Romano
Dept. of Electrical Engineering and Information Technology
University of Napoli Federico II
Napoli, Italy
spromano@unina.it

Abstract—The best way to train people about security is
through Cyber Ranges, i.e., the virtual platform used by cyber-
security experts to learn new skills and attack vectors. In order
to realize such virtual scenarios, container-based virtualization
is commonly adopted, as it provides several beneﬁts in terms of
performance, resource usage, and portability. Unfortunately, the
current generation of Cyber Ranges does not consider mobile
devices, which nowadays are ubiquitous in our daily lives. Such
devices do often represent the very ﬁrst entry point for hackers
into target networks. It is thus important to make available tools
allowing to emulate mobile devices in a safe environment without
incurring the risk of causing any damage in the real world. This
work aims to propose Dockerized Android, i.e., a framework
that addresses the problem of realizing vulnerable environments
for mobile devices in the next generation of Cyber Ranges. We
show the platform’s design and implementation and show how
it is possible to use the implemented features to realize complex
virtual mobile kill-chains scenarios.

Index Terms—Container-based architectures, Mobile Cyber

Ranges, Mobile Android Hacking, Security.

I. INTRODUCTION

Cyberthreats are real, and they will always be. There will
never be 100% secure software. What an organization or a
country can do is avoid a security incident from a cyber
threat and, if that happens despite all the efforts, minimize
the consequences. In order to do so, the organization/country
needs highly trained personnel. Currently, one of the most
effective ways to train people about security is through Cy-
ber Ranges, i.e., virtual platforms that allow companies and
security enthusiasts to learn cyber-security skills in a safe and
controlled environment. These platforms can be instrumented
for several purposes, even if they are commonly used to
create challenges to train security teams. Such challenges are
formed by two teams: the “Red Team”, i.e., security experts
that help companies to discover vulnerabilities by mimicking
a real attacker, and the “Blue Team”, i.e., security experts

that try to protect the vulnerable infrastructures from the Red
Team. Although it is proven that cyber ranges are essential to
improve the effectiveness of security training [1], the problem
they usually
with current Cyber range generations is that
do not consider the existence of mobile devices. This is a
strong limitation, as nowadays, mobile devices are commonly
adopted by companies and represent a severe security risk.
Proofpoint security researchers show that the number of at-
tacks increased by 500% at the beginning of 2022 [2]. A
mobile device can browse the Internet, connect to an FTP
server, and access all data. Therefore, it could be easily the
entrance point for hackers to introduce themselves into the
target network. Mayrhofer et al. (2021) [3] provide an Android
threat model that covers several mobile threats’ scenarios. The
threats summarized in Table I can be physical and/or proximal
(P), based on network attacks (N), caused by applications’
abuse (A), or by untrusted data processing.

Therefore, security training for these scenarios is crucial,
and cyber-ranges can give a great contribution to such a
purpose.

This paper describes the design and implementation of
Dockerized Android, i.e., a platform that allows emulating An-
droid devices in a container-based environment that represents
a fully realistic yet inherently safe place to study and train.

The paper is organized in six sections. Section II discusses
related works associated, respectively, with the introduction
of mobile components in Cyber Ranges and the container-
based emulation of Android devices. Section III proposes a
bird’s eye view of the proposed architecture by providing
a list of requirements to fulﬁll, as well as some possible
usage scenarios. In Section IV dig deeper into the details
associated with its implementation through Docker. Section V
provides a qualitative evaluation of what has been done with
the help of a few practical usage examples. Finally, Section VI
discusses how the proposed architecture naturally lends itself
to the study of advanced mobile hacking scenarios like the so-

 
 
 
 
 
 
TABLE I
THREAT MODEL FOR MOBILE DEVICES

TID

T.P1

T.P2
T.P3
T.P4

T.C1

T.C2

T.A1

T.A2

T.A3

T.A4
T.A5

T.A6

T.D1

T.D2

Description
Physical attack through remote vectors, e.g., cellular, Wi-Fi,
Bluetooth, GPS, NFC, and FM).
Mobile shutdown through physical access.
Device stolen by the attacker.
Authorization abuse through access to the device.
Passive eavesdropping through device network identiﬁers as
Media Access Control.
Man In The Middle attacks.
Abusing APIs supported by the OS with malicious intent, e.g.,
spyware.
Abusing APIs supported by other apps installed on the device.
Untrusted code from the web (i.e., JavaScript) is executed
without explicit consent.
Mimicking system or other app user interfaces to confuse users.
Reading content from system or other app user interfaces.
Injecting input events into the mobile OS system or through other
app user interface.
Perform spanning attacks against the victim’s device through
mobile calls, SMS, or emails.
Exploiting code that processes untrusted content in the OS or
apps through remote or local vulnerabilities.

called “mobile cyber kill chain”. It also highlights interesting
directions for our future work in the ﬁeld.

II. RELATED WORKS

Our platform leverages the beneﬁts of container-based
virtualization, an approach extensively adopted to create
cyber-ranges. Several authors explore the applicability of
container-based solutions to the cyber-range domain. Nataka
et al. (2020) [4] conﬁrm the performance beneﬁts of using
container-based virtualization techniques to reproduce cyber
ranges. In another work, Nakata and Otsuka (2020) [5] evalu-
ate the vulnerability coverage of container-based solutions and
estimate that 99.3% of vulnerabilities are reproducible. Despite
these results, we think that container-based virtualization has
several limitations in terms of vulnerability reproduction. This
is discussed in detail in [6].

Even though there is rich literature about cyber ranges [7],
few researchers have addressed the problem of enhancing
them with support for mobile scenarios. One of the most
recent works that try to ﬁll this gap is authored by Russo
et al. (2020) [8]. The authors give a full overview of the
current scenario about both cyber ranges and security training
before going into a more detailed description of the work that
needs to be done to create Next-Generation Cyber Ranges.
The work introduces an attack scenario inspired by Pierini
and Trotta (2017) [9] that leverages the so-called “Kerberos
Golden Ticket” to obtain administrative privileges. In the
proposed scenario, the attacker has no a priori knowledge and
time-limited access to the target system. The attacker must
proceed through several stages to hack the system, and the
last three steps involve the use of mobile techniques. The
proposed approach emphasizes the integration tasks needed
to build cyber ranges with mobile system support. One of
the most signiﬁcant issues is licensing problems and virtual
hardware compatibility. There are indeed several solutions

to that problem. Genymotion [10] is a commercial solution
that allows the execution of Android virtual devices in three
different ways:

• Desktop: allows running Android Virtual Devices on
one’s own desktop computer (like the ofﬁcial Android
emulator);

• SaaS: allows running Android virtual devices on Geny-

mobile Servers (mostly for test automation);

• PaaS Images: virtual Android images for Cloud providers.
Corellium [11] is yet another commercial solution that
allows to run ARM Virtualized Devices in the Cloud. Such
a solution provides different features for different use cases,
e.g., security research, app streaming, and device modeling.
To solve the licensing issues and take advantage of container-
based capabilities, we leverage the ofﬁcial Android Emulation
platform [12] to build our mobile cyber-range environment.
This choice is justiﬁed by the public availability of several
solutions allowing to have a Docker Image with a pre-installed
Android SDK (and an Emulator as well):

• thyrlian/AndroidSDK: a fully-ﬂedged Android SDK

Docker image [13];

• budtmo/docker-android: an ‘Android in Docker’ solution
with support for noVNC, as well as video recording
capabilities [14];

• bitrise-io/android: a customized Android Docker im-

age [15].

These solutions are based on the SDK and have been
realized for development and testing purposes. In particular,
they leverage the beneﬁt of container-based virtualization in
terms of performance, scalability, and portability but are not
able to fully satisfy the security research and Cyber range
needs. In particular, these solutions do not offer features that
help the realization of scenarios that reproduce the threats
described in Table I. However, they are a good starting point
to work on for solving the Mobile Virtualization problem.

III. DOCKERIZED ANDROID: DESIGN

Nowadays, it is imperative to integrate mobile systems into
a Cyber Range due to the rising importance and ubiquitous
usage of this kind of device. In [8] the difﬁculty of virtualizing
mobile systems is highlighted as the main problem associated
with this kind of integration.

The main purpose of our work is actually the implemen-
tation of a framework that allows the integration of a mobile
system in a container-based environment. We have focused our
efforts on Android for several reasons:

• it is open-source, so it is possible to easily reproduce the

target environment;

• it runs on nearly every device;
• there are many external tools that can easily be integrated

to provide enhanced features.

A further reason for focusing on Android is related to
compatibility issues. In the implemented system, the Android
Emulator is used, and it is both open source and compatible
with all host operating systems (Linux, Windows, and OS X).

The iOS Simulator, on the other hand, is a closed platform
that can only run on OS X, thus making it impossible to
test and work on without a machine running OS X. We have
opted for a container-based solution to take advantage of the
associated performance improvements [4], as well as for the
ever-increasing usage of this kind of virtualization over the
traditional virtual machine approach in current applications.
In particular, the resulting implementation should allow to:

• run an Android virtualized device;
• integrate a physical device;
• control this device through a web browser;
• control this device through the ADB (Android Debug

Bridge) tool;

• conﬁgure the main virtualized components;
• install applications;
• collect data;
• deﬁne networking info;
• conﬁgure usage options;
• integrate other tools.
We formalize these requirements as ten functional (F)

requirements and ﬁve non-functional NF requirements.

[F01] - Android virtual device execution. The resulting
system has to allow the execution of an Android virtualized
device in a container-based environment. Before the execution,
the user should also be able to select a few signiﬁcant options
(like, e.g., the speciﬁc Android OS version).

[F02] - Web browser device management. The user has to
be able to access the device through a web browser using an
ad hoc front-end. This front-end has to provide all the features
through a clean and simple UI (i.e., the device has to be usable
through such a UI).

[F03] - ADB device management The user has to be
able to access the device through the Android Debug Bridge
either directly from the above-mentioned front-end UI or by
accessing the container of the device itself.

[F04] - Virtualized components conﬁguration. The resulting
system has to allow the user to conﬁgure all of the virtu-
alized components of the emulated system. As an example,
the user should be able to conﬁgure the GPS location of
the device or use its SMS features. For obvious reasons,
some hardware components cannot be fully virtualized. For
example, the Android Emulator virtualizes the camera, but
it is nearly impossible to use it in an attack chain. Some
other components, like the microphone, could be virtualized
and used in a simulated attack chain. A proper distinction is
provided in Section V.

[F05] - Application management. The resulting system has
to allow the user to manage the applications on the device.
Namely, the user has to be able to install applications from
ﬁles, as well as to install applications even from the Play
Store (this last feature requires a Google Account, and for
this reason, it is not mandatory).

[F06] - Data collection. The resulting system has to allow
the user to collect data and record the sessions of the platform.
This feature is particularly useful for cyber-range administra-
tors interested in reviewing the actions performed by the users.

[F07] - Networking conﬁguration. The resulting system has
to allow the user to conﬁgure the network before executing the
container. For example, the user has to be able to conﬁgure
the IP addresses of the devices. Another advanced feature is
the ability to expose speciﬁc ports of the virtualized device,
which are used to interact with speciﬁc device services.

[F08] - Features conﬁguration. All of the features described
in the previous requirements must be conﬁgurable, meaning
that before the execution of the container, the user can set some
options or even decide the activation of a particular feature to
customize the environment entirely.

[F09] - Third-party tools integration. The platform has
to allow third-party tools integration with minimum effort,
meaning that it should expose the proper interfaces in order
to communicate with a third-party container that can be
used as a tool. For example, the Mobile Security Framework
(MobSF) [16] could be integrated and used in a particular
conﬁguration that allows the user to test the security of an
app using the virtualized system.

[F10] - Physical device integration. The system has to be
able to integrate an Android physical device fully. Even when
a physical device is connected, all of the features described
previously must be usable in the same way.

[NF01] - Management UI scalability. The front-end UI
described in the requirement F02 has to be adaptive, meaning
that it can be used with different screen resolutions.

[NF02] - Image size shrinking. The resulting system (that
could be either a single Docker image or multiple ones) has
to be developed by trying to reduce as much as possible
the dimensions of the resulting image to save space on the
device that actually runs the system. In order to optimize the
environment, we followed all the best practices suggested by
the Docker Community [17] to keep the container’s size as
low as possible.

[NF03] - Separation of concerns. The Docker Community
switched to the ’single concern’ principle [17], meaning that
a single Docker image can run multiple processes if related to
the same concern. The framework should keep this principle
in mind when implementing its own images.

[NF04] - Host cross-platform compatibility. The platform
must be usable on different operating systems (i.e., Linux,
macOS, Windows).

[NF05] - Device type transparency. The resulting system
has to also allow for the execution of a physical Android
device transparently. The physical device should get connected
via either a wired or a wireless communication channel.

Table II summarizes the above features; it is also used as a

reference model in section V:

IV. DOCKERIZED ANDROID ARCHITECTURE

This section shows the architecture of Dockerized Android.
Fig. 1 provides a high-level view of the Dockerized Android
platform that allows identifying the key components it com-
prises:

• Android Mobile Component: is the Android system acces-
sible from the other components. It can be indifferently an

TABLE II
DESIGN REQUIREMENTS

ID
F01
F02
F03
F04
F05
F06
F07
F08
F09
F10
NF01
NF02
NF03
NF04
NF05

Type
Functional
Functional
Functional
Functional
Functional
Functional
Functional
Functional
Functional
Functional
Non-Functional
Non-Functional
Non-Functional
Non-Functional
Non-Functional

Description
Android Virtual Device execution
Browser management
ADB device management
Virtualized components conﬁguration
Application management
Data collection
Network Conﬁguration
Features Conﬁguration
Third-party tools integration
Physical device integration
Management UI scalability
Image size shrinking
Separation of concerns
Host Cross-Platform compatibility
Device type transparency

increase the end-user experience as well;

• Screen Sharing: the goal of this component is to provide
a server that can be used by another component in order
to give the user a simpler way to access and control the
mobile device;

• Custom API: as several features are integrated into the
system, this component provides access to the external
tools with a uniform interface that hides the underlying
cumbersome integration mechanisms;

• Management UI: is the application front-end that can
be accessed by the user to control the mobile device
and enable the other features provided by the platform;
The UI uses the VNC (Virtual Network Computing)
component to let the user control the device through a
web browser, the abd component to provide a shell to
interact with the device in a more advanced way, and the
Custom API to provide access to other features effortless;
• Extra Tools: this component encloses the external tools

used to add further features to the platform.

Fig. 2 shows a in-depth view of the modules implemented in
the framework: The architecture can be divided into two parts:

Fig. 1. Overall Architecture, resources from ﬂaticon.com [18]

emulated device or a real one connected to the machine
hosting the container (through a cable or wireless). This
component has to provide all of the features related to
the Android OS itself, but also the hardware components
that can be simulated (like the GPS or the microphone
through the integration of an external device);

• adb: is the well-known Android Debug Bridge allowing
to control an Android system (either an emulated one
or a real one) through a command-line interface. This
component allows having a shell on the device, conﬁgure
options, install applications, etc. It has to be externally
accessible to provide a higher level of conﬁguration and

Fig. 2. Dockerized Android detailed architecture

• Core: executes all the processes needed to run an Android
Component (Emulated or Real) inside a Docker container,
also exposing some features to the outside.

• UI: gives the user a UI to access the Core component in

a simpler way through a web browser.

The Core component is composed of several modules that
execute “long-lived processes” (i.e., processes that offer sev-
eral functionalities along with all the Dockerized Android
execution), “start processes” (i.e., processes executed during
the framework’s bootstrap phase), and “utility scripts”. The
internal modules implement several features:

• xvdb, srcpy, and x11vnc modules simulate a real display
and synchronize the device’s monitor with a virtual X
server in the host system (i.e., the computer system that
executes Dockerized Android).

• The websockify module converts the VNC communication
protocol used by x11vnc to Web Socket network protocol;
in this way, it is possible to view the mobile’s screen
through a Web browser.

• The emulator component manages the Android Virtual
Device that emulates the mobile device when an emulated
device is used.

• The backend module written in Node.js implements an
extendible interface that allows adding cyber-range fo-
cused features, such as the dispatch of a malicious SMS
or e-mail to simulate phishing attacks.

• The adb-utils module implements several utility scripts
that use the ADB tool for implementing other func-
tionality, such as the installation of vulnerable Android
applications or instruments the mobile device with mobile
security toolkits, such as Frida [19].

• The rinetd-forward module manages the emulator’s port
forwarding by enabling the network communication be-
tween all the components.

The UI component is composed of a React Frontend and is
served through an NGINX server. The UI is developed using
the most recent features provided by the React framework, like
Hooks and Context, in order to follow the principle of strong
cohesion and loose coupling. The UI provides a simple way
to use all the features exposed by the backend and also adds
the ability to display and control the device. The user has to
manually insert the address of the Core component and the
corresponding ports (the port exposed by the backend and the
port exposed by websockify. Fig. 3 shows the most interesting
Dockerized Android user interface view.

The implementation of the above-mentioned architecture is

publicly accessible on GitHub [20].

V. EVALUATION

Fig. 3. UI Dockerized Android

A. Differences between Core for Emulator and Core for Real
Device

Even if a signiﬁcant effort has been put into creating a
system that has the same features for both kinds of devices,
there are limitations when emulation is used:

• SMS ADB send/reception feature: in emulated devices,
it
is possible to automate the send and reception of
SMS messages through the ADB software. Obviously,
this is not natively possible for real devices. Therefore,
the user must manually send and receive SMS messages
to implement SMS attack scenarios. A solution to address
this problem could be the realization of a custom Android
application that could be installed on a real device and
could be instrumented to send and receive messages
automatically.

• Networking: networking is quite different between the
Emulator and the Real device ﬂavors. In the emulator
version, the AVD is created inside the Docker container,
and therefore it shares the container’s IP address. Instead,
the real device is physically connected to the machine that
runs the container and keeps its own IP address.

• Hardware virtualization: for the hardware components,
the situation is quite different, too: some hardware de-
vices like the GPS and the microphone can be emulated.
In particular, the GPS location of the device can be set
through ADB, and the microphone of the host machine
can be shared with the emulator. There are other hardware
components that currently cannot be emulated, like, e.g.
Bluetooth.

This section assesses the Dockerized Android platform by
examining several aspects. Firstly, we emphasize the differ-
ences between the Core for Emulator and Core for Real Device
components in terms of features and highlight compatibility
with the three most used Operating Systems. Then, we provide
practical usage examples of Dockerized Android and discuss
coverage of the requirements deﬁned in Section III.

B. Host evaluation for cross-platform compatibility

The non-functional requirement NF04 (Cross-platform com-
patibility) states that the resulting system should be usable
from within any host OS. This refers to the OS of the machine
that runs the Docker containers. Table III provides a summary
of the compatibility with Linux, Windows, and OS X.

TABLE III
HOST OS COMPATIBILITY COMPARISON

Linux
Windows
OS X

Core for Emulator
Full Compatibility
Not supported (yet)
Not supported

Core for Real Device
Full Compatibility
Full Compatibility
Workaround

The problem with Windows is that currently, the best way
to use Docker is through the Windows Subsystem for Linux
(WSL) framework. Unfortunately, WSL does not support
nested virtualization yet, and this feature is required to run
the Android emulator inside a Docker container. However, the
feature will be available in upcoming WSL releases. It might
be possible to run the Core for Emulator ﬂavor on Windows by
using a virtual machine, though losing all of the performance
beneﬁts associated with containerization. A similar issue does
exist with OS X, with which there is currently no way to run
the Core for Emulator. Besides, OS X does not allow sharing
the USB device with a Docker container. For this reason, the
only ways to use the Core for Real Device ﬂavor are to either
run ADB over Wi-Fi or connect to the host ADB from within
the Docker container.

In the remainder of this section, we show the effectiveness
of Dockerized Android in reproducing security kill chains by
using both the Core for Emulator and Core for Real Device.

C. Security attack reproduction on the emulator

We herein focus on a sample vulnerability scenario as-
sociated with CVE-2018-76611. This CVE is related to the
free version of the application “Wi-Fi Baby Monitor”. This
application has to be installed on two devices in order to act
as a so-called baby monitor (a radio system used to remotely
listen to sounds emitted by an infant). As reported in the
National Vulnerability Database, “Wi-Fi Baby Monitor Free &
Lite” before version 2.02.2 allows remote attackers to obtain
audio data via certain speciﬁc requests to TCP port numbers
8258 and 8257”.

TABLE IV
REQUIREMENTS FOR WI-FI BABY MONITOR

Device Type
Application
APK Version

Real Device or Emulator
Wi-Fi Baby Monitor
Free & Lite before 2.02.2

The premium version of this application offers users the
ability to specify a password to use in the pairing process. By
monitoring the network trafﬁc, it is possible to observe that:

• the initial connection takes place on port 8257;
• the same sequence is always sent to start the pairing

process;

• at the end of the pairing process, a new connection is
started on port 8258. This port is used to transmit the
audio data;

• after connecting to the port 8258, the other connection
on the port 8257 is kept open and used as a heartbeat for
the session;

• on the heartbeat connection, the client periodically sends
the hexadecimal byte 0x01 (about once per second);
The proof of concept that allows the attacker to obtain audio
data is given in [21]. This Proof of Concept (PoC) is easily
reproducible on Dockerized Android through the realization
of an infrastructure composed of three services:

• core-emulator: an instance of the Core component with
a pre-installed Baby Monitor app acting as the sender;

• ui: the UI component to control what is going on;
• attacker: a customized version of Kali Linux that au-
tomatically installs all the dependencies needed for the
execution of the PoC.

This is also a perfect example to show the Port Forwarding

feature used to enable the communications.

D. Security attack reproduction on the real device

With the real device, we examine a further vulnerability,
known as BlueBorne. The term “BlueBorne” refers to mul-
tiple security vulnerabilities related to the implementation
of Bluetooth. These vulnerabilities were discovered by a
group of researchers from Armis Security, an IoT security
company, in September 2017. According to Armis, at the
time of discovery, around 8.2 billion devices were potentially
affected by the BlueBorne attack vector, which affects the
Bluetooth implementations in Android, iOS, Microsoft, and
Linux, hence impacting almost all Bluetooth device types
such as smartphones, laptops, and smartwatches. BlueBorne
was analyzed in detail in a paper published on the 12th of
September 2017 by Ben Seri and Gregor Vishnepolsk [22].
Eight different vulnerabilities can be used as part of the attack
vector.

Regarding Android, all devices and versions (therefore
versions older than Android Oreo, which was released in
December 2017) are affected by the above-mentioned vul-
nerabilities, except for devices that support BLE (Bluetooth
Low Energy). In general, two requirements should be satisﬁed
to exploit the vulnerability: (i) the target device must have
Bluetooth enabled; (ii) the attacker must be close enough to
the target device. As the Bluetooth feature is not available
in the Core Emulator, the kill-chain in question can only be
reproduced on real devices.

1) BlueBorne full reproduction on Dockerized Android: In
order to show the effectiveness of Dockerized Android, we
developed a kill chain that exploits two Remote Code Execu-
tion (RCE) vulnerabilities that affect Android, i.e., CVE-2017-
0781 and CVE-2017-0782. These vulnerabilities fall within
the Bluetooth set vulnerability’s set deﬁned “BlueBorne” and
discovered by a group of security researchers from Armis
Security [23].

The diagram in Fig. 4 gives an overview of the developed

kill chain:

1) The attacker creates a phishing email through Gophish,

1https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-7661

a phishing generator software.

2) The phishing email is sent to a victim’s mailbox.
3) The victim reads the phishing email and erroneously
clicks a malicious link contained in the email’s body.
4) The malicious link allows the attacker to trigger an
attack that downloads and installs a fake application on
the victim’s mobile device.

5) The malicious information sends relevant mobile infor-
mation to the attacker. This information is required for
the exploitation of the two vulnerabilities.

6) The attacker crafts a malicious payload to exploit the

vulnerabilities.

7) The attacker sends the attack by exploiting the Bluetooth
component’s vulnerabilities and has remote access to the
victim’s device.

context, it is used to get some useful information about
the target device. This application is used on the host
machine without Docker.

• Fake Spotify: a seemingly benign application that pretends
to provide the user with a free version of the well-known
Spotify Premium app, but rather sends to the attacker’s
server exﬁltrated ﬁles that are reverse-engineered on
Ghidra. Also, this app was created without the usage of
Docker.

Listing 1 shows how it is possible to simulate a container-
based virtualized scenario by deﬁning a docker-compose ﬁle,
i.e., a declarative ﬁle interpreted by the Docker engine to
generate the virtual infrastructure.

v e r s i o n :
s e r v i c e s :

" 3 . 8 "

c o r e − r e a l :
image :

s e c s i / d o c k e r i z e d − a n d r o i d − c o r e −

r e a l − d e v i c e

p r i v i l e g e d :
n e t w o r k s :

t r u e

b l u e b o r n e − n e t :

i p v 4 _ a d d r e s s : 1 0 . 5 . 0 . 2

u i :

image :
p o r t s :

s e c s i / d o c k e r i z e d − a n d r o i d − u i

− " 8 0 8 0 : 8 0 "

n e t w o r k s :

b l u e b o r n e − n e t :

i p v 4 _ a d d r e s s : 1 0 . 5 . 0 . 3

a t t a c k e r _ p h i s h i n g :

image : g o p h i s h / g o p h i s h
p o r t s :

− " 3 3 3 3 : 3 3 3 3 "
− " 8 0 8 1 : 8 0 8 0 "

v o l u m e s :

− . / p h i s h i n g : / home / p h i s h i n g

n e t w o r k s :

b l u e b o r n e − n e t :

i p v 4 _ a d d r e s s : 1 0 . 5 . 0 . 4

a t t a c k e r _ b l u e b o r n e :

image :

s e c s i / k a l i − r o l l i n g − w i t h −

d e p e n d e n c i e s : l a t e s t

t r u e

t t y :
v o l u m e s :

− . / e x p l o i t : / home / e x p l o i t
− . / d e p e n d e n c i e s − b l u e b o r n e : / home /

d e p e n d e n c i e s

e n v i r o n m e n t :

− SH_DEPENDENCIES_FILE_PATH = / home /

d e p e n d e n c i e s /

d e p e n d e n c i e s . s h

p r i v i l e g e d :
network_mode :

t r u e

" h o s t "

a t t a c k e r _ w e b _ s e r v e r :

image :

s e c s i / k a l i − r o l l i n g − w i t h −

Fig. 4. Exploit Chain Overview

The complex scenario covers several threats deﬁned in Table I.
Table V shows such threats and both the platform functionali-
ties and components that allow the scenario reproduction. The

TABLE V
THREATS, SCENARIO’S STEPS, FEATURES AND COMPONENTS

Threat ID

Scenario step

Useful features

T.D1

T.A4

T.A1, T.D2

T.P1

2,3

4

5

7

F01, F02, F08,
F10

F02, F03

F07

F10

Dockerized
Android
components

xvdb, scrpy,
x11vnc

websockify, UI,
backend,
adb-utils

rinetd-forward

backend

scenario requires complex network communications (F07) and
involves the utilization of Bluetooth. For this reason, we have
to use a physical device (F10). In the proposed scenario, we
have to simulate the installation of the malicious application
when the user receives the email. This can be done either
manually (F02) or by implementing utility ADB scripts (F03).
In order to reproduce the scenario, additional elements are
needed:

• Gophish: a webapp that allows to craft and send phishing

emails, for which a Docker version already exists.

• Ghidra: an application created by the National Security
Agency (NSA) for reverse engineering purposes. In this

d e p e n d e n c i e s : l a t e s t

t r u e

t t y :
p o r t s :

− " 8 0 0 0 : 8 0 0 0 "

v o l u m e s :

− . / w e b s e r v e r : / home / w e b s e r v e r
− . / d e p e n d e n c i e s − w e b s e r v e r : / home /

d e p e n d e n c i e s

e n v i r o n m e n t :

− SH_DEPENDENCIES_FILE_PATH = / home /

d e p e n d e n c i e s /
d e p e n d e n c i e s . s h

n e t w o r k s :

b l u e b o r n e − n e t :

i p v 4 _ a d d r e s s : 1 0 . 5 . 0 . 5

n e t w o r k s :

b l u e b o r n e − n e t :

ipam :

c o n f i g :

− s u b n e t : 1 0 . 5 . 0 . 1 / 2 4

Listing 1. docker-compose.yaml for the BlueBorne kill chain

It

is composed of ﬁve services,

two of which are the
subcomponents of Dockerized Android. The remaining three
are brieﬂy described in the following:

• attacker_phishing: contains the Gophish component used
to craft and send the phishing email that tricks the user
into downloading the malicious Fake Spotify app;

• attacker_web_server: contains the webserver used to re-
ceive the ﬁles sent by the malicious app, which are
reverse engineered in order to ﬁnd information allowing
the vulnerability on the target
the attacker to exploit
device;

• attacker_blueborne: the service used by the attacker to
execute the attack on the target device and obtain a
reverse shell on it.

E. Requirements coverage

In Table II we have illustrated the deﬁned requirements for
the realization of our platform. The following table contains
all the requirements and their corresponding status:

TABLE VI
REQUIREMENTS EVALUATION

Requirement ID
F01
F02
F03
F04
F05
F06
F07
F08
F09
F10

Status
Completed
Completed
Completed
Partial
Completed
Partial
Completed
Completed
Completed
Completed

Requirement F04, as detailed before, is set to Partial be-
cause of the inability to correctly conﬁgure all the hardware

components (for example the Bluetooth device). Requirement
F06 is set to partial because ADB gives the ability to record
the screen out-of-the-box, but this feature was not exposed
or made easier to use through the UI. Finally, requirements
F07 (Network Conﬁguration) and F09 (Third-Party Tools
integration) are granted by default because of the usage of
Docker. The network can be deﬁned in any possible way
through the docker-compose ﬁle, and third-party tools can be
easily used together with this system.

VI. CONCLUSION AND FUTURE DEVELOPMENTS

In this work, we have described Dockerized Android, a plat-
form that supports cyber-range designers in realizing mobile
virtual scenarios. The application is based on Docker, i.e., a
container-based virtualization framework extensively adopted
in the cyber-range ﬁeld for several beneﬁts already mentioned.
We described the main components and showed how it is
possible to realize a complex cyber kill-chain scenario that
involves the utilization of Bluetooth components. The archi-
tecture has been conceived at the outset as an extensible one.
Its feature set can be dynamically enabled or disabled through
the docker-compose creator, and some ﬁne-grained options
can be conﬁgured to customize the scenarios. The strength
of this system is its ability to quickly run a mobile component
through Docker, with many interesting features out of the
box. Furthermore, the centralization of several components
increases the overall usability level. The cons are all related to
compatibility issues with Windows and OS X when running
the Core for Emulator. While the former will probably be
solved with the next updates, the latter is not solvable without
signiﬁcant changes to the OS X implementation. Another
limitation is the lack of support for emulating some hardware
the Linux
components, e.g., Bluetooth. For these reasons,
environment as a host machine is strongly recommended. We
will also assess the potential beneﬁts of using Dockerized
Android in cloud-based environments in future works. Other
improvements include the full integration of security-based
features in the Android Emulator. For example,
the GPS
location could be useful to simulate a realistic route traveled by
a simulated user. In recent works, cyber ranges are conﬁgured
by using the high-level SDL (Speciﬁcation and Description
Language) representation [8]. Integrating this language in
Dockerized Android is relatively easy, as every feature is
set through Docker environment variables. Additional efforts
will be focused on improving automation features, such as
the design of an event-based architecture to simulate complex
sequential actions involving human interaction.

REFERENCES

[1]

Jan Vykopal et al. “Lessons learned from complex
hands-on defence exercises in a cyber range”. In: 2017
IEEE Frontiers in Education Conference (FIE). 2017,
pp. 1–8. DOI: 10.1109/FIE.2017.8190713.

[18] Flaticon. Free vector icons. https://www.ﬂaticon.com/.

[Online; accessed 17-April-2021].

[19] Frida. Frida. https://frida.re/. Online; 13-May-2022.
[20] Anonymized authors. Dockerized Android github repo.
. In order to adhere to the double-blind review princi-
ple, the github repo information has been obfuscated
and will be made available if and when the paper is
accepted.

[21] Android-Exploits. https : / / github . com / sundaysec /
Android - Exploits / blob / master / remote / 44242 . md.
[Online; accessed 19-April-2021].

[22] Ben Seri and Gregory Vishnepolsky. BlueBorne - The
dangers of Bluetooth implementations: Unveiling zero
day vulnerabilities and security ﬂaws in modern Blue-
tooth stacks. Tech. rep. Armis, 2017.

[23] Armis Security. BlueBorne. https : / / www. armis . com /
research/blueborne/. Online; 13-May-2022. 2017.

[2] Adam McNeil and W. Stuart Jones. Mobile Malware
is Surging in Europe: A Look at the Biggest Threats.
https://www.proofpoint.com/us/blog/email-and-cloud-
threats/mobile- malware- surging- europe- look- biggest-
threats. Online; 14-May-2022. 2022.

[3] René Mayrhofer et al. “The Android Platform Security
Model”. In: ACM Transactions on Privacy and Security
24.3 (Aug. 2021), pp. 1–35. DOI: 10 . 1145 / 3448609.
URL: https://doi.org/10.1145/3448609.

[4] Ryotaro Nakata and Akira Otsuka. “CyExec*: A High-
Performance Container-Based Cyber Range With Sce-
IEEE Access 9 (2021),
nario Randomization”.
In:
pp. 109095–109114. DOI: 10 . 1109 / ACCESS . 2021 .
3101245.

[5] Ryotaro Nakata and Akira Otsuka. Evaluation of vulner-
ability reproducibility in container-based Cyber Range.
2020. DOI: 10.48550/ARXIV.2010.16024. URL: https:
//arxiv.org/abs/2010.16024.

[6] Francesco Caturano, Gaetano Perrone, and Simon
Pietro Romano. “Capturing ﬂags in a dynamically
deployed microservices-based heterogeneous environ-
ment”. In: 2020 Principles, Systems and Applications
of IP Telecommunications (IPTComm). 2020, pp. 1–7.
DOI: 10.1109/IPTComm50535.2020.9261519.

[7] Muhammad Mudassar Yamin, Basel Katt, and Vasileios
Gkioulos. “Cyber ranges and security testbeds: Scenar-
ios, functions, tools and architecture”. In: Computers &
Security 88 (Jan. 2020), p. 101636. DOI: 10 . 1016 / J .
COSE.2019.101636.

[8] Enrico Russo, Luca Verderame, and Alessio Merlo.
“Enabling Next-Generation Cyber Ranges with Mobile
Security Components”. In: IFIP International Confer-
ence on Testing Software and Systems. Springer, 2020,
pp. 150–165.

[9] Giuseppe Trotta Andrea Pierini. From APK to Golden
Ticket. https://www.exploit-db.com/docs/english/44032-
from- apk- to- golden- ticket.pdf. [Online; accessed 01-
March-2021]. 2017.

[10] Genymotion. Android as a Service. https : / / www .

genymotion.com/. [Online; accessed 1-March-2021].

[11] Corellium. ARM Device Virtualization. https : / /

corellium.com/. [Online; accessed 10-March-2021].

[12] Android Emulator. https : / / developer . android . com /

[13]

studio/run/emulator. Accessed: 11-01-2021.
thyrlian. AndroidSDK. https : / / github . com / thyrlian /
AndroidSDK. [Online; accessed 10-March-2021].
[14] budtmo. docker-android. https : / / github. com / budtmo /

docker-android. [Online; accessed 10-March-2021].

[15] bitrise-io. android. https://github.com/bitrise-io/android.

[Online; accessed 10-March-2021].

[16] MobSF. Mobile Security Framework. https : / / www .
github . com / MobSF / Mobile - Security - Framework -
MobSF. [Online; accessed 1-March-2021].

[17] Dockerﬁle best practices. https : / / docs . docker . com /
develop / develop - images / dockerﬁle _ best - practices/.
Accessed: 13-02-2021.

