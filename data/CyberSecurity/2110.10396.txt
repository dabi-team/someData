UPPRESSO: Untraceable and Unlinkable Privacy-PREserving
Single Sign-On Services

2
2
0
2

p
e
S
2

]

R
C
.
s
c
[

2
v
6
9
3
0
1
.
0
1
1
2
:
v
i
X
r
a

Chengqian Guo1,2,4, Jingqiang Lin3, Quanwei Cai 1,2,4, Wei Wang 1,2,4, Fengjun Li 5,
Qiongxiao Wang 1,2,4, Jiwu Jing 4, Bin Zhao 6
1 State Key Laboratory of Information Security, Institute of Information Engineering, CAS
2 Data Assurance and Communication Security Research Center, CAS
3 School of Cyber Security, University of Science and Technology of China
4 School of Cyber Security, University of Chinese Academy of Sciences
5 University of Kansas
6 JD.com Silicon Valley R&D Center

Abstract

introduces reasonable overheads.

Single sign-on (SSO) allows a user to maintain
only the credential at the identity provider (IdP), to
login to numerous RPs. However, SSO introduces extra
privacy threats, compared with traditional authentica-
tion mechanisms, as (a) the IdP could track all RPs
which a user is visiting, and (b) collusive RPs could
learn a user’s online proﬁle by linking his identities
across these RPs. This paper proposes a privacy-
preserving SSO system, called UPPRESSO, to protect
a user’s login activities against both the curious IdP
and collusive RPs. We analyze the identity dilemma
between the security requirements and these privacy
concerns, and convert the SSO privacy problems into
an identity transformation challenge. In each login
instance, an ephemeral pseudo-identity (denoted as
P IDRP ) of the RP, is ﬁrstly negotiated between the
user and the RP. P IDRP is sent
to the IdP and
designated in the identity token, so the IdP is not aware
of the visited RP. Meanwhile, P IDRP is used by the
IdP to transform the permanent user identity IDU into
an ephemeral user pseudo-identity (denoted as P IDU )
in the identity token. On receiving the identity token,
the RP transforms P IDU into a permanent account
(denoted as Acct) of the user, by an ephemeral trap-
door in the negotiation. Given a user, the account at
each RP is unique and different from IDU , so collusive
RPs cannot link his identities across these RPs. We
build the UPPRESSO prototype on top of MITREid
Connect, an open-source implementation of OIDC. The
extensive evaluation shows that UPPRESSO fulﬁlls
the requirements of both security and privacy and

1. Introduction

Single sign-on (SSO) protocols such as OpenID
Connect (OIDC) [1], OAuth 2.0 [2] and SAML [3],
[4], are widely deployed in the Internet for identity
management and authentication. With the help of SSO,
a user logins to a website, referred to as the relying
party (RP), using his identity registered at a trusted
web service, known as the identity provider (IdP). An
RP delegates user identiﬁcation and authentication to
the IdP, which issues an identity token (e.g., id token
in OIDC or identity assertion in SAML) for a user to
visit the RP. For example, in common OIDC systems,
a user sends a login request to the target RP. Then, the
RP constructs an identity-token request with its identity
(denoted as IDRP ) and redirects this request to the IdP.
After authenticating the user, the IdP issues an identity
token explicitly binding the identities of both the user
and the RP (i.e., IDU and IDRP ), which is returned
to the user and forwarded to the RP. Finally, the RP
veriﬁes the identity token to decide whether the user
is allowed to login or not. So, a user keeps only one
credential for the IdP, instead of several credentials for
different RPs.

As the comprehensive solution of identity manage-
ment and authentication, SSO services allow the IdP
to provide more attributes in the tokens along with the
authenticated user’s identity. The attributes (e.g., age,
hobby, education, and nationality) are maintained at

 
 
 
 
 
 
the IdP, and enclosed in the identity tokens after the
user’s authorization [1], [2].

The wide adoption of SSO raises concerns on user
privacy [5]–[8], because SSO facilitates curious parties
to track a user’s login activities. To issue identity
tokens, in each login instance the IdP is aware of
when and to which RP a user attempts to login. As
a result, an honest-but-curious IdP could track all the
RPs that each user has visited over time [7], [8], called
IdP-based login tracing in this paper. Meanwhile, the
RPs learn users identities from the identity tokens. If
the IdP encloses the same user identity in the tokens
when the user visits different RPs [9], [10], collusive
RPs could link these login instances across the RPs
and learn the user’s online proﬁle [5]. We denote this
privacy risk as RP-based identity linkage.

Privacy-preserving SSO schemes are expected to
support comprehensive identity management and au-
thentication while protecting user privacy [5]–[8].
Therefore, they should provide the following design
features: (a) User identity at an RP, i.e., an identity
token enables an RP to uniquely identify every user,
(b) User authentication only to the IdP, i.e., the steps
of authentication between a user and the RP are
eliminated, and a user only needs to hold the secret
credential to authenticate himself to the IdP, and (c)
Provision of IdP-conﬁrmed user attributes, i.e., a user
maintains his attributes at the trusted IdP and RP-
requested attributes are provided after authorized by
the user. Meanwhile, the privacy threats from different
types of adversaries are considered: (a) honest-but-
curious IdP, (b) collusive RPs, and (c) honest-but-
curious IdP colluding with some RPs. In Section
2.2, we overview the existing privacy-preserving SSO
solutions and identity federation.

We conceptualize the privacy requirements of SSO
into an identity transformation problem and propose
an Untraceable and Unlinkable Privacy-PREserving
Single Sign-On (UPPRESSO) protocol
to protect
user privacy. In particular, we design three identity-
transformation functions for the SSO login ﬂow. In
each login instance, the RP transforms its IDRP to an
ephemeral P IDRP for the requesting user and sends it
to the IdP, who then transforms IDU to an ephemeral
P IDU accordingly. Hence, the identity token binds
ephemeral IDs instead of the permanent ones. Finally,
after receiving an identity token with the matching
P IDRP , the RP transforms P IDU into a user “ac-
count”, which remains identical across multiple login
instances. Meanwhile, a user’s accounts at different
RPs are different and unrelated.

Unlike existing privacy-preserving SSO solu-
tions [6]–[8] that prevent only one of the two privacy
threats, UPPRESSO can eliminate both of them. It
prevents IdP-based login tracing by hiding the RP’s
permanent
identity from the IdP during the login
process and RP-based identity linkage by construct-
ing unique yet consistent user accounts at each RP.
The identity transformations work compatibly with the
login ﬂows of widely-adopted SSO protocols [1]–[3],
[6] so that UPPRESSO supports all desired security
features of SSO. We summarize our contributions as
follows.

•

• We formalize the SSO privacy problems as an
identity-transformation challenge and propose
a solution to protect users’ login activities; that
is, solve this challenge by designing identity-
transformation functions.
The UPPRESSO protocol is presented based
on identity transformations with several de-
signs speciﬁc for web applications. We prove
that UPPRESSO satisﬁes all the security and
privacy requirements of the SSO services.
• We build a prototype system for web appli-
cations on top of an open-source OIDC im-
plementation. With experimental performance
evaluations, we show that UPPRESSO intro-
duces reasonably small overheads.

The remainder is organized as below. Section 2
presents the background and related works. The iden-
tity dilemma of privacy-preserving SSO is analyzed
in Section 3, and Section 4 presents the designs of
UPPRESSO. Security and privacy are analyzed in
Section 5. We explain the prototype implementation
and experimental evaluations in Section 6, and discuss
extended issues in Section 7. Section 8 concludes this
work.

2. Background and Related Works

We introduce typical SSO login ﬂows and discuss
existing privacy-preserving solutions and other related
works.

2.1.OpenID Connect and SSO Services

OIDC is one of the most popular SSO protocols.
Users and RPs initially register at the IdP with their
identities and other necessary information such as user
credentials and RP endpoints (i.e., the URLs to receive
identity tokens). It supports three types of login ﬂows,

2

at the IdP. If it is lost or leaked, the user only renews
it at the IdP. However, if a user proves some non-
ephemeral secret to RPs, which is valid across multiple
login instances (i.e., authentication steps are actually
involved), he has to notify each RP when it is lost or
leaked.

IdP-conﬁrmed selective attribute provision. The IdP
usually provides user attributes in the authentication
tokens [1]–[3], in addition to user (pseudo-)identities.
These attributes are maintained by users at the IdP. Be-
fore enclosing attributes in a token, the IdP obtains the
user’s authorization or provide only the attributes pre-
selected by the user. So, no distinctive attributes such
as telephone number and email address are enclosed in
the identity tokens of privacy-preserving SSO systems.

2.2.Privacy-Preserving SSO and Identity Federation

We summarize prior privacy-preserving solutions
for SSO and identity federation in Table 1. Widely-
adopted SSO protocols [1]–[4] allow a user to log
in to an RP without holding any permanent secret
veriﬁed by the RP or maintaining an account at the
RP. While preserving this feature, existing privacy-
preserving SSO approaches [6]–[8] prevent either IdP-
based login tracing or the RP-based identity linkage,
while UPPRESSO prevents both threats.

Identity federation enables a user registered at
the IdP to be accepted by other parties, with dif-
ferent accounts sometimes, but more user operations
are involved than those of SSO. Privacy-preserving
identity federation [12]–[16] protects privacy against
even collusive attacks by the IdP and the RPs, but
requires a user to (a) hold long-term secrets veriﬁed
by RPs, in addition to the authentication credentials
for the IdP, and (b) manage the accounts at different
RPs by himself. That
there are actually some
is,
authentication steps between the user and RPs (or
called asynchronous authentication [13]).

Pairwise pseudonymous identiﬁers (PPIDs) are rec-
ommended [6] and speciﬁed in SSO protocols [1],
[4] to protect user privacy against curious RPs. When
issuing an identity token, the IdP encloses a user PPID
(but not the identity at the IdP). Given a user, the IdP
assigns a unique PPID based on the target RP. So,
collusive RPs cannot link the users. However, PPIDs
cannot prevent IdP-based login tracing because the IdP
needs the RP’s identity to issue tokens.

Several solutions prevent IdP-based login tracing
but are vulnerable to RP-based identity linkage. In

Figure 1: The implicit SSO login ﬂow of OIDC.

i.e. implicit ﬂow, authorization code ﬂow, and hybrid
ﬂow (a mix-up of the other two). While they work with
different steps to request and receive identity tokens,
they share the common security requirements for the
identity tokens. Next, we focus on the implicit ﬂow to
present our designs. In Section 7, we will discuss the
support to the authorization code ﬂows.

As shown in Figure 1, when a user initiates a login
request to an RP, the RP constructs an identity-token
request with its own identity and the scope of the
requested user attributes. This request is redirected to
the IdP. After authenticating the user, the IdP issues
an identity token that will be forwarded by the user
to the RP’s endpoint. The token contains user identity
(or pseudo-identity), RP identity, a validity period, the
requested user attributes, etc. Finally, the RP veriﬁes
the received identity token and allows the user to login
as the enclosed (pseudo-)identity. The user’s operations
including redirection, authorization, and forwarding
are implemented in a software called user agent (e.g.,
a browser).

Three design features are expected in SSO services,
which are supported by popular SSO systems [1]–[4],
[6].

User identiﬁcation at an RP. The RP is expected to
recognize each user (by a unique identiﬁer or account)
and provide customized services across multiple lo-
gins.

User authentication only to the IdP. A “pure” SSO
protocol [1]–[3] does not include the authentication
steps. The authentication between a user and the IdP
is conducted independently and the RPs only need to
verify the tokens issued by the IdP. This design has
several advantages. First, the IdP could authenticate
users by any appropriate means (e.g., password, one-
time password, and multi-factor authentication). Mean-
while, the user only needs to maintain his credential

3

IdPUserRPLogin RequestIdentity-Token Request, IDRP, EnptRPAuthenticationSign [IDRP, IDU]SK[IDRP, IDU]SKVerify [IDRP, IDU]SKLogin ResultTable 1: Privacy-Preserving Solutions of SSO and Identity Federation.

SSO Feature - supported

, unsupported

Solution

User Identity
at an RP

User Authentication
Only to the IdP

(cid:32)

, or partially
IdP-Conﬁrmed Selective
(cid:71)(cid:35)
Attribute Provision

(cid:35)

Privacy Threat - prevented

IdP-based
Login Tracing

RP-based
Identity Linkage

OIDC with PPID [6]
BrowserID [7]
SPRESSO [8]
PRIMA [11]
PseudoID [12]
EL PASSO [13]
UnlimitID [14]
Opaak [15]
Fabric Idemix [16]
U-Prove [17]
UPPRESSO

(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
4
(cid:32)
5
(cid:71)(cid:35)
(cid:35)
(cid:32)
(cid:32)

1
(cid:32)
(cid:71)(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)

(cid:32)
2
(cid:35)
(cid:35)
3
(cid:32)
(cid:35)
(cid:32)
(cid:32)
(cid:35)
6
(cid:32)
(cid:71)(cid:35)
(cid:32)

(cid:35)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)

or not
Collusive Attack
(cid:32)
(cid:35)
by the IdP and RPs
-
-
-
-

(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:35)

(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)

1. A BrowserID user generates an ephemeral private key to sign every “subsidiary” token, which is veriﬁed by the RP.
2. SPRESSO can be extended to provide user attributes in then tokens, while the prototype does not support it.
3. Blindly-signed user attributes can be selectively provided using zero-knowledge proofs, but not implemented in the prototype [12].
4. Opaak supports exclusive pseudonym options: (a) linkable within an RP but unlinkable across multiple RPs and (b) unlinkability for any
two actions.
5. In the original design of Idemix [18], every user logins to an RP with a unique account.
6. A U-Prove token may contain some attributes invisible to the IdP, in addition the ones conﬁrmed by the IdP.

BrowserID [7] (formerly known as Firefox Accounts
[10] and Mozilla Persona [19]), the IdP issues a special
token (called user certiﬁcate) to bind a user identity
to an ephemeral public key. With the corresponding
private key, the user signs a “subsidiary” token (called
identity assertion) to bind the target RP’s identity and
sends both tokens to the RP. The PRIMA IdP signs a
credential binding a veriﬁcation key and a set of user
attributes [11], where the key is considered the user
identity. The user selectively provides IdP-conﬁrmed
attributes to an RP using his signing key [20]. In
SPRESSO [8], an RP creates a veriﬁable one-time
pseudo-identity for itself in each login instance, which
is enclosed in the identity token generated by the IdP.
In these schemes [7], [8], [11], collusive RPs could
link a user based on his unique identity in the tokens
(or credentials).

PseudoID [12] introduces an independent

token
service in addition to the IdP to blindly sign an access
token binding a pseudonym and a user secret. The user
unblinds this token and the IdP will assert it, which
allows the user to login to an RP using his secret.
Two kinds of privacy threats are prevented, because (a)
the RP’s identity is not enclosed in the access token
and (b) the user encloses different pseudonyms when
visiting RPs. Collusive attacks by the IdP and RPs are
also prevented, for they cannot link two blindly-signed
tokens.

In EL PASSO [13], after authenticating a user,

the IdP signs an anonymous credential [21] binding
a secret, both of which are kept on the user’s device.
When attempting to login to an RP, the user proves that
he is the owner of this credential without exposing the
secret, and discloses selective attributes in the creden-
tial. Although one credential is proved to multiple RPs,
user-maintained pseudonyms and anonymous creden-
tials prevent the RPs, even when collusive with the
IdP, from linking the users across the RPs. UnlimitID
[14] presents similar designs based on anonymous
credentials [21], to prevent collusive attacks by the
IdP and RPs. NEXTLEAP [22] adopts UnlimitID for
anonymous secure messaging.

Anonymous credentials [21], [23] are utilized in
ﬂexible ways. Opaak [15] keeps IdP-signed anonymous
credentials in mobile phones as pseudonym tokens,
which bind a user’s secret key. The Idemix anony-
mous credential system [18] is integrated in Hyper-
ledger Fabric [16] to implement completely-unlinkable
pseudonyms and IdP-conﬁrmed selective attribute dis-
closure. After a user retrieves a U-Prove token [17],
[24] from the IdP, it enables the user to authenticate
himself and selectively disclose attributes to an RP.

2.3.Other Related Works

Anonymous SSO. Anonymous SSO schemes allow
authenticated users to access a service protected by

4

the IdP, without revealing their identities. Anonymous
SSO was proposed for the global system for mobile
(GSM) communications [25], and formalized [26].
Privacy-preserving primitives, such as group signature,
zero-knowledge proof, Chebyshev Chaotic Maps and
proxy re-veriﬁcation, were adopted to design anony-
mous SSO [26]–[29]. Anonymous SSO schemes work
for some applications, but are unapplicable to most
systems that require user identiﬁcation for customized
services.

Privacy-preserving tokens/credentials. In addition to
login, tokens (or credentials) authorize a user to con-
duct operations in privacy-preserving ways. ZKlaims
[30] allow users to prove statements on the credentials
issued by a trusted party using zero-knowledge proofs,
but the credential contents are not revealed. Privacy-
Pass [31] allows a user to receive a great amount of
anonymous tokens. These tokens are used to access
resources on content delivery networks, so the user
does not interact with challenges such as CAPTCHAs.
Crypto-Book [32] coordinates key servers to generate
a ring-signature private key, and a user picks up his
private key through a list of Email addresses (i.e.,
an anonymity set). Then, the key pair works as an
untraceable pseudonym to sign messages. Two-party
threshold-cryptography schemes are implemented with
a central server, to improve the security of user private
keys [33], [34]: to sign or decrypt a message, the user
needs a token from the server. Tandem [35] decouples
the obtaining and using of such tokens, to preserve the
privacy of key usage.

SSO protocol analysis. Fett et al. [36], [37] formally
analyzed OAuth 2.0 and OIDC using an expressive
Dolev-Yao style model [38], and presented the attacks
of 307 redirection and IdP mix-up. SAML-based SSO
is also analyzed [39], and the RP identity is found not
to be correctly bound in the identity tokens of a variant
designed by Google.

Implementation vulnerabilities of SSO protocols.
Vulnerabilities were found in SSO implementations for
web applications, resulting in attacks of impersonation
and identity injection by breaking conﬁdentiality [40]–
[44], integrity [40], [44]–[48] or RP designation [44],
[46]–[49] of identity tokens. Integrity of identity tokens
was not ensured in SSO systems [40], [45]–[48] due to
software ﬂaws such as XML signature wrapping [45],
incomplete veriﬁcation by RPs [40], [46], [48], and IdP
spooﬁng [47], [48]. RP designation is broken due to
incorrect binding at the IdP [46], [49] and insufﬁcient
veriﬁcation by RPs [47]–[49].

Automatic tools such as SSOScan [50], OAuthT-
ester [51] and S3KVetter [49], detect the violations
of conﬁdentiality, integrity, or RP designation of SSO
identity tokens. Wang et al. [52] detect the vulnera-
ble applications built with authentication/authorization
SDKs, due to the implicit assumptions of these SDKs.
Navas et al. [53] discussed the possible attack patterns
of the speciﬁcation and implementations of OIDC.

In mobile systems,

the IdP App, IdP-provided
SDKs or browsers are responsible for forwarding iden-
tity tokens, but none of them ensures the identity to-
kens are sent to the designated RP only [54], [55]. The
SSO protocols are modiﬁed for mobile Apps, but the
modiﬁcations are not well understood by developers
[54], [56]. Vulnerabilities were disclosed in Android
Apps, to break conﬁdentiality [54]–[57], integrity [54],
[56], and RP designation [54], [57] of identity tokens.
A ﬂaw was found in Google Apps [42], allowing a
malicious RP to hijack a user’s authentication attempt
and inject a payload to steal the cookie (or identity
token) for another RP.

If a user is compromised, the attackers will control
his accounts at all RPs. Single sign-off [58] helps the
victim to revoke all his tokens accepted and logout
from the RPs.

3. The Identity-Transformation Frame-

work

This section investigates the security requirements
of privacy-preserving SSO, and explains the identity
dilemma. Then, we present the identity-transformation
framework.

3.1.Security Requirements of SSO

The primary goal of non-anonymous SSO services
is to ensure that a legitimate user is able to login to
an honest RP as his permanent identity at this RP, by
presenting the identity tokens issued by the honest IdP.

To achieve this goal, an identity token generated by
the IdP speciﬁes (a) the RP to which the user requests
to login (i.e., RP designation) and (b) the user who
is authenticated by the IdP (i.e., user identiﬁcation).
Therefore, an honest RP compares the designated RP
identity (or pseudo-identity) in identity tokens with
its own before accepting the tokens; otherwise, a
malicious RP could replay a received identity token
to the honest RP and login as the victim user. The RP

5

Table 2: The (pseudo-)identities in privacy-preserving
SSO.

Notation Description
IDU
IDRPj
P IDi

U,j

The user’s unique identity at the IdP.
The j-th RP’s unique identity at the IdP.
The user’s pseudo-identity, in the user’s i-th
login instance to the j-th RP.
The j-th RP’s pseudo-identity, in the user’s
i-th login instance to this RP.
The user’s identity (or account) at the j-th
RP.

P IDi

RPj

Acctj

Lifecycle
Permanent
Permanent
Ephemeral

Ephemeral

Permanent

Figure
preserving SSO.

2:

Identity

transformations

in

privacy-

allows the token holder to login as the user (pseudo-
)identity speciﬁed in the accepted tokens.

The SSO login ﬂow implies conﬁdentiality and
integrity of identity tokens. An identity token shall
be forwarded by the authenticated user to the target
RP only, not leaked to any other parties; otherwise, an
adversary who presents the token, would successfully
login to this honest RP. Integrity is also necessary to
prevent adversaries from tampering with an identity
token. So identity tokens are signed by the IdP and
usually transmitted over HTTPS [1]–[3].

These four security requirements (i.e., RP designa-
tion, user identiﬁcation, conﬁdentiality, and integrity)
of SSO identity tokens have been discussed [36],
[37], [39], and vulnerabilities breaking any of these
properties result in effective attacks [40]–[51], [54]–
[57], [59], [60].

3.2.The Identity Dilemma of Privacy-Preserving

SSO

We aim to design a privacy-preserving SSO system
with the four security properties as above, while pre-
venting the privacy threats due to the IdP-based login
tracing and the RP-based identity linkage. However, to
satisfy the requirements of security and privacy at the
same time, poses a dilemma in the generation of iden-
tity tokens. Table 2 lists the notations in the following
explanation, and the subscript j and/or the superscript
i may be omitted, when there is no ambiguity.

An identity token contains the (pseudo-)identities
of the authenticated user and the target RP. Since the
IdP authenticates users and always knows the user’s
identity (i.e., IDU ), to prevent the IdP-based login
tracing, we shall not reveal the target RP’s permanent
identity (i.e., IDRP ) to the IdP. So an ephemeral
pseudo-identity for the RP (i.e., P IDRP ) shall be

6

used in the identity-token request: (a) to ensure RP
designation, P IDRP shall be uniquely associated with
the target RP; and (b) the IdP cannot derive any
information about IDRP from any P IDi
RP , which
implies P IDi
RP in multiple login instances shall be
independent of each other.1

To prevent the RP-based identity linkage, the IdP
shall not enclose IDU in identity tokens. A user
pseudo-identity (i.e., P IDU ) shall be bound instead:
(a) the RP cannot derive any information about IDU
from any P IDU,j, which implies P IDU,j for different
RPs shall be independent of each other; (b) in multiple
login instances to the RP, P IDi
U shall be independent
of each other and generated ephemerally, to prevent the
IdP-based login tracing;2 and (c) to ensure user iden-
tiﬁcation, an ephemeral P IDi
U in each login instance
shall enable the RP to correlate it with the permanent
account (i.e., Acct) at this RP.

Give a user, (a) any identity token contains only
pseudo-identities, i.e., P IDi
, which
are independent of each other for different RPs and
in multiple login instances, respectively, and (b) these
two ephemeral pseudo-identities enable the target RP
to derive a permanent account, i.e., Acctj.

U,j and P IDi

RPj

The relationships among the (pseudo-)identities in
identity tokens is illustrated in Figure 2. The red
and green blocks represent permanent identities and
ephemeral pseudo-identities, respectively. The arrows
denote the transformations of (pseudo-)identities. It
describes the identity dilemma of privacy-preserving
SSO as below:

Given an authenticated user and an unknown RP
(i.e., permanent IDU and ephemeral P IDRP ), the
IdP is expected to generate an ephemeral pseudo-
identity (i.e., P IDU ) which will be correlated with the

1. While the target RP is kept unknown to the IdP, the IdP shall

not link multiple login instances to visit this RP.

2. If P IDi

it
implies the IdP could link multiple login instances to visit this RP.

U is not completely independent of each other,

IdPIdentity TokenRPUserIDUPIDRPPIDUPIDRPPIDUFPIDUIDRPPIDUAcctFAcctPIDRPIDRPFPIDRPx=?=xEphemeralPermanentIDUFPIDRPuser’s permanent identity at this RP (i.e., Acct), while
knowing nothing about the RP’s identity or the user’s
account at this RP (i.e., IDRP or Acct).

RPs behave arbitrarily and might collude with each
other, attempting to break the security and privacy
guarantees for benign users.

We explicitly distinguishes a user’s identity at the
RP, i.e., the account, from (a) the user’s identity at
the IdP and (b) the user’s pseudo-identity in identity
tokens.

3.3.Identity Transformation

The privacy protection of SSO is converted into a
challenge to design identity-transformation functions
as below.
•

•

•

FP IDRP (IDRP ) = P IDRP , calculated by
the user and the RP. From the IdP’s view,
FP IDRP () is a one-way function and the cal-
culated P IDRP appears a random variable.
FP IDU (IDU , P IDRP ) = P IDU , calculated
by the IdP. From the RP’s view, FP IDU () is
a one-way function and the calculated P IDU
appears a random variable.
FAcct(P IDU , P IDRP ) = Acct,
calcu-
lated by the RP. Given IDU and IDRP ,
Acct keeps permanent and unique to other
in the user’s
accounts at
this RP;
any i-th and i(cid:48)-th (i
login in-
stances to the RP, FAcct(P IDi
RP ) =
U , P IDi(cid:48)
FAcct(P IDi(cid:48)

U , P IDi

(cid:54)= i(cid:48))

RP ).

i.e.,

In an SSO login ﬂow with identity transforma-
tions, a user ﬁrstly negotiates an ephemeral P IDRP
with the target RP. Then, an identity-token request
with P IDRP is sent by the user to the IdP. After
authenticating the user as IDU , the IdP calculates an
ephemeral P IDU based on IDU and P IDRP , and
issues an identity token binding P IDU and P IDRP .
After verifying the designated RP pseudo-identity in
the token, the RP calculates Acct and allows the token
holder to login as Acct.

4. The Designs of UPPRESSO

This section presents the threat model and as-
sumptions. We then introduce identity-transformation
functions satisfying the requirements and the detailed
UPPRESSO protocols.

4.1.Threat Model

The IdP is curious-but-honest, while some users
and RPs could be compromised. Malicious users and

7

Curious-but-honest IdP. The IdP strictly follows the
protocol, while being interested in learning user pri-
vacy. For example, it might store all received messages
to infer the relationship among IDU , IDRP , P IDU ,
and P IDRP to track a user’s login activities. The
IdP is trusted to maintain the private key for signing
identity tokens and RP certiﬁcates. So, adversaries
cannot forge such tokens or certiﬁcates.

We do not consider the collusion of the IdP and
RPs. If the IdP could collude with some RPs, a user
would ﬁnish login instances completely with collusive
entities and it is rather difﬁcult to prevent the IdP-
based login tracing across these RPs while keeping
all the features of SSO. Note that we aim to design
schemes for a user without any non-ephemeral secret
or credential veriﬁed by the RPs.

Malicious Users. We assume the adversary could
control a set of users, by stealing users’ credentials
or registering Sybil users in the system. They want
to impersonate a victim user at honest RPs, or allure
the benign user to login to an honest RP under the
adversary’s account. A malicious user might modify,
insert, drop or replay a message, or behave arbitrarily
in any SSO login instances.

Malicious RPs. The adversary could control a set of
RPs, by registering at the IdP as an RP or exploit-
ing software vulnerabilities to compromise some RPs.
The malicious RPs might behave arbitrarily to break
the security and privacy guarantees. For example, a
malicious RP might manipulate P IDRP in a login
instance, attempting to allure honest users to return an
identity token that might be accepted by some honest
RP, or, attempting to affect the generation of P IDU
and analyze the relationship between IDU and P IDU .

Collusive Users and RPs. Malicious users and RPs
might collude with each other. For example, a mali-
cious RP might collude with malicious users to allure
victim users to forward an identity token to him, to
impersonate the victim and login to some honest RP.

4.2.Assumptions

A user never authorizes the IdP to enclose any
distinctive attributes in identity tokens, which are iden-
tiﬁable information such as telephone number, Email
address, etc. A user does not conﬁgure distinctive

Table 3: The notations in the UPPRESSO protocols.

calculates P IDRP .

Notation Description
E
G, n

IDU

IDRPj
t

P IDi

RPj

P IDi

U,j

Acctj

An elliptic curve over a ﬁnite ﬁeld Fq.
A base point (or generator) of E, where the order of G is
a prime number n.
IDU = u, 1 < u < n; the user’s unique identity at the
IdP.
IDRP = [r]G, 1 < r < n; the j-th RP’s unique identity.
The user-generated random integer in a login instance,
1 < t < n.
P IDRP = [t]IDRP = [tr]G; the j-th RP’s pseudo-
identity, in the user’s i-th login instance to this RP.
P IDU = [IDU ]P IDRP = [utr]G; the user’s pseudo-
identity, in the user’s i-th login instance to the j-th RP.
Acct = [t−1 mod n]P IDU = [IDU ]IDRP = [ur]G;
the user’s account at the j-th RP.
The IdP’s key pair, a private key and a public key, to sign
and verify identity tokens and RP certiﬁcates.

SK,
P K
EnptRPj The j-th RP’s endpoint, to receive the identity tokens.
CertRPj A signed RP certiﬁcate, binding IDRPj and EnptRPj .

attributes at any RP, either. Thus, the privacy leakage
due to user re-identiﬁcation by distinctive attributes, is
out of the scope of our work.

HTTPS is adopted to secure the communications
between honest entities, and the adopted cryptographic
primitives are secure. The software stack of a honest
entity is correctly implemented, to transmits messages
to the receivers as expected.

We focus on the privacy threats introduced by the
design of SSO protocols, but not network attacks such
as the trafﬁc analysis that trace a user’s activities from
network packets. Such attacks shall be prevented by
other defenses.

4.3.Identity-Transformation Functions

We

design

identity-transformation

functions,
FP IDRP , FP IDU and FAcct, on an elliptic curve E.
Table 3 lists the notations, and the subscript j and/or
the superscript i may be omitted in the case of no
ambiguity.

For each user, a unique integer u is assigned by the
IdP and IDU = u. When an RP is registering, the IdP
generates a random number r, and IDRP = [r]G, a
unique point on E, is assigned to the RP. Here, u, r ∈
[1, n), r is unknown to the RP, and [r]G is the addition
of G on the curve r times.

IDRP -P IDRP Transformation. The user selects a
random number t (1 < t < n) as the trapdoor and

8

P IDRP = FP IDRP (IDRP ) = [t]IDRP = [tr]G

(1)

IDU -P IDU Transformation. On receiving an
identity-token request with IDU and P IDRP , the IdP
calculates P IDU .

P IDU = FP IDU (IDU , P IDRP )
= [IDU ]P IDRP = [utr]G

(2)

P IDU -Acct Transformation. The trapdoor t is sent
to the target RP, which calculates P IDRP to match the
RP pseudo-identity in identity tokens. On verifying a
token binding P IDU and P IDRP , it calculates Acct
as below.

Acct = FAcct(P IDU , P IDRP )
= [t−1 mod n]P IDU

(3)

From Equations 1, 2 and 3, it is derived that
Acct = [t−1utr mod n]G = [ur]G = [IDU ]IDRP

The RP derives an identical permanent account from
the identity tokens in different login instances, with the
help of t. Given a user, the accounts at different RPs
are inherently unique; while, given an RP, the accounts
of different users are also unique. Moreover, due to the
elliptic curve discrete logarithm problem (ECDLP), it
is impossible for the RP to derive IDU from either
P IDU or Acct, and for the IdP to derive IDRP from
P IDRP . Section 5 presents the detailed proofs.

Note that r is kept unknown to RPs; otherwise,
two collusive RPs with IDRPj = [r]G and IDRPj(cid:48) =
[r(cid:48)]G could check whether [r(cid:48)]Acctj = [r]Acctj(cid:48) or
not, to link a user’s accounts.

4.4.The Designs Speciﬁc for Web Applications

The designs speciﬁc for web applications, enable
UPPRESSO to work with commercial-off-the-shelf
(COTS) browsers. First of all, in UPPRESSO the IdP
is not aware of the visited RP, so the user agents
(or browsers) have to deal with the forwarding of
identity tokens to the target RP, as well as the cal-
culation of P IDRP . On the contrary, in commonly-
used SSO protocols the IdP needs this information to
ensure conﬁdentiality of identity tokens. In the OIDC
services, when an RP registers itself at the IdP, the
redirect_uri parameter is set as the endpoint

URL to receive tokens [1]. Then, when the IdP wants
to transmit identity tokens to an RP, it utilizes HTTP
302 redirection with this endpoint as the target URL
in the HTTP response, so the user browser forwards it
to the RP.

In UPPRESSO such user-agent functions are im-
plemented by web scripts within browsers. Two scripts
downloaded from the visited RP and the IdP, respec-
tively, and each is responsible for the communications
is
with the origin web server. Only the RP script
not enough to implement a user agent; otherwise, the
script will leak its origin to the IdP web server (e.g.,
an identity-token request sent by the RP script will
automatically carry an HTTP referer header that
discloses the RP domain). Moreover, a script from the
honest IdP ensures conﬁdentiality of identity tokens
(i.e., it is sent to only the designated RP) and interacts
with the user for the authorization of user attributes,
for the RP might be malicious. On receiving a request,
the IdP checks that it is from the IdP script.

The RP script prepares IDRP and EnptRP for the
IdP script, through RP certiﬁcates. An RP certiﬁcate is
signed by the IdP during the RP registration, binding
the RP’s identity and its endpoint. In a login instance
the RP will provide its certiﬁcate through the RP
script, to the IdP script. The IdP script veriﬁes the RP
certiﬁcate to extract IDRP and EnptRP . The IdP’s
public key is set in the IdP script, so a user does not
conﬁgure anything locally, as it does in popular SSO
systems.

After using the extracted IDRP to calculate
P IDRP and receiving an identity token from the
IdP, the IdP script needs to ensure the RP script will
forward this token to EnptRP which is bound with
IDRP in the RP certiﬁcate. The scripts communi-
cate with each other within the browser through the
postMessage HTML5 API, and the receiver (i.e.,
the RP script) is restricted by the postMessage
targetOrigin mechanism [61]. When the IdP script
sends identity tokens, the receiver’s origin is set as
a parameter, e.g., window.opener.postMessage
(tkn, ’https://RP.com’), so only a script
from this targetOrigin is a legal receiver. The parameter
consists of the protocol (i.e., https://), the domain
(i.e., RP.com) and a port which may be implicit.

Finally, the browser downloads the RP script when
visiting an RP, and this RP script opens a new window
that downloads the IdP script. We shall prevent the
referer leakage when the IdP script is downloaded.
Generally, when a browser window visits another
the
website not belonging to its opener’s origin,

HTTP request
to this website automatically carries
the referer header (i.e., the opener’s origin). This
HTTP header leaks the visited RP’s domain to the
IdP. Fortunately,
in UPPRESSO this newly-opened
window is a redirection from the RP to the IdP, but
not a direct visit by the browser (Figure 3, Steps 1.2-
1.3). This leakage is prevented by setting the header
referrer-policy=no-referrer in the HTTP
response from the RP, when it is redirected to the IdP.
Then the HTTP request to download the IdP script
carries no referer header. This setting is speciﬁed
by W3C [62] and widely supported. We tested it in
browsers including Chrome, Safari, Edge, Opera and
Firefox, and conﬁrmed no referer leakage.

4.5.The UPPRESSO Protocols

System Initialization. The IdP generates a key pair
(SK, P K) to sign/verify identity tokens and RP cer-
tiﬁcates. The IdP keeps SK secret, and P K is publicly
known.

RP Initial Registration. Each RP registers itself at the
IdP to obtain IDRP and its RP certiﬁcate CertRP as
follows:

1) An RP sends a registration request,

including
the endpoint to receive identity tokens and other
information.

2) The IdP randomly generates r ∈ [1, n), until
IDRP = [r]G is unique. It signs CertRP =
[IDRP , EnptRP , ∗]SK, where [·]SK is a message
signed using SK and ∗ is supplementary informa-
tion such as the RP’s common name.

3) The RP veriﬁes CertRP using P K, and accepts

IDRP and CertRP if they are valid.

User Registration. Each user registers once at the IdP
to set up a unique identity IDU and the corresponding
credential.

SSO Login. A login instance consists of four steps,
namely script downloading, RP identity transforma-
tion, identity-token generation, and Acct calculation,
as shown in Figure 3. In this ﬁgure, the operations by
the IdP are linked by a vertical line, so are the RP’s.
Two vertical lines split the user operations into two
groups (i.e., in two browser windows), one of which
is to communicate with the IdP, and the other with
the target RP. Each solid horizontal line means some
messages between the user and the IdP (or the RP), and
each dotted line means a postMessage invocation

9

Figure 3: The SSO login ﬂow of UPPRESSO.

between two scripts (or browser windows) within the
user browser.

1. Script Downloading. The browser downloads the
scripts from the visited RP and the IdP.

1.1 When attempting to visit any protected re-
sources at the RP, the user downloads the RP
script.

1.2

1.3

The RP script opens a window in the browser
to visit the login path at the RP, which is then
redirected to the IdP.

The redirection to the IdP downloads the IdP
script.

2. RP Identity Transformation. The user and the RP
negotiate P IDRP = [t]IDRP .

2.1

2.2

2.3

The IdP script chooses a random number t
in Zn and sends it to the RP script through
postMessage. The RP script sends t to the
RP.

On receiving t, the RP veriﬁes 1 < t < n
and calculates P IDRP . The RP replies with
CertRP , which is then transmitted from the
RP script to the IdP script, as well as the scope
of requested user attributes.

The IdP script veriﬁes CertRP , extracts
IDRP and EnptRP from CertRP and cal-
culates P IDRP = [t]IDRP .

Identity-Token Generation. The IdP calculates
3.
P IDU = [IDU ]P IDRP and signs the identity token.

3.1

The IdP script requests an identity token for

10

IdPUserRP1.2 /login2.2 Calculate PIDRP2.2 CertRP, AttrScope2.3 Verify CertRP, extract IDRP and EnptRP, calculate PIDRP1.3 /script1.2 Redirection2.1 To opener window: t2.1 /startNegotiation(t)2.2 To IdP-script window:CertRP3.3 Check PIDRP, calculate PIDU, sign [PIDRP, PIDU, Issuer, Validity, Attr]SK4.1 /uploadToken(ID Token)4.2 Verify ID Token, extract PIDU, calculate Acct4.3 Login Result1.1 /script2.1 Randomly choose t1.1 RP script1.3 IdP script3.2 Authentication [optional]RP ScriptIdP Script3.2

3.3

P IDRP and the user attributes.

The IdP authenticates the user if he has not
been authenticated yet.

the

the

the

obtaining

user’s
requested

checks whether
valid,
is

authorization
After
attributes,
enclose
to
received
the
IdP
P IDRP
calculates
P IDU = [IDU ]P IDRP for the authenticated
user. The IdP then signs an identity token
[P IDRP , P IDU , Issuer, V alidity, Attr]SK,
where Issuer is the IdP’s identity, V alidity
and Attr
indicates
the validity period,
contains the requested attributes.

and

3.4

The IdP replies with the identity token.

4. Acct Calculation. The RP receives the identity token
and allows the user to login.

4.1

4.2

4.3

The IdP script forwards the identity token to
the RP script, which then sends it to the RP
through EnptRP .

The RP veriﬁes the identity token, including
the IdP’s signature and its validity period. It
also veriﬁes P IDRP in the token matches
the one negotiated in Step 2.2. Then,
the
RP extracts P IDU and calculates Acct =
[t−1]P IDU .
The RP allows the user to login as Acct.

If any veriﬁcation or check fails, this ﬂow will be
halted immediately. For example, the user halts the
ﬂow on an invalid CertRP . The IdP rejects a request,
if the received P IDRP is not on the elliptic curve E.
Or, the RP rejects an identity token when P IDRP in
it does not match the negotiated one.

4.6.Compatibility with OIDC

Among the four steps of the login ﬂow in UP-
PRESSO, the script downloading prepares the user
agent before other steps. The user agent of SSO is
responsible for the communications between the IdP
and the RP, which are implemented by browser redi-
rections in OIDC. On the other hand, in UPPRESSO
the scripts hide EnptRP from the IdP, and forward
the identity token to EnptRP extracted from the RP
certiﬁcate. So the IdP does not set redirect_uri
in the HTTP response.

Most operations of RP identity transformation are
conducted within browsers, while the RP only receives

t to calculate P IDRP and responds with CertRP .
The calculation of P IDRP is viewed as an operation
to prepare the RP identity in OIDC, and the static
CertRP is a supplementary message to users.

The operations of identity-token generation and
Acct calculation, are actually identical
to those of
OIDC, because (a) the calculation of P IDU is viewed
as a method to generate PPIDs and (b) the calculation
of Acct is viewed as a mapping from the user identity
in tokens to a local account at the RP.

Finally, this compatibility is experimentally con-
ﬁrmed by our prototype implementation: only 20 lines
of Java code in MITREid Connect [63], an open-
source OIDC system, are modiﬁed to build the IdP
of UPPRESSO (see Section 6.1).

5. The Analysis of Security and Privacy

5.1.Security

UPPRESSO satisﬁes the security requirements of
identity tokens in SSO services, as discussed in Section
3.1.

•

•

•

•

RP Designation The RP (pseudo-)identity
bound in the identity token identiﬁes the target
RP, and only this RP.

Identiﬁcation The

User
(pseudo-
)identity bound in the identity token identiﬁes
the authenticated user, and only this user.

user

Conﬁdentiality An identity token is acces-
sible to only the authenticated user and the
target RP, in addition to the IdP.

Integrity An honest RP accepts only identity
tokens binding its (pseudo-)identity and the
authenticated user’s (pseudo-)identity.

RP Designation. The identity token binds P IDRP
identifying the target RP, because t is sent to the target
RP with IDRP and P IDRP = [t]IDRP .

Next, based on the ECDLP we prove that, for an
adversary, the probability of ﬁnding t and t(cid:48) satisfying
[t]IDRPj = [t(cid:48)]IDRPj(cid:48) is negligible, where RPj and
RPj(cid:48) are any two RPs in the ﬁnite set of RPs (i.e.,
IDRPj = [rj]G and IDRPj(cid:48) = [rj(cid:48)]G, while rj
and rj(cid:48) are kept secret to adversaries). The negligible
probability means the token designates only the target
RP.

11

Figure 4: The algorithm based on the P IDRP colli-
sion, to solve the ECDLP.

Let E be an elliptic curve, G be a point on E of
order n, and Q = [x]G where x is a random integer in
Zn. Given G and Q, the probability that a probabilistic
polynomial time (PPT) algorithm calculates x (i.e.,
solve the ECDLP) is negligible. For any PPT algorithm
D, we deﬁne

Pr{D(G, [x]G) = x} = (cid:15)c(k)

Here, Pr{} denotes the probability. So (cid:15)c(k) becomes
negligible with the increasing security parameter k.

Assume a game Gc between an adversary and a
challenger, to describe this P IDRP collision attack:
the adversary receives a ﬁnite set of RP identities
from the challenger, denoted as (IDRP1, IDRP2, ...,
IDRPm ) where m is the amount of RPs in the system,
and then outputs (a, b, t, t(cid:48)). If [t]IDRPa = [t(cid:48)]IDRPb ,
the adversary succeeds in this game. Note that m is a
ﬁnite integer, and m (cid:28) 2k as k increases. We deﬁne
the probability that the adversary succeeds in this game
as Prs.

Then, Figure 4 shows a PPT algorithm D∗

c based
on this game, to solve the ECDLP. The input of D∗
c
is in the form of (G, Q). On receiving an input, the
challenger of Gc randomly chooses r1, r2, · · · , rm in
Zn, calculates [r1]G, [r2]G, · · · , [rm]G, and randomly
replaces some [rj]G with Q. Then,
these m RP
identities are sent to the adversary, which returns the
result (a, b, t, t(cid:48)). Finally, the challenger calculates
s = t−1t(cid:48)rb mod n and returns s as the output of D∗
c .

If [ra]G happens to be replaced with Q and the
adversary succeeds, we ﬁnd Q = [s]G and then
s = x because [tra]G = [t]Q = [t(cid:48)rb]G. As [rj]G
is randomly replaced by the challenger, Q and other
RP identities in the input set are indistinguishable to
the adversary. Thus,

Pr{D∗

c (G, [x]G) = x} = Pr{s = x}

=Pr{a = j}Prs =

1
m

Prs

If the adversary is able to ﬁnd t and t(cid:48) satisfying that
[t]IDRPj = [t(cid:48)]IDRPj(cid:48) , it will have non-negligible
advantages in Gc and Prs becomes non-negligible as
k increases. Because m (cid:28) 2k, Pr{D∗
c (G, [x]G) =
x} = 1
m Prs also becomes non-negligible with the
increasing k. This deﬁnitely violates the ECDLP. Thus,
the probability of ﬁnding t and t(cid:48) satisfying that
[t]IDRPj = [t(cid:48)]IDRPj(cid:48)
in UPPRESSO is negligible,
and then the adversary cannot break RP designation.

User Identiﬁcation. Given a user, an honest RP
with IDRP always deterministically derives an iden-
tical account from different identity tokens binding
P IDU and P IDRP . That
in the user’s any i-
(cid:54)= i(cid:48)) login instances to the RP,
th and i(cid:48)-th (i
FAcct(P IDi
RP ) =
[IDU ]IDRP .

RP ) = FAcct(P IDi(cid:48)

U , P IDi(cid:48)

U , P IDi

is,

In the calculation of Acct = [t−1]P IDU =
[t−1][u]P IDRP , P IDU is calculated by the honest IdP
based on (a) the authenticated user, i.e., IDU = u, and
(b) the received P IDRP , while this P IDRP is gener-
ated by the target RP based on IDRP and t. Thus, the
calculated account is always exactly the authenticated
user’s account at the RP (i.e., [IDU ]IDRP ).

Conﬁdentiality. No event leaks an identity token to
any malicious entity other than the authenticated user
and the designated RP. First of all, the communica-
tions among the IdP, RPs and users, are protected by
HTTPS, and the postMessage HTML5 API ensures
the dedicated channels between two scripts within the
browser, so adversaries cannot eavesdrop the identity
tokens. Further, the IdP sends the identity token only
to the authenticated user (i.e., the IdP script). The
IdP script forwards the token to the RP script only
if it is downloaded from the same origin as EnptRP ,
and the binding of EnptRP and IDRP is ensured by
the signed RP certiﬁcate. So only the RP that holds
EnptRP and IDRP , receives this token.

Integrity. The identity token binds Acct and IDRP
implicitly, and any breaking results in some failed
check or veriﬁcation in the login ﬂow. The identity
token binding P IDU and P IDRP is signed by the
IdP. According to the proof of RP designation, there
is no t(cid:48) (cid:54)= t but satisfying that P IDRP = [t]IDRPj =
[t(cid:48)]IDRPj(cid:48) . That is, the identity token explicitly bind-
ing P IDU and P IDRP , matches only one IDRP and
then also only one Acct = [t−1]P IDU . Thus, Acct
and IDRP are actually bound by the IdP’s signatures,
due to the one-to-one mapping between (a) the pair of
Acct and IDRP and (b) the triad of P IDU , P IDRP ,
and t.

12

(IDRP1, IDRP2, ..., IDRPm)G, QChallengersRandomly choose r1, r2, ..., rm in (1, n)(IDRP, IDRP, ..., IDRP)PIDRP CollisionAdversary(a, b, t, t')s = t-1t'rb mod n([r1]P, [r2]P, ..., Q, ..., [rm]P)Finally, we formally analyze the security properties
of UPPRESSO, based on a Dolev-Yao style model [8].
The model abstracts the entities in a web system, such
as web servers and browsers, as atomic processes. It
also deﬁnes script processes to formulate client-side
scripts, i.e., JavaScript code.

The UPPRESSO system contains atomic processes
as follows: an IdP process, a ﬁnite set of web servers
for honest RPs, a ﬁnite set of honest browsers, and
a ﬁnite set of attacker processes. These processes
communicate with each other through events such as
HTTPS request and response. We consider all RP
and browser processes are honest, while model an
RP or a browser controlled by an adversary as at-
tacker processes. Within an honest browser, honest IdP
scripts, honest RP scripts and also attacker scripts are
invoked. Script processes communicate with each other
through postMessage, modelled as transmitted-to-
itself events of the browser.

After formulating UPPRESSO by the Dolev-Yao
style model, we trace the whole lifecycle of an identity
token, starting when it is generated and ending when
accepted by the RP, to ensure the token is not leaked
to attackers or tampered with by any adversary. We
locate the generation of an identity token, and trace to
all places where P IDU , P IDRP and other parameters
in the token are calculated and transmitted, to ensure
no adversary retrieves or manipulates them.

5.2.Privacy

UPPRESSO effectively prevents the threats of IdP-

based login tracing and RP-based identity linkage.

IdP-based Login Tracing. The information accessible
to the IdP and derived from the RP’s identity, is only
P IDRP , where P IDRP = [t]IDRP is calculated by
the user. Because (a) t is a random number from Zn
and kept secret to the IdP and (b) IDRP = [r]G and
G is the base point (or generator) of E, the IdP has to
view P IDRP as randomly and independently chosen
from E, and cannot distinguish [t]IDRPj = [tr]G from
any [t(cid:48)]IDRPj(cid:48) = [t(cid:48)r(cid:48)]G. So, the IdP cannot infer the
RP’s identity or link any pair of P IDi
RP ,
and the IdP-based login tracing is impossible.

RP and P IDi(cid:48)

RP-based Identity Linkage. We prove UPPRESSO
prevents the RP-based identity linkage, based on the
elliptic curve decision Difﬁe-Hellman (ECDDH) as-
sumption. Let E be an elliptic curve, and G be a
point on E of order n. For any PPT algorithm D, the

probability of distinguishing ([x]G, [y]G, [xy]G) and
([x]G, [y]G, [z]G) is negligible, where x, y and z are
integers randomly and independently chosen from Zn.
Let Pr{} denote the probability and we deﬁne

Pr1 = Pr{D(G, [x]G, [y]G, [xy]G) = 1}
Pr2 = Pr{D(G, [x]G, [y]G, [z]G) = 1}

Then, (cid:15)r(k) = |Pr1 − Pr2| becomes negligible as k
increases.

In every login instance, the RP holds IDRP and
Acct,
receives t, calculates P IDRP , and veriﬁes
P IDRP and P IDU in the identity token. After ﬁl-
tering out the redundant information (i.e., P IDRP =
[t]IDRP and Acct = [t−1]P IDU ), the RP actually
receives (IDRP , t, Acct) = ([r]G, t, [ur]G).




expressed as L =

The prevention against the RP-based identity link-
age is proved by this proposition: when c collu-
sive RPs collect the information of login instances
by v users,
they still cannot determine whether
a login instance to another RP belongs to one
of these v users or not. The login instances are


,

where Li,j = (IDRPj , ti,j, [IDUi]IDRPj ) =
([rj]G, ti,j, [uirj]G). Given a login instance to an-
other RP L(cid:48) = (IDRPc+1, t(cid:48), [IDU (cid:48)]IDRPc+1) =
([rc+1]G, t(cid:48), [u(cid:48)rc+1]G), we deﬁne the RP-based iden-
tity linkage game Gr: after receiving L and L(cid:48) from
a challenger, the adversary outputs the result s = 1
if it determines that u(cid:48) ∈ {u1, u2, · · · , uv}, or s = 0
otherwise.

L1,1, L1,2,
L2,1, L2,2,
· · · ,
· · · ,
Lv,1, Lv,2,

· · · , L1,c
· · · , L2,c
· · · ,
· · ·
· · · , Lv,c



We deﬁne the adversary’s advantage in Gr as

AdvA. Then,

Pr(cid:48)
Pr(cid:48)
AdvA = |Pr(cid:48)

1 = Pr{Gr(L, L(cid:48)|IDU (cid:48) ∈ {IDU1 , IDU2 , · · · , IDUv }) = 1}
2 = Pr{Gr(L, L(cid:48)|IDU (cid:48) ∈ Zn) = 1}
1 − Pr(cid:48)
2|

We design a PPT algorithm D∗

r based on Gr,
shown in Figure 5, to solve the ECDDH problem.
is in the form of (G, Q1 = [x]G,
The input
Q2 = [y]G, Q3 = [z]G). On receiving the input, the
challenger of Gr randomly chooses {u1, u2, · · · , uv},
{r1, r2, · · · , rc}, {t1,1, t1,2, · · · , tv,c}, and t(cid:48)
from
Zn. Then the challenger constructs L and L(cid:48) as
below. It ﬁrst assigns Li,j = ([rj]G, ti,j, [uirj]G),
and randomly chooses d ∈ [1, v] to replace [udrj]G
with [rj]Q1 = [xrj]G for 1 ≤ j ≤ c. So L =

13

systems: (a) MITREid Connect [63] which supports
the PPID-enhanced OIDC protocol to prevent the RP-
based identity linkage, and (b) SPRESSO [8] prevent-
ing only the IdP-based login tracing.

6.1.Prototype Implementation

The identity-transformation functions are deﬁned
on the NIST P256 elliptic curve. RSA-2048 and SHA-
256 are adopted as the signature algorithm and the hash
function, respectively.

The IdP is built on top of MITREid Connect [63],
an open-source OIDC Java implementation, and only
small modiﬁcations are needed. We add only 3 lines of
Java code to calculate P IDU , and 20 lines to modify
the way to send identity tokens. The calculations of
IDRP and P IDU are implemented based on Java
cryptographic libraries.
.
We implemented the user functions by the IdP and
RP scripts, by about 160 and 140 lines of JavaScript
code, respectively. The cryptographic computations,
e.g., CertRP veriﬁcation and P IDRP negotiation, are
ﬁnished based on jsrsasign [64], an efﬁcient JavaScript
cryptographic library.

We provide a Java RP SDK. The SDK provides
two functions to encapsulate the protocol steps: one
to request identity tokens, and the other to derive the
accounts. It is implemented based on the Spring Boot
framework with about 500 lines of Java code and
cryptographic computations are ﬁnished based on the
Spring Security library. An RP invokes these functions
for the integration, by less than 10 lines of Java code.

6.2.Performance Evaluation

MITREid Connect runs following the implicit ﬂow
of OIDC, while the identity tokens in SPRESSO are
forwarded by a user to the RP, similarly to the implicit
ﬂow. In the identity tokens of SPRESSO, P IDRP is
the encrypted RP domain, while the one-time symmet-
ric key only known by the RP and the user. They also
conﬁgure RSA-2048 and SHA-256 in the generation
of identity tokens.

MITREid Connect provides Java implementations
of the IdP and RP SDK, while SPRESSO implements
all entities by JavaScript based on node.js. We imple-
mented the RPs based on Spring Boot for UPPRESSO
and MITREid Connect, by integrating the correspond-
ing SDKs. The RPs in three schemes provide the same

Figure 5: The algorithm based on the RP-based identity
linkage, to solve the ECDDH problem.






L1,1,
L2,1,
· · · ,
([r1]G, td,1, [r1]Q1),
· · · ,
Lv,1,

L1,2,
L2,2,
· · · ,
· · · ,
· · · ,
Lv,2,

· · · ,
· · · ,
· · · ,
· · · ,
· · · ,
· · · ,

L1,c
L2,c
· · ·
([rc]G, td,c, [rc]Q1)
· · ·
Lv,c






it

=

(Q2, t(cid:48), Q3)

constructs L(cid:48)

=
Next,
([y]G, t(cid:48), [z/y][y]G). Finally, L and L(cid:48) are sent
to the adversary, and the output s of Gr is output by
the challenger. According to the above construction
of L and L(cid:48), x is actually inserted into L as ud
and z/y is assigned to u(cid:48). So, if z = xy, z/y = x
and IDU (cid:48) ∈ {IDU1, IDU2, · · · , IDUv }; otherwise,
IDU (cid:48) ∈ Zn. Thus,
Pr1 = Pr{D∗

r (G, [x]G, [y]G, [xy]G) = 1} = Pr(cid:48)
1

=Pr{Gr(L, L(cid:48)|IDU (cid:48) ∈ {IDU1 , IDU2, · · · , IDUv }) = 1}

Pr2 = Pr{D∗

r (G, [x]G, [y]G, [z]G) = 1} = Pr(cid:48)
2

=Pr{Gr(L, L(cid:48)|IDU (cid:48) ∈ Zn) = 1}
1 − Pr(cid:48)

AdvA = |Pr(cid:48)

2| = |Pr1 − Pr2| = (cid:15)r(k)

The ECDDH assumption means that

in Gr the
adversary does not have advantages, i.e., cannot dis-
tinguish a user U (cid:48) chosen from {U1, U2, · · · , Uv} or
randomly from the user set of UPPRESSO. So the RP-
based identity linkage is impossible.

6. Implementation and Evaluation

We implemented the UPPRESSO prototype,3 and
experimentally compared it with two open-source SSO

3. The prototype is open-sourced at https://github.com/uppresso/.

14

IDU'  in {IDU1, ..., IDUv} or notL' = (IDRPc+1, t', [IDU']IDRPc+1)GQ1, Q2, Q3ChallengersRandomly choose{u1, u2, ..., uv}{r1, r2, ..., rc}{t1,1, t1,2, ..., tv,c} and t' from [1, n)Li,j = ([rj]G, ti,j, [uirj]G),for 1 ≤ i ≤ v and 1 ≤ j ≤ c;Randomly choose d,replace [udrj]G with [rj]Q1 for 1 ≤ j ≤ c;Let L' = (Q2, t', Q3)RP-based Identity LinkageAdversarysL1,1, L1,2, ..., L1,cL2,1, L2,2, ..., L2,c...Lv,1, Lv,2, ..., Lv,cwhere Li,j means Ui visits RPjL' = (IDRP, t', [IDU']IDRP)IDU'  in {IDU, ..., IDU} or nottance (Step 4 in Figure 3), as the RP receives, veriﬁes
and parses the identity token.

We measured the time cost and calculated the
average of 1, 000 measurements. The results are shown
in Figure 6. The overall times of an SSO login instance
for MITREid Connect, UPPRESSO, and SPRESSO
are (a) 63 ms, 179 ms, and 190 ms, respectively,
when all entities are deployed as Alibaba Cloud virtual
machines, or (b) 312 ms, 471 ms, and 510 ms, respec-
tively, when the user browser runs locally to remotely
visit the cloud servers.

In the part of identity-token requesting, the RP
of MITREid Connect constructs the identity-token re-
quest immediately. Compared with MITREid Connect,
the main overhead of UPPRESSO is to open a new
browser window and download the scripts.4 The RP
in SPRESSO needs to obtain some information on the
IdP and encrypt its domain using an ephemeral key,
resulting in the additional overhead.

In the identity-token generation, UPPRESSO sim-
ply retrieves a token from the IdP. On the contrary, in
MITREid Connect when a user retrieves the identity
token from the IdP, the token must be carried with
identiﬁer # instead
a URL following the fragment
of ?, due to some security considerations [65]. So
the user needs to ﬁrst download the script from the
RP to process this token, which takes the most time.
SPRESSO takes a little more time to generate an
identity token, as it
implements the IdP based on
node.js and adopts a JavaScript cryptographic library,
while a more efﬁcient Java library is used in the others.

In the identity-token acceptance, MITREid Connect
and UPPRESSO spend the comparable amounts of
time for sending identity token to the RP and verifying
this token. SPRESSO needs the longest time due to the
complicated process at the user browser: after receiving
identity tokens from the IdP, the browser downloads
the JavaScript code from a trusted forwarder, decrypts
the RP endpoint, and ﬁnally sends identity tokens to
this endpoint.

4. This overhead may be mitigated by implementing a user agent
with browser extensions. A user installs the extension before visiting
RPs. We tested such a browser extension while the IdP and RPs are
unmodiﬁed, and experiments show about 90 ms and 260 ms will
be saved in a login instance, in a virtual private cloud and by a
remotely-visiting browser, respectively.

(a) In a virtual private cloud

(b) With a remotely-visiting browser

Figure 6: The time cost of SSO login.

function, i.e., simply extract the user’s account from
veriﬁed identity tokens.

The IdP and RP servers are deployed on Alibaba
Cloud Elastic Compute Service, each of which runs
Window 10 with 8 vCPUs and 32 GB memory. The
forwarder of SPRESSO runs Ubuntu 20.04.4 with 16
vCPUs and 16 GB memory, also on Alibaba Cloud.
We compare the schemes in two scenarios: (a) a
user browser, Chrome 104.0.5112.81, runs on another
virtual machine with 8 vCPUs and 32 GB memory on
Alibaba Cloud, and (b) the browser runs locally on a
PC with Core i7-8700 CPU and 32 GB memory, to
remotely visit the servers. In the cloud scenario, all
entities are deployed in the same virtual private cloud
and connected to one vSwitch, which minimizes the
inﬂuence of network delays. In any scenario, the IdP
never directly communicates with the RP.

We divide a login ﬂow into three parts: Identity-
token requesting (for UPPRESSO, it includes Steps 1-
2 in Figure 3), to construct an identity-token request
transmitted to the IdP; Identity-token generation (Step
3 in Figure 3), for the IdP to generate an identity token,
while the user authentication and the authorization of
user attributes are excluded; and Identity-token accep-

15

050100150200250Identity-tokenrequestingIdentity-tokengenerationIdentity-tokenacceptanceTotalMITREid ConnectUPPRESSOSPRESSOTime (in ms)0100200300400500600Identity-tokenrequestingIdentity-tokengenerationIdentity-tokenacceptanceTotalMITREid ConnectUPPRESSOSPRESSOTime (in ms)7. Discussions

Applicability of Identity Transformations. These
i.e., FP IDRP (),
identity-transformation functions,
FP IDU (), and FAcct(), are applicable to various SSO
scenarios (e.g., web application, mobile App, and
native software), because these functions follow the
common model of SSO protocols and do not depend
on any special implementation or runtime.

Scalability. Adversaries cannot exhaust P IDRP or
IDRP . IDRP is generated uniquely in an RP’s initial
registration, and the capacity is n (i.e., the order of
G). For example, for the NIST P256 elliptic curve,
n is approximately 2256. As for P IDRP , we only
ensure P IDRP is unique in unexpired tokens,
the
number of which is denoted as σ. The probability that
at least two P IDRP s are identical among the σ ones,
is 1 − (cid:81)σ−1
i=0 (1 − i/n). For example, when the IdP
serves 108 requests per second and the validity period
of identity tokens is 10 minutes, σ is less than 236 and
the probability is less than 2−183 for the NIST P256
elliptic curve. This probability is negligible.

The capacity of accounts at any RP is also n.
E is a ﬁnite cyclic group, so IDRP = [r]G is
also a generator of order n. Given an RP, a unique
account is assigned to every user, because Acct =
[IDU ]IDRP = [u]IDRP .

Compatibility with the Authorization Code Flow.
In the authorization code ﬂow of OIDC [1], the IdP
does not directly issue the identity token; instead, an
authorization code is sent to the RP, and then the RP
uses this code to ask for identity tokens. The identity-
transformation functions FP IDU , FP IDRP and FAcct
can be integrated into the authorization code ﬂow: an
authorization code is forwarded to the RP script by the
IdP script and this code is used to ask for an identity
token binding P IDU and P IDRP . An authorization
code is usually the index to retrieve the identity token
from the IdP, and does not disclose any information on
the authenticated user.

After receiving the authorization code, the RP uses
it and another secret credential which is issued by
the IdP during the initial registration, to retrieve the
identity token from the IdP [1]. In order to protect RP
identities from the IdP, privacy-preserving credentials
(e.g., ring or group signatures [66], [67]) and anony-
mous networks (e.g., Tor [68]) need to be adopted for
RPs in the retrieval of identity tokens.

Collusive Attack by the IdP and RPs. When the IdP
is still kept curious-but-honest but shares messages in

the login ﬂow (i.e., IDU , P IDRP , and P IDU ) with
some collusive RPs, UPPRESSO still provides secure
SSO services, provided that the signed identity tokens
are sent to the authenticated users only; however, the
collusive adversaries are able to trace the users’ login
activities to these RPs. Anyway, even in this case, a
user’s login activities at the other RPs not collusive
with the IdP, are still protected from the IdP and these
collusive RPs, because a triad of t, P IDU and P IDRP
is ephemeral and independent of each other.

Restriction of the RP Script’s Origin. When identity
tokens are forwarded by the IdP script to the RP script,
the receiver is restricted by the postMessage targe-
tOrigin mechanism [61], to ensure it will forward the
tokens to EnptRP that is bound in the RP certiﬁcate. A
targetOrigin is speciﬁed as a domain (e.g., RP.com)
and the parts of protocol and port (if not presented,
implicitly 80 for http and 443 for https), and it
requires the RP script’s origin accurately matches the
targetOrigin.

If

is

by

not

checked

Although the URL path part of EnptRP ,
e.g., /uploadTkn,
the
only
assumes
targetOrigin mechanism, which
it brings no extra
one RP runs on a domain,
risk.
two RPs run on one domain but with
different endpoints to receive identity tokens (e.g.,
https://RP.com/honest/uploadTkn
and
https://RP.com/malicious/uploadTkn),
they cannot be distinguished by postMessage.
same-
Meanwhile,
of web
origin
could
resources
the
always
browser,
scripts
vwin=window.open(’http://RP.com/honest’)
and vwin.document.cookie, even if the honest
RP restricts that only HTTP requests to speciﬁc paths
carry its cookies.

[69].
access
e.g.,

a
other’s
the

browsers
the
in

(malicious) RP

the
control

So
the
steal

resources

cookies

enforce

access

policy

by

in

Alternative Way to Bind IDRP and EnptRP . In the
prototype, an RP certiﬁcate binds IDRP and EnptRP ,
veriﬁed by the honest IdP script. The RP certiﬁcates
ensure the target RP has already registered itself at the
IdP, which prevents unauthorized RPs from accessing
the IdP’s SSO services.

This binding may be ﬁnished in another way:
IDRP is deterministically calculated based on the RP’s
unambiguous friendly name. Hs() encodes an RP’s do-
main (or the RP script’s origin, https://RP.com/)
to a point on the elliptic curve E as IDRP , where
hashing to elliptic curves Hs() [70] provides collision

16

resistance and does not reveal the discrete logarithm
of the output (i.e., IDRP = [r]G but r is unknown).
Then, in Step 2.2 the RP script will send the endpoint
but not its RP certiﬁcate, to the IdP script, and IDRP is
calculated by the IdP script. However, if the RP updates
its domain, for instance, from https://RP.com/
to https://theRP.com/, Acct = [IDU ]IDRP
will change inevitably. In such cases, it needs special
operations by each user to migrate his account to the
updated RP system. This account migration requires
extra operations explicitly by each user; otherwise,
collusive RPs could actually link a user’s accounts
across RPs.

8. Conclusion

This paper proposes UPPRESSO, an untraceable
and unlinkable privacy-preserving single sign-on sys-
tem, to protect a user’s login activities at different
RPs against both the curious IdP and collusive RPs.
We convert the identity dilemma in privacy-preserving
SSO into an identity-transformation challenge and de-
sign three functions satisfying the requirements, where
(a) FP IDRP protects the RP’s identity from the curious
IdP, (b) FP IDU prevents collusive RPs from linking a
user across these RPs, and (c) FAcct allows the RP to
derive an identical account for a user in his multiple
login instances. These functions can be integrated with
existing SSO protocols, such as OIDC,
to protect
user privacy, without breaking the security guarantees
of SSO services. The experimental evaluation of the
UPPRESSO prototype shows that it provides efﬁcient
SSO services: on average a login instance takes 174
ms (when the IdP, the RP and a user are deployed
together) or 421 ms (when the user visits remotely).

References

[1] N. Sakimura, J. Bradley, M. Jones, B. de Medeiros,
and C. Mortimore, OpenID Connect core 1.0 incor-
porating errata set 1, The OpenID Foundation, 2014.

[2] D. Hardt, RFC 6749: The OAuth 2.0 authorization

framework, Internet Engineering Task Force, 2012.

[3]

J. Hughes, S. Cantor, J. Hodges, F. Hirsch, P. Mishra,
R. Philpott, and E. Maler, Proﬁles for the OASIS
security assertion markup language (SAML) V2.0,
OASIS, 2005.

[5] E. Maler and D. Reed, “The venn of identity: Options
and issues in federated identity management,” IEEE
Security & Privacy, vol. 6, no. 2, pp. 16–23, 2008.

[6] P. Grassi, E. Nadeau, J. Richer, S. Squire, J. Fenton,
N. Lefkovitz, J. Danker, Y.-Y. Choong, K. Greene, and
M. Theofanos, SP 800-63C: Digital identity guide-
lines: Federation and assertions, National Institute of
Standards and Technology (NIST), 2017.

[7] D. Fett, R. K¨usters, and G. Schmitz,

“Analyzing
the BrowserID SSO system with primary identity
providers using an expressive model of the Web,” in
20th European Symposium on Research in Computer
Security (ESORICS), 2015, pp. 43–65.

[8] D. Fett, R. K¨usters, and G. Schmitz, “SPRESSO: A
secure, privacy-respecting single sign-on system for
in 22nd ACM Conference on Computer
the Web,”
and Communications Security (CCS), 2015, pp. 1358–
1369.

[9]

“Google Identity Platform,” https://developers.google.
com/identity/, Accessed August 20, 2019.

[10]

“About Firefox Accounts,” https://mozilla.github.
io/application-services/docs/accounts/welcome.html,
Accessed August 20, 2019.

[11] M. R. Asghar, M. Backes, and M. Simeonovski,
“PRIMA: Privacy-preserving identity and access man-
agement at Internet-scale,” in 52nd IEEE International
Conference on Communications (ICC), 2018.

[12] A. Dey and S. Weis, “PseudoID: Enhancing privacy
for federated login,” in 3rd Hot Topics in Privacy
Enhancing Technologies (HotPETs), 2010.

[13] Z. Zhang, M. Kr´ol, A. Sonnino, L. Zhang, and
E. Rivi`ere,
“EL PASSO: Efﬁcient and lightweight
privacy-preserving single sign on,” Privacy Enhancing
Technologies, vol. 2021, no. 2, pp. 70–87, 2021.

[14] M. Isaakidis, H. Halpin, and G. Danezis, “UnlimitID:
Privacy-preserving federated identity management us-
in 15th ACM Workshop on
ing algebraic MACs,”
Privacy in the Electronic Society (WPES), 2016, pp.
139–142.

[15] G. Maganis, E. Shi, H. Chen, and Dawn Song,
“Opaak: Using mobile phones to limit anonymous
identities online,” in 10th International Conference on
Mobile Systems, Applications, and Services (MobiSys),
2012.

[4] T. Hardjono and S. Cantor,

SAML V2.0 subject
identiﬁer attributes proﬁle version 1.0, OASIS, 2018.

[16] Hyperledger Fabric, MSP implementation with Identity

Mixer, 2022.

17

[17] C. Paquin, U-Prove technology overview v1.1, Mi-

crosoft Corporation, 2013.

[18]

J. Camenisch and E. V. Herreweghen, “Design and
implementation of the Idemix anonymous credential
system,” in 9th ACM Conference on Computer and
Communications Security (CCS), 2002.

[19] Mozilla Developer Network (MDN),

“Persona,”

https://developer.mozilla.org/en-US/docs/Archive/
Mozilla/Persona.

[20] M. Simeonovski, F. Bendun, M. R. Asghar,
M. Backes, N. Marnau, and P. Druschel, “Oblivion:
the
Mitigating
leaks
in 13th
discoverability of online information,”
International Conference on Applied Cryptography
and Network Security (ACNS), 2015.

controlling

privacy

by

[21] M. Chase, S. Meiklejohn, and G. Zaverucha, “Alge-
braic MACs and keyed-veriﬁcation anonymous cre-
in ACM Conference on Computer and
dentials,”
Communications Security (CCS), 2014.

[22] H. Halpin, “NEXTLEAP: Decentralizing identity with
privacy for secure messaging,” in 12th International
Conference on Availability, Reliability and Security
(ARES), 2017.

[23]

J. Camenisch and A. Lysyanskaya,
“An efﬁcient
system for non-transferable anonymous credentials
with optional anonymity revocation,” in Advances in
Cryptology - EUROCRYPT, 2001.

[24] W. Mostowski and P. Vullers,

“Efﬁcient U-Prove
implementation for anonymous credentials on smart
in 7th International Conference on Secu-
cards,”
rity and Privacy in Communication Networks (Se-
cureComm), 2011.

[25] K. Elmufti, D. Weerasinghe, M. Rajarajan, and
V. Rakocevic, “Anonymous authentication for mobile
single sign-on to protect user privacy,” International
Journal of Mobile Communications, vol. 6, no. 6, pp.
760–769, 2008.

J. Wang, G. Wang, and W. Susilo, “Anonymous single
sign-on schemes transformed from group signatures,”
in 5th International Conference on Intelligent Net-
working and Collaborative Systems (INCoS), 2013,
pp. 560–567.

[26]

[27]

[28] T.-F. Lee, “Provably secure anonymous single-sign-on
authentication mechanisms using extended Chebyshev
Chaotic Maps for distributed computer networks,”
IEEE Systems Journal, vol. 12, no. 2, pp. 1499–1505,
2018.

[29]

J. Han, L. Chen, S. Schneider, H. Treharne, S. Wese-
meyer, and N. Wilson, “Anonymous single sign-on
IEEE Transactions on
with proxy re-veriﬁcation,”
Information Forensics and Security, vol. 15, pp. 223–
236, 2020.

[30] M. Schanzenbach, T. Kilian, J. Schutte, and C. Banse,
“ZKlaims: Privacy-preserving attribute-based cre-
dentials using non-interactive zero-knowledge tech-
in 16th International Joint Conference on
niques,”
e-Business and Telecommunications (ICETE), Volume
2: SECRYPT, 2019.

[31] A. Davidson, I. Goldberg, N. Sullivan, G. Tankersley,
and F. Valsorda, “Privacy Pass: Bypassing Internet
challenges anonymously,” Privacy Enhancing Tech-
nologies, vol. 2018, no. 3, pp. 164–180, 2018.

[32]

J. Maheswaran, D. I. Wolinsky, and Bryan Ford,
“Crypto-book: An architecture for privacy preserving
in 12th ACM Workshop on Hot
online identities,”
Topics in Networks (HotNets), 2013.

[33] D. Boneh, X. Ding, G. Tsudik, and C.-M. Wong, “A
method for fast revocation of public key certiﬁcates
and security capabilities,” in 10th USENIX Security
Symposium, 2001.

[34] A. Buldas, A. Kalu, P. Laud, and M. Oruaas, “Server-
supported RSA signatures for mobile devices,”
in
22nd European Symposium on Research in Computer
Security (ESORICS), 2017.

[35] W. Lueks, B. Hampiholi, G. Alpar, and C. Troncoso,
“Tandem: Securing keys by using a central server
while preserving privacy,” Privacy Enhancing Tech-
nologies, vol. 2020, no. 3, pp. 327–355, 2020.

[36] D. Fett, R. K¨usters, and G. Schmitz, “A comprehensive
in 2016
formal security analysis of OAuth 2.0,”
ACM Conference on Computer and Communications
Security (CCS), 2016, pp. 1204–1215.

[37] D. Fett, R. K¨usters, and G. Schmitz, “The Web SSO
standard OpenID Connect: In-depth formal security
analysis and security guidelines,” in 30th IEEE Com-
puter Security Foundations Symposium (CSF), 2017,
pp. 189–202.

J. Han, L. Chen, S. Schneider, H. Treharne, and
“Anonymous single-sign-on for n
S. Wesemeyer,
designated services with traceability,” in 23rd Euro-
pean Symposium on Research in Computer Security
(ESORICS), 2018, pp. 470–490.

[38] D. Fett, R. K¨usters, and G. Schmitz, “An expressive
model for the web infrastructure: Deﬁnition and appli-
cation to the BrowserID SSO system,” in 35th IEEE
Symposium on Security and Privacy (S&P), 2014, pp.
673–688.

18

[39] A. Armando, R. Carbone, L. Compagna, J. Cu´ellar,
“Formal analysis of SAML 2.0
and L. Tobarra,
web browser single sign-on: Breaking the SAML-
based single sign-on for Google Apps,” in 6th ACM
Workshop on Formal Methods in Security Engineering
(FMSE), 2008, pp. 1–10.

[40] R. Wang, S. Chen, and X. Wang,

“Signing me
onto your accounts through Facebook and Google:
A trafﬁc-guided security study of commercially de-
ployed single-sign-on web services,” in 33rd IEEE
Symposium on Security and Privacy (S&P), 2012, pp.
365–379.

[41] S.-T. Sun and K. Beznosov,

“The devil is in the
(implementation) details: An empirical analysis of
OAuth SSO systems,” in 19th ACM Conference on
Computer and Communications Security (CCS), 2012,
pp. 378–390.

[42] A. Armando, R. Carbone, L. Compagna, J. Cu´ellar,
G. Pellegrino, and A. Sorniotti, “An authentication
ﬂaw in browser-based single sign-on protocols: Impact
and remediations,” Computers & Security, vol. 33, pp.
41–58, 2013.

[43] C. Bansal, K. Bhargavan, A. Delignat-Lavaud, and
S. Maffeis, “Discovering concrete attacks on website
authorization by formal analysis,” Journal of Com-
puter Security, vol. 22, no. 4, pp. 601–657, 2014.

[44] W. Li and C. Mitchell, “Analysing the security of
Google’s implementation of OpenID Connect,” in 13th
International Conference on Detection of Intrusions
and Malware & Vulnerability Assessment (DIMVA),
2016, pp. 357–376.

[45]

J. Somorovsky, A. Mayer, J. Schwenk, M. Kampmann,
and M. Jensen, “On breaking SAML: Be whoever you
want to be,” in 21th USENIX Security Symposium,
2012, pp. 397–412.

[46] H. Wang, Y. Zhang, J. Li, and D. Gu, “The achilles
heel of OAuth: A multi-platform study of OAuth-
based authentication,” in 32nd Annual Conference on
Computer Security Applications (ACSAC), 2016, pp.
167–176.

[47] C. Mainka, V. Mladenov, and J. Schwenk, “Do not
trust me: Using malicious IdPs for analyzing and
in 1st IEEE European
attacking single sign-on,”
Symposium on Security and Privacy (EuroS&P), 2016,
pp. 321–336.

[48] C. Mainka, V. Mladenov, J. Schwenk, and T. Wich,
“SoK: Single sign-on security - An evaluation of
OpenID Connect,” in 2nd IEEE European Symposium
on Security and Privacy (EuroS&P), 2017, pp. 251–
266.

[49] R. Yang, W. C. Lau, J. Chen, and K. Zhang, “Vetting
single sign-on SDK implementations via symbolic
in 27th USENIX Security Symposium,
reasoning,”
2018, pp. 1459–1474.

[50] Y. Zhou and D. Evans, “SSOScan: Automated testing
of web applications for single sign-on vulnerabilities,”
in 23rd USENIX Security Symposium, 2014, pp. 495–
510.

[51] R. Yang, G. Li, W. C. Lau, K. Zhang, and P. Hu,
“Model-based security testing: An empirical study on
OAuth 2.0 implementations,” in 11th ACM Asia Con-
ference on Computer and Communications Security
(AsiaCCS), 2016, pp. 651–662.

[52] R. Wang, Y. Zhou, S. Chen, S. Qadeer, D. Evans,
and Y. Gurevich,
“Explicating SDKs: Uncovering
assumptions underlying secure authentication and au-
in 22th USENIX Security Symposium,
thorization,”
2013, pp. 399–314.

[53]

J. Navas and M. Beltr´an, “Understanding and mitigat-
ing OpenID Connect threats,” Computer & Security,
vol. 84, pp. 1–16, 2019.

[54] E. Chen, Y. Pei, S. Chen, Y. Tian, R. Kotcher, and
P. Tague, “OAuth demystiﬁed for mobile application
developers,” in 2014 ACM Conference on Computer
and Communications Security (CCS), 2014, pp. 892–
903.

[55] H. Wang, Y. Zhang, J. Li, H. Liu, W. Yang, B. Li,
“Vulnerability assessment of OAuth
and D. Gu,
in 31st
implementations in Android applications,”
Annual Computer Security Applications Conference
(ACSAC), 2015, pp. 61–70.

[56] R. Yang, W. C. Lau, and S. Shi, “Breaking and ﬁxing
mobile App authentication with OAuth2.0-based pro-
tocols,” in 15th International Conference on Applied
Cryptography and Network Security (ACNS), 2017,
pp. 313–335.

[57] S. Shi, X. Wang, and W. C. Lau,

“MoSSOT: An
automated blackbox tester for single sign-on vul-
in 14th ACM
nerabilities in mobile applications,”
Asia Conference on Computer and Communications
Security (AsiaCCS), 2019, pp. 269–282.

[58] M. Ghasemisharif, A. Ramesh, S. Checkoway,
C. Kanich, and J. Polakis, “O single sign-off, where art
thou? An empirical analysis of single sign-on account
hijacking and session management on the web,” in
27th USENIX Security Symposium, 2018, pp. 1475–
1492.

19

[59] Y. Cao, Y. Shoshitaishvili, K. Borgolte, C. Kr¨ugel,
G. Vigna, and Y. Chen, “Protecting web-based single
sign-on protocols against relying party impersonation
attacks through a dedicated bi-directional authenti-
cated secure channel,” in 17th International Sympo-
sium on Research in Attacks, Intrusions and Defenses
(RAID), 2014, pp. 276–298.

[60] M. Shehab and F. Mohsen, “Towards enhancing the
security of OAuth implementations in smart phones,”
in 3rd IEEE International Conference on Mobile Ser-
vices (MS), 2014, pp. 39–46.

[61]

[62]

[63]

[64]

living

“HTML
cross-document
messaging,” https://html.spec.whatwg.org/multipage/
web-messaging.html, Accessed June 7, 2022.

standard:

9.3

J. Eisinger and E. Stark, W3C candidate recommen-
dation: Referrer policy, World Wide Web Consortium
(W3C), 2017.

“MITREid Connect,” http://mitreid-connect.github.io/
index.html, Accessed August 20, 2021.

“jsrsasign,” https://kjur.github.io/jsrsasign/, Accessed
August 20, 2019.

[65] B. de Medeiros, M. Scurtescu, P. Tarjan, and M. Jones,
OAuth 2.0 multiple response type encoding practices,
The OpenID Foundation, 2014.

[66] A. Bender, J. Katz, and R. Morselli, “Ring signa-
tures: Stronger deﬁnitions, and constructions without
in 3rd Theory of Cryptography
random oracles,”
Conference (TCC), 2006, pp. 60–79.

[67] D. Chaum and E. van Heyst,

“Group signatures,”
in Advances in Cryptology - EUROCRYPT. Springer,
1991, pp. 257–265.

[68] R. Dingledine, N. Mathewson, and P. Syverson, “Tor:
The second-generation onion router,” in 13th USENIX
Security Symposium, 2004, pp. 303–320.

[69]

“Same origin policy,” https://www.w3.org/Security/
wiki/Same Origin Policy, Accessed June 7, 2022.

[70] A. Faz-Hernandez, S. Scott, N. Sullivan, R. Wahby,
and C. Wood, “Hashing to elliptic curves,” Internet-
Draft draft-irtf-cfrg-hash-to-curve-16, Internet Engi-
neering Task Force, 2022.

20

