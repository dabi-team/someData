MLSNet: A Policy Complying Multilevel Security
Framework for Software Deﬁned Networking

Stefan Achleitner, Quinn Burke, Student Member, IEEE,
Patrick McDaniel, Fellow, IEEE, Trent Jaeger, Member, IEEE,
Thomas La Porta, Fellow, IEEE, and Srikanth Krishnamurthy, Fellow, IEEE

1

0
2
0
2

p
e
S
1
2

]
I

N
.
s
c
[

1
v
1
2
0
0
1
.
9
0
0
2
:
v
i
X
r
a

Abstract—Ensuring that information ﬂowing through a net-
work is secure from manipulation and eavesdropping by unau-
thorized parties is an important task for network administrators.
Many cyber attacks rely on a lack of network-level information
ﬂow controls to successfully compromise a victim network. Once
an adversary exploits an initial entry point, they can eavesdrop
and move laterally within the network (e.g., scan and penetrate
internal nodes) to further their malicious goals. In this paper,
we propose a novel multilevel security (MLS) framework to
enforce a secure inter-node information ﬂow policy within the
network and therein vastly reduce the attack surface available
to an adversary who has penetrated it. In contrast to prior
work on multilevel security in computer networks which relied
on enforcing the policy at network endpoints, we leverage the
centralization of software-deﬁned networks (SDNs) by moving
the task to the controller and providing this service transparently
to all nodes in the network. Our framework, MLSNet, formalizes
the generation of a policy compliant network conﬁguration (i.e.,
set of ﬂow rules on the SDN switches) as network optimization
problems, with the objectives of (1) maximizing the number
of ﬂows satisfying all security constraints and (2) minimizing
the security cost of routing any remaining ﬂows to guarantee
availability. We demonstrate that MLSNet can securely route
ﬂows that satisfy the security constraints (e.g., > 80% of ﬂows
in a performed benchmark) and route the remaining ﬂows with
a minimal security cost.

Index Terms—Software-deﬁned networks, security services,

security management.

I. INTRODUCTION

Ensuring that information ﬂowing through a network is
secure from manipulation and eavesdropping by unauthorized
parties is an important task for network administrators. Many

This research was sponsored by the U.S. Army Combat Capabilities
Development Command Army Research Laboratory and was accomplished
under Cooperative Agreement Number W911NF-13-2-0045 (ARL Cyber
Security CRA). The views and conclusions contained in this document are
those of the authors and should not be interpreted as representing the ofﬁcial
policies, either expressed or implied, of the Combat Capabilities Development
Command Army Research Laboratory or the U.S. Government. The U.S.
Government is authorized to reproduce and distribute reprints for Government
purposes notwithstanding any copyright notation here on.

Stefan Achleitner was with the Department of Computer Science and
Engineering, The Pennsylvania State University, University Park, PA 16802
USA. He is now with Palo Alto Networks, Inc., Santa Clara, CA 95054 USA
(e-mail: stefan@stefanachleitner.com).

Quinn Burke, Patrick McDaniel, Trent Jaeger, and Thomas La Porta are
with the Department of Computer Science and Engineering, The Pennsylvania
State University, University Park, PA 16802 USA (e-mail: qkb5007@psu.edu;
mcdaniel@cse.psu.edu; trj1@psu.edu; tﬂ12@psu.edu).

Srikanth Krishnamurthy is with the Department of Computer Science and
Engineering, University of California, Riverside, Riverside, CA 92521 USA
(e-mail: krish@cs.ucr.edu).

attacks against modern networks rely on a lack of network-
level information ﬂow controls to inﬁltrate an organizational
network. Here, adversaries initially subvert edge defenses to
target and compromise an internal node. Once inside the net-
work, the adversary can probe network nodes or eavesdrop on
ﬂows to penetrate further into the network [1]. This adversary-
enabling freedom of movement and lack of secure routing (to
prevent eavesdropping) can be cast as a classical information
ﬂow problem in security [2].

Even with defenses such as ﬁrewalls,

information ﬂow
control in networks often fails: conﬁguration is error-prone [3],
and compromised internal hosts may initiate ﬂows that never
have to cross a ﬁrewall boundary [4]. Thus, adversaries can
exploit ﬁrewall rule conﬂicts to exﬁltrate information, and in-
ternal adversaries can eavesdrop and move laterally (i.e., scan
and penetrate internal nodes) within their network boundary
without restriction. Fundamentally, they are enabled by a lack
of security policy governing what ﬂows are permitted and what
paths they may take in the network.

Multilevel security (MLS) provides the means to enforce
such a policy. A multilevel security framework controls infor-
mation ﬂow among entities of different security classes with
security labels (i.e., levels and categories) assigned to those
entities. In fact, multilevel security already plays a critical role
in controlling access to information for both military personnel
and employees of commercial businesses with different levels
of clearance [5]. Common use cases include controlling ﬁle
access in an operating system [6] or table access in a relational
database [7]. The notion of multilevel security can also be
applied to computer networks, where the MLS policy dictates
which nodes are allowed to communicate, what type of trafﬁc
they may exchange, and what paths the ﬂows may take in
the network. This strategy can prevent eavesdropping and
unrestricted lateral movement that plague modern networks.

Lu et al. [8] envisioned such a model that enforces the
information ﬂow policy at network endpoints; however, the
scale and dynamic behavior of modern networks make deploy-
ing such an enforcement mechanism on every endpoint im-
practical. Despite this, the inherent centralization of software-
deﬁned networks (SDNs) allows enforcement of a network-
level MLS policy in a scalable and efﬁcient manner. Deter-
mination of whether or not ﬂows are permitted can be done
by the controller, and the policy can be enforced by the data-
plane switches in the form of ﬂow rules—which allows the
service to be provided transparently to the entire network.

Thus, in this paper, we propose an SDN-based MLS frame-

 
 
 
 
 
 
TABLE I
NOMENCLATURE AND NOTATION.

Notation Description
V
E
F
R
A
S
O
C
df
κij ((cid:101)κij)
σi
λc
i
L

Set of vertices in network graph G = {V, E}
Set of edges in network graph G = {V, E}
Set of packet ﬂows to be accommodated
Set of matching ﬁelds in a ﬂow rule
Set of action ﬁelds in a ﬂow rule
Set of subjects
Set of objects
Set of security categories
Size of ﬂow f ∈ F
Residual capacity of link (i, j), (i, j) ∈ E
Security level of node i, i ∈ V
Security category c at node i
Set of labels that form the lattice

work to enforce an inter-node information ﬂow policy that
preserves conﬁdentiality. The challenge here is to ﬁt the or-
ganizational needs by allowing entities to exchange permitted
ﬂows while also conﬁguring the network (by leveraging ﬂow
rules) to be policy compliant. Permitted ﬂows between two
endpoints may not always ﬁnd a secure path due to limited
network resources (e.g., link capacity). Then, to guarantee
availability, a ﬂow may have to be routed through an insecure
path. We refer to such a situation as a policy conﬂict, and each
conﬂict imposes a security cost in terms of the risk the ﬂow
is being exposed to.

Unlike prior work [8], we approach the challenge of se-
curing information ﬂow in the network by considering two
optimization models: one that can provide a secure network
conﬁguration (i.e., composition of ﬂows rules) that obeys the
security policy, supplemented by a model that can minimally
relax the security policy to ensure that every ﬂow can be
routed. The key contributions are:

• An optimization model to maximize the number of ﬂows
routed according to the given security policy in an SDN.
• An optimization model to minimize the security cost of
routing any remaining ﬂows to guarantee availability.
• A method for constructing ﬂow rules which adhere to a

given security policy.

• A comprehensive evaluation of MLSNet’s ability to gen-
erate policy compliant network conﬁgurations and resolve
policy conﬂicts in realistic network topologies.

II. DEFINITIONS AND BACKGROUND

In this section, we extend prior work’s [8] terms and
notations (Table I) to an SDN setting and provide background
on related network security threats and defenses, and MLS.

A. Term Deﬁnitions

Node. A resource connected to a network (e.g., a user, server,
router, or SDN switch).
Subject. A node that initiates communication to other nodes

Fig. 1. Corporate network scenario.

in the network.
Object. A node that either provides (provider) and/or receives
(receiver) information to/from subjects
Forwarding Node. A node (SDN switch) that processes
incoming ﬂows according to the installed ﬂow rules.
Controller. An application in the SDN control plane that
has a global view of the topology and installs ﬂow rules to
forwarding nodes based on the security policy.
Security Levels. Hierarchical attributes (e.g., top-secret, pub-
lic) that indicate relative authorization power.
Security Categories. Non-hierarchical attributes (e.g., TCP,
IP) that offer ﬁner-grained authorization besides the security
level. In MLSNet, security categories are only assigned to
objects and subjects but not forwarding nodes.
Security Label. The security level and categories combined,
used by the controller to admit or deny ﬂows.

B. Network Threats to Conﬁdentiality

Conﬁdentiality ensures that information is only being ac-
cessed by authorized parties. In the context of networking,
preserving conﬁdentiality means that only explicitly allowed
communication can ﬂow between any two nodes in the net-
work to prevent data from falling into the hands of untrusted
entities. A lack of a formal communication policy to realize
this may allow adversaries who have compromised internal
nodes to explore the network or eavesdrop on ﬂows. For
example, in Figure 1, a compromised trusted node in the
software center may be able to probe other nodes in the
software and commercial centers as they are all behind the
same ﬁrewall boundary; the ﬁrewall itself cannot prevent the
adversary from probing all nodes on TCP port 22. Indeed, this
is possible regardless of the (implicit) security level of the
nodes; however, we can reduce attacker capabilities (enforce
least-privilege) with multilevel security.

Recent work has demonstrated the ability of an adversary
to freely probe within their network boundary to recover
sensitive information about the network [9], [10], [11], [12],
[13], including active network hosts and even switch ﬂow table
rules [14]. We observe that although discovered attacks on
networks in the literature pursue different goals, the strategies

2

TABLE II
DEFENSES AGAINST DISCUSSED ATTACK TECHNIQUES.

Packet spooﬁng
Lateral movement
Man-in-the-middle

MLSNet
×
×
×

[19]
×
-
-

[4]
-
×
-

[21]
-
-
×

of those posing a threat to conﬁdentiality can be reduced to a
small set of techniques.

Packet Spooﬁng. Spooﬁng packets is the most common
technique. By spooﬁng, adversaries may be able to imperson-
ate other nodes to escalate privilege [15] or leak information
to untrustworthy nodes or outside of the network [16].

Lateral Movement. Adversaries can also move laterally by
probing many other nodes in the network. This nonessential
communication may allow them to extract sensitive informa-
tion from nodes of higher security levels or compromise nodes
and escalate privilege to move deeper into the network [14].
Man-in-the-Middle. Adversaries can also position them-
selves as a man-in-the-middle (MiTM), silently eavesdropping
on communications traversing them or within their broadcast
domain [17], [18].

C. Proposed Defenses

Although there have been defenses proposed against some
of the discussed attack techniques, they are limited in their
ability to preserve conﬁdentiality.

Source validation. To address the issue of packet spooﬁng,
source validation seeks to only permit packets into a network
which’s source IP is valid on the given network interface. This
is typically implemented via ingress ﬁltering [19] in wide-area
networks; however, it is difﬁcult to implement, especially in
data-center networks [20], and does not prevent adversaries
from spooﬁng nodes within their own subnetwork.

Firewalling. The primary purpose of a ﬁrewall is to prevent
unauthorized packets from entering a network or subnetwork.
However, ﬁrewalling is limited with respect
to preventing
lateral movement as conﬁguration is error-prone [3], and com-
promised internal hosts can still probe within their network
boundary [4] to compromise internal nodes.

Encryption. Active man-in-the-middle attacks (i.e., those
staged by spooﬁng) may be mitigated with source validation;
however, preventing passive MiTM (eavesdroppers) is difﬁcult.
Even with services such as encryption, adversaries can still
perform trafﬁc analysis to extract sensitive information [21].

D. Preserving Conﬁdentiality with Multilevel Security

Broadly speaking, existing defenses solve distinct problems
and only partially address the issue of conﬁdentiality. Adver-
saries are enabled by a lack of policy preventing them from
probing network nodes and eavesdropping on communications.
What is needed are means to specify what ﬂows are permitted
and what paths they may take in the network.

MLS. A multi-level security policy provides the means to
prevent these problems with a secure ﬂow model between en-
tities that are assigned speciﬁc security labels (i.e., a level and

categories). The security labels form a lattice structure, which
reﬂects a hierarchical ordering of their relative authorization
power. We consider a node’s label to be higher than another
node’s if the former’s level is greater than or equal to, and
the categories form a superset of, the latter’s. With respect to
conﬁdentiality, information should only ﬂow to nodes with the
same or higher security label to prevent the potential leakage
of sensitive data to nodes of lower security labels. This is
typically summarized as ”no read up, no write down”.

Network MLS. Multilevel security already plays a critical
role in controlling access to ﬁles and databases in military
and commercial business contexts [5], [6], [7]. This notion
can also be applied to computer networks to prevent
the
eavesdropping and unrestricted lateral movement that plague
modern networks. For example, nodes with lower security
levels should not be able to probe or communicate with nodes
of higher levels on speciﬁc TCP ports, and sensitive (e.g., top-
secret) ﬂows should not traverse a node of lower security level.
In this context, for communication to be permitted and routed
between two nodes, both nodes and any intermediate nodes
must adhere to the ”no read up, no write down” policy.

Lu et al. [8] envisioned such an MLS model that enforces
the information ﬂow policy at network endpoints. The problem
with this approach is that the scale and dynamic behavior
of modern networks make deploying such an enforcement
mechanism on every endpoint impractical. However, the inher-
ent centralization of software-deﬁned networks (SDNs) allows
enforcement of a network-level MLS policy in a scalable
and efﬁcient manner. Determination of whether or not ﬂows
are permitted can be done by the controller, and the policy
can be enforced by the data-plane switches in the form of
ﬂow rules. This offers the signiﬁcant advantage over previous
work of allowing the service to be provided transparently to
the entire network, because network devices do not have to
run specialized software. The controller’s global view of the
network also offers greater ﬂexibility as changes to labels and
policy can be reﬂected by simple changes to ﬂow rules, as
opposed to manually re-conﬁguring individual devices.

Ultimately, multilevel security can ensure that the network
achieves (to the degree possible) least-privilege isolation,
where only explicitly allowed communication can ﬂow within
the network and must ﬂow through secure paths. Hence,
it provides for maximal isolation from unauthorized parties
and therefore the smallest possible threat surface. Here, we
can mitigate lateral movement (by enforcing least-privilege),
eavesdropping (with secure routing paths), and packet spoof-
ing (blocking unknown sources) by unauthorized entities—a
signiﬁcant improvement over prior work (see Table II). We
note that compromised nodes may still be able to probe or
eavesdrop nodes for which they have sufﬁcient security level
and categories; however, their capabilities are signiﬁcantly
restricted to only that allowed by policy, and they can quickly
be quarantined (via ﬂow rules) upon detection.

III. MLSNET OVERVIEW

In this section, we present our threat model,
security labels, and policy constraints for MLSNet.

lattice of

3

A. Threat Model and Assumptions

For the assignment of security labels, we assume a Network
Security Ofﬁcer (NSO), as deﬁned by Lu et al. [8], who assigns
appropriate security labels (i.e., levels and categories) to the
network entities (e.g., endpoint devices and forwarding nodes).
The assignment can be done by leveraging the controller
as it has a global view of the network, and it must be
based on a security assessment of the entities in the network.
For example, endpoints with unpatched operating systems
should be assigned a lower security level, as they are more
likely to contain vulnerabilities than others with the latest
software updates. IoT devices or forwarding nodes connected
to third-party networks can also be considered less secure,
and therefore should be assigned a lower security level and a
restricted set of categories. In contrast, endpoints containing
more sensitive (e.g., top-secret) data should have a higher
security level assigned since information ﬂow to nodes with
lower levels should be prevented.

MLSNet aims to protect conﬁdentiality by preventing leak-
age to unauthorized entities. We assume that nodes connected
to a network may become compromised and have malicious
intentions. In this scenario, we aim to limit an adversary’s
ability to further compromise the network.

Additionally, we assume the controller has an accurate view
of the topology (i.e., nodes have not been spoofed). MLS
cannot detect all forms of packet spooﬁng, and we rely on
other SDN-based defenses to detect packet spooﬁng against
the topology discovery service [9].

B. Multilevel Security Lattices for Computer Networks

To compute an SDN-based network conﬁguration (set of
ﬂow rules installed to SDN switches) that satisﬁes the security
policy, we must ﬁrst consider security levels and categories. As
drawn from Denning [2], we order the security levels used in
our model according to the following: TopSecret (4) > Secret
(3) > Conﬁdential (2) > Public (1). For an SDN, we deﬁne
the security categories as the packet types supported by the
OpenFlow [22] protocol for matching incoming packets to
ﬂow rules: TCP, ICMP, etc. Although, any number of levels
and categories can be deﬁned to separate classes of ﬂows; we
just use the above descriptions as one example for evaluation.
The combination of a level and one or more categories
then forms the label at a node. These labels form a lattice,
a partially ordered set that reﬂects the secrecy and privilege
requirements of communication in the network. We consider
a node’s label to be higher than another node’s if the former’s
level is greater than or equal to, and the categories form a
superset of, the latter’s. This can be seen in the sample lattice
shown in Figure 2. We note that this construction may lead to
incomparable labels, where neither label is a subset/superset
of the other, in which case communication would be denied by
default. This will preserve conﬁdentiality but with the caveat
that not every ﬂow may be accommodated.

Given the labels, the controller will install ﬂow rules to the
SDN switches to allow communication only if the security
constraints are satisﬁed.

Fig. 2. OpenFlow speciﬁc security lattice for networks used in our evaluations

C. Security Policy Constraints

In this section, we discuss the access control and ﬂow
control constraints, which form the basis of our security policy.
Access Control. As the ﬁrst step to compute a security pol-
icy compliant network conﬁguration, we determine if a subject
(e.g., user or process) initiating communication with an object
(e.g., ﬁle or resource) is allowed to exchange information with
the object based on the security levels and categories. To deﬁne
the constraints for access control, we have to consider if the
subject is communicating with a receiver object (i.e., object
receives from subject) or a provider object (i.e., subject sends
to object). If the subject communicates with a provider object,
then information ﬂows from object o to subject s; inversely, if
object o is a receiver object, then information ﬂows from s to o.
In case the object is both a provider and receiver object at the
same time, information ﬂow between s and o is bidirectional.
Considering these three cases, given security level σ and
categories C of subject s and object o, the authorized informa-
tion ﬂows are deﬁned by a conventional MLS conﬁdentiality
model [23]. For a subject s (e.g., workstation user) communi-
cating with a provider object o, (e.g., mail server in the DMZ
in Figure 1), the following constraint must be satisﬁed:

σo ≤ σs and Co ⊆ Cs, ∀o ∈ O, s ∈ S

(1)

Secondly, for a subject s (e.g., Wi-Fi client) communicating
with a receiver object o (e.g., network printer), the following
constraint must be satisﬁed:

σo ≥ σs and Co ⊇ Cs, ∀o ∈ O, s ∈ S

(2)

And for a subject s (e.g., workstation user) communicating
with an object o that is both a provider and receiver (e.g., git
repository), the following constraint must be satisﬁed:

σo = σs and Co = Cs, ∀o ∈ O, s ∈ S

(3)

Upon the initial arrival of a ﬂow at the SDN controller from
a subject, it can be determined if the subject s is allowed
to exchange information with object o by considering the
access control constraints. While we deﬁne our framework
in a general way, security levels and categories are deﬁned
speciﬁc to SDNs, as discussed in Section III-B.

Flow Control. If the access control constraints are satisﬁed,
information is allowed to ﬂow between object o and subject s.
The next step before rule installation is for the controller to de-
termine whether there exists a path between o and s such that
the security level of any forwarding node on the path between o
and s is not lower than that of the ﬂow. In Figure 1, the security
level of the switch connecting the publicly accessible Wi-Fi
to the network is lower compared to the switches connected
with the secure VPN, which are behind ﬁrewalls and only for
internal users. Traversing lower classiﬁed nodes puts a ﬂow at
risk of being leaked to untrustworthy entities, being modiﬁed,

4

or otherwise disrupted. Thus, protection of conﬁdentiality is
constrained by secure path selection, and MLSNet will choose
an optimal path (if one exists) that satisﬁes this constraint for
any candidate ﬂow.

the
We can formulate such a constraint by stating that
security level σ of a node j on the path between o and s
cannot be lower than the security level of the originating node
of the ﬂow. As with the access control constraint, we have to
take into account whether a subject is communicating with a
provider object, a receiver object, or an object that is both. If
the subject is communicating with a provider object, then the
following constraint must be satisﬁed:

σo ≤ σj, ∀j ∈ V on path (o, s) for ﬂow f ∈ F

(4)

Secondly, if the subject is communicating with a receiver
object, then trafﬁc is ﬂowing from the subject toward the
object, and the following constraint must be satisﬁed:

σs ≤ σj, ∀j ∈ V on path (o, s) for ﬂow f ∈ F

(5)

Lastly, the access control constraint for communicating with
an object that is a receiver and provider at the same time
deﬁnes that s and o are required to have the same security
level as stated in (3). Therefore, the ﬂow control for such a
case requires a forwarder node to have a security level that is
higher or equal compared to the level of s and o:

(σs, σo) ≤ σj, ∀j ∈ V on path (o, s) for ﬂow f ∈ F

(6)

In addition to the security labels, we also must consider the
capacity κij of a link (i, j) on a path between s and o for a ﬂow
with a size of df : κij ≥ df ∀(i, j) on path (o, s). As a trade-
off for providing ﬂow control, policy compliant paths may be
longer than a shortest available path which does not consider
a security policy. Additionally, in case two nodes satisfy the
the access control constraint, there is no guarantee that a path
between the nodes can be found which fulﬁlls the ﬂow control
constraint. If such, there may be a path traversing nodes which
do not have a high enough security label. We refer to such
cases as policy conﬂicts. In Section IV-C, we present a model
to minimize policy conﬂicts on ﬂow paths. In short, it will ﬁnd
the best ﬁtting conﬁguration and report the exact locations on
paths where policy conﬂicts exist. By deploying additional
security mechanisms, such as declassiﬁcation via encrypted
communication channels, such conﬂicts can be resolved, as
we further discuss in Section IV-F.

under the assumption that all ﬂows f ∈ F permitted by the
access control constraint must be accommodated.

A. Policy Compliant Flow Maximization Problem

In this section, we introduce an ILP to maximize the number
of ﬂows that can be accommodated by a network under
consideration of capacity and security constraints. We refer
to this problem as the policy compliant ﬂow maximization
problem, and formulate the constraints in (7). The optimization
model shown determines if a network conﬁguration fulﬁlling
the deﬁned security policy can be found to route the ﬂows F
between the subjects S and objects O. To compute a path, we
ﬁrst introduce a binary decision variable xf
ij to indicate if link
(i, j) ∈ E is used on the path for ﬂow f (i.e., xf
ij = 1) or not
(i.e., xf
ij = 0). To decide if a ﬂow f can be accommodated,
we also introduce the binary decision variable αf .

In 7b, we add αf to the link indication variable xf
is to
trigger a ﬂow f at a subject s. To compute a path between the
subject node s and object node o, a ﬂow f is consumed at a
node o, as stated in constraint 7c, by subtracting αf from the
link indication variable. In 7d, we state the ﬂow preservation
constraint to ensure that the sum of incoming ﬂows into a node
equals the sum of outgoing ﬂows of a node.

max

(cid:88)

αf

f ∈F

s.t.

(cid:88)

xf
is + αf =

(cid:88)

xf
sj ,

i:(i,s)∈E

j:(s,j)∈E

(cid:88)

xf
oj − αf = 0,

j:(o,j)∈E

(cid:88)

xf
ij =

(cid:88)

xf
jk,

i,j∈E

j,k∈E

(cid:88)

xf
ij ≤ 1,

i:(i,j)∈E

(cid:88)

f ∈F

xf
ij · df ≤ κij ,

(7a)

∀f ∈ F

(7b)

∀f ∈ F

(7c)

∀f ∈ F

(7d)

∀f ∈ F, j ∈ V

(7e)

∀(i, j) ∈ E

(7f)

αf · lev(σo, σs) = αf ,

∀o(f ) ∈ O, s(f ) ∈ S, f ∈ F

(7g)

αf · cat(λc

o, λc

s) = αf ,

∀o(f ) ∈ O, s(f ) ∈ S, c ∈ C, f ∈ F

(7h)

IV. POLICY COMPLIANT FLOWS

ij · orig(σo, σs) ≤ xf
xf

ij · σj ,

Given the policy constraints and security labels, we intro-
duce optimization models to compute a ﬂow-rule-based net-
work conﬁguration under consideration of policy compliance
and resource availability. We ﬁrst introduce an integer linear
programming (ILP) model to maximize the number of ﬂows
strictly satisfying all security constraints. If no path meeting
the required security constraints can be found for a ﬂow f , the
model will suggest to drop f . Further, we propose a second
ILP-based optimization model which minimizes the sum of
policy conﬂict values, given a topology and security labels,

xf
ij ∈ {0, 1},
αf ∈ {0, 1},

∀(i, j) ∈ E, o(f ) ∈ O, s(f ) ∈ S, f ∈ F

(7i)

∀(i, j) ∈ E, f ∈ F

∀f ∈ F

We add constraint 7e to limit the number of visits of a
node to one for each ﬂow. Constraint 7f ensures that the given
capacity κij of a link (i, j) ∈ E is not exceeded for forwarding
ﬂows over a link i, j with a size of df per ﬂow. Typically, in
bidirectional communication in computer networks the size of

5

the request ﬂow is different than the size of the reply ﬂow.
Since we assume symmetric routes, the ﬂow size variable
df should be chosen to account for the ﬂow size in both
directions. Additionally, since new ﬂow demands typically
arrive at different times in a network, we can replace the above
link capacity κij with the residual capacity (cid:101)κij which states
the remaining capacity on a link (i, j) ∈ E considering the
existing ﬂows in a network traversing link (i, j).

In constraints 7g and 7h, we deﬁne the access control
properties. Constraint 7g ensures that a ﬂow f between a
subject s and an object o is only permitted if the function
lev(σo, σs), shown in (8), returns 1, indicating that the security
levels of s and o allow communication:

lev(σo, σs) =

if o is provider object and σo ≤ σs
if o is receiver object and σo ≥ σs
if o is both and σo = σs


1,

1,
1,

0, otherwise

(8)

As deﬁned in Section III-C for access control, we further
the subject s and object o have the
have to ensure that
appropriate security categories before calculating a path. In
function cat(λc
s) shown in (9), we model the requirement
of security categories to allow a ﬂow between s and o:

o, λc

Algorithm 1 PolicyCompliantPath(G,s,o,df )

dist[v] = inﬁnity, prev[v] = null

1: V = nodes in G
2: for all v ∈ V do
3:
4: end for
5: dist[s] = 0
6: N = nodes in G
7: if lev(σo, σs) = 1 and cat(λc

o, λc

s) = 1, ∀λc

o ∈ Co, λc

s ∈

Cs then

while N not empty do

i = node in N with smallest dist[]
remove i from N
for all adjacent node j of i do

if orig(σo, σs) ≤ σj and df ≤ (cid:101)κij then

distnew = dist[i] + 1
if distnew ≤ dist[j] then

dist[j] = distnew
prev[j] = i

end if

8:
9:
10:
11:
12:
13:

14:
15:
16:
17:
18:

end if
end for
end while

19:
20:
21: end if
22: return prev

cat(λc

o, λc

s) =





1 − (λc
1 − (λc
1 − (λc
0,

o − λc
s − λc
s − λc

o · λc
s),
s · λc
o),
o) · (λc

s − λc

o), if o is both
otherwise

if o is provider
if o is receiver

Section III-C:

(9)
To mathematically deﬁne this, we introduce variable λc
i which
indicates if a node i has a security category c, i.e., λc
i =
1, or not, i.e., λc
i = 0. As an example for the operation of
function cat(), suppose a subject s wants to communicate with
a provider object o. In order to permit the ﬂow, the constraint
that Co ⊆ Cs must be satisﬁed. To evaluate if the security
categories Co of an object are a subset of the categories in
Cs, we introduce the formulation 1 − (λc
s) as shown
in (9). This will evaluate to 0 if subject s does not have a
security category c, but object o does, i.e., (1−(1−1·0)) = 0.
Such a case does not fulﬁll the access control constraint, and
therefore the ﬂow cannot be admitted, i.e., αf = 0.

o − λc

o · λc

Function cat() works in a similar way if o is a receiver
object. In case o is both a provider and receiver, function
cat() evaluates to 1 if Co = Cs. As stated in constraint 7h,
the function cat() has to return 1 for all categories c ∈ C
for a ﬂow f between a subject s(f ) ∈ S and an object node
o(f ) ∈ O. Additionally, in constraint 7i, we deﬁne the secure
ﬂow property to prevent information ﬂow to lower classiﬁed
nodes. Thus, for each next node j on a link (i, j) of a ﬂow
f , indicated by the decision variable xf
ij, the security class
of the originating node of ﬂow f (i.e., the subject if the
object is a receiver, and the object otherwise) has to be less or
equal to the security class at the next node j on the path. We
deﬁne function orig(σo, σs) as shown in (10), where orig()
returns the security level depending on the type of object
node o, according to the deﬁned ﬂow control constraint in

6

orig(σo, σs) =

(cid:40)

if o is receiver

σs,
σo, otherwise

(10)

This last constraint ensures that on a path between a subject
s and an object node o, no forwarding nodes with a lower
security level compared to the security level of the originating
node of the ﬂow are visited. We then use the speciﬁed con-
straints 7b-7i as the basis for our heuristic-based maximization
algorithm discussed in the next section.

B. Policy Compliant Flow Maximization Algorithm

The linear programming model introduced in Section IV-A
is a binary integer programming model, a special case of
integer linear programming (ILP) since all variables are binary.
Integer linear programming models are NP-hard problems in
general, and the special case of binary integer programming
is one of Karp’s 21 NP-complete problems [24]. Although
solvers such as Gurobi [25] are efﬁcient in computing a so-
lution for such problems, binary integer programming models
can be impractical to solve for certain inputs.

To address this issue, we also formulate a heuristic algo-
rithm to compute a security compliant path between subjects
and objects based on a modiﬁcation of Djikstra’s shortest path
algorithm. Algorithm 1 is a modiﬁcation of Dijkstra’s shortest
path algorithm where we add the access control and secure
ﬂow control constraints, similar to the constraints presented
in (7). Speciﬁcally, we formulate the access control constraint
in line 7 based on the introduced functions lev() as deﬁned
in (8) and cat() as deﬁned in (9). To compute a secure path
between s and o we deﬁne the constraints in line 12 to only

consider an adjacent node j of a link if the security level of
node j is greater or equal the security level of the originating
node of ﬂow f and the link connecting node i and j has
enough residual capacity to accommodate ﬂow f . In effect,
the introduced model and algorithm will compute paths that
accommodate the maximum number of ﬂows f ∈ F between
a subject node s and an object node o, with consideration for
security and link capacity.

C. Policy Conﬂict Minimization Model

Finding a path fulﬁlling all security conditions might not
always be possible considering the nature of real-world net-
works. In contrast to the previous model, here we assume
that all ﬂows fulﬁlling the access control and link capacity
constraints must be accommodated in the network, which may
lead to policy conﬂicts. Policy conﬂicts are conditions where a
ﬂow is visiting a node on a path that has a lower security level
than the transferred information (i.e., than the sender node),
and we quantify a policy conﬂict as the numerical difference
between those security levels. Considering the lattice in Sec-
tion III-B, we assume that nodes classiﬁed as Conﬁdential
(2) have a higher risk of being compromised than nodes
classiﬁed as Secret (3). The goal here is to minimize policy
conﬂicts; therefore, if information classiﬁed as Top Secret (4)
is transferred on a path with policy conﬂicts, it is preferable
to select nodes with the smallest numerical difference (i.e.,
Secret (3) nodes are preferred over Conﬁdential (2) nodes).

Resolving policy conﬂicts requires additional security mea-
sures (e.g., declassiﬁcation). The larger a policy conﬂict (i.e.,
higher numerical difference in security levels), the more an
additional security measure will cost, in terms of transmission
time or computation overhead. By minimizing the numerical
distance of policy conﬂicts, we aim to minimize the cost
required to apply additional security measures to meet a
deﬁned security policy.

To achieve this, we compute a network conﬁguration in
a two-step process. We ﬁrst select a subset of the ﬂows
Fl ⊆ F that fulﬁll the access control constraints, and second,
compute paths between subjects and objects with the objective
to minimize security policy conﬂicts. We deﬁne the access
control constraints as follows:

(11)

∀λc

o, λc

s) = 1,

o ∈ Co, ∀λc

Fl ={f ∈ F : lev(σo, σs) = 1 and cat(λc
s ∈ Cs, o ∈ O, s ∈ S}
Next, for the set of legitimate ﬂows Fl, we also deﬁne an
objective function, conf, to ﬁnd a network conﬁguration that
accommodates all ﬂows in Fl while minimizing the policy
conﬂicts on a path of a ﬂow f ∈ Fl between a subject s
and an object o. The function returns the difference between
the security level of the ﬂow’s originating node, given by
orig(σo, σs), and the security level σj of a node j on the
path between s and o if σj < orig(σo, σs). More formally:

conf (σo, σs, σj) =

(cid:40)

orig(σo, σs) − σj,
0,

if σj < orig(σo, σs)
otherwise

(12)
We aim to minimize the policy conﬂicts caused by visited
nodes with lower security levels. Assuming a ﬂow originates

7

Fig. 3. Path selection based on security levels.

from a node o, we deﬁne the severity of the policy conﬂict by
the numerical distance from level σo of node o to a node j with
level σj, if σj < σo. Then, choosing a node j over a node h,
where (σo −σj) < (σo −σh), is preferable. And for selecting a
secure path, we want to give preference to these nodes with a
smaller difference in security level with the originating node,
even if such a path is signiﬁcantly longer than the shortest
path. To model this, we introduce a factor γ and deﬁne our
objective function as follows:

(cid:88)

(cid:88)

min

f ∈Fl

i,j∈E

xf
ij · γconf (σo(f ),σs(f ),σj )

(13)

In (13), xf
ij denotes the decision variable if link (i, j) is
selected as part of the path between s and o for a ﬂow f .
In the objective function as shown in (13), σo(f ) denotes the
security level of object node o of a ﬂow f , σs(f ) denotes the
security level of subject node s of a ﬂow f . The security level
of a node j on the path between s and o is deﬁned by σj. The
factor γ controls the length of a path that should be chosen as
a trade-off for visiting nodes with a smaller distance in terms
of security levels. We visualize this in an example shown in
Figure 3.

Considering this small network, two possible paths exist
between s and o. The numbers in the nodes indicate their
security level. If we select a factor γ = 4, the top path results
in a value of 44−2 = 16, while the bottom path has a smaller
policy conﬂict value of 3 · 44−3 = 12, and thus would be
selected. In contrast, if we select a smaller value for γ (e.g.,
γ = 2) then considering the top path, a transition from the
node with security level 4 to the node with security level 2
has to be made, resulting in a policy conﬂict value of 24−2 =
4. Computing the policy conﬂict value for the bottom path
would result in 3 · 24−3 = 6, since we have to visit three
nodes with a difference in the security level of 1. Based on
this, the top path would be selected, although from a security
perspective, the bottom path may be more preferable since
nodes with a smaller security level difference are visited. This
example shows that the factor γ controls the selection of longer
paths visiting nodes with a smaller security level difference. To
always select paths with the smallest security level difference,
γ can be set to the network diameter + 1, in terms of hop
count, which we prove as follows.

Lemma 1. To select a longer path with lower policy conﬂicts,
we must set γ to the maximum path length + 1.

Proof. Assuming a ﬂow originating from an object o, we
have to show that for a path of ﬂow f deﬁned by a set of
links (i, j) ∈ E indicated by the decision variable xf
ij, the
value of policy conﬂicts speciﬁed as (cid:80)
ij · γσo−σj and

i,j∈E xf

assuming that ∀j, σj < σo, is larger for a path with higher
policy conﬂicts than a potentially longer path with a lower
conﬂict value if γ is chosen appropriately. Given a candidate
node for the path of ﬂow f with a policy conﬂict of a, we
want to choose γ so that a potentially longer path y over a
set of nodes with a lower policy conﬂict of b is selected, i.e.,
γa > y · γb. Since a > b, we can express b as a − q, where q
is the numerical difference of the security levels of a and b,
i.e., q = a − b. By replacing b with a − q, we can write the
inequality above as γa · γq > y · γa. Assuming the smallest
absolute difference of two unequal security classes, i.e., q = 1,
the inequality above can be written as γ > y. Therefore, we
can say that in order to select a path that is y hops longer,
over a set of nodes with a lower policy conﬂict value, we have
to select a value for γ that is at least y + 1. This also holds
for larger security differences, since γq < γq+1 holds true for
positive values of q.

D. Policy Conﬂict Minimization Problem

To minimize the policy conﬂicts on a path, we formulate the
optimization problem as an integer linear programming (ILP)
model. We refer to this problem as the security policy conﬂict
minimization problem, as shown in (14).

To trigger a ﬂow at a node s, 14b adds 1 to the decision
variable xf
is. In our formulation to compute a path from s to
o, the ﬂow is consumed at node o as stated in constraint 14c.
In 14d, we state the ﬂow preservation constraint to ensure
that the sum of incoming ﬂows to a node equals the sum of
outgoing ﬂows. Constraint 14e ensures that the given capacity
κij of a link (i, j) ∈ E is not exceeded by forwarding ﬂows
f ∈ Fl with a size of df per ﬂow. In 14e, we assume that
the ﬂow size df is chosen to include trafﬁc between s and o
in both directions since we assume symmetric routes. Since
new ﬂow demands typically arrive at different times in a
network, we can replace the above link capacity κij with the
residual capacity (cid:101)κij which states the remaining capacity on
a link (i, j) ∈ E considering the existing ﬂows traversing link
(i, j). Accordingly, with the speciﬁed constraints 14b-14e, the
introduced model will compute a path for every ﬂow f ∈ Fl
between a subject node s(f ) and an object node o(f ) with the
objective function as deﬁned in 14a.

(cid:88)

(cid:88)

min

f ∈Fl

i,j∈E

xf
ij · γconf (σo(f ),σs(f ),σj )

(14a)

s.t.

(cid:88)

i:(i,s)∈E
(cid:88)

xf
is + 1 =

(cid:88)

xf
sj ,

j:(s,j)∈E

xf
oj − 1 = 0,

j:(o,j)∈E
(cid:88)
xf
ij =

(cid:88)

xf
jk,

i,j∈E
(cid:88)

j,k∈E
xf
ij · df ≤ κij ,

f ∈Fl
xf
ij ∈ {0, 1},

∀f ∈ Fl

(14b)

∀f ∈ Fl

(14c)

∀f ∈ Fl

(14d)

∀(i, j) ∈ E (14e)

∀(i, j) ∈ E, f ∈ Fl

E. Policy Conﬂict Minimization Algorithm

As discussed in Section IV-B, ILP models with binary
integer variables, such as (14), are typically NP-hard and can

Algorithm 2 MinConﬂictPath(G,s,o,df )

conf [v] = inﬁnity, prev[v] = null

1: V = nodes in G
2: for all v ∈ V do
3:
4: end for
5: conf [s] = 0, N = nodes in G
6: if lev(σo, σs) = 1 and cat(λc

o, λc

s) = 1, ∀λc

o ∈ Co, λc

s ∈

Cs then

while N not empty do

i = node in N with smallest conf []
remove i from N
for all adjacent node j of i do

if df ≤ (cid:101)κij then

confnew = conf [j] + γconf (σo,σs,σj )
if confnew ≤ conf [j] then

conf [j] = confnew
prev[j] = i

7:
8:
9:
10:

11:
12:
13:
14:
15:

end if

end if
end for
end while

16:
17:
18:
19:
20: end if
21: return prev

be impractical to solve for certain input sequences. To address
this, we also propose a heuristic algorithm to approximate an
optimal solution and replace the objective to ﬁnd the shortest
path with the objective to compute a path with the smallest
sum of policy conﬂict values (Algorithm 2, lines 12-13).

Since Algorithms 1 and 2 are based on Dijkstra’s shortest
path algorithm, we can express their time complexity as
O(|F | · (|E| + |V |log|V |)) for a number of |F | ﬂows.

F. Resolving Policy Conﬂicts

As we’ve shown in the previous section, paths with sufﬁ-
cient security levels and capacity may not always exist for two
nodes permitted to communicate. In such a case, additional
security mechanisms must be applied on the ﬂow in order to be
policy compliant. These mechanisms typically involve a cost
to implement (e.g., increased transmission delay, processing
time, or capacity), which the latter model aims to minimize.
An important mechanism for resolving policy conﬂicts is
declassiﬁcation, which is the process of lowering the security
level of the information. Sabelfeld et al. [26] discuss a general
framework for declassiﬁcation by deﬁning the dimensions of
information release, including: what information is released,
who releases the information, where information is released,
and when it
is released. By analyzing these dimensions,
a network operator is then able to evaluate the risks and
beneﬁts of declassiﬁcation to resolve certain security policy
conﬂicts. In our framework, declassiﬁcation can involve low-
ering a ﬂow’s security level so it can traverse a path with
lower classiﬁed nodes than the originating node. Methods
to achieve this include trafﬁc camouﬂaging techniques [27]
or VPNs to defend against trafﬁc analysis. Resolving policy
conﬂicts can also be achieved by the NSO relabeling certain

8

nodes in the network (e.g., increasing the security level of
forwarding nodes) after upgrading the security measures on
a switch and re-evaluating its security level. Our proposed
optimization model to minimize policy conﬂicts will point out
exactly which components of the network topology are causing
conﬂicts; therefore, relabeling of nodes can be a permanent
solution to policy conﬂicts which may reoccur.

V. SECURE FLOW RULE CONSTRUCTION

To realize a policy compliant network conﬁguration, in the
following we deﬁne a set of principles for the construction of
secure ﬂow rules which preserve conﬁdentiality.

A. Isolating Flows

Attacks that exploit

the composition of ﬂow rules are
effective because the matching criteria often only identiﬁes
packets by a limited set of header ﬁelds, as discussed by
Achleitner et al. [14]. If the ﬂow rules are only matching
packets against header ﬁelds of a certain network layer (e.g., IP
addresses), then the information in other layers will be seen as
”wild cards” and thus will be ignored. This problem motivates
the construction of SDN ﬂow rules with consideration of
information spanning all network layers.

The OpenFlow protocol [22] deﬁnes a set of matching ﬁelds
supporting different network layers. Multiple endpoints may
share lower layer ﬁelds such as physical ingress port; thus,
to differentiate them and identify their security levels, we
must include ﬁelds from higher network layers (e.g., IP or
Ethernet addresses). But security leaks caused by the exchange
of certain packet types in SDN-enabled networks [9], [11],
[14] motivate the use of categories in a security lattice to offer
ﬁner granularity of information exchange in SDN ﬂow rules.
Therefore, we derive these categories from additional packet
header ﬁelds (e.g., ARP , IP , T CP , U DP and ICM P ), and
use them in enforcing the security policy.

Additionally, with this general framework, a security cate-
gory can be deﬁned with even ﬁner granularity. For example,
by specifying ﬁeld subtypes: ICMP type 8 code 0, to allow
ping packets. Thus, the various header ﬁelds allow greater
ﬂexibility when deﬁning the security policy, and unlike tra-
ditional networks, the policy can be efﬁciently managed by
sending ﬂow mod messages to the forwarding nodes to update
their routing tables.

B. Constructing Secure Flow Rules

In SDN-enabled networks, we must consider the assigned
security labels during the construction of ﬂow rules at the
controller. As described previously, security leaks can arise
with imprecise matching criteria. Considering this, we must
construct precise ﬂow rules which ensure that only packets
fulﬁlling the deﬁned security level and category constraints can
be transmitted. More formally, for secure rule construction, we
represent the set of ﬁelds supported for network layer Ni ∈ N ,
where N is the set of all network layers, as RN i. Then, the
superset of ﬁelds to be matched against some packet P during

Algorithm 3 GenerateFlowRule(R,A,P ,next)

rule.append(r = P (r))

1: rule.append(”match : ”)
2: for all r ∈ R do
if r ∈ P then
3:
4:
end if
5:
6: end for
7: rule.append(”action : ”)
8: if next != drop then
9:
10:

for all a ∈ A do

rule.append(a)

end for
rule.append(”next”)

rule.append(”drop”)

11:
12:
13: else
14:
15: end if
16: return rule

secure rule construction can be realized by taking the union
of sets, which we denote as R:
(cid:91)

R =

RNi

(15)

Ni∈N :∀Ni≤NP

This formulation ensures that—after satisfying access control
constraints—a ﬂow is isolated and handled correctly according
to its security categories (i.e., packet ﬁelds).

Besides matching criteria, OpenFlow also deﬁnes action
sets, specifying what actions to apply on matched packets.
These include a required action part (e.g., forwarding or
dropping) and optional actions (e.g., rewriting packet header
ﬁelds). We denote the required action part as next, which
speciﬁes to either send a packet to a speciﬁc output port or to
drop it. Similarly, we specify the set of optional actions, such
as rewriting addresses, as the action set A.

Based on sets R and A for a packet P , we formulate Algo-
rithm 3. We begin rule construction by deﬁning the matching
part of a ﬂow rule in line 1. We continue to iterate through
the set of matching ﬁelds in R, as deﬁned in Equation 15, and
check in line 3 if a speciﬁed ﬁeld r can be applied to a value
in packet P . If this evaluates to true, we add the matching
ﬁeld r and its associated value P (r) to the ﬂow rule in line 4.
In line 7, we add the action part of a ﬂow rule and check in
line 8 if the action is to drop the packet. In case we specify
a rule to drop packets of a ﬂow with speciﬁc protocol types,
it must be ensured that the priority of that rule is higher than
other rules for the ﬂow which may allow forwarding for other
protocol types (i.e., allowing most IP trafﬁc, but disallowing
any UDP over IP).

To resolve any ﬂow rule conﬂicts between rule actions,
we refer to existing frameworks such as Porras et al. [12].
Nonetheless, if the packet is forwarded, then the set of action
ﬁelds and the output port are added to the rule, as shown in
lines 10 and 12. With this construction, we are able to properly
generate a secure ﬂow rule conﬁguration and isolate the ﬂows
to ensure that conﬁdentiality of information ﬂow is preserved
in the network.

9

VI. EVALUATION

With an MLS policy, adversarial capabilities (in terms of
probing, eavesdropping, and lateral movement) are by def-
inition restricted to only that allowed by policy. Here, we
still want to be able to route all legitimate ﬂows. In the
following, we demonstrate that (in comparison to not enforcing
a security policy) a network administrator can still provide
strong coverage of network ﬂows. The goal of our approach is
to achieve this, while also reducing the security cost associated
with guaranteeing all ﬂows be routed. In Table III, we report
on the performance of our framework to ﬁnd policy compliant
paths for ﬂows in various topologies and with lattices of
different sizes. In Table IV, we report MLSNet’s performance
when minimizing the policy conﬂicts, where accommodating
the remaining ﬂows may require routing along paths con-
taining nodes with a lower security-level than required. We
further show MLSNet’s ability to mitigate common attacks
(see Section II-B), such as those executed by the recently
proposed reconnaissance tool SDNMap [28], [14].

A. Accommodating Network Flows

To evaluate the ability of our framework to maximize the
number of policy compliant ﬂows and minimize policy con-
ﬂicts on paths, we test the introduced linear programming (LP)
models and heuristic algorithms (HA) on different network
topologies. We ﬁrst consider a realistic autonomous system
(AS) network topology. Then, to model common data-center
and cloud topologies, we consider different k-ary fat-tree
networks [29], where k is the port density of each switch in
the network (e.g., 8, 12, and 16 ports). We consider lattices of
2-4 security levels which are evenly distributed and randomly
assigned to the nodes in a network. To generate ﬂows, we
randomly pick source and destination node pairs which fulﬁll
the access control constraint and compute paths with our
linear program models and heuristic algorithms. Further, we
consider networks with different link capacities to simulate
congestion. Our results for ﬂow maximization and policy
conﬂict minimization (for the remaining ﬂows) are averaged
over several runs and shown in Tables III and IV.

We explore the number of ﬂows able to be routed in the
AS3257 Rocketfuel [30] topology (161 nodes, 656 links), as
well as 8-ary (208 nodes, 384 links), 12-ary (612 nodes, 1296
links), and 16-ary (1344 nodes, 3072 links) fat-tree networks.
For ﬂow maximization, shown in Table III, our framework
shows that a majority of ﬂows was always routed securely. For
any of the topologies, the number of ﬂows routed reached, at a
maximum, approximately 85% coverage. We also observe, for
any of the topologies, that the number of ﬂows routed securely
decreases as the number of security levels increases (from
left to right in any row). However, even at 4 security levels
(common in military networks), a majority of ﬂows was routed
securely in the noncongested network. Certainly, congestion
dynamics (here, randomly chosen), node labels (here, random),
and the different trafﬁc types vary with different networks and
will affect the number of ﬂows able to be routed, although
this situation can be remedied with conﬂict minimization.
Nonetheless, the results demonstrate that the framework is in

fact feasible in several network topologies of different sizes.
In the case of congested networks, we observe that the linear
programming models show slightly better performance in
terms of ﬂow assignment compared to the heuristic algorithms.
We note that despite the low ﬂow coverage (∼ 50%) because
new ﬂows could not be supported by the links at some speciﬁc
time, rules may still have a scheduled install at a delayed time
(i.e., when the links can support the new ﬂows), so permitted
ﬂows do not necessarily have to be discarded.

The key insight here is that the randomness used in generat-
ing the networks did not hinder the ﬂow coverage. Speciﬁcally,
in real data-center or cloud networks, edge switches may
carry similar trafﬁc [31] and thus have similar security levels
and only be limited by the available capacity (i.e., not the
security levels). These results show that even in the worst case
of random level assignment—where for example higher-level
nodes may be surrounded by lower-level ones and thus cannot
communicate without a policy conﬂict—paths (even if longer)
can be found for a majority of ﬂows.

Given that a majority of ﬂows can be routed according to
policy, we evaluate our model’s ability to route the remaining
ﬂows (in the noncongested case) to guarantee availability.
Table IV shows that all ﬂows can be routed with minimal
policy conﬂict along the allowed path. We deﬁne policy
conﬂicts as the scenario where a node is visited on a ﬂow path
that has a lower security level than the transferred information
(i.e., the originating node), and quantify it as the difference of
the security levels. Minimizing the conﬂicts also minimizes
the additional security measures needed to protect the ﬂows
traversing unsafe links (e.g., via stronger encryption).

For the AS network, paths with no conﬂict can be found
for the majority of ﬂows, while most of the remaining ﬂows
only impose a conﬂict of one security level difference. Less
than 5% of ﬂows must be routed through even less secure
paths in order to guarantee availability. The case is similar
for the fat-tree networks; the majority of ﬂow paths have no
conﬂict, approximately 20 − 30% of ﬂows can be routed with
minimal policy conﬂict of one level, while feasible paths for
the remaining ﬂows can also be found, ﬁtting as many ﬂows
along two-level difference paths, and so forth. The key insight
here is that most of the remaining ﬂows were able to be routed
with a conﬂict of one security level difference. Investigating
the reasons behind this is an interesting direction for future
work, where it may be possible to identify whether or not
this conﬂict occurs at hot (or commonly used) nodes, and
whether that information can be used to relabel nodes (and
perhaps repurpose them) or physically reconﬁgure the network
to reduce possible conﬂicts to a minimum, for any set of ﬂows.
We observe that the execution time of computing secure
paths is strongly correlated with the number of switches in
the network, scaling exponentially. We ﬁnd that both the LP
solver (Gurobi [25]) and the greedy algorithms can quickly
compute the paths for a few hundred ﬂows in a 8-ary tree on
average between 0.5s to 1s in a Python-based implementation.
When routing thousands of ﬂows for the same network, the
execution time can increase to between 7-8s, where the greedy
algorithm performs faster (approximately 3.5-4s) as the num-
ber of ﬂows increases further. However, large data-centers may

10

TABLE III
FLOW MAXIMIZATION BENCHMARK.

4 lev.

2 lev.

AS network
3 lev.

k=16
k=8
2 lev.
4 lev.
3 lev.
4 lev.
3 lev.
2 lev.
85% 75% 65.7% 79.5% 64.6% 58.3% 79.5% 66.6% 59%
81% 68.4% 64%
79.6% 71% 63.1% 63% 52% 50.6% 66.5% 57% 51.1% 68.5% 61.1% 53%
53.4% 45.2% 37.4% 45.5% 39.3% 34.3% 56% 46.5% 36.5% 56% 50.6% 36.5%
51.9% 41.8% 35.8% 44.5% 33.5% 31.9% 50% 38% 32.3% 52.3% 45.8% 34.5%

k=12
3 lev.

2 lev.

4 lev.

TABLE IV
POLICY CONFLICT MINIMIZATION BENCHMARK.

4 lev.

2 lev.

4 lev.

2 lev.

k=12
3 lev.

AS network
3 lev.

k=16
k=8
2 lev.
4 lev.
3 lev.
2 lev.
4 lev.
3 lev.
81% 68.4% 64%
85% 75% 65.7% 79.5% 64.6% 58.3% 79.5% 66.6% 59%
20.5% 26% 28.5% 19% 22% 20%
15% 21.5% 29.3% 20.5% 24.6% 24%
9.6% 11%
-
5%
-
-
79.6% 71% 63.1% 63% 52% 50.6% 66.5% 57% 51.1% 68.5% 61.1% 53%
20.4% 21.5% 24.6% 37% 25.7% 22.1% 33.5% 29% 27.5% 31.5% 23.2% 23%
15.7% 14%
-
10%
-
-

22.3% 22.6% -
4.7% -
-

7.5% 6.6% -
5.7% -
-

14% 14.7% -
6.7% -
-

10.8% 12.7% -
5%
-
-

3.5% 4.3% -
0.7% -
-

7.4% 10%
-

-
2.5% -

# Lattice Levels
LP (no congestion)
HA (no congestion)
LP (cong. network)
HA (cong. network)

# Lattice Levels
no conﬂict
LP
1 lev. diff.
2 lev. diff.
3 lev. diff.
HA no conﬂict
1 lev. diff.
2 lev. diff.
3 lev. diff.

be composed of tens of thousands of nodes [29], and even mid-
sized data-centers may contain several hundred or up to one-
thousand nodes. In the latter case (for example, represented
by a 16-ary fat-tree), solving the optimization can take nearly
45s. In enterprise-grade networks, the computation speed of
MLSNet can be further improved by applying buffering of
precomputed paths, implementation on hardware, or clustering
of ﬂows which is especially applicable in fat-tree networks.

Overall, the results show strong evidence for the ability of
our framework to accommodate ﬂows in real networks, while
preserving conﬁdentiality of information ﬂow.

B. Defending Against Attacks

We then implement the network scenario shown in Figure 4
with the SDN simulator Mininet [32], assigning security labels
to the nodes and conﬁguring the network to use our framework
MLSNet. Here, we use SDNMap [28] to demonstrate that our
framework can mitigate the attack techniques discussed in
Section II-B. SDNMap operates by iteratively probing net-
work nodes with crafted packets and eavesdropping on reply
messages from all endpoints in the network to reconstruct
ﬂow rules (identify active hosts and supported protocols). The
gathered information is then used to exploit ﬂow rules and
bypass security measures such as access-control lists.

Here, we use the security lattice from Figure 2 to conﬁg-
ure the network. Running the MLSNet system at the SDN
controller, we assign the security classiﬁcation of Public -
[ARP,IP,TCP] to the adversary node at 10.0.0.1 (who is using
SDNMap). We then let the adversary begin sending probes
into the network. The switch default action for an unknown
ﬂow is to send it to the controller for inspection and ﬂow rule
generation. On receipt of a new ﬂow, the controller will verify

the access control constraint of the communicating parties and
the ﬂow control constraint of nodes along a potential ﬂow path.
A secure ﬂow rule that obeys the security policy will then be
generated.

Mitigating lateral movement. MLSNet ensures that a node
with this classiﬁcation cannot receive packets from nodes
with a higher classiﬁcation (e.g., from the node at 10.0.0.4
labeled Secret - [ARP,ICMP,IP,TCP,UDP]). Therefore, all of
the probes destined from the attacker toward a node of higher
level should be blocked at the controller, and any induced
responses (e.g., from ARP) should also be blocked from
ﬂowing back toward the attacker, with no ﬂow rules being
generated. We observed exactly this behavior after scanning
the network’s IP space. The attacker sent out a series of probes
enumerating the packet ﬁelds (e.g., IP addresses and protocols)
to identify active hosts and supported protocols. However, all
of the probes sent toward nodes of higher classiﬁcation were
blocked by the controller for not satisfying the access control
constraint. Here, SDNMap reported that only the node with
IP address 10.0.0.5 replied (the other public host). Although
present
the remaining hosts, 10.0.0.4 and
10.0.0.6, are not discovered by the attacker.

in the network,

Further, any induced responses over different protocols such
as UDP or ICMP were blocked at
the controller for not
satisfying the ﬂow control constraint as well. Therefore, the
attacker could not obtain any other information about the other
hosts or protocols supported by them, and their capabilities
were only limited to scanning public nodes over the protocols
allowed by the deﬁned security label (here, ARP, IP, and TCP).
Indeed, future work may investigate optimal
labeling and
relabeling strategies that can respond to the current network
trafﬁc proﬁle in order to dynamically enforce least-privilege
and further reduce the threat surface.

Mitigating packet spooﬁng. With respect to packet spoof-

11

lateral movement, and eavesdropping, which have been well-
known problems since the 90s [38] and have become increas-
ingly important as more information is being put online [39].
In fact, recent work has already demonstrated the ability of
an adversary to freely probe within the network to recover
sensitive information [9], [10], [11], [12], [13],
including
active network hosts and even switch ﬂow table rules in
software-deﬁned networks [14].

Over time, there have been many defense methods pro-
posed against these techniques, including: source validation to
prevent or mitigate packet spooﬁng [19], [20], ﬁrewalling to
enforce access policies at network boundaries [3], encryption
to prevent unauthorized parties from intelligibly interpreting
sniffed data, among others. While each useful in a variety
of scenarios, they target speciﬁc attack techniques and only
partially address the problem of conﬁdentiality—ensuring
that only authorized entities have access to some data. This
motivates our work for developing a solution to combine
the beneﬁts offered by each of these methods. We exploit
multilevel security to accomplish this, providing guarantees
about who in the network may access what data.

Multilevel security allows a network administrator to specify
an hierarchical access control policy of a set of subjects on a
set of objects. With labels (i.e., a level and categories) given
to each subject and object, the policy is enforced through
access and ﬂow-control constraints. In fact, multilevel security
already plays a critical role in controlling access to information
for both military personnel and employees of commercial
businesses with different levels of clearance [5]. Common
use cases include controlling ﬁle access in an operating
system [6], object access in generic storage systems [40], table
access in a relational database [7], as well as a primitive for
securing information ﬂow between variables in programming
languages [41].

The notion of multilevel security can also be applied to
computer networks, where the MLS policy dictates which
nodes are allowed to communicate, what type of trafﬁc they
may exchange, and what paths the ﬂows may take in the
network. This property precisely address the concerns about
conﬁdentiality. We draw inspiration for our framework from
the seminal work by Lu et al. [8] and apply it to SDN-enabled
networks. In their work, they introduce a model for multilevel
security (MLS) in computer networks by deﬁning a Trusted
Network Base (TNB) that is similar to a Trusted Computing
Base (TCB) in single-computer systems. The proposed model
deﬁnes a set of entities (e.g., terminals or printers) and users
of the network and relies on the implementation of a security
policy by the network endpoints. This approach becomes
impractical when having to deploy it on every node in the
network, and we exploit the centralization of software-deﬁned
networking (SDN) [42] to provide this service transparently
to the entire network.

VIII. CONCLUSION

In this paper, we propose MLSNet, a framework which can
efﬁciently enforce an MLS policy by generating secure ﬂow-
rule conﬁgurations. Built upon access control and ﬂow control

Fig. 4. Network scenario with security labels.

ing, we observe that MLSNet can signiﬁcantly reduce the
threat surface. SDNMap reports that it is not able to spoof
IP addresses from hosts which can’t be discovered, since
our framework will prevent the deployment of a rule for an
unrecognized node, and therefore additional ﬂow rule features
cannot be reconstructed. By including information from all
network layers (as discussed in Section V) and deploying rules
that only allow ﬂows according to the given policy, we are able
to prevent attacks resulting from these forms of spooﬁng.

Although, we note again that MLS cannot detect all forms
of packet spooﬁng, and we rely on other SDN-based defenses
to detect packet spooﬁng of existing nodes or against the
topology discovery service [9]. Despite this, it can mitigate
the threat of data exﬁltration from packet spooﬁng with secure
routing paths. For example, consider a compromised node with
a lower security level (e.g., public) spooﬁng a node of higher
level (e.g., top-secret) to communicate with another top-secret
node, but through two other public nodes. The adversary would
have to compromise both public nodes in between in order for
them to actually forward the top-secret ﬂow—as it is against
security policy.

Mitigating eavesdropping. In addition to mitigating the
threat of lateral movement, MLSNet also prevents the attacker
from eavesdropping on communication between nodes of
higher-classiﬁcation. Since the controller prevents ﬂow rules
that direct higher-level trafﬁc toward public nodes from being
generated,
the attacker was unable to capture any trafﬁc
passing between the secret and conﬁdential nodes at 10.0.0.4
and 10.0.0.6. Further, any responses induced from the probes
were also blocked from generating a new ﬂow rule to direct
trafﬁc toward the attacker, preventing eavesdropping. As a
result, MLSNet
is able to signiﬁcantly limit the ability of
SDNMap to reconstruct ﬂow rules.

VII. RELATED WORK

Historically, networks have enforced security policies (i.e.,
information ﬂow) through ﬁrewall and routing conﬁguration.
However, these mechanisms are often very coarse and prone
to ambiguity, errors, and require coordination across many
devices [33], [34], [3]. Indeed, failures due to errors have
enabled a variety of attacks to be launched against real-world
networks, including device impersonation, man-in-the-middle,
and denial-of-service [35], [36], [37]. Typically these attacks
manifest from a small set of techniques: packet spooﬁng,

12

constraints, we develop models and heuristic algorithms to
compute policy compliant conﬁgurations according to two
goals: satisfying a strict ﬂow policy and a soft policy. For
the deployment of a policy compliant network conﬁguration,
we deﬁne principles for secure ﬂow rule construction. We
then demonstrate that our framework can deploy network
conﬁgurations able to withstand recently identiﬁed attacks on
SDNs. We hope this framework will serve as a base for further
investigation into defenses which protect the network with a
broader scope than speciﬁc attacks and efﬁcient mechanisms
for resolving policy conﬂicts in real-time.

REFERENCES

[1] J. Jang-Jaccard and S. Nepal, “A survey of emerging threats in cyber-
security,” Journal of Computer and System Sciences, vol. 80, no. 5, pp.
973–993, 2014.

[2] D. E. Denning, “A lattice model of secure information ﬂow,” Commu-

nications of the ACM, 1976.

[3] L. Yuan, H. Chen, J. Mai, C.-N. Chuah, Z. Su, and P. Mohapatra,
“Fireman: A toolkit for ﬁrewall modeling and analysis,” in 2006 IEEE
Symposium on Security and Privacy (S&P’06).
IEEE, 2006, pp. 15–pp.
[4] L. Spitzner, “Honeypots: Catching the insider threat,” in 19th Annual
IEEE,

Computer Security Applications Conference, 2003. Proceedings.
2003, pp. 170–179.

[5] O. S. Saydjari, “Multilevel security: reprise,” IEEE security & privacy,

vol. 2, no. 5, pp. 64–67, 2004.

[6] P. Loscocco, “Security-enhanced linux,” Linux 2.5 Kernel Summit, San

Jose (Ca) USA, 2001.

[7] X. Qian and T. F. Lunt, “A semantic framework of the multilevel
secure relational model,” IEEE Transactions on Knowledge and Data
Engineering, vol. 9, no. 2, pp. 292–301, 1997.

[8] W.-P. Lu and M. K. Sundareshan, “A model for multilevel security
in computer networks,” IEEE Transactions on Software Engineering,
vol. 16, no. 6, pp. 647–659, 1990.

[9] S. Hong, L. Xu, H. Wang, and G. Gu, “Poisoning network visibility in
software-deﬁned networks: New attacks and countermeasures.” in NDSS,
2015.

[10] C. Yoon, S. Lee, H. Kang, T. Park, S. Shin, V. Yegneswaran, P. Porras,
and G. Gu, “Flow wars: Systemizing the attack surface and defenses
in software-deﬁned networks,” IEEE/ACM Transactions on Networking
(TON), vol. 25, no. 6, pp. 3514–3530, 2017.

[11] M. Dhawan, R. Poddar, K. Mahajan, and V. Mann, “Sphinx: Detecting

security attacks in software-deﬁned networks.” in NDSS, 2015.

[12] P. Porras, S. Shin, V. Yegneswaran, M. Fong, M. Tyson, and G. Gu, “A
security enforcement kernel for openﬂow networks,” in HotSDN. ACM,
2012.

[13] H. Hu, W. Han, G.-J. Ahn, and Z. Zhao, “Flowguard: building robust
ﬁrewalls for software-deﬁned networks,” in HotSDN. ACM, 2014.
[14] S. Achleitner, T. La Porta, T. Jaeger, and P. McDaniel, “Adversarial
network forensics in software deﬁned networking,” in Proceedings of
the 2017 ACM Symposium on SDN Research.

[15] W. Dawoud, I. Takouna, and C. Meinel, “Infrastructure as a service
security: Challenges and solutions,” in 2010 the 7th International
Conference on Informatics and Systems (INFOS).
IEEE, 2010, pp.
1–8.

[16] C. Tankard, “Advanced persistent threats and how to monitor and deter

them,” Network security, vol. 2011, no. 8, pp. 16–19, 2011.

[17] M. Antikainen, T. Aura, and M. S¨arel¨a, “Spook in your network:
Attacking an sdn with a compromised openﬂow switch,” in Nordic
Conference on Secure IT Systems. Springer, 2014, pp. 229–244.
[18] S. Khan, A. Gani, A. W. A. Wahab, M. Guizani, and M. K. Khan,
“Topology discovery in software deﬁned networks: Threats,
taxon-
omy, and state-of-the-art,” IEEE Communications Surveys & Tutorials,
vol. 19, no. 1, pp. 303–324, 2017.

[19] D. Senie and P. Ferguson, “Network ingress ﬁltering: Defeating denial
of service attacks which employ ip source address spooﬁng,” Network,
1998.

[20] L. Savu, “Cloud computing: Deployment models, delivery models, risks
and research challenges,” in 2011 International Conference on Computer
and Management (CAMAN).

IEEE, 2011, pp. 1–4.

[21] S. Feghhi and D. J. Leith, “A web trafﬁc analysis attack using only
timing information,” IEEE Transactions on Information Forensics and
Security, vol. 11, no. 8, pp. 1747–1759, 2016.

[22] “Openﬂow,” https://www.opennetworking.org/sdn-resources/openﬂow.
[23] D. E. Bell and L. J. LaPadula, “Secure computer system: Uniﬁed
exposition and Multics interpretation,” Tech. Rep. ESD-TR-75-306,
1976.

[24] R. M. Karp, “Reducibility among combinatorial problems,” in Complex-

ity of computer computations. Springer, 1972.

[25] “Gurobi,” http://gurobi.com.
[26] A. Sabelfeld and D. Sands, “Declassiﬁcation: Dimensions and princi-

ples,” Journal of Computer Security, 2009.

[27] X. Cai, R. Nithyanand, and R. Johnson, “Cs-buﬂo: A congestion
sensitive website ﬁngerprinting defense,” in Proceedings of the 13th
Workshop on Privacy in the Electronic Society. ACM, 2014.

[28] “Sdnmap open source tool,” https://github.com/SDNMap.

13

[29] M. Al-Fares, A. Loukissas, and A. Vahdat, “A scalable, commodity data
center network architecture,” in ACM SIGCOMM Computer Communi-
cation Review, vol. 38, no. 4. ACM, 2008, pp. 63–74.

[30] N. Spring, R. Mahajan, and D. Wetherall, “Measuring isp topologies
with rocketfuel,” ACM SIGCOMM Computer Communication Review,
2002.

[31] T. Benson, A. Akella, and D. A. Maltz, “Network trafﬁc characteristics
of data centers in the wild,” in Proceedings of the 10th ACM SIGCOMM
conference on Internet measurement. ACM, 2010, pp. 267–280.
[32] “Mininet - realistic virtual sdn network emulator,” http://mininet.org/,

accessed: 2017-11-06.

[33] L. Bauer, S. Garriss, and M. K. Reiter, “Detecting and resolving
systems,” ACM Trans.
[Online]. Available:

policy misconﬁgurations
Inf. Syst. Secur., vol. 14, no. 1, Jun. 2011.
https://doi.org/10.1145/1952982.1952984

in access-control

[34] A. Wool, “A quantitative study of ﬁrewall conﬁguration errors,” Com-

puter, vol. 37, no. 6, pp. 62–67, 2004.

[35] M. Conti, N. Dragoni, and V. Lesyk, “A survey of man in the middle
attacks,” IEEE Communications Surveys & Tutorials, vol. 18, no. 3, pp.
2027–2051, 2016.

[36] R. Sommer and V. Paxson, “Outside the closed world: On using machine
learning for network intrusion detection,” in 2010 IEEE symposium on
security and privacy.
IEEE, 2010, pp. 305–316.

[37] O. Osanaiye, K.-K. R. Choo, and M. Dlodlo, “Distributed denial of
service (ddos) resilience in cloud: Review and conceptual cloud ddos
mitigation framework,” Journal of Network and Computer Applications,
vol. 67, pp. 147–165, 2016.

[38] B. Harris and R. Hunt, “Tcp/ip security threats and attack methods,”
Computer communications, vol. 22, no. 10, pp. 885–897, 1999.
[39] F. B. Shaikh and S. Haider, “Security threats in cloud computing,”
in 2011 International conference for Internet technology and secured
transactions.

IEEE, 2011, pp. 214–219.

[40] V. Varadharajan and S. Black, “A multilevel security model for a
distributed object-oriented system,” in [1990] Proceedings of the Sixth
Annual Computer Security Applications Conference.
IEEE, 1990, pp.
68–78.

[41] D. Volpano and G. Smith, “A type-based approach to program security,”
in Colloquium on Trees in Algebra and Programming. Springer, 1997,
pp. 607–621.

[42] M.-K. Shin, K.-H. Nam, and H.-J. Kim, “Software-deﬁned networking
(sdn): A reference architecture and open apis,” in 2012 International
Conference on ICT Convergence (ICTC).

IEEE, 2012, pp. 360–361.

14

