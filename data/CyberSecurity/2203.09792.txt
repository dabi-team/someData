AdIoTack: Quantifying and Reﬁning Resilience of
Decision Tree Ensemble Inference Models against
Adversarial Volumetric Attacks on IoT Networks

2
2
0
2

r
a

M
8
1

]

G
L
.
s
c
[

1
v
2
9
7
9
0
.
3
0
2
2
:
v
i
X
r
a

Arman Pashamokhtari, Gustavo Batista, and Hassan Habibi Gharakheili
UNSW Sydney, Australia
Emails: {a.pashamokhtari,g.batista,h.habibi}@unsw.edu.au

Abstract—Machine Learning-based techniques have shown
success in cyber intelligence. However, they are increasingly
becoming targets of sophisticated data-driven adversarial attacks
resulting in misprediction, eroding their ability to detect threats
on network devices. In this paper, we present AdIoTack1, a
system that highlights vulnerabilities of decision trees against
adversarial attacks, helping cybersecurity teams quantify and
reﬁne the resilience of their trained models for monitoring and
protecting Internet-of-Things (IoT) networks. In order to assess
the model for the worst-case scenario, AdIoTack performs white-
box adversarial learning to launch successful volumetric attacks
that decision tree ensemble network behavioral models cannot
ﬂag. Our ﬁrst contribution is to develop a white-box algorithm
that takes a trained decision tree ensemble model and the proﬁle
of an intended network-based attack (e.g., TCP/UDP reﬂection)
on a victim class as inputs. It then automatically generates recipes
that specify certain packets on top of the indented attack packets
(less than 15% overhead) that together can bypass the inference
model unnoticed. We ensure that the generated attack instances
are feasible for launching on Internet Protocol (IP) networks
and effective in their volumetric impact. Our second contribution
develops a method to monitor the network behavior of connected
devices actively, inject adversarial trafﬁc (when feasible) on behalf
of a victim IoT device, and successfully launch the intended
attack. Our third contribution prototypes AdIoTack and validates
its efﬁcacy on a testbed consisting of a handful of real IoT
devices monitored by a trained inference model. We demonstrate
how the model detects all non-adversarial volumetric attacks on
IoT devices while missing many adversarial ones. The fourth
contribution develops systematic methods for applying patches to
trained decision tree ensemble models, improving their resilience
against adversarial volumetric attacks. We demonstrate how our
reﬁned model detects 92% of adversarial volumetric attacks.

I.

INTRODUCTION

IoT adoption is on the rise in both consumer and business
mainstreams. Still, more than half of the connected IoT devices
are found vulnerable [36] to a wide range of sophisticated
cyber threats like botnets, malware, phishing, or DDoS attacks.
According to a report recently published by Nokia [34], IoTs
saw a 100% increase in infections in 2020 over the previous
year. These vulnerabilities at scale can lead to signiﬁcant
disruption of critical enterprise operations [35], [48], [11] or
exﬁltration of sensitive data [29]. The lack of a real-time and
detailed inventory of connected IoT assets, deployed in large
numbers, leads enterprises to operate their network partially
blind [41], [19]. This leaves vulnerable devices unmonitored
and hence exposes their organization to grave risks [2].

1Funding for this project was provided by CyAmast Pty Ltd.

While manufacturers are assumed (expected) to embed
appropriate safeguards in the devices for securing them, many
IoT devices have shown [36], [34] to be unprotected and can be
compromised with little effort from attackers. This paper ad-
vocates “network-level” security measures, instead of “device-
level” [44]. We note that embedded security implementation
can be highly variable across various IoT devices depending
on manufacturers, device capabilities, and mode of operation.
Therefore, the network-level monitoring approach comes with
a number of advantages including: (a) it can be applied to a
range of heterogeneous IoT devices; (b) it can be implemented,
operated, and upgraded in the cloud by network operators with
no dependency to device manufacturers; and (c) it can augment
any device-level security implemented by the manufacturer,
providing an extra layer of protection.

Given the speed and complexity of modern cyber threats,
network security teams are increasingly applying machine
learning (ML) techniques to network trafﬁc (packets and/or
ﬂows) of IoT devices to model their network behavior [12].
ML-based models [40] are used on the network (running on
general computers fed by trafﬁc features) to automatically clas-
sify assets from identiﬁable patterns in their network activity
and detect anomalous behaviors [18], [19], [42], indicative
of compromise, ﬁrmware upgrade, or emerging novel attacks.
Learning-based methods offer the ability to respond to situ-
ations not explicitly encountered before, replacing processes
that would have required formidable manual analysis by human
experts.

In the context of IoT cybersecurity, well-trained ML mod-
els have proven to effectively capture the intended behavior
of IoT devices on a per-type basis. These models can ﬂag
deviations in the volume and/or frequency of network activity
without being impacted by limited patterns of certain known
attacks [33], [42], [18]. This approach is successful primarily
because IoT devices display a ﬁnite set of activities (with
reasonably identiﬁable patterns) on the network during their
regular operation. These behavioral characteristics present an
opportunity to train models with purely benign instances
obtained from IoT network trafﬁc. The trained models would
have the ability to distinguish clearly the “bounded” set
of benign behavior from an “unbounded” set of malicious
(anomalous/unintended) behavior resulted from of a network-
based cyber attack. This gives a signiﬁcant advantage to ML-
based methods against traditional signature-based ones to infer
from IoT network trafﬁc.

 
 
 
 
 
 
Traditionally, the “security of ML-based models” has not
been the main objective for designing algorithms and de-
veloping inference systems in various domains, especially in
cybersecurity. Therefore, potential adversaries with certain in-
centives aim to subvert the ML model either during training or
operation which is known as adversarial attack. Attackers may
poison the training instances to inﬂuence the resulted model.
They may attempt to carefully manipulate network trafﬁc at
run-time to ﬂip predictions, yielding a poor performance of
the inference model in distinguishing the malicious instances.

Several countermeasures have been proposed, under the
umbrella of Adversarial Machine Learning (AML), with practi-
cal successes in the area of machine vision and image recogni-
tion [47], [46], [13]. However, in the context of cybersecurity,
it is in its nascent stage of development to the best of our
knowledge. A recent report by McAfee [26] highlights a few
malware families that have bypassed machine learning engines
in 2018. It predicts how cyber-criminals will be increasingly
employing artiﬁcial intelligence techniques to evade detection.

The primary objective of adversarial cyber-attackers is to
ﬁnd loopholes in ML-based network security models like
trafﬁc classiﬁers, anomaly detectors, or intrusion detection
systems. To fortify inference models against these targeted
attacks, cyber-security teams need to quantify the resilience
of their trained model and reﬁne any loopholes. This paper
focuses on developing techniques for launching volumetric
attacks (known as adversarial evasion attack) on IoT devices
without being noticed by a decision tree ensemble inference
that continuously monitors the network trafﬁc. To
model
make these ideas more concrete, let us consider a scenario
whereby an attacker aims to launch a TCP SYN reﬂection
attack (common in large-scale DDoS attacks sourced from IoT
devices [25]) with 1000 attack packets.

The attacker sends 1000 TCP SYN packets with spoofed
source IP address to a target IoT device which replies (reﬂects)
them to the victim destination (the source entity speciﬁed in the
SYN packets) with 1000 TCP SYN-ACK packets. IoT devices
typically generate a small amount of trafﬁc volume on their
limited set of TCP/UDP ﬂows; thus, reﬂection attacks with
high rates can be detected by inference models relatively easily.
That said, attackers with sufﬁcient prior knowledge would
have the ability to launch their intended attack (without being
detected) by precisely generating and injecting some adver-
sarial network trafﬁc (say, 50 NTP packets along with 5 DNS
packets and an SSDP packet) in addition to the intended attack
packets (1000 TCP SYN packets). To humans, this additional
trafﬁc seems to be irrelevant and random; however, this well-
crafted “recipe” subverts the model’s internal decision-making,
leading it to accept this network trafﬁc instance as benign.
Finding these attack recipes would depend on the inference
model’s trafﬁc features and detection algorithm, which requires
a well-developed adversarial learning algorithm to generate
them precisely. It is important to note that this paper uses the
term “attack” in two different contexts. First is the network-
based volumetric attack (e.g., TCP SYN reﬂection) on IoT
devices, whereby target IoT devices reﬂect the incoming attack
trafﬁc towards an external victim. Second is the adversarial
machine learning attack which is a technique that utilizes
prior knowledge to subvert the ML-based inference model, and
hence the volumetric attacks can go undetected.

In the literature, researchers have studied adversarial at-
tacks on IoT networks [16], [45], [20], [39], [6]. Prior works
primarily focus on developing adversarial models that can learn
how to bypass neural network-based attack detection models.
In contrast, the literature has not devoted much attention to
decision tree-based models. Unlike neural networks, decision
thus, well-known
tree-based models are not differentiable;
approaches like [17], [37], [10] are not compatible with their
structure. Additionally, given the dynamics of network trafﬁc
and some constraints on Internet Protocol (IP) packets, adver-
sarial attacks in the context of network security (unlike image
processing) become relatively more challenging. Another gap
in the current literature is that adversarial attacks, to the best
of our knowledge, have never been executed in a real network
protected by an ML-based inference model. Lastly, no prior
systematic attempt has been made to improve the resilience
of decision trees against these sophisticated attacks without
manipulating the training process which requires re-training
the model.

This paper presents AdIoTack, a systematic approach for
learning and launching adversarial attacks on IoT networks
protected by decision tree ensemble models. We make four
main contributions: (1) We develop a novel adversarial learning
algorithm named ofﬂine learning that automatically gener-
ates adversarial attack “recipes” given an intended volumet-
ric attack on a target class, subverting a trained decision
tree ensemble model (§III). We consider two representative
network-based volumetric attacks, namely TCP SYN and
SSDP reﬂection, which are widely used on IoT devices for
launching DoS/DDoS attacks [21], [25], [28], [32]. Adversarial
recipes specify certain overhead packets (2% for TCP SYN
reﬂection and 14% for SSDP reﬂection) to be injected for an
intended volumetric attack to go unnoticed; (2) We develop an
online execution method that launches the adversarial instances
(learned from ofﬂine learning) on a real IoT device network
monitored by a decision tree ensemble inference model (§IV);
(3) We demonstrate the performance of AdIoTack by applying
it to our testbed comprising of nine consumer IoT devices. We
show our online attack execution has at least a 95% chance of
successfully launching an adversarial attack when the attacker
has the prior knowledge of the inference model cycles (§V);
and, (4) We develop a method for patching decision trees
(without a need for re-training), making them more robust
against adversarial volumetric attacks while maintaining the
inference accuracy for benign trafﬁc (§VI). Our reﬁned model
can detect all adversarial SSDP reﬂection attacks with low
(less than 200 attack packets per minute), medium (between
200 and 700 attack packets per minute), and high (greater than
700 attack packets per minute) impact rates. For adversarial
SYN reﬂection attacks, the reﬁned model detects 63% of low,
75% of medium, and 100% of high impact attacks.

II. RELATED WORK

Cyber Intelligence for IoT Infrastructure: The cyber-
security of IoT networks differs from that of non-IoT or
traditional IT networks where general-purpose computers,
smartphones, or tablets display an unbounded range of network
behaviors reﬂecting their users’ online activity. IoT devices,
in contrast, have a limited range of activities (with slight
variations but predictable) in the trafﬁc pattern. While mod-
eling benign behavior of non-IoTs is complicated (or even

2

impossible), IoT devices’ intended activity can be formally
deﬁned and enforced on the network. A “whitelist” of IoT
behaviors, speciﬁed in the form of MUD (Manufacturer Usage
Description) proﬁles, has been employed to detect anomalies
[19]. Researchers have employed various ML techniques to
learn from the benign behavior of IoT devices to monitor their
health and detect malicious incidents [33], [42], [18], [38].
The use of pure benign instances from IoT network trafﬁc
in training inference models, without the inclusion of known
attack (malicious) instances, enables them to become more
robust against unseen and morphing cyber-attacks.

Adversarial Attacks: Adversarial attacks were ﬁrst studied
in the context of image recognition, where the objective
is to create an adversarial copy of a benign image that is
indistinguishable to human eyes. However, the image classiﬁer
mispredicts the adversarial copy. Adversarial learning in cy-
bersecurity differs from that in the image recognition domain
in (1) in image recognition, the similarity of the adversarial
instance and the benign instance, expected to look identical
to human eyes,
is the primary constraint of the problem.
However, this constraint is relaxed in cybersecurity and trafﬁc
inference problems; (2) there is no requirement for the impact
or intensity of intended attacks in image recognition problems,
i.e., any adversarial instances (with any level of deviations from
the benign instance) are accepted as long as they subvert the
model; (3) Practicality of adversarial attacks (i.e., executing
them in a real environment) is of concerns in cybersecurity
since every adversarial instance (a set of numerical values)
may not be necessarily realized as network packets.

Adversarial attack on differentiable models like neural net-
works has been widely studied both in image recognition and
cybersecurity research problems, while non-differential mod-
els like decision tree-based models remain relatively under-
learning techniques (computing
explored. Also, adversarial
gradients of the model’s loss function) for differentiable mod-
els cannot be readily applied to non-differentiable models.
Work in [14] developed a method that replaces last few layers
of a neural network model with a Random Forest, hide the
gradients of the neural network and perhaps protecting it
against adversarial attacks.

These prior works have studied evasion attacks on decision
tree-based models [8], [22], [49]. Authors in [8] has shown
vulnerability of Gradient Boosting and Random Forest models
against adversarial evasion attacks using methods of [9], [22].
They also developed a robustness technique to avoid adver-
sarial attacks by bringing adversarial instances to the training
phase to change the ensemble model with this purpose that the
model still has high accuracy for attack inputs. Work in [22]
developed a mixed-integer linear programming (MIPS) tech-
nique for solving the adversarial attack optimization problem
on tree ensembles. All existing works, applied their methods
on public dataset like MNIST [27]; in contrast, to the best of
our knowledge, our paper is the ﬁrst in developing techniques
for adversarial attacks against tree ensembles in the context of
IoT cybersecurity.

Adversarial Attack Approaches in IoT: Existing works in
IoT cybersecurity primarily adopt techniques from the image
recognition domain with little adaptation and contextualization.
Hence, some of the fundamental challenges and differences
(discussed above) remain unaddressed. Authors of [6] employ

reinforcement learning (RL) to generate adversarial instances
against
their multi-class inference model (four classes of
cyberattacks plus a class of benign trafﬁc). In that work, the ad-
versary iteratively adds random noises to samples of an attack
dataset and presents them to the inference model until they get
classiﬁed as benign. However, randomly generated numerical
instances do not necessarily represent realistic cyberattacks.
Authors of [1] studied the impact of adversarial attacks on
models that detect malware-infected IoT applications. Their
neural network-based model infers from graph-like features
of the binary ﬁle of applications. Work in [16] trained a set
of binary-class (malicious versus benign) inference models,
each per unit of IoT devices. The authors used GAN (Genera-
tive Adversarial Networks), a well-known adversarial learning
technique for neural networks (initially designed for image
classiﬁcation context). The primary objective is to improve
the resilience of their model during training by including
adversarial instances in the training set. Another work [20]
focused on neural networks for detecting network-based at-
tacks. Their detection is done by a multi-class inference model
(with four classes of cyberattacks and one class of benign
trafﬁc). Their objective was to manipulate numerical instances
of either attack or benign for which the model makes incorrect
predictions. The authors directly borrowed techniques from
image recognition and did not demonstrate the feasibility of
subverting the model on real network. Importantly, they do not
attempt to reﬁne the vulnerable inference model.

Our work distinguishes from the prior adversarial attack
studies on decision tree-based models by (a) inter-dependency
among many features in this paper versus tweaking only
one feature in prior works; (2) considering the impact of
the volumetric network attacks and their feasibility on real
networks; (3) existing works did not explore the sequence order
of decision trees to ﬁnd adversarial instances. We, instead,
analyze how the order our approach processes the decision
trees in a forest model can affect the richness of adversarial
instances; (4) our robustness technique is done post-training
which does not require re-training the model and is not a
function of a set of known adversarial instances.

Prior works in IoT cybersecurity were directly adopted
from those in image recognition with their primary focus on
neural network models. In this paper, we demonstrate our
method of generating and launching adversarial attacks on a
live network of IoT devices. To the best of our knowledge,
no prior work has focused on decision tree-based models in
this context while considering the practical challenges; and
this is the ﬁrst time that an adversarial attack is executed on
a real network of IoT devices. Also, our patching techniques
systematically reﬁne trained decision trees to detect adversarial
volumetric attacks on data networks whereas previous works
[8], [5] targeted other application domains like image recog-
nition.

III. ADIOTACK: SYSTEM ARCHITECTURE AND
ADVERSARIAL LEARNING

This section describes our AdIoTack system,

including
major functional decisions and system components (§III-A),
ofﬂine learning (§III-B),
the core algorithms (§III-C) and
consistency veriﬁcation (§III-D).

3

(cid:0)

(cid:0)

(details discussed in §III-B). For AdIoTack (shown by shaded
region), there are two essential phases, namely: (a) learning
and (b) execution (launching).

In the learning phase (steps

(cid:3)
(cid:3)
(cid:0)
(cid:1)2 in Fig. 1), the ofﬂine
(cid:1)1 and
(cid:2)
(cid:2)
learning module uses the inference model (note the white-
box scenario) to learn blind spots of the model to generate
(cid:3)
adversarial recipes (step
(cid:1)3 ). Each adversarial recipe consists
(cid:2)
of a number of conditions over features of the inference model
(e.g., 10 < f1, f2 ≤ 50, and 20 < f3 < 40); thus, each recipe
can generate several adversarial instances that conform to the
recipe’s conditions. For example, an adversarial instance for
the mentioned recipe could be f1 = 15, f2 = 30, and f3 = 25.
(cid:3)
For execution, network telemetry (step
(cid:1)4 ) similar to inputs of
(cid:2)
the inference model must be collected, so that an “appropriate”
adversarial recipe can be selected based on the current state
of the network. To obtain real-time telemetry and execute the
intended adversarial attack, network trafﬁc of IoT devices is
snooped. As a part of our threat model, we assume a “malicious
agent” like an infected smartphone or a computer is already
inside the local network (the red box inside the IoT network
on the top left) for this purpose.

(cid:0)

To obtain network telemetry in real-time, the malicious
agent can passively (e.g., snifﬁng) or actively (e.g., man-in-
the-middle via ARP poisoning) monitor the behavior of victim
IoT devices. The passive approach is stealthier to perform but
could be practically challenging in some cases, like when the
malicious agent and its victims are on different physical access
mediums (wireless versus wired). For AdIoTack, we employ
the active mode for adversarial network monitoring. Also, our
method only analyzes packet metadata (headers), so it has no
issue with encrypted payloads.

In the next step, the online engine starts a search for feasi-
ble adversarial recipes, given the current state of the network.
From those candidate recipes, the online engine selects the
closest one to the current state of the network to minimize
the amount of adversarial packets (overhead) to be injected
(in real-time to the network trafﬁc) on behalf of the victim.
Eventually, the intended volumetric attack is launched (step
(cid:3)
(cid:1)5 ) by judiciously crafting network trafﬁc matching the chosen
(cid:2)
recipe. Note that the local victim will reﬂect/amplify the attack
trafﬁc onto an ultimate victim on the Internet. It is important to
note that the adversarial packets (overhead trafﬁc) are injected
on behalf of local victims for their reﬂected/ampliﬁed trafﬁc
to go undetected.

(cid:0)

B. Ofﬂine Adversarial Learning

Ofﬂine adversarial

learning is a process of generating
adversarial recipes which: (a) result
in desired malicious
impact, and (b) can go undetected i.e., the trafﬁc inference
model raises no anomaly ﬂag. The results of ofﬂine adversarial
learning show to what extent the given model is vulnerable to
adversarial volumetric attacks.

We employ ML models’ classiﬁcation score as a measure
for detecting behavioral changes. We deﬁne a classiﬁcation
score threshold for each class (device type) according to the
training results. At run-time, any instance with a classiﬁcation
score below the given threshold is ﬂagged as an anomaly. We
can deﬁne the adversarial learning problem formally as below:

4

Fig. 1. System architecture of AdIoTack.

A. Threat Model: Functional Decisions and
System Components

The main objective of AdIoTack is to help cyber-security
teams quantify the resilience of their decision tree-based mod-
els against adversarial volumetric attacks that target integrity
of the inference models. Given a well-trained trafﬁc inference
model that is able to detect “non-adversarial” attacks relatively
easily, AdIoTack generates adversarial instances that the model
mispredicts as benign. Note that ML models may be tested for
other aspects like their availability, i.e., whether they remain
operational while being ﬂooded by malicious requests [3],
which is beyond the scope of this paper. In terms of inﬂuence,
adversarial attacks may be either causative or exploratory
[3]. In causative attacks, training data instances are poisoned
in order to manipulate the inference logic. In exploratory
attacks which happens post-training, well-crafted malicious
trafﬁc instances that resemble benign instances are used to
bypass the model while launching an attack. Our focus in
AdIoTack is on exploratory attacks.

One can quantify the resilience of an ML model in three
different scenarios: (a) White-box is the worst-case scenario
when the knowledge of the model’s structure, algorithm, and
features is used to evaluate the model against adversarial
attacks – testing and improving the model’s performance
by a white-box approach would result in the best resilience
[7]; (b) Grey-box, when the model is evaluated with limited
knowledge of the model (say, partial access to the training
data); (c) Black-box, when the model is attacked without any
prior knowledge, and it can only be probed e.g., through API
calls. This paper aims to help cyber-security teams evaluate
and reﬁne their decision tree-based models (self-assessment).
Therefore, we develop AdIoTack in a white-box setup to
maximise effectiveness in a worst-case scenario.

Fig. 1 shows the architecture of our AdIoTack system. On
the top left, we see a network of IoT devices (green boxes)
whose trafﬁc is monitored periodically (e.g., every one minute)
by a decision tree ensemble model (i.e., trees T1 to Tn). The
network router extracts the required telemetry (e.g., packet/byte
count of different trafﬁc ﬂows) from the network trafﬁc of
each IoT device and passes it to the ML inference model
(bottom left). The model continuously infers the most probable
class of the connected devices from the received telemetry. We
use the classiﬁcation score of the ML model to compute a
device-speciﬁc threshold to distinguish benign behavior from
malicious. That way, if the model yields a score below the
is an indication for malicious behavior
given threshold,

it

IoT networkDev#ADev#BDev#CnetworktelemetryML inference modeloffline learningreal-time network telemetryattack commandonlinelaunching engineadversarialrecipes13254AdIoTackT1T2T3…Tnwithout the need for data normalization or scaling prior to
training; (iii) Random Forest algorithm is reasonably resilient
to the overﬁtting problem [4]; (iv) Decision tree-based models
often yield good results in terms of accuracy and explainability
which means their internal decision-making process is visible
during testing, which is highly desirable for cyber-analysts
(particularly for IoT network security [30], [15], [31], [40],
[43]) in taking remedial and/or preventive actions. In contrast,
competitors like neural networks do not provide insights
into their internal process of inference; (v) Random Forest
classiﬁers are more robust than k-nearest-neighbors (k-NN),
decision trees, and AdaBoost [23] against adversarial evasion
attacks, hence, become more difﬁcult to evade.

C. The AdIoTack Algorithms

AdIoTack focuses on performing adversarial attacks on a
given decision tree ensemble model. The model consists of
several decision trees. Weighted or unweighted voting gives
the ﬁnal classiﬁcation, i.e., the fraction of trees yielding the
ﬁnal output determines the prediction and classiﬁcation score.

In order to explain how voting works, let us consider an
example relevant to our device class inference problem. Let
say, if a benign trafﬁc instance x belongs to IoT device class
“A” (ground-truth), and say 95% of the trees in the ensemble
model classify it correctly, the ﬁnal prediction would be “A”
with the score of 0.95. Now, assume “A” is under a cyberattack,
having a trafﬁc instance ˆx. The model is expected to give a
lower score [40] for ˆx since because of the deviation from
benign instance x there will be disagreement among various
trees, each inferring from a speciﬁc set of features. Certain
features of ˆx will signiﬁcantly deviate from their expected
normal range, leading a portion of trees to classify ˆx as a
class other than “A”, and other features may remain relatively
unchanged hence some other trees predict the class of ˆx as
“A”. Therefore, the attack can be ﬂagged with a good chance.
In adversarial attack, we aim to ﬁnd a recipe which has the
same malicious impact of ˆx in such a way that the majority
of decision trees predict it as “A”, resulting in high score and
implying it is still benign.

In the context of decision trees, we deﬁne an adversarial
path to be the path from the root node of a given decision
tree to a leaf with the label of the victim device that we aim
to launch an attack on it. Each adversarial path is associated
with a set of conditions that are met across the path nodes.
Fig. 3-left shows how the adversarial path is found on an
illustrative decision tree. Grey circles are decision nodes, each
checking a certain condition (e.g., f1 ≤ τ1), proceeding to
subsequent branch (left or right, depending on the check
result). Adversarial path x∗ is a complete path from the root to
a leaf node, landing on the target victim class “A”. AdIoTack
performs tree traversals using the pre-order method – the root
node is ﬁrst visited, then recursively a pre-order traversal of
the left subtree is performed, followed by a recursive pre-order
traversal of the right subtree.

Note that searching the adversarial path needs to be ex-
tended to all decision trees inside the ensemble model where
consistency of conditions across trees becomes a non-trivial
challenge. Fig. 3 shows an illustrative example of searching for
an adversarial path across two decision trees while conditions
(of paths in the two trees) need to be consistent. Assume

Fig. 2.

Inputs and outputs of our adversarial learning process.

∀d ∈ D, {x | pred(x) = d and score(x) ≥ Td}
s.t. ∀f ∈ F, xf ≥ fmin

This equation deﬁnes a set of adversarial instances X for
each IoT device type d ∈ D. The output of the inference
model for each adversarial instance x ∈ X, pred(x), is d
and the classiﬁcation score, score(x), is greater than or equal
to the classiﬁcation threshold of the corresponding class, Td.
Therefore, every adversarial instance x can bypass the infer-
ence model’s detection as it satisﬁes the minimal classiﬁcation
score. Also, we deﬁne a set of constraints to guarantee that X
fulﬁlls the requirements of the desired attack. As the scope of
this paper is volumetric attacks, we deﬁne these constraints as a
set of lower bound conditions for each feature f that belongs to
the target feature set F. The set F contains the relevant features
that would be affected by the desired attack, e.g., TCP packet
and byte count features in TCP SYN reﬂection attack.

Fig. 2 illustrates inputs and outputs of our ofﬂine adver-
sarial learning process. For illustration purpose we only show
two features, f1 and f2. Suppose we want to test whether
the model is vulnerable to a volumetric attack on a victim
device (e.g., Amazon Echo), where the attack offers more
than 1000 packets over f1. The desired attack impact
is
captured by a set of conditions for the target feature(s) (in our
example, f1 > 1000). The ofﬂine adversarial learning process
then searches over a given tree ensemble model in order to
determine recipes that the ensemble model predicts them as the
class of the victim device with a classiﬁcation score of greater
than or equal to the given threshold. Adversarial recipes can be
seen as a region in an N dimension space, being N the number
of features required by the inference model. Conditions on
target features (f1 in our example) speciﬁed by the adversarial
recipes must be consistent with those conditions given as input
for the intended attack (i.e., f1 > 1000). In other words, any
point in an adversarial recipe region is an adversarial instance
that satisﬁes the conditions of the intended attack.

logistic regression, and SVM,

We can use different search methods to ﬁnd X depending
on the underlying inference model. For models like neural
this optimization
networks,
problem can be solved using gradient-based methods such as
gradient descent, fast gradient sign [17], Jacobian saliency
map [37], or auto projected gradient descent [10]. While
differentiable models like neural networks have been widely
applied to image processing tasks, non-differentiable models
like decision trees have received less attention. In cybersecurity
applications, instead, decision tree-based models seem more
attractive with some interesting properties: (i) faster training
of O(n log n); (ii) better handling of imbalanced datasets [24]

5

inferencing model <Decision-Tree ensemble>offline adversarial learningvictim device <Class>target attack<feature rules>f1f2𝑓!"#$𝑓!"%&𝑓’"#$𝑓’"%&adversarialrecipescore threshold<number>Searching adversarial paths in two decision trees: The adversary starts traversing decision tree #1 with no prior rule – a path to target class “A” is
Fig. 3.
found ((cid:88)). Moving to decision tree #2, the ﬁrst path becomes inconsistent with rules of the chosen path from decision tree #1 (×), and thus an alternative path
is sought and found ((cid:88)).

we want to target class “A” with a cyberattack that requires
{f1 > 1000} (i.e., target rule). Below, we show the initial
recipe to begin the attack:

Recipe : f1 > 1000 ⇒ A

Starting from decision tree #1 (on the left), AdIoTack ﬁnds
the ﬁrst path leading to a leaf with the target class “A” (by
traversing the tree in pre-order mode). The adversarial path
on decision tree #1 consists of two conditions: {f1 > 100
and f2 > 50}, which are consistent with the initial recipe;
therefore, we can add them to the recipe:

Recipe : f1 > 1000 ∧ f1 > 100 ∧ f2 > 50 ⇒ A

which can be simpliﬁed (merged) to:

Recipe : f1 > 1000 ∧ f2 > 50 ⇒ A

Moving on to decision tree #2, the ﬁrst possible path (in
pre-order search) to the target class “A” requires {f1 ≤ 50},
which is inconsistent with {f1 > 1000} in the current recipe –
this path cannot be taken, and hence an alternative path needs
to be sought. The other path to the other leaf with class “A”
(on decision tree #2) results in two new conditions: {f3 > 10
and f2 ≤ 60}, not violating the current recipe determined by
the path from decision tree #1. The updated recipe is shown
below:

Recipe : f1 > 1000 ∧ f3 > 10 ∧ 50 < f2 ≤ 60 ⇒ A

To generate an adversarial recipe that drives the majority
vote to the target class, AdIoTack needs to keep track of
conditions and progressively augment them as new adversarial
paths are found across individual decision trees. Our search
procedure visits each tree in a greedy manner, i.e., it skips a
tree if it could not ﬁnd any consistent adversarial path on it.
Also, the order of the trees inﬂuences the output of the method.
We address this problem by running the algorithm multiple
times with different tree ordering to generate new recipes.

Having these intuitive illustrations of the adversarial attack
method, let us formally develop it by Algorithms 1 and 2.
Algorithm 1 searches for an adversarial recipe for a given
target device. This algorithm expects the inference model
(IM), a set of target rules (T R) that are deﬁned based on

R ← (T R ⇒ T D)
for t in IM.trees do

Algorithm 1 Adversarial evasion attack on tree ensemble
model.
1: IM ← inference model
2: T R ← set of target rules
3: T D ← target device class
4: Td ← classiﬁcation score threshold of T D
5: function FINDRECIPE(IM, T R, T D, Td)
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19: end function

end for
x∗ ← PROJECT(R)
if IM.PRED(x∗) = T D & IM.SCORE(x∗) ≥ Td then

AdvP ath ← FINDADVPATH(t.root, T D, R, [ ])
if AdvP ath (cid:54)= Null then

R ← MERGE(R, AdvP ath)

return Null

return R

(cid:46) Recipe

end if

end if

else

the target cyberattack, the target class of victim IoT device
(T D), and the classiﬁcation score threshold (Td) as inputs.

In essence, Algorithm 1 iterates over all

trees in the
ensemble model (IM). Notice the tree order in a decision
tree ensemble model is arbitrary, and different orders may
give different results (new recipes or no recipe at all). In §V,
we evaluate how different orders can affect the number of
generated recipes. For each tree, the algorithm calls the func-
tion FindAdvPath in Algorithm 2 to ﬁnd an adversarial path
consistent with the current recipe generated so far. If such a
path is found, the corresponding adversarial path’s rules are
merged with the current recipe rules (Merge). The following
examples show how Merge function works:

Merge(f ≤ τ1, f ≤ τ2, τ1 ≤ τ2) = f ≤ τ1, or

Merge(f > τ1, f > τ2, τ1 > τ2) = f > τ1

As there is no guarantee that FindAdvPath will ﬁnd an
adversarial path for every tree, we need to validate the efﬁcacy
of the ﬁnal recipe (whether it can bypass the model or not).
We may ﬁnd adversarial paths effective on only a small
subset of the decision trees, or even no tree at all. In this
case, the resulted adversarial instances will become ineffective
in yielding the target class and/or the score threshold. We
validate the efﬁcacy of a recipe by generating a representative

6

𝑓1𝑓2𝑓3≤100𝑓3Decision Tree #1Decision Tree #2> 100BDDCBBAACA𝑥∗𝑥∗✅✅☒consistency?search adversarial path> 10≤10> 50≤50> 10≤10𝑓2> 60≤60𝑓1> 50≤50else

end if

return P

return Null

if n is leaf then

(cid:46) Adversarial path

if n.label = target then

Algorithm 2 Searching for a consistent adversarial path.
1: function FINDADVPATH(n, T D, R, P )
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:

r ← FINDADVPATH(n.lef t, T D, R, [P ∧ n.cond])
if r (cid:54)= Null then
return r

end if
r ← Null
if ISCONSISTENT(n.cond, R) & ISCONSISTENT(n.cond, P ) then

ISCONSISTENT(¬n.cond, R) & ISCONSISTENT(¬n.cond, P )

end if

end if
if
then

r ← FINDADVPATH(n.right, T D, R, [P ∧ ¬n.cond])

17:
end if
18:
return r
19:
20: end function

adversarial instance, x∗, using Project function. We note
that every instance of a recipe would fall under the desired
adversarial paths determined by Algorithm 1; therefore, if x∗
can bypass the model, any other adversarial instance generated
from the given recipe can do the same. The instance x∗ is
presented to the model to obtain the prediction. If it is classiﬁed
as the target class with a classiﬁcation score greater than or
equal to the speciﬁed threshold (Td), the algorithm approves
and returns the recipe.

Algorithm 2 (invoked from within Algorithm 1) searches
for a consistent adversarial path (P ) to a leaf with the target
class label (T D) on a given tree. The algorithm is a direct
application of pre-order traversal for binary trees. During a
search, we check for consistency (IsConsistent) between
the nodes’ condition and the recipe (explained in III-D). This
helps to prune the search space, reducing the average execution
time. Algorithm 2 assumes binary decision trees; therefore, the
nodes are described by only three ﬁelds (left, right and
cond). The left subtree is associated with the condition cond
and the right subtree with logical negation of it (¬cond).

Note that an adversary may choose to stop searching when
a certain level of majority across trees (i.e., classiﬁcation
score) is obtained. Our algorithm, instead, aggressively aims
to maximize its chance of subverting the model by (greedily)
searching all possible trees. Given this greedy nature of our
ofﬂine adversarial learning, its time complexity is O(T .N .F),
proportional to the number trees (T ), maximum number of
nodes in the trees (N ), and total number of features (F). It
is important to note that our search across trees progresses
only in a forward direction. Hence, in some cases, it may not
yield any consistent adversarial path on a decision tree (in the
middle of iterating over trees). In other words, if a consistent
path on a tree is not found, then that tree is skipped without
going backward, seeking alternative adversarial paths on the
previous trees, and updating the recipe correspondingly.

D. Verifying Consistency of Conditions

Our adversarial learning algorithm is general and can be
applied to any decision tree ensemble model. However, certain
constraints may be needed when employing the algorithm

7

Fig. 4. Local adversary (an infected machine) collects trafﬁc features before
launching an online attack.

for speciﬁc domain problems. Given the primary use-case of
this paper is network-based volumetric attacks, three types of
consistency checks are performed before taking a new branch
(left or right subtree) while searching for an adversarial path:

Single-feature consistency: This type of consistency is
required when different conditions are imposed on a single
feature across trees. Let us consider two illustrative conditions
f ≤ τ1 and f > τ2. They are considered consistent if τ2 < τ1,
where f denotes a feature that the inference model uses. A
single-feature consistency check is required in any problem
of adversarial machine learning. However, in the context of
cybersecurity, we identiﬁed two additional checks essential
for launching attacks; otherwise, the ofﬂine learning algorithm
may generate impractical adversarial recipes that cannot be
launched during the online phase.

Frame size consistency: This constraint

is speciﬁc to
the use-case of this paper. Frame size is measured in bytes
and has a minimum and maximum length, depending on the
implemented technology. For example, an Ethernet frame must
be at least 64 bytes for collision detection to work and can be
a maximum of 1518 bytes to avoid IP fragmentation. This
expected characteristic may get violated by a condition. For
example, let us consider a set of conditions on two features of
incoming (↓) DNS trafﬁc for a given adversarial recipe:

(cid:40) C1 : 9 <

(cid:7)
↓DNS packet count
(cid:6)

(cid:7)
↓DNS byte count ≤ 100
(cid:6)

(cid:5)

(cid:4)

(cid:4)

(cid:5)

C2 :

These translate into an average size of incoming DNS
frames to be less than 10 bytes, which is impossible on
Ethernet networks – sending at least ten frames even with
no payload would result in 640 bytes of trafﬁc, violating the
condition C2 above.

Boundary consistency: Average frame size obtained by
the ratio of byte count and packet count must be rounded to
integer values (cannot be ﬂoat values). There are certain corner
cases where packet count and byte count conditions become
inconsistent. The following conditions exemplify this situation:

(cid:7)
(cid:40) C3 : 10 <
↓DNS packet count ≤ 15
(cid:6)
(cid:7)
↓DNS byte count ≤ 1, 000
(cid:6)

C4 : 998 <

(cid:5)

(cid:5)

(cid:4)

(cid:4)

victim IoT devicedefault gatewayARP poisoningAdIoTackIcvictim’s  current feature vectorlocal IoT devicesARP poisoningmaintains a record (feature vector Ic) of the trafﬁc features
in the current epoch. Given Ic, AdIoTack would ﬁnd feasible
adversarial recipes towards the end of each epoch. A feasible
recipe has to be an upper bound to vector Ic (Fig. 5 shows
it in a 2D space). If the victim displays network activities
(Ic) exceeding a threshold (f < τ ) speciﬁed by a recipe,
then Ic cannot be projected to that recipe anymore simply
because we cannot reduce the amount of trafﬁc that already has
been exchanged by the device but we can increase it. Among
all feasible recipes, AdIoTack selects the closest adversarial
instance to Ic, minimizing the overhead packets to be injected.
This strategy requires AdIoTack to be aware of the inference
model’s timing cycles, i.e., when it is called for prediction.
In our evaluation (§V), we will explain how AdIoTack has the
chance to execute successful attacks even without syncing with
cycles of the inference model.

In this paper, we use linear search to ﬁnd feasible recipes.
Though we do not encounter a challenge in terms of the time
complexity of the linear search in our evaluation, there might
be situations where a simple linear search becomes inefﬁcient.
To achieve certain response time, one may attempt to optimize
the search process and/or prune the generated recipes. Both of
these objectives are beyond the scope of this paper.

We use an example in Table I to better clarify our method
for executing a volumetric TCP SYN reﬂection attack on
Google Chromecast. The top two rows indicate lower-bound
and upper-bound feature values speciﬁed by the adversarial
recipe for launching a successful attack. Note that the symbol
“*” indicates unbounded features (no lower/upper limits).
The third row shows the current feature vector of Google
Chromecast over the last 60 seconds. The bottom row shows
the adversarial instance comprising the intended volumetric
attack trafﬁc (bold cells) reﬂected by Google Chromecast and
overhead packets (underlined cells) injected by AdIoTack.

To successfully launch the adversarial volumetric attack,
AdIoTack needs to inject certain spoofed packets (the overhead
trafﬁc speciﬁed by the closest recipe) on behalf of the victim,
so that the inference model does not detect any deviation in
the behavior of the victim IoT device. Table II summarizes
certain packet metadata ﬁelds to be modiﬁed along with their
spoofed value for a given set of trafﬁc features in the speciﬁc
model we studied. GW and VIC stand for gateway and victim,
respectively. WAN IP and LAN IP respectively refer to external
(public) and internal (private) IP address. Also, “*” highlights
a wildcard value for the respective ﬁeld.

Practical Challenges of Network-Based Attacks: We
discuss a few practical challenges to overcome for successful
execution of adversarial attack instances in what follows: (i)
in order to intercept bidirectional trafﬁc exchanged between
the victim and its local network, AdIoTack needs to employ
Gratuitous ARP replies to send a broadcast spoofed ARP reply
(on behalf of the victim device) to all local devices. That way,
all local trafﬁc destined to the victim device is forwarded to
AdIoTack; and, (ii) there might be cases whereby AdIoTack
and victim may not share the same network interface (e.g., one
is wired and the other one is wireless). In that case, AdIoTack
will have to send the spoofed trafﬁc via the default gateway,
which will disrupt
the MAC-learning tables (wireless vs.
wired) of the default gateway’s interfaces due to the spoofed
source MAC address in those packets (Table II) – this can lead

Fig. 5. Finding feasible recipes’ region and the closest adversarial instance
given current state Ic. For illustration purpose, only two features are shown.

(cid:7)
↓DNS packet count = 11
(cid:6)

(cid:5)

(cid:4)

(cid:4)

(cid:5)

Choosing the combination of
(cid:7)
↓DNS byte count = 999 gives a minimum average frame
and
(cid:6)
size of 91 B (equally sized). At a high level, this combination
would violate C4 since 11 DNS incoming messages of size
91 B each will amount to 1001 B. Indeed, one may choose
to solve this inequality problem by judiciously setting packet
sizes (e.g., nine packets of each 100 B and a packet of 99
B) – this is beyond the scope of this paper. We only consider
recipes that allow adversarial attacks of equal packet size.

Note that in a single tree, conditions inside each path (from
root to a leaf) satisfy single-feature consistency by default.
Still, even conditions within a given path of a single tree may
violate frame size and boundary consistencies.

IV. LAUNCHING ADVERSARIAL VOLUMETRIC ATTACK

This section describes how we use adversarial recipes to
launch real volumetric attacks on an operational IoT network
whose trafﬁc is continuously monitored by a trained inference
model. To clarify the method better, we explain this section
with a set of the ﬂow-based features that the model uses
for inference. Inspired by [40], we choose packet count and
byte count of certain network ﬂows: ↓DNS, ↑DNS, ↓NTP, ↑NTP,
↑SSDP, ↓LAN, ↓WAN, and ↑WAN, proven to be reﬂective of IoT
behavior, during ﬁxed time windows (of length one minute);
where ↓ and ↑ indicate incoming and outgoing directions,
respectively.

This phase aims to project the current state (trafﬁc feature
vector) of a victim IoT device to an adversarial
instance
using one of the adversarial recipes obtained in the ofﬂine
learning phase. A naive approach is to launch a cyberattack
blindly based on a random recipe. This approach is not
guaranteed to bypass the inference model given the variability
in volume and frequency of trafﬁc sent/received by the victim
IoT devices during the last time window (i.e., current state).
It is important to note that malicious packets (pertinent to the
intended network attack) get added to the benign trafﬁc of the
victim device. Hence, a more effective strategy is needed that
considers the current state of the variable network.

A well-known method to track network trafﬁc and create
a feature vector for the victim device is poisoning the ARP
tables (discussed in §III) of local IoT devices and default
gateway. Therefore, AdIoTack can sit in the middle of these
entities by forwarding trafﬁc between them. Fig. 4 illustrates
the monitoring phase before launching the attack. AdIoTack

8

f1f2recipe #1recipe #4recipe #2recipe #5closest adversarial instanceICfeasible adversarialrecipes regionrecipe #3TABLE I.

AN EXAMPLE OF A FEASIBLE SYN REFLECTION ATTACK ON GOOGLE CHROMECAST.

t
k
p

S
N
D

↓

2
*
0
3

e
t
y
b

S
N
D

↓

119
1,666
0
120

t
k
p

S
N
D

↑

2
*
0
3

e
t
y
b

S
N
D

↑

194
*
0
195

t
k
p

P
T
N

↓

*
*
0
1

e
t
y
b

P
T
N

↓

45
*
0
46

t
k
p

P
T
N

↑

*
1
0
0

e
t
y
b

P
T
N

↑

*
*
0
0

t
k
p

P
D
S
S

↑

7
9
0
8

e
t
y
b

P
D
S
S

↑

4,353
4,553
0
4,354

t
k
p

N
A
L

↓

94
148
0
95

e
t
y
b

N
A
L

↓

9,303
13,797
0
9,304

t
k
p

N
A
W

↓

88
*
46
1,000

e
t
y
b

N
A
W

↓

45,568
*
125,857
74,000

t
k
p

N
A
W

↑

10
*
51
1,000

e
t
y
b

N
A
W

↑

5,650
*
5,752
74,000

Condition (>)
Condition (≤)
Current state (Ic)
Adversarial instance

TABLE II.

SPOOFED METADATA FOR EACH FEATURE.

Feature

↓ DNS

↑ DNS

↓ NTP

↑ NTP

↑ SSDP

↓ LAN

↓ WAN

↑ WAN

src
MAC

dst
MAC

src IP

dst IP

src Port

dst Port

GW

VIC

GW

VIC

VIC

*

GW

VIC

VIC

GW

VIC

GW

*

*

VIC

*

VIC

VIC

VIC

LAN IP

VIC WAN IP

VIC

*

VIC

*

*

VIC

VIC

GW

VIC

WAN IP

53

*

123

*

*

*

*

*

*

53

*

123

1900

*

*

*

TABLE III.

THREE ENSEMBLE MODELS PERFORMANCE ON THE

TESTING DATASET.

Model
Random Forest
Gradient Boosting
AdaBoost

Accuracy
96%
91%
99%

False positive
9%
0.1%
5%

to mis-forwarding of other packets to/from the victim (wireless
LAN instead of wired LAN). Disrupting the default gateway’s
MAC tables results in dropping future packets with the same
MAC address, this time as the destination ﬁeld. To avoid
this, AdIoTack sends a speciﬁc ICMP packet with destination
broadcast MAC address (ff:ff:ff:ff:ff:ff) and victim’s
IP address. The victim’s reply will revert the MAC tables to
their correct state.

V. EVALUATION RESULTS

This section evaluates the performance of AdIoTack in its
two phases, namely ofﬂine adversarial learning, and online
adversarial execution. We begin by training three well-known
decision tree ensemble models namely Random Forest, Gradi-
ent Boosting, and AdaBoost classiﬁers.

A. The Inference Model

Fig. 6. Number of generated adversarial recipes for three ensemble models
for attack impact of 1000 packets.

data from February, March and the ﬁrst half of April for
training, and the second half of April and May for testing.

We use the Python Scikit Learn library to train multi-
class classiﬁers by three representative ensemble decision-tree
algorithms, namely Random Forest, Gradient Boosting, and
AdaBoost, to predict device class label. These models provide
us with a classiﬁcation score used as a baseline threshold for
detecting misbehavior. Table III shows the accuracy and false
positive rate of each model. For detecting misbehaviors, we
use classiﬁcation scores’ µ and σ for each class of IoT device
(shown in Table IV for Random Forest model) obtained from
the training dataset in such a way that if for a given instance
the model’s classiﬁcation score for its predicted label is below
µ − σ (of that label), the instance is considered as malicious.
Table IV shows the Random Forest model’s classiﬁcation score
for each class of IoT devices in our testbed obtained from the
training dataset. We use µ and σ values obtained from the
training for detecting IoT devices’ misbehavior in such a way
that if for a given instance the model’s classiﬁcation score for
its predicted label is below µ − σ (of that label), the instance
is considered as malicious.

Inspired by [40], we consider ﬂow-level features from net-
work trafﬁc, periodically computed over one-minute windows.
That way, no need for inspecting packet payloads. Trafﬁc
features include statistics (packet and byte counts) of ↓DNS,
↑DNS, ↓NTP, ↑NTP, ↑SSDP, ↓LAN, ↓WAN, and ↑WAN; where
↑ indicates upstream trafﬁc from each IoT device, and ↓
highlights downstream trafﬁc to each IoT device. This means
a total of 16 features.

We train our model with a dataset collected from our
testbed (comprising nine IoT devices), during February-May
2020. Our full dataset has 954,384 benign instances. We use

B. AdIoTack Ofﬂine Instances

In this part, we evaluate the performance of AdIoTack in
ofﬂine adversarial learning with a view to launch two well-
known network-based attacks, namely TCP SYN and SSDP
reﬂection attacks.

Let us begin by showing that our ofﬂine learning method
is generalizable by applying it to the three popular ensemble
models. Fig. 6 indicates the number of adversarial recipes
for SSDP and SYN reﬂection attacks per inference model.
Random Forest seems to be more robust to adversarial attacks

9

Random ForestGradient BoostingAdaBoostinference model010203040# adversarial recipesSYN reflection attackSSDP reflection attackTABLE IV.

EXPECTED CLASSIFICATION SCORE (µ AND σ) OF THE

RANDOM FOREST MODEL OBTAINED FROM TRAINING.

IoT class
Amazon Echo
Belkin motion
Belkin switch
Chromecast
Hue bulb
LiFX bulb
Netatmo camera
Samsung camera
TP-Link switch

Benign
σ
0.10
0.06
0.18
0.16
0.01
0.15
0.14
0.002
0.10

µ
0.94
0.96
0.86
0.90
0.99
0.72
0.88
1.00
0.86

Fig. 8. Number of generated adversarial recipes per IoT device for two
representative attacks (result of a 20-permutation run).

algorithm with 20 permutations. Belkin switch and Chromecast
in both types the attacks. Samsung smart camera has no recipe
for SSDP reﬂection, TP-Link has no recipe for SYN reﬂection
attack, and Hue lightbulb has no recipe for both of the attacks,
indicating tight constraints for those classes.

Before experimenting with our adversarial recipes in an op-
erational network of IoT devices, we evaluate the performance
of our inference model and efﬁcacy of ofﬂine adversarial in-
stances by replaying various unseen datasets in three scenarios,
namely: (1) a purely benign dataset is expected to receive
high classiﬁcation scores from the model, (2) syntactically
changed features of the benign instances (to represent non-
adversarial SYN reﬂection attack) are expected to receive
low scores from the model (highlighting a detection), and
(3) synthetically changed features of the benign instances (to
represent adversarial SYN reﬂection attack) are expected to
receive high scores from the model (highlighting a miss).

Fig. 9 shows the results for two representative IoT devices
over an hour. As expected, almost all benign instances are
classiﬁed with a high score (i.e., above the threshold shown by
dashed blue line), highlighting the expected performance under
normal situations (benign trafﬁc). The dotted red curve shows
the model’s score for non-adversarial attack instances, which
the model detects a majority of them (receiving scores below
the threshold). Finally, the purple curve highlights the model’s
inability to detect adversarial attacks (i.e., giving scores above
the threshold, meaning benign). In some epochs like at 5:03pm
for Amazon Echo and 5:08pm for Belkin switch, there is no
recipe in the feasible region to project the current instance,
thus missing data points.

C. AdIoTack Online Evaluation

To demonstrate adversarial attacks in a realistic scenario,
we deploy our inference model in a system that can classify
trafﬁc in real-time. It receives a stream of ﬂow-based telemetry
and predicts trafﬁc features of individual connected devices
every minute. To collect real-time telemetry, we use an SDN-
enabled home gateway in our setup, shown in Fig. 10. We
installed Open Virtual Switch (OVS) on the gateway of our
IoT network. Ryu, an open-source SDN controller, is installed
on another machine that communicates with this OVS. The

Fig. 7. Number (min, max, avg) of generated adversarial recipes for different
permutation counts for attack impact of 1000 packets.

compared to the other two models, corroborating with the ob-
servations in [23]. Because of its relative robustness, we choose
Random Forest for the rest of the experimental evaluation in
this paper.

We now quantify the impact of the sequence order of
trees in generating adversarial recipes. We deﬁne permutation
as a random shufﬂe of the trees inside the ensemble model,
which we need to iterate through them in the same order as
the permutation suggests. We show that various permutations
can result in different adversarial recipes. Fig. 7 shows the
min, max, and average number of unique recipes for different
permutation counts by running the algorithm ﬁve times for
each permutation value. For example, if the permutation count
is three, we run the ofﬂine learning with three different permu-
tations for each device over ﬁve rounds and count the number
of unique recipes at each round. The plot shows an overall
increasing trend which means as we try different permutations,
there is a high chance of ﬁnding new recipes. Also, the plot
suggests that SSDP reﬂection can generate more recipes than
SYN reﬂection, in which the increasing trend seems to become
smoother after three permutations. The average time taken
for generating adversarial recipes per permutation is about
1.5 minutes for SSDP reﬂection and 2.2 minutes for SYN
reﬂection attack. This is probably because four features (packet
and byte count of ﬂows ↓WAN and ↑WAN) are affected by SYN
reﬂection attack, whereas only two features (packet and byte
count for ↑SSDP) are affected by the SSDP reﬂection attack.

Fig. 8 illustrates the number of generated recipes for each
IoT device in our testbed by running the ofﬂine learning

10

12345678910# permutations036912151821242730# adversarial recipesSSDP reflection attackSYN reflection attackAmazon EchoBelkin motionBelkin switchChromecastLiFX lightNetatmo cam.Samsung cam.TP-Link switchdevice020406080100120# adversarial recipesSSDP reflection attackSYN reflection attackFig. 9.
scenarios: benign (green), synthetic adversarial SYN reﬂection attack (purple) and synthetic non-adversarial SYN reﬂection attack (red).

Time trace of model performance against replayed instances of two representative IoT devices: (a) Amazon Echo, and (b) Belkin switch, in three

(a) Amazon Echo.

(b) Belkin switch.

regions, the model gives scores lower than expected threshold
to non-adversarial
instances across the three representative
devices.

During the online evaluation, we found that it is impossible
to execute any adversarial attack on three devices, namely
Samsung smart camera, Philips Hue lightbulb, and Amazon
Echo. For Samsung smart camera, the reason is that no feasible
adversarial recipe was found for Ic (device’s current feature
vector) to be projected on as Ic during our experiment violated
the upper bound of the rule on ↑SSDP feature. For the other two
devices, the reason relies on the network aspect. Philips Hue
lightbulb responds to the corrective ping message sourced by
AdIoTack. However, the response does not revert the gateway’s
MAC table; probably because Philips Hue is not a standalone
device and relies on a separate bridge for communication.
Amazon Echo did not respond to the ping message, hence
the disrupted MAC table issue stopped us from launching the
attack.

During this evaluation, we assumed that AdIoTack knows
the inference cycles of the model i.e., when the model fetches
the ﬂow counters from the SDN controller and classiﬁes the
trafﬁc. This is a valid assumption as we already declared our
work to be a white-box approach. Still, we further evaluate
AdIoTack online execution in scenarios where inference cycles
are unknown. Fig. 12 illustrates this evaluation for Belkin mo-
tion sensor and Chromecast. We launched adversarial attacks
on these devices with four different timings. Time-shift of T
means that the attacker is T seconds ahead of the inference
model. We need to note that the time window in this evaluation
is 60 seconds meaning that the model becomes online every
60 seconds.

Unsurprisingly, Fig. 12 shows that adversarial attacks with
the time shift of zero are 100% successful
in bypassing
the model. Fig. 12 shows that for Chromecast,
time-shift
almost has no effect on the success of adversarial attacks;
however, for Belkin motion sensor, it has signiﬁcant effects.
The results suggest that a time shift of 30 seconds leads to
the minimum success rate (23%), but when it gets closer to
the inference model’s time cycle, i.e., time shift of 45 seconds,
the success rate signiﬁcantly rises (92%). The key takeaway is
that regardless of when AdIoTack launches the attack, there is
always a chance to bypass the model.

Fig. 10. Prototype of AdIoTack.

Ryu controller initializes the setup by sending a ﬁxed set of
ﬂow rules speciﬁc to each IoT device on the network, of which
the inference model needs the corresponding ﬂow counters as
features (features described in §V-A). Every minute, the model
receives ﬂow counters from the controller and classiﬁes indi-
vidual devices. The model also detects unexpected behavior
by way of classiﬁcation score (explained in §V-A).

Fig. 11 shows the performance of AdIoTack in the online
execution phase for three representative devices with SYN
reﬂection attack. Our entire evaluation lasted for 35 minutes
with three stages: between 2:40pm and 2:48pm (highlighted
in green), no attack was executed to observe the behavior
of our inference model in normal operation; between 2:48pm
and 3:10pm (highlighted in orange), we performed adversarial
SYN reﬂection attacks in each epoch; lastly, between 3:10pm
and 3:15pm (highlighted in red), we performed non-adversarial
SYN reﬂection attack with the same impact of the adversarial
ones launched in the middle stage. The upper subplots show
the inference model’s classiﬁcation score at the end of each
epoch. The score threshold of each class is shown by a constant
dashed red line. The lower subplots show the number of attack
packets received by the ultimate target machine (victim server)
residing on the WAN interface of the gateway (outside the local
IoT network).

It can be seen that the inference model displays an accept-
able performance under normal operation (i.e., pure benign
trafﬁc, without any attack). Moving to the orange regions, we
observe that all adversarial reﬂection attacks are successful
(classiﬁcation scores above the threshold), except during an
epoch for Chromecast in Fig. 11(b). Lastly, focusing on the red

11

5:00pm5:10pm5:20pm5:30pm5:40pm5:50pm6:00pmtime0.000.250.500.751.00classification scorebenignadversarialnon-adversarialscore threshold5:00pm5:10pm5:20pm5:30pm5:40pm5:50pm6:00pmtime0.000.250.500.751.00classification scorebenignadversarialnon-adversarialscore thresholdInternetinferencemodelAdIoTackLocal networkIoT devicesRyu controllerOpenFlow rulesflowcountersminutelyflow featuresWANtarget(a) Belkin switch.

(b) Chromecast.

(c) Netatmo camera.

Fig. 11. Time trace of model performance and attack trafﬁc on three IoT devices in three scenarios: normal operation (green), adversarial attack (orange) and
non-adversarial attack (red).

VI. REFINING RESILIENCE OF DECISION TREES AGAINST
ADVERSARIAL VOLUMETRIC ATTACKS

We have so far highlighted the vulnerability of decision
tree-based models against systematically crafted adversarial
attacks. In this section, we develop a method called patching
to reﬁne the model post-training, making decision trees robust
against adversarial volumetric attacks.

Decision trees trained purely by benign trafﬁc instances
are inherently vulnerable (given their structure) to volumetric
attacks. Fig. 13 illustrates an illustrative decision tree with four
leaves and three decision nodes on three features. For each leaf,
we deﬁne bounded and unbounded feature sets. For a given
leaf l, its bounded feature set includes feature f , if inside the
path from the tree’s root to l, there is at least one decision
node on f which must take the left branch (i.e., f ≤ τ ) to
reach l. Otherwise, if there is no such a decision node for f ,
we consider f as an unbounded feature for l. For example,
in Fig. 13, consider the leaf with label ‘C’. To reach this leaf
from the root, the following conditions must be met: f1 > 100
and f3 ≤ 70. Thus if an instance has f1 = +∞, f2 = +∞,
and f3 = 70, it still reaches the leaf with no issue as there
is no upper boundary check for f1 and there is no upper or
lower boundary check for f2 at all.

In the literature, there exist methods [8], [5] for developing
robust decision trees against adversarial attacks. The current
techniques manipulate the training process of decision trees
by changing the original model to make sure if an adversarial

attack happens, the model still gives the correct output label
which is desirable in image classiﬁcation which requires a
given set of adversarial instances to be provided before reﬁning
the model i.e., the model still might be vulnerable to another
set of adversarial instances. That way, they sacriﬁce the predic-
tion accuracy for benign instances, in order to make decision
trees robust in adversarial scenarios. Also, given their primary
focus is on image recognition, they do not have a notion of
volumetric attacks, and thus, unbounded features remain loose.
Our method, however, focuses on a different problem (i.e.,
volumetric cyberattacks), and aims to reﬁne a trained model.
Therefore, it does not interfere with the training process and
does not require re-training. Our method receives a trained
decision tree-based model and then patches the unbounded
features with no dependency on any adversarial recipes. If
the training dataset gives a correct representation of devices’
trafﬁc characteristics by at least capturing the maximum trafﬁc
volume for each class correctly, the patched model will have
the exact same accuracy/false positive over benign instances
as the original model. However, if there are data instances in
the testing dataset that have higher trafﬁc features’ value than
the limits which were captured from the training dataset, our
method would ﬂag them an as malicious (i.e., higher false
positives than the original unpatched model).

We deﬁne a patch for feature f on leaf l as follows:
patchl,f = f ≤ max(lf )

This patch can be seen as a new decision node added

12

0.00.20.40.60.81.0classification score2:40pm2:50pm3pm3:10pmtime02505007501000attack packet count0.00.20.40.60.81.0classification score2:40pm2:50pm3pm3:10pmtime02505007501000attack packet count0.00.20.40.60.81.0classification score2:40pm2:50pm3pm3:10pmtime02505007501000attack packet countFig. 12. Effect of time-shift for two IoT devices.

(a) Belkin motion sensor.

(b) Chromecast.

Fig. 13. Bounded and unbounded features for each leaf in a decision tree.

Fig. 14. Essential patching performed on individual leaves of the vulnerable
decision tree from Fig. 13.

just before reaching the leaf, that checks the upper bound
of f for l. The upper bound is calculated based on the
training dataset used for training the original model. As
an example, based on our training dataset, Amazon Echo
sends a maximum of four DNS packets every minute; thus,
max(Amazon Echo↑DN S pkt) = 4. Any instance x reaching
leaf l, which xf > max(lf ), goes to a new leaf that yields x
as a malicious instance.

13

Fig. 15. Detection rate of Essential and Additional patching for adversarial
SYN and SSDP reﬂection attacks.

There are two noteworthy points: (1) Because IoT devices
send/receive a low volume of trafﬁc and have repetitive be-
havioral patterns, individual devices’ maximum trafﬁc volume
can be captured [43]. However, this could be challenging for
personal computers and smartphones which their trafﬁc volume
highly depends on users’ activities. (2) Our method reduces
the impact of adversarial volumetric attacks signiﬁcantly. How-
ever, low-impact attacks (i.e., within the normal behavior range
of IoT devices) can still bypass the model.

There are two scenarios where feature f can become
unbounded for leaf l: (1) When there is a decision node on f ,
but its right branch (i.e., f > τ ) is taken on the path from the
tree’s root to l (e.g., f1 for leaf ‘C’ in Fig. 13); and (2) When
there is no decision node on f through the path at all (e.g., f2
for leaf ‘C’ in Fig. 13). We develop two patching techniques
to address these two scenarios. Essential Patching solves the
ﬁrst problem by traversing a given vulnerable decision tree
and patching leaves with unbounded features through paths
from the root. Fig. 14 shows the result of essential patching

0.00.20.40.60.81.0time shift = 00.00.20.40.60.81.0time shift = 150.00.20.40.60.81.0time shift = 305:40pm5:45pm5:50pmtime0.00.20.40.60.81.0time shift = 45classification score0.00.20.40.60.81.0time shift = 00.00.20.40.60.81.0time shift = 150.00.20.40.60.81.0time shift = 305:40pm5:45pm5:50pmtime0.00.20.40.60.81.0time shift = 45classification scoref1ABCD> 100≤ 100≤ 50> 70> 50≤ 70f2f3f1f2f1f3-f3f2f3f1, f2f1 , f2 , f3f1ABCD> 100≤ 100≤ 50> 70> 50≤ 70f2f3f2B>max(𝐵!!)≤ max(𝐵!!)f1≤ max(𝐶!")C> max(𝐶!")f3f1DD>max(𝐷!#)> max(𝐷!")≤max(𝐷!#)≤ max(𝐷!")2004006008001000# attack packet count5060708090100detection rate (%)Adversarial SSDP reflection attack (Essential patch only)Adversarial SYN reflection attack (Essential and Additional patch)Adversarial SYN reflection attack (Essential patch only)robust against SSDP reﬂection attacks with any impact. The
improvement becomes more evident as the impact increases.
More importantly, no recipe exists for volumetric attacks with
an impact above 600 packets.

VII. CONCLUSION

In this paper, we developed AdIoTack, a systematic way
of quantifying and reﬁning the resilience of decision tree en-
semble models against data-driven adversarial attacks. We ﬁrst
developed a white-box algorithm that automatically generates
recipes of volumetric network-based attacks that can bypass the
inference model unnoticed. Our algorithm takes the intended
attack on a victim class and the model as inputs. We developed
a systematic method to successfully launch the intended attack
on real networks. We next prototyped AdIoTack and validated
its efﬁcacy on a real testbed of real IoT devices monitored
by a trained Random-Forest model. We demonstrated how
the model detects all non-adversarial volumetric attacks on
IoT devices while missing many adversarial ones. Finally, we
developed systematic methods to patch loopholes in trained
decision tree ensemble models. We demonstrated how our
reﬁned model detects 92% of adversarial volumetric attacks.

REFERENCES

[2]

[1] A. Abusnaina, A. Khormali, H. Alasmary, J. Park, A. Anwar, and
A. Mohaisen, “Adversarial Learning Attacks on Graph-based IoT Mal-
ware Detection Systems,” in Proc. IEEE ICDCS, Dallas, USA, Jul 2019.
J. Anand, A. Sivanathan, A. Hamza, and H. H. Gharakheili, “PARVP:
Passively Assessing Risk of Vulnerable Passwords for HTTP Authenti-
cation in Networked Cameras,” in Proc. ACM Workshop on Descriptive
Approaches to IoT Security, Network, and Application Conﬁguration
(DAI-SNAC), Virtual Event, Germany, Dec 2021.

[3] M. Barreno, B. Nelson, A. D. Joseph, and J. D. Tygar, “The Security of
Machine Learning,” Springer Machine Learning, vol. 81, p. 121–148,
May 2010.

[4] L. Breiman, “Random Forests,” Springer Machine learning, vol. 45,

no. 1, pp. 5–32, Oct 2001.

[5] S. Calzavara, C. Lucchese, G. Tolomei, S. A. Abebe, and S. Orlando,
“Treant: Training Evasion-aware Decision Trees,” Data Mining and
Knowledge Discovery, vol. 34, no. 5, pp. 1390–1420, 2020.

[6] G. Caminero, M. L. Mart´ın, and B. Carro, “Adversarial Environment
Reinforcement Learning Algorithm for Intrusion Detection,” Computer
Networks, vol. 159, pp. 96–109, Aug 2019.

[7] N. Carlini and D. Wagner, “Adversarial Examples Are Not Easily
Detected: Bypassing Ten Detection Methods,” in Proc. ACM AISec,
Dallas, USA, Nov 2017.

[8] H. Chen, H. Zhang, D. Boning, and C. Hsieh, “Robust Decision Trees
Against Adversarial Examples,” in Proc. ICML, Long Beach, CA, USA,
Jun 2019.

[9] M. Cheng, T. Le, P.-Y. Chen, J. Yi, H. Zhang, and C.-J. Hsieh,
“Query-Efﬁcient Hard-label Black-box Attack:An Optimization-based
Approach,” in proc. of ICLR, Vancouver, Canada, Apr 2018.

[10] F. Croce and M. Hein, “Reliable Evaluation of Adversarial Robustness
with an Ensemble of Diverse Parameter-free Attacks,” arXiv e-prints,
p. arXiv:2003.01690, Mar 2020.

“University
light

by
attacked
bulbs & 5,000

[11] CSO,
smart
[Online].
university-attacked-by-its-own-vending-machines-smart-light-bulbs-and-5-000-iot-devices.
html

vending machines,
2017.
Feb
https://www.csoonline.com/article/3168763/

Available:

its
IoT

devices,”

own

Fig. 16. Number of recipes generated for SYN reﬂection attack before and
after patching the model.

performed on the tree from Fig. 13. Adversarial instances will
be routed to the red leaves, which results in true detection of
the attack.

Although essential patching is necessary to ﬁx some un-
bounded features, it does not cover the second scenario where
some features do not even exist on some paths. For example,
leaf “A” in Fig. 14, still can be targeted with volumetric attack
on f3 = +∞. In fact, some adversarial attacks can be captured
solely with essential patching (e.g., SSDP reﬂection attack
in Fig. 15). To overcome this problem, we deﬁne Additional
Patching which patches all leaves for a given feature. This way,
regardless of the trees’ structure, we make sure all leaves are
patched against adversarial volumetric attacks on the desired
features. Additional patching can be done in different ways;
for example, one may choose to patch all leaves for all possible
features to create maximum robustness, making the model
complex and slow. Another one may use expert knowledge
to select speciﬁc vulnerable features to limit the complexity
of the model while making it robust against attacks over
those features that are more likely to be targeted by attackers.
After applying the essential patching to our original model,
we quantify the accuracy and false-positive over the testing
dataset and they are 96% and 0.09%, respectively, which are
exactly the same as the original model.

Fig. 15 shows the performance of our patching methods
over adversarial SSDP and SYN reﬂection attacks with a
range of attack impacts (100 to 1,000 packet count). Note
that these attack instances are created based on adversarial
recipes, bypassing the unpatched model, as shown in the
previous section. Essential patching is sufﬁcient to detect all
SSDP reﬂection attacks while detecting 86% of the high-
impact SYN reﬂection attacks. Having an additional patch over
↑ WAN packet count feature increases the detection rate for low,
medium, and high impact attacks; and detects all attacks with
an impact greater than 636 packets. The average impact of
SYN reﬂection attacks that can still bypass the model is 117
packets across our IoT devices, with the maximum impact
of 636 packets for Chromecast. Compared to the vulnerable
model, which has no limit over the attack packet count (i.e.,
unlimited impact), this impact shows a signiﬁcant improvement
in terms of robustness.

Finally, we validate the efﬁcacy of our patched model
by re-running the adversarial ofﬂine learning function on the
reﬁned model. Fig. 16 compares the number of generated
recipes in the patched model versus the original (unpatched)
model. The patched model (green bars) has become more

[12] Cyberedge, “Cyberthreat Defense Report,” https://cyber-edge.com/wp-
content/uploads/2020/03/CyberEdge-2020-CDR-Report-v1.0.pdf, 2020.
[13] G. S. Dhillon, K. Azizzadenesheli, Z. C. Lipton, J. Bernstein, J. Kossaiﬁ,
A. Khanna, and A. Anandkumar, “Stochastic Activation Pruning for
Robust Adversarial Defense,” arXiv e-prints, p. arXiv:1803.01442, Mar
2018.

14

2004006008001000impact02468101214# adversarial recipesunpatched modelpatched model[32] NETSCOUT Security, “A Deeper Look at IoT Weaponization,” 2020.

[Online]. Available: https://bit.ly/3pr3NJT

[33] T. D. Nguyen, S. Marchal, M. Miettinen, H. Fereidooni, N. Asokan,
and A. Sadeghi, “D¨IoT: A Federated Self-learning Anomaly Detection
System for IoT,” in Proc. IEEE ICDCS, Dallas, USA, Jul 2019.
[34] Nokia, “Threat Intelligence Report 2020,” Computer Fraud & Security,

vol. 2020, no. 11, 2020.

[35] OPTIV,

Florida Water

“Attempted
IoT/OT

derscores
line]. Available:
attempted-ﬂorida-water-supply-tampering-underscores-iotot-security

Tampering Un-
[On-
https://www.optiv.com/explore-optiv-insights/blog/

Challenges,”

Security

Supply

2021.

Feb

[36] Palo Alto Networks, “Unit42 IoT Threat Report,” Apr 2020. [Online].

Available: https://start.paloaltonetworks.com/unit-42-iot-threat-report

[37] N. Papernot, P. D. McDaniel, S. Jha, M. Fredrikson, Z. B. Celik, and
A. Swami, “The Limitations of Deep Learning in Adversarial Settings,”
in Proc. IEEE EuroS&P, Saarbr¨ucken, Germany, Mar 2016.
[38] A. Pashamokhtari, N. Okui, Y. Miyake, M. Nakahara,

and
H. Habibi Gharakheili, “Inferring Connected IoT Devices from IPFIX
Records in Residential ISP Networks,” in IEEE LCN, Virtual Event,
Canada, Oct 2021.

[39] Y. E. Sagduyu, Y. Shi, and T. Erpek, “IoT Network Security from
the Perspective of Adversarial Deep Learning,” in Proc. IEEE SECON,
Boston, USA, Jun 2019.

[40] A. Sivanathan, H. H. Gharakheili, and V. Sivaraman, “Managing IoT
Cyber-Security using Programmable Telemetry and Machine Learning,”
IEEE Transactions on Network and Service Management, vol. 17, no. 1,
pp. 60–74, 2020.

[41] A. Sivanathan, H. Habibi Gharakheili, F. Loi, A. Radford, C. Wije-
nayake, A. Vishwanath, and V. Sivaraman, “Classifying IoT Devices
in Smart Environments Using Network Trafﬁc Characteristics,” IEEE
TMC, vol. 18, no. 8, pp. 1745–1759, Aug 2019.

[42] A. Sivanathan, H. Habibi Gharakheili, and V. Sivaraman, “Detecting
Behavioral Change of IoT Devices using Clustering-Based Network
Trafﬁc Modeling,” IEEE Internet of Things Journal, vol. 7, no. 8, pp.
7295–7309, Aug 2020.

[43] A. Sivanathan, D. Sherratt, H. H. Gharakheili, A. Radford, C. Wije-
nayake, A. Vishwanath, and V. Sivaraman, “Characterizing and Clas-
sifying IoT Trafﬁc in Smart Cities and Campuses,” in Proc. IEEE
INFOCOM Workshops, Atlanta, USA, May 2017.

[44] Verimatrix, “IoT security for

today’s connected world.” [Online].

Available: https://www.verimatrix.com/markets/internet-of-things
[45] P. V¨ah¨akainu, M. Lehto, and A. Kariluoto, “IoT-based Adversarial
Attack’s Effect on Cloud Data Platform Service in Smart Building’s
Context,” in Proc. ICCWS, Norfolk, USA, Mar 2020.

[46] H. Wang and C. Yu, “A Direct Approach to Robust Deep Learning
Using Adversarial Networks,” arXiv e-prints, p. arXiv:1905.09591, May
2019.

[47] C. Xie, Y. Wu, L. Maaten, A. L. Yuille, and K. He, “Feature Denoising
for Improving Adversarial Robustness,” in Proc. IEEE CVPR, CA,
USA, Jun 2019.

[48] ZDNet, “Ransomware attack halts production at IoT maker Sierra Wire-
less,” Mar 2021. [Online]. Available: https://www.zdnet.com/article/
ransomware-attack-halts-production-at-iot-maker-sierra-wireless/
[49] C. Zhang, H. Zhang, and C.-J. Hsieh, “An Efﬁcient Adversarial Attack

for Tree Ensembles,” in Proc. NeurIPS, Virtual, Dec 2020.

[14] Y. Ding, L. Wang, H. Zhang, J. Yi, D. Fan, and B. Gong, “Defending
Against Adversarial Attacks Using Random Forests,” in Proc. CVPR,
Long Beach, CA, USA, Jun 2019.

[15] R. Doshi, N. Apthorpe, and N. Feamster, “Machine Learning DDoS
Detection for Consumer Internet of Things Devices,” in Proc. IEEE
S&P Workshops, San Francisco, CA, USA, May 2018.

[17]

[16] A. Ferdowsi and W. Saad, “Generative Adversarial Networks for
Distributed Intrusion Detection in the Internet of Things,” in Proc. IEEE
GLOBECOM, Waikoloa, USA, Dec 2019.
I. J. Goodfellow, J. Shlens, and C. Szegedy, “Explaining and Harnessing
Adversarial Examples,” arXiv e-prints, p. arXiv:1412.6572, Dec 2014.
[18] A. Hamza, H. Habibi Gharakheili, T. A. Benson, and V. Sivaraman,
“Detecting Volumetric Attacks on IoT Devices via SDN-Based Moni-
toring of MUD Activity,” in Proc. ACM SOSR, CA, USA, Apr 2019.
[19] A. Hamza, D. Ranathunga, H. Habibi Gharakheili, T. A. Benson,
M. Roughan, and V. Sivaraman, “Verifying and Monitoring IoTs Net-
work Behavior using MUD Proﬁles,” IEEE Transactions on Dependable
and Secure Computing, pp. 1–1, 2020.

[20] O. Ibitoye, O. Shaﬁq, and A. Matrawy, “Analyzing Adversarial Attacks
Against Deep Learning for Intrusion Detection in IoT Networks,” in
Proc. IEEE GLOBECOM, Waikoloa, USA, Dec 2019.
IBM X-Force Research, “The weaponization of IoT devices,” 2017.
[Online]. Available: https://www.ibm.com/downloads/cas/6MLEALKV
[22] A. Kantchelian, J. D. Tygar, and A. D. Joseph, “Evasion and Hardening

[21]

of Tree Ensemble Classiﬁers,” in Proc. ICML, NY, USA, Jun 2016.

[23] Z. Katzir and Y. Elovici, “Quantifying the Resilience of Machine
Learning Classiﬁers Used for Cyber Security,” Expert Systems with
Applications, vol. 92, pp. 419–429, Feb 2018.

[24] T. M. Khoshgoftaar, M. Golawala, and J. V. Hulse, “An Empirical Study
of Learning from Imbalanced Data Using Random Forest,” in Proc.
IEEE ICTAI, Patras, Greece, Oct 2007.

[25] M. K¨uhrer, T. Hupperich, C. Rossow, and T. Holz, “Hell of a Hand-
shake: Abusing TCP for Reﬂective Ampliﬁcation DDoS Attacks,” in
Proc. USENIX WOOT, San Diego, USA, Aug. 2014.

[26] M. Labs,

“McAfee Labs

2019 Threats Predictions Report,”

https://www.mcafee.com/blogs/other-blogs/mcafee-labs/mcafee-labs-
2019-threats-predictions/, 2018.

[27] Y. LeCun, C. Cortes, and C. J. Burges, “The MNIST database of
handwritten digits,” 1998. [Online]. Available: http://yann.lecun.com/
exdb/mnist/

[28] M. Lyu, D. Sherratt, A. Sivanathan, H. H. Gharakheili, A. Radford, and
V. Sivaraman, “Quantifying the Reﬂective DDoS Attack Capability of
Household IoT Devices,” in Proc. ACM WiSec, Boston, USA, Jul 2017.
“New Vulnerability Allows DDoS Attack
2020.
https://www.cpomagazine.com/cyber-security/

and Data Exﬁltration
[Online]. Available:
new-vulnerability-allows-ddos-attack-and-data-exﬁltration-on-billions-of-devices/

[29] C. Magazine,

of Devices,”

on Billions

Jun

[30] H. Mahmudul, M. M. Islam, M. I. I. Zarif, and M. M. A. Hashem,
“Attack and Anomaly Detection in IoT Sensors in IoT Sites Using
Machine Learning Approaches,” Elsevier Internet of Things, vol. 7, p.
100059, Sep 2019.

[31] M. Miettinen, M. S, I. Hafeez, T. Frassetto, N. Asokan, A. R. Sadeghi,
and S. Tarkoma, “IoT SENTINEL: Automated Device-Type Identiﬁca-
tion for Security Enforcement in IoT,” in Proc. IEEE ICDCS, Atlanta,
USA, June 2017.

15

