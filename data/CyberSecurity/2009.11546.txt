DSMIX: A Dynamic Self-organizing Mix
Anonymous System
Renpeng Zou∗, Xixiang Lv∗,
∗School of Cyber Engineering, Xidian University, Xian 710071, China

1

0
2
0
2

p
e
S
4
2

]

R
C
.
s
c
[

1
v
6
4
5
1
1
.
9
0
0
2
:
v
i
X
r
a

Abstract—Increasing awareness of privacy-preserving has led
to a strong focus on anonymous systems protecting anonymity.
By studying early schemes, we summarize some intractable
problems of anonymous systems. Centralization setting is a
universal problem since most anonymous system rely on central
proxies or presetting nodes to forward and mix messages, which
compromises users’ privacy in some way. Besides, availability
becomes another important factor limiting the development of
anonymous system due to the large requirement of additional ad-
ditional resources (i.e. bandwidth and storage) and high latency.
Moreover, existing anonymous systems may suffer from different
attacks including abominable Man-in-the-Middle (MitM) attacks,
Distributed Denial-of-service (DDoS) attacks and so on. In this
context, we ﬁrst come up with a BlockChain-based Mix-Net
(BCMN) protocol and theoretically demonstrate its security and
anonymity. Then we construct a concrete dynamic self-organizing
BlockChain-based MIX anonymous system (BCMIX). In the
system, users and mix nodes utilize the blockchain transactions
and their addresses to negotiate keys with each other, which
can resist the MitM attacks. In addition, we design an IP
sharding algorithm to mitigate Sybil attacks. To evaluate the
BCMIX system, we leverage the distribution of mining pools
in the real world to test the system’s performance and ability
to resistant attacks. Compared with other systems, BCMIX
provides better resilience to known attacks, while achieving low
latency anonymous communication without signiﬁcant bandwidth
or storage resources.

Index Terms—Anonymous systems, blockchain, anonymity,

self-organizing, mix network attacks.

I. INTRODUCTION

K EEPING communication private has become increasing

important in an era of mass surveillance and carriers-
sponsored attacks. Recently, many events about private data
leakage in Online Social Networks (OSNs) [1], mobile net-
work service (Uber, Didi Chuxing) [2] and telephone commu-
nications [3] have occurred frequently. Thus it is often the case
that two parties want to communicate anonymously, which
means to exchange messages while hiding the fact that they
are in conversation.

In this context, the anonymous communication technology
emerges as a critical topic. Aiming to preserve communica-
tion privacy within the shared public network environment,
anonymous communication mainly focus on how to hide the
identities or address information of one side or both sides
in communications. Since the seminal work by Chaum [4]
for anonymous communication, more than seventy anonymous
systems have been proposed, based on different anonymous
mechanism [5]. Generally, anonymous systems can be di-
vided into the following sub-types, mix re-encryption, mul-
ticast/broadcast, mix multi-layer encryption and peer-to-peer.

There are, however, concerns about the lack of efﬁciency
and security in anonymous systems [6], [7], as explained
below:

• Centralization. Most of

systems,

anonymous

i.e.
Anonymizer [8], LPWA [9] and cMix [10], rely on central
proxies or preset nodes to hide the address information,
then still use these proxies to blind and forward messages.
The centralized anonymous systems bring privacy leakage
risks to users since the service providers can control
all proxies and mix node to infer the users’ identities.
What’s worse, the public proxies or preset nodes are
easily exposed to attackers. For instance, an attacker can
launch distributed denial-of-service attacks to block one
or more proxies and thus crash the system.

• Availability. Efﬁciency and additional

resources are
the main factors affecting the availability of anony-
mous systems. High-latency anonymous systems such
as OneSwarm [11] and A3 [12], though provide high
anonymity, are not well suited for practical utilization
because of the poor efﬁciency in terms of intolerable la-
tency [11]. In order to hide the identities of the recipients,
multicast/broadcast and peer-to-peer based anonymous
systems consume more bandwidth resources to cover the
normal trafﬁcs [13]. In spite of effectiveness, users may
not be willing to contribute a lot of bandwidth, which
hinders the development of such anonymous systems. In
addition, some anonymous systems, such as cMix, adopt
additional inspection schemes to identify the malicious
nodes, which would place an additional burden on users
and decrease message utilization.

• Security. Along the research line about security, anony-
mous systems based on different mechanism may suffer
from different security issues. Some anonymous systems
based on MIX technologies rely on ﬁxed cascade nodes to
mix and forward messages. Such systems are vulnerable
to collusion-tagging attacks which is hard to detect. Re-
routing or proxy forwarding based anonymous systems,
such as Tor [14] and Tarzan [15], deliver messages
through nodes or proxies randomly selected from clusters,
hence an eavesdropper can perform trafﬁc analysis attacks
and destroy the anonymity. As for multicast/broadcast
based anonymous system, an attacker can masquerade
as the benign recipients to intercept the messages. With
respect to the P2P based anonymous systems, an attacker
can create multiple identities to launch a Sybil attack,
which allows the attacker to analyze the forwarding

 
 
 
 
 
 
path and impersonate the recipient to receive the mes-
sages. Moreover, in anonymous systems applying key
exchange schemes, an attacker can employ Man-in-the-
Middle (MitM) attacks [16] to undermine the security of
these systems.

A. Solutions and Contributions

Motivated by these identiﬁed limitations, we combine
blockchain technology with mix network, and design a dy-
namic self-organizing blockchain-based mix anonymous sys-
tem. We expect to dispose of the following challenges.

Challenge 1. Designing a decentralized self-organizing
anonymous system. The ﬁrst challenge we seek to address
is the centralization issues. As we mention above, the central
proxies or preset nodes might pry into users’ private data and
reveal the true identities. Therefore, we intend to construct a
decentralized anonymous system in which the mix nodes are
dynamic and self-organizing.

Solution 1. When it comes to decentralization, the most
popular technology is blockchain, an emerging decentralized
architecture and distributed computing paradigm underlying
Bitcoin [17] and other cryptocurrencies. Leveraging the dy-
namic and decentralized properties of blockchain miners, we
devise voting algorithms to elect mix nodes from blockchain
miners. This trustless and distributed design not only prevents
privacy leakage from service provides, but also mitigates
single point failure and DDos attacks.

Challenge 2. Designing a user friendly anonymous
system. Another challenge is to construct an anonymous
system with high availability. In fact, users are often reluctant
to consume more additional resources (i.e. bandwidth and
computing resources) and wait for a long time. Thus we are
drove to build a high available anonymous system with less
additional resources.

Solution 2. Our proposed solution is inspired by cMix.
Similar to cMix, we also split the time-consuming, compli-
cated public key operations with the real time phase. The
difference is that cMix adopts ﬁxed mix nodes with a stable
joint public key while our approach leverages the dynamic
blockchain miners to compete for mix nodes, which brings a
problem that the elected mix nodes (miners) have to negotiate
a joint public key in each round. To avoid interacting with
other mix nodes in each round, we ﬁrstly propose a revised
additive homomorphism mix-net protocol. Then we combine
the protocol with Bitcoin account schemes, such that
the
elected mix nodes can calculate the system public key in a
non-interactive manner. It is worth noting that no additional
resources are required in BCMIX other than the miners’
computing power for solving Bitcoin puzzles.

Challenge 3. Designing a secure anonymous system. The
most intractable challenge is building a secure anonymous
system. Based on different principles, anonymous systems
are assailable to disparate attacks including internal attacks
and external attacks. The internal attacks , i.e. trafﬁc analysis
attacks, DDos attacks and so on, are caused by the design
principles of systems while the external attacks, such as
MitM attacks and Sybil attacks, arise from the cryptographic

2

protocols or other schemes utilized in anonymous systems. In
the case, we intend to construct an anonymous system which
can resist the attacks mentioned above.

Solution 3. Through the former schemes we found mix
technology can defend against most kind of attacks on anony-
mous systems except bring the centralization problem and
tagging attacks. To mitigate the weakness, our ﬁrst con-
sideration is combining blockchain and mix technology, as
mentioned in Solution 1. Unfortunately, the introduction of
blockchain raises the Sybil attacks into the anonymous system.
By researching the properties of Sybil attacks we structure
PoW voting and IP sharding algorithms to mitigate the impact
of Sybil attacks. For MitM attacks, we design a transaction-
based key exchange scheme which makes use of the Bitcoin’s
transaction propagation mechanism to break the single-channel
control of attackers. The detailed illustration is provided in
Section V and Section VI.

To summarize, the contributions of this paper are as follows.
a blockchain-based mix-net protocol
• We propose
(BCMN) whose security and anonymity are demonstrated
theoretically. Especially, we elect miners as mix nodes via
special algorithms to avoid the centralized settings.

• We construct a dynamic self-organizing blockchain-based
mix anonymous system (upon the proposed BCMN proto-
col) and discuss how the proposal can satisfy the security
requirements.

• We demonstrate the feasibility and effectiveness of the
proposed BCMIX by developing the system in an analog
network with the miner distribution data in the real world.
Compared with existing systems, our system performs
well and provides stronger security.

B. Related Works

Generally, anonymous communication systems can be di-
vided into the following sub-types, mix re-encryption, mul-
ticast/broadcast, mix multi-layer encryption and peer-to-peer.
Mix re-encryption based anonymous systems [18], [19] lever-
age cryptography technologies to dispose messages and hide
the users’ identities, which can resist trafﬁc analysis attacks.
But with the utilizing of public key cryptography, mix re-
encryption based anonymous systems is expensive and easy
to waste resources. To settle the problem, Chaum et.al [10]
proposed a anonymous system called cMix in 2017. Through
a precomputation, the core cMix protocol eliminates all expen-
sive real time public-key operationsat the senders, recipients
and mix nodes, thereby decreasing real time cryptographic
latency and lowering computational costs for clients. The
core real
time phase performs only a few fast modular
multiplications. The authors claim that cMix can detect the
malicious nodes by utilizing Random Partial Checking (RPC)
and commitment scheme.

Multicast/broadcast based anonymous communication sys-
tems [20], [21] achieve anonymity through one-to-many com-
munications among hosts. This method is expensive and inef-
ﬁcient for non-broadcast networks. In the case of large scale
networks, an attacker can easily masquerade as the recipient to
intercept the message, which further increases the computation
and communication overhead required for authentication.

As for mix multi-layer encryption based anonymous sys-
tems [22] [14] [23], one or more proxies are selected from
the cluster, and forward the messages from the former nodes
and then the messages in a confusing order. The technology
can achieve low-latency communications under the premise of
ensuring efﬁciency, but is vulnerable to analyzing attacks such
as trafﬁc analysis attacks and sniper attacks [24].

The rapid development of peer-to-peer (P2P) networks
drives the research of anonymous communication technology
in P2P network environment [25]. In P2P based anonymous
systems [26], [27] nodes enjoy anonymous services, and
provide anonymous services for other nodes in their spare
time. Because the P2P network itself has a high degree of
self-organization and disorder, and the number of members
is large, the P2P network can also provide a high degree
of anonymity when the attacker has a huge attack resource.
However, because of its openness and anonymity, the attacker
can control a large number of zombie nodes to launch witch
attacks, and can disguise as normal nodes for trafﬁc analysis,
thereby destroying the system’s anonymity without being
noticed.

C. Roadmap

The rest of this paper is organized as follows. In Section
II, we review some preliminaries and propose an attacks
against cMix. In Section III, we illustrate the security model
and requirements. Nest, we detail the BCMN protocol and
the proposed BCMIX in Section IV. Then we evaluate the
performance and demonstrate security respectively in Section
V and Section VI. Finally, this paper is concluded in Section
VII.

II. PRELIMINARIES AND PROPOSED ATTACKS ON CMIX

In this section we brieﬂy review the relevant notations and
deﬁnitions that are used in this paper. Then we describe some
attacks against cMix.

A. Elliptic Curve based Cryptographic Primitives

In this work, we adopt elliptic curves over prime ﬁnite ﬁeld
Fp. The elliptic curve y2 = x3 + ax + b over Fp could be
represented as Ep(a, b).

EC-Elgamal. The analog of ElGamal crypto system based
on ECC, which is known as EC-Elgamal, was ﬁrst introduced
in [28]. It consists of the following algorithms.

• Setup(1K). The algorithm takes as input the security
parameter K, and outputs the elliptic curve Ep(a, b) with
base point G.

• KeyGen. For the elliptic curve Ep(a, b) with base point
G, pick k R←−Fp and compute K = kG. Set P K = K
and SK = k.

• Enc(m, P K, r). For the plaintext point m, pick r R←−Fp.
Compute C1 = rG, C2 = m + rK. Set ciphertext points
C = (C1, C2).

• Dec(C, SK). For the ciphertext C, compute m(cid:48) = C2 −

kC1.

3

Deﬁnition 1. Suppose p is a prime and Ep(a, b) is an elliptic
curve. For the two points G and Q on the elliptic curve, they
satisfy Q = kG. It can be proved that it is easier to calculate
Q from k and G. However, it is difﬁcult to calculate k from
Q and G [29].

The security of ECC is based on Elliptic Curve Discrete
Logarithm Problem (ECDLP) which is consider to be compu-
tationally infeasible to solve.

ECDH Key Exchange. Elliptic Curve Difﬁe-Hellman
(ECDH) key exchange is the elliptic cuive analogue of the
classical Difﬁe-Hellman key exchange operating in Z∗
p. We
describe two communicating parties, usually called Alice and
Bob, establish a shared secret key in secure communication
channel as follows. We assume that Alice and Bob use the
same set of domain parameters D := (p, a, b, G, n, h) for their
computations.

• Alice generates an ephemeral key pair (kA, QA), i.e.
he/she generates a random number kA in [1, n − 1]
and then performs a scalar multiplication to get
the
corresponding public key QA = kA ·G. Then Alice sends
QA to Bob.

• Bob generates an ephemeral key pair (kB, QB) with
(QB = kB · G) in the same way and sends QB to Alice.
• After Alice receives QB, he/she performs a scalar multi-

plication to obtain the shared secret S = kA · QB.

• After Bob receives QA from Alice, he/she obtains the

shared secret through computation of S = kB · QA

The security of the ECDH protocol relies on the intractabil-
ity of (computational) Elliptic Curve Difﬁe-Hellman Problem
(ECDHP). That is, given an elliptic curve Ep(a, b), a base
point G ∈ E(FP ), and two points QA = kA · G and
QB = kB ·G, ﬁnd the point S = kA ·kB ·G without knowledge
of kA, kB. It is clear that an algorithm for solving a generic
ECDLP instance would allow one to solve the ECDHP as well.

B. Veriﬁable Random Function.

A Veriﬁable Random Function (VRF) [30] is the public-key
version of a keyed cryptographic hash. In this application, a
Prover holds the VRF secret key and uses the VRF hashing to
construct a hash-based data structure on the input data. Due
to the nature of the VRF, only the Prover can answer queries
about whether or not some data is stored in the data structure.
Anyone who knows the public VRF key can verify that the
Prover has answered the queries correctly. A VRF is a triplet of
algorithms VRF := (Gen, Eval, Vfy) providing the following
functionalities.

• Gen(1K). The key generation algorithm is a probabilistic
algorithm that takes as input the security parameter K
and outputs a key pair (vk, vsk). We say that vsk is the
secret key and vk is the veriﬁcation key.

• Eval(vsk, X). The deterministic algorithm on input the
secret key vsk and X ∈ {0, 1}k and outputs a function
value Y ∈ Y, where Y is a ﬁnite set, and a proof π. We
write Vvsk(X) to denote the function value Y computed
by Eval on input (vsk, X).

• Ver(vk, X, Y, π). The veriﬁcation algorithm takes as in-
put (vk, X, Y, π) and outputs a bit b ∈ {0, 1} indicating
whether or not π is a valid proof.

4

−−−−→
inputs,

−−−−−→
outputs, sig), where

Blockchain Basics. We review some basic components
of a proof-of-work blockchain [31]. We deﬁne a transaction
−−−−−→
tx := (
outputs
are the inputs and outputs of a UTXO-based model,
sig is
the signature signed by the transaction sender.
the form B := (s, x, txs, ctr),
A block is a triple of
s ∈ {0, 1}K, x ∈ {0, 1}∗, ctr ∈ N, where s is the state of the
previous block, x is the data and ctr is the proof of work of
the block. A block B is valid iff

−−−−→
inputs and

validBlockD(B) := H(ctr, T (s, x, txs)) < D.
Here, H : {0, 1}∗ → {0, 1}K and T : {0, 1}∗ → {0, 1}K
are cryptographic hash functions, and the parameter D ∈ N is
the difﬁculty level of the block.

A chain is simply a chain of blocks, that we call C. The
rightmost block is called the head of the chain, denoted by
Head(C). Any chain C with a head Head(C) := (s, x, ctr) can
be extended to a new longer chain C(cid:48) := C||B(cid:48) by attaching a
block B(cid:48) := (s(cid:48), x(cid:48), ctr(cid:48)) such that s(cid:48) = H(ctr, G(s, x)); the
head of the new chain C(cid:48) is Head(C) := B(cid:48). We let C := ε to
express a chain C is empty. The function len(C) denotes the
length of a chain C.

For a chain C of length n and any q > 0, we denote by
C(cid:112)q the chain resulting from removing the q rightmost blocks
of C, and analogously we denote by C(cid:113)q the chain resulting
in removing the q leftmost blocks of C; note that if q ≥ n
then C(cid:112)q := ε and C(cid:113)q := ε. If C is a preﬁx of C(cid:48) we write
C ≺ C(cid:48). We also leverage slot which is deﬁned in [ []]. A
slot is the continuous amount of divided time. Each slot slotl
is indexed for l ∈ {1, 2, 3, · · · }. We assume that users have a
synchronised clock that indicates the current time down to the
smallest discrete unit.

Blockchain protocol. With the illustrations of the basic
components, we describe the blockchain protocol [31] Γ =
(Γ.KeyGen, Γ.Update, Γ.Validate, Γ.Broadcast) as follows.

• {pk, sk} ← Γ.KeyGen: The algorithm generates the key

pair (pk, sk) of the blockchain nodes.

• {C(cid:48), ⊥} ← Γ.Update: This algorithm returns a longer
and valid chain C in the network (if it exists), otherwise
returns ⊥.

• {0, 1} ← Γ.Validate: The validity check algorithm takes
as inputs a transaction tx, a block B or a chain C and
returns 1 iff the transaction, the block or the chain is valid
according to a public set of rules.

• Γ.Broadcast: The algorithm takes as inputs some txs and
broadcasts it to all the nodes of the blockchain system.
The security of a PoW blockchain protocol Γ is charac-
terized by three properties, namely: Chain Growth, Chain
Quality and Common P ref ix [31].

Chain growth. The chain property quantiﬁes the number
of blocks that are added to the blockchain during any given
number of slots.

Deﬁnition 2. (Chain Growth). Consider the chains C1, C2
possessed by two honest parties at the onset of two slots slot1,

Fig. 1. Workﬂow of cMix.

slot2, with slot2 at least s slots ahead of slot1. Then it holds
that len(C2) − len(C1) ≥ τ · s, for s ∈ N and 0 < τ ≤ 1, where
τ is the speed coefﬁcient.

Chain Quality.The chain quality property informally states
that the ratio of adversarial blocks in any segment of a chain
held by a honest party is no more than a fraction µ, where µ
is the fraction of resources controlled by the adversary.

Deﬁnition 3. (Chain Quality). Consider a portion of length
(cid:96)-blocks of a chain possessed by an honest party during any
given slot intervals, for (cid:96) ∈ N. Then, the ratio of adversarial
blocks in this (cid:96) segment of the chain is at most µ, where
0 < µ ≤ 1 is the chain quality coefﬁcient.

Common Preﬁx. The common preﬁx property informally
says that if we take the chains of two honest nodes at different
times slots, the shortest chain is a preﬁx of the longest chain.

Deﬁnition 4. (Common Preﬁx). The chains C1, C2 possessed
by two honest parties at the onset of the slots slot1 < slot2
are such that C(cid:112)k
1 denotes the chain obtained
by removing the last k blocks from C1, where k ∈ N is the
common preﬁx parameter.

1 (cid:22) C2, where C(cid:112)k

C. cMix Anonymous System

The cMix protocol by Chaum et al. [10] is a new mix-net
protocol which aims to provide an anoymous communication
tool for users at large scales. In contrast with existing mix-net
systems, cMix provides signiﬁcant performance and security
upgrades. Figure 1 brieﬂy describes the workﬂow of cMix. The
protocol contains two participants: U sers := (U1, · · · , Uβ)
and mix nodes := (N1, · · · , Nn). Each node Ni holds a
tuple of the form (πi, ri,j, si,j, Ki,t, E(·), D(·)), where πi is
a random permutation, ri,j, si, j ∈ G(i (cid:54)= j) is the random
elements in cyclic group G, Ki,t ∈ G denotes the shared group
element between node Ni and user Ut, E(·) and D(·)) denotes

Node 1Node nNode 2Node nNode 1Node 2                                                                                                                                                                                                                                                          Node 1Node nNode 2Node nNode 1Node 2                                                                                                                             (a) Precommunication Phase(b) Real time Phasethe encryption and decryption algorithm of Elgamal. The
detailed description of cMix protocol is provided in Appendix
A.

We now present a collision tagging attack on cMix protocol.
The attacker have to compromise the last node Nl and any mix
node Ni. To launch the attack, only small changes are needed
to the protocol:

• Precomputation Phase- Step 3: The mix node Ni
calculate the decryption share D( (cid:126)C1) with the vector
(1, · · · , t−1, · · · , 1) and commit to the D( (cid:126)C1).

• Real time Phase- Step 1: The mix node Ni adds tag
(1, · · · , t, · · · , 1) to (cid:126)m, and sends (cid:126)m to the next mix node.
• Real time Phase- Step 3: The last node publish the
output of the mixing step Πh( (cid:126)m × (cid:126)Rh) × (cid:126)Th. Afterwards,
all mix nodes release their decryption shares Di( (cid:126)C1)
and the message component of the ciphertext (cid:126)C2. The
mix node Ni waits for other mix nodes to publish their
decryption ﬁrst, then Ni collude with Nl to obtain the
message package with the tagged messages. After that,
Ni publish D( (cid:126)C1).

The mix node Ni and Nl get

the location of the tag
message in advance, and the mixed messages are the same
from the senders’ perspective. Thus the attacker can break the
anonymity of cMix.

III. SECURITY MODEL AND REQUIREMENTS

In this section, we present our proposed system model
for BCMIX and the related security requirements. The com-
munication methods among them include transactions and
Transport Layer Security (TLS), where the former is an on-
chain communication (i.e., publishing a transaction using P2P
communications) and the latter is an off-chain communication
(i.e., establishing a secure communication channels among mix
nodes).

A. System Model

There are three entities in our proposed BCMIX, that is,

Miners, Mix nodes and Senders (see Figure 2).

• Miners: These entities validate new transactions and
record them on the global ledger. Simultaneously, the
entities compete to solve a difﬁcult mathematical puzzle
based on a cryptographic hash algorithm. In BCMIX,
miners are eligible to become mix nodes through PoW
algorithm competition. Miners disclose their addresses in
the form of (addressM , pkM ) where addressM is the
blockchain address and pkM is the blockchain public key
deriving the related address.

• Mix nodes: These entities are selected from miners
through the PoW and VRF algorithm. After being elected
as mix nodes successfully, these entities ﬁrstly negotiate
keys with senders in the set up phase. Then they execute
the precomputation and real time phase to encrypt and
mix the messages during the duty period and pass the
message down. Besides,
to their
computations and send special transactions to blockchain
network for subsequent auditing.

they should commit

5

Fig. 2. Architecture of blockchain-based mix anonymous system. Before
anonymity phase, we elect miners in node pools to serve as mix nodes via
designed algorithms. During anonymity phase, mix nodes mix and forward
messages from users through Transport Layer Security (TLS). Meanwhile,
mix nodes sends special transactions to blockchain for auditing.

• Senders: These entities refers to BCMIX users, who hold
the respective accounts addressU , pkU . Before accessing
to the anonymous service, senders send transactions to
mix nodes and negotiate the corresponding keys with
mix nodes. Then in the real time phase, senders blind
messages with the shared keys and send the message to
the ﬁrst mix nodes.

B. Threat Model

BCMIX assumes authenticated communication channels
among all mix nodes Therefore, we consider a malicious
adversary (a.k.a Byzantine), who can delay, drop, eavesdrop,
forward, and delete messages between mix nodes, but not
modify, replay, or inject new ones, without detection. For
any communication not among mix nodes, we assume the
adversary can delay, drop, re-order, eavesdrop, modify, or
inject messages at any point of the network. BCMIX accepts
one message per user per batch, starting the pre-computation
once the batch reaches β messages.

The adversary can also create a lot of accounts and compro-
mise an arbitrary numbers of users. In addition, we assume the
adversary can control more than 50% of the system computing
powers. However, such adversary is not able to read the
contents of the messages. We assume the security of the used
cryptographic primitives, including a secure hash function and
a secure signature scheme.

C. Security Requirements

According to the existing literature [5], [32], [33], BCMIX
needs to satisfy the following fundamental security require-
ments.

• Resistance to Sybil Attacks. BCMIX should minimize
the possibility of an attacker being successfully selected
as multiple mix nodes at the same time.

• Resistance to Collision Tagging Attacks. BCMIX
should prevent collision attackers from performing tag-
ging attacks to link a message to a certain sender.

  Mix node 1BlockchaintxSendersReceiversTLSTLSMix node iMix node nMinersMinersMiners  txtxNode pools• Sender Anonymity. BCMIX provide sender anonymity
for users. That is, every mix node performs mixing oper-
ations on messages, destroying the associations between
senders and receivers. Thus an attacker can not associate
teh export messages with a certain sender.

• Resistance to MitM attacks. BCMIX should prevent an
attacker from replacing the shared keys between senders
and mix nodes.

• Single Point of Failure Resilience. In case of single
point of failure (e.g. a mix node is under denial of service
attacks or the mix node is crashed), BCMIX should detect
the failure and guarantee the system keep operating.
• Resistance to Other Attacks. BCMIX should resist com-
mon attacks on mix-net system such as replay attacks,
trafﬁc-analysis attacks and so on.

IV. PROPOSED BCMIX SYSTEM

In this section, we will present our construction of BCMIX
system. We ﬁrst introduce an additive homomorphism mix-net
protocol and then we propose the blockchain based mix-net
protocol. Thereafter, we describe the concrete BCMIX system.

A. Additive Homomorphism Mix-net Protocol

To solve the MitM attacks of key agreement process and the
dependency on trusted entities, we replace Elgamal in cMix
[10] with EC-Elgamal and propose an additive homomorphism
mix-net protocol ∆ to integrate the mix-net protocol with the
blockchain.

Our mix-net protocol contains two participants, Senders :=
(U1, · · · , Uβ) and mix nodes := (N1, · · · , Nn), where the
mix nodes are selected from the blockchain miners. Mix
nodes negotiate keys with senders by means of a special
transaction txKE and calculate the system public key through
N , pki
their address pair (addressi
M = Qi. (We
will describe these two processes in the next part). We suppose
a authenticated communication among mix nodes and we
denote it as ∆.TLS. The proposed mix-net protocol is a tuple
of algorithms (Setup, Precom, RealTime). The notations and
the processes of the protocol ∆ are presented in Table I and
Algorithm 1.

N ), where pki

B. Basic Components of the Proposed Blockchain Protocol

We build our blockchain protocol Γ∗ by extending and
modifying the aforementioned protocol Γ. We ﬁrst deﬁne the
basic components in our blockchain protocol.

Transaction. Our blockchain contains three types of trans-
action, namely normal transaction txN , key-exchange transac-
tion txKE and commitment transaction txCOM . The normal
transaction txN is the same deﬁnition of the transaction that
in protocol Γ. We deﬁne a key-exchange transaction txKE :=
−−−−−→
outputs, sig) and a commitment transaction
(KE , pk,
txCOM := (COM , commitment, sig), where KE , COM
denotes the transaction type, pk is the blockchain public key of
the sender, commitment is the commitment value issued by
−−−−−→
outputs, sig are the same as the above
mix nodes and
deﬁnition. A key-exchange transaction is used to negotiate

−−−−→
inputs,

−−−−→
inputs,

6

TABLE I
NOTATIONS OF THE REVISED MIX-NET PROTOCOL

Symbol
di
Qi
Q
EQ()
Ddi ()

ri,a

si,a

πi

Πi
ki,j

ki

Kj

Mj

Ri,

Si

i xi)di · G;

i xi · G) =

Description
the secret share for mix node Ni of the secret key d, di ∈ Fp;
the public key of mix node Ni, Qi = diG;
the public key of the system, Q = (cid:80)
i Qi;
EQ(m) = (x · G, m + x · Q), x ∈ Fp;
the decryption share of mix node Ni, Ddi ((cid:80)
((cid:80)
random values (freshly generated for each round) of mix node
Ni for groove a;
random values (freshly generated for each round) of mix node
Ni for groove a;
a random permutation of the β grooves used by mix node
Ni;
the permutation performed by BCMix through mix node Ni;
a group element shared between mix node Ni and the sending
user for groove j. These values are used as keys to blind
messages;
the vector of derived secret keys shared between mix node
Ni and all users in a batch, i.e. ki = (ki,1, · · · , ki,β );
the product of all shared keys for the sending user of slot j,
i.e. Kj = (cid:81)n
the message sent by user j. Like other values in the system,
these vlaues are group elements;
the product of all local random r values through mix node
Ni, Ri = (cid:81)i
the product of all local random s values through mix node

i=1 ki,j ;

j=1 rj ;

(cid:40)

Ni, Si =

s1
πi(Si−1) × si 1 < i ≤ n

i = 1

.

Fig. 3. Chain Structure of BCMIX

keys between senders and mix nodes, while a commitment
transaction is released to supervise the behavior of mix nodes.
Block and Chain. According to the transaction type
involved, we deﬁne three blocks respectively called main
block BM , key-exchange block BKE and commitment block
BCOM , where BM := (ske , scom , x, txN s, ctr), BKE :=
(s, x, txKE s) and BCOM := (s, x, txCOM s). Here s is the
state of the previous block, ske is the state of previous blocks,
x is the data and ctr is the proof of work of the block.

A chain C is the form of C := (CM , CKE , CCOM ), where
CM , CKE and CCOM respectively represent main chain, key-
exchange chain and commitment chain in Figure 3. We deﬁne
a stable main block Bi
M as the origin of the key-exchange
chain CKE and commitment chain CCOM .

Deﬁnition 5. Let two chains C1, C2 are possessed by two
honest parties at the onset of the slots slot1 < slot2, if C(cid:112)w
1 (cid:22)

01ijnnewMain blockCommit blockKey exchange block(cid:112)(w+1)
1

C1 and C
and Bi

(cid:14) C1, then we call Cw
M where i ∈ [1, w] are stable main blocks.

M is a stable main chain

Note that the BKE and the BCOM do not contain proof of
work, thus an adversary can manipulate the contents of these
blocks. To avoid the problem we specify that the latest main
and Blatest
always contains the states of Blatest
block Blatest
COM .
We further give out the deﬁnition of valid blocks.

KE

M

Deﬁnition 6. We say blocks BN , BKE and BCOM are valid
iff

• The transactions contained in BN , BKE and BCOM are

valid;

main

• For
two
any
:=
(sp
N s, ctri)
com , xi, txi
:=
com , xj, txj
N s, ctrj), where i < j. p ≥ m
(sm
and q ≥ n hold;

ke , sq
ke , sn

blocks

Bj
N

and

Bi
N

• H(ctr, T (ske , scom , x, txs)) < D.

Blockchain based mix-net protocol. Below we propose a
blockchain based mix-net protocol Γ∗ which combines the ba-
sic blockchain protocol Γ with the proposed mix-net protocol
∆. The protocol Γ has copies of all the basic functionalities
exposed by Γ and ∆ through the interfaces described above,
and adds additional algorithms including VRF, IP Sharding in
order to resist Sybil attacks. We describe the protocol Γ∗ :=
(Setup, Update, Vote, Mix, Verify, Broadcast) as follows.

• Setup. System parameters involved in our construction
are {Ep(a, b), G, G, K, H, T }, where Ep(a, b) is a non-
singular elliptic curve, G is a cyclic group which con-
sists of all points on Ep(a, b), as well as the point
at inﬁnity O, G is the base point of Ep(a, b), K is
the security parameter and H : {0, 1}∗ → {0, 1}K,
T : {0, 1}∗ → {0, 1}K are cryptographic hash functions.
Entities invoke the algorithm to generate the blockchain
key pair (pk, sk) := (qG, q), the address (address, pk)
and the VRF key pair (vk, vsk). Here q ∈ Fp is selected
by entities.

• Update. This algorithm ﬁrst invoke Γ.validate to validate
the new transactions, chains and blocks. Then returns
a longer valid chain C := (CM , CKE, CCOM ) in the
network (if it exists), otherwise returns ⊥.

• PoWVote. The algorithm take as inputs the data x, the
state s and a difﬁculty level D(cid:48) < D, where D is the sys-
tem difﬁculty level, and then computes H(ctr(cid:48), T (s, x))
where ctr(cid:48) is a random string. Thereafter, the algorithm
estimate whether Hi(ctr(cid:48), T (s, x)) < D(cid:48). If so the
algorithm outputs 1 and add the miner into a set M,
otherwise returns 0.

• IPSharding. This algorithm takes as input IP preﬁx of
miners in set M, and outputs n node pools (Miners in
each node pool have the same IP preﬁx IP/z where z is
a integer and z ∈ [0, 32].)

• VRF. The algorithm takes as inputs IP/z and the current
slot slotl, and outputs a value Y ∈ Y, where Y is a ﬁnite
set, and a proof π.

• Mix. The algorithm take as

set
U := (U1, U2, · · · , Uβ), a mix node set N :=
(N1, N2, · · · , Nn) and a message vector M . Then it

inputs a sender

7

revokes (∆.Setup, ∆.Precom, ∆.RealTime) and outputs
a permuted message vector Πn(M ).

• Verify. Given a message vector M := (m1, m2, · · · , mβ)
and a message vector M := (m(1), m(2)), · · · , m(β)),
this algorithm decides whether the following conditions
holds: For ∀i ∈ [1, β], mi ∈ M , ∃j ∈ [1, β], mj ∈ M ,
mi = mj. If so, the algorithm returns 1. Otherwise the
algorithm returns 0.

• Broadcast: The algorithm takes as inputs some txs and
address (address, pk) and broadcasts them to all the
nodes of the blockchain system.

Theorem 1. If Γ satisﬁes (τ, s)-chain growth, then Γ∗ satisﬁes
(τ, s)-chain growth.

KE, C2

KE and C1

Consider the chains C1

Proof. We note that the side chain CKE and CCOM do not
contain proof of work, and the update of CKE, CCOM is
independent of the update of CM . Thus we conclude that CM
satisﬁes (τ, s)-chain growth as the chain C in Γ. We now prove
that CKE and CCOM satisfy (τ, s)-chain growth.
COM , C2

COM at the
onset of two slots slot1, slot2, with slot2 at least s slots ahead
of slot1, and τKE, τCOM are the speed coefﬁcient of CKE and
CCOM . Since a key exchange block BKE and a commitment
block BCOM are jointly generated by all mix nodes at the
expected speed τKE and τCOM respectively, we derive that
CKE and CCOM are updated at the expected speed τKE and
τCOM . Then we hold the following two equations len(C2
KE)−
len(C1
COM ) = τCOM ·s.
Thus we conclude that CKE and CCOM satisﬁes (τ, s)-chain
growth. In summary, Γ∗ satisﬁes (τ, s)-chain growth.

KE) = τKE ·s and len(C2

COM )−len(C1

Theorem 2. Let H, G be two collision-resistant cryptographic
hash functions. If Γ satisﬁes (µ, (cid:96))-chain quality, then Γ∗
satisﬁes (µ, (cid:96))-chain quality.

Proof. We emphasize that proof of work is not contained in the
key exchange chain CKE and the commitment chain CCOM .
And the security of CKE, CCOM is depend on the security
of the main chain CM since CM takes the states of CKE and
CCOM as inputs of the proof of work. Suppose an adversary A
wants to manipulate contents of CKE and CCOM . According
to the formula H(ctr, T (ske, scom, x, txs)) < D (Deﬁnition
7.), A has to amend the corresponding main block BM . Note
that the capabilities of the adversary and external environment
in Γ∗ are exactly the same as that in Γ. Thus we can conclude
that the main chain CM is the only factor affecting the chain
quality property. We show below that A has only a negligible
probability of violating chain quality of Γ∗.

Let us denote by Bi

M the i-th block of the main chain
M · · · Blen(C)
CM at some slot intervals so that CM := B1
M .
From Deﬁnition 4. we know that the number of main blocks
generated by A in chain CM are at most µ · len(C). According
to [31], A can not generate more than µ · len(C) main blocks
with the current computing hash power. Or the adversary A
could try to build an valid candidate block B(cid:63)
M to replace a
validate block Bj
M generated by honest parties in CM , where
M (cid:54)= Bj
j ∈ [1, len(C)], B(cid:63)
M ). By the
collision-resistance property of hash function we can draw a

M and H(B(cid:63)

M ) = H(Bj

The Additive Homomorphism Mix-net Protocol ∆

8

Algorithm 1
1: procedure SETUP PHASE
2: (Q, Ki, ki,j ) ← Setup(pki
N , pkj

U ) and mix nodes Mj with address
N ), where i ∈ [1, β], j ∈ [1, n]. The algorithm takes as inputs the public key of senders and mix nodes and returns a shared key

M ): This algorithm is invoked by senders Ui with address (addressi

U , pki

U , pkj

(addressj
ki,j between a send Ui and a mix node Mj . A slot key Ki = (cid:81)n

j=1 ki,j and the system public key Q = (cid:80)

j pkj

M = (cid:80)

j Qj .

3: procedure PRECOMPUTATION PHASE Precom := (Preprocess, Mix, Postprocess)

• Preprocess. The mix nodes generate the fresh r, s, π values and computes the encryption E(r−1

). At the same time the mix nodes issues the
commitment values of the fresh values COMr, COMs, COMπ. Then they collectively compute the product of the received values by sending the
following message to the next mix node:

i

(cid:40)

EQ(Ri) =

EQ(r1)
EQ(Ri−1) × EQ(ri) 1 < i ≤ n

i = 1

Eventually, the last mix node sends the ﬁnal values EQ(Rn) to the ﬁrst mix node as input for the next step and issues the commitment value
COMEQ(Rn).

• Mix. The mix node together mix the values and compute the results Πn(Rn) × Sn, under encryption. The mix nodes perform this mixing by

having each mix node i send the following message to the next mix node:

EQ(Π(Rn) × Si) =

(cid:40)

π1(EQ(Rn) × EQ(s1))
πi(EQ(Πi−1(Rn) × Si−1)) × EQ(si) 1 < i ≤ n

i = 1

As with the ﬁrst step, the last mix node sends the ﬁnal encrypted values EQ(Πn(Rn) × Sn) to the ﬁrst mix node.

• Postprocess. To complete the precomputation, each mix node Ni computes its decryption shares Ddi ((cid:80)

i xi · G), where (x, c) = EQ(Πn(Rn) ×
of their secret shares. The message parts c are multiplied
Sn), and keep its secret. Then each mix node issues the commitment values COMDdi
with all the decryption shares to retrieve the plaintext values Πn(Rn) × Sn. The last mix node to be used in the real time phase stores the decrypted
precomputed values.

4: procedure REALTIME PHASE RealTime := (Preprocess, Mix, Postprocess)
5: Each user constructs its message M K−1

j

and combines them to get a vector M × K−1.

(for slot j) by multiplying the message Mj and it sends it to the ﬁrst mix node, which collects all messages

• Preprocess. Each node Ni sends ki × ri to the next mix node, which uses them to compute M × Rn = M × K−1 × (cid:81)(cid:81)(cid:81)n

i=1 ki × ri and the

last node sends the result to the ﬁrst node.

• Mix. Each node Ni computes πi(Πi−1(M × Rn) × Si−1) × si, where Π0 is the identity permutation and S0 = 1. The last node sends a

commitment to its message Πn(M × Rn) × Sn to every other node.

• Postprocess. Each node Ni opens its precomputed decryption share for (x, c) = ((Πn(Rn) × Sn)−1), while the last node sends its decryption
share multiplied by the value in the previous step and the message component: Πn(M × Rn) × Sn × Dn(x) × c. Finally, the permuted message
can be decrypt as Πn(M ) = Πn(M × Rn) × Sn × (cid:81)n

i=1 Di(x) × c.

6: Note: The shared key kij in Setup Phase is generated through ECDH protocol. After the mix node set (N1, N2, · · · , Nn) is selected from miners. Every sender sends

txKE s to all mix nodes. Since senders and mix nodes know the public key of each other, they can execute the ECDH protocol and obtain the shared key kij .

Fig. 4. The detailed orchestration of BCMIX.

PoW  VotingIP  Sharding Pool 1 Pool  i Pool n  VRF  VotingGenesis block Stable blocktxKEPrecommunication    BKEBCOMReal time    1. Miners invoke   PoWVote  to complete as the candidate miners.     2. The candidate  miners  invoke  IPSharding   to be classified into different pools.    3. The  candidate  miners  in different pools invoke   VRF   to complete as the current mix nodes.Vote  Phase  1.2.3.  4. Users  negotiate  keys  with  mix  nodes through  txKE  and send            to mix nodes.  5.The mix nodes execute percommunication and real time phase, and update related data to blockchain through BKE and BCOM.Mix  Phase4.5.Audit  Phase    6. After  the  system outputs  the permuted message, senders invoke  Verify   to validate the integrity of the message. SendersReservers6.The Main ChainThe Commitment ChainThe Key Exchange ChainThe Mix NodesPrecommunication Phase Real Time Phase The Candidate MinersThe  Minersconclusion that the adversary has only a negligible chance
of producing such a candidate block B(cid:63)
M ) =
H(Bj

M ). Hence Γ∗ satisﬁes (µ, (cid:96))-chain quality.

M where H(B(cid:63)

Theorem 3. Let Bw
M be a stable block which is the genesis
of the chain CKE and CCOM . If Γ satisﬁes k-common preﬁx,
then Γ∗ satisﬁes k-common preﬁx.

Proof. Note that the chain CKE and CCOM will not fork
since they don not contain proof-of-work and are uniquely
generated bt the mix nodes. Hence CKE and CCOM satisfy
the k-common preﬁx property. We recall that the behaviors
of the adversary and the honest parties in Γ∗ are exactly the
same as that in Γ. Thus according to the literature [], the main
chain satisﬁes k-common preﬁx property. This concludes the
proof.

the

Given

above,

Γ∗
:=
the
(Setup, Update, Vote, Mix, Verify)
is a secure blockchain
protocol which satisﬁes the properties of (τ, s)-chain growth,
(µ, (cid:96))-chain quality and k-common preﬁx.

tuple

C. System Design

With the description of the blockchain-based mix-net pro-
tocol, we propose the dynamic self-organizing blockchain-
based mix anonymous system in this part. Our BCMIX system
consists of four phases, namely: System Initialization, Vote,
Mix, Audit. The orchestration of BCMIX is detailed in Figure
4.

the public

system determine

System Initialization. This phase initializes the sys-
for participants.
tem parameters and generate accounts
system parameters
The
{Ep(a, b), G, G, K, H, T } (e.g. secp256k1 of Bitcoin). After
that the entities (i.e., users and miners) invoke Γ∗Setup to
generate their key pairs (i.e., user key pair (pki
u, ski
u) :=
mG, qj
m, skj
u) and miner key pair (pkj
(qi
m))
and addresses (i.e., user address (addressi
U ) and miner
address (addressj
N , pkj
N ) respectively). In additon, miners
also generate their VRF key pairs, which are used to complete
as mix nodes.

m) := (qj
U , pki

uG, qi

Vote. This phase is executed by the miners to elect the

candidate mix nodes for mixing messages.

1) Firstly, miners invokes Γ∗.PoWVote to solve the puzzle
D(cid:48). If the algorithm Γ∗.PoWVote returns 1, then the
miner Mi is added to the candidate set M. Otherwise
miners re-select inputs s, x to compute H(ctr(cid:48), T (s, x))
until H(ctr(cid:48), T (s, x)) < D(cid:48).

2) After a period of certain time, e.g. T , M stops ac-
cepting new miners. Then the candidates miners run
Γ∗.IPSharding (Algorithm 2) and join the node pool with
the same IP preﬁx.

3) After that the candidate miners Mi in each node pool
take the IP/z and current slot slotl as inputs, and invoke
Γ∗.VRF to generate a value Yi ∈ Y and the corresponding
proof π. Then the candidate miner who holds the smallest
value Y in each node pool is elected as the mix node
in the current slot. Finally, the elected mix nodes are
networked in the order of Y .

9

Algorithm 2
Input: The IP address of the candidate miners, where ipi :=
A1.A2. ∗ .∗. Here A1, A2 and ∗ denote four decimal
segments; the system parameter σ;

The IPSharding algorithm.

Output: k mix node pools;
1: coordinateipm := (Am
2 );
2: |N um2p,2q | denotes the number of nodes distributed in

1 , Am

(2p, 2q);

j > 2i+1 then

for i = 0,i <= 7 do

3: for j = 0,j <= 2 do
4:
5:
6:

if Am

j < 2i or Am
i + +;
else break;
j + +;
the

8:
9: Classify

7:

|N um2p,2q |j
|N um2p ,2q |min

coordinate

into
<= σ, k ∈ [1, k];

10: return k mix node pools.

k

parts

such

that

Mix.

In this phase,

the current mix nodes N :=
(N1, N2, · · · , Nn) ﬁrst negotiate shared keys with users U :=
(U1, U2, · · · , Uβ). Then the current mix nodes blind and mix
messages M := (M1, M2, · · · , Mβ) for users.

To negotiate keys with each other through ECDH protocol,

the mix nodes and the users do as follows.

1) After

the current mix nodes are selected,

they run
Γ∗.Broadcast to disseminate their addresses and the VRF
parameters, i.e. (address, pk)||(vk, Y, π), to the partici-
pants in the blockchain network.

2) Upon receiving the addresses and parameters of all
invoke VRF.Ver to ver-
then
KE to every mix
KE as txKE :=
−−−−−→
outputs, sig) and obtain the public key

mix nodes, a user Ui ﬁrst
ify the received.
the user Ui sends transactions txi
nodes. Then the mix nodes parse txi
(KE , pk,
of each user.

the algorithm returns 1,

−−−−→
inputs,

If

3) Finally the mix nodes Nj and the user Ui multiply their
secret key with the public key of each other, and obtain
the shared key kij = qi

U · qj
After negotiating keys with users, the mix nodes network

N · G.

blind and mix messages as follows.

1) The mix nodes invoke ∆.Precom to compute the parame-
ters EQ(Πn(Rn)×Sn) utilized in the real time phase and
update the corresponding commitment values COMr,
COMs, COMπ, COMDdi
to the commitment chain
CCOM through the commitment transaction txCOM .
2) After receiving the blind messages M × K−1 from the
users, the mix nodes invoke the algorithm ∆.RealTime
to mix the received messages and obtain the permuted
message Πn(M ).

Audit. In this phase, the users invoke Γ∗.Verify to check the
integrity of the permuted messages. If the algorithm Γ∗.Verify
returns 1 to all the users, then the permuted messages are
considered integrated. If Γ∗.Verify returns 0 to some users,
then the users ask the current mix nodes to check their cal-
culation through the corresponding commitment block BCOM

10

Fig. 5. The probability of the expected number of candidate miners

and identify the malicious mix nodes. The malicious mix node
will be removed out of BCMIX.

V. PERFORMANCE EVALUATION

Fig. 6. The results of IPSharding algorithm when σ = 5 (four node poos,
i.e. four mix nodes). We denote an IP address as four segments, the x axis is
the ﬁrst segment and the y axis denotes the second segment. We can change
the division strategy to control the number of mix nodes. We respectively
simulate the attackers which hold 53.84% (the red circle), 63.43% (the red
circles and the green circle) and 74.80% (the red circles, the green circle and
the purple circles) of total computing powers.

This

section presents

the performance evaluation of
BCMIX. We ﬁrstly theoretically analyze the number of candi-
date miners. Then we describe the implementation of BCMIX
and evaluate its performance.

see that when ﬁxing the difﬁculty, the longer the average time
to generate a block, the higher the probability of generating
multiple blocks simultaneously.

A. The Number of candidate miners

B. Implementation

In Bitcoin, the difﬁculty value D, the target target and the

network hash rate satisfy the following formula:

D =

DM ax
targetcurrent

, Hashratemin =

D · 232
T

,

where DM ax is a large constant, targetcurrent denotes the
current target and Hashratemin represents the minimum hash
rate required to calculate a block of difﬁculty D within time T .
According to literature [], the process of generating n blocks
within the average time t will be a Poission distribution with
the expected value λ,

P (X ≥ M ) =

∞
(cid:88)

k=M

λk
k!

e−λ.

Since the Bitcoin network with Hashratemin mining
power generates one block within average time T , we can
conclude that

λ =

Hashratereal
Hashratemin

=

Hashratereal · T
D · 232

.

Here Hashratereal denotes the mining power of the Bitcoin
network in the real world. To better simulate BCMIX in the
real world scenario, we leverage the mining power distribution
from 1. In Appendix B, Table IV details the IP address and
mining power of different mining pools. With D = 1 × 1011,
we estimate the probability of simultaneous block generation
under different T and report our results in Figure 5. We can

1https://btc.com/stats/pool?pool mode=year

In order to show the feasibility of BCMIX, we build a Bit-
coin network in a desktop computer (equipped with a Ubuntu
16.04 LTS, Intel (R) Core (TM) i5-8500 CPU of 3.00GHz and
16GB RAM). We make use of two Github programs, Bitcoin-
Simulator 2 and cMix 3, to evaluate the proposed BCMIX. We
set up the public parameters by utilizing the publicly available
library for cryptography on the secp256k1 curve 4.

We apply the Algorithm 2 to Table IV and obtain the
distribution of mining pools in the real world. The results are
shown in Figure 6. Combining Figure 5 and Figure 6, we
can ﬁnd that when ﬁxing difﬁculty D to 1.0 × 1011, setting
the average block generation time to 20s or 30s can obtain a
reasonable number of mix nodes, which is more conducive to
the implementation of BCMIX. To measure the approximate
time cost, we test the functionality of PoWVote, IPSharding,
Key Exchange, Precomputation and RealTime under different
number of mix nodes and users for 100 times. The test results
are shown in Table II. We can see that PoWVote spends more
time than other algorithms. In order to improve the operating
efﬁciency of BCMIX, we elect mix nodes at regular intervals.

VI. SECURITY ANALYSIS

According to the proposed additive homomorphism mix-net
protocol and basic components of proof-of-work blockchains,

2https://github.com/arthurgervais/Bitcoin-Simulator
3https://github.com/byronknoll/cmix
4https://github.com/bitcoin-core/secp256k1

11

TABLE II
TIME COST (IN RM S) FOR DIFFERENT NUMBER OF MIX NODES AND USERS TO EXECUTE THE ALGORITHMS

Time
Alg

Number

Mix Node
User

10

3
50

100

10

5
50

100

10

7
50

100

10

9
50

100

PoWVote

IPSharding

Key Exchange

Precomputation

RealTime

29.62

28.90

30.12

29.77

31.23

29.35

29.00

30.27

32.14

31.36

30.80

29.79

0.65

0.60

0.33

0.03

0.65

0.83

0.33

0.11

0.65

1.07

0.33

0.26

0.93

0.69

0.47

0.06

0.93

1.03

0.47

0.19

0.93

1.47

0.47

0.37

1.46

0.77

0.62

0.12

1.46

1.26

0.62

0.23

1.46

1.86

0.62

0.43

1.88

0.86

0.81

0.16

1.88

1.48

0.81

0.29

1.88

2.26

0.81

0.49

We ﬁx the difﬁculty D = 1 × 1011 and stipulate the block generation time T = 30s. We can change the division strategy in Figure 6 to control the
number of mix nodes.

TABLE III
SUMMARY COMPARISON OF ATTACK RESILIENCE AND PERFORMANCE

Technology

Attacks

BCMIX
cMix
Tor
BAR
AnonPubSub
Tarzan
DiceMix

Blockchain Re-encryption
Mix Re-encryption
Mix Mutilayer Encryption
Multicast/Broadcast
Probabilistic Forwarding
Peer-to-peer
CoinJoin

Trafﬁc analysis
!
!
%
!
!
!
%

DDos
!
%
%
%
%
!
%

Tagging MitM Sybil

!
%

\
%
!
!
!

!
%
%
%
%
%
%

!

\
\
\
\
%
%

!- The system is secure against this attack or the system performs well.
%- The system is vulnerable to this attack or the system is not performing well.
\ - The system does not involve this attack of the authors did not mention the related performance.

Performance

Bandwidth
!
!
!
!

Latency
!
!
!
%

\
!
!

\
!
!

Fig. 7. The relationship between difﬁculty and probability to launch the Sybil
attacks.

Fig. 8. The relationship between difﬁculty and probability to launch the
collision tagging attacks.

BCMIX system can satisfy all the security requirements de-
scribed in Section III-C. Table III summarizes a comparison
among different anonymous systems.

• Resistance to Sybil Attacks. We indicate that an attacker
implement Sybil attacks successfully means the attacker
take control of all mix nodes. To simulate a process of
Sybil attacks, we assume that an IP address of mining
pools in Table IV represents an identity, and all identities
created by a mining pool share the mining pool’s com-
puting power equally. Figure 7 shows the requirements
in terms of difﬁculty (computing power), in order for an
attacker with different computing power to successfully
launch Sybil attacks. Figure 7 indicates that, when the
difﬁculty D is ﬁxed, an attacker with higher computing
power have a higher probability of successfully launching

Sybil attacks than attackers with lower computing power.
And if we set the difﬁculty D to be very small, the
probability that an attacker successfully launching Sybil
attacks is almost zero.

• Resistance to Collision Tagging Attacks. As we men-
tion in Section II C, an attacker compromise the last mix
node Nl and any mix node Ni to launch collision tagging
attacks. In this case, we can treat a collision tagging attack
as a special form of a Sybil attack. We illustrates the
relationship between the difﬁculty D and the probability
of launching collision tagging attacks in Figure 8. Similar
to Sybil attacks, we can set the difﬁculty D to be very
small to resist the collision tagging attacks.

• Sender Anonymity. Suppose that an adversary A can
compromise β − 2 users and n − 1 nodes. Let Ux and

Uy denote any two honest users and let Ni be the
only honest mix node. The sender anonymity property
the adversary cannot distinguish the
guarantees that
messages from the two honest users. We design the
following experiments for a PPT adversary A.

an(∆, A, λ) :

EXP b
ASetup:

(Q, Kx, Ky, K A

m,m(cid:54)=x,m(cid:54)=y) ← Setup(1λ),

APrecomputation:

(EQ(RA) · EQ(rNi)) ← Preprocess(r),
EQ(Πn(Rn) · Sn) ← Mix(s, π),
(Πn(Rn) · Sn) ← Postprocess(Ddi),

ARealTime:
(mb ·rNi, m1−b ·rNi) ← Preprocess(Kx ·mb, Ky ·m1−b),
πNi (mb · rNi · sNi, m1−b · rNi · sNi) ← Mix,

(cid:48)

(cid:48)

(m

b, m

1−b) ← Postprocess

The adversary’s advantage in the experiments is:

|P r[EXP 0

an(∆, A, λ) = 1]−P r[EXP 1

an(∆, A, λ) = 1]|.

Deﬁnition 7. (Anonymity). An additive homomorphism
mix-net protocol ∆ := (Setup, Precom, RealTime) main-
tains anonymity if the advantage of the adversary in the
anonymity game is negligible.
Theorem 4. If E is a ECDLP-secure additive homo-
morphism encryption scheme, ECDH is a ECDHP-secure
key exchange protocol and a non-interactive commitment
scheme COM is perfectly-hiding, then BCMIX satisﬁes
anonymity deﬁned in Deﬁnition 7.

Proof. (Sketch). We prove the security of BCMIX by
reduction from the security of the encryption system E.
Without loss of generality, we assume that the adversary
A can compromise β − 2 users and n − 1 nodes. Let Ux
and Uy denote any two honest users and let Ni be the
only honest mix node.
In the setup phase, A can control all the shared keys
except Kx, Ky. In the precomputation phase, A gets
command of random values RA, SA and random per-
mutations ΠA except rNi, sNi, πNi, the corresponding
ciphertext E(rNi) and the decrypt share DNi. In the real
time phase, users send blind messages to mix networks in
the form of M ×K. The adversary A can parse the blind
messages as (Kx · mb, Ky · m1−b). During the mixing
process of real time phase, A decrypt the mixed messages
and obtain the mixed messages (mb · rNi · sNi, m1−b ·
rNi · sNi). Finally, A observe the plaintext messages of
the form (m
We assume a challenger C assigns the blind messages
(Kx · m0, Ky · m1), where m0 = mb and m1 =
m1−b as determined by a random bit b. An adversary
1−b) predicts the association between
b, m
holding (m
(Kx · m0, Ky · m1) and (m
if
the anonymity game adversary A predicts the bit b
correctly, we can infer that A can calculate Kx and
Ky which break the ECDHP-secure of the underlying
key exchange system. Thus |P r[EXP 0
an(∆, A, λ) =

1−b). In the end,

1−b).

b, m

b, m

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

12

1] − P r[EXP 1
ilarly, we conclude that |P r[EXP 0
P r[EXP 1
cludes the proof.

an(∆, A, λ) = 1]| ≤ neglECDHP . Sim-
an(∆, A, λ) = 1] −
an(∆, A, λ) = 1]| ≤ neglECDLP . This con-

• Resistance to MitM attacks. In BCMIX we leverage the
gossip protocol to spread messages. We assume that an
attack cannot control all access networks of a blockchain
node. According to [34], this is reasonable since none
instances of eclipse attacks have arisen in reality up
to now. Besides, many blockchain communities have
ﬁxed this vulnerability [35]. In this case, an adversary
(cid:101)A attempts to simulate an elected mix node to deceive a
user (cid:101)U . At the same time, other nodes connected with
(cid:101)U inform (cid:101)U the latest elected mix node sets, thus (cid:101)U
identities (cid:101)A as an adversary.

• Single point of failure Resilience. Nodes in BCMIX are
networking dynamically. Once an elected mix node Ni
loses the response for a period of time, the next mix node
Ni+1 would inform other nodes that i is crashed. Then
the other nodes validate the situation of node i, and begin
a new networking process if i goes down, or identify node
Ni+1 as a malicious node if i works normally.

• Resistance to Other Attacks. BCMIX can also resist the

following attacks.
a) Replay attacks. An attacker may retransmitting a
message m form a previous session. Then the at-
tacker compare the mixed message sets with the
previous message sets which contain m, thus the
attacker can associate the egress messages with
the ingress messages. Since the random values and
permutations are never reused, thus BCMIX resists
replay attacks.

b) Trafﬁc analysis attacks. In connection-based sys-
tems such as Tor, attackers can distinguish between
two different paths in the free mix network by
counting packages and timing communication. Since
BCMIX is a message-based system which batches
and permutes messages during the transmitting pro-
cess, attackers can not distinguish and analyze the
blind messages, thus BCMIX resists trafﬁc analysis
attacks.

c) Intersection attacks and statistical disclosure attacks.
These attacks utilize information given by observing
mix networks where the users can freely choose the
mix node for their messages. Since BCMIX adopts
a ﬁxed cascade of mix nodes every round,
thus
BCMIX is not susceptible to these attacks.

VII. CONCLUSION

In this paper, we achieved a dynamic self-organizing mix
anonymous system. With blockchain technology, we elect
mix nodes from public, dynamic blockchain miners. Before
constructing BCMIX, we proposed BCMN protocol with the
formal security models. Building on the proposed protocol,
we designed a transaction-based key exchange scheme and
proposed our BCMIX. Then we illustrated BCMIX can satisfy
the relevant security requirements. After that we demonstrated

experimentally that BCMIX is resistant to the attacks proposed
in this paper. Finally, we evaluated the performance of the
prototype with the real world data and compared BCMIX with
some latest anonymous systems. The results suggested that
BCMIX is practical for real world deployment.

A follow-on work is to ﬁnd a solution for

recipient
anonymity, which would improve the anonymity ability of our
system. We believe that building a bidirectional anonymous
system allow us to identity additional features and properties.

VIII. APPENDIX A.
The detailed description of cMix protocol is as follows.
Setup phase. The mix nodes establish their decryption share
Xi, and the public key y is computed. Each user Aj will
individually establish a symmetric key ki,j with each mix node
Ni in the network. The mix nodes draw their random values
(cid:126)ri and vecti for the n slots.

Precomputation phase. The goal in this phase is to perform
the public-key operations that is needed in the real time phase.
), and
send their calculated vector to the network handler. The
network handler then computes E( (cid:126)R−1

Step 1-Preprocessing: Mixnode Ni computes E((cid:126)r−1

h ) = (cid:81)h

i=1 E((cid:126)r−1

Step 2-Mixing: Ni(i = 1, · · · , h − 1) computes and sends

).

i

i

the following to Ni+1
(cid:40)

i

i

) =

E(Πi( (cid:126)R−1

h ) × (cid:126)T −1

i−1)) × E((cid:126)t−1

h ) × (cid:126)T −1

π1(E( (cid:126)R−1
πi(E(Πi−1( (cid:126)R−1

h )) × E((cid:126)t−1
1 )
h ) × (cid:126)T −1

i = 1
) 1 < i ≤ h
Nh ﬁnally computes: ( (cid:126)C1, (cid:126)C2) = E((( (cid:126)Rh) × (cid:126)Th)−1) =
h ). Nh sends (cid:126)C1 to the other
πh(E(( (cid:126)R−1
mix nodes and store (cid:126)C2 locally for use in the real time phase.
Step 3-Postprocessing: Mixnode Ni use their decryption
share Xi to decrypt the vector of random components they
received in the previous step; Di( (cid:126)C1) = (cid:126)C −Xi
. They publish
a commitment to their calculated decryption share.

h−1)) × E((cid:126)t−1

1

j

Real time phase. In this phase, the senders are involved. Aj
constructs a blinded message mj ×K −1
. The blnded messages
are the input to the protocol, and they are combinded by the
network handler to yield the vector (cid:126)m × (cid:126)K −1.

Step 1-Preprocessing: Every mix node Ni calculates (cid:126)ki ×(cid:126)ri,
and sends the resulting vector to the network handler. The
network handler then computes (cid:126)m × (cid:126)Rh = (cid:126)m × (cid:126)K −1 ×
(cid:81)h
(cid:126)ki × (cid:126)ri, hence the (cid:126)K −1 vector is replaced with the

i=1

random r values of each mix node.

Step 2-Mixing: Ni computes and sends the following to

Ni+1:

(Πi( (cid:126)m × (cid:126)Rh) × (cid:126)Ti) =

(cid:40)

π1( (cid:126)m × (cid:126)Rh) × (cid:126)t1
πi(Πi−1( (cid:126)m × (cid:126)Rh) × (cid:126)Ti−1) × (cid:126)ti 1 < i < h

i = 1

Mix node Nh computes Πh( (cid:126)m × (cid:126)Rh) × (cid:126)Th = πh(Πh−1( (cid:126)m ×
(cid:126)Rh) × (cid:126)TH−1) × (cid:126)th. Nh commits to this vector and sends the
commitment to the remaining mix nodes.

Step 3-Postprocessing: When mix node Ni(i = 1, · · · , h−1)
receive the commitment from Nh, they send their decryption
share Di( (cid:126)C1) computed in the precomputation phase to the
network handler. The last mix node computes and send the
following to the network handler: Πh( (cid:126)m × (cid:126)Rh) × (cid:126)Th × (cid:126)C2 ×
(cid:81)h
i=1 D( (cid:126)C1) = Πh( (cid:126)m × (cid:126)Rh) × (cid:126)Th × (Πh( (cid:126)Rh) × (cid:126)Th)−1 =
Πh( (cid:126)m)

The network handler outputs Πh( (cid:126)m), that is a permutation

of the input message.

13

IX. APPENDIX B.

The distribution of mining pools in the real world. To
simulate a process of Sybil attacks, we assume that an IP
address of mining pools in Table IV represents an identity,
and all identities created by a mining pool share the mining
pool’s computing power equally.

TABLE IV
NOTATIONS OF THE REVISED MIX-NET PROTOCOL

Pool Name

IP Address

f2pool
Poolin

BTC.com

AntPool
ViaBTC
Huobi.pool
58COIN&1THash

SlushPool

OKExPool
unknown
BTC.TOP
BytePool
Binance Pool

BitFury

Lubian.com

NovaBlock

SpiderPool
WAYI.CN
Bitcoin.com
MiningCity
OKKONG

TATMAS Pool

BitClub
Sigmapool.com
KanoPool
Solo CK

203.107.32.162
47.75.234.12
117.24.1.243, 117.24.1.239
117.24.1.238, 117.24.1.242
47.94.135.145
116.211.155.211, 123.155.158.10
47.93.94.105
39.98.72.224
104.26.5.102, 104.26.4.102
172.67.74.105
208.43.170.231
47.93.94.105
123.56.208.222
58.218.215.133
13.248.150.68, 76.223.2.151
104.26.5.32, 104.26.4.32
172.67.70.128
47.56.109.242
104.26.11.113, 104.26.10.113
172.67.70.128
47.52.126.9
47.103.164.189
104.18.26.217, 104.18.27.217
23.218.94.192, 23.32.241.177
47.96.193.193
104.18.40.151, 172.67.148.229
104.1841.151
213.173.105.14
18.156.81.156
45.77.7.149
51.81.56.15

Hashrate
124(EH/s)
21.1048
19.716

16.1076

13.95
7.8988
7.626
6.4728

5.6792

4.9724
4.7244
3.9804
2.2816
2.0832

2.0336

1.922

1.488

0.62
0.5459
0.4092
0.124
0.062

0.0496

0.0496
0.0372
0.0124
0.0124

Proportion
100%
17.02%
15.9%

12.99%

11.25%
6.37%
6.15%
5.22%

4.58%

4.01%
3.81%
3.21%
1.84%
1.68%

1.64%

1.55%

1.20%

0.5%
0.44%
0.33%
0.1%
0.05%

0.04%

0.04%
0.03%
0.01%
0.01%

REFERENCES

[1] J. Sanders and D. Patterson, “Facebook data privacy scandal: A cheat

sheet,” 2019.

[2] D. R. Hayes, C. Snow, and S. Altuwayjiri, “Geolocation tracking
and privacy issues associated with the uber mobile application,” in
Proceedings of the Conference on Information Systems Applied Research
ISSN, vol. 2167, 2017, p. 1508.

[3] N. Alexopoulos, A. Kiayias, R. Talviste, and T. Zacharias, “Mcmix:
Anonymous messaging via secure multiparty computation,” in 26th
{USENIX} Security Symposium ({USENIX} Security 17), 2017, pp.
1217–1234.

[4] D. L. Chaum, “Untraceable electronic mail, return addresses, and digital
pseudonyms,” Communications of the ACM, vol. 24, no. 2, pp. 84–90,
1981.

[5] T. Lu, Z. Du, and Z. J. Wang, “A survey on measuring anonymity in
anonymous communication systems,” IEEE Access, vol. 7, pp. 70 584–
70 609, 2019.

[6] G. Danezis and C. Diaz, “A survey of anonymous communication
channels,” Technical Report MSR-TR-2008-35, Microsoft Research,
Tech. Rep., 2008.

[7] M. Edman and B. Yener, “On anonymity in an electronic society:
A survey of anonymous communication systems,” ACM Computing
Surveys (CSUR), vol. 42, no. 1, pp. 1–35, 2009.

[8] J. Boyan, “The anonymizer-protecting user privacy on the web,” 1997.
[9] E. Gabber, P. B. Gibbons, D. M. Kristol, Y. Matias, and A. Mayer,
“Consistent, yet anonymous, web access with lpwa,” Communications
of the ACM, vol. 42, no. 2, pp. 42–47, 1999.

14

[35] Y. Marcus, E. Heilman, and S. Goldberg, “Low-resource eclipse attacks
on ethereum’s peer-to-peer network.” IACR Cryptol. ePrint Arch., vol.
2018, p. 236, 2018.

Michael Shell Biography text here.

PLACE
PHOTO
HERE

John Doe Biography text here.

Jane Doe Biography text here.

[10] D. Chaum, D. Das, F. Javani, A. Kate, A. Krasnova, J. De Ruiter,
and A. T. Sherman, “cmix: Mixing with minimal real-time asymmet-
ric cryptographic operations,” in International Conference on Applied
Cryptography and Network Security. Springer, 2017, pp. 557–578.

[11] S. Prusty, B. N. Levine, and M. Liberatore, “Forensic investigation of the
oneswarm anonymous ﬁlesharing system,” in Proceedings of the 18th
ACM conference on Computer and communications security, 2011, pp.
201–214.

[12] M. Sherr, A. Mao, W. R. Marczak, W. Zhou, B. T. Loo, and M. A.
Blaze, “A3: An extensible platform for application-aware anonymity,”
2010.

[13] J. Kong and X. Hong, “Anodr: anonymous on demand routing with
untraceable routes for mobile ad-hoc networks,” in Proceedings of the
4th ACM international symposium on Mobile ad hoc networking &
computing, 2003, pp. 291–302.

[14] P. Syverson, R. Dingledine, and N. Mathewson, “Tor: The secondgen-

eration onion router,” in Usenix Security, 2004, pp. 303–320.

[15] M. J. Freedman and R. Morris, “Tarzan: A peer-to-peer anonymizing
network layer,” in Proceedings of the 9th ACM conference on Computer
and communications security, 2002, pp. 193–206.

[16] M. Conti, N. Dragoni, and V. Lesyk, “A survey of man in the middle
attacks,” IEEE Communications Surveys & Tutorials, vol. 18, no. 3, pp.
2027–2051, 2016.

[17] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,”

Manubot, Tech. Rep., 2019.

[18] M. Gomułkiewicz, M. Klonowski, and M. Kutyłowski, “Onions based
on universal re-encryption–anonymous communication immune against
repetitive attack,” in International Workshop on Information Security
Applications. Springer, 2004, pp. 400–410.

[19] O. Pereira and R. L. Rivest, “Marked mix-nets,” in International
Springer,

Conference on Financial Cryptography and Data Security.
2017, pp. 353–369.

[20] D. Chaum, “The dining cryptographers problem: Unconditional sender
and recipient untraceability,” Journal of cryptology, vol. 1, no. 1, pp.
65–75, 1988.

[21] P. Kotzanikolaou, G. Chatzisofroniou, and M. Burmester, “Broadcast
anonymous routing (bar): scalable real-time anonymous communica-
tion,” International Journal of Information Security, vol. 16, no. 3, pp.
313–326, 2017.

[22] C. Egger, J. Schlumberger, C. Kruegel, and G. Vigna, “Practical attacks
against the i2p network,” in International workshop on recent advances
in intrusion detection. Springer, 2013, pp. 432–451.

[23] A. M. Piotrowska, J. Hayes, T. Elahi, S. Meiser, and G. Danezis,
“The loopix anonymity system,” in 26th {USENIX} Security Symposium
({USENIX} Security 17), 2017, pp. 1199–1216.

[24] R. Jansen, F. Tschorsch, A. Johnson, and B. Scheuermann, “The sniper
attack: Anonymously deanonymizing and disabling the tor network,”
Ofﬁce of Naval Research Arlington VA, Tech. Rep., 2014.

[25] T. Chothia and K. Chatzikokolakis, “A survey of anonymous peer-to-peer
ﬁle-sharing,” in International Conference on Embedded and Ubiquitous
Computing. Springer, 2005, pp. 744–755.

[26] T. Rufﬁng, P. Moreno-Sanchez, and A. Kate, “P2p mixing and unlinkable

bitcoin transactions.” in NDSS, 2017, pp. 1–15.

[27] J. Han and Y. Liu, “Mutual anonymity for mobile p2p systems,” IEEE
Transactions on Parallel and Distributed Systems, vol. 19, no. 8, pp.
1009–1019, 2008.

[28] N. Koblitz, “Elliptic curve cryptosystems,” Mathematics of computation,

vol. 48, no. 177, pp. 203–209, 1987.

[29] Y. Luo, X. Ouyang, J. Liu, and L. Cao, “An image encryption method
based on elliptic curve elgamal encryption and chaotic systems,” IEEE
Access, vol. 7, pp. 38 507–38 522, 2019.

[30] T. Jager, “Veriﬁable random functions from weaker assumptions,” in

Theory of Cryptography Conference. Springer, 2015, pp. 121–143.

[31] J. Garay, A. Kiayias, and N. Leonardos, “The bitcoin backbone protocol:
Analysis and applications,” in Annual International Conference on the
Theory and Applications of Cryptographic Techniques. Springer, 2015,
pp. 281–310.

[32] J. Yu, D. Kozhaya, J. Decouchant, and P. Esteves-Verissimo, “Repucoin:
Your reputation is your power,” IEEE Transactions on Computers,
vol. 68, no. 8, pp. 1225–1237, 2019.

[33] S. Hohenberger, S. Myers, R. Pass et al., “Anonize: A large-scale
anonymous survey system,” in 2014 IEEE Symposium on Security and
Privacy.

IEEE, 2014, pp. 375–389.

[34] E. Heilman, A. Kendler, A. Zohar, and S. Goldberg, “Eclipse attacks on
bitcoins peer-to-peer network,” in 24th {USENIX} Security Symposium
({USENIX} Security 15), 2015, pp. 129–144.

