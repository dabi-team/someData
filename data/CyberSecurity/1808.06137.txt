EviHunter: Identifying Digital Evidence in the Permanent
Storage of Android Devices via Static Analysis

Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan
Department of Electrical and Computer Engineering
NIST Center of Excellence in Forensic Science - CSAFE
Iowa State University
{cccheng, cshi, neilgong, guan}@iastate.edu

8
1
0
2

g
u
A
8
1

]

R
C
.
s
c
[

1
v
7
3
1
6
0
.
8
0
8
1
:
v
i
X
r
a

ABSTRACT
Crimes, both physical and cyber, increasingly involve smartphones
due to their ubiquity. Therefore, digital evidence on smartphones
plays an increasingly important role in crime investigations. Digital
evidence could reside in the memory and permanent storage of a
smartphone. While we have witnessed significant progresses on
memory forensics recently, identifying evidence in the permanent
storage is still an underdeveloped research area. Most existing
studies on permanent-storage forensics rely on manual analysis or
keyword-based scanning of the permanent storage. Manual analysis
is costly, while keyword matching often misses the evidentiary data
that do not have interesting keywords.

In this work, we develop a tool called EviHunter to automatically
identify evidentiary data in the permanent storage of an Android
device. There could be thousands of files on the permanent storage
of a smartphone. A basic question a forensic investigator often
faces is which files could store evidentiary data. EviHunter aims to
answer this question. Our intuition is that the evidentiary data were
produced by apps; and an app’s code has rich information about the
types of data the app may write to a permanent storage and the files
the data are written to. Therefore, EviHunter first pre-computes an
App Evidence Database (AED) via static analysis of a large number
of apps. The AED includes the types of evidentiary data and files
that store them for each app. Then, EviHunter matches the files on
a smartphone’s permanent storage against the AED to identify the
files that could store evidentiary data. We evaluate EviHunter on
benchmark apps and 8,690 real-world apps. Our results show that
EviHunter can precisely identify both the types of evidentiary data
and the files that store them.

CCS CONCEPTS
• Applied computing → System forensics;

KEYWORDS
Digital Forensics, Mobile Device Forensics, Static Analysis

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5693-0/18/10. . . $15.00
https://doi.org/10.1145/3243734.3243808

ACM Reference Format:
Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan.
2018. EviHunter: Identifying Digital Evidence in the Permanent Storage
of Android Devices via Static Analysis. In 2018 ACM SIGSAC Conference
on Computer and Communications Security (CCS ’18), October 15–19, 2018,
Toronto, ON, Canada. ACM, New York, NY, USA, 13 pages. https://doi.org/
10.1145/3243734.3243808

1 INTRODUCTION
Smartphones are playing an increasingly important role in inves-
tigating both cyber and physical crimes, as they are pervasive de-
vices and they capture both online and offline activities of their
owners. For instance, even several years ago when smartphones
were not as pervasive as today, the number of crimes that involve
mobile-phone evidence increased 10% per year on average from
2006 to 2011 [33]. In 2017, a visiting scholar at University of Illinois
Urbana-Champaign was kidnapped. Via forensic examination of the
suspect’s smartphone, FBI agents found that the smartphone owner
visited websites about “perfect abduction fantasy” and “planning
a kidnapping”, which has been used as important digital evidence
investigation [42]. Likewise, in one of the biggest poaching cases
in Washington [14], suspects took pictures and videos of killing
animals (illegally). GPS locations retrieved from these images and
videos led to dozens of kill sites where physical evidence (e.g., bul-
lets) was found, and texts retrieved from the suspects’ smartphones
were used as digital evidence to corroborate charges.

Digital evidence on a smartphone could reside in the memory or
permanent storage, e.g., flash storage, SD card. Recently, a series of
tools [37–40] have been developed to significantly advance memory
forensics. However, identifying digital evidence in the permanent
storage of a smartphone is still an underdeveloped research area.
While memory forensics can reconstruct a smartphone’s context
that is probably in a short period of time before the last use of
the smartphone, permanent-storage forensics could uncover evi-
dentiary data about the smartphone’s historical activities over a
long period of time, as some criminal cases may be planned and
conducted across a large range of dates and locations. In this work,
we focus on permanent-storage forensics. More specifically, data
are stored in files by apps on a permanent storage; and one basic
problem a forensic investigator often faces is which files, among
the possibly thousands of files on a suspect’s smartphone, could
store relevant evidentiary data (e.g., GPS locations, visited URLs,
and texts). We call this problem evidence identification problem. Af-
ter identifying such files, forensic investigators can then retrieve,
decode, or reconstruct the evidentiary data from them.

 
 
 
 
 
 
CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan

Existing studies on this evidence identification problem mainly
rely on manual analysis [9–11, 46] or keyword-based scanning [2,
3, 7, 17]. For instance, in keyword-based scanning, a file whose file
name or content includes the keywords GPS, latitude, or longitude
is labelled as a file that could include GPS locations. Manual analysis
is time-consuming and error-prone, while keyword-based scanning
misses the files that do not include the specified keywords. Indeed,
studies [23] showed that keyword-based scanning can only identify
a small fraction of files that could store evidentiary data.

Our work: In this work, we develop EviHunter, a tool to automat-
ically identify the files on an Android device that could store the
evidentiary data of interest to forensic investigators. Our intuition
is that the files/data on a smartphone were produced by apps; an
app’s code contains rich information about 1) the types of data that
the app could write into a file system and 2) the files where the data
are written to.

Based on the intuition, EviHunter takes an offline-online ap-
proach. In the offline phase, EviHunter builds an App Evidence
Database (AED) for a large number of apps via static data flow
analysis. Specifically, for each app, the AED includes the files that
could store evidentiary data of interest and the types (e.g., location,
visited URL, text input, and time) of evidentiary data in each of
such files, where a file is represented using its complete file path
on Android. We adopt static analysis instead of dynamic analysis
to have high coverage and be less likely to miss the files that could
contain evidentiary data. In the online phase, given a smartphone,
EviHunter matches the file paths on the smartphone’s file system
against those in the AED to identify the files that could contain
evidentiary data.

Building the AED is a key challenge for EviHunter. We note
that a large number of static analysis tools–such as CHEX [30],
FlowDroid [12], AmanDroid [45], DroidSafe [21], R-Droid [13],
IccTA [28], and HornDroid [15]–have been developed to detect
sensitive data flows between sources and sinks in Android apps.
These tools were designed to detect the data that could flow from
certain sources to sinks, where a source is where data are created
and a sink is where the data ends, e.g., file system is a sink in our
problem. However, these tools did not consider the files where the
data are written to. For instance, these tools could detect that an
app will collect GPS locations and save them to the file system,
but they do not report the files where the GPS locations will be
written to. One possible reason is that these tools were designed for
security and privacy purposes; and it does not matter much which
files sensitive data are written to in terms of privacy leakage.

To address the challenge, EviHunter extends existing static data
flow analysis techniques for Android in several aspects. First, in
some existing static analysis tools, a tag is associated with a variable
to represent the types of sensitive data in the variable. We extend
the tag to include both the types of sensitive/evidentiary data and
the file path associated with a variable. Second, we extend the prop-
agation rules to spread both the types of evidentiary data and file
paths as we analyze the statements in an app. Third, we leverage
techniques developed by HornDroid [15] to partially address multi-
threading and reflection. Fourth, for complexity consideration, we
manually summarize the semantics for the commonly used system
APIs as some previous tools did [12, 30, 45]. However, we further

summarize the semantics of the system APIs for file path construc-
tion, which were not considered by previous tools. Fifth, we extend
the sources by 1) uncovering the source methods for file path con-
struction (these were not considered by previous tools), and 2)
uncovering new sources for sensitive/evidentiary data including
location, visited URL, and time (these sources were considered by
previous tools but not complete).

In implementing EviHunter, we leverage Soot to transform an
Android app to Jimple code (a three address intermediate representa-
tion), IC3 [16] to build inter-connected component communication
models, and FlowDroid [12] to build call graphs and entry points.
Then, EviHunter performs forward analysis of the Jimple code. We
evaluate EviHunter with respect to AED construction using 1) the
benchmark apps in DroidBench [1] that have file-system sinks,
2) new benchmark apps that we design to test the scenarios that
are not covered by the DroidBench apps, and 3) 8,690 real-world
apps. Our results show that EviHunter can precisely and accu-
rately find the files that could store evidentiary data for benchmark
apps. Moreover, we performed a best-efforts manual verification of
the results for 60 randomly sampled real-world apps. Our results
show that EviHunter achieves a precision of 90% and a recall of
89% at identifying the files that could contain evidentiary data. Al-
though our work does not focus on privacy leakage, our results
do have interesting privacy implications. In particular, we found
that some apps save GPS locations, visited URLs, and text inputs
on the external storage of an Android device. An app with the
READ_EXTERNAL_STORAGE permission can access these data to
track and profile the user. Finally, we use a case study to show how
a forensic investigator can use EviHunter to find evidentiary data
on a smartphone.

In summary, our contributions are as follows:
• We develop EviHunter to automatically identify the files on an

Android device that could contain evidentiary data.

• We extend existing static analysis tools for Android to detect
both types of evidentiary data an app could write to file system
and the files where the data are written to.

• We evaluate EviHunter using both benchmark apps and real-
world apps. Our results show that EviHunter achieves high
precisions and recalls.

2 BACKGROUND AND PROBLEM

FORMULATION

We first briefly introduce the Android file system used to manage
the permanent storage and then define our forensics problem.

2.1 Android File System

Directory structure: Android file system pre-defines several top-
level directories, e.g., /data/ and /sdcard/. The directory /data/ is on
the internal storage of Android, while /sdcard/ is linked to external
storage. Figure 1 shows the structure of the /data/ and /sdcard/ direc-
tories. Each app has a default directory /data/data/<package name>/,
where the package name is treated as the identifier of the app. For
instance, the Facebook app’s package name is com.facebook.katana
and an Android device will create a directory /data/data/com.facebook.
katana/ after the Facebook app is installed on the device. An app’s
directory stores various data of the app. Android also pre-defines

EviHunter

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Table 1: Android APIs to get file paths.

API

getDataDirectory()

getCacheDir()

getFilesDir()

getFileStreamPath(String arg0)

openFileOutput(String arg0, int arg1)

getDataDir()

openOrCreateDatabase(String arg0, ... )

openDatabase(String arg0, ...)

getSharedPreferences(String arg0,int arg1)

getDefaultSharedPreferences(Context arg0)

getPreferences(int arg0)

getDir(String arg0, int arg1)

openOrCreateDatabase(File arg0, ... )

getExternalStorageDirectory()

getExternalStoragePublicDirectory(String arg0)

getObbDir()

getExternalCacheDir()

getExternalFilesDir(String arg0)

Description

Return File object whose path is "/data/"
Return File object whose path is "/data/data/<package name>/cache/"
Return File object whose path is "/data/data/<package name>/files/"
Return File object whose path is "/data/data/<package name>/files/<arg0>"
Return FileOutputStream object whose path is "/data/data/<package name>/files/<arg0>"
Return File object whose path is "/data/data/<package name>/databases/"
Return SQLiteDatabase object whose path is "/data/data/<package name>/databases/<arg0>"
Return SQLiteDatabase object whose path is "/data/data/<package name>/databases/<arg0>"
Return SharedPreferences object whose path is "/data/data/<package name>/shared_prefs/<arg0>.xml"
Return SharedPreferences object whose path is

"/data/data/<package name>/shared_prefs/<package name>_preferences.xml"

Return SharedPreferences object whose path is "/data/data/<package name>/shared_prefs/<context>1.xml"
Return File object whose path is "/data/data/<package name>/app_<arg0>/"
Return SQLiteDatabase object whose path is "<arg0>"
Return File object whose path is "/sdcard/"
Return File object whose path is "/sdcard/", if <arg0>is empty.
Return File object whose path is "/sdcard/<arg0>/", otherwise.
Return File object whose path is "/sdcard/Android/obb/<package name>/"
Return File object whose path is "/sdcard/Android/data/<package name>/cache/"
Return File object whose path is "/sdcard/Android/data/<package name>/files/", if <arg0>is empty.
Return File object whose path is "/sdcard/Android/data/<package name>/files/<arg0>/", otherwise.

1 <context> refers to an app’s environment information, such as launching activity class name and service name.

1
2
3
4
5
6
7
8
9

f o o ( S t r i n g gpsLong , S t r i n g g p s L a t ) {
S t r i n g f i l e N a m e = " l o c S i n k " ;
F i l e O u t p u t S t r e a m s i n k

= o p e n F i l e O u t p u t ( f i l e N a m e , 0 ) ;

l o n g t i m e = System . c u r r e n t T i m e M i l l i s ( ) ;
S t r i n g s t r = gpsLong + g p s L a t + t i m e ;
s i n k . w r i t e ( s t r . g e t B y t e s ( ) ) ;
s i n k . c l o s e ( ) ;

}

Listing 1: An example of soft-coded file access.

Figure 1: Illustration of the /data/ and /sdcard/ directories
in Android’s file system.

several sub-directories under an app’s directory. Example sub-
directories include /files/, /databases/, /share_prefs/, and /cache/. The
sub-directory /files/ can include any files, /databases/ stores SQLite
database files, /share_prefs/ stores SharedPreferences files, and
/cache/ stores cache files. A SharedPreferences file can be viewed
as a simple database, in which data are stored in key-value pairs.

When an app wants to use external storage and has the per-
mission to do so, Android will create a directory /sdcard/Android/-
data/<package name>/ for the app. Moreover, this directory contains
sub-directories /files/ and /cache/. Unlike the internal storage, data
stored in the external storage can be read by all other apps on
the device. Moreover, the external storage also has other public

directories such as Pictures and Download. We note that if a device
does not have a real SD card, Android will use a part of the internal
storage to emulate one and link /sdcard/ to it.

File access: An app can access a file using either a hard-coded
approach or a soft-coded approach. Specifically, in the hard-coded
approach, an app specifies an absolute file path (e.g., /data/data/-
com.facebook.katana/files/a.txt) and reads/writes to the file. In the
soft-coded approach, the app uses an Android API to locate a file
and then operates on the file. Table 1 shows some example Android
APIs that can be used to find file paths. These APIs were found
via reading through the latest version Android documentation and
source code. Listing 1 shows an example of soft-coded file access.
The app uses an API openFileOutput(fileName, 0) at line 4 to open
the file /data/data/<package name>/files/locSink, and then the app
writes GPS location and time to the file.

/data/data/<package name>//sdcard/files/databases/share_prefs/cache/Download/… …Android/data/<package name>/Pictures/… …CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan

2.2 Problem Definition
Suppose a forensic investigator is investigating a crime and has col-
lected a suspect’s mobile device. Moreover, the forensic investigator
has obtained a file system image from the device, e.g., through phys-
ical image extraction [29]. We note that it is a common practice in
forensics that the forensic investigator can retrieve the file system
image, e.g., using SRSRoot [6]. There could be thousands of files on
the device. For example, we extracted the physical image of a Nexus
7 tablet that was used for around 5 years. The device has installed
90 apps (including both system and user apps), which generated
around 19K files. The forensic investigator aims to identify the
files on the device that could contain certain types of evidentiary
data, e.g., GPS locations, visited URLs. We call the problem evidence
identification problem, and we formally describe it as follows:

Definition 2.1 (Evidence Identification Problem). Given an image
of a device’s file system and a type of evidentiary data, the evidence
identification problem is to identify the files (if any) that contain
the type of evidentiary data.

In this work, we focus on solving the evidence identification
problem for Android smartphones. Moreover, we focus on the evi-
dentiary data including location, time, visited URL, and text input as
they were shown to be useful digital evidence in real-world crime
investigations [14, 27, 32, 42]. For instance, GPS locations and texts
retrieved from suspects’ smartphones were used to corroborate
charges in one of the biggest poaching cases in Washington [14];
visited URLs retrieved from a suspect’s smartphone are used as
important digital evidence for investigating a kidnapping case that
happened at University of Illinois Urbana-Champaign in 2017. Al-
though we focus on these types of evidentiary data, our techniques
can be easily extended to other types of data such as contacts, device
ID, and sensors, if a forensic investigator is interested in analyzing
such data for potential evidence.

3 EVIHUNTER
3.1 Overview
Figure 2 overviews our EviHunter, which consists of two compo-
nents, App Evidence Database and Matcher.
App Evidence Database (AED): AED contains the evidentiary
data for a large number of apps. Specifically, each row of AED
represents a file that could be generated by an app and the types
of evidentiary data that the file contains. Files are identified by
their file paths. AED has three columns: the first column includes
apps’ package names; the second column includes file paths; and
the third column indicates the types of evidentiary data that the
corresponding file could contain. A file path could be either static or
dynamic. Specifically, if a file path does not depend on the execution
environment of the app that generates the file, then the file path is
static, otherwise it is dynamic. Therefore, if an app uses a static file
path for a file, then this file has the same path on different devices;
if an app uses a dynamic file path for a file, then the file path could
be different on different devices and at different times. For instance,
an app could use timestamp as a part of a file’s name, which results
in a dynamic file path. In our AED, a dynamic file path includes
the pattern for the dynamic part. For instance, /data/data/<package
name>/files/evidence-<timestamp>.txt represents that the app could

Figure 2: Overview of our EviHunter.

generate a file whose file name includes the timestamp when the
file was generated.

Matcher: Given a file system image from a suspect’s device, the
Matcher matches the file paths on the device against those in the
AED, to identify the files on the device that could contain the
evidentiary data of interest to forensic investigators. If the device
has an app that is not included in AED, we will analyze the app
using EviHunter and add the results into AED. A file path on the
device is matched against a file path in the AED if they are the
same.

Moreover, when matching a file path against a dynamic file
path in the AED, a forensic investigator can use partial match via
ignoring the dynamic part or consider the pattern (e.g., date format)
of the dynamic part via regular expression.

Next, we discuss how EviHunter builds the AED.

3.2 Building the AED via Static Analysis
AED should have a high coverage to avoid missing potential eviden-
tiary data. Specifically, for an app, AED should include as many file
paths that contain evidentiary data as possible. we leverage static
analysis instead of dynamic analysis to build the AED. In particular,
we develop a static data-flow analysis method to build an AED for
a large number of apps. Specifically, in our static data-flow analysis,
we define a customized tag structure for variables and propagate
the tags in an app via forward analysis. We leverage existing sink
methods for file system found by existing tools [12, 21, 35]. How-
ever, we uncover new sources as the sources in existing tools are
not complete.

3.2.1 Pre-processing. Given an app, we first use Soot [43] to trans-
form the app to Jimple code, a three address intermediate repre-
sentation. Second, we use IC3 [16] to build the inter-connected
component communication (ICC) models. Finally, we use Flow-
Droid [12] to construct call graphs and entry points. The latest
version of FlowDroid has integrated IccTA [28] to incorporate the
ICC models when building call graphs. FlowDroid also extracts the
app’s package name, which we will use as the app’s identifier. We
note that FlowDroid alone is insufficient to build our AED. Specifi-
cally, FlowDroid aims to identify data flows from sources to sinks.
However, FlowDroid does not identify the file paths where data are
written to.

3.2.2 Tag for a Variable. We define a tag structure for each variable,
e.g., primitive, object, and class field. Then, we propagate variables’

App Evidence DatabaseFile System Image of Suspect’s DeviceMatcherForensic Analysis ReportApp Package NameEvidence File PathEvidence Typecom.app1com.app1com.app2com.app2 /data/data/com.app1/files/a.txtlocation, time /data/data/com.app1/databases/m.sqlitevisited URL /data/data/com.app2/shared_prefs/b.xmltext input /data/data/com.app2/cache/crash.bintimeEviHunter

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Table 2: Propagation rules of non-method-invoking statements. Ca is a constant string, while Cb
is a constant that is not string. fA and fB are static fields, while fa and fb are instance fields.

Statement

EvSet
t(va ).EvSet ← ∅
t(va ).EvSet ← ∅
t(va ).EvSet ← t(vb ).EvSet
t(va ).EvSet ← t(fB ).EvSet
t(fA).EvSet ← t(vb ).EvSet
t(va ).EvSet ← t(vb .f ).EvSet
t(va .f ).EvSet ← t(vb ).EvSet
t(va ).EvSet ← t(vb ).EvSet
t(va ).EvSet ← t(va ).EvSet ∪ t(vc ).EvSet
t(va ).EvSet ← t(vb ).EvSet ∪ t(vc ).EvSet
2 t(va ).EvSet ← t(vb ).EvSet ∪ t(vc ).EvSet

va = Ca
va = Cb
va = vb
va = fB
fA = vb
va = vb .fb
va .fa = vb
va = vb [vc ]
va [vb ] = vc
va = vb
1
va = vb binop vc
1 When vb and vc are string values.
2 When the binary operator binop is not “+”.

+ vc

Propagation Rule
Path
t(va ).Path ← C
t(va ).Path ← ∅
t(va ).Path ← t(vb ).Path
t(va ).Path ← t(fB ).Path
t(fA).Path ← t(vb ).Path
t(va ).Path ← t(vb .f ).Path
t(va .f ).Path ← t(vb ).Path
t(va ).Path ← t(vb ).Path
t(va ).Path ← t(vc ).Path
t(va ).Path ← t(vb ).Path + t(vc ).Path
t(va ).Path ← ∅

tags via performing forward data-flow analysis starting from the
entry point in the call graph. We denote by t(v) the tag for a variable
v. The tag should carry sufficient information to identify both
the types of evidentiary data and the file paths. To achieve these
goals, we propose a tag structure which includes the following
information:

• Evidence type set (EvSet): Types of evidentiary data that a

variable could contain.

• File path (Path): File path associated with a variable. For
instance, when an app writes data to file system via a file
descriptor, the Path associated with the file descriptor is the
file where data are written to.

We note that in conventional static analysis tools that were
designed to detect sensitive data flows in Android apps, a tag often
only includes the data types (i.e., EvSet in our case).

3.2.3 Propagation Rules. Propagation rules define how tags are
updated when analyzing the statements in an app. Our rules are
applied to the three-address Jimple code of an app. We classify
statements into two groups, i.e., non-method-invoking statements
and method-invoking statements. We discuss the propagation rules
for them separately.

Non-method-invoking statements: Table 2 shows the propa-
gation rules for the possible non-method-invoking statements in
the Jimple intermediate representation. When a statement assigns
a constant string to a variable, we set the EvSet and Path of the
variable’s tag to be empty and the constant, respectively; if the
constant is not a string, we will set both EvSet and Path to be empty.
Moreover, when a statement assigns one variable’s value to another
variable, i.e., va = vb , we assign vb ’s tag to va . Next, we discuss
the statements with more complex assignment relationships.

• Class field access: A class field can be a static field or an
instance field. A static field is shared by all instances of a
class, while an instance field is unique to an instance of a

class. Each field has a tag. We maintain static fields of a class
in a globally available map, where static fields are keys and
their tags are values in the map. For an instance, we use
a map to maintain its instance fields and their tags, where
fields are keys and their tags are values in the map. This map
structure can help track the fields of an object.

• Array access: For an array variable va , we store its tag t(va )
as the union of the tags of its elements. Moreover, for each
array, we maintain a map that stores the tags of its elements.
For instance, t(va .i) is the tag of the ith element of the ar-
ray variable va . For each array access, we resolve the index
whenever we can. Suppose we have an assignment statement
va [vb ] = vc . If the index variable vb can be resolved, we
propagate tags as t(va .vb ) ← t(vc ), otherwise we merge the
evidence set t(vc ).EvSet of the variable vc into that of va . In
the case of the statement va = vb [vc ], if vc is resolvable, we
assign the tag of the element vc to va , otherwise we assign
the tag of the array variable vb to that of the variable va .
The propagation rules for array access shown in Table 2 are
for the scenarios where index cannot be resolved.

• Binary operator: We propagate the union of the EvSet of the
two operands for all binary operators. If the operator is +
and both operands are string, then we update the Path as the
concatenation of the Path of the two operands, otherwise
we set the Path to be empty.

v1.method(v2, v3, · · · );
v0 = v1.method(v2, v3, · · · );

(1)

(2)

Method-invoking statements: A method-invoking statement could
be a method call without leveraging the return value or a method
call with assigning the return value to a variable. We abstract the
two cases in Equation 1 and 2, respectively. In the first case, we

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan

Table 3: Data-flow summary of example Android APIs for file access.

Method

getDataDirectory()

getCacheDir()

getFilesDir()

getFileStreamPath(String v2)
openFileOutput(String v2, int v3)
getDataDir()

openOrCreateDatabase(String v2, ... )
openDatabase(String v2, ... )
getSharedPreferences(String v2,int v3)
getDefaultSharedPreferences(Context v2)
getPreferences(int v2)
getDir(String v2, int v3)
openOrCreateDatabase(File v2, ... )
getExternalStorageDirectory()

getExternalStoragePublicDirectory(String v2)

getObbDir()

getExternalCacheDir()

getExternalFilesDir(String v2)

Data-flow Summary

t (v0).Path ← "/data/"
t (v0).Path ← "/data/data/<package name>/cache/"
t (v0).Path ← "/data/data/<package name>/files/"
t (v0).Path ← "/data/data/<package name>/files/" + v2
t (v0).Path ← "/data/data/<package name>/files/" + v2
t (v0).Path ← "/data/data/<package name>/databases/"
t (v0).Path ← "/data/data/<package name>/databases/" + v2
t (v0).Path ← "/data/data/<package name>/databases/" + v2
t (v0).Path ← "/data/data/<package name>/shared_prefs/" + t (v1).Path + ".xml"
t (v0).Path ← "/data/data/<package name>/shared_prefs/<package name>_preferences.xml"
t (v0).Path ← "/data/data/<package name>/shared_prefs/<context>.xml"
t (v0).Path ← "/data/data/<package name>/app_" + v2
t (v0).Path ← t (v2).P ath
t (v0).Path ← "/sdcard/"
t (v0).Path ← "/sdcard/", if v2 is empty.
t (v0).Path ← "/sdcard/" + v2 + "/", otherwise.
t (v0).Path ← "/sdcard/Android/obb/<package name>/"
t (v0).Path ← "/sdcard/Android/data/<package name>/cache/"
t (v0).Path ← "/sdcard/Android/data/<package name>/files/", if v2 is empty.
t (v0).Path ← "/sdcard/Android/data/<package name>/files/" + v2 + "/", otherwise.

propagate the tags of the base instance v1 (if available) and argu-
ments v2, v3, · · · into the callee and analyze the data flow in the
callee. In the second case, we will analyze data flow in the callee
and assign the tag of the return value to that of the variable v0. We
note that when analyzing method calls, we may get into a loop of
method calls. For example, if there is a loop in the call graph of an
app. We avoid the loop by using a stack to keep track of method
calls and skipping a method call if the method is already on the
stack. Essentially, we analyze the methods in a loop in the call graph
once.

3.2.4 Multi-threading and Reflection. Multi-threading and reflec-
tion are well known challenges for static program analysis. We
leverage the techniques from the state-of-the-art static analysis
tools [13, 15, 21] to partially handle multi-threading and reflection.
Specifically, for multi-threading, we assume the threads execute
in a sequential order, following prior studies [13, 15]. Therefore,
whenever a certain thread is spawned and starts running, we find its
corresponding entry method and redirect analysis to it. For exam-
ple, an instance invoke of method start() in java.lang.Thread
will be redirected to its actual running method run(). We handle
the dedicated Android threading library android.os.AsyncTask
and android.os.Handler by method redirecting as well. For re-
flection, we analyze the reflective call only if the method can be
parsed statically, following prior static analysis tools [15, 21]. In
particular, EviHunter uses the parsed declaring class name and Path
information to determine the actual method call and redirect the
reflective call to it.

Table 4: Data-flow summary of example Java APIs for file
path construction.

Method
FileWriter <init>(File v2)
File <init>(File v2, String v3)

Data-Flow Summary
t(v1).Path ← t(v2).Path
t(v1).Path ← t(v2).Path + v3

3.2.5 Data-Flow Summary for System APIs. For complexity consid-
eration, we manually summarize the data flows for the commonly
used system APIs and skip the remaining ones, instead of incor-
porating the framework code into EviHunter. We note that Droid-
Safe [21] proposed a technique to model framework, which was
able to find more sensitive data flows in benchmark apps. However,
Reaves et al. [36] found that DroidSafe requires a large amount
of main memory and fails to analyze real-world apps. In addition,
DroidSafe does not track the file paths where data are written to.
Therefore, we do not adopt the technique in DroidSafe to model
framework.

When we discuss the data-flow summary for system APIs, we

will refer to Equation 1 and 2 for the definition of variables.

System APIs to construct file paths: Java provides APIs for apps
to construct file paths and access files in a hard-coded approach. We
summarize data flows for these APIs. Table 3 shows the data-flow
summary for some example Android APIs that are used to get file
paths. Table 4 shows data-flow summary for example APIs. As we
described in Section 2.1, Android provides APIs for apps to locate
files in a soft-coded approach. A majority of these Android APIs
can be summarized using their arguments and the app’s package

EviHunter

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Table 5: Data-flow summary of example APIs for string op-
eration and commonly used data structures.

API

Data-Flow Summary

toString()
valueOf(double v2)
read(byte[] v2)

<init>(String v2)

concat(String v2)

add(Object v2)

t(v0) ← t(v1)
t(v0) ← t(v2)
t(v1) ← t(v2)
t(v0).Path ← v2
t(v0).EvSet ← t(v2).EvSet
t(v0).Path ← t(v1).Path + v2
t(v0).EvSet ← t(v2).EvSet ∪ t(v1).EvSet
t(v1).EvSet ← t(v1).EvSet ∪ t(v2).EvSet

name. For instance, the API getExternalFilesDir(String) returns a file
object whose file path is /sdcard/Android/data/<package name>/files/
if the input parameter is an empty string, otherwise the file path
is /sdcard/Android/data/<package name>/files/v2/, where v2 is the
input parameter.

However, there are two cases that require extra information to
summarize the file paths for Android APIs. The first one is get-
Preferences(int) that returns a SharedPreferences file whose file
path depends on the Context class. Context refers to the runtime
environment, for example, a launching Activity named "MainAc-
tivity". If "MainActivity" creates a SharedPreferences file by get-
Preferences(int), the file name is "MainActivity.xml". To handle this
case, we trace back the method calls until finding the Context and
we use the class name of the Context to resolve the corresponding
SharedPreferences file path.

The second case is the SQLite database creation and access
through SQLiteOpenHelper. An app can access a SQLite database
via creating a class inheriting this helper class and handling the
inherited callback methods. When the inherited class is initialized,
a SQLite database is created through the helper class initializa-
tion method SQLiteOpenHelper<init>(Context, String, · · · ), where
the 2nd argument is the database name and the database is lo-
cated in the directory /data/data/<package name >/databases/. When
getWritableDatabase() is called to retrieve database object, we search
the declaring class name and assign the database file path to the
corresponding variable’s tag.

We note that these Android APIs have changed over Android
versions. Therefore, in practice, our tool requires summarizing data
flows for these Android APIs for different versions.
System APIs for string operations and commonly used data
structures: W summarize the data flows of APIs for string opera-
tions. Example APIs include toString(), valueOf(), <init>(String) (for
string initialization), and concat(String). Moreover, we summarize
the data flows for collection class, string buffers, and similar com-
monly used data structures such as HashSet and ArrayList. Table 5
shows our data-flow summary for some example APIs.
System native methods: We obtain a list of system native meth-
ods from DroidSafe [21]. For each system native method call, we
make an over-approximation of evidence types for each input/out-
put variable involved in the method call. Specifically, we take the
union of the evidence set EvSet of the input variables, and we assign

1
2
3
4
5
6
7
8
9
10
11
12
13
14

v o i d f o o ( ) {

WebView wv =

( WebView ) f i n d V i e w B y I d ( R . i d . webView ) ;

S t r i n g t e s t U r l = " h t t p : / / www. f o o . com " ;
wv . l o a d U r l ( t e s t U r l ) ;
s i n k ( t e s t U r l ) ;
wv . s e t W e b V i e w C l i e n t ( new WebViewClient ( ) {

@Override
p u b l i c v o i d o n P a g e F i n i s h e d
( WebView view , S t r i n g u r l ) {

s i n k ( u r l ) ;

}

} ) ;

}

Listing 2: Method arguments as sources for URL.

the union to each input variable and output variable. We update
input variables because they may be modified within the native
method.

Sources and Sinks. In EviHunter, a sink is a system API that
3.2.6
writes data to file system, while a source is where evidentiary
data are created or file path is created. We first combined the pub-
licly available sources and sinks in existing tools including Flow-
Droid [12], SuSi [35], and DroidSafe [21]. These sources and sinks
were also used by more recent tools, e.g., HornDroid [15].

We use the sink methods combined from existing tools. However,
we found that the combined source methods for evidentiary data
are not complete. In particular, existing tools missed the methods
whose arguments indicate sources. Moreover, they did not consider
sources for file paths. Therefore, we extend the source methods for
evidentiary data and uncover the sources for file paths. We make
the sources and sinks used by EviHunter publicly available [5].

Sources for evidentiary data (EvSet): In this work, we focus on
the types of evidentiary data including location, text input, time, and
visited URL as they were shown to be useful in real-world crime
investigations [14, 27, 32, 42]. However, our EviHunter can be ex-
tended to other types of evidentiary data if needed. Specifically, we
can add the sources for those types of evidentiary data in EviHunter
and extend the EvSet in tags. Next, we discuss the sources for each
of the four types of evidentiary data.

1) Location: Location includes GPS location and course-grained
location determined by WiFi and/or cellular data. We treat an An-
droid API that returns location data as a source. We obtained 39
source methods for location from existing tools [12, 21, 35]. More-
over, we found that GPS location can also be created in the argument
of a method. Specifically, the argument of the method onLocation-
Changed(android.location.Location) stores a GPS location. Therefore,
when we analyze a statement that involves onLocationChanged, we
will add the data type location to the argument’s tag.

2) Text input: Text input is the string data typed in by users.
For example, an instant message in a social networking app is a text
input; a search query is a text input. We obtained 2 source methods
for text input from existing tools [12, 21, 35].

3) Time: We obtained 16 source methods for time from existing
tools [12, 21, 35]. Moreover, we found one more source method for
time, i.e., currentTimeMillis(), which returns the system timestamp.
4) Visited URL: A user could visit URLs via a browser or a
non-browser app using WebView. We obtained 3 source methods

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan

Table 6: The AED that EviHunter constructed for the 4 benchmark apps in DroidBench. <internal storage> refers to “/data/-
data/<package name>”.

App Package Name

Evidence File Path

de.ecspride

<internal storage>/files/out.txt

Evidence Type

Device ID

edu.mit.event_context_shared_pref_listener

<internal storage>/shared_prefs/settings.xml Device ID

edu.mit.icc_event_ordering

<internal storage>/shared_prefs/prefs.xml

Device ID

org.cert.writeFile

<internal storage>/files/sinkFile.txt

Location

Table 7: The AED that EviHunter constructed for the three benchmark apps we designed. <internal storage> refers to “/data/-
data/<package name>”, while <external storage> represents “/sdcard/Android/data/<package name>”.

App Package Name

Evidence File Path

Evidence Type

com.evihunter.GPS

<internal storage>/shared_prefs/com.evihunter.GPS_preferences.xml Time

com.evihunter.GPS

<internal storage>/databases/mfGps.db

com.evihunter.GPS

<internal storage>/files/<timestamp>.txt

com.evihunter.Browser <internal storage>/app_goo2/goo3

com.evihunter.Browser <internal storage>/files/foo_<UUID>.bin

com.evihunter.Browser <external storage>/files/foo3

com.evihunter.Browser /sdcard/browser_<intent>.txt

com.evihunter.IM <internal storage>/databases/mfChat.db

Location, Time

Location

Visited URL

Time

Visited URL

Time

Text Input, Time

that return URLs from existing tools [12, 21, 35], and we found
one more source method whose return value is URL. Moreover,
we found that the arguments of certain Android APIs and callback
methods correspond to visited URLs. Listing 2 shows an example.
testUrl is initialized as a string constant, passed to the Android API
loadUrl(testUrl) as an input argument, and finally written to the file
system. We can identify that the testUrl is a visited URL because it is
used as an argument of the Android API loadUrl(String). Therefore,
once a variable is used as an argument of loadUrl(String), we add
the data type visited URL to the EvSet of the variable’s tag.

Arguments of certain callback methods also indicate URLs. For
instance, the second argument of the callback method onPageFin-
ished(...) (e.g., line 9 in Listing 2) corresponds to a URL. In total,
we find 6 callback methods whose arguments correspond to URLs.
Once a variable is passed as the corresponding argument of these
methods, we extend the variable’s tag to include visited URL.

Sources for file paths (Path): An app could use a static file path
or a dynamic file path. When a constant string is assigned to a
variable, we initialize the variable’s Path as the constant. In order to
understand dynamic file paths, we sampled 100 dynamic file paths
in our preliminary analysis results and did a manual measurement
study about them. Via manually analyzing the code, we found the
top-3 ways that apps use to generate dynamic file paths include
intent, timestamp, and universally unique identifier (UUID), which
represent 33%, 20%, and 12% of the dynamic file paths, respectively.
Intent refers to the case where a part of the file path is constructed
from an intent that is used for inter-component communications.
When a variable is assigned as the return value of a method that
corresponds to intent, we assign the variable’s Path as <intent>. We
found 38 such methods. UUID is a 128-bit random string generated

by the API randomUUID() in the class java.util.UUID. When a
variable is assigned as the return value of the API randomUUID(),
we initialize the variable’s Path as <UUID>. Timestamp refers to the
case where a part of the file path is constructed using the system
time. When a variable is assigned as the return value of a system
method that returns system time, we initialize the variable’s Path as
<timestamp>. We use the source methods for time that we discussed
in the above as sources for <timestamp>.

4 EVALUATION
We aim to evaluate the AED generated by EviHunter. First, we
evaluate EviHunter using benchmark apps from DroidBench and
benchmark apps that we design. Second, we evaluate EviHunter on
a large number of real-world apps. Third, we show a case study on
how a forensic investigator can use EviHunter to find evidentiary
data on an Android smartphone.

Our implementation leverages Soot [43] to transform an app to
Jimple code, IC3 [16] to build inter-component communications
models, and FlowDroid [12] to build call graphs and entry points.
We perform our experiments on an Intel® Xeon® CPU E5-1603 v3
@ 2.8GHz running Ubuntu 14.04 with 64GB of heap memory for
the JVM.

4.1 Results on Benchmark Apps
Previous studies on mobile security and privacy have designed and
published some benchmark apps, e.g., DroidBench [1] provides a
collection of benchmark apps. Among the 120 benchmark apps
in DroidBench, we found only 4 apps have sinks to a file system
and they all use the soft-coded approach to construct file paths.
One possible reason is that these benchmark apps were designed

EviHunter

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Table 8: Analysis results for each type of evidentiary data on the 8,690 real-world apps. The column “Static” indicates the
number of static file paths; the column “Dynamic” indicates the number of dynamic file paths; and the column “App” indicates
the number of apps. “Others” indicates a file that does not include the four specified types of evidentiary data.

Evidence Type

SQLite Database
Static Dynamic

App

SharedPreferences
Dynamic
Static

Location

Time

Visited URL

Text Input

Others

145

343

20

166

903

0

0

0

0

3

145

316

19

155

721

195

1128

25

410

5941

0

1

0

1

3

App

72

924

25

388

Ordinary File
Static Dynamic

151

431

19

184

0

4

0

2

App

151

411

18

148

3135

6901

576

3448

Table 9: Summary of the analysis results for the 8,690 real-
world apps.

File Type

Evidence File Path
Static File Path Dynamic File Path

SQLite Database

SharedPreferences

Ordinary File

Total

674

1758

785

3217

0

2

6

8

for privacy studies and storing sensitive data only at the local file
system without sending them to the Internet may not be consid-
ered as a privacy leakage. Among the 4 apps, 3 of them consider
device ID as sensitive data and the remaining one considers GPS
location as the sensitive data. To analyze these benchmark apps,
we extend EviHunter to incorporate device ID as evidentiary data.
Specifically, we add the system APIs that return device ID to the
sources. Table 6 shows the AED that EviHunter constructed for
the 4 benchmark apps. EviHunter finds all the file paths accurately
in the 4 apps. We note that in the app org.cert.WriteFile, the GPS
location data is passed between components. EviHunter accurately
identifies the location data. This is because EviHunter leverages the
inter-component communications support in FlowDroid to track
evidentiary data across components.

However, the 4 benchmark apps have limitations at evaluating
EviHunter. Specifically, they all use the soft-coded approach to con-
struct file paths; they only consider SharedPreferences and ordinary
files; and they only consider device ID and GPS location as data
sources. To address these limitations and better evaluate EviHunter,
we design three benchmark apps by ourselves. Specifically, our
benchmark apps are GPS, Browser, and Instant Messenger, whose
package names are com.evihunter.GPS, com.evihunter.Browser, and
com.evihunter.IM, respectively. As their names suggest, these apps
are designed to mainly evaluate evidentiary data location, visited
URL, and text input, respectively. The data type time is covered by
more than one benchmark app. When we design the benchmark
apps, we consider static file paths, dynamic file paths, soft-coded
approach and hard-coded approach for file path construction, as
we as SQLite database files, SharedPreferences files, and ordinary
files. In particular, dynamic file paths include the three popular
patterns <timestamp>, <UUID>, and <intent> that we discussed in
Section 3.2.6.

We use EviHunter to analyze the three benchmark apps. Table
7 shows the AED EviHunter constructed for the three apps. Evi-
Hunter accurately finds all the file paths that could store evidentiary
data for the three benchmark apps.

4.2 Results on Real-World Apps
We obtained 8,690 real-world Google Play apps collected by Play-
Drone [44]. We use EviHunter to build an AED for these apps. Some
apps take a long time to be fully analyzed. Since we aim to analyze a
large number of apps, we set a 3-minute timeout for each real-world
app analysis. Specifically, if our tool does not finish analyzing an
app within 3 minutes, we force the analysis to abort and report the
analysis results. Note that the 3 minutes timeout does not count the
time used for preprocessing an app via Soot, IC3, and FlowDroid.
Our analysis stops early for 583 apps (6.7% of total apps) due to the
3-minute timeout.

Table 9 summarizes our analysis results, and Table 8 further
shows the analysis results for each type of evidentiary data. A
reported file could include at least one type of evidentiary data
including location, visited URL, time, and/or text input. A file path
is treated as dynamic file path if the file path includes one of the
three patterns <timestamp>, <UUID>, and <intent>. All other paths
are treated as static file paths. Our manual measurement study
(discussed in Section 3.2.6) showed that around 65% of dynamic file
paths use the patterns <timestamp>, <UUID>, and/or <intent>. In
other words, around 35% of dynamic file paths are treated as static
file paths. Therefore, a small number of the static file paths shown
in the table are actually dynamic file paths.

First, static file paths are much more frequently used than dy-
namic file paths by app developers. Specifically, since around 65% of
dynamic file paths use the patterns <timestamp>, <UUID>, and/or
<intent>, the total number of dynamic file paths is around 12. There-
fore, around 0.4% of file paths are dynamic file paths. Second, Shared-
Preferences are more frequently used in apps than SQLite database
and ordinary files (e.g., text and binary files). The reason may be
that SharedPreferences are well defined lightweight data structures
and provide rich APIs for developers to maintain data easily. Inter-
estingly, in dynamic file paths, ordinary files are more frequently
used than SQLite database and SharedPreferences.

App popularity: We randomly sampled some apps and collected
their metadata on Google Play. In total, we collected metadata
of 1,130 randomly sampled apps. Among these apps, EviHunter

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan

Figure 3: App popularity.

reports that 661 of them store evidentiary data in the file system.
Figure 3 shows the number of apps that have a given number of
downloads. We observe that the apps that store evidentiary data
on the file system have diverse popularity, ranging from hundreds
of downloads to millions of downloads. Moreover, whether an app
stores evidentiary data on the file system does not depend on its
popularity. Specifically, around half of the apps in each category of
popularity (e.g., < 500, 5K-10K, or >1M) store evidentiary data on
the file system.

Manual verification: Without ground truth, it is challenging to
evaluate our results for the real-world apps. We perform a best-
efforts manual verification. Specifically, we randomly sampled 30
apps that EviHunter reports to have at least one file containing
evidentiary data. We installed each app on a smartphone, clicked as
many buttons of the app as possible, and typed in text inputs when
we can. Then, we manually analyzed each file generated by the
apps. In total, these apps generated 559 files. EviHunter reported
that 72 of them could contain evidentiary data.

For a given type of evidentiary data (e.g., GPS), a file is a false
positive if EviHunter reports that the file includes the evidentiary
data but the file actually does not; and a file is a false negative if
EviHunter reports that the file does not include the evidentiary data
but the file actually does. We note that a file could be both false posi-
tive and false negative with respect to different types of evidentiary
data. For instance, suppose a file includes GPS data and EviHunter
reports that the file includes visited URL. Therefore, this file is a
false positive with respect to visited URL and a false negative with
respect to GPS. We compute the precision and recall for each type
of evidentiary data. We find that EviHunter achieves a precision of
90% and a recall of 89% averaged over the four types of evidentiary
data considered in the paper. Additionally, we randomly sampled
30 apps that EviHunter did not report any file containing the four
specified types of evidentiary data, and we manually verified the
analysis results for them. Our verification did not find any false
negatives.

Privacy implications: We find that 5 apps save GPS locations
on external storage; 8 apps save visited URLs on external storage;
and 27 apps save text inputs on external storage. This result has
serious privacy implications. Specifically, any app that has the
READ_EXTERNAL_STORAGE and INTERNET permissions can
read data from the external storage and send them to the Internet.
If a user installs an app that saves sensitive data on the external

Figure 4: GPS location and time data collected by the app in
our case study.

storage, then other apps on the user’s smartphone could monitor
such data to compromise user privacy and security, even if the apps
do not have permissions to access the sensitive data. For instance,
an app can track user locations via monitoring GPS locations on the
external storage; and an app can perform web tracking to profile a
user via the visited URLs on the external storage.

Via manual analysis, we found that one app, whose functionality
is to backup contacts, saves a user’s plaintext email address, phone
number, and password to three separate files on the external storage.

4.3 A Case Study
We use a case study to demonstrate how a forensic investigator can
use EviHunter to identify evidentiary data on an Android smart-
phone. Among the real-world apps that we analyzed, we found 133
apps could write GPS location and time data to a SQLite database
with a static file path <internal storage>/databases/databases/ldata.db.
After manual analysis about these apps, we found that this database
file is generated and accessed by a third-party advertisement library
called airpush. The package name for this library is com.yrkfgo.assxqx4.
The advertisement library registers a location listener. Once a de-
vice’s GPS location changes, the library will receive the GPS loca-
tion, and then the library writes the GPS location as well as system
time into the file <internal storage>/databases/databases/ldata.db.
The advertisement library uses GPS location to provide location-
based advertisements. We speculate the reason that the library saves
GPS locations in a local file system is to approximate a device’s
location when real-time GPS locations are unavailable.

We simulate a suspect’s device using an Android smartphone
and perform forensic investigation on the smartphone’s file sys-
tem. Specifically, we installed an app, whose package name is
com.vijay.tamilrecipes, on the smartphone. The app uses the air-
push library. One author of the paper walked around a building
with the smartphone for a while, such that the app collected and
stored GPS location and time data into the smartphone’s file system.
Then, we retrieved an image of the smartphone’s file system. We
matched the file system image against the AED we constructed
in the previous section. In particular, we matched the file path
/data/data/com.vijay.tamilrecipes/databases/databases/ldata.db and
our AED showed that this file path stores location and time data.
Figure 4 shows a part of the database file. The columns of the data-
base include _id (event id for location changes), latitude, longitude,
and date. A forensic investigator could use these GPS location and
time data to assist crime investigation. For instance, a forensic in-
vestigator could use these data as a digital evidence to determine
whether the suspect was at the crime scene or not when the crime
happened.

The total number of installations for these 133 apps is more
than 10M. If a suspect has installed at least one of these apps on

<500500-1K1K-5K5K-10K10K-50K50K-100K100K-500K500K-1M>1MNumber of downloads050100150200250Number of appsAll appsApps with evidentiary dataEviHunter

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

its Android smartphone, a forensic investigator could use the GPS
location and time data saved by the app(s) as evidence for crime
investigations.

5 DISCUSSIONS AND LIMITATIONS
EviHunter shares the limitations of many static data-flow analysis
tools [12, 13, 19–21, 25, 30, 45, 49] for Android. Specifically, Evi-
Hunter over-approximates the system native methods and does
not consider the developer-defined native methods. EviHunter only
considers the reflective method calls that can be statically resolved.
In general, EviHunter cannot handle dynamic class loading. For
instance, an app could download a DEX file from Internet and exe-
cute it during runtime. Without runtime environment information,
static program analysis cannot handle the loaded library. One pos-
sible way to mitigate this challenge is to download the dynamically
loaded classes and statically analyze them together with the app.

EviHunter leverages IC3 and FlowDroid to support inter-component

communications for the analysis of evidentiary data. However, Evi-
Hunter has basic support for inter-component communications
with respect to file path propagation. In particular, if a dynamic
file path includes intent in inter-component communication, Evi-
Hunter uses a regular expression <intent> as a part of the file path.
Moreover, EviHunter has basic support for system APIs. In par-
ticular, we manually summarize the data flows for system APIs
that are related to file path constructions, string operations, and
commonly used data structures. It would be an interesting future
work to model frameworks. We note that the framework modeling
technique proposed by DroidSafe [21] is insufficient for our file
system forensics problem because of two reasons: 1) the technique
is not scalable to real-world apps [36], and 2) the technique only
captures the flows of sensitive data, but not file paths.

Another limitation revolves around matching file paths on a sus-
pect’s device against those in an AED. In particular, some dynamic
file paths may not be successfully matched. For instance, suppose a
file has a file name that completely consists of an intent. EviHunter
will represent the file name as <intent>. However, since we do not
produce any fine-grained patterns for the intent, it is hard to match
the file on a suspect’s device with the right dynamic file path in the
AED. As a result, we will incorrectly treat the file as a file that does
not include evidentiary data. We believe it is an interesting future
work to extend our tool to support more fine-grained analysis for
dynamic file paths. For instance, via inter-component communi-
cation analysis, we may uncover patterns within an intent. We
can include these fine-grained patterns into the regular expression
<intent> in a dynamic file path. When matching file paths, we can
consider such patterns via regular expressions.

When our tool identifies files on a suspect’s device that contain
evidentiary data, a forensics investigator still needs to retrieve,
decode, or reconstruct the evidentiary data from the files. If a file is
a text file, SQLite database, or SharedPreferences, then retrieving
data from the file is relatively easy. However, for a binary file or an
encrypted file, a forensic investigator needs the format of the binary
file or the encryption method to retrieve the evidentiary data. Our
current tool does not support the format analysis of binary files.
It is an interesting future work to extend EviHunter to track the
format of a binary file.

6 RELATED WORK
6.1 Digital Forensics for Android
6.1.1 Permanent-Storage Forensics. Permanent-storage forensics
for Android is still an underdeveloped research area. Most exist-
ing studies and tools on this topic simply leverage either manual
analysis or keyword search. As a result, they can only analyze a
small number of apps or construct an inaccurate AED. Our work
represents the first one to perform automated permanent-storage
forensic analysis for Android via program analysis.

Manual analysis: Some studies [9–11, 46] manually analyzed apps
in order to construct an AED. Specifically, they install apps on an
Android device or run the apps in a sandbox environment (e.g.,
Android Emulator [4] and YouWave [8]). Then, they retrieve an
image of the file system from the device or the sandbox environ-
ment. Specifically, the file system image can be retrieved from a
device using the Android Debug Bridge. The file system image can
be either logical or physical, where a physical image could also
include the deleted files that are not overwritten yet. By running
apps under a sandbox environment, researchers have control over
the file system and main memory, so they can also retrieve im-
ages of the RAM and NAND flash memories. After obtaining a file
system image, they manually examine the files generated by the
apps, e.g., analyzing the files under a directory /data/data/<package
name>/files/, where <package name> refers to the package name of
the app to be analyzed.

Since manual analysis is time-consuming, error-prone, and costly,
these studies often only analyzed a very small number of apps. In
particular, they often focused on instant messaging apps (e.g., What-
sApp [11], WeChat [46]) and maps navigation apps [31]. They found
that instant messaging apps often save messages (i.e., a certain type
of text input) on the local file system, while maps navigation apps
collect GPS location history and post on databases.

Keyword search: Several commercial tools (e.g., Cellebrite UFED [2],
XRY [7], and FTK [3]) are available to analyze the files on a device.
Specifically, given a device, these tools first retrieve an image of
the device’s file system. Then, these tools provide Graphical User
Interface (GUI) for forensic investigators to search files that could
contain evidentiary data. However, the search is only performed by
keyword matching or regular expression matching, which clearly
has limitations. For instance, if a file contains GPS data but does
not have the regular expressions or keywords such as GPS, latitude,
or longitude, then the file will be incorrectly labeled as a file that
does not contain evidentiary data. Indeed, studies [23] showed that
tools based on keyword matching can only identify a small fraction
of files that could store evidentiary data.

6.1.2 Memory Forensics. Several tools [37–40] were recently de-
veloped for memory forensics. For instance, DSCRETE [40] au-
tomatically renders data structure contents in memory images.
The intuition is that the app that defines a data structure often in-
cludes rendering and interpretation logic for the data structure, and
DSCRETE leverages such logic. VCR [38] is a memory forensics tool
that recovers all photographic evidence an Android device’s camera
produces. GUITAR [37] is a memory forensics tool to automatically
reconstruct apps’ GUIs from a memory image. However, GUITAR

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan

cannot reconstruct an app’s previous screens. RetroScope [39] ad-
dressed this limitation by leveraging two observations: (1) app data
on previous screens stay longer than the corresponding GUI data
structures in memory, and (2) each app can redraw its screens when
receiving commands from the Android framework. These tools are
different from ours as our tool is designed for permanent-storage
forensics instead of memory forensics.

6.1.3 Active Forensics. Several studies [24, 26, 34, 47] proposed
active forensics. Specifically, they proposed to design monitoring
apps, which are installed on a device in advance. Then, the app
can collect the forensic information when the device uses other
apps. For instance, DroidWatch [22] monitors the data collected and
generated by other apps on the device through ContentObserver
and Broadcast Receiver. Lee et al. [26] designed a monitoring app
that leverages system APIs to observe data including device ID,
MAC address, and running processes. WebCapsule [34] is a light-
weight and portable forensic engine for web browsers. WebCapsule
needs to be installed together with a web browser and records all
non-deterministic inputs to the web rendering engine. The goal of
WebCapsule is to reconstruct web security attacks, e.g., phishing
attacks. A key challenge for active forensics is that it is almost im-
possible to install the monitoring app on a suspect’s device before
a crime happened. Our EviHunter is designed for passive forensics,
i.e., we analyze a suspect’s device after a crime has happened.

6.2 Static Data Flow Analysis for Android
Improving the security and privacy of Android has attracted lots
of attention in the security community. A large number of tools
have been developed to detect sensitive data flows between sources
and sinks in Android apps. For instance, dynamic analysis tools
include TaintDroid [18], TaintART [41], and Malton [48]. Example
static analysis tools include SCanDroid [19], Scandal [25], Androi-
dLeaks [20], LeakMiner [49], CHEX [30], FlowDroid [12], Aman-
Droid [45], DroidSafe [21], R-Droid [13], IccTA [28], and Horn-
Droid [15]. Reaves et al. [36] performed a systematic comparative
study about a large number of tools. Both dynamic analysis and
static analysis can be used for permanent-storage forensics. For in-
stance, Xu et al. [47] designed a dynamic analysis tool by extending
the Android platform’s memory heap space to track information
flow and report evidentiary data once a sink method is invoked.

EviHunter leverages static analysis. Static analysis of Android
apps relies on a comprehensive model to approximate Android’s
runtime behavior. CHEX [30] was the first static analysis tool to
consider different types of entry points of an Android app. Flow-
Droid [12] models an app’s life cycle and creates a dummy main
method for an app, which was also adopted by AmanDroid [45] and
R-Droid [13]. Many tools manually summarized the data flows for
some commonly used system APIs while ignoring the rest of them
for efficiency consideration. Specifically, with the summarized data
flows, a tool does not need to include the framework code, which
is more efficient. DroidSafe [21] proposed a technique to model the
Android framework, which was also used by R-Droid [13]. However,
Reaves et al. [36] found that DroidSafe is not scalable to real-world
apps and fails to analyze them. Several tools [12, 21, 28, 30, 45] also
considered inter-component communications, which can increase
the precision of the analysis.

A key difference between these static analysis tools and Evi-
Hunter is that EviHunter considers both the types of sensitive data
and file paths where the data are written to. Specifically, the tools
that were designed to improve the security and privacy of Android
focused on identifying what sensitive data (e.g., locations, contacts,
device ID) are leaked to which types of sinks (e.g., network socket,
file system, device’s screen). Our EviHunter focuses on the file sys-
tem as a type of sink and further identifies the files where data are
written to. This key difference introduces several challenges: 1) we
need to design a new tag that contains both evidentiary data and
file path, 2) we need to design new propagation rules to update tags,
especially for file paths, and 3) we also need to identify new source
methods for file paths. EviHunter addresses these challenges.

7 CONCLUSION AND FUTURE WORK
In this work, we design EviHunter to automatically identify the
files on an Android smartphone that could contain evidentiary data.
EviHunter first builds an App Evidence Database for a large number
of apps via static data flow analysis. Then, EviHunter matches the
files on a smartphone against those in the AED to identify the
files containing evidentiary data. EviHunter extends the existing
static analysis tools that were designed for security and privacy
analysis of Android apps with respect to 1) tags associated with
variables, 2) propagation rules to update tags, 3) data-flow summary
of commonly used system APIs, and 4) sources and sinks. Our
evaluations on both benchmark apps and real-world apps show
that EviHunter can precisely and accurately identify the evidentiary
data that an app could save to file systems and the files where the
data are written to. Future work includes modeling inter-component
communications and frameworks for file path construction as well
as extending EviHunter for fine-grained privacy analysis.

ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers for their insight-
ful feedback. This work was funded by the Center for Statistics and
Applications in Forensic Evidence (CSAFE) through Cooperative
Agreement #70NANB15H176 between NIST and Iowa State Uni-
versity, as well as partially by NSF under grants No. CNS-1527579,
CNS-1619201, and CNS-1730275, and Boeing Company.

REFERENCES
[1] 2017. DroidBench. https://blogs.uni-paderborn.de/sse/tools/droidbench/
[2] 2018. Cellebrite UFED Ultimate.

https://www.cellebrite.com/en/products/

ufed-ultimate/

[3] 2018.

Forensic Toolkit (FTK).

https://accessdata.com/products-services/

forensic-toolkit-ftk

[4] 2018. Run Apps on the Android Emulator. https://developer.android.com/studio/

run/emulator.html

[5] 2018. Sources and Sinks. https://github.com/MobileDeviceForensics/EviHunter
[6] 2018. SRSRoot. http://www.srsroot.com
[7] 2018. XRY - Extract. https://www.msab.com/products/xry/
[8] 2018. YouWave. https://developer.android.com/studio/run/emulator.html
[9] Mohammed I Al-Saleh and Yahya A Forihat. 2013. Skype forensics in android

devices. International Journal of Computer Applications 78, 7 (2013).

[10] Tadani Alyahya and Firdous Kausar. 2017. Snapchat Analysis to Discover Digital
Forensic Artifacts on Android Smartphone. Procedia Computer Science 109 (2017).
[11] Cosimo Anglano. 2014. Forensic analysis of WhatsApp Messenger on Android

smartphones. Digital Investigation 11, 3 (2014).

[12] Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick McDaniel. 2014. Flow-
Droid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware Taint
Analysis for Android Apps. In PLDI.

EviHunter

CCS ’18, October 15–19, 2018, Toronto, ON, Canada

[13] Michael Backes, Sven Bugiel, Erik Derr, Sebastian Gerling, and Christian Hammer.
2016. R-Droid: Leveraging Android App Analysis with Static Slice Optimization.
In AsiaCCS.

Digital Forensics.

[32] DECLAN MCCULLAGH. 2010. Police Blotter: Web searches lead to murder

conviction. https://goo.gl/HqJ6h4

[14] Evan Bush. 2017. Suspects’ phones led Northwest investigators to carcasses in

[33] J. E. R. McMillan, W. B. Glisson, and M. Bromby. 2013. Investigating the Increase

one of the biggest poaching cases they’ve ever seen. https://goo.gl/nUQyNA

in Mobile Phone Evidence in Criminal Activities. In HICSS.

[15] Stefano Calzavara, Ilya Grishchenko, and Matteo Maffei. 2016. HornDroid: Prac-
tical and Sound Static Analysis of Android Applications by SMT Solving. In
EuroS&P.

[16] Matthew Dering Somesh Jha Patrick McDaniel Damien Octeau, Daniel Luchaup.
2015. Composite Constant Propagation: Application to Android Inter-Component
Communication Analysis. In ICSE.

[17] F. Daryabar, M. H. Tadayon, A. Parsi, and H. Sadjadi. 2016. Automated analysis
method for forensic investigation of cloud applications on Android. In IST.
[18] William Enck, Peter Gilbert, Byung-Gon Chun, Landon P. Cox, Jaeyeon Jung,
Patrick McDaniel, and Anmol N. Sheth. 2010. TaintDroid: An Information-flow
Tracking System for Realtime Privacy Monitoring on Smartphones. In OSDI.

[19] Adam P Fuchs, Avik Chaudhuri, and Jeffrey S Foster. 2009. Scandroid: Automated

security certification of android. Technical Report.

[20] Clint Gibler, Jonathan Crussell, Jeremy Erickson, and Hao Chen. 2012. Androi-
dLeaks: Automatically Detecting Potential Privacy Leaks in Android Applications
on a Large Scale. In TRUST.

[21] Michael I Gordon, Deokhwan Kim, Jeff H Perkins, Limei Gilham, Nguyen Nguyen,
and Martin C Rinard. 2015. Information Flow Analysis of Android Applications
in DroidSafe.. In NDSS.

[22] Justin Grover. 2013. Android forensics: Automated data collection and reporting

from a mobile device. Digital Investigation 10 (2013).

[23] Hans Henseler. 2017. Finding digital evidence in mobile devices. In DFRWS.
[24] Filip Karpisek, Ibrahim Baggili, and Frank Breitinger. 2015. WhatsApp network
forensics: Decrypting and understanding the WhatsApp call signaling messages.
Digital Investigation 15 (2015).

[25] Jinyung Kim, Yongho Yoon, Kwangkeun Yi, Junbum Shin, and SWRD Center.
2012. ScanDal: Static analyzer for detecting privacy leaks in android applications.
MoST 12 (2012).

[26] Xinfang Lee, Chunghuang Yang, Shihjen Chen, and Jainshing Wu. 2009. Design
and implementation of forensic system in Android smart phone. In The 5th Joint
Workshop on Information Security.

[27] Hannah Leone. 2017. GPS evidence can be used in Aurora KFC shooting case.

https://goo.gl/28rGnN

[28] Li Li, Alexandre Bartel, Tegawendé F. Bissyandé, Jacques Klein, Yves Le Traon,
Steven Arzt, Siegfried Rasthofer, Eric Bodden, Damien Octeau, and Patrick Mc-
Daniel. 2015. IccTA: Detecting Inter-component Privacy Leaks in Android Apps.
In ICSE.

[29] Mark Lohrum. 2014.

Live imaging an Android device Not as hard as it
sounds if you break it down. https://freeandroidforensics.blogspot.kr/2014/08/
live-imaging-android-device.html

[30] Long Lu, Zhichun Li, Zhenyu Wu, Wenke Lee, and Guofei Jiang. 2012. CHEX:
Statically Vetting Android Apps for Component Hijacking Vulnerabilities. In
CCS.

[31] Stefan Maus, Hans Höfken, and Marko Schuba. 2011. Forensic analysis of geodata
in android smartphones. In International Conference on Cybercrime, Security and

[34] Christopher Neasbitt, Bo Li, Roberto Perdisci, Long Lu, Kapil Singh, and Kang Li.
2015. WebCapsule: Towards a Lightweight Forensic Engine for Web Browsers.
In CCS.

[35] Siegfried Rasthofer, Steven Arzt, and Eric Bodden. 2014. A Machine-learning
Approach for Classifying and Categorizing Android Sources and Sinks.. In NDSS.
[36] Bradley Reaves, Jasmine Bowers, Sigmund Albert Gorski III, Olabode Anise, Rahul
Bobhate, Raymond Cho, Hiranava Das, Sharique Hussain, Hamza Karachiwala,
Nolen Scaife, Byron Wright, Kevin Butler, William Enck, and Patrick Traynor.
2016. ∗Droid: Assessment and Evaluation of Android Application Analysis Tools.
ACM Comput. Surv. (2016).

[37] Brendan Saltaformaggio, Rohit Bhatia, Zhongshu Gu, Xiangyu Zhang, and
Dongyan Xu. 2015. GUITAR: Piecing Together Android App GUIs from Memory
Images. In CCS.

[38] Brendan Saltaformaggio, Rohit Bhatia, Zhongshu Gu, Xiangyu Zhang, and
Dongyan Xu. 2015. VCR: App-Agnostic Recovery of Photographic Evidence
from Android Device Memory Images. In CCS.

[39] Brendan Saltaformaggio, Rohit Bhatia, Xiangyu Zhang, Dongyan Xu, and Golden
G. Richard III. 2016. Screen After Previous Screens: Spatial-Temporal Recreation
of Android App Displays from Memory Images. In Usenix Security Symposium.
[40] Brendan Saltaformaggio, Zhongshu Gu, Xiangyu Zhang, and Dongyan Xu. 2014.
DSCRETE: Automatic Rendering of Forensic Information from Memory Images
via Application Logic Reuse. In Usenix Security Symposium.

[41] Mingshen Sun, Tao Wei, and John C.S. Lui. 2016. TaintART: A Practical Multi-level

Information-Flow Tracking System for Android RunTime. In CCS.

[42] United States v. Brendt A. Christensen. 2017. Criminal Complaint, United States

District Court, Central District of Illinois. https://goo.gl/b81btj

[43] Raja Vallée-Rai, Phong Co, Etienne Gagnon, Laurie Hendren, Patrick Lam, and
Vijay Sundaresan. 1999. Soot - a Java Bytecode Optimization Framework. In
CASCON.

[44] Nicolas Viennot, Edward Garcia, and Jason Nieh. 2014. A Measurement Study of

Google Play. In SIGMETRICS.

[45] Fengguo Wei, Sankardas Roy, Xinming Ou, and Robby. 2014. Amandroid: A
Precise and General Inter-component Data Flow Analysis Framework for Security
Vetting of Android Apps. In CCS.

[46] Songyang Wu, Yong Zhang, Xupeng Wang, Xiong Xiong, and Lin Du. 2017.
Forensic analysis of WeChat on Android smartphones. Digital Investigation 21
(2017).

[47] Zhen Xu, Chen Shi, Chris Chao-Chun Cheng, Neil Zhengqiang Gong, and Yong
Guan. 2018. A Dynamic Taint Analysis Tool for Android App Forensics. In
SADFE.

[48] Lei Xue, Yajin Zhou, Ting Chen, Xiapu Luo, and Guofei Gu. 2017. Malton: Towards
On-Device Non-Invasive Mobile Malware Analysis for ART. In Usenix Security
Symposium.

[49] Z. Yang and M. Yang. 2012. LeakMiner: Detect Information Leakage on Android

with Static Taint Analysis. In WCSE.

