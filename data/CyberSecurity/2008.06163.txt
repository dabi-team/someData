0
2
0
2

v
o
N
3
1

]

R
C
.
s
c
[

2
v
3
6
1
6
0
.
8
0
0
2
:
v
i
X
r
a

The First Step Towards Modeling Unbreakable Malware

Tiantian Ji
jitiantian0728@bupt.edu.cn
Key Laboratory of Trustworthy
Distributed Computing and Service
(BUPT), Ministry of Education,
Beijing University of Posts and
Telecommunications
Beijing, China

Zhongru Wang
wangzhongru@bupt.edu.cn
Chinese Academy of Cyberspace
Studies
Beijing, China

Binxing Fang
fangbx@bupt.edu.cn
Key Laboratory of Trustworthy
Distributed Computing and Service
(BUPT), Ministry of Education,
Beijing University of Posts and
Telecommunications
Beijing, China

Jiawen Diao
Key Laboratory of Trustworthy
Distributed Computing and Service
(BUPT), Ministry of Education,
Beijing University of Posts and
Telecommunications
Beijing, China

WeiQiang Yu
(Beijing DigApis Technology Co., Ltd
Beijing, China

Xiang Cui∗
cuixiang@gzhu.edu.cn
Cyberspace Institute of Advanced
Technology, Guangzhou University
Guangzhou, China

Tian Wang
Key Laboratory of Trustworthy
Distributed Computing and Service
(BUPT), Ministry of Education,
Beijing University of Posts and
Telecommunications
Beijing, China

ABSTRACT
Constructing stealthy malware has gained increasing popularity
among cyber attackers to conceal their malicious intent. Never-
theless, the constructed stealthy malware still fails to survive the
reverse engineering by security experts. Therefore, this paper mod-
eled a type of malware with an “unbreakable” security attribute-
unbreakable malware (UBM), and made a systematical probe into
this new type of threat through modeling, method analysis, ex-
periments, evaluation and anti-defense capacity tests. Specifically,
we first formalized the definition of UBM and analyzed its secu-
rity attributes, put forward two core features that are essential for
realizing the “unbreakable” security attribute, and their relevant
tetrad for evaluation. Then, we worked out and implemented four
algorithms for constructing UBM, and verified the “unbreakable”
security attribute based on our evaluation of the abovementioned
two core features. After that, the four verified algorithms were em-
ployed to construct UBM instances, and by analyzing their volume
increment and anti-defense capacity, we confirmed real-world ap-
plicability of UBM. Finally, to address the new threats incurred by
UBM to the cyberspace, this paper explored some possible defense
measures, with a view to establishing defense systems against UBM
attacks.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
arxiv ’20, 2020, xxx
© 2020 Association for Computing Machinery.
ACM ISBN xxx. . . $xxx
https://doi.org/xxx

KEYWORDS
Unbreakable Malware, Accurate identification, Intent concealment

ACM Reference Format:
Tiantian Ji, Binxing Fang, Xiang Cui, Zhongru Wang, Jiawen Diao, Tian
Wang, and WeiQiang Yu. 2020. The First Step Towards Modeling Unbreak-
able Malware. In xxx. ACM, New York, NY, USA, 13 pages. https://doi.org/
xxx

1 INTRODUCTION
Malware comes in various forms, including viruses, worms, remote
access Trojans , bots, ransomware, etc. Since the Morris worm ap-
peared in 1988, malware has demonstrated its destructiveness and
started to cause international concern. In recent years, cybersecu-
rity companies and media have released many reports on major
cybersecurity incidents, most of which actually focus on malware
analysis. Undoubtedly, malware accounts for a thorny problem in
cyberspace security [5].

As the lasting arms race featuring cyberattack and defense is
entering a new stage, many malware programs attempt to conceal
their existence and malicious intent, and thus are called “stealthy
malware” (SM for short). This type of malware stands a chance
ten times higher than conventional malware to launch a successful
attack [17]. A recent report [3] estimates that SM-based attacks
account for 35% of all attacks at present, and the attacks in the first
half of 2019 alone, for example, increased by 364%. It is not hard to
see that constructing stealthy malware has become a trend.

Despite the lots of studies invested into construction and im-
provement of stealthy malware, the malware’s malicious intent still
risks being uncovered. For example, the Stuxnet worm, a notori-
ous stealthy malware program, has been constructed only aimed at

 
 
 
 
 
 
arxiv ’20, 2020, xxx

Tiantian Ji, Binxing Fang, Xiang Cui, Zhongru Wang, Jiawen Diao, Tian Wang, and WeiQiang Yu

attacking industrial control systems that are installed with some par-
ticular software and hardware. Another noted example of stealthy
malware is the DarkHotel spyware which incorporates a function
to detect virtual machines, sandbox environment and antivirus
engines. These environments are not the target environments of
DarkHotel, and only in the case where they are not detected will the
spyware perform its malicious acts. Analysis of the Stuxnet worm
and DarkHotel spyware, however, reveals that their attack targets,
malicious intent and attack methods are all hardcoded in malware
files. The security defenders can employ static analysis to conduct
complete reverse engineering of such malware, which is the major
challenge that stealthy malware engineers face at present.

DeepLocker [6], a malware that IBM Research proposed on Black
Hat 2018, was the first proof-of-concept of the new type of mal-
ware that this paper is devoted to. Before an attack is unleashed,
the DeepLocker realizes the perfect “unbreakable” attribute with
the help of AI technologies, i.e., even if its codes are available as
open source, its malicious intent remains stealthy. Moreover, in an
actual attack case, the malware BIOLOAD coded by the APT group
FIN7, based on the attribute of “computer name” and hashing, also
attempted to attain this “unbreakable” attribute. BIOLOAD once
again proves that unbreakable malware can be employed as a novel
advanced technique to launch attacks in real-world application.

In this connection, this paper modeled a type of UnBreakable Mal-
ware (UBM) and analyzed it in an all-round manner through mod-
eling, method analysis, experiments, evaluation and anti-defense
capacity tests. The main contributions of this paper are as follows:

1) This paper, for the first time, proposed the concept of UBM and
modeled it formally. The UBM abandons the “if this, then that”
target identification algorithm that the existing stealthy malware
depends on, displacing it with a new algorithm that is able to pre-
cisely perceive a (or a type of) target environment; meanwhile,
it conceals its malicious intent. In this way, a common malware
can be equipped with the “unbreakable” security attribute, thus
are able to defend against reverse engineering completely.
2) This paper proposed two core features – non-enumerability and
definiteness, which are essential for realizing the “unbreakable”
security attribute. Further, a tetrad to evaluate the two core fea-
tures was put forward in this paper through formalized definition
and analysis. The malware that meets the constraint conditions
for this tetrad is able to survive forward analysis and reverse
engineering. Thereby, the two core features work to ensure the
realization of the “unbreakable” security attribute in a thorough
manner.

3) Based on the formalized definition of UBM and research on its
security attributes, this paper then proposed an architecture for
constructing UBM, and found four algorithms to realize the two
functions of “accurate identification” and “intent concealment”.
Also, by implementing these four algorithms and evaluating
their security, this paper confirmed that the UBM Discriminator
constructed based on the four algorithms had incorporated this
“unbreakable” security attribute, as is in conformity with the
standard for UBM construction.

4) Based on the four algorithms and the UBM six-tuple, this paper
has constructed four actual UBMs. Evaluation of the applicability
of these programs proved that UBM can realize an unperceivable

volume increment and successfully avoid the detection of almost
all antivirus engines, thereby verifying the high-threat combat
capacity of UBM.

5) To defend against the security threats incurred by UBM, this
paper has identified the vulnerabilities of UBM during the two
links of its construction: “target attribute designation” and “func-
tioning stages”, and explored some possible defense solutions,
with a vision to enhance UBM-oriented security defense.

2 BACKGROUND AND RELATED WORK
This section presents relevant research work. In view of some exist-
ing problems in constructing stealthy malware, the research back-
ground, related work, and our UBM modeling views are introduced
in this section.

2.1 Basic concepts
To conduct accurate UBM modeling, this paper first defines relevant
concepts as follows:

• D1 Malicious Payload: Independent files or code segments
that harbor malicious intent, like the code segments in Not-
Petya that perform the function of erasing the hard drive.
Moreover, in this paper, the plaintext attack payload is termed
plain payload (denoted as “pp”), while the corresponding en-
crypted ciphertext attack payload is termed cipher payload
(denoted as “cp”).

• D2 Malicious Intent: Intent carried by the malicious pay-
load to pinpoint its attack target, technique, act, purpose,
etc. Common malicious intent includes intelligence stealing,
data encryption, hard-drive erasure, data shredding and so
on.

• D3 Target Attribute: The attribute designated by an at-
tacker. In this paper, we use T to denote a target attribute
sample, and its corresponding non-target attribute sample
is denoted as 𝑇 ; the set of target attribute samples and that
of the non-target attribute samples together constitute the
input space X of the UBM. In this paper, the UBM estab-
lishes a “one-to-one” or “one type-to-one” mapping relation
between the target attribute sample and the key. This paper
defines the target attribute used for “one-to-one” mapping
as the target attribute of uniqueness, e.g., a specific file or
a specific computer name; and the target attribute used for
“one type-to-one” mapping is defined as the target attribute
of unique-typedness, e.g., the facial images of Tom Cruise.

2.2 Triggering conditions for stealthy malware

attacks

Before an attack is unleashed, the malware seeks stealthiness by hid-
ing its malicious intent. An attack will be launched if and only if the
stealthy malware meets some specific attack triggering conditions.
By the attack triggering condition, this paper divides the attack
implementation mechanism of existing stealthy malware into two
types: target environment detection-based implementation, and
complex logic judgment-based implementation.

• Target environment detection

The First Step Towards Modeling Unbreakable Malware

arxiv ’20, 2020, xxx

Existing stealthy malware determines whether to unleash an attack
by detecting and judging whether the target environment meets its
anticipation. Detectable indicators include the residential country,
language, operation system (version) and system performance of
the current host computer. For instance, only when a specific plat-
form or an operation system (version) is found as expected can the
malware for Stuxnet, Duqu, Gauss and Flame execute a malicious
attack [2].

Furthermore, researchers have proposed various sandbox de-
tection techniques [1, 7, 9] to help design the attack triggering
conditions, and conducted comprehensive detection and evaluation
of various sandbox features to determine whether the current host
computer environment is the sandbox environment. If it is detected
as the sandbox environment, the malware will not work or attempt
to make the system break down. Only in a non-sandbox environ-
ment can the malware be triggered off to unleash an attack, and
this non-sandbox environment is actually the target environment
of the stealthy malware.

Figure 1: Execution Flow of stealthy malware

• Complex logic judgment
One dynamic analysis of malware can only cover one execution
path, so complex logic structures are designed for various types
of stealthy malware to conceal their execution branches of the
malicious payload. Unleashing a malicious attack depends on the
execution of the complex logic branches. For example, magic bytes
or string matching, stalling loop and infinite loop all fall into the
category of complex logic judgment [16].

This type of stealthy malware that launches attacks based on
complex logic judgment, as presented in the above examples, has
made it a challenge in the detection process of symbolic execution
[12], fuzz testing [18] and other dynamic analysis tasks. As a con-
sequence, complex logic judgment-based design is popular among
attackers.

To sum up, in constructing the two attack triggering conditions,
we will end up with the judgment “Is this a target”, no matter how
complex the target environment or logic judgment is. As shown in
Figure 1, both of the two attack triggering conditions worked out
in this paper are in line with the “if this, then that” design idea, i.e.,
as long as the judgment condition “Is this a target” is satisfied, the
malicious attack will be triggered and unleashed.

This design, however, has its limitations: The information used
to crack the attack triggering conditions is always hardcoded in
the malware or transmitted via the command and control (C&C)
channel. By analyzing the study case of some actual attacks in

ATT&CK [13], we found that such information can be easily at-
tained through reverse engineering or network monitoring. To put
it another way, the defender can utilize such information to break
the attack triggering conditions and thereby uncover the malicious
intent.

Accordingly, this paper discards the “if this, then that” design
idea, and replaces it with the two functions of “accurate identi-
fication” and “intent concealment”. This not only makes it hard
to access the information for ascertaining the attack triggering
conditions, but ensures that the malicious payload will not be de-
coded even when the code of the malware is available as open
source (because the malicious payload encrypted based on this is
hard-to-get information). In this way, the malicious intent is made
“unbreakable”.

2.3 Attack Mechanism of DeepLocker
In this section, we take DeepLocker as an example of UBM and
explore its mechanism to help for modeling UBM for research.

As shown in Figure 2, DeepLocker uses a deep neural network
(DNN) model to accurately identify the target attributes and con-
ceal the intent of the malicious payload. The two core functions are
implemented through the two processes – concealment and unlock-
ing. During concealment, DeepLocker uses the DNN to conduct
dynamic concealment of the symmetric key, i.e., the key will not be
hardcoded into the malware, while the input received is taken as a
basis for the DNN to determine whether to generate the key or not.
During concealment, the key is employed to encrypt a plain
payload into a cipher payload, so the DNN’s concealment of the
key means successful concealment of the malicious intent. A DNN
model can help implement our concealment of malicious intent
mainly because with its well-trained classification function based
on the data sets of target attributes and of non-target attributes, it
can implement accurate identification of the target attributes.

Correspondingly, during unlocking, the DNN first accurately
identifies the target attribute (as shown by the facial image of Tom
Cruise in Figure 2) to assist generating the key for decoding the
cipher payload, and then unleashes an attack. In this way, the “if
this, then that” design idea is displaced.

Based on the attack mechanism of DeepLocker, this paper analy-
ses further the main reasons for its “unbreakable” security attribute
from the perspective of a security defender:

First, the target attribute cannot be ascertained by brute-force tra-
versal . The target attribute is assigned as controlled by the attacker,
who can make use of specific pictures, files, videos, audios, phys-
ical environment, software environment, user action, geographic
location, and so on. The defender neither knows the type of the
target attribute, nor has any means to match the specific target
attribute. It is challenging to conduct brute-force traversal of the
target attribute, as hard as or even harder than to crack the AES-128
algorithm, and this is an unreachable hashrate for current electronic
computers. Thereby, from the perspective of forward decryption , as
the target attribute cannot be ascertained by brute-force traversal,
the trigger cannot be activated; consequently, the cipher payload
cannot be decrypted and executed, and the malicious intent cannot
be identified by the defender.

arxiv ’20, 2020, xxx

Tiantian Ji, Binxing Fang, Xiang Cui, Zhongru Wang, Jiawen Diao, Tian Wang, and WeiQiang Yu

Figure 2: Execution flow of DeepLocker and its concealment and unlocking operations

Second, the cryptographic algorithm’s key strength is at least
128 bits, which is a crucial indicator to measure the security level
of a cryptographic algorithm. Even if DeepLocker is open source,
its built-in cipher payload cannot be reversely cracked, mainly in
that the DeepLocker takes the AES-128 algorithm by default and
has a key strength of 128 bits, and the defender cannot obtain any
information by analyzing the open source DeepLocker to crack for
the key. Therefore, key guessing is the only solution for reverse
decryption, but no existing techniques are capable of guessing a
key with 128 bits strength.

To sum up, we conclude that the “unbreakable” attribute of UBM
is determined by two functions – “accurate identification” and “in-
tent concealment”. On this basis, hereinafter, we perform modeling
of the highly stealthy malware and analyze its attributes in the
following sections.

3 FORMALIZED MODELING OF
UNBREAKABLE MALWARE
3.1 Assumptions for modeling
Modeling inevitably depends on specific assumptions. To explicitly
express the functions and action scope of UBM, this paper made
the following assumptions:

Assumption 1: To demonstrate that the UBM has the “unbreak-
able” security attribute, the UBM in this paper was placed in a
cooperative adversarial environment. Advanced antivirus engines
were deployed on the perimeter of the network and on the victim
host computer for defense, and high-caliber reverse engineers for
security were allowed to be present to stay vigilant.

Assumption 2: As for the application scenario, we assumed that
the location of the target was unknown, and the UBM had to seek its
attack target by castnet communication. One real-world example of
casenet communication is intranet translation that malware usually
employs to seek a target in a physically-isolated private network
or organization.

Assumption 3: During UBM construction, even though the
malicious payload supports both symmetric and asymmetric en-
cryption, this paper only assumed symmetric encryption as the
algorithm to help construct the UBM, because the asymmetric en-
cryption complicates UBM design and features a low encryption-
decryption speed without bringing additional security benefits.

Therefore, hereinafter, the “encryption key” and “decryption key”
were jointly called “key” and denoted by “𝑘𝑒𝑦”. Its corresponding
wrong key was denoted by “𝑘𝑒𝑦”.

Assumption 4: From a realistic perspective, this paper assumed
that all relevant adversarial attack-and-defense processes related
to malware were placed in an electronic computer environment,
instead of a quantum computer environment.

3.2 Formalized definition of UBM
Based on the above assumptions, this paper provided a formalized
definition of UBM.

• Model Define: UBM (UnBreakable Malware). The UBM, com-
prised of a six-tuple, refers to a type of malware with the “un-
breakable” security attribute, denoted as UBM={Discriminator,
Unb, Judger, Decryptor, cp, BenCode}.

Discriminator: A Discriminator realizes the two core functions
of “accurate identification” and “intent concealment”, and con-
verts the input space X into possibleKey, denoted as Discriminator:
𝑋 → 𝑝𝑜𝑠𝑠𝑖𝑏𝑙𝑒𝐾𝑒𝑦. It incorporates the two mapping relations of
𝑇 → 𝑘𝑒𝑦 and 𝑇 → 𝑘𝑒𝑦. The function is expressed as 𝑝𝑜𝑠𝑠𝑖𝑏𝑙𝑒𝐾𝑒𝑦 =
𝐷𝑖𝑠𝑐𝑟𝑖𝑚𝑖𝑛𝑎𝑡𝑜𝑟 (𝑋 ), and then 𝑘𝑒𝑦 = 𝐷𝑖𝑠𝑐𝑟𝑖𝑚𝑖𝑛𝑎𝑡𝑜𝑟 (𝑇 ) and 𝑘𝑒𝑦 =
𝐷𝑖𝑠𝑐𝑟𝑖𝑚𝑖𝑛𝑎𝑡𝑜𝑟 (𝑇 ). For the target attribute of uniqueness, the Dis-
criminator represents a tuple of itself, denoted as 𝐷𝑖𝑠𝑐𝑟𝑖𝑚𝑖𝑛𝑎𝑡𝑜𝑟 =
{𝐷𝑖𝑠𝑐𝑟𝑖𝑚𝑖𝑛𝑎𝑡𝑜𝑟 }; for the target attribute of unique-typedness, the
Discriminator represents a two-tuple, denoted as 𝐷𝑖𝑠𝑐𝑟𝑖𝑚𝑖𝑛𝑎𝑡𝑜𝑟 =
{𝑓 𝐶𝑜𝑙𝑙𝑒𝑐𝑡𝑜𝑟, 𝐷𝑖𝑠𝑐𝑟𝑖𝑚𝑖𝑛𝑎𝑡𝑜𝑟 }.

fCollector: The feature collector. Aimed at the target attribute
of unique-typedness, the fCollector extracts the main feature infor-
mation of the target attribute, helping the Discriminator to map a
type of target attributes to a unique stable key.

Unb: The intrinsic and “unbreakable” security attribute of the
UBM. This attribute entails two core features of the malware–“non-
enumerability” and “definiteness”, and it is denoted as Unb={non-
enumerability, definiteness}.

non-enumerability: The input space and output space are too
big to be traversed in a brute-force manner. All input and output
spaces mentioned in this paper refer to the input and output spaces
of the Discriminator. That is, the input space X consists of 𝑇 and 𝑇 ,
and the output space possibleKey comprises 𝑘𝑒𝑦 and 𝑘𝑒𝑦.

The First Step Towards Modeling Unbreakable Malware

arxiv ’20, 2020, xxx

definiteness: The algorithm that processes inputs of the corre-
lation engine features definiteness. That is, the same input or the
same type of inputs, if fed into the engine for multiple times, will
yield the same output.

These two core features (non-enumerability and definiteness)
are manifested as the functions of “accurate identification” and
“intent concealment” in malware implementation. Thus, the security
attribute of UBM depends on the Discriminator for realization.

Judger: The security attribute judging function, which works
to ensure that the implementation of the Discriminator realizes the
security attributes of UBM. It takes the Discriminator as the input,
and outputs the tuple for evaluating the Discriminator, denoted as
𝑒𝑣𝑎 = 𝐽𝑢𝑑𝑔𝑒𝑟 (𝐷𝑖𝑠𝑐𝑟𝑖𝑚𝑖𝑛𝑎𝑡𝑜𝑟 ).

eva: A constraint tuple that evaluates the Discriminator, ex-
pressed as Formula (1), where x, y, z and w represent the critical
values to meet the evaluation standards. These values are specified
by the attacker as per the actual attack scenario, attack demand
and attack capacity. Only when the eva evaluation standards are
met will the Discriminator be considered qualified for constructing
the UBM.

𝑒𝑣𝑎 = {𝑃𝑖𝑛 ≤ 𝑥, 𝑃𝑜𝑢𝑡 ≤ 𝑦, 𝑃𝑠𝑡𝑎 ≥ 𝑧, 𝑃𝑎𝑐𝑐 ≤ 𝑤 }

(1)

Decryptor: The Decryptor takes the cipher payload and possi-
bleKey as inputs and attempts to decode the cipher payload. It is
denoted as 𝐷𝑒𝑐𝑟𝑦𝑝𝑡𝑜𝑟 = {𝑘𝑒𝑦 𝐽𝑢𝑑𝑔𝑒𝑟, 𝑑𝑒𝑐𝐹𝑢𝑛𝑐}.

keyJudger: The key judgment mechanism. It judges whether a
possibleKey is a 𝑘𝑒𝑦; when the possibleKey is a 𝑘𝑒𝑦, it will interrupt
the execution of the Decryptor.

decFunc: A decryption function. If and only if a possibleKey is
a key can the decFunc convert the cipher payload into the plain
payload, which is denoted as: 𝑝𝑝 = 𝑑𝑒𝑐𝐹𝑢𝑛𝑐 (𝑐𝑝, 𝑘𝑒𝑦); otherwise,
the decFunc will not produce any output, thereby lowering the risk
of UBM’s being detected.

cp: The cipher payload. It represents encrypted plain payload,
which is obtained through encryption of the key generated by the
Discriminator based on the target attribute sample T.

BenCode: A benign functional code. The UBM, if not detected,
inserts the malicious code into the BenCode to circumvent detection
by an antivirus engine. One common example of BenCode is video
conferencing software.

3.3 The two core features
As specified in the formalized definition of UBM, “non-enumerability”
and “definiteness” are the two core features to satisfy the “unbreak-
able” security attribute (i.e., Unb). Table 1 presents the formalized
analysis of these two features in different scenarios.

a) Non-enumerability

This paper gave a formalized definition of non-enumerability in a
reversed manner. That is, this paper provided a formalized definition
of the possibility to enumerate the target objects, and a smaller
possibility of enumeration would mean higher non-enumerability.
The enumerated object(s) in the input space was (were) one
or one type of target sample in correspondence with the target
attribute. In this paper, the enumerability in the input space is
denoted as 𝑃𝑖𝑛. As shown in Formula (2) and (3), 𝑃𝑖𝑛 is the ratio of
the number of target samples to that of total samples.

The target attribute of uniqueness has only one corresponding
target sample in the input space, so as shown in Formula (2), the
value of 𝑃𝑖𝑛 depends on the number of total samples in the input
space.

The target attribute of unique-typedness has only one specific
type of target samples in the input space. As shown in Formula (3),
in the input space, we denote the complexity of target samples
is denoted as 𝑂 (𝑡𝑎𝑟𝑔𝑒𝑡 𝑐𝑙𝑎𝑠𝑠), and the complexity of total sam-
ples as 𝑂 (𝑡𝑜𝑡𝑎𝑙 𝑐𝑙𝑎𝑠𝑠𝑒𝑠). Then, 𝑃𝑖𝑛 is the ratio of 𝑂 (𝑡𝑎𝑟𝑔𝑒𝑡 𝑐𝑙𝑎𝑠𝑠)
to 𝑂 (𝑡𝑜𝑡𝑎𝑙 𝑐𝑙𝑎𝑠𝑠𝑒𝑠). Suppose each class has the same number of
samples, then the value of 𝑃𝑖𝑛 will be dependent on the size of the
sample class space in the input space.

In the output space, 𝑃𝑜𝑢𝑡 is used to express the possibility of
enumerated targets. The target object that we enumerate is a key,
which is unique. Thus, as shown in Formula (4), the value of 𝑃𝑜𝑢𝑡
will be dependent on the number of total samples in the output
space. What’s more, as the key is in the plain text format, we sup-
pose the cipher payload is open source, then the number of total
samples in the output space will be dependent on the key strength.

b) Definiteness

Definiteness helps to ensure the quality of the key generated
by the Discriminator. In this paper, a high-quality key is termed a
“stable key”. To generate stable key, this paper divides “definiteness”
further into two important probability attributes for formalized def-
inition. They are “key stability” and “key accessibility”, respectively
denoted as 𝑃𝑠𝑡𝑎 and 𝑃𝑎𝑐𝑐 .
1○ Key stability

This paper prescribes the following essential requirements for
key stability: most of the positive samples must have the same cor-
responding key within an acceptable scope of fault tolerance. In this
paper, the target attribute input samples are positive samples, while
those non-target attribute samples are called negative samples.

Hereby, we have the formalized definition of 𝑃𝑠𝑡𝑎, as shown
in Formula (5), and 𝑃𝑠𝑡𝑎 comes out as a probability. When 𝑃𝑠𝑡𝑎
approaches 0, the key has extremely low stability; when 𝑃𝑠𝑡𝑎 ap-
proaches 1, the key has good stability.

In Formula (5), 𝑆𝑖 refers to the i-th possibleKey mapped with
positive samples, and 𝑚𝑆𝑖
refers to the count of 𝑆𝑖 , i.e., the number
of positive samples that correspond to the same possibleKey. A larger
means higher stability of 𝑆𝑖 . Thus, we chose the maximum value
𝑚𝑆𝑖
, and took the corresponding 𝑆𝑥 as the key. Thereby, 𝑃𝑠𝑡𝑎 would
𝑚𝑆𝑥
be the ratio of the number of samples of the corresponding key to
the number of all positive samples. Therefore, the bigger 𝑃𝑠𝑡𝑎 is, the
more stable the key will be, as is more in line with the requirements
in this paper.
2○ Key accessibility
This paper had the following essential requirements for key accessi-
bility: Most of the negative samples should not be able to generate a
key (i.e., the accessibility of key approaches 0) within an acceptable
scope of fault tolerance.

In this paper, 𝑃𝑎𝑐𝑐 has a formalized definition as shown in For-
mula (6). As with 𝑃𝑠𝑡𝑎, 𝑃𝑎𝑐𝑐 also comes out as a probability. When
𝑃𝑎𝑐𝑐 approaches 0, the negative samples can hardly be mapped to
the key; when it approaches 1, almost all negative samples can be
mapped to the key through the Discriminator.

arxiv ’20, 2020, xxx

Tiantian Ji, Binxing Fang, Xiang Cui, Zhongru Wang, Jiawen Diao, Tian Wang, and WeiQiang Yu

Table 1: Formalized definitions of non-enumerability and definiteness

𝑇

𝑈 𝑛𝑏

non-enumerability

definiteness

Input space

Output space

Key stability

Key accessibility

(cid:205)𝑛

𝑖=0 ((𝑆𝑖 ⊙ 𝑘𝑒𝑦) ∗ 𝑚𝑆𝑖 )
𝑖 𝑚𝑆𝑖

(cid:205)𝑛

(6)

uniqueness

unique-typeness

𝑃𝑖𝑛 =

=

𝑡𝑎𝑟𝑔𝑒𝑡 𝑠𝑎𝑚𝑝𝑙𝑒
𝑡𝑜𝑡𝑎𝑙 𝑠𝑎𝑚𝑝𝑙𝑒𝑠
1
𝑡𝑜𝑡𝑎𝑙 𝑠𝑎𝑚𝑝𝑙𝑒𝑠
(2)

𝑃𝑖𝑛 =

=

𝑡𝑎𝑟𝑔𝑒𝑡 𝑠𝑎𝑚𝑝𝑙𝑒
𝑡𝑜𝑡𝑎𝑙 𝑠𝑎𝑚𝑝𝑙𝑒𝑠
𝑂 (𝑡𝑎𝑟𝑔𝑒𝑡 𝑐𝑙𝑎𝑠𝑠)
𝑂 (𝑡𝑜𝑡𝑎𝑙 𝑐𝑙𝑎𝑠𝑠𝑒𝑠)
(3)

𝑃𝑜𝑢𝑡 =

=

𝑡𝑎𝑟𝑔𝑒𝑡 𝑠𝑎𝑚𝑝𝑙𝑒
𝑡𝑜𝑡𝑎𝑙 𝑠𝑎𝑚𝑝𝑙𝑒𝑠
1
𝑡𝑜𝑡𝑎𝑙 𝑠𝑎𝑚𝑝𝑙𝑒𝑠
(4)

𝑚𝑎𝑥 (𝑚𝑆0

𝑃𝑠𝑡𝑎 =

, 𝑚𝑆1
(cid:205)𝑛

, 𝑚𝑆2
𝑖 𝑚𝑆𝑖

, . . . , 𝑚𝑆𝑛 )

𝑃𝑎𝑐𝑐 =

(5)

(a) Concealment of malicious intent

(b) Unlocking of malicious intent

Figure 3: Architecture for UBM construction

In Formula (6), 𝑆𝑖 refers to the i-th output mapped from negative
samples. If 𝑆𝑖 is the same as the key, the key is accessible, and 𝑆𝑖
is an accessible sample. Otherwise, the key is not accessible, and
𝑆𝑖 is an inaccessible sample. Accordingly, (cid:205)𝑛
𝑖=0 ((𝑆𝑖 ⊙ 𝑘𝑒𝑦) ∗ 𝑚𝑆𝑖 )
represents the count of accessible samples. 𝑃𝑎𝑐𝑐 is the ratio of the
count of all accessible samples to that of all negative samples. The
smaller 𝑃𝑎𝑐𝑐 is, the less accessible the key will be, as is more in line
with the requirements in this paper.

3.4 UBM construction architecture
Based on the formalized definition of UBM and our research on its
security attributes, we proposed an architecture for UBM construc-
tion. It comprises two processes of malicious intent concealment
and unlocking, as shown in Figure 3.

During the concealment proccess, the attacker assigns the target
attribute in the input space X, and uses a Discriminator in confor-
mity with the UBM construction criteria to generate a key. The
encryptor, with the key and the plain payload as its input, outputs
the cipher payload and thereby conceals the malicious intent.

The First Step Towards Modeling Unbreakable Malware

arxiv ’20, 2020, xxx

In the unlocking process, the UBM does not know its attack
target, so the built-in Discriminator takes possible attribute sam-
ples as the input, and outputs possibleKey to perform decryption
over and over again. Because of its accurate identification function,
when the Discriminator identifies the target attribute, the condi-
tion 𝑝𝑜𝑠𝑠𝑖𝑏𝑙𝑒𝐾𝑒𝑦 = 𝑘𝑒𝑦 is satisfied, after which the cipher payload
can be decrypted and the plain payload can be generated. Mean-
while, because of the intent concealment function of the Discrim-
inator, when it has not identified the target attribute, the output
𝑝𝑜𝑠𝑠𝑖𝑏𝑙𝑒𝐾𝑒𝑦 = 𝑘𝑒𝑦 , thereby concealing the key. In this case, as
there is no way to decrypt the cipher payload, concealment of key
is equivalent to concealment of the malicious intent.

Figure 4: Execution Flow of UBM

Figure 4 shows the implementation flow of the UBM when the
target attribute is identified. In comparison with the SM imple-
mentation flow (Figure 1), UBM replaces the “if this, then that”
attack-triggering idea with the realization of the Discriminator’s
functions – “accurate identification” and “intent concealment”. To
realize these two functions, the following requirements must be met:
(1) The input space of the Discriminator should be non-enumerable.
(2) In the mapping relation implemented by the Discriminator, the
key will be output when and only when the input is the target
attribute. (3) The input space should also be non-enumerable; in
other words, the output key must be at least 128-bit strong. When
these three requirements are met, the UBM will be unbreakable
and survive both forward analysis or reverse engineering. This
clearly demonstrates the necessity of “non-enumberabilty” and
“definiteness”.

To sum up, the focus of UBM construction is on the Discriminator.
Based on the attribute judgment function, this paper explored and
found the four algorithms that could support construction of the
Discriminator (Figure 3): 1○ Value transfer algorithm; 2○ Typical
Hash algorithm; 3○ Binary deep neural network; and 4○ Perceptual
Hash algorithm. In the following experiments in this paper, we
would first construct a Discriminator with the abovementioned two
core functions based on these four algorithms for construction of
the UBM.

4 EXPERIMENT
Table 2 shows the tuples of four UBMs. Based on the above-mentioned
four algorithms (Figure 3) that were used to construct the Discrimi-
nator, we constructed the UBMs to conduct further performance
evaluation.

The experiment was performed on the Windows platform, though
the construction of UBM can also be fulfilled on Linux or other
platforms. Besides, when constructing the UBM, we used the AES
symmetric encryption algorithm, in which the secret key length
employed equals to the secret key strength. As a 128-bit key is hard
to crack, we made sure that the output key should be at least 128
bits long when constructing the Discriminator .

4.1 Value transfer algorithm
The value transfer algorithm is the most simple and direct approach
to convert the target attribute into a key. It constructs the Discrim-
inator by combination, splicing, clipping, value assignment and
other operations, and establishes a mapping from the target at-
tribute to the key.

In this paper, we chose SSID as the target attribute. As SSID can
set be set at any length within the (0, 256] bit zone, we used the
combined information of SSID and GUID to generate the key, as
specified in formula (7).

where 𝑘𝑒𝑦𝑤𝑙𝑎𝑛 refers to the key for encrypting and decrypt-
ing the malicious payload, 𝑙𝑒𝑛(𝑆𝑆𝐼 𝐷) refers to the length of SSID,
𝑘𝑒𝑦𝑙𝑒𝑛 (𝑆𝑆𝐼 𝐷) (𝑆𝑆𝐼 𝐷) is part of the key generated by SSID, and
𝑘𝑒𝑦128−𝑙𝑒𝑛 (𝑆𝑆𝐼 𝐷) (𝐺𝑈 𝐼𝐷) is part of the key generated by GUID, and
“+” denotes “combination” or “splicing”.

Specifically, Formula (7) provides two different schemes to gen-

erate the key, depending on the length of SSID:

𝑘𝑒𝑦𝑤𝑙𝑎𝑛 =

(cid:26)𝑘𝑒𝑦𝑙𝑒𝑛 (𝑆𝑆𝐼 𝐷) (𝑆𝑆𝐼𝐷) + 𝑘𝑒𝑦128−𝑙𝑒𝑛 (𝑆𝑆𝐼 𝐷) (𝐺𝑈 𝐼𝐷), (𝑖)
𝑚𝑑5(𝑆𝑆𝐼𝐷), (𝑖𝑖)

(7)

(i). When the SSID length <=128 bits, we would use all SSID bi-
nary representations as part of the key, and the remaining
part of the 128 bits would be supplemented by the key gener-
ated by GUID. In this case, the final key is a combination of
GUID and SSID information.

(ii). When the SSID length >128 bits, we performed md5 comput-

ing on SSID to generate a 128-bit key.

Figure 5: Value transfer algorithm based Discriminator

Finally, we constructed a value transfer Discriminator based on
Formula (7). As shown in Figure 5, when the Discriminator detects
that the current host computer is located in the target network
environment (labeled “target SSID”), the key will be generated by
the value transfer algorithm.

It should be noted that the type of target attributes corresponding
to the value transfer Discriminator are generally short texts. In
addition to SSID, the texts can also be a hard disk serial number or
a computer name that marks the physical environment of the host
computer. They can also be taken as target attributes to construct
Discriminator.

arxiv ’20, 2020, xxx

Tiantian Ji, Binxing Fang, Xiang Cui, Zhongru Wang, Jiawen Diao, Tian Wang, and WeiQiang Yu

Table 2: Tuples for modeling four UBM

Number

Discriminator

Unb

eva←Judger

Decryptor

cp

BenCode

UBM={Discriminator, Unb, Judger, Decryptor, cp, BenCode}

1○

2○

3○

4○

Value transfer algorithm

Typical hash algorithm

Unbreakable

Binary deep neural network

Perceptual hash algorithm











𝑃𝑖𝑛 ≤

𝑃𝑜𝑢𝑡 ≤

1
2128
1
2128
𝑃𝑠𝑡𝑎 = 1
𝑃𝑎𝑐𝑐 = 0

𝑃𝑖𝑛 ≤

𝑃𝑜𝑢𝑡 ≤

1
2128
1
2128
𝑃𝑠𝑡𝑎 ≥ 95%
𝑃𝑎𝑐𝑐 ≤ 0.5%

𝜑 = 𝑃𝐾𝐶𝑆7𝑃𝑎𝑑𝑑𝑖𝑛𝑔
𝛿 = 𝐴𝐸𝑆 − 128

𝜑 = 𝑃𝐾𝐶𝑆7𝑃𝑎𝑑𝑑𝑖𝑛𝑔
𝛿 = 𝐴𝐸𝑆 − 256

𝜑 = 𝑃𝐾𝐶𝑆7𝑃𝑎𝑑𝑑𝑖𝑛𝑔
𝛿 = 𝐴𝐸𝑆 − 128

𝜑 = 𝑃𝐾𝐶𝑆7𝑃𝑎𝑑𝑑𝑖𝑛𝑔
𝛿 = 𝐴𝐸𝑆 − 128











In this paper,
a.exe in trick-
bot
is taken
as pp, while
cp represents
the encrypted
output of Dis-
criminator.

In this paper,
is
BenCode
as
realized
a
simple
pop-out
program.

4.2 Typical hash algorithm
The key generation scheme (ii) provided by Formula (7) is designed
based on a typical hash algorithm, which includes sha1, sha256,
sha512, aside from md5. These algorithms have some salient fea-
tures: First, the target attribute in these algorithms can be short
text objects in the value transfer algorithm, or part of the long text
(no shorter than 128 bits) included in some specific files in a victim
host computer. Second, these algorithms can convert the target
attributes into unbreakable secret key of different lengths. For in-
stance, md5, sha1, sha256 and sha512 algorithms can respectively
convert the following secret key lengths: 128 bits, 160 bits, 256 bits
and 512 bits. To highlight these two features, this paper took some
specific files as the target attributes and constructed a Discriminator
based on the sha256 algorithm, as shown in Formula (8):

𝑘𝑒𝑦ℎ𝑎𝑠ℎ = 𝑠ℎ𝑎256(𝑡𝐹𝑖𝑙𝑒)

(8)

where tFile refers to a designated target file, and sha256() can be
realized by the sha256() method in the hashlib, and thus 𝑘𝑒𝑦ℎ𝑎𝑠ℎ is
the key generated based on the target file. As the example shown in
Figure 6, the APT1 report titled Appendix C (Digital) - The Malware
Arsenal.pdf is the designated target file; if the Discriminator takes
this file as the input, the output key will be: 0xe22e8ccf50d9e0013688
229ffbffb4bc3a77e6e46b23726fd83925ba5899af3e.

Figure 6: Typical hash algorithm based Discriminator

4.3 Binary deep neural network
The binary classification deep neural network (“B-DNN” for short)
model is implemented, aimed at the target attribute of the unique-
typedness. During its implementation, the input space should be
provided with a type of high-quality target attribute samples set and
a type of high-quality non-target attribute samples set to meet the
demand for B-DNN training. A well-trained B-DNN can establish a
“multiple-to-one” mapping relationship between one type of target
samples and the stable key.

Thus, we first constructed a binary classification sample set.
Specifically, we designated the facial images of Tom Cruise as the
target attributes, and those that were not his facial images as the
non-target attributes. Figure 7 shows some examples of a type of
target attribute samples.

Figure 7: Examples of a type of facial images of Tom Cruise

Then, we trained the B-DNN model using the prepared sample
set to realize the binary classification and achieve accurate identifi-
cation of the target attributes.

Meanwhile, in Discriminator construction, concealment of ma-
licious intent is realized by concealing the key. Therefore, in the
B-DNN model in this paper, the key was dynamically concealed
in a specific hidden layer. Moreover, this designated hidden was
designed to have at least 128 neurons so that the output key could
be no shorter than 128 bits to defend against reverse decryption.

After repeated adjustment, training and testing, we obtained a
B-DNN model (Figure 8). In the figure, Conv refers to the convolu-
tional layer, Relu refers to the activation layer, which is implemented
based on the rectified linear unit function; Pool refers to the pooling

The First Step Towards Modeling Unbreakable Malware

arxiv ’20, 2020, xxx

(a) 𝐼0

(b) not 𝐼0

Figure 10: Target images for Perceptual hash based Discrim-
inator

Thereby, for a type of target attribute samples, the B-DNN based
Discriminator could produce a stable output, i.e., the stable key. Take
for example the facial image of Tom Cruise shown in Figure 9; we fi-
nally obtained the stable key: 0x5c3871870e3c50f469dd86aeed38f7ed.

4.4 Perceptual hash algorithm
The perceptual hash algorithm generates a “fingerprint” charac-
ter string for each image and then compares the fingerprints: a
higher similarity between the fingerprints indicates more resem-
blance between the corresponding images. One notable feature
of this algorithm is that it generates the fingerprint for a type of
similar images. When an attacker designates a specific image, the
perceptual hash algorithm can generate different embeddings for
this image and keep their perceptual hash values the same. This
considerably facilitates coordinated adversarial attacks and helps
circumvent detection of signatures and hashes by the defenders so
that other bots will remain hidden when one bot is detected.

Suppose we denote a type of images with perceptual hashes
as {𝐼0, 𝐼1, 𝐼2, . . . , 𝐼𝑛}, and when one target image 𝐼0 is designated,
other images of the same type {𝐼1, 𝐼2, . . . , 𝐼𝑛 } are usually man-made.
Figure 10 presents an example: Sub-fig. (a) shows a target image
designated by the text, i.e., the image of the Microsoft Word program.
We slightly altered (a) to generate Sub-fig. (b) while maintaining
their visual resemblance. They had distinct sha256 hash values but
the same perceptual hash value. Therefore, both sub-figs. (a) and
(b) can be taken as the target image and be accurately identified by
the perceptual hash-based Discriminator.

In this paper, we constructed a Discriminator based on the per-
ceptual hash algorithm (Figure 11). As with the B-DNN based Dis-
criminator, this Discriminator is also aimed at the target attribute
of unique-typedness and comprises fCollector and Discriminator.
The fCollector, with the two functions of “image graying” and “im-
age size adjustment”, collects the main features of an input image
and outputs a 9*9 gray image as the feature image. Then, the Dis-
criminator calculates the row hash and column hash of the feature
image before outputting a hash image and a column hash image,
both of a size of two 8*8. These two output images correspond
to two 64-bit hash calculation results, which are then combined
into a 128-bit output. An example is shown in Figure 11: the tar-
get image 𝐼0 in Figure 10 is input into the Discriminator, and the
output is a 128-bit key, which is represented in hexadecimal as:
0xd4e8e8aa8c94d4d4ffc04b6b6baab680.

To judge whether these four Discriminators constructed above
meet the requirements for UBM construction, we designed quali-
tative constraints on the “unbreakable” security attribute 𝑈 𝑛𝑏 of

Figure 8: Unfolded layers of B-DNN

layer, AffineX refers to the fully-connected layer, with X indicat-
ing the number of neurons within. For example, Affine128 refers
to a fully-connected layer with 128 neurons. The Dropout layer
serves to prevent overfitting, and Softmax, the last layer, performs
normalization and classification.

At last, we built a B-DNN based Discriminator (Figure 9): Layers
0-17 in the model form the feature collector fCollector, and Layers
18-25 constitute the Discriminator. When the image of Tom Cruise
is taken as the input, fCollector will first collect the features, and
the output of the fully-connected layer is taken as high dimension
feature vector representation, which will then be input into the
Discriminator to identify whether the input image is the target
attribute.

Figure 9: B-DNN Based Discriminator

Specifically, the Discriminator will produce output for Affine128
(Layer 18 shown in Figure 8), and the established B-DNN has stable
representation on this output, i.e., it corresponds to a type of target
attribute samples, and the 128-bit outputs on this layer are very
similar. Then, we use the bucketization mechanism to process these
similar outputs to achieve a stable output. For example, both 0.995
and 0.998 were output as 1, 0.0006 and 0.0001 were output as 0.

arxiv ’20, 2020, xxx

Tiantian Ji, Binxing Fang, Xiang Cui, Zhongru Wang, Jiawen Diao, Tian Wang, and WeiQiang Yu

For value transfer based Discriminator and typical hash based
Discriminator, the input target attribute samples are text no shorter
than 128 bits. There are no constraints on the content of the textual
inputs, so the difficulty of traversing these inputs in the binary space
will surely satisfy 𝑃𝑖𝑛 = 1/2𝑙𝑒𝑛 (𝑡𝑎𝑟𝑔𝑒𝑡 𝑠𝑎𝑚𝑝𝑙𝑒) ≤ 1/2128 , where
𝑙𝑒𝑛(𝑡𝑎𝑟𝑔𝑒𝑡𝑠𝑎𝑚𝑝𝑙𝑒) refers to the binary length of the target attribute
sample. It should be noted that the file type’s target attributes also
fall into the category of text.

For B-DNN based Discriminator and perceptual hash based Dis-
criminator, the input attribute samples were a type of images. When
used to constructed the UBM, these two algorithms established a
“multiple-to-one” mapping relation between a specific type of im-
ages and key no shorter than 128 bits, and generated the different
outputs for different types of images. Since the enumeration space
of the key were at least 2128 large, the number of corresponding
types of images surely exceeded 2128, which met the standard .

To sum up, the input and output spaces of all the four Discrimina-
tors constructed in this paper met the requirement of “unbreakable”
non-enumerability.

5.2 Evaluation of definiteness
The Discriminators constructed based on the value transfer algo-
rithm and typical hash algorithm establishes a “one-to-one” map-
ping relation between the target attribute and the key, and there is
only one positive sample that corresponded to the target attribute.
Therefore, according to Table 2, 𝑃𝑠𝑡𝑎 and 𝑃𝑎𝑐𝑐 must be 1 and 0.

Using Formula (5), we obtained that 𝑃𝑠𝑡𝑎 was 1:1, which indi-
cates a 100% probability for “key stability”. As shown in the non-
enumerability evaluation, the input space comprised of positive
and negative samples was infinitely large, which means that the
number of negative samples corresponding to non-target attributes
was no less than 2128. Therefore, according to Formula (6) and the
“one-to-one” definite mapping relation, 𝑃𝑎𝑐𝑐 ≤ 0/2128 = 0, i.e., the
“key accessibility” probability was 0.

The Discriminators constructed based on B-DNN and the percep-
tual hash algorithms establish a “multiple-to-one” mapping between
the target attributes and the key. As shown by the eva tuple in Ta-
ble 2, we set an acceptable range of fault tolerance, requiring that
𝑃𝑠𝑡𝑎 ≥ 95% and 𝑃𝑎𝑐𝑐 ≤ 0.5%.

For the B-DNN based Discriminator, the input space is finite.
According to Formula (5) and (6), if the requirements for key stabil-
ity and accessibility requirements can be satisfied in a finite input
space, then they can also be satisfied in an actual input space that is
infinitely large. Therefore, for the B-DNN based Discriminator, the
finite input space was created by the Tom Cruise’s facial images
data set (contains 1317 positive samples) and non-Tom Cruise’s
facial images data set (contains 1757 negative samples). Finally, this
Discriminator achieved a 𝑃𝑠𝑡𝑎 of 98.5%, and a 𝑃𝑎𝑐𝑐 of 0, which met
the evaluation standard for “definiteness”.

Particularly, for the Discriminator created based on the percep-
tual hash algorithm, all images in a same type of samples, except
the initially designated image 𝐼0, are inputs controlled and ma-
liciously tweaked by the attacker, and they are invisible to the
defender. The only visible image is the image 𝐼0 in the input space.
In this logic, though the discriminator built based on the perceptual
hash algorithm is for the target attribute of unique-typedness, the

Figure 11: Perceptual hash algorithm based Discriminator

the UBM according to Table 2. That is, we specified the four crit-
ical values x, y, z and w in the tetrad eva. Then, we specified the
evaluation standards for non-enumerability of 𝑃𝑖𝑛 and 𝑃𝑜𝑢𝑡 as the
constraint, and the evaluation standards for definiteness of 𝑃𝑠𝑡𝑎 and
𝑃𝑎𝑐𝑐 as the constraints. As per the formalized definition of UBM,
𝑈 𝑛𝑏 is a two-tuple consisting of the two core features. That is to say,
only when the malware constructed by the Discriminator meets the
evaluation standards of these two core features can it be defined as
UBM, i.e., malware with the “unbreakable” security attribute 𝑈 𝑛𝑏.
To sum up, in order to construct the UBM, we would first evaluate
the two core features of “non-enumerability” and “definiteness” in
the upcoming text.

5 EVALUATION
This paper evaluated the Discriminators by the following four as-
pects: (a) non-enumerability, (b) definiteness, (c) UBM volume in-
crement, and (d) actual adversarial defense capability. Evaluation of
the first two is a security evaluation of the Discriminator to judge
whether the discriminator meets the criteria for UBM construction;
evaluation of the latter two is a fact evaluation of the applicability
of the UBM. In other words, by evaluating (c) and (d), we could
measure the UBM’s capacity to survive antivirus engines and sound
alarms for security defense.

5.1 Evaluation of non-enumerability
As per the standard for generating 128-bit unbreakable key, we
set the limit of the infinite traversal at 2128. Thus, as shown in
Table 2, the enumeration space in both the input and output spaces
in this paper had to exceed 2128. From the perspective of reverse
definition, both of the two non-enumerability indicators 𝑃𝑖𝑛 and
𝑃𝑜𝑢𝑡 were set as ≤ 1/2128 in this paper.

In this paper, all the four Discriminators output key no shorter
than 128 bits, and the key length was equivalent to the key strength
because we used the AES algorithm. The Discriminator constructed
based on the typical hash algorithm output 256-bit key, and accord-
ing to Formula (4), 𝑃𝑜𝑢𝑡 = 1/2256 < 1/2128; the rest three Discrimi-
nators generated 128-bit key, and the corresponding 𝑃𝑜𝑢𝑡 = 1/2128.
That is to say, all of the four Discriminators met the standards for
unbreakable non-enumerability in the output space.

• Input space

As indicated by Formula (2) and (3), to realize the unbreakable
non-enumerability in the input space, the total number of input
samples should be at least 2128 for the target attribute of unique-
ness; and for the target attribute of unique-typedness, the total
number of input sample types should be no less than 2128.

The First Step Towards Modeling Unbreakable Malware

arxiv ’20, 2020, xxx

“multiple-to-one” mapping relation it establishes is in essence equiv-
alent to a “one-to-one” mapping relation. Then, by using Formula (5)
and (6), the 𝑃𝑠𝑡𝑎 was 1 and the 𝑃𝑎𝑐𝑐 was 0.

To sum up, the four Discriminators built in this paper all satisfied
the requirements of “key stability” and “key accessibility”, so they
showed “definiteness”. The results of non-enumerability evaluation
also revealed that they met the standards. In other words, all the
four Discriminators fulfilled the “unbreakable” security attributes
and hence met the standards for constructing the UBM. Then, based
on the tuples presented in Table 2, we constructed four UBMs in
this paper: 1○ value transfer-based UBM, 2○ typical hash-based
UBM, 3○ B-DNN based UBM, and 4○ perceptual hash-based UBM.

5.3 UBM volume increment
To minimize the chance of being suspected during malware attacks,
the UBM volume increment must be considered. The UBM volume
increment is defined as the combined volume of the rest four tuples
among the six UBM tuples except for BenCode and Unb.

First, the benign function code BenCode implemented in this
paper was a simple “Hello, world” pop-out. We packed the benign
function codes into an executable application, whose volume was
20723 KB, i.e., circa 20.24 MB.

Table 3 shows the volume increment of the four UBMs obtained
based on the volume of BenCode. Specifically, these UBMs were
divided into two categories: UBMs constructed based on methods
other than neural networks ("NN" for short), and those constructed
based on NN. The former is a “code-is-implementation” method.
Their UBM volume increment comes from the increase of codes
due to the construction of Discriminator, Judger and Decryptor,
and the dynamic link library that these codes rely on during the
program packing process. We refer to this kind of UBM volume
increment as “code volume increment”. Construction of the latter
category of UBM relies on training the neural network, adjusting
model parameters, and saving of the architecture, which will bring
in additional volume increment. In this paper, we refer to this kind
of increment as “non-code volume increment”.

In Table 3, the “code volume increment” and “non-code volume
increment” columns sum up the total volume increment brought
about by Discriminator, Judger and Decryptor. There is another
type of increment: the free volume increment brought about by the
cipher payload cp. As the type, function, or representation of the
cipher payload varies, the volume of the free volume increment
differs. In this connection, we analyzed the volumes of payloads
labeled “malicious” in the public cloud sandbox and concluded that
the volume of almost half of payloads is smaller than 1 MB. As
stated in Table 2, when constructing the UBM, we took the a.exe
in trickbot as the malicious payload, whose volume stayed at 452
KB before and after encryption. Compared with the volume of a
benign function program, the volume of the payload is negligible.
Finally, based on the data recorded in Table 3, we reached the
following conclusion: The non-NN method brought about little
volume increment when used to construct the malware. Thus, it
would make the malware less likely to be suspected by the defender
in actual applications. As for the NN method, the network model
that used to construct the B-DNN based UBM in this paper was
artificially built without relying on the open source TensorFlow

library, so the model can be saved to a very small size, making the
final total volume increment stay at only 4.27 MB. Compared with
that of a benign function program, this volume is still unlikely to
raise the defender’s suspicion.

Given the analyses of volume increment above, the range of
volume increment of the four UBMs built in this paper was [0.99
MB, 4.27 MB], and the larger the volume of the benign function
program was, the less likely the UBM would be detected as suspi-
cious. Therefore, in actual attack scenarios, selecting proper benign
function programs is necessary according to the acceptable range
of malware volume increments when constructing the UBM.

5.4 Actual anti-defense capability
From the perspective of adversarial attack and defense, the attacker
conceals the malware to survive or circumvent the detection of the
defender’s antivirus engine, thereby creating a chance to launch
attacks. To better demonstrate the actual attack performance of the
UBM, we used antivirus engines deployed on the cloud and on the
host computer to test the anti-defense capacity of our constructed
UBMs. One antivirus engine on the host computer and nearly 100
antivirus engines on the cloud were employed to conduct detection.
Especially VirusTotal [4], which integrates most of the well-known
anti-virus engines, can perform static analysis or dynamic detection.
Therefore, the detection result delivered by VirusTotal is convincing,
and the same is true for ThreatBook [14], as shown in Table 4.

As mentioned before, the plain payload used in this paper is
a.exe in trickbot. When it was downloaded to the host computer or
uploaded to the cloud detection engine, the antivirus engine on the
host computer would immediately scan and clean it. The VirusTotal
employed on the cloud side conducted detection using 72 antivirus
engines, 57 of which detected plain payloads as “malicious”. Among
the 25 antivirus engines in ThreatBook, nine detected plain payloads
as “malicious” and marked their threat level as “malicious”.

Unlike the plain payload, the cipher payload was identified as
“secure” files by antivirus engines both on the host computer and
the cloud. Moreover, as shown in Table 4, the four complete and
releasable UBMs constructed in this paper have also been detected.
The result shows that almost all four UBMs were identified as “safe”.
Therefore, we could conclude that even when the UBM or the cipher
payload was open source, the defender still could not find a way
to crack the malicious intent hidden in the malware by forward
or reverse analysis methods. Finally, it should be noted that in
Table 4, as the file size upper limit was set at 20 MB on ThreatBook,
while our uploaded UBM exceeded this limit, so we did not use the
engines on ThreatBook to test our constructed UBMs.

To sum up, by evaluating the four aspects of the constructed
UBMs, i.e., the non-enumerability, definiteness, UBM volume in-
crement and actual anti-defense capability, we confirmed the se-
curity benefits of UBM. To be specific, by evaluating the “non-
enumerability” and “key stability and key accessibility” of the UBMs,
we verified their “unbreakable” security attribute; evaluation of
their “UBM volume increment” and “actual anti-defense capabil-
ity” attested that the UBMs could conceal the malicious intent and
survive/circumvent detection by almost all available well-known
antivirus engines for the time being.

arxiv ’20, 2020, xxx

Tiantian Ji, Binxing Fang, Xiang Cui, Zhongru Wang, Jiawen Diao, Tian Wang, and WeiQiang Yu

Table 3: Volume increment of UBMs

*** based UBM

Value transfer algorithm

Code
volume increment
21740KB-20723KB

Non-code
volume increment
0

Total
volume increment
0.99MB

Volume of
cipher payload

Non-NN
method

Typical hash algorithm

21738KB-20723KB

Perceptual hash algorithm 23245KB-20723KB

0

0

NN method

B-DNN

23247KB-20723KB

model: 1850KB

0.99MB

2.46MB

4.27MB

452KB

Table 4: Detection results of antivirus engines

Antivirus
engine

Host

huorong

plain
payload
Kill immediately

cipher
payload
0 risk

Cloud

VirusTotal

57/72

0/61

ThreatBook

9/25

0/25

UBM

0 risk

1○: 1/72
2○: 1/71
3○: 1/70
4○: 1/71
–

1○Value transfer algorithm based UBM, 2○Typical hash algorithm based UBM, 3○B-DNN based

Note :
UBM, 4○Perceptual hash algorithm based UBM.

6 DEFENSE AGAINST UNBREAKABLE

MALWARE

In this section, we probed into possible defense measures based on
analysis of vulnerabilities of UBM revealed during target attribute
designation and in the functioning stages, with a vision to address
new security threats incurred by UBM.

• Vulnerability incurred by target attribute designation

In the input space of the Discriminator, there were various types
of target attributes that can be designated and connected to the
victim host computer, such as the software environment, physical
environment, user behavior and geographic location, as shown in
Figure 3. By selecting proper target attributes, the defender can
have two possible defense solutions.

First, from the perspective of security defense, the intrinsic at-
tributes of the victim, such as computer name and user name, can
be utilized. In the input space, these intrinsic attributes help to
ensure non-enumerability; on the defender’s side, however, calling
these attributes can be taken as features that helps to detect UBM.
As for the second solution, when the designated target attribute
is a specific file or image, this type of target attributes will see a
considerable traversal space in the victim host computer (this space
is a subset of the input space). In this case, the Discriminator needs
to frequently execute “read” operations (loading pictures frequently,
for instance) in an attempt to decrypt the malicious payload. On
the defender’s side, these frequent operations are aberrant behavior
and can be taken as a feature for the detection of UBM.

Based on the malware attack chain [5], we focused on malware
concealment capability of our constructed UBMs before an attack
was unleashed, while the two stages of “effect” and “command
and control” were not considered. However, even if the UBM has
achieved nearly complete concealment before launching an attack,
it will still be subject to detection by process behavior-based [10, 15]
and malicious traffic-based [8, 11] detections after launching the
attack. Therefore, the defender can defend against the UBM by
real-time scanning and removal of malicious behaviors.

7 CONCLUSION AND FUTURE WORK
For the first time, this paper proposed the concept of unbreakable
malware – UBM, and made a systematic probe into it through mod-
eling, method analysis, experiments, evaluation and anti-defense
tests. Compared with existing methods, we built UBM and thus
summarized the features of this type of malware: any malware that
satisfies the two core features of “non-enumerability” and “definite-
ness” possesses the “unbreakable” security attribute.

By formalized modeling, research on security attributes, archi-
tecture building, and exploration of evaluation standards, we con-
structed UBM instances based on four algorithms. In the experi-
ments, we verified the “unbreakable” security attribute of the con-
structed UBMs through security evaluation; meanwhile, by evaluat-
ing the applicability of the UBM, we confirmed that UBM is a novel
high-threat attack technique. That is, it has a volume increment
that is hardly perceivable, and can get away with the detection by
nearly one hundred antivirus engines deployed locally or on the
cloud.

Moreover, we have explored possible defense solutions to attacks
of UBM and uncovered some of its defects. In future work, we will
try to repair these defects and improve the performance of UBM.
More importantly, we will invest more to explore defense solutions
against this type of advanced “unbreakable” malware.

REFERENCES
[1] Jeremy Blackthorne, Alexei Bulazel, Andrew Fasano, Patrick Biernat, and Bülent
Yener. 2016. AVLeak: Fingerprinting Antivirus Emulators through Black-Box
Testing. In 10th USENIX Workshop on Offensive Technologies, WOOT 16, Austin, TX,
USA, August 8-9, 2016, Natalie Silvanovich and Patrick Traynor (Eds.). USENIX
Association. https://www.usenix.org/conference/woot16/workshop-program/
presentation/blackthorne

[2] Thomas M. Chen and Saeed Abu-Nimeh. 2011. Lessons from Stuxnet. Computer

44, 4 (2011), 91–93. https://doi.org/10.1109/MC.2011.115

[3] David Clement. 2019. 2019 Midyear Security Roundup: Evasive Threats, Pervasive
Effects. Technical Report. https://documents.trendmicro.com/assets/rpt/rpt-
evasive-threats-pervasive-effects.pdf

[4] google [n. d.]. VirusTotal. Retrieved August 18, 2020 from https://www.virustotal.

• Vulnerability incurred in the functioning stage

com/gui/home/upload

The First Step Towards Modeling Unbreakable Malware

arxiv ’20, 2020, xxx

[5] Tiantian Ji, Binxing Fang, Xiang Cui, Zhongru Wang, Ruiling Gan, Yu Han,
and Weiqiang Yu. 2020. Research on deep learning-powered malware attack
and defense techniques. Chinese Journal of Computers 43, 13 (May 2020), 1–29.
http://cjc.ict.ac.cn/online/bfpub/jtt-202058150207.pdf

concealing targeted attacks with ai

[6] Dhilung Kirat, Jiyong Jang, and Marc Ph. Stoecklin. 2018.

Deeplocker
-
In Black Hat
USA, 2018, Las Vegas, USA, August 4-9, 2018.
informatech, 3873–3878.
https://www.blackhat.com/us-18/briefings/schedule/index.html#deeplocker---
concealing-targeted-attacks-with-ai-locksmithing-11549

locksmithing.

[7] Clemens Kolbitsch, Engin Kirda, and Christopher Kruegel. 2011. The power of
procrastination: detection and mitigation of execution-stalling malicious code.
In Proceedings of the 18th ACM Conference on Computer and Communications
Security, CCS 2011, Chicago, Illinois, USA, October 17-21, 2011, Yan Chen, George
Danezis, and Vitaly Shmatikov (Eds.). ACM, 285–296. https://doi.org/10.1145/
2046707.2046740

[8] Gonzalo Marín, Pedro Casas, and Germán Capdehourat. 2019. Deep in the Dark -
Deep Learning-Based Malware Traffic Detection Without Expert Knowledge. In
2019 IEEE Security and Privacy Workshops, SP Workshops 2019, San Francisco, CA,
USA, May 19-23, 2019. IEEE, 36–42. https://doi.org/10.1109/SPW.2019.00019
[9] Najmeh Miramirkhani, Mahathi Priya Appini, Nick Nikiforakis, and Michalis
Polychronakis. 2017. Spotless Sandboxes: Evading Malware Analysis Systems
Using Wear-and-Tear Artifacts. In 2017 IEEE Symposium on Security and Privacy,
SP 2017, San Jose, CA, USA, May 22-26, 2017. IEEE Computer Society, 1009–1024.
https://doi.org/10.1109/SP.2017.42

[10] Matilda Rhode, Pete Burnap, and Kevin Jones. 2018. Early-stage malware pre-
diction using recurrent neural networks. Comput. Secur. 77 (2018), 578–594.
https://doi.org/10.1016/j.cose.2018.05.010

[11] Homayoun Sajad, Ahmadzadeh Marzieh, Hashemi Sattar, Dehghantanha Ali, and
Khayami Raouf. 2018. BoTShark: A deep learning approach for botnet traffic
detection. In Cyber Threat Intelligence, Dehghantanha Ali, Conti Mauro, and
Dargahi Tooska (Eds.). Advances in Information Security, Vol. 70. Springer, Cham,

137–153. https://doi.org/10.1007/978-3-319-73951-9_7

[12] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vi-
gna. 2016. Driller: Augmenting Fuzzing Through Selective Symbolic Exe-
cution. In 23rd Annual Network and Distributed System Security Symposium,
NDSS 2016, San Diego, California, USA, February 21-24, 2016. The Internet Soci-
ety. http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2017/09/
driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf

[13] The MITRE Corporation 2015–2020. MITRE ATT&CK. Retrieved August 18,

2020 from https://attack.mitre.org/

[14] ThreatBook [n. d.]. Threatbook cloud sandbox. Retrieved August 18, 2020 from

https://s.threatbook.cn/

[15] Shun Tobiyama, Yukiko Yamaguchi, Hajime Shimada, Tomonori Ikuse, and
Takeshi Yagi. 2016. Malware Detection with Deep Neural Network Using Process
Behavior. In 40th IEEE Annual Computer Software and Applications Conference,
COMPSAC Workshops 2016, Atlanta, GA, USA, June 10-14, 2016. IEEE Computer
Society, 577–582. https://doi.org/10.1109/COMPSAC.2016.151

[16] Tushar Ubale and Ankit Kumar Jain. 2020. Survey on DDoS Attack Techniques
and Solutions in Software-Defined Network. In Handbook of Computer Networks
and Cyber Security, Principles and Paradigms, Brij B. Gupta, Gregorio Martínez
Pérez, Dharma P. Agrawal, and Deepak Gupta (Eds.). Springer, 389–419. https:
//doi.org/10.1007/978-3-030-22277-2_15

[17] Qi Wang, Wajih Ul Hassan, Ding Li, Kangkook Jee, Xiao Yu, Kexuan Zou, Jungh-
wan Rhee, Zhengzhang Chen, Wei Cheng, Carl A. Gunter, and Haifeng Chen.
2020. You Are What You Do: Hunting Stealthy Malware via Data Provenance
Analysis. In 27th Annual Network and Distributed System Security Symposium,
NDSS 2020, San Diego, California, USA, February 23-26, 2020. The Internet So-
ciety. https://www.ndss-symposium.org/ndss-paper/you-are-what-you-do-
hunting-stealthy-malware-via-data-provenance-analysis/

[18] Micha? Zalewski. 2015–2020. American fuzzy lop. Retrieved August 18, 2020

from https://lcamtuf.coredump.cx/afl/

