Secure Lightweight Authentication for Multi User
IoT Environment

Chintan Patel, Member, IEEE

1

2
2
0
2

l
u
J

1
2

]

R
C
.
s
c
[

1
v
3
5
3
0
1
.
7
0
2
2
:
v
i
X
r
a

Abstract— The Internet of Things (IoT) is giving a boost to a
plethora of new opportunities for the robust and sustainable
deployment of cyber-physical systems. The cornerstone of any
IoT system is the sensing devices. These sensing devices have
considerable resource constraints, including insufﬁcient battery
capacity, CPU capability, and physical security. Because of such
resource constraints, designing lightweight cryptographic proto-
cols is an opportunity. Remote User Authentication ensures that
two parties establish a secure and durable session key. This study
presents a lightweight and safe authentication strategy for the
user-gateway (U-GW) IoT network model. The proposed system
is designed leveraging Elliptic Curve Cryptography (ECC). We
undertake a formal security analysis with both the Automated
Validation of Internet Security Protocols (AVISPA) and Bur-
rows–Abadi–Needham (BAN) logic tools and an informal security
assessment with the Delev-Yao channel. We use publish/subscribe
based Message Queuing Telemetry Transport (MQTT) protocol
for communication. Additionally, the performance analysis and
comparison of security features show that the proposed scheme
is resilient to well-known cryptographic threats.

Index Terms—Generic IoT, Home Area Network, ECC,
Authentication, MQTT

I. INTRODUCTION

E xpansion of internet-based services signiﬁcantly impacts

routine life of the people. Due to its ambient and easy-to-
use support services, the adoption of Internet of Things (IoT)
based services (i.e., smart electricity supply, smart agricultural,
industry 4.0, smart healthcare,
smart amenity distribution,
smart home) has soared in recent years.

According to recent Gartner forecasts, more than 25.44
billion IoT gadgets will be incorporated into the cyber world’s
working environment by 2030. IoT-based smart health care
connects healthcare entities such as patients, doctors, hospital
administrators, drug suppliers, ambulances, and pharmacists
using a network of smart healthcare devices. Doctors can
obtain real-time health data from patients via wearable health
devices using an intelligent patient monitoring system.

IoT based smart grid provides a intelligent system for
electricity generation, electricity distribution and customer
payments [1]. The smart grid aims to convert current client-
server type electricity distribution to peer-to-peer type energy
distribution. Using a two-way electricity line, consumers can
also sell
their self-generated energy to power distribution
companies. The smart meter provides real-time monitoring for
the energy distribution system [2].

IoT-based intelligent and smart agriculture helps farmers
in environment monitoring, soil quality analysis, fertilizer

Chintan Patel is a Post doctorate Fellow in University of Shefﬁeld,

UK.

E-mail: chintan.p592@gmail.com

requirement analysis, water distribution control, and so on.
Farmers can save water, money, and time by using smart agri-
culture applications. Farmers can get inputs from agriculture
scientists and the government about their fertilizer needs, and
new crop decreases using the real-time data generated from
the ambient deployment of nano-sensors on farms [3].

An IoT-based smart home provides automation and smart
control for their ambient home devices. Smart home users can
control home devices from anywhere globally using internet-
connected intelligent home appliances. The smart home user
can do the security checkup, thermal monitoring, light con-
trolling, washing machine controlling, and many more smart
activities using in-hand mobile devices.

The vast data generated from these IoT-based services is
stored in the cloud and is used for generating knowledge
through data processing. Thus, IoT provides an opportunity
for the real-time monitoring of sensor data for quick decision-
making and storage of data for data analysis and futuristic
planning. Every IoT based data service pass through the
following four basic layers:

• The ground layer provides the physical deployment of
sensing devices and actuator devices on the ground. This
layer works as a data generator.

• The second layer consists of gateway devices that collect
data from ground layer sensing devices and deliver this
data to the end-user as well as to the cloud for any further
processing.

• The third layer provides data analysis using machine
learning techniques and artiﬁcial intelligence-based in-
telligent decision making.

• The fourth layer focuses on end-users who collect the
data from the third layer as well as the ground layer
(based on application) via second layer devices.

The IoT deployment comes with many challenges and op-
portunities. Starting from deploying thousands of tiny and
heterogeneous devices on the ground level to data collection,
data analysis, and intelligent decision-making forms signiﬁcant
challenges for researchers. The recent past surveys by [4]
show that standardization, communication protocol designing,
data analysis, security, and privacy are the highly notable
challenges in the IoT setup. These surveys also highlight that
security is a big concern, among others. Some of the signiﬁcant
security issues are data conﬁdentiality, user privacy, device
authentication, physical security, and so on [5]. Followings are
two crucial reasons behind the need for a full-proof security
mechanism for the IoT system.

• Numerous heterogeneous tiny resource constraint devices

on the ground level.

 
 
 
 
 
 
• Privacy of the user’s data.

We can divide the IoT devices among three major parts:

• User devices in the IoT are a combination of resource
constraints and resource-capable devices. Resource con-
straint devices like wearable devices to resource-capable
devices like laptops and mobiles.

• Gateway devices in the IoT are considered resource-
capable devices and can work as intermediary devices
between sensing devices and user devices. They provide
setup support to the other devices in the IoT system.
The IoT user communicates with the gateway device to
receive runtime sensing data.

• Sensing devices in the IoT involve tiny sensors and
actuator devices. They are not capable of performing
any traditional and non-traditional security mechanisms.
Many security papers highlight that sensing devices do
cryptographic operations, but it is non-practical in real
time due to energy issues and on-time service require-
ments. e.g., A thermal sensor deployed in the house can
not run for the cryptographic operation when you ask
for temperature. They transmit data to the home gateway
device, and the user receives data from it.

Thus, the communication between sensors, gateway devices,
and end-users must be secure enough to fulﬁll all the critical
security goals. The secure authentication mechanism between
these devices provides secure key generation for communi-
cation and mutual trust among each communicating party. A
secure authentication system fulﬁlls most major security goals
except some like access control [6], [7].

Cryptography is a branch of mathematics that deals with
. With the
enumerations and executions of cryptosystems.
run-up towards smart technology, the need for lightweight
cryptography came into the picture. The reason behind this
need is the use of numerous resource constraint devices in
the deployment of sensor-based IoT application deployments.
These resource constraint devices are short of computation
memory and storage capability. It is nearly impossible for these
devices to perform sixteen rounds of Data Encryption Standard
(DES) and exponential computations of the RSA promptly
and without higher energy utilization. In 2003, Hankerson et
al. highlighted Elliptic Curve Cryptography (ECC), which is
much lighter than traditional crypto methods in computations
and storage requirements [8]. Due to its appealing features
such as reduced key sizes, relatively short time requirements,
and limited resource utilisation, the ECC became a well-known
cryptographic approach for resource constraint devices. . The
Elliptic Curve Difﬁe-Hellman encryption (ECDHE) provides a
lighter version of Difﬁe-Hellman with Elliptic Curve Discrete
Logarithm Problem (ECDLP).

Contributions : For the U-GW-based network model pre-
sented in section A, we provide a secured and coherent two-
factor authentication protocol employing a password and a
smart card (SC). In the U-GW-based network model, we
consider that the IoT application user communicates with the
gateway device for receiving the sensor data. Over here, we
believe that the sensing device deployed in the local network
are tiny devices, and they do not perform security mechanisms.

2

In this model, the IoT user receives sensor data from the
gateway device through a precarious channel. We provide
a rigorous security analysis of the proposed scheme using
globally recognized tools such as BAN Logic and AVISPA.
An informal security analysis using widely adopted Dolev-Yao
attack model is also provided. We also compare the provided
solution to other approaches and analyze performance of
proposed work. This examination demonstrates the proposed
work’s uniqueness, efﬁciency, and reliability.

Motivations : The strong motivation for this paper is the
existence of numerous vulnerabilities in the recently proposed
schemes. After a thorough literature study, we critically ob-
served that it is challenging to design a lightweight authenti-
cation security scheme for sensing-based applications. These
devices require an authentication scheme that uses less energy,
less time, and lower space for the secure key exchange; hence
IoT users can timely receive heterogeneous IoT sensor data
from the gateway device. In the proposed scheme, the secure
key exchange between the gateway and the IoT user assures
secure data transmission of sensing data among IoT user
and gateway device over the anxious public internet. Another
strong motivation for proposing this work is a synchronous
implementation of the presented work. We implemented the
proposed scheme using the real-time deployment of sensors
and microprocessors (Raspberry-Pi).

A. Related work

In 1981, Lamport introduced the ﬁrst RUA scheme based on
the hash chain and with the password table at the server-
side [9]. By considering the limitations of password table-
based schemes, in 1993, Chang et al. [10] introduced the ﬁrst
Smart Card (SC) based authentication scheme. In the SC-based
authentication schemes, the user keeps an SC generated by the
service provider as another security feature. Following this
work, many other researchers proposed an RUA scheme for
the client-server model used on the internet.

In 2009, Das et al. set forth the ﬁrst two-factor authenti-
cation scheme for the wireless sensor network [11]. In 2010,
Khan et al. [12] performed cryptanalysis on Das et al.’s scheme
and successfully highlighted several vulnerabilities in their
system. They underlined that Das et al. technique is vulnerable
to a range of threats, involving node bypassing, a lack of
reciprocal authentication, and the likelihood of an insider
attack. Between 2010 to 2013, many authors proposed an
authentication scheme, but the continuous ﬁx-brake channel
of the authentication brightens up new vulnerabilities and
challenges for the two-factor authentication.

In 2013, Xue et al. [13] put forward a temporal credential-
based mutual authentication scheme using a password for the
WSN. In 2015, Jiang et al. [14] highlighted vulnerabilities
like identity guessing, privilege insider attack, and stolen SC
attack inside [13] and also proposed a new RUA scheme. In
2016, Amin et al. [15] came up with a lightweight mutual
authentication scheme for the WSN architecture. However, in
2017, Wu et al. [16] derived vulnerabilities like sensor capture
attack, user forgery attack, gateway forgery attack, and user
tracing attack security loopholes in [15].

In 2017, Jiang et al. [14] proposed a new three-factor
scheme after analysis of the scheme proposed by Amin et
al. They identiﬁed several security loopholes like known
session-speciﬁc temporary attacks and tracking attacks, side-
channel attacks, and impersonation attacks in [15]. In 2017,
Chen et al. [17] proposed an authentication scheme for the
IoT environment and claimed that it is secured from all the
well-known attacks, but recently in 2019, Patel et al. [18]
provided cryptanalysis for Chen et al.’s scheme and proved
that their scheme is not secure enough against attacks such as
sensor device anonymity and gateway device bypassing attack.
Recently, in 2020, Patel et al. also proposed a lightweight
authentication scheme for the same network model [19]. They
also highlighted that their proposed scheme is secure and
lightweight for the U-GW network model. The proposed
network model can be applied for UAV communications
[20], [21] also where users securely communicate with UAV
devices.

We limit the related work discussion due to the restricted
manuscript size. We suggest readers of this manuscript to refer
other ECC based RUA schemes for further references [22],
[23], [24], [19].

B. Road map of the paper

The remaining portion of the paper is organized as follows:
The section II contains the essential preliminaries that are
employed throughout this work. We propose an authentication
system in section III. The section IV encompasses formal and
informal security analysis which is followed by comparative
analysis of the proposed system with existing schemes. The
section VII provides implementation details. Finally, section
VIII summarizes this work by addressing some future aspects
of the proposed work.

II. PRELIMINARIES

section discusses preliminaries

This
the Net-
work model, Elliptic curve cryptography (ECC) encryp-
tion/decryption, and the threat model. We request readers to
follow [19] for the basics of hash function and ECC.

such as

A. Network model

IoT has started its journey with RFID (Radio-frequency identi-
ﬁcation) technology. RFID gets attraction due to its properties
like being free from the line of sight and acceptable range.
Thus, RFID tags on things can provide necessary information
about a thing, and internet-connected RFID readers can help
monitor and collect data. The IoT-based network models vary
from application to application. In this paper, we consider the
IoT-based U-GW network model [19]. We can use a smart
home network as an example of the U-GW network model,
where the user accesses data of all inner deployed sensing
devices using the local gateway device. This model is also
applicable to other IoT applications (such as smart hospital
management), where every registered user receives data from
the underlying sensing devices through the gateway device.

3

TABLE I
Notations and symbols

Symbols
U ID
||
U P W
⊕
GW
Sk
U
U Ri
GW Rj & ngw
Hash(.)
Tk
Kgw
Ku
Ad
→
⇒

Description
User Identity
String concatenation
User Password
Ex-OR Operation
Gateway
Session key
User
User random number
Gateway random number
One way Hash function
Time stamp
Gateway computed key
User computed key
Adversary
Insecure communication
Secured communication

Figure 1. Generic IoT network model

Figure 1. presents system model for the proposed approach.
The user establishes a secure session key only with the
gateway device in this model. Over here, we make realistic
assumptions that the communication between sensors and the
home gateway is secured though we consider that communi-
cation as a locally secured network [19]. This assumption is
valid because this model exclusively focuses only on the home
network, and there is no foreign agent involved in it [19].
The gateway node forwards all received data to the cloud and
provides live sensor data to the user.

In this network model, all application users register with the
gateway device, and the gateway device issues the requisite
credentials based on their requirements for data access. Sub-
sequently, whenever the IoT application user wants to access
the data, they forward a request to the gateway node for the
temporary lightweight session establishment.

B. Notations and symbols

Table I presents notations used for articulation of the proposed
scheme.

               Gateway Node 1 Gateway  Node 2 Internet Cluster Head Cluster Head User 1 User 2 Sensor Node Sensor Node Sensor Node Sensor Node Sensor Node Sensor Node Home Area Network C. ECC encryption/decryption

Device A and Device B uses key derivation function (KBKDF)
that provides every time same output if user provides same
input every time. The encryption/decryption operation over
elliptic curve occurs as follow:
Device A performs

1. Device A randomly generate ra where ra ∈ {1,2,....,n-1}

and is a private key for device A.

2. Device A computes P ubA = ra * G. Here P ubA serves as
a public key. For E/FP , G is known as a public generator
point shared between devices.

3. Device A publishes P ubA.
Device B performs

1. Device B selects rb where rb ∈ {1,2,....,n-1} and is a private

key for device B.

2. Device B computes public key P ubB = rb * G
3. Device B computes rb * P U BA = rb *(ra * G) = ra *

(rb * G).

4. Device B inputs rb * P U BA and generates symmetric key
K using the KBKDF. Device B encrypts message M as ME
= EncK(M ). Device B sends ME message to Device A
along with the value P ubB through public channel.

Device A performs
1. Device A inputs ra * (P ubB) into the same KBKDF and
generates symmetric key for the decryption as K. Device
A decrypts ME as M = DecK(ME).

D. Threat Model

We follow the following threat model considered from [25]
which derives certain capabilities for the adversary Ad. The
polynomial time Ad can:
1 compute valid pair of identity ∗ password ofﬂine in the

polynomial time.

2 extract information from the user’s smart card [26].
3 fully access communication channel between U-GW.
4 obtain the previously calculated session key.
5 get secrets of gateway node during system failure situations

[27].

6 get physical access to user device and can extract saved

information through power analysis.

7 Adversary Ad is unable to access the user password or
SC simultaneously. The simultaneous access of both the
password and SC leads to impersonation attack [19].

III. PROPOSED SCHEME

This section discusses the proposed ECC-based two-factor
authentication scheme for the U-GW paradigm. The proposed
scheme is divided into four steps: (1) Setup phase, (2) User
registration phase, (3) Login and key Generation phase, and
(4) Password update phase. We assume that there are n users
and a single gateway device for the proposed work. Table II
bright ups tabular presentation for the login and key generation
phase.

4

A. Setup phase
During the setup phase, the user device (Ui) and the gate-
way device (GW ) setup computation environment. For the
proposed scheme, the setup phase performs as follow:
UF1:
Step 1: Both Ui and GW devices agree on E/Fp (represents
curve deﬁned over ﬁnite ﬁeld F using prime number
p), the generator point G(X,Y) and the KBKDF.

U Ri ∈ Z ∗
range of Z ∗

Step 2: Ui produces random number U Ri

in such a way
p , Here p is a large prime number and the
p is (0,1,2....,p-1).
Step 3: Ui calculates Du = U Ri ∗ G.
Step 4: Ui sends Du to the GW in ofﬂine manner.
GWF1:
Step 1: GW generates

random number GW Rj where

GW Rj ∈ Z ∗
p .
Step 2: GW calculates Si = GW Rj*G.
Step 3: GW transmits Si to the Ui.
UF2:
Step 1: Ui generates symmetric key Ku using U Ri,Si by
KBKDF. This is not the session key but this is a key
that is used for encryption/decryption by both Ui and
GW whenever they establish session.

GWF2:
Step 1: GW generates symmetric key Kgw using GW Rj,D

by KBKDF.

Step 2: GW discards D.
Thus, after completion of setup phase, Ui device have {U Ri,
Du, Si} in its conﬁdential memory while Kgw in the secret
memory and the GW device have {GW Rj, Si} in its con-
ﬁdential memory while Kgw in its secret memory. The data
stored in conﬁdential memory is read-only and can be read by
anyone using power analysis or reverse engineering. But, the
data stored in secret memory can be read by the device itself
only.

B. User Registration Phase
In this phase, the Ui registers to the GW by using identity
U ID and password U P W . The gateway device generates an
SC (SC) with numerous parameters. These parameters are used
by Ui during the login and key generation phase.
UF1:
Step 1: Ui chooses unique identity U ID and secure password

U P W .

Step 2: Ui calculates hi = Hash(Du||U P W ||U ID).
Step 3: Ui generates message M1 = {U ID,hi} and sends M1
to GW over secure channel. We created a Transport
Layer Security (TLS) channel over the MQTT proto-
col for data transmission across a secure means in our
implementation.

GWF1:
Step 1: GW receives message M1 and retrieves user identity
U ID. GW veriﬁes U ID in the database and checks
its availability. If similar U ID is used by another
user then GW transmits message such as ”Identity

not available”, else (U ID is available for user Ui)
GW continues.

Step 2: GW computes Xi = Hash(U ID ⊕ hi),

M ID = EncKgw (U ID), T1 = Hash(Si||KS), Oi =
T1 ⊕ hi.
Step 3: GW frames

smart

card

SC,

SC

=

{Oi,MID,Xi,Hash(.)}.

Step 4: GW sends SC to the user through secure channel.
UF2:
Step 1: User Ui acquires SC from the GW device and keep
Du after encrypting it using T Kgw = {U P W *P}
and generates Z = EncT Kgw (Du). Ui stores Z into
secret memory of the SC. Thus ﬁnal SC with user
have {Oi,M ID,Xi,Hash(),Z} parameters. Except Z,
remaining parameters will be in conﬁdential memory
of the SC.

C. Login and key generation phase

The user will supply their identify, password, and SC to the
card reader during this phase. The card reader will authenticate
the user’s identity and password before communicating with
the Gateway to establish the session key.
UF1:
Step 1: Ui inserts U ID, U P W and SC in to SC reader (SCR).
SC computes DecU P W ∗P (Z) and extracts D from its
secret memory.

Step 2: calculates hi = Hash(Du||U P W ||U ID), X ∗

i =
?= Xi, T = Oi ⊕hi, Li
Hash(U ID||hi), and verify X ∗
i
= Hash(Du||U ID), PID = T ⊕ Hash(U ID||Li||Tk),
Z = EncKgw (Du).

Step 3: Ui frames M = {MID,Z,Tki,PID} and sends it to the
gateway device. Over here Tki is the current time
stamp of User.

GWF1:
Step 1: GW receives message M and computes own times-

?
≤ T ∗

tamp T ∗

k , Verify timestamp ∆T
Step 2: GW calculates DecKgw (M ID) to receive U ID.
Step 3: GW extracts Du by calculating DecKgw (Z).
Step 4: GW computes T = Hash(GW Rj||Kgw), Ni =
Hash(Du||U ID), P ID∗ = T ⊕ Hash(U ID||Ni||Tki).
Step 5: GW veriﬁes P ID ?= P ID∗. After successful veriﬁ-

k - Tk,

cation only GW continues.

Step 6: GW generates ngw in order to ngw ∈ Z ∗

p and

computes NS = EncKgw (ngw).

Step 7: GW calculates Sk = Hash(U ID||T ||ngw ∗ Du).
Step 8: GW calculates key veriﬁer SQi =

Hash(Sk||ngw||T ||Tknew ) and forwards Mnew =
{SQi, N S, Tknew } to user.

UF2:
Step 1: Ui recovers ngw = DecKu (N S).
Step 2: Ui calculates S∗
Step 3: Ui computes SQ∗
Step 4: Ui veriﬁes SQi

i = Hash(S∗
?= SQ∗
then he/she considers S∗

k = Hash(U ID||T ||ngw ∗ Du).
k||ngw||T ||Tknew ).
i . If veriﬁcation is successful
k as a new current session key.

5

D. Password update phase
Using this phase, Ui updates his/her identity U ID and pass-
word U P W through SCR device.
UF1:
Step 1: Ui provides SC to SCR and selects password update

option.

Step 2: Ui provides U ID, U P W , U P W new
SCRF1:
Step 1: SCR validates {U ID, U P W }. SCR computes hi =
i = Hash(U ID ⊕ hi) and

Hash(U ID||U P W ||D), X ∗
?= Xi.
checks X ∗
i

= Hash(U ID||U P W new||Du).

Step 2: Computes hnew
Step 3: Computes Oi = hi ⊕hnew

i

i
), Znew = EncU P W new (Du).

i ⊕Oi, X new

hnew
i

Step 4: Replaces {Xi,Oi,Z} by {X new

i

,Onew
i

= Hash(U ID⊕

,Znew}.

IV. SECURITY ANALYSIS

In this section, we put forward an informal security analysis
using the Dolev-Yao channel [25] and a formal security
analysis using the AVISPA and the BAN Logic.

A. Informal security analysis

We present an informal security analysis for the proposed
authentication mechanism employing the Doleve-Yao threat
model in this subsection. [25]. Table III provides a security
comparison for the proposed scheme with the other existing
schemes.
F1. Password guessing attack:

In this attack, adversary Ad performs ofﬂine and online
password assumptions and veriﬁes numerous passwords.
Ad uses a famous bruit force dictionary method to get
success in this attack. In our scheme, an Ad can not
achieve success in password guessing attacks due to hash-
ing of Hash(U ID||U P W ||Du). Even though adversary
may guess the correct U ID and U P W ; then also, he/she
will not receive value of Du. After guessing the correct
{U ID, U P W } pair, an adversary can not compute the
ﬁnal session key because of the unavailability of the
random parameter ns. As a result, the proposed scheme
is resistant to the password guessing attack.

F2. Message Replay attack:

the polynomial adversary Ad captures
In this attack,
communication between Ui and GW . These messages are
used for spooﬁng and impersonation type activities. We
use three random parameters that provide immunity from
the replay activities of the attacker. The ﬁrst parameter is a
timestamp (Tk), the second one is a random variable U Ri,
and the last parameter is random nonce Ni. With the help
of these parameters, the receiver can quickly validate the
freshness of received messages. As a result, the proposed
scheme is protected against the message replay attack.

F3. User anonymity:

If adversary Ad acquires the user’s identity, we can
state that the user anonymity attack is successful. In our
scheme, we use hash function to protect identity and pass-
word at user side (hi = Hash(U ID||U P W ||DecU P W ))

TABLE II
Proposed Scheme : Login and Authentication phases

6

User (Ui)
The Login & Authentication Phase:
Enters SC, provides U ID, U P W ,
Computes hi = Hash(U ID||U P W ||DecU P W (Z)),X ∗
?
Hash(U ID ⊕ hi), X ∗
= Xi,
i
Computes T = Oi ⊕ hi, Li = Hash(D||U ID),
Computes P ID = T ⊕ Hash(U ID||Li||Tk), Z = EncKu (D),
{P ID,Tki,M ID,Z}
−−−−−−−−−−−−−−→

i =

?
≤ T ∗

knew

− Tknew ,

knew

, Veriﬁes ∆Tnew

Gets T ∗
Computes ngw = DecKu (N S)
Computes S∗
i = Hash(S∗
Computes SQ∗
?
Veriﬁes SQ∗
= SQi,
i
Session key is Sk = S∗
k

k = Hash(U ID||T ||ngw ∗ Du),

k ||ngw||T ||Tknew ),

Gateway (GW)

Gets current time T ∗
k

?
≤ T ∗

k - Tk,DecKgw (MID),DecKgw (Z)

Veriﬁes ∆T
Computes Ni = Hash(Du||U ID),T =
Hash(GW Rj ||Kgw),P ID∗ = T ⊕ Hash(U ID||Ni||Tk),
Veriﬁes P ID∗ ?
Computes NS = EncKgw (ngw), Sk =
Hash(U ID||T ||ngw ∗ Du), SQi =
Hash(Sk||ngw||T ||Tknew )
N S,SQi,Tknew
←−−−−−−−−−−−

= P ID, Generates ngw ∈ Z∗
p ,

as well as at gateway side, we validate inside hash
computations. Thus, neither entity shares U ID over an
insecure channel in the proposed scheme.

F4. Perfect forward secrecy attack:

In this threat, the availability of a gateway secret key Kgw
does not lead an adversary towards successful session
key computations. The proposed scheme uses a random
number (ngw) at the gateway side for the session key
computation; thus, even though the adversary gets the
gateway secret key Kgw,
they do not succeed in the
previous session key as well as session key for future
communications.
F5. Stolen SC attack:

In the stolen SC attack, Ad receives SC and performs
power analysis to extract data. After extracting data, Ad
require password to receive Z. Thus, the extraction of SC
data does not provide the right direction to an adversary
for the session key computations. As a result, the proposed
scheme is resistant to stolen SC threats.

F6. Privileged insider attack:

In this attack, Ad is an insider to the gateway device
and can see the received messages. We do not relieve
U ID anywhere in the plaintext during computation in
the proposed scheme. After receiving P ID from the user,
the gateway performs veriﬁcation for the P ID∗ = P ID,
and it is secured using hash. Thus, Ad at the gateway
device neither receive identity nor password. For key
computation, Ad needs {U ID,T ,Du} and it is near to
impossible for an Ad to re-frame the same pair. As a
result, the proposed scheme is impervious to privileged
insider attacks.

F7. Mutual authentication:

The proposed scheme achieves mutual authentication. The
gateway GW calculates P ID∗ and validate it with the
P ID∗. The GW also validates ID and PW of the Ui.

?= Qi. The Qi
The Ui authenticates GW by verifying Q∗
i
is calculated with the help of received key. As a result,
we may assert that the suggested system meets the mutual
authentication property.

F8. Man-In-The-Middle (MITM) attack:

In this attack, Ad receives messages communicated be-
tween the Ui and the GW . In proposed scheme, even
Ad receives {P ID, M ID, Z} then also he/she will not
get success in order to read inside data due to hashing
and ECC encryption. Using {N S (Computed parameter
using ngw) , SQi}, Ad could not calculate the Sk because
of inadequate information about {ngw, U ID, D}. As a
result, the suggested technique is protected against an
MITM attack.

F9. User impersonation attack:

To impersonate as a legitimate user, an adversary Ad
captures SC parameters such as {Oi, Si, Ai, Z}. Using
these parameters, an Ad can not generate correct login re-
quests {P ID, Tki, M ID, Z}. As a result, an adversary’s
imitation attempts are unsuccessful. Hence, the proposed
scheme is secured against the user impersonation attacks.

F10. Gateway impersonation attack:

To impersonate as a legitimate gateway, an adversary Ad
captures the public message and public parameters such
as the gateway device. Using these parameters, an Ad can
not generate correct reply Mnew = {SQi, N S, Tknew } for
the user due to inadequacy of parameter Kgw. Thus, an
adversary does not get success in user impersonations.
Similarly, an adversary Ad can not decrypt the message
M ID and Z due to the nonavailability of gateway master
secrets. As a result, the proposed scheme is unlikely to
be affected by a gateway impersonation attack.

F11. Denial of service attack:

Using this attack, the polynomial adversary Ad tries to

7

F1
F2
F3
F4
F5
F6
F7
F8
F9
F10
F11

Security Parameter
Ofﬂine Password guessing
Replay
User anonymity
Perfect forward secrecy
Stolen smart card
Privilege insider
Mutual authentication
Man-in-the-Middle
User impersonation
Gateway impersonation
Denial of Service

TABLE III
Security comparison

[12]
×
(cid:88)
(cid:88)
(cid:88)
×
(cid:88)
(cid:88)
×
×
(cid:88)
(cid:88)

[28]
×
(cid:88)
(cid:88)
(cid:88)
×
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

[29]
(cid:88)
×
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

[30]
(cid:88)
×
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
×
×
(cid:88)

[31]
×
(cid:88)
×
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
×
×
(cid:88)

Proposed
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

stop Ui and GW from key generation through either
ﬂooding or any other means. An adversary Ad gives rise
to redundant requests for either device and generates too
much delay in the key generation process. In the real-
time scenario, it is nearly impossible to achieve full proof
protection against DoS-based attacks; still, we tried to
protect our scheme using the time-stamp and random
numbers. As a result, it prevents an attacker Ad from
gaining complete control of the system.

Goal
No.

1

2

F. Goals

TABLE IV
Goals

Goal

Sk←→ GW

User Ui |≡ C
Gateway GW |≡ S

Sk←→ Ui

B. Mutual authentication using BAN logic

In this subsection, we show that our scheme achieves mutual
authentication property using this BAN logic tool. The BAN
logic generates trust between the principles (communicating
parties). It focuses on the proposed scheme’s coherence and
feasibility. It works on proper formulations of postulates,
inference rules, and assumptions with realistic goals.

C. Postulates

Figure 2 shows basic postulates used by the BAN Logic. Over
here P and Q are the communicating principals, M1 and M2
are the communicated messages. The key KS is used for the
encryption/decryption operations and ks is the shared secret.

D. Inference rules

Inference rules are derivations that are derived from postulates
by the BAN logic. The inference rules prove that the proposed
authentication scheme satisﬁes the mutual authentication fol-
lowing. Figure 3 shows basic inference rules generated for
mutual authentication proof.

E. Assumptions

BAN Logic works based on the following assumptions:

• There are some shared secrets.
• Principals can compute fresh nonces.
• Each principals believes on each other.
• Each principal can recognize his/her messages.
• If principal P believes that KS is his public key, then P

must know corresponding private key KS−1.

For any U-GW model, the followings are the primary goals or
conclusions those must be achieved during the authentication.
Hence, using above said inference rules, assumptions and
postulates, both user (Ui) and the gateway (GW ) have to
achieve following goals:

Theorem 1. The proposed satisﬁes mutual authentication
property among Ui and GW .

Proof. We rewrite the messages communicated in login and
authentication phase of the proposed scheme in the generic
form as below:

MS 1: Ui → GW : (Enc(ID), Hash(Si||Kgw)⊕
Hash(D||U P W ||U ID) ⊕ Hash(D||U ID||U P W ) ⊕
Hash(U ID ||Hash(D||U ID) ||Tki),Enc(D), T si)

MS 2: GW → Ui: (Enc(ngw),

Hash(Hash(U ID ||Hash(GW Rj||Kgw) ||ns ∗ D)
||Hash(GW Rj||Kgw) ||Tknew ), Tknew )
Idealized form: We can rephrase MS1 and MS2 in idealized
form as follows:

MS 1: Ui → GW : (cid:104)< (ID), (Si||Kgw),

(D||U P W ||U ID), (D||U ID||U P W ) , (U ID ||
Hash(D||U ID) ||Tki),(D), T si >(cid:105)

D,Si←−−→GW

Ui

MS 2: GW → Ui: (cid:104)< (ngw), ((U ID ||(GW Rj||Kgw) ||ns∗

D) ||(GW Rj||Kgw) ||Tknew ), Tknew >(cid:105)
Goal: We deﬁne goals of the proposed scheme in idealized
form as follow:

D,Si←−−→GW

Ui

GL1: GW |≡ Ui
GL1: Ui |≡ Ui

Sk←→ GW

Sk←→ GW

Following assumptions are used to prove the mutual authenti-
cation:

Y1. Ui |≡ #(Tki)
Y2. GW |≡ #(Tki)
Y3. Ui |≡ #(Tknew )
Y4. GW |≡ #(Tknew )
Y5. Ui |≡ (Ui

Si,D
←−−→ GW )

8

Figure 2. Postulates

Figure 3. Inference Rules

Si,D
←−−→ GW )

Sk←→ GW )

Y6. GW |≡ (Ui
Y7. Ui |≡ GW |∼ (Ui
Y8. GW |≡ #(ngw)
Y9. Ui |≡ #(ngw)

Mutual authentication among Ui and GW is achieved as given
below:

W1: From MS 1,
GW (cid:47) (cid:104)< (ID), (Si||Kgw), (D||U P W ||U ID),
(D||U ID||U P W ) , (U ID ||Hash(D||U ID) ||Tki),
(D), T si >(cid:105)

D,Si←−−→GW

Ui

W2: Using W1, Z1 and Y6, we obtain,
GW |≡ Ui

|∼ (cid:104)< (ID), (Si||Kgw), (D||U P W ||U ID),
(D||U ID||U P W ) , (U ID ||Hash(D||U ID) ||Tki),(D), T si
>(cid:105)

W3: Using W2, Y2, Z2, we gain,
GW |≡ Ui ⇒ (cid:104)< (ID), (Si||Kgw), (D||U P W ||U ID),
(D||U ID||U P W ) , (U ID ||Hash(D||U ID) ||Tki),(D), T si

>(cid:105)

W4: Using Z7, Z3, we get,
GW |≡ #() (cid:104)< (ID), (Si||Kgw), (D||U P W ||U ID),

(D||U ID||U P W ) , (U ID ||Hash(D||U ID) ||Tki),(D), T si
>(cid:105)

W5: Using W3,W4, Z8, we achieve,
GW |≡ Ui ⇒ (Si||Kgw), (D||U P W ||U ID),
(D||U ID||U P W ) , (U ID ||Hash(D||U ID) ||Tki)

W6: Using W1, W4, Z2, Y8, we obtain,
GW |≡ GW Sk←→ Ui [Goal 1]
W7: From message 2, we receive,
Ui(cid:47) (cid:104)< (ngw), ((U ID ||(GW Rj||Kgw) ||ns ∗ D)

||(GW Rj||Kgw) ||Tknew ), Tknew >(cid:105)

D,Si←−−→GW

Ui

W8: Using W7, Z1 and Y6, we receive,
Ui |≡ GW |∼ (cid:104)< (ngw), ((U ID ||(GW Rj||Kgw) ||ns ∗ D)

||(GW Rj||Kgw) ||Tknew ), Tknew >(cid:105)
W9: Using W8, Y2, Z2, we obtain,

9

Figure 4. AVISPA Simulation Flow

Ui |≡ GW ⇒ (cid:104)< (ngw), ((U ID ||(GW Rj||Kgw) ||ns ∗ D)

||(GW Rj||Kgw) ||Tknew ), Tknew >(cid:105)
W10: Using W9, Z7,Z3, we get,
Ui |≡ #() (cid:104)< (ngw), ((U ID ||(GW Rj||Kgw) ||ns ∗ D)

||(GW Rj||Kgw) ||Tknew ), Tknew >(cid:105)

W11: Using W10, W9, Z8, we achieve,
Ui |≡ GW ⇒ (cid:104)< ((U ID ||(GW Rj||Kgw) ||ns ∗ D) >(cid:105)
W12: Using W8, W9, Z2, Y8, we receive,
Ui |≡ Ui
Thus, Goal 1 and Goal 2 derives that proposed work satis-

Sk←→ GW [Goal 2]

ﬁes mutual authentication among communicating entities.

V. FORMAL SECURITY SIMULATION USING AVISPA
Formal security protocol simulation provides strong proto-
col veriﬁcation against cryptographic and networking attacks.
AVISPA is widely adopted formal security analysis tool.
AVISPA is a one-button tool
that veriﬁes the security of
protocol against attacks such as replay and MITM attacks. We
utilized AVISPA for further security analysis of our protocol.
Because of its unique simulation environment, performing
simulation in AVISPA is a tremendous challenge. Figure 4
shows ﬂow if AVISPA simulation.
AVISPA conducts its simulations in a difﬁcult-to-read lan-
guage called High-Level Protocol Speciﬁcation Language
(HLPSL), which is less opaque. HLPSL is a role-based lan-
guage for describing proposed protocol and intruder behaviors.
As a result, each proposed protocol in AVISPA must be rebuilt
in HLPSL. In HLPSL, roles represent principals, sessions, and
the environment. There are three types of roles in HLPSL:

• Basic Role: The execution behaviour of the principals
is deﬁned with the help of this role. In our protocol, we
have two essential roles called as IoT user and application
gateway.

• Composed Role: Session modelling of fundamental role

events are presented using this role.

• Environment Role: Effective principles and sessions that
must be considered during implementation are deﬁned by
this role. The starting point is considered as a highest role
for simulation execution.

The HLPSL protocol is translated into Intermediate Format
(IF) using the HLPSL2IF translator. We are using Delev-
Yao medium that works based on two fundamental operations
called as SND and RCV. This is the only medium supported by
AVISPA, for communication simulation. We ran a simulation
for the proposed protocol’s three phases (registration phase,
login phase, and key generation phase).

Figure 5. AVISPA OFMC tool Output

Figure 6. AVISPA Simulation Output

The AVISPA tool comprises four sub-tools that function
as the back-end to IF, as indicated in Figure 4. To obtain
Output Format (OF), the Protocol transformed in IF is injected
into these tools.
the Tree Automata based on Automatic
Approximation for the Analysis of Security Protocol tool, the
SAT-Based Model Tracker tool, The On-the-Fly Model (OFM)
Checker tool, and the Constraint Logic-based Model Checker
tool are four major back end tools utilized for computing OF,
which states whether or not the proposed protocol is secure
against said attacks.

The simulation of the proposed protocol using the famed
OFMC tool can be seen in the Figure 5. We utilized two
back-end tools (OFMC and CL-AtSe) to simulate the pro-
posed protocol. Due to their inability to simulate bitwise
XOR operations, SATMC and TA4SP cannot simulate the
proposed protocol, hence whatever results these tools provide
are inconclusive.

The protocol tested 25 states during simulation using the
CL-AtSe tool, of which 21 were attainable, as shown in Figure
6. While an OFMC simulation revealed that the simulation
visited 476 nodes up to a depth of 27 heaps in 0.21 seconds.
The protocol is secure against a replay attack and a Man-in-
the-Middle attack, according to simulations employing both
tools.

VI. PERFORMANCE ANALYSIS

In this section, we evaluate the developed protocol’s perfor-
mance in terms of computing and communication overhead.
The computation cost analyzes the proposed protocol in terms
of the utilization of cryptographic operation. The communi-

Developer Language [Algorithms] High Level Protocol Specification Language Translator IF OFMC CL-AtSe SATMC TA4SP Output TABLE V
Comparison of Computation Cost

Scheme
[12]
[28]
[29]
[30]
[31]
Proposed

Computation Cost
6TP m + 1TP a + 10Th ≈ 13.4078
6TP m + 2TSyn + 11Th ≈ 13.3905
5TP m + 3TSyn + 13Th ≈ 13.4767
6TP m + 4TSyn + 11Th ≈ 13.3997
13Th + 4TP m ≈ 8.9339 ms
2TP m + 5TSyn + 11Th ≈ 4.5003

TABLE VI
Comparison of Communication Cost

Scheme
[12]
[28]
[29]
[30]
[31]
Proposed

No of Message
2
2
2
2
3
2

Comm. cost
1184 bits
1184 bits
1600 bits
1952 bits
1280 bits
992 bits

cation cost analyzes protocol regarding the number of ”bits”
transmitted by each participating party.

A. Computation cost analysis

The computation cost deﬁnes the total time consumed by the
scheme for session key generation. In the proposed scheme, we
uses different functions/methods for session key generation.
Let us deﬁne this functions as, Th, TP a, TP m, and TSyn. That
is time complexity for the hash computation, elliptic curve
point addition operation, elliptic curve scalar multiplication
operation and symmetric encryption and decryption operation
respectively. We extracted the individual time required for
each these functions. That was 0.0024 ms, 0.029 ms, 2.227
ms, 0.0047 ms for Th, TP a, TP m, TSyn respectively. Table V
shows comparative analysis for the computation cost between
the proposed scheme and other existing schemes and proves
computational efﬁciency of the proposed scheme.

B. Communication cost analysis

The communication cost shows the total number of bits
transmitted before establishing the key over a channel for
authentication. We computed the size of individual parameters
(in bits) for communication cost computations. The size of the
user identity is 160 bits; the output of the hash operation is
160 bits, the size of the randomly generated nonce is 128 bits,
and the size of the time-stamp is 32 bits. We use ECC in the
proposed protocol. Each point in the elliptic curve is built up
using two coordinates, each with 160 bits; hence, the total
size of the point (Xp, Yp) is 320 bits. The public key size
(U P W ∗ P ) is 320, and the private key (U P W ) size is 160
bits as per ECC computations. Table VI presents a analogous
analysis of the communication costs for our protocol with
other available protocols for the similar environment.

VII. IMPLEMENTATION

For implementation, we used two types of user devices and
two types of gateway devices. We used ﬁve nodeMCU and ﬁve
Raspberry-Pis as light-weight user devices and two laptops as
resource-capable user devices. As a resource-capable gateway

10

Figure 7. Computed Session key

device, we used a laptop with a conﬁguration of 8 GB RAM,
Intel (R) Core (TM)i7-5500U CPU, 2.40 GHz, 64 bit, Ubuntu
16.04 operating system. As a lightweight gateway device,
we used Raspberry Pi 3 Model B with Quad Core 1.2GHz
Broadcom BCM2837 64bit CPU, 1GB RAM with BCM43438
wireless LAN, and Bluetooth Low Energy (BLE) on board. As
a programming language, we used python 3. We used publish-
subscribe-based MQTT Protocol as a communication protocol
at the application layer, which uses TCP at the transport layer
protocol and 6LoWPaN at the network layer.

We implemented all basic elliptic curve operations in python
language by connecting Raspberry Pi as a gateway device and
the desktop system as a user device.

A. Computed session key

Following Figure 7. shows computed session key using pro-
posed work:

B. Networking parameters

We computed individual networking parameters, such as round
trip delay, packet loss, and throughput. Implementing the pro-
posed scheme using ECC operations and the MQTT protocol
reduces the round trip delay, increases throughput, and reduces
packet loss for the proposed scheme. We used the widely
adopted packet snifﬁng and packet analyzing tool ”Wireshark”
to compute the aforementioned parameters. The Wireshark
captures MQTT packets and provides all essential networking
parameters in an unstructured format; thus, we used python
programming to retrieve data more structured way. We inter-
pret these parameters using an automated python script that
reads Wireshark data and evokes the required information.

VIII. CONCLUSION AND FUTURE WORK

For the U-GW-based generic IoT paradigm, this article devel-
oped a unique, reliable, and lightweight SC-based remote user
authentication technique. For the discrete logarithm operations,
we employed ECC. We performed an informal security study
utilising the Dolev-Yao channel and a formal security analysis
using the widely used BAN Logic and AVISPA tools for
the proposed method. We show that the suggested scheme
is very efﬁcient and reliable in terms of communication
loss, and
cost, computation cost, end-to-end delay, packet
throughput for the U-GW system model by comparing it to
other current methods. We utilised the Raspberry Pi and the
MQTT protocol for implementation. We’re also working on
to overcome the restrictions of two-
a multi-factor model
factor authentications and also on U-GW-sensor model with

11

[22] H. Xiong, J. Tao, and C. Yuan, “Enabling telecare medical information
systems with strong authentication and anonymity,” IEEE Access, vol. 5,
pp. 5648–5661, 2017.

[23] A. Chaturvedi, D. Mishra, and S. Mukhopadhyay, “An enhanced dy-
namic id-based authentication scheme for telecare medical information
systems,” Journal of King Saud University-Computer and Information
Sciences, vol. 29, no. 1, pp. 54–62, 2017.

[24] W. Li, L. Xuelian, J. Gao, and H. Y. Wang, “Design of secure authen-
ticated key management protocol for cloud computing environments,”
IEEE Transactions on Dependable and Secure Computing, 2019.
[25] D. Dolev and A. Yao, “On the security of public key protocols,” IEEE
Transactions on information theory, vol. 29, no. 2, pp. 198–208, 1983.
[26] T. Messerges and E. Dabbish, “&amp; sloan, rh (2002). examining
smart card security under the threat of power analysis attacks,” IEEE
Transactions on Computers, vol. 51, no. 5.

[27] P. Kocher, J. Jaffe, and B. Jun, “Differential power analysis,” in Annual
international cryptology conference. Springer, 1999, pp. 388–397.
[28] L. Zhang and S. Zhu, “Robust ecc-based authenticated key agreement
scheme with privacy protection for telecare medicine information sys-
tems,” Journal of medical systems, vol. 39, no. 5, pp. 1–11, 2015.
[29] V. Odelu, A. K. Das, and A. Goswami, “A secure biometrics-based
multi-server authentication protocol using smart cards,” IEEE Transac-
tions on Information Forensics and Security, vol. 10, no. 9, pp. 1953–
1966, 2015.

[30] W. Liu, Q. Xie, S. Wang, and B. Hu, “An improved authenticated
key agreement protocol for telecare medicine information system,”
SpringerPlus, vol. 5, no. 1, pp. 1–16, 2016.

[31] S. Qiu, G. Xu, H. Ahmad, and L. Wang, “A robust mutual authentica-
tion scheme based on elliptic curve cryptography for telecare medical
information systems,” IEEE access, vol. 6, pp. 7452–7463, 2017.

lighter implementation using protocols like light-MQTT and
Bluetooth low energy as a future work for the proposed
scheme.

REFERENCES

[1] H. Farhangi, “The path of the smart grid,” IEEE power and energy

magazine, vol. 8, no. 1, pp. 18–28, 2009.

[2] R. Zafar, A. Mahmood, S. Razzaq, W. Ali, U. Naeem, and K. She-
hzad, “Prosumer based energy management and sharing in smart grid,”
Renewable and Sustainable Energy Reviews, vol. 82, pp. 1675–1684,
2018.

[3] A. Antonacci, F. Arduini, D. Moscone, G. Palleschi, and V. Scog-
namiglio, “Nanostructured (bio) sensors for smart agriculture,” TrAC
Trends in Analytical Chemistry, vol. 98, pp. 95–103, 2018.

[4] A. Whitmore, A. Agarwal, and L. Da Xu, “The internet of things—a
survey of topics and trends,” Information systems frontiers, vol. 17, no. 2,
pp. 261–274, 2015.

[5] F. A. Alaba, M. Othman, I. A. T. Hashem, and F. Alotaibi, “Internet of
things security: A survey,” Journal of Network and Computer Applica-
tions, vol. 88, pp. 10–28, 2017.

[6] M. Ammar, G. Russello, and B. Crispo, “Internet of things: A survey
on the security of iot frameworks,” Journal of Information Security and
Applications, vol. 38, pp. 8–27, 2018.

[7] R. Ch, G. Srivastava, T. R. Gadekallu, P. K. R. Maddikunta, and
S. Bhattacharya, “Security and privacy of uav data using blockchain
technology,” Journal of Information Security and Applications, vol. 55,
p. 102670, 2020.

[8] D. Hankerson, A. J. Menezes, and S. Vanstone, Guide to elliptic curve

cryptography. Springer Science & Business Media, 2006.

[9] L. Lamport, “Password authentication with insecure communication,”
Communications of the ACM, vol. 24, no. 11, pp. 770–772, 1981.
[10] C.-C. Chang and S.-J. Hwang, “Using smart cards to authenticate remote
passwords,” Computers & Mathematics with Applications, vol. 26, no. 7,
pp. 19–27, 1993.

[11] M. L. Das, “Two-factor user authentication in wireless sensor networks,”
IEEE transactions on wireless communications, vol. 8, no. 3, pp. 1086–
1090, 2009.

[12] S. H. Islam and M. K. Khan, “Cryptanalysis and improvement of authen-
tication and key agreement protocols for telecare medicine information
systems,” Journal of medical systems, vol. 38, no. 10, pp. 1–16, 2014.
[13] K. Xue, C. Ma, P. Hong, and R. Ding, “A temporal-credential-based
mutual authentication and key agreement scheme for wireless sensor
networks,” Journal of Network and Computer Applications, vol. 36,
no. 1, pp. 316–323, 2013.

[14] Q. Jiang, J. Ma, X. Lu, and Y. Tian, “An efﬁcient two-factor user
authentication scheme with unlinkability for wireless sensor networks,”
Peer-to-peer Networking and Applications, vol. 8, no. 6, pp. 1070–1081,
2015.

[15] R. Amin and G. Biswas, “A secure light weight scheme for user
authentication and key agreement in multi-gateway based wireless sensor
networks,” Ad Hoc Networks, vol. 36, pp. 58–80, 2016.

[16] F. Wu, L. Xu, S. Kumari, X. Li, J. Shen, K.-K. R. Choo, M. Wazid, and
A. K. Das, “An efﬁcient authentication and key agreement scheme for
multi-gateway wireless sensor networks in iot deployment,” Journal of
Network and Computer Applications, vol. 89, pp. 72–85, 2017.
[17] Y. Chen, J.-F. Mart´ınez, P. Castillejo, and L. L´opez, “A privacy protection
user authentication and key agreement scheme tailored for the internet
of things environment: Priauth,” Wireless Communications and Mobile
Computing, vol. 2017, 2017.

[18] C. Patel and N. Doshi, “Cryptanalysis of ecc-based key agreement
scheme for generic iot network model,” in 2019 10th International Con-
ference on Computing, Communication and Networking Technologies
(ICCCNT).

IEEE, 2019, pp. 1–7.

[19] C. Patel and N. prafulchandra Doshi, “Secure lightweight key exchange
using ecc for user-gateway paradigm,” IEEE Transactions on Computers,
2020.

[20] W. Wang, H. Xu, M. Alazab, T. R. Gadekallu, Z. Han, and C. Su,
“Blockchain-based reliable and efﬁcient certiﬁcateless signature for iiot
devices,” IEEE Transactions on Industrial Informatics, 2021.

[21] C. Iwendi, Z. Jalil, A. R. Javed, T. Reddy, R. Kaluri, G. Srivastava, and
O. Jo, “Keysplitwatermark: Zero watermarking algorithm for software
protection against cyber-attacks,” IEEE Access, vol. 8, pp. 72 650–
72 660, 2020.

