Noname manuscript No.
(will be inserted by the editor)

P 4QS: A Peer to Peer Privacy Preserving Query
Service for Location-Based Mobile Applications

Meysam Ghaﬀari · Nasser Ghadiri ·
Mohammad Hossein Manshaei · Mehran
Sadeghi Lahijani

Received: date / Accepted: date

Abstract The location-based services provide an interesting combination of
cyber and physical worlds. However, they can also threaten the users’ pri-
vacy. Existing privacy preserving protocols require trusted nodes, with serious
security and computational bottlenecks. In this paper, we propose a novel dis-
tributed anonymizing protocol based on peer-to-peer architecture. Each mobile
node is responsible for anonymizing a speciﬁc zone. The mobile nodes collab-
orate in anonymizing their queries, without the need not get access to any
information about each other. In the proposed protocol, each request will be
sent with a randomly chosen ticket. The encrypted response produced by the
server is sent to a particular mobile node (called broker node) over the network,
based on the hash value of this ticket. The user will query the broker to get the
response. All parts of the messages are encrypted except the ﬁelds required for
the anonymizer and the broker. This will secure the packet exchange over the
P2P network. The proposed protocol was implemented and tested successfully,
and the experimental results showed that it could be deployed eﬃciently to
achieve user privacy in location-based services.

Keywords LBS · Trusted Anonymizer Server · Peer-to-Peer Anonymizing.

1 Introduction

With the technological growth, especially in the Internet and communication
devices, available services are increasing. A new class of services that have
emerged with the development of the Internet and smartphones with location

Department of Electrical and Computer Engineering,
nology,
{nghadiri,manshaei}@cc.iut.ac.ir

Isfahan 84156-83111,

Isfahan University of Tech-
Iran. E-mail: {meysam.ghafari,m.sadeghi}@ec.iut.ac.ir

Corresponding Author: Nasser Ghadiri

6
1
0
2

n
u
J

8

]

R
C
.
s
c
[

1
v
3
7
3
2
0
.
6
0
6
1
:
v
i
X
r
a

 
 
 
 
 
 
2

Meysam Ghaﬀari et al.

sensors are location-based services (LBS). An LBS system provides one or
more location-dependent services customized for every user that connects to
the LBS provider and sends her location information to the server.

As LBS combines the cyber and physical worlds, it would be interesting for
users. Example applications are ﬁnding nearby places such as restaurants and
gas stations, or ﬁnding nearby friends through location-based friend ﬁnders,
such as Foursquare.

Although such services are attractive, they need access to physical informa-
tion about the real-world user’s life [1]. If the system fails to provide adequate
security mechanisms, it can be harmful to the users’ privacy. For example, an
intruder can infer the user’s behavior, habits, social activities, sickness and
other information just by knowing her location [2]. Therefore, the users’ se-
curity and privacy must be regarded as one of the most important issues in
LBS.

The privacy aspects of the location data have been extensively investigated.
Most researchers acknowledge the need to hide the users’ locations even from
the service providers [3]. With the development of storage devices and the
increased processing power of computers, the users could be easily identiﬁed
by tracking their movements and the locations that they pass through. Fur-
thermore, analyzing such trajectory data is possible [4], and most LBS users
are not comfortable with this issue. It can cause many threats to the users’
privacy. For example, users may be exposed to location advertisements, or
subject to prejudice by service providers, or physical harm and extortion [2].
So, many researchers have proposed diﬀerent methods such as spatial and tem-
poral cloaking [5][6], fake locations [7], the addition of noise [8], k -anonymity
[5], and similar methods to cope with this threat.

A well-known identity protection mechanism is k -anonymity [9]. The prin-
ciple operation of this method is as follows: The system will preserve the
privacy of a location-dependent query from a user if the probability of dis-
tinguishing the user’s query is less than 1
k . A trusted third-party anonymizer
is used to achieve this goal [10][5][9] [11] (see Fig. 1). The trusted server in-
teracts with users and manipulates their location data. Users will send their
queries to the anonymizer instead of sending them directly to the LBS server.
The anonymizer generates a cloaking region around the user in a way that the
user is indistinguishable from k -1 other users. Although this method seems to
be working, it has its shortcomings. A serious challenge is to ﬁnd a tradeoﬀ
between privacy, time and the quality of service.

A familiar privacy metric is based on the concept of anonymity, implying
that the user is indistinguishable from other users as members of an anonymity
set. Another privacy metric is unlinkability, which means the attacker cannot
distinguish whether two or more items of interest have a relationship between
them. In unlinkability approach, the information revealed by a sequence of
queries is considered important because of the computation and storage char-
acteristics. Most of the acquired information items are gained by analyzing the
sequence of queries [12]. We will employ these metrics to preserve anonymity
and unlinkability.

Title Suppressed Due to Excessive Length

3

As discussed above, most of the existing methods are just a trade-oﬀ be-
tween the quality of service and privacy. Some of them suﬀer from the risk of
revealing information in security bottlenecks, leading to sensitive information
about the users to be disclosed. While the unlinkability factor is crucial, it has
not been considered thoroughly in literature.

In this paper, a novel architecture named Peer to Peer Privacy Preserving
Query Service (P 4QS) is proposed for improving the users’ privacy in location-
based social networks. First, we use a distributed P2P architecture to acquire
the queries and deliver the results. Second, by using proper symmetric and
asymmetric encryption methods, each node would have access to the necessary
information only. Third, by exploiting the Distributed Hash Table (DHT) in
the proposed P2P architecture, the response is delivered to the client, but the
LBS could not identify him. The main contributions of this paper are threefold:

1. We propose a novel P2P model for anonymizing the location-dependent
queries. In this model, the nodes collaborate with each other to make the
queries K -anonymized. At the same time, the information contents of the
queries are protected.

2. The protocol has four advantages:

– It does not require any trusted nodes. There are few distributed meth-
ods for anonymization, but they need a few trusted nodes to achieve
anonymity.

– Unlike existing distributed methods, the nodes do not need to store any

information such as geographical maps.

– The system has no security, privacy or computational bottleneck. For
example in central trusted server, the server itself is the bottleneck of
the service.

– There is no additional or hidden costs for deploying the system. Unlike
existing methods that would be expensive to implement due to their
need for speciﬁc hardware and systems, the proposed method could be
easily implemented with no prerequisites.

3. We have implemented the P 4QS as a proof-of-concept prototype to evalu-

ate its feasibility. Full source code is made available for download1.

The rest of the paper is organized as follows: in Section 2, the related works
will be surveyed. In Section 3, the basic concepts and a high-level view of the
proposed model will be introduced. In Section 4, the proposed model and
protocol description will be explained and evaluated in detail. In Section 5,
both analytical and numerical evaluations of the protocol are illustrated by
using a set of common scenarios and experiments. Finally, Section 6 closes the
paper with the conclusion.

1 http://dkr.iut.ac.ir/content/codes-Peer-to-Peer-Privacy-Preserving-Query-Service

4

2 Related Works

Meysam Ghaﬀari et al.

In this section, we give an overview of the current literature in location privacy
domain. The techniques are categorized to the pseudonym, perturbation, and
trusted server methods, as well as distributed architectures explained in the
following subsections.

2.1 Pseudonym

Using the real identity has the risk of revealing information about users. The
pseudonym method is proposed to address this problem. It uses a ﬁctitious
name instead of the user identiﬁer [13]. However, it has been proved that
by tracing the sequence of activities and queries, the identity of the user is
detectable. The mix zone method further develops this core approach, which
deﬁnes speciﬁc zones and allows the pseudonyms to change when the user
changes his region [14] [15]. By changing the pseudonym, the unlinkability
metric is satisﬁed whenever the user moves into another area.

2.2 Perturbation and Obfuscation

Another class of methods to achieve location privacy use perturbation and
obfuscation. Adding noise, spatial cloaking, and fake location methods fall
into this category.

The noise addition method interleaves noisy queries between the user queries
to hide the original query. A problem with this approach is the high compu-
tational overhead on the server to process all queries [8]. The fake location
method improves this approach by sending fake queries. Besides the real path
of the user and his queries, a false path of queries will be generated and sent
to hide the actual path of the user. However, the adversary could distinguish
the authentic and fake paths by using background knowledge, map matching,
or other methods such as using spatiotemporal density estimation and line
intersections[8][16].

Spatial cloaking is a general method based on concealing the user queries
by adding cloaks to achieve the k -anonymity. In this way, the user will become
indistinguishable from k -1 other users. In the primary method, a constant
cloaking range is added to user queries. This method is optimized by proposing
the trusted anonymizer server as explained in the following subsection.

2.3 Trusted Server

The methods above such as spatial cloaking, fake location, and noise addition
put signiﬁcant computational overhead on the server or imply the loss of qual-
ity. To overcome this problem, the use of trusted anonymizer server became
popular, making a balance between privacy and the quality loss. The general

Title Suppressed Due to Excessive Length

5

Fig. 1: Central Trusted Server architecture. In this architecture, all nodes
send their requests to one trusted server. This server makes the queries K-
anonymized and sends them to the LBS.

architecture of the trusted server is shown in Fig. 1. The basic idea is that each
node sends its query to the trusted server. The trusted server accumulates the
queries and anonymizes them by adding spatial and temporal cloaking in a
way that at least k diﬀerent queries become indistinguishable.

The trusted server architecture was ﬁrst proposed by Gruteser and Grun-
wald [5]. It provides k -anonymity for protecting privacy based on a trusted
anonymization server. They represent location information of the client by
three tuples ((x1, y1), (x2, y2), (t1, t2)). Tuples one and two show the area and
the third tuple indicates the period of client queries. Based on this structure,
they design a cloaking algorithm that generates spatiotemporal cloaking. The
cloaked region contains, at least, k clients and their location information are
sent to the location-based server indistinguishably. The parameter k is the
minimum acceptable anonymity. In this method, it is very tough to provide a
ﬂexible privacy protection scheme, because of its pre-deﬁned constant value k.
Moreover, in the case of small areas, k -anonymity is very hard to achieve.

Signiﬁcant eﬀorts have been made to overcome these drawbacks and some
novel methods are proposed, including CliqueCloak [10]. CliqueCloak is a per-
sonalized anonymity method by which clients can tune their personal privacy
protection requirements as well as their spatiotemporal cloaking levels. This
personal level is achieved by modeling the anonymization constraints to ﬁnd
the best satisfaction conditions. Another framework proposed for customized
anonymity is Casper [11]. Casper has a proﬁle for each user’s privacy settings
to fulﬁll the requirements of every individual user. It consists of a value that
determines k for the minimum acceptable cloaking in k -anonymity. Casper

Location-Based Server (LBS)Users (mobile Clients)LBS requests(encrypted communication)Trusted Anonymizer Serverwhich performs spatial and temporal cloakingK-anonymized Queries will be sentAnd responses will be receivedLocation-Based Server (LBS)6

Meysam Ghaﬀari et al.

also uses an incomplete pyramid structure to keep the user information dy-
namically [17].

Another scheme based on trusted server is Cache Cloak [18]. This method
caches LBS responses to use them for subsequent queries. Thus, it decreases the
number of queries and the chance of adversary to infer from queries. Exploiting
this method can increase privacy without the loss of accuracy. However, this
system suﬀers from scalability problem. It cannot be used in a large scale
situation because it needs huge amounts of memory to save the queries and
responses. Moreover, in the worst case, if each client has diﬀerent types of
queries from diﬀerent location-based servers, the trusted server needs to cache
an enormous amount of information. Thus, it becomes the bottleneck of their
proposed system.

Schlegel et al. proposed dynamic grid system (DGS) which requires a semi-
trusted third party to preserve user privacy [19]. In this method, the user
could deﬁne her privacy level. In DGS diﬀerent privacy levels has not diﬀerent
communication costs for the user. However, this method also needs a central
server.

In all derivations of central trusted anonymizer server, the queries must
be sent to the central anonymizer. This limitation makes the anonymizer a
bottleneck for the system. If an intruder penetrates to the trusted server, he
could extract client’s information. It has been proved that using pseudonyms
or even spatial cloaking cannot solve this problem [20].

We propose a novel architecture based on distributed trusted server to
address the problems mentioned above. In our proposed protocol, even an in-
truder can attack, only a limited information would be revealed. The proposed
method relies on a peer-to-peer distributed architecture. Before presenting our
solution, we review some literature in this category.

Table 1: Functions of each peer in the system.

Party

PCi : Client Peer i

PAj :Anonymizing Peer

PBm : Broker Peer

Function
Sends a query and waits for the response. The system
must defend against correlation of queries and PCi .
Each user node determines a user’s chosen location
and is responsible for the anonymization of queries
in the zone nearby. If suﬃcient anonymization is not
achieved, this node cooperates with nearby PAj s.
Receives the response packet based on Hash(Ticket)
and waits for PCi to ask for his packet.
Then PBm sends the response packet to PCi .

Title Suppressed Due to Excessive Length

7

2.4 Mobile and Distributed Architectures

Central trusted servers had the potential of becoming the single point of fail-
ure, causing system failure. The central servers also have the risk of being
compromised or controlled by an intruder, making them not reliable. Thus,
deploying a secure trusted server that works smoothly in real-world situations
would be extremely hard to achieve. To solve this problem, mobile-based meth-
ods have been proposed. The advantage of the mobile-based method for the
users is that they could preserve privacy without relying on the central servers.
In this approach, several groups of mobile users collaborate with each other
to achieve the desired privacy.

CAP provides k -anonymity by maintaining road density using quadtree
followed by VHC mapping and perturbation [21]. VHC mapping is used to
project a two-dimensional geographic space into a one-dimensional space which
preserves the homogeneity of every point. The adjacent points will also remain
close to each other [22]. In this way CAP tries to reduce the storage and
computational overheads required for mobile-based methods of storing the
maps to achieve k -anonymity.

Hu and Xu proposed a method to generate cloaking boxes based on the

strength of receiving a signal from the nearby devices [23].

Chen proposed the LISA method. LISA is based on m-unobservability and
tries to prevent the attacker from attributing any particular location to the
user. LISA also predicts the user movements by exploiting Kalman Filter that
leads to increased privacy [24].

Our proposed protocol employs mobile-based methods that are used to
preserve anonymity and unlinkability. Unlike the methods mentioned above,
the privacy of user will be maintained without revealing and exchanging loca-
tion information. Users communicate with each other, but they cannot get any
information about other user’s location or queries. Unlinkability metric is also
satisﬁed by using ticket instead of user identiﬁcation number, the pseudonym,
or any other identiﬁer.

3 Proposed Model

The proposed method which is called Peer to Peer Privacy Preserving Query
Service (P 4QS) follows a role-based, peer-to-peer architecture. As it is shown
in Table 1, each node may have diﬀerent roles at any time to perform one or
more of three functionalities: (1) querying, (2) anonymizing queries, and (3)
brokering responses.

From an overall view, the system operates as follows. In the ﬁrst step, a
node needs to send its query. We call this node ”Client Peer ” because it needs
the service and plays the role of a client in a peer-to-peer architecture. We
designate clients by PCi, where C ∈ {1,2,...,N}. Each user is located in a zone
where she sends the query. We represent these zones by Zi, where i shows the
sum of latitude and longitude of the user.

8

Meysam Ghaﬀari et al.

The PCi’s query will be sent to another peer responsible for anonymizing
the speciﬁc zone which contains the query location. The anonymization is the
second functionality of each peer. In this role, the ”Anonymizing Peer ” gets
queries from diﬀerent clients corresponding to a speciﬁc zone for which this
Anonymizing Peer is in charge. We represent this peer by PAj . Note that there
exist N Anonymizing Peers, and each peer is responsible for the zone Zi, which
is represented by P Zi
A .

PAj anonymizes the queries from multiple PCis by adding appropriate spa-
tial and temporal cloaking to them to make them K-anonymized and sends
them to the LBS. The LBS processes the queries and sends each of them to
the speciﬁc peer responsible for that response. This peer, which is called Bro-
ker Peer, is represented by PBm, where B ∈ {1,...M}. The Broker Peer gets
the responses from the LBS and keeps them until the speciﬁc client asks its
response from the broker. The broker then sends the corresponding answer to
its owner, i.e., each PC asks the response from PBm and PBm sends back the
response to the PCi. The overall process is shown in Fig. 2.

Fig. 2: P 4QS Architecture: Anonymizing and sending a query to the dis-
tributed system and getting the response. 1(cid:13) Client Peer sends query qCA
which includes Location, Proposed key, Ticket and Query. The proposed key
is encrypted with the servers public key using RSA method. Ticket and query
are encrypted with the proposed key using AES encryption method. 2(cid:13), 3(cid:13)
The Anonymizing Peer adds spatial and temporal cloaking to the queries and
sends QAS set of K-anonymized queries to the LBS. 4(cid:13) The LBS sends the
encrypted (response) qSB with the clients proposed key to the appropriate
broker. 5(cid:13) The broker will be chosen based on the calculated Hash(Ticket). 6(cid:13)
The client interacts the broker and gets its response qBC.

Title Suppressed Due to Excessive Length

9

An essential point in the proposed architecture is that no central trusted
server is required. Thus, the risk of the single point of failure will be eliminated.
As shown in Algorithm 1, we ﬁrst choose the nearest PAj based on the nearest
neighbor of the query location (i.e., Line 3 in Algorithm 1). Achieving K-
anonymity needs K diﬀerent queries. So PAj needs to wait for queries from
other users, or it has to generate fake queries. There is a wait time loop (line
4) such that if PAj does not receive enough queries (line 5), it will collaborate
with the adjacent nodes or generate fake queries, as shown in line 6 of the
algorithm. Then K -anonymized queries are sent to the server. The server will
process the queries and send the encrypted response packet to PBm (i.e., line
11). PBm is chosen based on the Hash (Ticket), where the ticket is sent by
Client Peer in the ﬁrst step. Finally, PCi asks R from PBm and PBm sends it
to PCi.

So the overall P 4QS protocol procedure is as follows: PCi ﬁnds the ap-
propriate PAj and also ﬁnds PBm based on Hash(Ticket). Then PCi sends its
query to the PAj and request for the response of this query to the PBm . The
PAj accumulates and anonymizes the queries. If needed, PAj adds fake queries
to achieve the predeﬁned privacy threshold. Then it sends these anonymized
queries to the server. The server gets the queries, decrypts and processes each
query, and sends the response to the node PBm based on Hash(Ticket). After
receiving a response from server or a request for response from a client, PBm
matches the request and response and forwards the answer to the client. The
overall process was shown in Algorithm 1. The user’s query is in the form of:

Loc, E(prop − key)P ubserver , E(T icket, Query, P (cid:48)

Bm

sIP )prop−key

where Loc is the location of the user and the query is based on this place.

1. The random number which is generated by the LBS to determine PBm.
2. A validation time stamp which shows the expiry time of the ticket.
3. The server mark which is encrypted with the private key of the server.
Every user can decrypt it with the public key of the server to assure the
validity of the ticket, in the case of receiving a ticket from other peers.

prop-key is the user’s proposed key for the encryption of the response. This
key can be changed for each request. P ubserver is the server’s public key and
is known for all users.

To evaluate the eﬃciency of the proposed model, we use a set of common
challenging scenarios to assess this model from multiple aspects. These scenar-
ios have diﬀerent frequency of queries, time delay sensitivity, position accuracy
and the amount of revealed information per query. Consequently, each scenario
can evaluate the model from a diﬀerent aspects. The features of these scenarios
and their attributes are summarized in Table 2. We will explain the scenarios
and evaluate the model by them in the evaluation section.

4 Protocol description

The P 4QS is based on attaining two important goals: distributed anonymiz-
ing and avoid correlation between the sequences of queries (unlinkability). To

10

Meysam Ghaﬀari et al.

Algorithm 1 The Pseudo code of the P 4QS
1: Input:ClientQuery :

Encrypted with proposed key(Ticket, Query) and Encrypted with servers public
key(proposed key)

2: Output:Response of the query which will be delivered to Client with a distributed

hash table

Or
Collaborate with PAj ± 1 (Adjacent PAj ) or generate fake queries

3: PCi Sends Query to PAj
4: while Anonymity in PAj < K do
5: W ait f or new query
6:
7:
8: end while
9: PAj sends (K Anonymized Query) to the server
10: Server process queries
11: Server sends E(R)P roposedKey to PBm which PBm = Hash(T icket)
12: PCi Sends Query to PAj
13: PBm Sends R to PCi

Table 2: Proposed scenarios and their usages

Scenario

Main feature

Proﬁle Matching (PM): used
for ﬁnding similar proﬁles

Driving Condition Monitoring
(DCM):
in case of need to
monitor the road condition,
privacy of the users who sent
the data must be protected
Road Map (RM): used to ﬁnd
the path

Detecting User By Sequence
of Queries (DUSQ): can be
used to detect user and visited
places
Detecting User Speed in High-
way (DUSW): even without
detecting the user identity, de-
tecting over-speeding in high-
ways can jeopardize privacy

Accuracy is important
but sequence of queries
must not correlated
low sensitivity to the
position accuracy and
delay but sequence of
queries must be kept
uncorrelated
Sensitive to delay but
Position cloaking is tol-
erable
Revealing user’s iden-
tity
correlating
by
queries to user

inability to correlate
sequence of queries to
each other

Proven feature by
Scenario
preserving accuracy, si-
multaneously no corre-
lation between queries
correlation
between
queries in case of not
sensitivity to delay and
position accuracy

ability
to
against path tracking

protect

inability to associate
queries to user

detecting
between queries

correlation

achieve these goals, we proposed a distributed peer-to-peer architecture. In
the proposed system, each peer has three roles, as described in the previous
section, namely client, anonymizer, and broker roles.

In the ﬁrst step, each peer needs to send its query, but, unlike the previous
methods, the query will be forwarded to the relevant anonymizer peer. Each
peer in our system is responsible for anonymizing queries close to a particular
location. The anonymizer peer gets multiple queries from multiple client peers.
These queries have an important part in common, and that is their positions.

Title Suppressed Due to Excessive Length

11

These locations of queries are close to each other and PAj anonymizes them
and sends them to the LBS.

The structure of query is slightly diﬀerent from typical queries. The query
consists of the user’s location which is sent as plain text, the ticket, the query
text and the proposed key. The proposed key is encrypted with the public key
of the LBS and the ticket and the query encrypted with the proposed key. The
ticket is used as a control mechanism in our protocol and will be described
later in this section. The queries are encrypted with the user’s proposed key.
For peer-to-peer communications, we exploit a distributed hash table (DHT)
as described shortly. Then we will explain the proposed method and show how
it uses the DHT.

4.1 Distributed Hash Table (DHT)

Distributed hash table belongs to a class of decentralized systems for distribut-
ing tasks between peers. In this method, each peer is responsible for keeping
data and forwarding it to others. The DHT architectures provide three major
features: scalability, ﬂexibility, and immediate deployment. It could be used
eﬃciently in mobile nodes [25]. For ﬁnding a speciﬁc node in the DHT, diﬀer-
ent methods have been proposed. One of the best and most simple methods is
Chord. In Chord, each peer stores the addresses of n peers. The computational
complexity of the search operation is log(N ), where N is the number of all
peers in the distributed table [26]. As depicted in Fig. 3, if a peer has data
and wants to locate or save this data, it will calculate the hash of data. The
nearest peer to the extracted value is responsible for keeping or locating the
data. For example, in Fig. 3, peer X is responsible for data ”D” as its hashed
value is the closest to the hash of data. Most of the proposed DHT use SHA-1
hash function.

Fig. 3: DHT Search Space: each node is speciﬁed by an index number from 0
to 2n − 1. For ﬁnding a speciﬁc node, the user ﬁnds the closest node to the
Hash(data). In this case, there exist 10 active peers. The hash value of D is
equal to 2465. Hence, peer 2136 is responsible for it.

082502136298010800Data D with the hash value equal to 24654000430060001430012

Meysam Ghaﬀari et al.

4.2 Hashing Protocol

One of the advantages of DHTs is that the user could specify the appropriate
hash function. In the proposed system, the protocol uses geographical data for
this purpose, which consists of latitude and longitude. A straightforward and
eﬃcient method for using these two-dimensional data is to map it into a new
one-dimensional space. For this purpose, we deﬁne our hashing function by,

H = X + Y,

(1)

where X and Y are the longitude and latitude values of the determined location
of PCi and H is the hash value used in DHT for ﬁnding a particular peer. Using
this function, we can simply ﬁnd the best anonymizer peer for each location.
Adjacent geographical anonymizer peers (peers whose RAs are close to each
other) are located beside each other in the DHT, so they can easily cooperate
with each other to achieve the best anonymization by optimum spatial and
temporal cloaking.

The proposed function has one weakness in the ﬁrst glance: the symmetric

points will be matched to one point in the new space, as shown in Fig. 4.

Fig. 4: The symmetric points. If some nodes locate in each of these symmetric
locations, they will be assigned to one anonymizer based on the sum of their
latitude and longitude.

This problem could be addressed by assigning two symmetric zones to
each anonymizer. Thus, each anonymizer is responsible for both regions. Af-
ter receiving the queries, the anonymizer separates them based on a deﬁned
threshold and anonymizes each zone separately.

4.3 Ticket

A key architectural element in our proposed method builds on the concept of
the ticket. It will be used for running the P 4QS protocol by diﬀerent peers.
Unlike pseudonym-based methods, exchanging the ticket does not need any

X:LongitudeY: LatitudeA1A2A3B1B2B3Title Suppressed Due to Excessive Length

13

computation or authentication. Therefore, it could be easily implemented and
quickly used. Moreover, analyzing linkability between queries is impossible.
The usage of the ticket is described in this subsection.

When the location-based server processes the query and produces the re-
sponse, it needs to send it back to the client. The aim of our protocol is to make
the client completely anonymous and eliminate the linkability of the queries
to other queries or users. An identiﬁer is needed to identify the owner of each
query and simultaneously change it abruptly with the minimum computation
cost. For this purpose, we propose using a unique ticket for each query. By this
method, the owner of the query is unknown to the LBS and the only available
information is the ticket, which is unique for each query. Thus, analyzing a
sequence of queries becomes impossible.

The server(LBS) sends the response based on the ticket. A simple method
for the LBS is extracting the hash of the ticket and sending the response to
the appropriate peer. The peer with the closest hash to the hash of the ticket,
which is called Broker Peer, is responsible for receiving the response from the
server (LBS). In this case, the same hash function could be used in this step
as well, and there is no need to deﬁne a new distributed hash table.

The Client Peer knows the ticket and thus, it can calculate the hash of the

ticket and ﬁnd out the appropriate Broker Peer to ask for the response.

4.4 Protocol Execution

The P 4QS protocol executes in two phases: initialization and execution. In
the initialization phase, the peers introduce themselves to the system. In the
initialization process, each peer runs a server thread and listens to a particular
port. Then it chooses myRA, which is a random number used for determining
the anonymizer and the broker.

After receiving the response to the join request, the client is ready to per-
form all his functions as PCi , PAj and PBm . The pseudo codes for these
functions are shown in Algorithm 2, Algorithm 3, and Algorithm 4, respec-
tively.

Algorithm 2 Pseudo code of PCi (Client Peer )
1: Get the Location
2: Choose myRA
3: Calculate Hash = X + Y of the Location
4: Choose one of the tickets and retrieve its Hash bydecrypting the ticket with Servers

public key

5: F ind Anonymizer
6: F ind Broker (Based on ticket)
7: Send Query : Loc, E(P ropKey)P ubServer , E(T icket, query, Broker(cid:48)sIP address)P ropKey

8: Send ”Request − F or − Answer” message to Broker

14

Meysam Ghaﬀari et al.

As shown in Algorithm 2, PCi ﬁnds the appropriate anonymizer based on
Hash(location) and sends the query to it. Also, the broker is chosen based on
the Hash(T icket). So, by changing the users’ location, the anonymizer peer
will be changed. Moreover, each response is sent to a broker. Thus, compromis-
ing a client (a broker peer) by the server will not reveal signiﬁcant information
about a speciﬁc user.

P ut query in ReceivedQueries list

end if
W ait T second f or new queries
if af ter T second Queries < K then

Algorithm 3 The Pseudo code of PAj (Anonymizing Peer )
1: while Anonymizer Peer is Active do
while Anonymity in PAj < K do
2:
3:
if N ew Query Recieved then
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15: end while

end if
end while
PAj sends (K Anonymized Queries) to the server
Empty Query List

Collaborate with PAj ± 1 (Adjacent PAj )
OR
Generate F ake Query(ies)

Algorithm 3 shows the function of the anonymizer peer. In this procedure,
the anonymizer is always waiting for new queries. In lines 3 and 4, after a
new query is received, the anonymizer puts it in the query list. Lines 6-11
indicate that the anonymizer waits for T seconds to gather K queries. If the
number of received queries is less than K, she can collaborate with the adjacent
anonymizers or create some queries herself. Then, the anonymizer adds spatial
cloaking to the K queries to make them indistinguishable. Since the ticket
information is encrypted by the public key of the LBS, the anonymizer has
no access to the sensitive information of the user, so she just could anonymize
the user location. Thus even in case of having a malicious or semi-honest
anonymizer she just has access to the user location in a speciﬁc zone. As
soon as the user moves to an adjacent zone, she will be assigned to another
anonymizer so the anonymizer could not analyze the user path.

Functioning as a broker peer, the client saves requests for the answers
received from other clients and the responses received from the LBS in two
separate lists. As soon as a new request for answer or response is received, it
checks the list and if it ﬁnds a match, it will forward the response to the PCi
and remove both request and response from the lists (as shown in Algorithm 4).
As described in Section 4.3, the system uses tickets to deliver responses to
the owner. Although using multiple pseudonyms is an ideal method to achieve
privacy, it has the risk of the (Denial of Service) DoS attack, leading to system
breakdown [27]. The P 4QS is similar to multiple pseudonyms method, but
it does not require the pseudonym changing process, eliminating the need

Title Suppressed Due to Excessive Length

15

Algorithm 4 The Pseudo code of PBm (Broker Peer )
1: while Broker Peer is Active do
2: W ait f or new message
3:
4:
5:

if N ew Response(Request f or Response) Received then

if T here is a M atch f or it in Request List(Response List) then

Remove the M atched Request (Response) f rom the Request List (Response
List)

end if

else

6:
7:
8:
9:
10: end while

end if

P U T the Request (Response) in the Request List (Response List)

for time and computational process. The P 4QS could be vulnerable to DoS
attacks especially because, unlike multiple pseudonyms methods, it does not
have any authentication. So, the proposed method is ideal for privacy, because
it uses tickets that work like a pseudonym for each query. However, the protocol
needs to be protected against DoS attacks. To solve this problem, we propose
a ticket exchange protocol.

If an intruder wants to make a DoS attack on the system, he will need
to send plenty of valid queries. We prevent such attacks by limiting the al-
lowed number of queries of each user. To achieve this goal, we propose a ticket
exchange protocol. In this protocol, the location-based server generates a col-
lection of tickets and sends a speciﬁc number of tickets to each authorized
user of the system in predeﬁned time periods; for example, in an hourly man-
ner. The client uses one of these tickets for each query. Thus, the DoS attack
becomes preventable. However, this ticket exchange approach has two issues:
using randomly generated tickets by the attacker and tracking the users by
knowing the owner of the tickets. To solve these problems, we further improve
the ticket exchange protocol.
Ticket Generation:
The server will generate a pre-deﬁned number of tickets and send them
to the users in a speciﬁc time periods. The structure of ticket sent by the
LBS is E(T oken, Identif ier, V alidT ime)P rivServer , which means the ticket is
an encrypted package including a random token, an identiﬁer and the valid
time of the ticket. This package is encrypted with the private key of the LBS.
So each entity in the system can decrypt it with the public key of the LBS
and check the identiﬁer to control the validity of the package. This mechanism
has two important roles in the system. First, the attacker could not generate
random tickets and the LBS checks the identiﬁer. Before processing the query,
the LBS checks the validity of the ticket number and thus, the chance of the
intruder will be lowered signiﬁcantly. The second and more important role
of this identiﬁer is that in the P 4QS, users exchange some of their tickets
with each other in deﬁned time intervals frequently. The tickets are chosen
randomly for exchange and each user exchanges tickets just with the adjacent
peers. The user checks the identiﬁer after getting each ticket and thus, she can
validate the tickets. If any user gets any invalid tickets, she drops them. If the

16

Meysam Ghaﬀari et al.

invalid tickets exceed a predeﬁned threshold, she will consider the sender as
untrusted, so generating and distributing fake tickets will be prevented.

After a few exchanges, the tickets will be circulated across the network of
the users, and the LBS may not be able to determine the owner of any query.
Thus, we prevent DoS attack and provide the ideal privacy. The pseudo code
for the ticket exchange protocol is shown with Algorithm 5. In this algorithm,
PCti

is a list of trusted peers for peer PCi and PCtk

is a peer in this list.

Algorithm 5 Ticket Exchange Protocol

PCi exchange E of its randomly selected T ickets with otherPCj
Check the validity of each received ticket
if Received ticket is invalid then

1: Ticket: (token, verif ier, T imeStamp)privateserver
2: Server sends ticket batch to each authenticated user in specif ic time periods
3: while not achieved ideally exchanged tickets do
4:
5:
6:
7:
8:
9:
10:
11:
12:
13: end while
14: Each peer has limited valid tickets that the server could not trace them

Drop the ticket
count number of invalid tickets f rom specif ic PCj
if PCj sends invalid tickets more than threshold then

Remove PCtk

f rom trusted list

end if

end if

In our ticket exchange protocol, if the LBS has T tickets for each peer in
the deﬁned periods, and the system has N peers, every peer will exchange E
tickets in each round. The exchange could be done by sending E tickets for the
following peer. So after R rounds, the probability of having tickets assigned
by the LBS to each peer can be calculated by Equation (2).

P =

(cid:17)R

(cid:16) T − E
T

+

(cid:16) E
T

(cid:17)N R−1
(cid:88)

i=1

(cid:17)i

(cid:16) T − E
T

(2)

If the number of peers gets high enough, as compared to the number of
tickets, The sigma part of the equation could be neglected. Achieving low P
is essential for the privacy of users (preferably P < 1

K ).

4.5 Handling Overloading Anonymizer

Every system faces inappropriate situations. Most of the system failures and
attacks are due to these problems. In this case, discovering the weaknesses
and handling the problem is critical. Based on our analysis, in the case of
using the P 4QS, the overloading anonymizer exceptions need to be handled
properly. As described in the protocol description method, each anonymizer
peer is responsible for anonymizing speciﬁc zones. As these zones are randomly
selected for each peer, it is possible to have an anonymizer in a crowded zone.

Title Suppressed Due to Excessive Length

17

In this case, it is possible to have too many queries. The anonymizer is just
a mobile node, and it is unable to handle all queries. In this case, a right
solution is to allow this node to leave the DHT and rejoin with a new random
MyRA. The anonymizer is now responsible for the new zones. At the same
time, when the anonymizer leaves the DHT, the queries will be sent to the
closest peers, which means that the queries will be divided between two peers,
the predecessor and successor nodes.

5 Evaluation

In this section, we evaluate the P 4QS by providing common scenarios in Sec-
tion 5.1 and this is followed by evaluation against the scenarios in Section 5.2.
A proof-of-concept prototype of the system is also built and evaluated in Sec-
tion 5.4.

5.1 Scenarios

We illustrate the diﬀerent aspects of the proposed method through a few sce-
narios. These services are diﬀerent from the following aspects:

– The frequency of access: This deﬁnes the acceptable period between two

sequential queries.

– Time accuracy and delay sensitivity: The adequate temporal cloaking which

may be caused by the anonymizer due to network delay.

– Position accuracy: The acceptable location cloaking which is made by the

anonymizer.

– The amount of required (revealed) data: In the case of requesting a speciﬁc

service, what information must be sent (revealed) by the user?

5.1.1 Proﬁle Matching

One of the possible applications of location services could be proﬁle matching.
In this case, a user needs to know speciﬁc information about users nearby. It is
very important just to reveal the permitted information, and the user should
not be able to perform further analysis by sending multiple queries. In this
case, accuracy is critical, but a sequence of queries or responses must not be
correlated.

5.1.2 Driving Conditions Monitoring

Modern vehicles have multiple sensors to acquire road and weather conditions.
These sensors could be useful for reporting road conditions instead of using
multiple expensive ﬁxed sensors. The vehicle will report road condition along-
side its path, and the whole road will be covered with sensors. In this case,
the position accuracy is not so critical, and a distance of 100 meters will be

18

Meysam Ghaﬀari et al.

suﬃcient [5]. This situation is not sensitive to delay, and reporting on the con-
dition with some delay is tolerable. However, the method must prevent the
extraction of further information such as path and speed from the reported
conditions [28][29].

5.1.3 Road Map

The roadmap is a useful feature in routing. In this case, the user needs to
report his position and query the map and speciﬁc points of interest such as
hospitals, hotels, and so on. In this case, a quick and accurate response is
needed, but the query could have some spatial cloaking because the answer
will cover a large area around the query. The important issue here is that the
identity or goal of the user must not be revealed from sequences of queries or
a particular location.

5.1.4 Detecting User based on the Sequence of Queries

It is important that the intruder must not be able to reveal the user or his goal
by analyzing sequences of queries, regardless of the type of service or user’s
intention. In this case, two important issues must be noticed. First, there is
no correlation between queries or between the queries and users. Second, the
exact position of the user in any query must not be revealed, because in this
case, it is probable that intruder could identify the user and his goal is based on
the query and background knowledge. For example, if a user queries hospitals
in midnight, when he is at his home, the intruder ﬁnds that the speciﬁc person
is sick, so she is going to reach a hospital.

5.1.5 Detecting User Speed in Highways

Sometimes just knowing the sequence of queries even without knowing the user
could be harmful to the user. For example, the police or insurance companies
could detect over-speeding in highways and detect the user in cameras based
on his position. In this case, the location-based service is not desired, and the
user prefers not to use it. Thus spatial cloaking or time delay is not a solution
here, and the only possible solution is that there would be no way to correlate
the sequence of queries. By doing that, it is probable that next query could
be from another user, and the privacy of the user might be assured.

5.2 Scenarios Evaluation

In this section, we are going to analyze the P 4QS. First, we use the mentioned
scenarios to evaluate and analyze it thoroughly from diﬀerent aspects.

The most frequent scenarios could be driving condition monitoring and
road maps. In these scenarios, the accuracy and delay are ignorable. The aim
is to hide the users’ identity in these scenarios, as it could be achieved in most

Title Suppressed Due to Excessive Length

19

of the previous methods such as fake locations, noisy queries, trusted server,
and so on. The same goal could be obtained with the P 4QS because the user’s
query will be anonymized by spatial and temporal cloaking in the anonymizer
peers.

In the scenario of detecting user by a sequence of queries, the intruder needs
to know the owner of multiple queries. This is possible in the previous methods
such as pseudonyms. In the P 4QS, each query has its unique identiﬁer, which
is the ticket, and thus the attacker will not be able to analyze the sequence
of queries. This situation happens for the proﬁle matching scenario by which
the attacker knows the user and wants to distinguish it from other users, thus
tracing his activities. In this kind of attack, using fake paths does not solve the
problem because the attacker can easily distinguish them by knowing the exact
pattern of the user. But the proposed model is resistant against this attack
also by using tickets. In these cases, even without considering spatial cloaking
(which is not recommended), the attacker cannot trace the user and distinguish
the sequence of user’s queries and hence, his identity, path and activities.
The proposed method satisﬁes the unlinkability metric and thus preserves
the privacy of the user. Note that in the central trusted server approach, the
system is vulnerable to these threats in the case of compromising the trusted
server or gaining control over it by the intruder.

The ﬁnal scenario is detecting user’s speed in highways. Most of the pre-
vious methods do not preserve the user against this threat because they do
not satisfy the unlinkability metric. Even knowing two consecutive queries is
suﬃcient to detect over-speeding. In this case, by using cameras, the user is dis-
tinguishable by knowing the approximate location and using the pseudonym,
spatial cloaking, and the fake path could not help. Since the only required
information is two correlated queries, by using other methods, the user will be
distinguished. A central trusted server is not completely trustable because it
could be controlled by the government or the insurance companies. The pro-
posed method is reliable in this case because in this model, there are not any
correlated queries, and no one could determine that two queries belong to one
user. Thus, over-speeding detection is impossible.

5.3 Attacks against P 4QS

In this part, we are going to explain the possible attacks against the P 4QS.
It uses tickets and satisﬁes anonymity and unlinkability metrics and thus pre-
serves user’s privacy. However, using tickets will cause the vulnerability in
some situations as explained below.

Non-cooperative nodes: It is possible that PAj or PBm may not cooper-
ate with the users, and the user could not get its response during this period.
In this case, it would be hard for the user to ﬁnd the non-cooperative peer
since he only knows that the response is not available. If the problem is with
the PBm, it can be easily solved by sending another query. By having a new
hash value, the new broker will be assigned to deliver the response. However,

20

Meysam Ghaﬀari et al.

since the user is in a particular location, the PAj is constant and thus, the
system needs to determine the non-cooperative peers and remove them from
the hash table. This could be done by announcing the non-delivery of the re-
sponse. If these announcements exceed a speciﬁc threshold, the PAj will be
removed from DHT, but this threat remains in the proposed model.

Sending used tickets to other peers: In the P 4QS, each peer exchanges
its tickets with other trusted peers to avoid identiﬁcation by the LBS through
using speciﬁc tickets. In this case, a peer can have malicious activities such
as sending invalid tickets or used tickets. Invalid tickets could be recognized
through the identiﬁers as mentioned in Section 4.4, but the used tickets cannot
be determined. The only possible solution is that the server adds a time stamp
to the tickets to show their valid time. Thus by limiting the usage time of the
tickets, a malicious peer has does not have enough time to use and resend the
tickets to other peers, but the model is still vulnerable against this attack.

5.4 Experimental Evaluation

The P 4QS is evaluated by implementing a server-based system and a proof-
of-concept application on Android operating system to prove the feasibility
and evaluate the overall performance of the protocol. For this purpose, two
experiments are performed: (i) We ﬁrst perform some tests on a local network
(Android device, emulator, and server are all connected to a local, isolated
network), (ii) then the same tests are performed in the Internet.

In the implemented protocol, each user chooses a random pair in (-270,
270) interval, that is called RA. Note that the sum of each pair of (longitude,
latitude) on the Earth is in this interval. Clients, either as real Android devices
or virtual clients in the emulator, will form a DHT in the server and will be
sorted based on their RAs. Also, each client has the pair (RA, IP Address) of
four successors and four predecessors of itself in the DHT. The N th successor
of client A is 2(N −1)th node in the DHT after A and M th predecessor of client
A is 2(M −1)th node in the DHT before A.

The implemented querying process consists of a few steps explained below:
First, the client needs to ﬁnd its anonymizer. So he calculates the sum of its
longitude and latitude and then ﬁnds the client whose RA is closest to the
calculated sum. After that, the client chooses one of its tickets to put it in the
query and ﬁnd the broker as well.

Tickets are created by the server and sent directly to clients (for example,
in reply to a join message). For creating a ticket, the server chooses a random
pair in (-270, 270) interval and attaches it to the known string ”server” and
ﬁnally, encrypts it with the server’s private key. So, it is only the server that
can create valid tickets.

After the client chooses a ticket, it decrypts the ticket with server’s public
key. Now, the client can ﬁnd the broker of the query. The broker is the client
with the nearest RA to the random number of the tickets. Now it is the time
to create the query. Query is a message that consists of four strings:

Title Suppressed Due to Excessive Length

21

Fig. 5: Local Network Architecture

1- Client’s longitude
2- Client’s latitude
3- (Query text + ticket + broker’s IP address) encrypted with a symmetric
key.
4- (The symmetric key) encrypted with the server’s public key.
Then the query is sent to the anonymizer, and a request for the answer to
this query is sent to the broker. The anonymizer waits for ﬁve seconds (or less
if four queries have been received) to gather some queries. If there are less
than four queries received, the anonymizer will create some queries to have
four queries to anonymize. Now, the anonymizer changes the longitude and
latitude of the queries to anonymize them. This process is a trade-oﬀ between
the quality of service (accuracy of the answer) and privacy. The anonymized
queries are sent to the server. The server decrypts the ticket of each query,
checks the validity of the ticket and creates an answer message, and sends it
to the broker responsible for that answer. When the broker receives an answer
from the server, it decrypts the ticket, checks the validity of the ticket and
then sends the answer back to the client who has requested for that answer.

5.4.1 Local Evaluation

In this experiment, the server was connected to an access point using an eth-
ernet cable and the cell phone and emulator nodes were attached to the same
access point using a wireless connection. (As shown in Fig. 5 )

Hardware speciﬁcations of devices used in this experiment are as follows:
Android device: Samsung GT-I9000 mobile phone, which has 1GHz Cortex-
A8 CPU, 512MB of RAM, 8GB of internal memory and Android version 4.4.4.
Emulator: A 2.6GHz Dual-core Intel Core i5 computer, with 8GB RAM and
256GB PCIe-based ﬂash storage.
Server: A desktop computer with Dual-Core CPU E5300 @ 2.60GHz, x64-
based processor and 2GB RAM.

22

Meysam Ghaﬀari et al.

In this experiment, two diﬀerent approaches were taken. First, we ran An-
droid application and the emulator as the ordinary clients. The Android device
and virtual devices were used to send queries and receive the answer.

Table 3 shows the mean of the querying time (the time between sending
the query to the anonymizer and receiving the answer from the broker) and
the mean time of ﬁnding the broker for the mobile node and emulator nodes.
Wait time is a random time the client waits after receiving an answer. After
that time, the client sends another query.

Table 3: Wait time for combination mode within local network

Time(ms) / Number of Nodes
Receiving query mean time (emulator)
Finding broker mean time (emulator)
Receiving query mean time (mobile)
Finding broker mean time (mobile)

20
4855.44
10.98
4354.41
46.48

40
4993.72
14.03
4867.50
31.63

60
5071.60
9.76
5199.06
45.73

80
5802.11
5.21
5361.60
53.71

Moreover, a particular conﬁguration was tested to analyze the abnormal
situations. In this test, the anonymizer of all clients in the emulator is set to be
the real device. So the load eﬀect of the protocol on a single node is analyzed.
Table 4 shows the results of this test.

Table 4: Sending all load on a single mobile node in local network

Maximum wait time (ms)/number of
emulator nodes

20

50

100

10000
20000
30000
40000
50000
60000

678.42
1492.32
1828.21
2156.14
2062.66
1954.89

1668.78
1585.00
2272.16
2319.00
2486.10
3267.05

2947.87
2712.63
2332.19
3122.87
3042.99
3019.08

As the results indicate, the processing load of the proposed method is not

signiﬁcant for any user node over the network.

5.4.2 Internet-based Evaluation

In this part, the protocol was evaluated over the Internet using multiple devices
with diﬀerent connection types. The cell phone was connected to the Internet
using a wireless ADSL modem. For the emulator and the server, two virtual
private servers with valid IP addresses were used. So this test could be more
close to the real-world infrastructures. (Fig. 6)

Title Suppressed Due to Excessive Length

23

Fig. 6: Experimental architecture over the Internet

Table 5 shows the mean of querying time over the Internet with diﬀerent

wait times before sending the next query.

Table 5: Wait time for combination mode over the Internet

Time(ms) / Number of Nodes
Receiving query mean time (emulator)
Finding broker mean time (emulator)
Receiving query mean time (mobile)
Finding broker mean time (mobile)

20
7539.92
3271.46
11876.76
3285.76

40
13548.82
11686.93
14599.56
5719.37

60
15575.06
13613.34
14238.75
5975.78

80
21280.23
13197.20
14387.89
5891.31

With a similar scenario, all virtual devices send their queries to one mobile
anonymizer node. Table 6 shows the mean of the querying time in this scenario.

Table 6: Sending all load on a single mobile node over the Internet

Maximum wait time(ms)/number of
emulator nodes

20

50

100

10000
20000
30000
40000
50000
60000

4754.27
4084.68
4648.85
4484.59
5096.97
4830.29

20948.73
15154.70
19952.28
18305.65
14300.29
12913.29

55975.71
42778.03
46668.33
48671.62
43559.16
52732.65

All of these experiments indicate that the P 4QS does not have a signiﬁcant
delay time or computational overhead. Thus, it can be easily deployed to
achieve privacy with anonymization without any extra costs such as a trusted
server.

24

6 Conclusion

Meysam Ghaﬀari et al.

In this paper, we introduced a novel peer-to-peer architecture for anonymizing
location-based queries. In the proposed architecture, each node was responsible
for anonymizing a zone and at the same time, it could use location-based
services as a client peer. By using appropriate symmetric and asymmetric
encryptions, each node just has the required information. So it could not have
any more details about the owner of the query or the sequence of her queries.
The ticket exchange protocol supported the execution and protected against
DoS attacks. The P 4QS was implemented and tested on the local network and
on the Internet. Experimental results showed that the P 4QS had a negligible
eﬀect on the time and computation costs.

References

1. Hazim Almuhimedi, Florian Schaub, Norman Sadeh, Idris Adjerid, Alessandro Acquisti,
Joshua Gluck, Lorrie Faith Cranor, and Yuvraj Agarwal. Your Location has been Shared
5,398 Times!: A ﬁeld Study on Mobile APP Privacy Nudging. In Proceedings of the 33rd
Annual ACM Conference on Human Factors in Computing Systems, pages 787–796.
ACM, 2015.

2. Serge Gutwirth. Privacy and the information age. Rowman & Littleﬁeld Publishers,

2002.

3. Urs Hengartner. Hiding location information from location-based services. In Mobile
Data Management, 2007 International Conference on, pages 268–272. IEEE, 2007.
4. Miao Lin and Wen-Jing Hsu. Mining gps data for mobility patterns: A survey. Pervasive

and Mobile Computing, 12:1–16, 2014.

5. Marco Gruteser and Dirk Grunwald. Anonymous usage of location-based services
In Proceedings of the 1st international con-

through spatial and temporal cloaking.
ference on Mobile systems, applications and services, pages 31–42. ACM, 2003.

6. Bidi Ying and Dimitrios Makrakis. Protecting location privacy in vehicular networks
against location-based attacks. International Journal of Parallel, Emergent and Dis-
tributed Systems, 30(2):101–117, 2015.

7. Tun-Hao You, Wen-Chih Peng, and Wang-Chien Lee. Protecting moving trajectories
with dummies. In Mobile Data Management, 2007 International Conference on, pages
278–282. IEEE, 2007.

8. Baik Hoh and Marco Gruteser. Protecting location privacy through path confusion.
In Security and Privacy for Emerging Areas in Communications Networks, 2005. Se-
cureComm 2005. First International Conference on, pages 194–205. IEEE, 2005.

9. Panos Kalnis, Gabriel Ghinita, Kyriakos Mouratidis, and Dimitris Papadias. Preventing
location-based identity inference in anonymous spatial queries. Knowledge and Data
Engineering, IEEE Transactions on, 19(12):1719–1733, 2007.

10. Bugra Gedik and Ling Liu. Protecting location privacy with personalized k-anonymity:
Architecture and algorithms. Mobile Computing, IEEE Transactions on, 7(1):1–18,
2008.

11. Mohamed F Mokbel, Chi-Yin Chow, and Walid G Aref. The new casper: query pro-
cessing for location services without compromising privacy. In Proceedings of the 32nd
international conference on Very large data bases, pages 763–774. VLDB Endowment,
2006.

12. Andreas Pﬁtzmann and Marit Hansen. A terminology for talking about privacy by data
minimization: Anonymity, unlinkability, undetectability, unobservability, pseudonymity,
and identity management, 2010.

13. Alastair R Beresford and Frank Stajano. Location privacy in pervasive computing.

Pervasive Computing, IEEE, 2(1):46–55, 2003.

Title Suppressed Due to Excessive Length

25

14. Rongxing Lu, Xiaodong Li, Tom H Luan, Xiaohui Liang, and Xuemin Shen. Pseudonym
changing at social spots: An eﬀective strategy for location privacy in vanets. Vehicular
Technology, IEEE Transactions on, 61(1):86–96, 2012.

15. Alastair R Beresford and Frank Stajano. Mix zones: User privacy in location-aware
services. In Pervasive Computing and Communications Workshops, IEEE International
Conference on, pages 127–127. IEEE Computer Society, 2004.

16. Tanusri Bhattacharya, Lars Kulik, and James Bailey. Automatically recognizing places
of interest from unreliable gps data using spatio-temporal density estimation and line
intersections. Pervasive and Mobile Computing, 19:86–107, 2015.

17. Walid G Aref and Hanan Samet. Eﬃcient processing of window queries in the pyra-
In Proceedings of the ninth ACM SIGACT-SIGMOD-SIGART

mid data structure.
symposium on Principles of database systems, pages 265–272. ACM, 1990.

18. Joseph Meyerowitz and Romit Roy Choudhury. Hiding stars with ﬁreworks: location
privacy through camouﬂage. In Proceedings of the 15th annual international conference
on Mobile computing and networking, pages 345–356. ACM, 2009.

19. Roman Schlegel, Chi-Yin Chow, Qiong Huang, and Duncan S Wong. User-deﬁned
privacy grid system for continuous location-based services. Mobile Computing, IEEE
Transactions on, 14(10):2158–2172, 2015.

20. Meysam Ghaﬀari and Nasser Ghadiri. Ambiguity-driven fuzzy c-means clustering: How

to detect uncertain clustered records. arXiv preprint arXiv:1409.2821, 2014.

21. Aniket Pingley, Wei Yu, Nan Zhang, Xinwen Fu, and Wei Zhao. Cap: A context-
aware privacy protection system for location-based services. In Distributed Computing
Systems, 2009. ICDCS’09. 29th IEEE International Conference on, pages 49–57. IEEE,
2009.

22. Kang G Shin, Xiaoen Ju, Zhigang Chen, and Xin Hu. Privacy protection for users of

location-based services. Wireless Communications, IEEE, 19(1):30–39, 2012.

23. Haibo Hu and Jianliang Xu. Non-exposure location anonymity. In Data Engineering,
2009. ICDE’09. IEEE 25th International Conference on, pages 1120–1131. IEEE, 2009.
24. Zhigang Chen. Energy-eﬃcient information collection and dissemination in wireless

sensor networks. PhD thesis, The University of Michigan, 2009.

25. Liz Ribe-Baumann and Kai-Uwe Sattler. A hierarchical approach to resource awareness
in dhts for mobile data management. Pervasive and Mobile Computing, 15:113–127,
2014.

26. Ion Stoica, Robert Morris, David Karger, M Frans Kaashoek, and Hari Balakrishnan.
Chord: A scalable peer-to-peer lookup service for internet applications. ACM SIG-
COMM Computer Communication Review, 31(4):149–160, 2001.

27. Gildas Avoine, Muhammed Ali Bingol, Xavier Carpent, and Siddika Berna Ors Yal-
cin. Privacy-friendly authentication in rﬁd systems: On sublinear protocols based on
symmetric-key cryptography. Mobile Computing, IEEE Transactions on, 12(10):2037–
2049, 2013.

28. Chi Wang, Hua Liu, Kwame-Lante Wright, Bhaskar Krishnamachari, and Murali An-
navaram. A privacy mechanism for mobile-based urban traﬃc monitoring. Pervasive
and Mobile Computing, 20:1–12, 2015.

29. Jiadi Yu, Hongzi Zhu, Haofu Han, Yingying Jennifer Chen, Jie Yang, Yanmin Zhu,
Zhongyang Chen, Guangtao Xue, and Minglu Li. Senspeed: Sensing driving conditions
to estimate vehicle speed in urban environments. Mobile Computing, IEEE Transactions
on, 15(1):202–216, 2016.

