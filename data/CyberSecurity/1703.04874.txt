Hacker Combat: A Competitive Sport from
Programmatic Dueling & Cyberwarfare

March 16, 2017

Department of Computer Information Systems
Georgia State University
Atlanta, GA, U.S.A

Jovonni L. Pharr
jpharr2@student.gsu.edu

Sponsored by
the Arizona Cyber Warfare Range, Phoenix, AZ, U.S.A

7
1
0
2

r
a

M
5
1

]

R
C
.
s
c
[

1
v
4
7
8
4
0
.
3
0
7
1
:
v
i
X
r
a

Abstract

The history of humanhood has included competitive activities of many diﬀerent forms. Sports have oﬀered
many beneﬁts beyond that of entertainment. At the time of this article, there exists not a competitive
ecosystem for cyber security beyond that of conventional capture the ﬂag competitions, and the like. This
paper introduces a competitive framework with a foundation on computer science, and hacking. This proposed
competitive landscape encompasses the ideas underlying information security, software engineering, and cyber
warfare. We also demonstrate the opportunity to rank, score, & categorize actionable skill levels into tiers
of capability. Physiological metrics are analyzed from participants during gameplay. These analyses provide
support regarding the intricacies required for competitive play, and analysis of play. We use these intricacies
to build a case for an organized competitive ecosystem. Using previous player behavior from gameplay, we
also demonstrate the generation of an artiﬁcial agent purposed with gameplay at a competitive level.

 
 
 
 
 
 
Department of Computer Information Systems - Georgia State University

Contents

11.5 Game Server Subscription . . . . . . .

13

Abstract

Manifesto

Introduction

Background

Proposal

Architecture

Philosophy

7.1 Motivation . . . . . . . . . . . . . . .

7.2 Penetration Testing . . . . . . . . . . .

Game Components

8.1 Units . . . . . . . . . . . . . . . . . . .

8.1.1 Randomized Birth . . . . . . .

8.1.2 Health Paradigm . . . . . . . .

8.1.3 Paradigm Extension . . . . . .

8.2 Game Arena

. . . . . . . . . . . . . .

8.3 Players . . . . . . . . . . . . . . . . . .

8.4 Realm . . . . . . . . . . . . . . . . . .

8.5 Action . . . . . . . . . . . . . . . . . .

8.6 Class . . . . . . . . . . . . . . . . . . .

Objectives

9.1 Objective-Based . . . . . . . . . . . .

9.2 Time-Based . . . . . . . . . . . . . . .

9.3 Speed-Based . . . . . . . . . . . . . . .

Gameplay

10.1 Environment setup . . . . . . . . . . .

10.2 Trial Units

. . . . . . . . . . . . . . .

10.3 Crowd Sourcing . . . . . . . . . . . . .

Demonstration

11.1 Game Server Requirements

. . . . . .

11.2 Player Server Requirement . . . . . . .

11.3 Player Targeting . . . . . . . . . . . .

11.4 Health Default

. . . . . . . . . . . . .

Experiment Design

12.1 Questions . . . . . . . . . . . . . . . .

12.2 Hypotheses

. . . . . . . . . . . . . . .

12.3 Trial Game Ecosystem . . . . . . . . .

12.4 Tools . . . . . . . . . . . . . . . . . . .

Experiments

13.1 Speed . . . . . . . . . . . . . . . . . .

13.2 Stress

. . . . . . . . . . . . . . . . . .

13.2.1 Measurement Equipment

. . .

13.2.2 Saliva . . . . . . . . . . . . . .

13.2.3 Heart Rate . . . . . . . . . . .

13.2.4 Breathing Frequency . . . . . .

13.2.5 Electroencephalography . . . .

13.3 Metric Aggregation . . . . . . . . . . .

Gameplay Metrics

14.1 Consistency . . . . . . . . . . . . . . .

14.2 Error Per Minute (EPM)

. . . . . . .

14.3 Characters Per Minute (CPM)

. . . .

14.4 Commands Per Minute (CoPM)

. . .

14.5 Commands Per Entry (CoPE) . . . . .

14.5.1 CoPE Psychology . . . . . . .

Game Versions

15.1 Player Server Locality . . . . . . . . .

Protocol

Unit Environments

17.1 Containers . . . . . . . . . . . . . . . .

17.1.1 Docker . . . . . . . . . . . . . .

17.2 Virtual Machines . . . . . . . . . . . .

17.2.1 Vagrant . . . . . . . . . . . . .

Source of Truth

18.1 Centralized . . . . . . . . . . . . . . .

18.2 Decentralized . . . . . . . . . . . . . .

18.2.1 Blockchain Validation . . . . .

18.3 Advantages . . . . . . . . . . . . . . .

18.4 Disadvantages . . . . . . . . . . . . . .

13

13

14

14

14

14

14

14

15

15

15

16

16

16

17

17

18

18

18

19

19

19

20

20

21

21

21

22

22

22

22

22

22

23

23

1

4

5

5

6

6

6

6

7

7

7

8

8

9

9

9

9

9

9

10

10

10

10

10

10

11

11

12

12

12

13

13

1

Department of Computer Information Systems - Georgia State University

Guaranteed Risk Level

User-Computer Interface

20.1 Scoreboard . . . . . . . . . . . . . . .

20.2 Command Terminal

. . . . . . . . . .

20.3 Built-in Browser

. . . . . . . . . . . .

Artiﬁcial Intelligence

21.1 Decision Making . . . . . . . . . . . .

21.1.1 Markov Decision Process

. . .

21.1.2 Recurrent Neural Network us-
ing BPTT . . . . . . . . . . . .

21.2 Kali Linux . . . . . . . . . . . . . . . .

21.3 Simulation Training . . . . . . . . . .

21.4 Data Capture . . . . . . . . . . . . . .

21.4.1 Command Capturing . . . . . .

21.5 Feature Selection . . . . . . . . . . . .

21.6 Policy Networks . . . . . . . . . . . . .

21.6.1 Recon Network . . . . . . . . .

21.6.2 Enumeration Network . . . . .

21.6.3 Access Network . . . . . . . . .

21.7 Outcome Analysis

. . . . . . . . . . .

21.7.1 Command Outcome Analysis .

21.7.2 Game Outcome Analysis . . . .

Physical Apparatus Extension

Further work

Conclusion

List of Figures

1

2

3

A setup for head-to-head cyber secu-
rity combat. . . . . . . . . . . . . . . .

illus-
Capture-the-ﬂag game design,
trating the exchange of validations for
predeﬁned ﬂags from players to a cen-
tralized source of truth – the game
. . . . . . . . . . . . . . . . . .
server.

Unit communication potential within
a Realm. Here we show two Realms,
each holding three Units . . . . . . . .

23

23

23

24

24

24

24

25

26

27

27

27

27

28

28

28

28

29

29

29

29

29

29

29

5

5

7

2

4

5

6

7

8

9

Each player unit has a unique ﬁn-
gerprint, of which regurgitation by a
Player other than the owner immedi-
ately destroys the enemy Unit as a
Proof-of-Exploitation . . . . . . . . . .

This is the Game mechanics from a
data ﬂow perspective, per each Game

The CIA Triangle . . . . . . . . . . . .

Top-down perspective of event struc-
. . . . . . . . . . . . . . . . . . .
ture

Event Structure from multiple per-
spectives . . . . . . . . . . . . . . . . .

Cortisol measurements for participant
P03, on the day of, and the day be-
fore experimentation. Time of game-
play window is highlighted on the day
. . . . . . . . . .
of experimentation.

8

11

11

12

13

16

10 Participant P03’s beats per minute

displayed with associated hacker phases 16

11

Shown is the breathing rate of partici-
pant P03 during Game experimentation 16

12 Anterior - Posterior Bipolar Montage
of participant P03 immediately after
an opponent exploitation . . . . . . . .

13 The superimposition of various physi-
ological measurements through time .

14 Error rate (red) visualized with com-
mands per minute (green), as calcu-
lated in equation 23, used to monitor
. . . . . . . . . . . .
Player behavior.

15

cumulative CoPM and EPM, at the
15-minute mark during experimenta-
tion for participants P01, P02, and
. . . . . . . . . . . . .
P03 respective

16 The amount of commands per minute
passed in the game whereby a trough
indicates a player pause in typing ac-
tion. This is captured from participant
P03 during experimentation . . . . . .

17 Early AWS Experimental Process

. .

18 The game setup process for a central-
ized game structure experiment #1.
Process returns credentials needed to
SSH into their player server s. This
speciﬁc proof of concept used Amazon
AWS, and associated platforms. . . . .

19 The storage of Game state being
. . . . .

stored in a blockchain ledger

17

18

18

18

19

20

21

23

Department of Computer Information Systems - Georgia State University

20 Demonstrating the GUI exposed to
each player in the trials containing
tabbed terminal window, one score-
. . .
board, and one internet browser.

22 The decision making architecture for
the proposed agent . . . . . . . . . . .

21

Illustrating the character-level RNN
using back propagation through time
(BPTT) for continuous next-character
. . . . . . . . . . . . . . .
prediction.

23 The FSM structure of the agent using
an MDP . . . . . . . . . . . . . . . . .

List of Algorithms

1

Calculating the next agent state s, at
time step t. We reference the MDP
ﬁrst, then predict using the relevant
policy network. The ellipsis conveys
the ﬂexibility of using either character-
level, or command-level prediction . .

24

24

25

26

26

3

Department of Computer Information Systems - Georgia State University

Manifesto

It is with great pleasure that this work be publicly shared. At the time of writing, there exists an ever-
growing competitive landscape in information security. With cyber warfare being an increasingly pertinent
threat to the humanity of civilization, the eﬃcient training of the next generation of cyber warriors becomes
ever more important; history has not been kind to the Black Hat. Plotting control over the individuals
of whom can liberate an entire generation. These unfortunate state of aﬀairs serve as a guiding beacon
throughout this work. This proposal is nation state agnostic, and serves the ethos of the Hacker culture.

It is understood that this proposal, rightfully belonging to the people, upon being misused, can be
detrimental to the purity of the ethos. It is for this reason that the researchers of this project intend to
organize this collective eﬀort. All collaborators on this project have exclusively spent volunteer hours to
bring this project to completion. It is for this reason that the culture must ensure that no entity, public nor
private, succeed in exploiting this framework for purposes that indicate skullduggery.

It is the ethos that widen the window of imagination, and it is the ethos that shall ensure survival of
unhindered exploration. The powers that are incentivized to destroy free exploration have not a motivation
to empower the ethos with such a framework. This is the reason that this project is For Hackers, Built By
Hackers. The supporters of this project are only messengers of the framework. This framework does not
invent a new concept, but focuses on disambiguating a competitive structure for cyber warfare, computer
science, and information security. In other words, the pieces are already "there", and have been so for quite
some time.

This project does not pretentiously try to convince the reader of a completely unique idea. We do not
attempt to take credit for creating this framework. It is fully believed that every practitioner in these ﬁelds
already perform the behaviors used to partake in the proposed system. This paper is merely a combination
of existing techniques, and methodologies.

The instance in which any individual nation state attempts to own this framework, will be a great loss
to the entirety of the ethos. However, the capabilities of this type of framework are conducive to militaristic
training, but should not be restricted for use by anyone interested. Upon the death, or earthly removal of
the project originators, there shall be no bearing on the potential uses of this framework for the remainder
of civilization. This proposal is not only created with care, but with passion as well. To the ethos, go the
freedom to ascend.

4

Department of Computer Information Systems - Georgia State University

Figure 1: A setup for head-to-head cyber security
combat.

Introduction

Arguably, computer programming is an art form.
With every art form, there exists tiers of talent –
novice to expert. This article yields a dueling sys-
tem built entirely on the methods & tactics used by
computer scientists, and cyber security researchers.
Cyber security is an important topic for the safety
of the planet, but this paper merely builds on the
fundamental philosophy of attack and defense.

At the time of this paper, there exists eﬀorts
to introduce Artiﬁcial Intelligence to cyber security
competitions. These eﬀorts remove the human as
the hacker, replaced by an artiﬁcial agent. The hu-
man plays the role of designing a system capable of
autonomous detection, exploitation, and patching of
security vulnerabilities. While this is subjectively an
interesting ﬁeld of research, this article focuses on
keeping the humanistic actor as the center partici-
pant in cyber warfare competition.

Background

Today, there exists an ecosystem of capture-the-
ﬂag competitions related to the cyber security indus-
try. This ecosystem is constantly growing, and of-
fers many beneﬁts to the ﬁeld. Traditionally, Black
Hat Capture the Flag games (CTF) are held, some-
times referred to as "Red versus Blue". These games
sometimes designate ﬁles on player systems, of which
must be defended, or stolen. Game servers periodi-
cally check for those ﬂags to be intact. "Intact" could
mean both existing, and unchanged. There also exist
situations where players must learn the behavior of
compiled programs. With conventional capture the
ﬂag competitions, there exists the following compet-
itive objectives:

2. Find a bug in a designated system

3. Answer cyber security related questions, serving

as education

4. Reverse engineering binary programs, sometimes

to obtain a ﬂag

The diﬀerence between capture-the-ﬂag, and this
system lies in how the idea of "Winning" inﬂuences
the game, and diﬀerent "Capabilities" of game pieces
available to a player. Today, participants are re-
warded points for exploiting a system, and deducted
points for being exploited. Here, there is no notion
of gaining points by exploitation. Participants must
take it beyond simply obtaining a shell.

During conventional CTF matches, there is a
game server that periodically pings each player’s sys-
tem to determine whether or not a predetermined ﬁle
is still on the system. If that ﬁle is not on a player’s
system, one assumes that the opposing player has
removed the ﬁle by penetrating the player’s system,
and removing it. Conventional CTFs also consist of
game servers that ping player resources to decide if
speciﬁed services are still available. They also enable
players to download binaries, and reverse engineer
them for an answer to a question, of which repre-
sents a "ﬂag". These questions are usually related to
cyber security. This is the current landscape of cyber
security CTF’s.

Figure 2: Capture-the-ﬂag game design, illustrating
the exchange of validations for predeﬁned ﬂags from
players to a centralized source of truth – the game
server.

1. Competitors are purposed with inﬁltrating ex-

isting servers

This proposed approach is diﬀerent from these
conventional paradigms in that it is a methodology

5

Department of Computer Information Systems - Georgia State University

that simply enables participants to battle, head-to-
head, in a darwinian, survival-of-the-ﬁttest competi-
tion. The currently existing paradigm is not a prob-
lem to be solved, and this paper aims to restate that;
we merely propose a diﬀerent perspective to cyber se-
curity competition. The Game Server is not focused
on providing tasks, of which users must accomplish,
or solve. The Game Server is instead focused on keep-
ing track of the state of the game during battle.

Proposal

This paper introduces a system that, using a
myriad of technological methods, enables competi-
tors to directly battle one another by attempting to
"destroy" one another’s servers/resources – while si-
multaneously oriented towards not having their own
resources "destroyed". Destruction either takes on
the form of rendering one of an individual player’s
server "unreachable", or by inﬁltrating an oppo-
nent’s server, and grabbing a "randomly generated
string" from a speciﬁc directory within that Player’s
server. This action serves as a Proof-of-Explotation,
thus providing instant destruction of the server. De-
pending on the game mode, rendering a player re-
source "unreachable" generates an arbitrary damage
amount for that given time duration deﬁned by how
long the server is "unreachable"; this is yet but one
game version proposed. For this proposal, we refer
to one of an individual Player’s servers as a Unit be-
longing to a Player.

Architecture

p represents an iterator over P , the set of all
Players.
i represents an iterator over the variable.
For example Upi represents, within the set U , the
Player (p) owning the Unit, and which Unit (i) within
all of the Player’s Units, U

A Realm is deﬁned as a virtual environment in

which Units of a Game exist. Let

g ∈ G ∧ r ∈ R ⇒| G |∈ R[0, ∞)

(8)

This proposal accommodates Games for only two
Players, but implies n Players is possible. Also, this
implies that the number of Realms in a given Game
is deﬁned as

∀gi, | R | ∈ R[2, ∞)

(9)

The cardinality of R represents between two Realms
in a Game, up to, but not equal to inﬁnity. This
is disregarding scalability, and any implementation
details.

∀ a ∈ A, aj = Actions for cn

(10)

Each Unit, deﬁned by its Class (c), has its own
properties and capabilities. Included in its capabil-
ities, are the Actions that the Unit can perform. n
deﬁnes iterating over all Classes, and j iterates over
all Actions for the speciﬁc Unit. This translates to
all Units being able to perform a set of Action.

Philosophy

7.1 Motivation

The perspective of this research is motivated by
multiple visions. Part of the vision stems from the
subjective notion of the need to increase cyber secu-
rity education in a world of ever increasing vulnera-
ble devices being created. After a survey of the Boy’s
& Girls club of America’s curriculum, it is clear that
DIY S.T.E.M (Science, Technology, Engineering, and
Mathematics) classes are oﬀered to participating chil-
dren. However, there is a lack of cyber security educa-
tion in these programs. This project is co-motivated
by the gamiﬁcation of cyber security in the service of
attracting new practitioners to the ﬁeld; agnostic of
age, and background.

Upi = Set of All Player Units
G = Set of A Game Arenas

P = Set of Players

A = Set of all Actions

C = Set of Unit Classes

R = Set of all Realms

(1)

(2)

(3)

(4)

(5)

(6)

(7)

Another motivation for this work is to be an at-
tempt at legitimizing the cyber security practice of
"Red vs Blue" as a widely accepted Sport – irre-
gardless of whether it is spectator based, or private
competition. In the same way that the National Bas-
ketball Association, and the Major League Baseball
organization oﬀer paths to professional athleticism,
this project believes in the same potential for cyber
security research.

6

Department of Computer Information Systems - Georgia State University

Figure 3: Unit communication potential within a Realm. Here we show two Realms, each holding three
Units

7.2 Penetration Testing

Ethical hacking is not only utilized by large com-
panies to ensure the integrity of their systems, but to
also enable programmers to use their craft with the
purpose of breaking into a system. As a penetration
tester, your role consists of both oﬀensive, and de-
fensive work. Given certain situations, it is even the
case that both Red and Blue actors may have to per-
form oﬀensive, and Defensive tasks. The details of
penetration testing help enable the existence of this
proposal.

Game Components

In this section, we deﬁne the components that

make up the proposal

• Units (U )

• Game Arena (G)

• Players (P )

• Realm (R)

• Action (A)

• Class (C)

8.1 Units

A Unit is a single computing environment; each
Unit is diﬀerent, and chosen by a random process.
Units bring about diﬀerent capabilities, and can be
used in combination with others. When they are al-
lowed to communicate to each other, assuming they
belong to the same Player, Units enable creative con-
ﬁgurations. Units can be chosen by strategy, depend-
ing on the Game mode. The default Game mode en-
ables random selection of Units. All Units for a given
Player reside within a single Realm. Units within a
single Realm can be uni-kernel, or iso-kernel. This

7

Department of Computer Information Systems - Georgia State University

Figure 4: Each player unit has a unique ﬁngerprint, of which regurgitation by a Player other than the
owner immediately destroys the enemy Unit as a Proof-of-Exploitation

is depending on what technology is used to imple-
ment the Units. This paper covers the comparison of
containerization, and virtual machine management.

In the trials, Units are deployed with speciﬁed
ports in use. These ports can either be predeter-
mined, or determined at runtime of a Game. Re-
gardless on when the ports are determined, neither
participating Player shall have prior knowledge of the
ports used. Work is required, from the Player to iden-
tify which ports are being used. Each Unit contains
a predetermined service that is indeﬁnitely running
once a Unit is born. It is this service that is used to
determine the "health" of the Unit.

It is also possible to have multiple services within
a Unit. If multiple services exist in a Unit, the scoring
mechanism must account for this diﬀerence in scor-
ing methodology. The trials that we perform are con-
strained to having only one service running at birth.

Player server; this network call is local to the Player
server if the Units are both uni-kernel, or iso-kernel,
as with the trials shown. If that ping is successful,
that Unit is reported to be "up", with a status code
of 200. If that ping is not successful, then the Player
server reports a status code of 400, denoting that
the Unit is "down". On a predeﬁned interval, the
Player host reports to the Game Server, opposed to
the Game Server pinging each Unit individually. The
Gameserver relies on this status for it’s health scoring
methods.

Determining the health of a Unit can be done in

many ways:

U D = Units Down

(11)

U D is the set holding all Units that are "down" at a
speciﬁc time step in the Game.

8.1.1 Randomized Birth

Depending on the Game mode, every Unit is se-
lected at random from a predetermined pool of au-
thorized Units. Each Unit is unique in nature in re-
gards its properties. This is reinforcing the notion of
unique Unit classes, and properties are discussed in
detail in the section covering Gameplay.

8.1.2 Health Paradigm

Upon Unit birth, each unit is Born with a pre-
determined amount of Health; default health is 100
in the trials of this paper. Health is determined
by the ability of each Player to report available ser-
vices residing on their Units. To report a live Unit,
the Unit is sent a network ping from its respective

ch = Current Health

(12)

ch is the current health of a Unit.

dc = Damage Constant

(13)

dc is the constant damage that is applied to any Unit
that is an element of U D, at any given time step.

s = Seconds passed

(14)

Such that a Unit’s health is deﬁned as,

∀u ∈ U D, uhealth = uch − s · dc

(15)

Depending on whether a objective-based, or
time-based Game style, when the set of Units be-
longing to a Player all reach a uhealth ≤ 0, a Player

8

Department of Computer Information Systems - Georgia State University

is deﬁned as Defeated. This is assuming a health
related Game mechanism (objective-based) is being
used, and that victory is determined by "last hacker
alive" rules.

If a default health of 1 is used during a Game,
that Game can be viewed as "sudden death" whereby
Units are destroyed upon any service interruption –
even accidental interruption.

8.1.3 Paradigm Extension

The permutation of properties given to the Units
in this proposal, as well as the permutation of other
Game mechanics, is beyond an exhaustive list. Due
to multiple types of Game mechanics that can be
integrated with this environment, there exists many
conﬁgurations that are possible. This is left to sub-
sequent work, and the subjective vision of any other
independent implementations of this initial proposal.

8.2 Game Arena

A Game arena is deﬁned as the inclusion of
both Player’s Realms. Players have access to these
Realms, and can also work externally. If the amount
of Players in a Game is greater than two, j, than a
Game arena can encompass j Players.

(a) Enter Unit

i. SSH a Player directly into a speciﬁc

Unit

3. Oﬀensive

(a) Capture Unit

i. Submit an opponent’s retrieved hash

string as proof-of-exploitation

(b) Attack Unit

i. (experimental) Enable beginners to se-
lect generic attack types, and launch
them at an opponent

8.4 Realm

A Realm is deﬁned as a space containing multi-
ple Game pieces (Units) belonging to a single Player.
Realms contain all Player data from a speciﬁc Game.
In the trials, a Realm is deﬁned as a single server
belonging to a Player. All Units in the trials exist
on this single server per each Player. If required, all
Player Units can exist on separate servers, but this
article does not cover such an approach.

UG = UR ∪ UR+1

(16)

8.5 Action

The Units in any given Game is deﬁned as the

union of all Player Realms.

8.3 Players

A Player is deﬁned by being a single participant
in a given Game arena, owning their own Realm,
and dueling against another single Player, or more.
Throughout a Game, each Player has access to these
"functions" – falling under three categories (Recon,
Defensive, and Oﬀensive):

1. Recon

(a) GetOpponentIP

i. Fetches the opponent’s IP address

(b) GetFlags

i. Fetches a Player’s own ﬂags from their

Units

2. Defensive

An action is deﬁned as being a behavior un-
dertaken by a speciﬁc Unit owned by an individual
Player. Depending on player eﬃciency ratings, Ac-
tions can be manually generated, and programmat-
ically constructed; they can also be ﬁred from pre-
made attack scripts for beginners. The trials focus
on no pre-made attack scripts, as Players can write
scripts during gameplay.

8.6 Class

A Class is a speciﬁc categorical label for a given
Unit. The Class of a Unit determines the capabilities
of that Unit, and also the available Actions that can
be performed by that Unit, provided that the Unit
has not been augmented by the owning Player. For
the sake of these trials, the Classes for Player Units
have been predeﬁned. We also explore the concept
of crowdsourcing Unit classes. A crowdsourced ap-
proach would enable for the most variety of content
within a given Player Unit.

9

Department of Computer Information Systems - Georgia State University

Objectives

The Game mechanics described here can take
the form of many types; this paper mainly highlights
three, but leads further research into others. In these
three forms, Players can compete in objective-based
combat, speed-based, or time-based. We enable mul-
tiple modes for the purpose of not creating an envi-
ronment that only models real world scenarios, but
can remain as adaptive as real-world cyber security
requires. This lack of constraint is also captured in
the idea of Dr. James Naismith inventing the game
of Basketball. With his initial framework, it enables
the opportunity to dunk a basketball today, regard-
less of not originally being incorporated into the game
mechanics of the Sport.

9.1 Objective-Based

With an objective-based Game mechanic, Play-
ers can duel until all of a Player’s Units are de-
stroyed, or an arbitrary amount/percentage of a
Player’s Units have been destroyed. With this be-
ing a default example of an objective-based Game
mechanic, it is clear that a myriad of permutations
can be utilized in the service of expanding, or chang-
ing the base Game mechanics. This paper does not
suggest one speciﬁc game mechanic, but rather intro-
duces many.

9.2 Time-Based

With a time-based Game mechanic, Players can
duel indeﬁnitely, until a game-server-owned timer is
exhausted. To determine a winner, at time exhaus-
tion, the Game Server can take into account the sum
of healths for each unit for a given player. It is also
possible to take into account the amount of Units left
after battle. This paper does not suggest one speciﬁc
scoring mechanic for time-based matches, but rather
illustrates multiple options.

as in actual speed-based Chess.
In speed-based, a
Player can also be defeated upon exhaustion of their
respective times. This introduces a notion of acting
eﬃciently, and quickly during gameplay.

Gameplay

The Game mechanics described here can take
the form of three types. Players can compete in an
objective-based environment, time-based, or speed-
based. One of the purposes of this system is to enable
a realistic, non-hindering, environment of which is as
closely emulative of real-world cyber warfare scenar-
ios. To support this goal we model the experience
around the stages of a cyber-attack, according to the
EC-Council. The stages are the following

1. Recon

2. Scanning

3. Gaining Access

4. Maintaining Access

5. Covering Tracks

Players must follow these steps in, at minimum,
a haphazard manner. This means that Players must
engage in all of these steps, multiple times during the
course of one Game. The only surface-level exception
can be "Covering Tracks"; this being because Players
can be found upon interrupting an opponent’s Unit.
We also document a post-match judging activity, to
enable a humanistic, intuitive, and artistic property
to the determination of a winning party. "Cover-
ing tracks" can be considered during judging rounds;
be it by manual, or automatic processes. It is doc-
umented that Games can operate with, or without
these factors. One of the main purposes of this paper
is to introduce the philosophy behind this ecosystem,
not to merely convey dogmatic implementation de-
tails.

9.3 Speed-Based

10.1 Environment setup

Similar to speed-based Chess, Players can be-
gin with a predeﬁned amount of time issued to each
Player clock. By taking turns, Player time will ex-
pend per each time step taken for them to submit
a move. Submission of a move can vary, as submis-
sion can be as simple as pressing "enter" within a
terminal, or physically pressing a speed clock timer,

This paper shows multiple development versions
of this Game. With one conﬁguration, AWS, and as-
sociated products are used. With other implementa-
tions, all Game mechanics are originally developed.
One conﬁguration uses a subscription & publishing
architecture for Game Server to Player Server com-
munication & syncing.

10

Department of Computer Information Systems - Georgia State University

(a) Service - Damn Vulnerable Web Applica-

tion (DVWA)

(b) Vulnerability - IP Ping service ﬁeld is not

ﬁltered properly

(c) Port - 3003

(d) Vulnerability - Command injection

These Units are completely arbitrary, initially
used, and only used as an example of full environ-
ments with diﬀering levels of exploitability, vulner-
ability, and overall capabilities. The exact permu-
tations, and conﬁgurations for each Unit used is up
to the decision of each implementation of this work.
This article merely suggests a variation among many.

The trial Units used all enable command execu-
tion on a target. In the real-world, not every vulner-
ability enables this type of exploit. With SQL Injec-
tion, an attacker can manipulate a target Database,
but this does not imply shell access. To construct
a system around every attack & vulnerability type
would require a change in scoring mechanism. For
example, a Player Server will have to be able to de-
termine whether a Player’s database is exploited, and
to what degree. Furthermore, if the vulnerability en-
ables a Cross Site Scripting (XSS) attack, this also
does not imply server access. A Game would be re-
quired to monitor the degree to which a Player’s front
end is being exploited. This paper does not propose a
solution to monitor every attack type known. Having
shell access to a server can imply complete control;
this is why we focus on vulnerabilities that allow for
direct command execution by some means. Refer-
ring to the CIA [5], the Trials focus on availability of
a service, opposed to integrity, or conﬁdentiality; this
is illustrated in 6.

Figure 6: The CIA Triangle

10.3 Crowd Sourcing

We introduce the usefulness of crowd sourcing
the internal environments for each Game Unit. This

Figure 5: This is the Game mechanics from a data
ﬂow perspective, per each Game

10.2 Trial Units

Without taking into account the notion of ran-
domized Units, the following are the Units used in
the Trials:

1. Unit 1

(a) Service - Node Application server

(b) Vulnerability - system call from direct

program parameters

(c) Port - 3001

(d) Exploit - remote code execution by query

string

2. Unit 2

(a) Service - OWASP Web Goat

(b) Vulnerability - Form POST is not ﬁltered

(c) Port - 3002

(d) Exploit - Command injection

3. Unit 3

11

Game ServerPlayer 1ServerPlayer 2ServerC1C2C3C5C4C6P1 ChannelP2 ChannelP1 HealthP2 HealthLocal Container CallDepartment of Computer Information Systems - Georgia State University

would beneﬁt the ecosystem by introducing addi-
tional layers of entropy to the Unit generation pro-
cess. While it is entirely possible for one indi-
vidual to create every Game Unit environment, a
crowd sourced methodology would yield Unit vari-
ations faster, and with more variability.

For the trials we model Units after industry-used
platforms. We use Damn Vulnerable Web Applica-
tion (DVWA), and OWASP Broken Web Application
(BWA) to enable vulnerable Units. With a crowd
sourced approach, the variety in the Units used in-
creases.

Demonstration

The strategy to legitimize cyber-warfare as a
Sport is directed by the production of physical, Live-
events. The proposed event structure is the same
as a typical, public, spectator Sporting match. The
only required augmentation revolves around ensur-
ing that Players cannot watch opponent screens, but
the audience is indeﬁnitely able to monitor both
Player screens – and a single Game Server scoring
screen. To accomplish this, Player screens are tilted
45◦ ≥ θ ≥ 0◦ from the orientation of a Player’s oppo-
nent’s facing direction, away from the spectating
audience, while said Player is sitting at their playing
station. A Player’s screen is shown in the projector
placed opposite of their playing station.

Each Player’s shown projected screen is placed
on the side of their opponent.
It is possible for a
Player to see their own projected screen. However,
this geometric setup ensures that a Player cannot
physically see their opponent’s screen, in a two Player
competition; the audience is still able to see both
Player’s screens, and the scoreboard projector behind
them from the orientation of the spectating audience.

Figure 7: Top-down perspective of event structure

11.1 Game Server Requirements

Assuming a centralized Game environment, the
Game Server hosts a service of which is treated as a
single point of truth for a Game. The Game Server
in the trials utilizes the Message Queue Telemetry
Transport (MQTT) protocol for the synchronization
of Players and the Game Server. This choice is
made because of the light-weight properties oﬀered by
the publish and subscription mechanism built within
MQTT.

To enable a live demonstration of the trials, the

11.2 Player Server Requirement

following steps must occur:

1. Start Game Server on capable server

2. Start Player servers on capable servers

3. Ensure Players are targeting each other on the

Game Server

4. Ensure that all Player Units are at a chosen de-

fault health

5. Ensure Players are targeting Game Server

6. Ensure Game Server is targeting itself for web-

socket UI

Each participating Player hosts a Realm holding
multiple Units. Units can be remote to a Player, but
we focus on locality in these trials. The Player must
remain updated about their own statistics, from the
source of truth (Game Server). The player can also
be aware of the truth about their opponent, but is
not required. At a minimum, this is the purpose of
a universal Game Scoreboard. If using MQTT, and
if the Player Server exists on a consumer device con-
trolled by the Player (i.e a Macbook Pro), the tim-
ing of the throughput speed for the Game-Server to
Player-Server communications cannot eﬃciently be
"real-time".

12

Department of Computer Information Systems - Georgia State University

Figure 8: Event Structure from multiple perspectives

This means that there is a tradeoﬀ between how
"real-time" the Game synchronization can be, and
the speed of the Game-to-Player communications on
consumer devices. To navigate this, the system is
placed on three Ubuntu 2XLarge AWS servers. It
is observed that executing the Player environments
on high-performance servers yields actual real-time
experience, but removes control of the Player environ-
ment from the local possession of the actual Player.
Additional implementations can use controlled REST
methods for Game synchronization, but a "real-time"
experience is preferred in these trials.

11.5 Game Server Subscription

Each Player must publish, and subscribe to the
Game Server holding their source of truth, unless in a
decentralized Game version. While being subscribed
to the same Game Server, the Game state is shared
between all parties involved; each Player, and a Game
Server. A Game is not dependent on a publish, and
subscribe structure, but this structure is conducive
to the trials demonstrated in this work.

Experiment Design

11.3 Player Targeting

12.1 Questions

The Game Server must also be aware of identity
In other
of each opponent, relative to the Player.
words, the Game Server has to be told which Player
In these trials,
is the opponent of another Player.
each Player is paired with a single opponent.
In
three-way competition, a Player is assigned two op-
ponents, and so on. Enabled by Player targeting, a
single Game Server can mediate multiple, indepen-
dent Games. The scenario of duplicate Player names
is not examined, but is discouraged for the reserva-
tion of Player identity "uniqueness".

11.4 Health Default

In a simple demonstration, we begin a Game
with each Unit starting at 100 health points. A cal-
culation for the health of a Unit is shown in equation
15, and is dependent on how many times a server
has been ﬂagged as locally-unreachable by a Player
service check.

This is a convenient Unit health with which to
begin. A choice in the trails is also made to begin
certain Games with a default Unit health of 1. This
enables a "sudden death" Game type, whereby Units
are destroyed upon any service interruption.

The following is an exhaustive list of our experimental
questions:

1. Is it possible to develop a system & methodology
that enables head-to-head competition based on
cyber security?

2. What performance issues arise when enabling

such a system with virtual environments?

3. What features of the real-time environment are

of interest to warrant analytics?

4. What is the likelihood of a modern cyber-
security professional desiring to participate in
such a competition?

5. What does a comparison in terms of energy con-

sumption look like with other Sports?

6. How does skill, and experience play a factor in

such an environment?

7. What are the challenges in this area for Artiﬁcial

Intelligence work?

8. How does the environment change if the source

of truth is decentralized?

13

Department of Computer Information Systems - Georgia State University

12.2 Hypotheses

The following is an exhaustive list of experimental hy-
potheses regarding the questions mentioned hereto-
fore:

1. The energy consumption of such an activity
takes the same amount of energy as at least one
given sport, during a span of 1 hour.

2. This Game environment creates a competitive
environment that induces measurable stress on
any participant.

3. A player with no cyber security skill set cannot
readily play this proposed game at a generally
competitive level.

4. Training an Artiﬁcial Agent to play this game is

not intractable.

5. Incrementally playing this proposed game is tur-

ing decidable for an Agent.

6. Spectators with no knowledge of cyber security
work will ﬁnd this activity appealing to observe.

7. A decentralized, and centralized Game structure

yield the same competitive environment.

12.3 Trial Game Ecosystem

For our experiments, we enable three server en-
vironments. Two for the Players of the Game, and
one for the scoring Game server. The Player servers
are subscribed to a channel providing data on their
own health, and another channel providing data on
their opponent’s health. The Game Server acts as a
traﬃc cop for the Game data. In a centralized struc-
ture, this ensures that all real-time calculations are
from one source of truth – the Game Server.

section on Game Versions uses AWS in a black-box
manner. Due to the technology requirement being so
heavy, that approach is not used any further. AWS is
used in these trials for access to computationally eﬃ-
cient servers within which to host both Player servers,
and Game Server. This proposal is in no way depen-
dent on AWS, or any service that is similar.

Experiments

We conduct various experiments highlighting
variables of interest to the research team. Among
these interests are the speed with which the Play-
ers operate,
the psychological stress levels ob-
served on the Players during gameplay, the con-
sistency that Players exhibit when typing & work-
ing on their system, the error rate observed from
Players during gameplay, characters-per-minute
(ChPM), commands-per-minute (CoPM), and
commands-per-entry (CoPE). These properties of
the Game are simply the properties chosen for the tri-
als of this work. Future implementations should ex-
periment with additional properties. After a Game is
ﬁnished, a Player’s style-of-play can be proﬁled using
these metrics.

13.1 Speed

While actively working during a Game, the
speed of typing, and command entry is measured in
real-time. This is similar to calculating words-per-
minute from the perspective of generic computer typ-
ing tests. Speed can be indicative of how comfortable
a Player feels with the environment used, and how
fast they can type during the performance of work.

13.2 Stress

12.4 Tools

We develop an MQTT client on Player Realm
servers to enable real-time, uninhibited Game scor-
ing. We also develop executables that enable a Player
to submit commands to the Game Server. For ex-
ample, we expose an executable in C++ that when
invoked with a string as a parameter, contacts the
Game Server, and attempts to "submit" an opponent
ﬂag, proving Player exploitation to the Game Server.

AWS is used in a myriad of ways during this
project. The initial experiment trial, covered in the

The focus around stress involves the question of
"What forms, and levels of stress does an average par-
ticipant endure during an ethical hacking exercise?".
It is a focus of this paper to support cyber warfare as
a legitimate sporting activity. We observe diﬀerent
indications of stress, and behavior associated with it.
If one could closely compare existing sporting activi-
ties with the activities of ethical hacking, it can serve
as the initiation of a conversation on the matter – at
the very least.

By summarizing the results of studies that mea-
sured the circulating levels of stress hormones before
and after individuals were exposed to various situa-

14

Department of Computer Information Systems - Georgia State University

Table 1: Participant age, identiﬁcation code, gen-
der, years professional, and testing start time for
physiological experimentation

Code Age
P01
P02
P03

24
26
21

Sex Years Testing Start Time
m
m
m

9:30am
1:30pm
12:30pm

7
13
1

tions that were deemed to be stressful (e.g., air-traﬃc
controllers or parachute jumping), Mason (1968) was
able to describe three main psychological determi-
nants that would induce a stress response in any in-
dividual exposed to them.

Using this methodology, he showed that in or-
der for a situation to induce a stress response,
it
has to be interpreted as being novel, and/or unpre-
dictable, and/or the individual must have the feeling
that he/she does not have control over the situation.
Recently, another determinant was added to this list
– namely a threat to the ego. Although this work led
to a general debate between Selye and Mason (Se-
lye, 1975), further studies conﬁrmed that the deter-
minants of the stress response are highly speciﬁc, and
therefore, potentially predictable and measurable [2].

We measure Cortisol

levels, heart rate, and
breathing frequency during gameplay. We also mon-
itor EEG channels. We combine all stress measure-
ments, except EEG data, synced by time, onto a sin-
gle visualization in ﬁgure. Table 1 shows the three
participants included in the study.

13.2.1 Measurement Equipment

We procure multiple pieces of equipment for
physiological measurement. For Heart Rate, we pur-
chase a Fitbit Charge ll ﬁtness band. For Corti-
sol monitoring, we purchase multiple ZRT Adrenal
Stress Proﬁle Hormone Imbalance Home Test Kits
by Genova Diagnostics [7]. This is a salivary cortisol
test that is taken by Players at multiple times dur-
ing the day. For Breathing frequency, we procure an
RMN-204 Respiration Monitor [6]. This enables for
the measurement of depth, and frequency of Player
breathing. Lastly, for EEG measurements, we rent
the Low-proﬁle MicroCel Geodesic Sensor Net from
Electrical Geodesics Incorporated (EGI) [8] with the
necessary software from EGI.

15

13.2.2 Saliva

Many assay techniques are available to quantify
free cortisol from saliva samples. The most common
assays are radioimmunoassay (RIA), time-resolved
immunoassay with ﬂuorometric detection (DELFIA)
and enzyme immunoassay (EIA). These techniques
rely on the principle of competitive binding between
free cortisol and reagents. Correlations betweens con-
centrations yielded from these techniques depend on
the type of population tested (clinical vs. healthy)
and on the range in concentrations assayed (Addi-
son vs. Cushing) (Raﬀ, Homar, & Burns, 2002; Raﬀ,
Homar, & Skoner, 2003) [2].

Therefore, one should use some caution and con-
sider the type of assay used when comparing values
obtained from one study to another study. The choice
of one technique over another depends not only on
the prices of the chemical kits, and availability at
laboratories, but also on the percentage of inter and
inter-
intra-assay coeﬃcient of variations. Brieﬂy,
assay variations refer to the variability related to the
assay between runs, while intra-assay variations refer
to the variability within runs. Further information
regarding assay techniques can be obtained from Dr.
Claire-Dominique Walker and Dr. Michael Meaney
[2]. With our approach, a 7 day time buﬀer is re-
quired between collecting a sample, and receiving the
results of the level of Cortisol concentrated within it.
The results are received from the supplier of the Sali-
vary test kits. Upon collection, the time of collection
is carefully recorded for each sample. This is crucial
for the time-series reconstruction of the Cortisol lev-
els. The lead time is signiﬁcant due to the lack of
salivary, and Lateral Flow Assay (LFA) expertise.

As a control, we also require participants to mea-
sure Cortisol levels for the day before testing. This is
used for comparison to the experimentation day. Fig-
ure 9 illustrates Cortisol levels for participant P03 in
the trials. It is to be noted that the participants are
not engaging in these experiments over the course of
a full day, but rather less than 2 hours. This hinders
a direct time analysis of Cortisol levels, but nonethe-
less enables a glimpse into Player stress.

13.2.3 Heart Rate

Using a Fitbit Charge ll, we monitor the Beats
Per Minute (BPMhr) within the Fitbit mobile ap-
plication for iOS. Heart Rate, unlike saliva, can be
retrieved and calculated in near real-time. Figure 10
shows participant P03’s heart rate, with associated

Department of Computer Information Systems - Georgia State University

Figure 9: Cortisol measurements for participant
P03, on the day of, and the day before experimen-
tation. Time of gameplay window is highlighted on
the day of experimentation.

hacker phases.

Figure 10: Participant P03’s beats per minute dis-
played with associated hacker phases

13.2.4 Breathing Frequency

Using the RMN-204 Respiration Monitor, we
measure the Breaths Per Minute (BPMb). The mon-
itor measures the amount of breathing occurring
within a speciﬁc timeframe, and calculates the pro-
jected BPMb. We observe faster breaths associated
with heighten levels of stress, and anxiety. Figure
11 illustrates the increase in breath frequency dur-
ing many hacker phases. Figure 11 also shows deep
breaths being taken upon the participant realizing
one of their Units have been exploited.

16

Figure 11: Shown is the breathing rate of partici-
pant P03 during Game experimentation

13.2.5 Electroencephalography

Electroencephalography is the measurement of
electrical activity in diﬀerent parts of the brain and
the recording of such activity as a visual trace (on
paper or on an oscilloscope screen). Using the Low-
proﬁle MicroCel Geodesic Sensor Net, we visualize
participant P03’s measurements in ﬁgure 12. We also
highlight the hacker phases upon which the partici-
pant is focused during the readings. We use the An-
terior - Posterior Bipolar Montage representation of
the EEG channels. We observe the participant imme-
diately after an opponent attack. We observe rapid
eye movement between the outer edges of the screen,
followed by two blinks. Previous to this time window,
we observe consecutive normal blinks. It is proposed
that the realization of the opponent attack serves as
the stimulus causing the observed eye movement. We
reference this same point in time in ﬁgures 11, and
10. Cortisol levels are not able to be this granularly
correlated due to the collection method used.

We observe increased physiological metrics fol-
lowing the instance of these eye movements. This
paper does not exhaust methods of validating such
claims.
It is a purpose of this paper to introduce
methods of monitoring Player biology, and is an at-
tempt to appeal to the richness of analytics enabled
by the proposed approach.

13.3 Metric Aggregation

We aggregate breath frequency, heart rate, and
cortisol measurements into one time-series plot. We
sync the plot by time, and highlight which hacker

Department of Computer Information Systems - Georgia State University

Figure 12: Anterior - Posterior Bipolar Montage of participant P03 immediately after an opponent ex-
ploitation

phase the participant is in at the moment. For the
Cortisol readings, we must use fewer data points, due
to the 7 day time buﬀer between saliva capture, and
result retrieval. However, this is handled by the time
recording upon sample collection. We maintain the
time synchronization between data points by super-
imposition, and scale merging. Figure 13 illustrates
the aggregated data points from these physiological
tests.

Gameplay Metrics

We formulate the metrics that are monitored
during gameplay. In this section, we highlight consis-
tency, error per minute, characters per minute, com-

mands per minute, and commands per entry.

14.1 Consistency

We highlight the behavioral consistencies that
Players exhibit, when available. Consistency only
measures the usage of speciﬁc commands, while in
certain situations. This can be a subjective measure
depending on the Game version. To measure con-
sistency, we observe the variety amongst a Player’s
commands. We do not attempt to formalize which is
better for use during gameplay. We simply observe
the type of command consistency that exists during
gameplay. It should be noted that it may not neces-
sarily be better for a Player to use diﬀerent types of

17

Department of Computer Information Systems - Georgia State University

Figure 13: The superimposition of various physio-
logical measurements through time

commands to accomplish the same thing. However,
this is subject for another research project.

14.2 Error Per Minute (EPM)

We analyze player typing errors by highlighting
frequency of "Delete", and "Backspace" appearing in
a key logger. This is indicative of a player entering
an erroneous command, or character. This can be
done by typing error, or error is logical approach, by
a Player, at a given time during gameplay. EPM is
shown in ﬁgure 14.

while typing for the purpose of gauging "keyboard
comfortability".
It is observed that both partici-
pants, P01 and P02, were able to type without look-
ing at their keyboards. P01, and P02 had a higher
average amount of CoPM, and CPM as seen in ﬁgure
15. This is in comparison to P03, of whom did not
possess the same ability.

Figure 15: cumulative CoPM and EPM, at the 15-
minute mark during experimentation for participants
P01, P02, and P03 respective

14.4 Commands Per Minute (CoPM)

CoPM keeps track of the amount of full & valid
commands a Player inputs per minute. As a pro-
grammer given the task of attacking a system, speed
is an inﬂuential metric for the eﬀectiveness of a pro-
grammer. With this in mind, the system monitors
the speed with which a Player is entering commands
into their Game environment. Visually, we plot the
amount CoPM, as a function of time. CoPM is also
shown in ﬁgure 17. We represent the set of total
commands, at a given time t, as Ct,

{Ct | Set of commands at t}

(17)

GET represents the time that has passed in the
Game, at the point in time in which CoPM is being
computed,

Figure 14: Error rate (red) visualized with com-
mands per minute (green), as calculated in equation
23, used to monitor Player behavior.

CP M holds the CoPM results. This is mentioned

for the purpose of thinking programmatically,

GET = The elapsed time passed in Game

(18)

14.3 Characters Per Minute (CPM)

CPM is keeping track of how many characters a
Player types per minute; this is important for typing
speed. It is possible to monitor Player eye position

CT S is the number of commands entered in the
most previous, 10-second window. This is only used
when calculating the CoPM in real-time, opposed to
retrospectively.

CP M = Commands per minute

(19)

18

Department of Computer Information Systems - Georgia State University

{CT S |

t−10
(cid:91)

t=0

Ct}

(20)

We observe the cardinality of CT S for the
amount of total commands entered in the last 10 sec-
onds,

| CT S |

(21)

One method of calculating CP M , is to divide the
total amount of commands, by the amount of time
elapsed during the game

CP M =

CT
GET

(22)

a second way to calculate CoPM would be to
count the amount of valid commands per every 10
seconds, and multiply by 6, meaning the amount of
10 second intervals existing within a 1 minute time
duration, or 60
10 .

CP M = 6 | CT S |

(23)

Because of the relationship between the time t
in the game, and the commands, it is implied that
their should be a method/function that performs a
computation on Time & Command, to calculate
the commands
for a given player (p). As example, it
can be as:

minute

int CMDPerMin(Time t,CMD cmd, realTime = 0){

if(realTime){

CMD[] c = CmdsByRange(t,t-10)
int numberOfCommands = sizeof(c)
return numberOfCommands * 6

}else{

CMD[] c = getTotalCMDs()
int numCMD = sizeof(c)
return numCMD / t.elapsedMins()

}

}

14.5 Commands Per Entry (CoPE)

This keeps track of the number of commands, on
average, that are chained into single terminal com-
mand entries by a Player. CoPE enables insight into
how many commands a Player is inserting as "one-
liners". This appears as player-separated commands,
typically by a semi-colon ";". This measurement en-
ables a psychological view into a Player’s behavior
and play style.

19

c

s
d
n
a
m
m
o
C

10

5

0

0

5

0
1

5
1

0
2

Time t [minutes]

Commands
m

Figure 16: The amount of commands per minute
passed in the game whereby a trough indicates a
player pause in typing action. This is captured from
participant P03 during experimentation

14.5.1 CoPE Psychology

In terms of measurable behavior, high CoPE oc-
curs when a player either already knows the eﬀect
that the given commands will have on the environ-
ment, or if they are attempting to string commands
together. A Player that is unsure about the environ-
ment is more reluctant to string multiple commands
together, unless there is a strategy as motivation.
This strategy could be aligned with wanting to see
the capabilities of a given environment, not caring
about the insertion of incorrect, or nonexistent com-
mands.

A Player that is unsure about their environment,
is more likely to step through their processes; this
is to closely observe the relationship between their
input into the environment, and the output from the
environment. This paper does not substantiate these
claims, and does not intend to do so at the current
moment. However, this will either be substantiated,
or disproven as more Games are played by various
unique Players. This has only ben observed among
the experiment Participants.

Game Versions

Due to the exploratory nature of this work, we
experiment with a myriad of Game versions. We use
both black box, and proprietary solutions. This sec-

Department of Computer Information Systems - Georgia State University

tion covers the variety of approaches, and introduces
both the positive, and negative factors of each deci-
sion.

Figure 17: Early AWS Experimental Process

Using the Amazon AWS version comes with its
own beneﬁts, challenges, and disadvantages. AWS
comes with built-in server orchestration tools. We
originally use AWS, AWS-CLI, GOLang, and Mon-
goDB, player certiﬁcates, and SSH sessions to enable
Games. This conﬁguration is conveyed in ﬁgure 17.
The problems with this proof of concept include risk-
ing a dropped SSH connection during gameplay. This
shows a need for "local" SSH sessions, and also raises
the question about the "real-world"ness of a Game,
and what should be suitable.
If we are aiming for
real-world simulation, then SSH sessions are not rare
to be dropped. For the purpose of the Game, the
Game environment could only include Player A’s lo-
cal machine, Player B’s local machine, and a Game
Server. We eventually use both local, and remote
Player environments.

As mentioned before, there is an issue of "hos-
ing" a Player’s computer, since the Game Server is
sending, and fetching data in real-time via a speciﬁc
protocol – in this case MQTT. To circumvent this

20

consumption of resources, we elevate performance on
Player servers. We enable two remote servers with
full game environment setups included (all Game de-
pendencies installed). Upon creation of a Game, the
Players are given SSH access to their servers, to which
they are expected to SSH, for the purpose of ad-
justing & augmenting their own Units, submitting
a "Capture" command, and if they just want to use
more "capable" resources. The main drawback of
this, like stated before, SSH sessions can drop at the
most inopportune moments during gameplay. This
highlights a tradeoﬀ between resiliency of gameplay,
and ease of play. However, for the actual development
of the game beyond a proof-of-concept, we choose less
predeﬁned solutions. This enables customisation of
all Game mechanics.

15.1 Player Server Locality

Another Game version involves a Game server
hosting every Unit within each opponent Realm.
This relinquishes full control of the environment to
the Game Server. Another conﬁguration involves the
remote of every Player Unit.

1. Remote

(a) Pro: Multi-device, Multi-platform

(a) Con: Player can lose connection during

Game

2. Local

(a) Pro: Organizational beneﬁt of bundle

download

(a) Con: Device throughput/resource limita-

tion

Protocol

These trials are implemented using MQTT,
which operates on top of TCP. This leads to obser-
vations of Player workstation limitations, whereby
the frequency of the packets from MQTT begin to
consume more computer resources, as the Game pro-
gresses. We test this on two, consumer grade, Mac-
book 13” laptops, and two, consumer grade, MacOS
desktop computers. The resource consumption is
consistent with at least 2 Players playing one Game.

We also propose a method of utilizing a cus-
tom protocol during gameplay. This protocol is used

Department of Computer Information Systems - Georgia State University

Figure 18: The game setup process for a centralized game structure experiment #1. Process returns
credentials needed to SSH into their player server s. This speciﬁc proof of concept used Amazon AWS, and
associated platforms.

to enable a smaller data footprint during gameplay,
leading to lower bandwidth required for base Game
mechanics. Using MQTT already uses a very small
protocol scheme. However, the data is broadcasted
very frequently, due to the nature of the protocol.
This is however conﬁgurable, but we do not exhaust
the conﬁgurations in this work. Without needing
to change MQTT’s polling nature, we can devise a
scheme to only transfer the data deemed important
for the Game to operate. Creating individual MQTT
topics for each Player, and Unit combination is a
tradeoﬀ between size of protocol overhead, and ease-
of-play on consumer devices. This is not thoroughly
covered in this work, and assumes a capable MQTT
broker server.

Unit Environments

We develop both a light-weight, and simulated
real-world implementation. The light-weight version
is mainly purposed for rapid education, and train-
ing. For competition environments with dedicated
environments, the real-world simulation emulates live
scenarios. Both versions can be rapidly deployed, and
decommissioned. In this section we highlight the key
diﬀerence between the proposed lightweight, and real-
world approaches.

17.1 Containers

Deploying the system in a containerized environ-
ment, allows the system to be played in any envi-
ronment supporting the containerization service. Us-
ing containerization allows for additional architecture
conﬁgurations without the overhead of using virtual
machines (VM). These conﬁgurations can diﬀer from

where the Game data is stored, how the Units are al-
located, and where the Units reside during gameplay.
Conﬁgurability is not unique to containerization, as
VMs are conﬁgurable as well.

We point out that deploying this system using
containers instead of VMs characterizes this Game
as a light-weight, but still dynamic simulation envi-
ronment. The light-weight categorization is due to
the notion of each Unit sharing a kernel with an-
other Unit (unikernel). This assumes each of a single
Player’s Units exist on a single host. Containeriza-
tion is conducive to educational, and training pur-
poses without unnecessary overhead.

17.1.1 Docker

This project’s light-weight implementation uses
the Docker engine [9]. We observe limitations of the
platform; most of which are not covered in this pa-
per. One substantial issue that exists when using the
Docker engine arises when the interruption of a base
process within a container occurs. For example, if we
create a container to fundamentally expose a Node JS
server, upon the forced interruption of the Node JS
process, SSH, and any further communication is hin-
dered. This project does not investigate this problem
further, but it is believed to be caused by interrupting
a process of which the container is originally gener-
ated to perform. It is to be noted that these Units are
created using speciﬁc Dockerﬁles. It is the Dockerﬁle
that conﬁgures the base processes to run inside the
Unit. We create light-weight Units with the following
structure.

docker run -d -p <port>:<port> <unit>

The port is the port upon which the base process

runs.

21

Department of Computer Information Systems - Georgia State University

17.2 Virtual Machines

18.2 Decentralized

Deployment using VMs enabled for truly isolated
environments. The beneﬁt coming from a hard parti-
tion that a CPU when using a VM. The notion of not
sharing a kernel (isokernel) also allows for an expe-
rience that resembles a real-world environment. The
tradeoﬀ to highlight here is that these isolated boxes
require more overhead on the host being used.

17.2.1 Vagrant

For the real-world simulated environment in this
project, we use Vagrant. This enables the research
team to deploy fully isolated VMs on a given host.
Using vagrant allows us to mitigate the "lost of com-
munication" problem observed with Docker. This
also enables for reliable SSH capabilities for Players.

config.vm.provision :shell, path:"start.sh",
run:"always", privileged:p

we use p, as a boolean, to denote Unit privi-
leges. The use of Docker, and Vagrant are diﬀerent,
and warrants development of separate Unit creation
processes. Again, this ultimately depends on the pur-
pose of a Game. However, the separation, and shar-
ing of kernels among Units is used as the delineation
of light-weight, and simulation.

Source of Truth

The Game mechanic has a potential for various
paradigms in terms of where the "source of truth"
lies. You can have a centralized source of truth with
a single Game Server, or you can make use of a de-
centralized source of truth by pure peer-to-peer con-
nections.

18.1 Centralized

Here we will examine the Game with a central-
ized architecture. With a centralized architecture,
you only require one Game Server. This Game Server
is a traﬃc router for Game data traveling to each
Player. Conventional CTF games adopt a central-
ized game structure. Although, conventional scoring
is diﬀerent from scoring in this proposal, a centralized
Game structure remains the same across implemen-
tations – as far as "source of truth" is concerned.

Here we will examine the Game with a decen-
tralized architecture. With a high amount of concur-
rent Players, each scoring computation is validated
by peer nodes. This enables consensus to take place
within Games. Theoretically, every Player is also a
Game Server, and thusly a "source of truth". The
disadvantages of a centralized system is the inher-
ent requirement to trust the integrity of that sin-
gle source of truth. During a physical event, with
oﬃcials present, this may not be a problem. How-
ever, once this system is being used by a high volume
of Players at one time, this requirement exposes an
integrity-based vulnerability within the system itself.
This also warrants the exploration of diﬀerent decen-
tralized Game structures.

18.2.1 Blockchain Validation

Using a Blockchain for various Game informa-
tion, the system can self-validate information, and
also validate that a speciﬁc Player sent a speciﬁc ac-
tion; similar to Bitcoin’s proof-of-work. The issue
at the time is the speed with which reliable proof-
of-work takes. The aim is to submit Player Actions
onto the ledger. This way validation happens with a
form of consensus. This is to be used during Games
In a blockchain ledger, the
with multiple Players.
blocks will fundamentally comprise of representations
(hashes) of the following:

{ timestamp: <date> <time> <timezone>,

ip: <ip address>,
playerName: <player name>,
cmds: {},
units:

[ { code: 200,

id: <unit 1 identity hash>,
health: 100,
port: <port 1> },

{ code: 200,

id: <unit 2 identity hash>,
health: 100,
port: <port 2> },

{ code: 200,

id: <unit 3 identity hash>,
health: 100,
port: <port 3> } ]

}

Each hash, along with other information,
is
stored in each block. This enables a distributed his-
tory of "transactions" within a Game. A transaction

22

Department of Computer Information Systems - Georgia State University

can be thought of as a single record of total Game
state at t. We do not explore diﬀerent consensus
algorithms for blockchain usage during peer-to-peer
gameplay, but signiﬁcant work is warranted in this
space. Figure 19 shows the Game state being stored
within a blockchain ledger. Game state includes all
properties needed for a Game, and Player commands
entered throughout the Game.

Figure 19: The storage of Game state being stored
in a blockchain ledger

18.3 Advantages

The beneﬁt of a decentralized nature is the
support for a gaming environment that is governed
by the system itself, not a central authority. Digital
history has ﬂourished with the rise of peer-to-peer
systems. The proposed system could inherent the
same traits with a decentralized structure.

18.4 Disadvantages

The problems with a decentralized structure be-
gin to arise regarding the environment dependencies
to run the system. If every Player is required to pos-
sess the same environment dependencies, in order to
run the game, additional friction is introduced to the
proposed platform’s "barrier-to-entry" for would-be
In addition, there is signiﬁcant computa-
Players.
tional overhead of which is introduced when using a
blockchain. While peer-to-peer capabilities will be
exhibited, the computational overhead will exceed
that of which consumer grade computers can handle.

The disadvantages of a decentralized architec-
ture also include the inherent validation computa-
tions that are required to take place on a given Realm

23

server. This leads to a performance issue with higher
amounts of concurrent Players, beyond two Player
Games.

Guaranteed Risk Level

This type of Game environment can easily be
dominated by top cyber security professionals, op-
posed to new participants to the ﬁeld. With this in
mind, we propose a recurring reintroduction of "equi-
value" risk into the Game mechanics. Since the Units
are randomized, we propose an additional Game me-
chanic centered around the organized decommission-
ing of Player Units, to shuﬄe a new Unit in place of
an old.

Philosophically,

if a defensive focused Player
patches all of their Units, none of their Units can
be exploited as easy as before. Depending on the
Unit details, it may not be exploitable at all besides
the network conﬁgurations denoted by the Unit at
birth. Reintroducing risk such as this, enables ongo-
ing work to be done by Players, even after securing
an asset. A goal for a Player then becomes to re-
main adaptively hardened, not just for the Player to
harden their assets. The leveling of the competitive
landscape is conducive for proper gamiﬁcation, and
adoption.

User-Computer Interface

We develop a bundled software package example
that enables real-time monitoring and scoring by cap-
turing Player typing data, Player system data, and
other behavioral metrics. This enclosed environment
allows for intricate an complex scoring mechanisms.
The tradeoﬀ is requiring users to obtain said bun-
dle in order to participate. Figure 20 demonstrates
the experimental interface. In this section, we cover
the segments of the interface, but do not dogmati-
cally require it to exist. It is introduced as a mere
convenience for the research.

20.1 Scoreboard

Throughout a competition, a player has direct
access to real-time, Game Server centered scores on
their Game Units. These metrics give universal
Player metrics, from the "source of truth", the Game
Server.

Department of Computer Information Systems - Georgia State University

originate from actual black hat actors, and their spe-
ciﬁc behaviors in given scenarios; current methodolo-
gies involve much "hard-coding" into the agent. We
use AI to demonstrate how capturing cyber security
tasks, command by command, can assist in the train-
ing of an artiﬁcial agent. We also show that upon tak-
ing a naive approach, a suitable agent can nonetheless
be constructed. This is due to the tractability of the
cyber security landscape and it is modeled here.

We take two approaches to generate an artiﬁcial
agent capable of competition. The two approaches
use, Markov Decision Processes (MDP) for proba-
bilistic reasoning about a ﬁnite, predeﬁned Game en-
vironment, and a recurrent neural network (RNN)
for character-level generation during each time step
of gameplay. We also experiment with a hybrid ap-
proach of the two.

21.1 Decision Making

Figure 22: The decision making architecture for the
proposed agent

To handle situational awareness, we model a
probabilistic approach such as a Markov Decision
Process (MDP), and a deterministic approach such
as a Finite State Machine (FSM). Either way, this en-
ables an agent to reason about some predeﬁned world.
The world of a hacker is a large, and diverse world,
but we submit that it is not only a ﬁnite world, but is
turing decidable, and tractable. Figure 22 shows the
decision making architecture using three policy net-
works, and a Markov Decision Process for command
orchestration.

Figure 20: Demonstrating the GUI exposed to each
player in the trials containing tabbed terminal win-
dow, one scoreboard, and one internet browser.

20.2 Command Terminal

Experiment participants are suggested to work
from the built-in command terminal. This enables
a full tracking of Player behavior. If a Player does
not work within the conﬁnes of the built-in command
terminal, the Player’s actions, and behaviors are com-
pletely ambiguous to the Game system. One could
require that all work be done from the proposed GUI,
but development is needed to provide the same, holis-
tic value as readily available platforms. One of which
is a penetration testing framework known as Kali
Linux. In the experimentation, we run the client on a
Kali Linux instance as well. For the experiments, we
monitor Player behavior within the proposed GUI,
and restrict work outside of it. However, we ensure
the proper usage of many industry penetration test-
ing tools.

20.3 Built-in Browser

The browser contained within the bundle allows
Players to reference internet resources from within
the experimental bundle. This is useful for Players
needing immediate answers to questions arising dur-
ing gameplay. Users can navigate to, and from arbi-
trary internet resources; we model the client to run
on both windows, and linux.

Artiﬁcial Intelligence

An additional motivation for this game is cen-
tered around the curiosity of creating an artiﬁcial
agent that is capable of acting as a dynamic hacker.
There are eﬀorts from DARPA, on using Artiﬁcial
Intelligence to train a system to hack another. How-
ever, the method used to train those systems does not

24

Department of Computer Information Systems - Georgia State University

Figure 21: Illustrating the character-level RNN using back propagation through time (BPTT) for contin-
uous next-character prediction.

21.1.1 Markov Decision Process

The ﬁrst approach taken uses a Markov Deci-
sion Process (MDP) for probabilistic reasoning in the
realm of common commands used in each phase of an
attack. We realize this can only be as advanced as
the known commands, suﬀering in autonomous cre-
ativity. This pure MDP approach is also limited by
human cognition, and creativity.

For a pure MDP implementation, we identify
common commands in each phase of an attack. The
automaton selects among possible phases, from its
current phase. The Markovian property of the sys-
tem requires that a decision at any given point in
time can only rely on information known at its cur-
rent state.

p(st+1 | st, at)

(24)

The transition probabilities describe the dynam-
ics of the world. They play the role of the next-state

function in a problem-solving search. Except that ev-
ery state is thought to be a possible consequence of
taking an action in a state. So, we specify, for each
state st and action at, the probability that the next
state will be st+1. You can think of this as being
represented as a set of matrixes, one for each action.
Each matrix is square, indexed in both dimensions
by states. If you sum over all states st, then the sum
of the probabilities that st is the next state, given a
particular state and action is 1 [10].

Once a transition phase is accomplished, the
agent selects from the predeﬁned set of suitable com-
mands in its current phase. This approach is naive,
but is suitable at progressing through a Game round.
This is due to the ﬁnite nature of permutations for
commands that exist in each phase. The ﬁrst arti-
ﬁcial agent approach only uses this MDP conﬁgura-
tion. We also use an MDP to transition between
phases for our Long-Short Term Memory (LSTM)
RNN implementation. This hybrid approach is one

25

Department of Computer Information Systems - Georgia State University

of many possible conﬁgurations, and is chosen for the
sake of this work alone.

(cid:88)

p(st+1 | st, at) = 1

(25)

We show that the sum of the probability of every
available state, at a given time step t, should equal
1.

|S| ≤ 5

(26)

In one approach, we encode a ﬁnite set of com-
mands per each hacker phase. We enable the agent
to decide which phase to enter next, and to select
among a ﬁnite set of commands for its selected time
step phase. This approach is only as useful as the
programming ﬂexibility developed into it.
It relies
on human intuition to map suitable commands, in a
predeﬁned ecosystem to preferable world-space out-
comes. Another problem is the requirement of any-
one conﬁguring this MDP, to have knowledge of state
transition probabilities in an a priori manner.

In another approach, the cardinality of the set of
phases available at each step is equal to the number
of total phases used to model the stages of an attack.
We create a FSM by modeling hacker stages, recon,
enumeration, and gaining access shown in ﬁgure 23.
It is possible to model every stage of any attack, but
this requires more development time for encoding ac-
tions in each phase. Using an MDP for the purpose
of competitive play, by itself, is a naive approach at
best. For this matter, we also propose an approach
inspired by Artiﬁcial General Intelligence (AGI). The
AGI approach, also uses an MDP for phase state de-
cision making.

26

Figure 23: The FSM structure of the agent using
an MDP

The following pseudocode explains the general
process for the proposed agent. We abstract the pro-
cesses within planning the next state, and calculating
the next command for the agent. Previous characters
entered can be considered when performing predic-
tion. Macro-level commands can also be represented
as classes, and used for prediction.

Algorithm 1 Calculating the next agent state s, at
time step t. We reference the MDP ﬁrst, then pre-
dict using the relevant policy network. The ellipsis
conveys the ﬂexibility of using either character-level,
or command-level prediction

1: function Decide(st, at)
2:
3:
4:
5: end function

S ← [∀states | s, t ]
statechosen ← argmax P lanN extState(S)
return P olicyP redict(statechosen, . . .)

(cid:46) x: state object array

21.1.2 Recurrent Neural Network using

BPTT

We initiate an agent purposed with generating
In one
terminal commands, at a character level.
implementation, the agent autonomously navigates
through each phase of an attack using an MDP. Each
phase is assigned an individual policy network, built
using an artiﬁcial neural network, of which is strictly
trained on common commands used during that re-
spective phase of an attack.

Using Back Propagation Through Time (BPTT)

Department of Computer Information Systems - Georgia State University

[1], each training iteration for the agent considers the
past impressions of past inputs. Weights are consid-
ered between time steps. We do not take into account
the previous command in time. For each policy net-
work, the output is modeled stochastically, for each
available character that can be used in a command.
Each time step takes into account the previous let-
ters typed, in the current command, and the agent’s
current state st, or the current hacker phase.

When deciding the ﬁrst character of a new com-
mand, Game metrics are taken into account. We do
not propose a formal method of using Game metrics
at this point, but we monitor the current phase in
which the agent currently exists. We also model a
knowledge-base inspired by the "5 W’s": who, what,
If an agent doesn’t known
when, where, and why.
"who" the target is, the Recon phase is probabilisti-
cally preferred. If "who" is known, but "what" the
target is, is not known, than the enumeration phase is
probabilistically preferred, and so on. This is an ar-
bitrary, and naive approach towards a Game speciﬁc
knowledge base. However, it illustrates the capabil-
ity of formulating an example agent. These factors
enable for a tractable world view for the Markovian
agent.

21.2 Kali Linux

Using Kali Linux, we utilize many tools to initi-
ate attacks on target machines. The following is one
example of a common command used in the "enu-
meration" phase of an attack.

nmap <parameters> <ip or domain>

In the "gaining access" phase, an agent can
blindly ﬁre every exploit available in Metasploit, or
craft custom packets. Both approaches used war-
rant varied uses of metasploit at diﬀerent times. For
the MDP, we construct a ﬁnite state machine (FSM)
using common commands in Kali Linux. The com-
mands are categorized, by their purpose, into their
respective hacker phases.

For character-level generation, training occurs
with Kali Linux speciﬁc commands only. For the hy-
brid approach using RNNs, we create a FSM pur-
posed with switching between modes, representing
phases of an attack. We generate policy networks,
of which are trained with commands speciﬁc to each
phase. The agent reasoning within each phase is then
generated on a character level.

21.3 Simulation Training

Training only occurs for the RNN approach. We
utilize human subjects to train each policy network
with the phases of an attack chosen. Strictly, subjects
input penetration test commands used for the respec-
tive phase undergoing training. This paper does not
highlight the variety among commands used to train
the networks, in each phase. However, the usage of
Kali Linux’s toolset enables a high variety of com-
mand availability.

21.4 Data Capture

In equation 23, we show how to calculate a users
eﬀective CoPM. We can use the same capturing tasks
from the system to generate other metrics. We create
a knowledge base consisting of the command that a
Player commits, the scenario in which it is commit-
ted, and the outcome of the Player action. We also
experiment with an agent that does not receive any
feedback beyond that of knowing whether or not a
used command is valid. The agent that does not
receive feedback is solely purposed with generating
character-level predictions based on previous charac-
ters used, and the phase with which it exists at a
given time t.

21.4.1 Command Capturing

One of the beneﬁts of providing a work environ-
ment for Players is the ease with which command
capturing can be accomplished. Every time a Player
presses "enter" in their terminal window, the char-
acters they type are captured, with their ordering
recorded. We also capture character level data. Upon
the pressing of a key, the system logs it. We then re-
construct commands when needed. This is also how
EPM is monitored, as covered before. If a user presses
any special representation of entering a command, it
is taken into account. This is similar to pressing an
"up" arrow, or "!!", both to refer to the last com-
mand entered. The following is the command shown
in ﬁgure 23. It is used to enumerate a target machine.

nmap -Pn 192.168.10.2

If we calculate the hamming distance between
the previous command, and the current, we can mon-
itor diﬀerences in commands. This is not formally
included in any experimentation, but enables an ad-
ditional perspective on gameplay per each command.
The following is a snippet to calculate the hamming

27

Department of Computer Information Systems - Georgia State University

distance between two commands, which are just of
the standard String data type:

each command. This is the case if the Game envi-
ronment is fully observable. The set of all possible
characters is denoted by CH

def hamming_distance(c1, c2):

if len(c1) != len(c2):

raise ValueError("Unequal length")

return sum(el1 != el2 for el1,

el2 in zip(c1, c2))

21.5 Feature Selection

We model our feature selection eﬀorts to account
for each letter that can be inputted into a terminal
window. Representing each possible character as a
class. We abstract away the use of "targets", such
as IP Addresses; these are inputted in whole using
predeﬁned ﬂags. For character-level generation, this
introduces a problem of knowing the accurate param-
eters that belong to commands. To input a target
IP Address during a generated command is another
problem to be solved. It is one problem to learn ter-
minal commands by character, but another to do so
by abstracting away the use of parameters.

To abstract the problem away, we assign a binary
class to represent "IP Address". As a data struc-
ture, this feature represents the occurrence of an IP
Address. This ensures that an agent can ignore all
characters indicating an IP Address, or variable tar-
get. The agent can then keep track of whether or
not it should insert the target IP Address as a "next
character".

21.6 Policy Networks

We generate policy networks for each stage in the
phases of an attack covered in the previous Gameplay
section. This gives us a separate neural network ar-
chitecture for each phase. Each policy network maps
previous character input, to next character input. We
combine this with an MDP to handle the decision of
the next state selection. While in a given state, the
policy network outputs the probability for each pos-
sible character, of which the most likely character in
selected as "next".

This process continues until a command should
be entered. We also generate a policy network for
determining the "end" of a proposed command that
checks for the "validity" of a submitted command.
Variable information, and parameters in each com-
mand are not used during training. This translates
to the removal of all domain, and IP addresses from

{CH | A, B, 0, 9, −, !, . . . chn}

(27)

The sum of all of the probabilities of the next
character is equal to 1. The agent probabilistically
considers all possible characters,

cch ∈ CH,

| CH |
(cid:88)

ch=1

p(cch) = 1

(28)

We can then interchange one policy network’s
output for another’s input. This is subject for an
entire paper, but we make note of combining the pre-
vious output from a "Recon" stage command, into
the input for a "Gaining Access" phase computation.
This is an attempt to add contextual awareness to
the LSTM-RNN process. We use Tensor Flow [11]
for all AI work.

21.6.1 Recon Network

The Recon policy network is trained on Recon
speciﬁc tasks. Among these tasks include scraping
target web applications, and accessing publicly avail-
able information. Even though "Google" scraping is
developed into the proposed agent, this is not useful
during matches against a regular Player. There is no
information that an agent can discover on the public
internet that is conducive to victory against a con-
ventional opponent. We train the Recon Policy net-
work on commands from platforms like "Curl", and
"Scrapy". This enables a network for pure Recon
tasks. Although there is a thin line between Recon,
and Enumeration, we purposely delineate the two for
this work.

21.6.2 Enumeration Network

Following the pattern, the Enumeration Policy
network is trained on commands from platforms like
"nmap", "netcat", "hping", and other enumeration
tools that exist within Kali Linux. The Enumeration
network can retrieve information of which the Recon,
and Access network commands cannot. Due to each
network being trained independently, this is true for
each network.

28

Department of Computer Information Systems - Georgia State University

21.6.3 Access Network

The last Policy network trained is that for Gain-
ing Access. There are many tools that exist in Kali
Linux to accomplish this, and we train the network
on all of them that are available. We also enable the
capability for the agent to probabilistically launch ev-
ery attack technique known to Kali Linux. This can
be thought of as a "hail mary" approach, and is used
as a last resort.

21.7 Outcome Analysis

An agent can learn on every command upon
command submission, or at the end of Game. In both
cases the Agent creates a map between the charac-
ters used in the command, and an outcome. The two
approaches diﬀer in outcome used. For this work,
we use a combination of monitoring the Game envi-
ronment diﬀerently, including the "health" of Game
Units for character-level validity checks.

21.7.1 Command Outcome Analysis

If an agent is to learn on each command, the out-
come to map can be the health of the Player’s Units.
However, this implementation is too ambiguous for
learnability. We examine further metrics from the
environment of which to use during modeling.

21.7.2 Game Outcome Analysis

To learn on the outcome of a Game, the agent
creates a map between all commands used during the
Game, and whether or not the Player "Wins". This
yields a binary outcome, of which we represent as
If the agent loses a given Game, it
the set {0, 1}.
will penalize every action taken during the Game by
the penalty rate, α. This can skew correct actions in
the wrong direction, but the assumption is that with
enough rounds of gameplay, on average, the correct
decision can be made easier by the agent.

Physical Apparatus Extension

This project implies that such a Game system
can be combined with real-world, physical actuators
in the service of creating an additional layer of enter-
tainment around the core Game concepts. It is not
the aim of this paper to identify such conﬁgurations.
However, it is implied that the proposed system en-
ables a physical augmentation. The use of physical

augmentation of these Game mechanics causes the
system to resemble a modern TV Game Show pro-
gram.

Further work

One evident factor of this work is the strict phys-
iological testing on male gendered participants. We
look to iterate upon this work using a female audi-
ence. Another factor upon which we would like to
iterate is the type of scoring mechanism around ex-
ploiting a system. We only take into account exploits
that enable remote code execution. Since we model
Units with a property known as "health", it skews
the type of scoring mechanism quite a bit. Without
the notion of "health", one could even more closely
examine the characteristics of XSS, or SQL Injection.
These may require more dependencies for the system,
and more development of speciﬁc scoring capabilities.
The vast landscape of vulnerability types, and ex-
ploitation types warrant more research in the realm
of suitable scoring mechanisms.

We also propose more work to be done in the
realm of Artiﬁcial Intelligence. Though the proposed
approach is reliable, there exists a plethora of tech-
niques that can be used for this work. As AI evolves
over time, this should be a continuous topic of discus-
sion, as this work brings science closer to AGI capable
of penetration testing a myriad of diverse systems.

Furher work is warranted to visualize Player
physiological metrics in real-time.
It is understood
that many of the methods used in this paper provide
challenge towards this goal.

Conclusion

In conclusion, this article introduces a new
paradigm of competitive, head-to-head cyber war-
fare. We demonstrate a real-time system capable of
handling the demands of such a system. Player per-
formance is also monitored during game play by an-
alyzing Player eﬃciency, and physiological metrics.
Lastly, we demonstrate multiple approaches in the
pursuit of developing an artiﬁcial agent capable of
participating in the proposed framework, but playing
at a competitive level based on previously recorded
gameplay rounds.

29

Department of Computer Information Systems - Georgia State University

[12] Melissa Lau, Li Wang, Sari Acra, Maciej S.

Buchowski
Energy Expenditure of Common Sedentary
Activities in Youth

[13] Andrej, Karpathy

The Unreasonable Eﬀectiveness of Recurrent
Neural Networks
http://karpathy.github.io/2015/05/21/rnn-
eﬀectiveness/

References

[1] Guo, Jiang

BackPropagation Through Time.
2013, HIT Social Computing and Information Re-
trieval Research Center

[2] Fernand-Seguin Research Centre
How to measure stress in humans
Centre for Studies on Human Stress

[3] Seoyeon Choia, Soocheol Kimb, Jung-Sik Yangb,
Jung-Hyun Leeb, Chulmin Joob, Hyo-Il, Junga
Real-time measurement of human salivary cor-
tisol for the assessment of psychological stress
using a smartphone

[4] Geertruida A. Posthuma-TrumpieJakob Kor-

fAart van Amerongen
Lateral ﬂow (immuno)assay: its strengths, weak-
nesses, opportunities and threats. A literature
survey
Analytical and Bioanalytical Chemistry

[5] Standards for Security Categorization of Federal

Information and Information Systems
Computer Security Division Information Technol-
ogy Laboratory National Institute of Standards
and Technology

[6] iWorx Systems, Inc.

RMN-204 Respiration Monitor

[7] Adrenocortex Stress Proﬁle

https://www.gdx.net

[8] Low-proﬁle MicroCel Geodesic Sensor Net

https://www.egi.com

[9] The Docker Organization
https://www.docker.com

[10] Lozano-Perez, Tomas, and Kaelbling, Leslie

Techniques in Artiﬁcial Intelligence (SMA 5504)

[11] Alphabet, Inc

Tensor Flow Deep Learning Framework
https://www.tensorﬂow.org

30

