Distortion based Light-weight Security for Cyber-Physical Systems

Gaurav Kumar Agarwal(cid:63), Mohammed Karmoose(cid:63), Suhas Diggavi, Christina Fragouli, Paulo Tabuada
Department of Electrical and Computer Engineering, UCLA, Los Angeles, USA
Email: {gauravagarwal, mkarmoose, suhasdiggavi, christina.fragouli, tabuada}@ucla.edu

0
2
0
2

n
u
J

5
2

]
T
I
.
s
c
[

1
v
8
9
9
5
1
.
6
0
0
2
:
v
i
X
r
a

Abstract

In Cyber-Physical Systems (CPS), inference based on communicated data is of critical signiﬁcance as it can be used to
manipulate or damage the control operations by adversaries. This calls for efﬁcient mechanisms for secure transmission of data
since control systems are becoming increasingly distributed over larger geographical areas. Distortion based security, recently
proposed as one candidate for secure transmissions in CPS, is not only more appropriate for these applications but also quite frugal
in terms of prior requirements on shared keys. In this paper, we propose distortion-based metrics to protect CPS communication
and show that it is possible to confuse adversaries with just a few bits of pre-shared keys. In particular, we will show that a linear
dynamical system can communicate its state in a manner that prevents an eavesdropper from accurately learning the state.

I. INTRODUCTION

Wireless networked environments are a natural host for a number of cyber-physical control applications, ranging from
autonomous cars and drones, to the Internet-of-Things (IoT), to immersive environments such as augmented reality. It is well
recognized that wireless networking is essential to realize the potential of new CPS applications, and is equally well recognized
that private and secure exchange of information are necessary and not simply desirable conditions for the CPS ecosystem to
thrive. For instance, personal health data in assisted environments, car positions and trajectories, proprietary interests, all need
to be protected. This paper introduces a new approach to secure communication in CPS, that aims to distort an adversary’s
view of a control system’s states. In particular, we will show that a linear dynamical system can securely communicate its state
to a trusted party in a manner that prevents a malicious adversary eavesdropping the communication from accurately learning
the state.

Our starting observation is that information security measures (cryptographic and information theoretic secrecy), are not
well-matched to CPS applications as they impose unnecessary requirements, such as protecting all the raw data, and thus can
cause high operational costs1. To illustrate this, we start by comparing existing techniques for ensuring CPS privacy, namely
cryptographic and information-theoretic techniques. Cryptographic methods rely on computational complexity as a guarantee
for the security of the underlying CPS, i.e., the system is secure against computationally-limited adversaries. Cryptographic
methods are universal and therefore are easy to integrate in any system under consideration. However, some of their shortcomings
are: 1) they do not provide guarantees against adversaries with unlimited computational power (e.g., quantum adversaries), 2)
they utilize computationally-heavy encryption/decryption algorithms, and 3) they come at the cost of high overhead on short
packet transmissions, therefore increasing delays [2]–[6]. In fact, those techniques have been previously studied in the context
of secure CPSs. For example, homomorphic encryption [7]–[9] and public-encryption systems [10] have been used to provide
security of networked control systems. Alternatively, information-theoretic methods rely on keys: they have low complexity
and do not add packet overhead, but require the communicating nodes to share large keys - every communication link needs
to use a shared secret key (for a one-time pad) of length equal to the entropy (effectively length) of the transmitted data [11],
[12]. These costs accumulate rapidly given that large CPS applications can have dense communication patterns.

Instead, we propose a lightweight approach which provides security guarantees against computationally-capable (i.e., with
unlimited computational power) adversaries, and uses small amounts of keys and low complexity operations. The main
observation behind our approach is the following. Consider a general encryption scheme which uses a K-bit key to encrypt the
states of a dynamical system. From an abstract point of view, such a scheme hides the true value of the state among a set of 2K
states; without knowing the value of the key, an outside observer of the encrypted state cannot resolve the ambiguity among
these fake states – we refer to this set as the ambiguity set. General encryption (e.g., cryptographic or information-theoretic)
schemes aim at increasing the size of the ambiguity set. Differently, in CPS applications, increasing the size of the ambiguity
set may not be effective if all of these states are close to each other in a metric space. To make this idea concrete, assume an
adversary is trying to locate a drone in order to shoot it down with one missile in its possession. If a K-bit encryption scheme
is used, the adversary would ideally have a set of 2K possible locations for the drone – any set of 2K possible locations are
equivalent from an information-theoretic security point of view. However, if all locations are in close proximity, an adversary

(cid:63)Co-ﬁrst authors.

This work was partially supported by NSF grant 1740047, by NSF grant 1705135, by the Army Research Laboratory under Cooperative Agreement W911NF-
17-2-0196, and by the UC-NL grant LFR-18-548554. A preliminary version [1] of the results in the submitted manuscript was presented at the 57th Conference
on Decision and Control (CDC), 2018. This manuscript contains new results not present in the CDC paper (Section-IIIB, Section IV, and Section VI), extended
proofs, and additional examples.

1Our work focuses on security against passive adversaries – alternatively referred to in the literature as CPS Privacy.

 
 
 
 
 
 
Figure 1: Example of drone motion: protection of the most signiﬁcant bit.

can possibly shoot the missile and hit the target regardless of the actual location. On the other hand, a different encryption
scheme which uses only 1 bit of information, but instead carefully chooses the two possible locations to be far apart, would
be more secure against such an adversary. We therefore propose a distortion measure in order to capture this idea.

The following example illustrates the effect of maximizing distortion2. Consider the following simple example of a drone’s
ﬂying motion, depicted in Fig. 1. The drone starts at any position, and moves between adjacent points within the grid. It
regularly communicates its location to a legitimate receiver, Bob. A passive eavesdropper, Eve, wishes to infer the drone’s
locations, and can perfectly overhear all the transmissions the drone makes. We assume the drone and Bob share just one bit
of key, that is secret from Eve, and ask: what is the best use we can make of the key?

Using the one bit of shared key to protect the most signiﬁcant bit (MSB) is not a good solution. The MSB can be protected
by XORing a one bit of shared key with the MSB. As shown in Fig. 1 the adversary can discover the fake trajectory after a few
time steps since this scheme leads to trajectories that do not adhere to the dynamics or environment constraints. In particular,
the fake trajectory abruptly moves from the left end of the grid to the right end. At this point, the adversary can learn the real
trajectory by ﬂipping back the MSB (we assume that the used scheme is known to everyone). Similar attacks can be made if
we use a one-time pad [11] using the same keys over time: as time progresses, more fake trajectories can be discovered and
discarded.

Conventional entropy measures also fail to provide insights on how to use the key. For instance, assume we label the 64
squares in Fig. 1 sequentially row per row, and consider two cases: in case I, Eve learns that the drone is in one of the
neighboring squares {1, 2}, each with probability 1/2. For case II, Eve knows that the drone is in one of the squares {1, 64},
again each with probability 1/2. Both cases are equivalent from an information security perspective since in both cases Eve’s
uncertainty is a set of two equiprobable elements and hence its entropy is 1. However, the security risks in both situations are
different. For example, if Eve aims to take a photo of the drone, in the ﬁrst case she knows where to turn her camera (squares
1 and 2 are close by) while in the second case, she does not (squares 1 and 64 are far apart).

Instead, we propose to use an Euclidean distance distortion measure: how far (in Euclidean space) is Eve’s estimate from
the actual location. We then propose encoding/decoding schemes which utilize the shared key to maximize this distance. We
ﬁrst consider an “average” distortion measure. Note that if Eve had not received any of the drone transmissions, then the best
(adversarial) estimate of the drone’s location at any given time is the center point of the conﬁned region in Fig. 1. Therefore, a
good encryption scheme would strive to maintain Eve’s estimate to be as close to the center point as possible; and we achieve
the maximum possible distortion, if, after overhearing the drone’s transmissions, Eve’s best estimate still remains the center
point.

The following scheme can achieve this maximum distortion by using exactly one bit of shared secret key. When encoding,
the drone either sends its actual trajectory, or a “mirrored” version of it, depending on the value of the secret key. The mirrored
trajectory is obtained by reﬂecting the actual trajectory across a mirroring point in space; in this example, the mirroring point
is the center point in Fig. 2. Since Eve does not know the value of the shared key, its best estimate of the drone’s location -
after receiving the drone’s transmissions - would be the average location given the trajectory and its mirrored version, which
is exactly the center point.

Our results in Section III extend this idea of mirroring to more general light-weight mappings for dynamical systems in
higher dimensional spaces, and theoretically analyze the performance in terms of average distortion for a larger variety of
distributions (with certain symmetry conditions). We also discuss a class of systems and controllers for which we can always
achieve the perfect distortion with just one bit of key.

Next, we consider a worst-case-sense distortion-based metric. In other words, our security metric is “in the worst case, how
far is Eve’s estimate from the actual location?” That is, the adversary’s distortion may be different for different time instances

2Although we illustrate our approach for a speciﬁc simple example, it extends to protecting general system states.

Figure 2: Example of drone motion: mirroring based scheme.

and different instances of the actual trajectory, and we are interested in the minimum among these. For example when the
drone is near the origin, both the actual and fake trajectory are close to origin and thus the adversary knows that the drone is
near the origin. In this case, the overall (expected) distortion for adversary is still maximum, but at this particular instance of
time, the adversary comes very close to the actual position. In Section V we provide encryption schemes that are suitable for
maximizing this distortion metric and show that with 3 bits of shared key per dimension (i.e., 9 for three dimensional motion),
our schemes achieve near-perfect worst case distortion. Our main contributions are as follows:
• We deﬁne security measures that are based on assessing the distortion: in the average sense over time and over data, and in
the minimum sense, providing worst case guarantees at any time and for any particular instances of data.
• For the expected distortion, we develop a scheme which uses exactly one bit of key and can provide maximum possible
distortion (equivalent to Eve with no observations) in some cases. We also discuss the cases where it is not optimal and give
an analytical characterization of the attained distortion. We then discuss a class of systems and controllers for which we can
always guarantee the perfect distortion with just one bit of shared key. Since for some applications an ambiguity set of size
two (corresponding to one bit of key) may not be enough, we also derive an expression of attained distortion when we use
larger keys.
• For the worst case distortion, we design a scheme that uses 3 bits of key per dimension and prove it achieves the maximum
possible distortion (equivalent to Eve with no observations) when the inputs to the systems are independent from the previous
states.
• For linear control systems, we provide a relation between the distortion in inputs to the distortion in states. This is particularly
useful when inputs are easier to distort and analyze compared to the states.

A. Related Work

Secure data communication where the adversary has unlimited computational power is studied from the lens of information
theory, most notably by Shannon [11] and Wyner [13]. The study of secure communication while using distortion as a
measure of security is relatively new and is ﬁrst studied by Yamamoto [14], where the goal is to maximize the distortion
of an eavesdropper’s estimate on a message, viewed from an asymptotic (in block length) information-theoretic approach.
Schieler and Cuff [15] later showed that, in the limit of an inﬁnite block length n code, only log(n) bits of secret keys are
needed to achieve the maximum possible distortion. The idea of using ﬁnite block length (and even single-shot) distortion as
a performance measure was initiated in [16], where schemes for single shot communication were considered. It demonstrated
the exponential beneﬁts for each additional bit of shared key. The schemes examined were for single-shot sensor observations,
and not for time-series data, which is the focus of our work in this paper.

Secure communication in control systems is studied in [17]–[21]. Securing the system state from an adversary was explored
in [17], [18], where an asymptotic steady-state analysis was explored. In contrast our work also deals with transients and
is not asymptotic. Information-theoretic security was explored in [19], where the mutual information was used as a privacy
measure. Security of the terminal state is considered in [20] where an adversary makes partial noisy measurement of the state
trajectory. Securing the states of an unstable system has been considered in [22] where the notion of secure capacity was used
to characterize the level of secrecy against an adversary connected through a wiretap channel. Differential privacy for control
systems was explored in [21], which uses standard statistical indistinguishability which is equally applicable to categorical
(non-metric space) data; in our work, we use the estimation error of the adversary in order to quantify privacy, utilizing the
fact that CPS data lies in an Euclidean space, as argued earlier.

Actual TrajectoryMirroring Point(Center)Mirrored TrajectoryB. Notation

For a matrix A, we denote by A(cid:48) and AH the transpose and complex-transpose of A, respectively; by Ar the r-th power
of A; X and Xa denote column vectors, and X b
b](cid:48) for b ≥ a and a, b ∈ Z; fX (x) denotes the probability
a+1 · · · X (cid:48)
density function of a random vector X; for any random vector Y , we denote the mean and covariance matrices of Y by µY and
RY respectively, thus for example, the mean and the covariance matrix of X b
respectively;
by [m] we denote {1, 2, . . . , m} where m ∈ Z+; and by [m1 : m2] we denote {m1, m1 + 1, . . . , m2} where m1, m2 ∈ Z+
and m2 > m1; a negative sign (−) in the superscript of a function indicates the inverse of the function, i.e., the inverse of the
functions α(x) and α(K)(x) are α−(x) and α−(K)(x) respectively.

a will be denoted by µX b

a = [X (cid:48)

and RX b

a X (cid:48)

a

a

A. System Dynamics

We consider the linear dynamical system,

II. SYSTEM MODEL

(cid:101)Xt+1 = A (cid:101)Xt + BUt + wt,

Yt = C (cid:101)Xt + vt,

(1)

where (cid:101)Xt ∈ Rn is the state of the system at time t ∈ N, Ut ∈ Rm is the input to the system at time t, wt ∈ Rn is the process
noise, Yt are the system observations, and vt ∈ Rp is the observation noise. We denote (cid:101)X T
by
w. Based on the initial state (cid:101)X1 and target state (cid:101)XT , the controller computes a sequence of inputs that moves the state from
initial state (cid:101)X1 to the target state (cid:101)XT in T time instances. We assume that the system uses the obsevations Y T
to optimally
1
estimate the states (cid:101)X. The optimal estimates of (cid:101)X made by the system are denoted by X – in the case of perfect observation,
i.e., noiseless and observable systems, then X = (cid:101)X.

1 by (cid:101)X, U T −1

by U and wT −1

1

1

B. Communication and Attacker/Defender Models

At each time instance the system (Alice) transmits information about its state estimate to a legitimate receiver, which is
referred to as Bob, via a noiseless link. This situation occurs for example when Bob is remotely monitoring the execution of
the system as in Supervisory Control And Data Acquisition (SCADA) systems or in the remote operation of drones.
Attacker Model. A malicious receiver, referred to as Eve, is assumed to eavesdrop on the communication between the system
and Bob and is able to receive all transmitted signals. The goal of Eve is to make an estimate that is as close to X as
possible: since Bob receives X and makes control decisions with this information, Eve is interested in X. We assume that
Eve knows: 1) the encoding/decoding functions used by Alice and Bob, 2) the dynamical system and 3) the controller design.
This information automatically implies knowing the prior probability distributions on the input and state vectors. With this
information set, we assume that Eve uses the most adversarial eavesdropping strategy: one which minimizes our performance
metric (see Section II-E). Eve is assumed to be passive: she does not actively communicate but is interested in learning the
system’s states from t = 1 to T .
Defender Model. We assume that Alice and Bob have a shared k-bit key K which they use to encode/decode the transmitted
messages. For a given encoding/decoding function, the assumed Eve adopts the most adversarial eavesdropping strategy
(from the perspective of our chosen performance metric). Therefore, we assume that Alice/Bob attempt to design their
encoding/decoding functions which optimize this worst-case performance. We elaborate more on that in Section II-E.

C. Inputs and States Random Process Model

We assume that both receivers are only aware of the system model, the matrices A, B, C and the statistics of noises.
Therefore, from the perspective of the receivers, the input and output sequences have random distributions which depend on
A, B, C and the statistics of the noise. In addition to the process noise w, the joint distribution f (X, U, w) depends on i) the
initial and target states, ii) the control law of the system and iii) the state estimation process. So, even in noiseless systems,
X and U possess inherent randomness from a receiver’s perspective due to its lack of knowledge about the initial and target
states.

D. Encoding Model

The system encodes and transmits packets Z T

1 , the optimal estimates
of the system. To do so, the system transmits a packet Zt at each time step t. In this work, we use light-weight memoryless
encryption schemes. The t-th transmitted packet is a function of only the current state estimate and the shared keys, thus,
Zt := Et(Xt, K), where Et is the encoding function used at time t. We will denote Z T

1 to ensure that Bob is able to accurately receive X T

1 by Z.

E. Bob/Eve Models of Decoding

Bob noiselessly receives the transmitted packets from the system, and decodes them using the shared key. Then, using the
decoded information, it generates an estimate of the state of the system at times t ∈ [T ]. We require that Bob’s estimate is as
accurate as Alice’s. If we assume that, at time t ∈ [T ], Bob’s decoding function is Γt (Z t
1, K), then the previous condition is
satisﬁed by ensuring that Γt (Z t
1, K) = Xt for all t ∈ [T ].

Similarly, Eve also receives all transmissions from the system. However, unlike Bob, she does not have the key K. Therefore,

Eve’s estimate of Xt is ˆXt := φt

(cid:0)Z T

1

(cid:1) , t ∈ [T ], where φt is the decoding function used by Eve at time t.

F. Distortion Metrics

We consider a distortion-based security metric which captures how far an estimate is from the actual value. In particular,
our analysis is based on the Euclidean distance as our distance metric. However, our analysis can be extended to any p-norm,
since other norms are just a constant factor away, i.e., (cid:107)X(cid:107)p ≤ n
q (cid:107)X(cid:107)q. We assess the performance of Eve as how far its
estimate ˆX, is from Alice’s estimate X. Formally, for a given time instance t and a transmitted codeword Z T
1 , we deﬁne the
following quantity,

p − 1

1

D(t, Z T

1 ) := EXt|ZT

1

(cid:13)
(cid:13)Xt − ˆXt
(cid:13)

(cid:13)
(cid:13)
(cid:13)

2 (a)

= tr

(cid:16)

RXt|ZT

1

(cid:17)

,

(2)

where (2) captures the distortion incurred by Eve while estimating Xt for transmitted symbols Z T
because the best (minimizing) estimates of Eve at time t are, ˆXt = φt
Note that Bob is required to successfully estimate Xt knowing Z t

1 and the key. Therefore, for a given realization of the key,
the encoding function can only map one Xt and that key realization to each value of Z T
1 . Therefore Eve realizes that only
trajectories from a particular subset can be the true trajectory for a given Z T
1 : those are the ones which correspond to each
key realization. Therefore, the expectation in (2) is in fact taken over the randomness in the key taking into account posterior
probabilities given Z T
1 . If Eve does not have observations, the expectation is taken over Xt with prior distribution and we get
D(t, Z T
1 ) = tr(RXt).

1 . Equality in (a) follows

(cid:1) = E (cid:2)Xt|Z T

(cid:0)Z T

(cid:3) .

1

1

As D(t, Z T

1 ) is a function of time t and the transmitted sequence Z T

“average case” distortion (denoted by DE) where we take expectation over all possible Z T
the “worst case” distortion (denoted by DW ) where we take minimum over all possible Z T

1 , we consider two overall distortion metrics: the
1 and average out over time; and
1 and time instances.

Average
Distortion

Worst Case
Distortion

(cid:34)

− DE := EZT

1

− DW := min
ZT
1

T
(cid:88)

t=1

1
T
(cid:20)

min
t∈[T ]

(cid:35)

D(t, Z T
1 )

D(t, Z T
1 )

(cid:21)

.

(3)

(4)

It is worth to note that the deﬁnitions of DE and DW in (3) and (4) imply that Eve’s state estimation must be associated
to a time instance. In other words, making a random/constant estimate of the state hoping that it matches the actual state at
some time will lead to high distortion values. Further, DW can be deﬁned even when there is no prior distribution on X T
1 .
However, to provide a baseline comparison with the case when the adversary has no observations, we assume that X T
1 always
have a known prior distribution.

G. Design Goals

Our goal is to choose the encoding and decoding functions, Et and γt, so that Bob can decode loselessly while the distortion
is maximized for Eve’s estimate. In addition, we seek to achieve this with the minimum amount of shared keys K. In absence
of any observation by Eve, these distortions will be,

Dmax

E =

1
T

T
(cid:88)

t=1

tr(RXt),

These will serve as upper bounds as,

DE =

1
T

EZT

1

T
(cid:88)

tr(RXt|ZT

1

t=1

(a)
≤

)

1
T

T
(cid:88)

t=1

Dmax

W = min
t∈[T ]

tr(RXt).

tr(RXt) = Dmax
E ,

(cid:104)
tr(RXt|ZT

1

(cid:105)
)

DW = min
ZT
1

min
t∈[T ]

tr(RXt|ZT

1

) ≤ min
t∈[T ]

EZT

1

(b)
≤ min
t∈[T ]

tr(RXt) = Dmax
W ,

where (a) and (b) follows from EZT

1

(cid:2)tr (cid:0)RXt|Z T

1

(cid:1)(cid:3) ≤ tr (RXt) which follows from the law of total variance.

(5)

(6)

III. OPTIMIZING AVERAGE DISTORTION DE
In this section, we will ﬁrst discuss schemes to optimize the Average Distortion (DE). We will initially analyze encoding
schemes which use one bit of secret key, and characterize their attained level of distortion. We then show that such schemes
attain the maximum level of distortion for a family of distributions on X which exhibit a certain class of symmetry. Later we
describe how this analysis extends to the use of multiple keys, as for some application having an ambiguity set of size two
might not be enough.

A. Encoding Schemes with 1-bit Shared Secret Key

We now discuss encoding schemes that use one bit of shared key and show how the achieved distortion compares to the

upper bound in (5). These encoding schemes work as follows:

Zt =

(cid:26) Xt

αt(Xt)

if K = 0,
if K = 1,

∀t ∈ [T ],

(7)

where K ∈ {0, 1} is the shared bit and αt(Xt) is a transformation of the state vector Xt. We will next show the attained
distortion of such schemes.

Theorem III.1 (Proof in Appendix VIII-A). The average distortion (DE) attained by using the scheme in (7) is,

where f α−(X) := [α−

1 (X1)(cid:48) α−

T (XT )(cid:48)](cid:48). Moreover, if the following condition holds,

t=1
2 (X2)(cid:48) · · · α−

1
2T

(cid:26)

T
(cid:88)

EX

fX (α−(X))
fX (X) + fX (α−(X))

(cid:13)
(cid:13)Xt − α−

2(cid:27)
t (Xt)(cid:13)
(cid:13)

,

then the expression simpliﬁes to

fX (x) = fX (α−(x)),

for all x ∈ X ,

DE =

1
4T

T
(cid:88)

t=1

EX (cid:107)Xt − αt(Xt)(cid:107)2 .

(8)

(9)

(10)

Condition (9) implies a general notion of symmetry in the distribution of fX (x). In the following, we focus on a particular
notion of distribution symmetry, for which we show the corresponding choice of αt(Xt) and how it can achieve high levels
of distortion. Consider a transformation function αt(x) which reﬂects a point x across an afﬁne subspace of dimension d,
deﬁned by the equations Stx = bt where St ∈ Rd×n consists of d ≤ n orthonormal rows, and bt ∈ Rd; the transformation
is αt(x) = (I − 2S(cid:48)
tbt. The choice of the dimension d and the subspace (St, bt) depend on the properties we
would like the encoded trajectories to have. We refer to encoding schemes that are based on this transformation as mirroring
schemes. For example, consider Xt ∈ R2 where St = 1√
[−1 1] and bt = 0. Then αt(Xt) corresponds to mirroring across a
2
line that passes through the origin with a 45◦ angle. This is shown in Fig. 3. We are interested in mirroring schemes as they
are light-weight and can be implemented on low-complexity IoT devices. Moreover, such schemes can provide the maximum
distortion level for a class of distributions with what we refer to as Point Symmetry.

tSt) x + 2S(cid:48)

Deﬁnition III.1 (Point Symmetry). A random vector X is said to have Point Symmetry if there exists a point v for which
fX (x) = fX (2v − x), ∀x ∈ X .

Lemma III.2. If X has Point Symmetry across v, then v = µX .

Proof: Since X has Point Symmetry, then

⇒

fX (x) = fX (2v − x)
µX = 2v − µX

⇒

⇒

fX (x) = f2v−X (x)

µX = v.

(cid:4)
The following result characterizes the performance of the mirroring scheme, and shows that it achieves the maximum

distortion for distributions with Point Symmetry.

Corollary III.3. If αt(Xt) is based on a mirroring scheme along the planes given by Stx = bt, t ∈ [T ] and the condition (9)
holds, then (10) becomes,

DE =

1
T

T
(cid:88)

i=1

tr (StRXtS(cid:48)

t + (bt − StµXt)(bt − StµXt )(cid:48)) .

(11)

Moreover, if X has Point Symmetry, then DE = 1
T

T
(cid:80)
t=1

tr(RXt), the maximum possible distortion.

Figure 3: Mirroring across the line passing through the origin and having a 45◦ angle with the X-axis.

T
(cid:80)
t=1
T
(cid:80)
t=1

Proof: If condition (9) holds, then by simply plugging the expression of αt(Xt) for the mirroring scheme along Stx = bt
tbt in (10) we get (11) (Formal proof in Appendix VIII-A). Choosing St = I and
1 which by Point Symmetry satisﬁes (9). Therefore, we get DE = 1
tr(RXt).
T

that is αt(Xt) = (I − 2S(cid:48)
bt = µxt makes α−(X T

tSt) Xt + 2S(cid:48)

1 ) = 2µX T

− X T

1

Note that the optimal distortion, denoted as D(cid:63)

E and obtained by optimizing over St and bt, satisﬁes D(cid:63)

E ≥ 1
T

tr(RXt).

However, from (5), we have D(cid:63)

E ≤ 1
T

are optimal.

T
(cid:80)
t=1

tr(RXt). Therefore, the selected St and bt and the corresponding distortion value
(cid:4)

Now, we show the implications of our results for mirroring based schemes in the context of a few examples.

Example 1. Consider an example where U is distributed as Gaussian with mean µU and covariance matrix RU . Then for
= QµU
2 after unfolding the time-dependent state equations into the form
2 = QU . A Gaussian random vector has Point Symmetry and therefore, according to Corollary III.3, we can get maximum

a noiseless system with perfect observation and a zero initial state, X T
and variance RX T
X T
distortion by setting bt = µXt and St = I.

2 is also Gaussian distributed with mean µX T

= QRU QT where Q relates U to X T

2

2

The next example is based on a Markov-based model for the dynamical system. For this example, the following lemma is

useful.

Lemma III.4. Consider the random vector X T
fXt|X t−1
virtue of Corollary III.3, mirroring schemes can achieve the maximum distortion.

) has Point Symmetry, then so does fX (X), where X = X T

1 where the following conditions hold: 1) fX1 (x1) has Point Symmetry, and 2)
(cid:48)](cid:48). Therefore, by
1 and µ = [µx1

(xt|xt−1
1

· · · µxT

(cid:48) µx2

1

(cid:48)

Lemma III.4 allows us to characterize the performance of the following example.
Example 2. Consider the following random walk mobility model. Let a ∈ N+, and Xt be its location at time t, then,

X1 ∼ Uni([−a : a])

Xt|Xt−1 ∼ Uni([−a : a] ∩ {Xt−1 − 1, Xt−1, Xt−1 + 1}).

This example follows the system model in (1) by assuming a noiseless system with Ut to be independent across t, and to
be uniformly distributed among {−1, 0, 1} when Xt ∈ [−a + 1 : a − 1], Ut uniformly distributed in {0, 1} when Xt = −a
and Ut uniformly distributed in {−1, 0} when Xt = a. One can see that these distributions satisfy the conditions in Lemma
III.4. Therefore, one can set bt = µt = 0 and St = 1, which will achieve maximum distortion of DE.

Example 3. Here we provide a numerical example which shows how our mirroring scheme performs for situations where
we compute the state distributions using numerical simulations. In the Section IV, we will also show that the controller used
in this Example falls under the class of controller where we do not need to compute the distribution on states and can directly
apply our scheme to achieve the perfect distortion. We consider the quadrotor dynamical system provided in (4) of [23]. The
quadrotor moves in a 3-dimensional cubed space with a width, length and height of 2 meters, where the origin is the center
point of the space. The quadrotor starts its trajectory from an initial point (−1, y1, z1) and ﬁnishes its trajectory at a target
point (1, yT , zT ) after T time steps, where the points y1, z1, yT , zT are picked uniformly at random in [−1, 1]4. We assume
that T = 10 time steps, and that the continuous model in [23, (4)] is discretized with a sample time of Ts = 0.5 seconds. We
assume that the quadrotor encodes and transmits only the states which contain the location information (ﬁrst three elements

Figure 4: An illustration of some trajectories. The reﬂection plane is shown as a dashed-black line. One trajectory (solid-black)
is shown along with its mirrored image (dotted-black).

of the state vector Xt). The quadrotor is equipped with an LQR controller which designs the input sequence U T −1
solution of the following problem

1

as the

(cid:13)X T −1
2

(cid:107)U (cid:107)2 + 10 (cid:13)
minimize
subject to Xt+1 = AquadXt + BquadUt,
· · ·
· · ·

X1 = (cid:2)−1
XT = (cid:2)1

y1
yT

z1
zT

0
0

(cid:13)
2
(cid:13)

∀t ∈ [T − 1]
0(cid:3)(cid:48)
,
0(cid:3)(cid:48)
,

(12)

where Aquad and Bquad deﬁne the quadrotor’s discrete-time model. The remaining states of X1 and XT are set to zero to allow
the drone to hover at the respective locations. We perform numerical simulation of the aforementioned setup: we run 2 millions
iterations, where in each iteration a new initial and target points are picked, and the resultant trajectory is recorded. Based
on the recorded data, we consider different mirroring schemes and numerically evaluate the attained distortion. To facilitate
numerical evaluations, the simulation space is gridded into bins with 0.2 meters of separation, and the location of the drone
at each trajectory is approximated to the nearest space bin.

Figure 4 shows some of the drone trajectories obtained from our numerical simulation. It is clear that not all trajectories
are equiprobable, and therefore the distribution of Xt is not uniform across all bins in space. Since the motion of the drone
is mainly progressive in the positive x-axis direction, reﬂection across a ﬁxed point results in mirrored trajectories that are
progressing in the opposite direction, and therefore are identiﬁed to be fake automatically. Therefore, mirroring across a point
here is useless: the numerically computed distortion for this scheme is equal to zero.

Next we consider mirroring across the reﬂection plane shown in Figure 4, where bt = 0 and St =

. As can be

seen from the ﬁgure, the reﬂection plane is indeed an axis of symmetry for the distribution of the drones trajectories, and
therefore is expected to provide high distortion values. We numerically evaluate the attained distortion using the scheme by
using equation (8), which evaluates to DE = 0.3971. This is slightly less than Dmax

E = 0.3979.

B. Encoding Schemes with k-bits Shared Secret Key

The scheme in (7) assumes the use of one bit for encryption. However, it is straightforward to extend the scheme when we
require a larger ambiguity set. For k bits, we denote the possible values of the shared key as K ∈ [0 : 2k − 1]. Therefore, the
scheme works as follows

t
is an invertible transformation function used at time t when the value of the key is K, and α(0)

where α(K)
(x) = x.
The following theorem shows the achieved value of the distortion in this case, which is a direct extension of Theorem III.1.

t (x) = α−(0)

t

t

Zt(K) = α(K)

(Xt), ∀t ∈ [T ],

(13)

(cid:20)0
0

(cid:21)

1
0

0
1

-11-0.510.50.50yz0x00.5-0.5-0.51-1-1Reflection PlaneA trajectoryMirroredTrajectoryTheorem III.5 (Proof in Appendix VIII-B). The average distortion DE attained by using the scheme in (13) is

1
2kT

T
(cid:88)

t=1

EX






2k−1
(cid:80)
K=0
(cid:34)2k−1
(cid:80)
K=0

fX (α−(K)(X))

fX (α−(K)(X))

fX (X)

(cid:13)
2
(cid:13)
(cid:13)

t

(cid:13)
(cid:13)R(K)
(cid:13)
(cid:35)2






,

(14)

where R(K)

t =

fX (α−((cid:96))(X))

(cid:16)

α−((cid:96))
t

(Xt) − α−(K)

t

(cid:17)

(Xt)

and α−(K)(X) := [α−(K)

1

(X1)(cid:48) α−(K)

2

(X2)(cid:48) · · · α−(K)

T

(XT )(cid:48)](cid:48).

2k−1
(cid:80)
(cid:96)=0

Moreover, if the following condition holds,

fX (α−(K)(x)) = C(x),

∀x ∈ X , ∀K ∈ [0 : 2k − 1],

wehre C(x) is a constant, then DE simpliﬁes to


1
23kT

T
(cid:88)

t=1

EX




2k−1
(cid:88)

2k−1
(cid:88)

K=0

(cid:96)=0

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:16)

α−(K)
t

(Xt) − α−((cid:96))

t

(cid:17)

(Xt)

2


 .

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)

(15)

(16)

t

t

Theorem III.5 shows the average distortion attained for general schemes which use k bits. In addition, we can generalize the
mirroring scheme in Section III to utilize k bits as follows. Given a k-bit key, then we select a set of k hyperplanes (i.e., a set
of k parameters, S(K)
∈ Rd) for each time step t. Then, let K be a set of binary values corresponding to the
binary representation of the k-bit key. The mirroring scheme would transform the point x to (cid:81)
bt,
K∈K

∈ Rd×n and b(K)

)x+2S(K)

i.e., x is mirrored across the hyperplanes corresponding to the 1-valued bits in the binary representation of the shared key. It
is not difﬁcult to see that this scheme can achieve the maximum distortion when Xt is Gaussian distributed with zero mean
and covariance matrix Rt and independent across t: for this case, S(K)
, K ∈ K are chosen as the eigenvectors of Rt and
b(K)
t = 0.
Using multiple bits of shared keys can provide beneﬁts beyond having a larger ambiguity set. In fact, while we show the
optimality of 1-bit mirroring schemes for distributions with point symmetries, using multiple bits of shared key can provide a
better distortion for general distributions. For example, it was shown that, for a general ﬁnite alphabet: (1) 1-bit schemes are
not sufﬁcient to achieve the maximum distortion, and (2) with just 5 bits of shared keys, a scheme achieves more than 97%
of the maximum possible distortion [16].

(I −2S(K)

S(K)
t

t

t

t

(cid:48)

(cid:48)

IV. TRANSFORMATIONS MAINTAINING POINT SYMMETRY

Encoding and decoding schemes such as the ones mentioned in Section III can be generally used for any dynamical system
with arbitrary distributions on the inputs U , the state vectors (cid:101)Xt and the state estimates Xt. However, characterizing the
attained level of average distortion (using expressions (8) and (14)) requires the knowledge of the distribution of the state
estimate. While a distribution can be obtained for the initial and target state vectors, it may be difﬁcult to incorporate the
system dynamics, the estimation method as well as the controller into the process of ﬁnding a distribution of the inputs, states
and states estimate. In such cases, numerical evaluations can aid into ﬁnding the needed distribution, as was shown in Example
3 in Section III. Although it is necessary to ﬁnd the state distribution in order to characterize the distortion, the knowledge
of existing symmetries in the distribution can directly give possible choices for the transformation function αt(·) which may
attain high levels of distortion; for example, if there is a point symmetry in the distribution, mirroring across the symmetry
point attains the maximum possible distortion. In this section, we ask the following question: “under which conditions on the
dynamical system, does point symmetry in the initial and target states results into point symmetry on the states estimate?”

A general answer to the aforementioned question appears to be difﬁcult. Therefore, we limit our answer in this work to the
scope of linear controllers. For a given initial and target state, let X (ref) be the reference trajectory that the control system
ideally wishes to follow. We assume that the system controller selects an input vector that is a linear function of X (ref). In many
cases, X (ref) is also a linear function of the initial and target states (e.g., when the reference trajectory is the solution of an
LQR problem for the noiseless version of the system). Then we can write Ut = Kt
. Moreover, we assume that
the optimal estimation function that the system uses is a linear one in the observations, i.e., we assume Xt is a linear function
of Y t
1 , Xinit and Xtarget. By incorporating the controller and estimation equations into the system dynamics, one can arrive at
(cid:48)
, and the matrix M is a function of the matrices A,
the following relation X = M Q, where Q =
B, C, Kt and the linear function used in the estimation of state Xt from the observations. We assume that wT
1 are
uncorrelated Gaussian random vectors. We ﬁrst prove the following lemma.

Xt − X (ref)

1 and vT

target wT
1

init X (cid:48)

vT
1

X (cid:48)

(cid:48)(cid:105)

(cid:16)

(cid:17)

(cid:104)

t

Lemma IV.1. If a random vector V1 ∈ Rn has Point Symmetry across µV1, and g is an afﬁne function, then the random vector
V2 = g(V1) has Point Symmetry across g(µV1 ).

Proof: If V1 has Point Symmetry, then the following conditions are equivalent:

fV1(v1) = fV1(2µV1 − v1),
fV1(v1) = f2µV1 −V1(v1),

∀v1 ∈ V1,
∀v1 ∈ V1.

Thus, to prove that V2 also has Point Symmetry, it sufﬁces to prove that the density of V2 and 2µV2 − V2 is the same.
Consider the two random vectors W1 and W2. If they have the same support and the same density function, then g(W1) and
g(W2) will also have the same density for any function g; we denote this by writing W1 ∼ W2. Thus,

V1 ∼ 2µV1 − V1
g(V1) ∼ g(2µV1 − V1)

M1V1 + M2 ∼ 2M1µV1 − M1V1 + M2

V2 ∼ 2(M1µV1 + M2) − (M1V1 + M2)
V2 ∼ 2(µV2) − V2.

Thus, V2 has a point of symmetry.

Theorem IV.2. If Xinit and Xtarget are independent of wT
well as X will all have Point Symmetries for any matrix M .

1 and vT

1 , and both have Point Symmetries, then the vectors Xt as

1 and vT

1 and vT

Proof: First, note that wT

1 are Gaussian random vectors, and therefore have Point Symmetries across their mean
points. Since Xinit and Xtarget are independent of wT
1 , then the vector Q also has a Point Symmetry across the mean
point (which is the concatenation of the mean points of the respective components of Q); we denote this point by µQ. Then,
by virtue of Lemma IV.1, X (respectively Xt) will also have Point Symmetry across the point M µQ (respectively across the
(cid:4)
point µQ left-multiplied by the corresponding section of the matrix M ).
Revisiting Example-3 of Section III: Example 3 in Section III shows an example where the initial and target points
exhibit Point Symmetry. In such an example, the LQR controller is a linear function of the previous states (one can ﬁnd
such a controller by applying the KKT conditions). Since the system is noiseless, then the estimated states are equal to the
observations. Therefore, the conditions for Theorem IV.2 are met, and Point Symmetry is preserved for Xt and the whole
trajectory X. Note, however, that the point of symmetry for Xt changes with t, i.e., it progresses along the x axis as shown
in Figure 4.

V. OPTIMIZING THE WORST CASE DISTORTION DW

The expected distortion metric might not be well-suited for some applications (for example if an adversary wants to shoot
a drone). In this case, the adversary’s estimate needs to be far from the actual state at all time instances. Therefore, a more
appropriate metric would be to consider the worst case distortion for the adversary. Consider for example the scheme in Fig. 2.
Here, the adversary’s estimate is always the center point and therefore the maximum expected distortion is achieved. However,
when the drone is close to the center, its mirror image will also be close to the center. At this particular time instance, the
adversary’s distortion will be very small and thus the adversary will essentially know the position.

In this section, we present an encryption scheme that attempts to maximize the worst case distortion for Eve. The main
idea is to obfuscate the initial state in such a way that Eve, even if she optimally uses her knowledge about the dynamics
and her observations, her best estimate is close to the maximal distortion. We start by studying the problem of distorting the
transmission of a single random variable in Theorems V.2 and V.3. These results then form the basis for maximizing the worst
case distortion of a trajectory, as described in Theorem V.4.

A. Building Step: Scalar Case

Consider the case where the system wants to communicate a single scalar random variable X to Bob by transmitting Z.
The worst case distortion DW for Eve will be DW = minZ Var(X|Z). Note that if Eve does not overhear Z, Eve uses the
minimum mean square error estimate (i.e., the mean value) as her estimate, and thus experience a worst case distortion equal
to the variance of X.

We ﬁrst assume that X ∼ N (0, 1), and thus, the worst case distortion can not be larger than 1 by (6). We next develop our

scheme progressively, from simple to more sophisticated steps. We will also use the following lemma.

Lemma V.1. The variance of a Bernoulli random variable taking values a and b with probabilities pa and pb, respectively, is
given by papb(a − b)2.

Mirroring. Reﬂecting around the origin (as we did for optimizing the average case distortion in Section III) does not work
well when X takes small values: indeed Var(X|Z) is P r(X = Z|Z)(P r(X = −Z|Z))(Z − (−Z))2 using Lemma V.1 and has
a worst case value that goes to zero as Z approaches zero.

Shifting. To avoid this, we could try to use a “shifting” scheme where we add a constant θ to X whenever the shared key
bit is one; but now this scheme does not perform well for large values of Z: as Z increases Var(X|Z) goes to zero. This is
because using Lemma V.1:

Var(X|Z) = P r(X = Z|Z)(P r(X = Z −θ|Z))(Z −(Z −θ))2

= P r(X = Z|Z)(P r(X = Z − θ|Z))(θ)2,

and P r(X = Z|Z)(P r(X = Z − θ|Z)) goes to zero for large value of Z.

Shifting+Mirroring. We here combine shifting and mirroring, in order to achieve a good performance for both small and

large values of X. We start from the case where we have k = 1 bit of key and then go to the case k ≥ 1.
• k = 1. We select a θ1 ∈ R that determines a window size (θ1 is public and known by Eve). The encoding function is

Z = E(X, K) =






X
−X
X + θ1
X − θ1

if K = 0
if K = 1, |X| > θ1
if K = 1, −θ1 ≤ X < 0
if K = 1, 0 ≤ X < θ1

We note that there is one particular value of X, X = θ1, which we do not transmit. Since this is of zero probability measure,
it can be safely ignored. Given Z, there are two possibilities for X:

X ∈






{Z, −Z}
{Z, Z + θ1}
{Z, Z − θ1}

if |Z| > θ1
if − θ1 ≤ Z < 0
if 0 ≤ Z < θ1.

Using the fact that X ∼ N (0, 1), we can calculate the posterior probabilities P r(X|Z) and use Lemma V.1 to compute
Var(X|Z). Fig. 6 plots Var(X|Z) for θ = 1.76. The worst case distortion in this case becomes 0.4477, which is the best we
can hope for if we have only one bit of shared key. This follows because for any mapping from X to Z, a transmitted symbol
Z can have at most two pre-images (as Bob needs to reliably decode with one bit of key), and if one of these is X = 0, then
no matter what the second one is, the distortion corresponding to Z will be at most 0.4477. Equality occurs when the second
pre-image of Z is ±1.76. Note that our scheme also maps 0 to −1.76 (for θk = 1.76).

−θ2

0

θ2

−θ2

0

θ2

(a)

(b)

Figure 5: (a) Transparent shapes represent true values and solid shapes represent their respective mapping when two bit key
is 11 and 10 respectively. (b) DW , as a function of number of keys for optimal choice of θk.

• k ≥ 1. For K ∈ {0, 1}k, we use the following encoding:

Z = E(X, K)



=

(cid:26) X if K < 2k−1
−X if K ≥ 2k−1

|X| > θk

(17)



X + K 2θk

2k mod [−θk, θk) X ∈ [−θk, θk),

where the optimal value of the constant θk depends on the number k of keys we have, K is the decimal equivalent of a binary
string of length k, and rmod [a, b) = r − i(b − a) is such that i is an integer and r − i(b − a) ∈ [a, b) for r, a, b ∈ R. Intuitively,
if |X| > θk then for half of the keys, we reﬂect across origin and for other half we do nothing; if |X| < θk, we divide this
window of size 2θk into 2k equal size windows and shift a point from one window to another by jumping K (in decimal)
windows. An example for k = 2 is shown in Fig. 5a for the key values K = 11 and K = 10. Fig. 5b plots DW as a function
of the number of keys k. Using k = 3 and θ3 = 4.84 we achieve DW = 0.9998 which is very close to 1, the best we can
hope for.

Remark: We optimize the parameter θk of our scheme assuming Gaussian distribution. In particular, θk = arg maxθk (minZ DW (Z))

and DW (Z) is Z 2 if |Z| > θk, and is (cid:80)

K∈{0,1}k

(cid:16)

pK (ZK)2(cid:17)

−

(cid:16)(cid:80)

K∈{0,1}k pKZK

, if |Z| ≤ θk. Here, pK = f (ZK)/(cid:80)

L∈{0,1}k f (ZL)

(cid:17)2

Figure 6: Var(X|Z) versus Z for the shifting+mirroring scheme with θ1 = 1.76; DW = 0.4477. Var(X|Z) is Z 2 for |Z| > θ1
and is pZ 2 + (1 − p) ˜Z 2 − (pZ + (1 − p) ˜Z)2 for |Z| ≤ θ1, where p = f (Z)/
, with f (Z) ∼ N (0, 1), and
˜Z = Z + θ1mod [−θ1, θ1).

f (Z) + f ( ˜Z)

(cid:16)

(cid:17)

with f (ZK) ∼ N (0, 1), and ZK for K ∈ {0, 1}k is deﬁned as ZK = Z + Kd
equivalent of K.

2θk
2k mod [−θk, θk], with Kd being the decimal

We pick a choice of θk by computationally iterating over the values of θk to ﬁnd one which maximizes DW , i.e., θk =

arg maxθk minZ(DW (Z)).

For other distributions, the optimal choice of θk and the corresponding worst case distortion would be different.

Theorem V.2. A Gaussian random variable with mean µ and variance σ2 can be near perfectly (∼ 0.9998 times the perfect
distortion) distorted in worst case settings by just using three bits of shared keys.

Proof: Generate the random variable V ∼ N (0, 1) as V = (X − µ)/σ and encrypt it using k = 3 key bits and the
previously described scheme. We transmit the mean µ and the variance σ2 uncoded, and show that near perfectly distorting
the standard Gaussian V results in near perfect distortion of X for Eve. For c = 0.9998 we have

DW = min

Var(X|Z) = min

Var(σV + µ|Z)

Z
= σ2 min
Z

Z

Var(V |Z) = cσ2.

B. Vector Case and Time Series
Theorem V.3 (Proof in Appendix VIII-C). For a Gaussian random vector X ∈ Rn with mean µ and a diagonal covariance
matrix Σ we can achieve DW within 0.9998 of the optimal by using 3n bits of shared keys.

This theorem uses our 3-bit encryption for each element in the vector. Assume now that this vector captures the probability

distribution of the initial state of dynamical system; by encrypting this state we can guarantee the following.

(cid:17)

(cid:16)

Theorem V.4 (Complete Proof in Appendix VIII-D). Using 3n bits of shared keys, the shifting+mirroring scheme achieves
with c = 0.9998 for the dynamical systems (1) with C = I, vt = 0, the singular value decomposition of
DW ≥ c · tr
A is A = ΦΛV H , and initial state X1 ∼ N (µ, Σ), where Σ is diagonal covariance matrix, and Ut and wt are independent of
Xt. Moreover, if |λi| ≥ 1, ∀i, where λi is the i-th singular value of A, then DW is within 0.9998 of the maximum distortion.

|Λ|2t Σ

Remark: Although the independence assumption on the inputs is rather restrictive, the result serves as a stepping stone

towards understanding general cases.

Proof: The system transmits Z1 = f (Y1, K) = f (X1, K) where f is the encoding in Theorem V.3, and for t ∈ [T − 1],

Bob can decode X1 using Z1 and K. Then:

Zt+1 = AZt + (Yt+1 − AYt) = AZt + BUt + wt.

ˆXt+1 = Zt+1 − AZt + A ˆXt

= (AZt + BUt + wt) − AZt + A ˆXt
= AXt + BUt + wt = Xt+1,

∀t ∈ [T − 1].

Eve’s distortion is calculated in the Appendix VIII-D.
Complexity: O(n2) per time instance for both encoding and decoding.
Case study: We take three choices of A of sizes 2 × 2, ﬁrst having all singular values no smaller than one, in particular
[1.01, 1], second having singular values [1.5, 0.5] and third having singular values of [0.8, 0.9]. For a given co-variance matrix
Σ = [2, 0; 0, 3] for the initial state, we plot the evolution of distortion at the adversary’s end corresponding to our encryption
scheme and compare with the ctr(Σ). This evolution is shown in Fig. 7. As we can observe, when A has all the singular values
more than one, the distortion at adversary’s end is always at least ctr(Σ), whereas for other cases in eventually goes to zero.

Figure 7: Evolution of the distortion for Eve for shifting+mirroring based scheme

VI. DISTORTING THE INPUTS AND THE IMPLICATION ON STATES
In many situations, it is easier to obtain a handle on the distribution of the input sequence than on the distribution of the
state transition sequence. Moreover, in some situations, a simple transformation of the original trajectory would lead to a fake
trajectory that does not obey the system dynamics and thus can be detected by the adversary – alternatively, the state trajectory
distribution does not have useful symmetry properties. Motivated by these, here we consider a different setup where Alice
encodes and transmits the input sequence to Bob instead of the state transition sequence, i.e., Zt := Et(Ut, K). Under this
setup, using the mirroring based scheme on inputs, one can provide guarantees on the level of average/worst-case distortion
for Eve’s estimate of the inputs. We then ask the following question: if Alice encodes and transmits the input vectors, how
does the guarantees on average and worst-case distortions on the inputs translates to the guarantees on average and worst-case
distortions on the states?

Formally, we consider the system model in (1) with zero noise, i.e., wt = 0. Following the deﬁnition of average and worst-

case distortions in (3) and (4) respectively, the distortions on inputs and states vectors are as follows:

Expected distortions:

D(X)

E =

1
T

EZ

T
(cid:88)

t=1

tr (cid:0)RXt|Z

(cid:1) ,

D(U )

E =

1
T

EZ

T −1
(cid:88)

t=0

tr (cid:0)RUt|Z

(cid:1) .

Worst-case distortions:

D(X)

W = min
Z

min
t

tr (cid:0)RXt|Z

(cid:1) ,

D(U )

W = min
Z

min
t

tr (cid:0)RUt|Z

(cid:1) .

The following Theorem provides a relation between the distortion on the input vector and the distortion on the state vector
for both expected and worst-case scenarios. In particular, it provides relations between DX

E , DU

E , and DX

W , DU

W .

Theorem VI.1. If the input vectors Ut, t ∈ [T − 1] ∪ {0} satisfy the following condition,



tr















EZ

t
(cid:88)

t
(cid:88)

j=i+1

i=1
(cid:124)

(cid:123)(cid:122)
Φt
















(cid:125)

B(cid:48)(At−j)(cid:48)At−iBRUi−1Uj−1|Z

≥ 0,

(18)

then, for given distortions D(U )

E and D(U )

W , the following bounds holds:

D(X)

E ≥ λmin (B(cid:48)B) D(U )
E ,

D(X)

W ≥ λmin (B(cid:48)B) D(U )
W ,

where λmin (B(cid:48)B) is the minimum eigenvalue of B(cid:48)B.

Theorem VI.1 gives a lower bound on the distortion level of the state vectors when distorting the inputs. The bound holds
when the condition (18) holds. Examples where condition (18) holds are open loop control systems where the distribution on
the inputs has a point of symmetry. We expand more on condition (18) after the proof of Theorem VI.1.

Proof: We start by introducing the following notation Z = Z T −1

, U = U T −1

, X = X T

0

0

generality, we assume that X0 = 0. The states of the noiseless dynamical system can be expressed as Xt =

1 . Moreover, without loss of
t
(cid:80)
At−iBUi−1.
i=1

Then we can write

RXt|Z =

t
(cid:88)

i=1

At−iBRUi−1|ZB(cid:48)(At−i)(cid:48) + 2Φt

(19)

Therefore, combining (18) and (19), we express D(X)

E

as

D(X)

E ≥

1
T

EZ

T
(cid:88)

t
(cid:88)

t=1

i=1

tr (cid:0)At−iBRUi−1|ZB(cid:48)(At−i)(cid:48)(cid:1)

(a)
≥

1
T

EZ

T
(cid:88)

t=1

tr (cid:0)BRUt−1|ZB(cid:48)(cid:1) =

1
T

EZ

T
(cid:88)

t=1

tr (cid:0)B(cid:48)BRUt−1|Z

(cid:1) ,

≥ λmin(B(cid:48)B)

1
T

EZ

T
(cid:88)

t=1

tr (cid:0)RUt−1|Z

(cid:1) = λmin(B(cid:48)B)D(U )
E ,

where (a) follows by noting that the matrices B(cid:48) (cid:0)At−i(cid:1)(cid:48)
RUi−1|ZAt−iB are positive semideﬁnite, and therefore their trace
is greater than or equal to zero. To see that they are indeed positive semideﬁnite, note that RUi−1|Z is positive semideﬁnite,
therefore it has the eigen-decomposition RUi−1|Z = ΣΛΣ(cid:48). Therefore, the claim follows by noting that, for any vector z, we
have

z(cid:48)B(cid:48) (cid:0)At−i(cid:1)(cid:48)
z(cid:48)B(cid:48) (cid:0)At−i(cid:1)(cid:48)

RUi−1|ZAt−iBz =
ΣΛ1/2Λ1/2Σ(cid:48)At−iBz = (cid:107)Λ1/2Σ(cid:48)At−iBz(cid:107)2 ≥ 0.

Identical arguments can be made to show the bound on D(X)
W .

Next, we show some sufﬁcient conditions which ensure that condition (18) holds:

1) Ui and Uj are uncorrelated for i (cid:54)= j and U := U T −1
has Point Symmetry: In this case, the optimal mirroring scheme is
to mirror the point U across the point of symmetry. Therefore, given Z, Ui takes two values: Zi with probability pZ and ˜Zi
with probability 1 − pZ, where pZ is equal to pZ = fU (Z)/(fU (Z) + fU ( ˜Z)) = 0.5, which follows from the Point Symmetry
assumption on U . So we have E[Ui|Z] = Zi+ ˜Zi

. Therefore, RUiUj |Z can be computed as follows

0

2

RUiUj |Z = EU |Z
(cid:16)
Zi − ˜Zi

=

1
4

(cid:2)(Ui − E[Ui|Z]) (Uj − E[Uj|Z])(cid:48)(cid:3)
(cid:17) (cid:16)

(cid:17)(cid:48)

Zj − ˜Zj

= (Zi − µZi) (cid:0)Zj − µZj

(cid:1)(cid:48)

.

Then we have EZRUiUj |Z = RUiUj = 0 by noting that Zi, Zj have the same distribution as Ui, Uj:
1
2

(cid:0)fUi,Uj (zi, zj) + fUi,Uj (˜zi, ˜zj)(cid:1) ,

fZi,Zj (zi, zj) =

=

1
2

(cid:0)fUi(zi)fUj (zj) + fUi(˜zi)fUj (˜zj)(cid:1) = fUi,Uj (zi, zj).

2) A and RUi,Uj |Z are positive semideﬁnite matrices for all i, j and Z: this follows because, if A is positive semideﬁnite,
then so is Ai for any value of i. Therefore we can write

tr (cid:0)B(cid:48)(At−j)(cid:48)At−iBRUi−1Uj−1|Z
(cid:1)
= tr (cid:0)B(cid:48)At−jAt−iBRUi−1Uj−1|Z
(cid:1)
= tr (cid:0)B(cid:48)A2t−i−jBRUi−1Uj−1|Z
= tr

(cid:16)

(cid:1)

(cid:16)

B(cid:48)ΣΛ1/2Λ1/2Σ(cid:48)BRUi−1Uj−1
Λ1/2Σ(cid:48)BRUi−1Uj−1|ZB(cid:48)ΣΛ1/2(cid:17)
(cid:32)

(cid:17)

(cid:33)

= tr

= tr

Λ1/2Σ(cid:48)BΦΓ1/2 Γ1/2Φ(cid:48)B(cid:48)ΣΛ1/2
(cid:124)
(cid:125)

(cid:123)(cid:122)
D

= tr (D(cid:48)D) ≥ 0.

VII. CONCLUSION

In this work, we considered distortion-based security for CPSs as a complementary security approach which optimizes an
alternative security goal. This approach for security is suitable for CPS applications where the estimation of the adversary
about the states is required to be ”far” from the actual state value. We provided security schemes which aim to optimize for
both the average and worst-case distortion. For the average distortion, we showed the surprising result that 1-bit schemes are
optimal for certain distributions. We then provided the expression for the attained level of distortion for a general security
scheme. For worst-case distortion, we considered an initial situation where we proposed an encryption scheme which achieves
near optimal distortion.

A. Proof of Theorem III.1 and Corollary III.3

VIII. APPENDICES

. Note that given a sequence of transmitted symbol Z T

1 there are two possible values of

We start by computing RXt|ZT
sequence of message symbols X T

1 which are X T
The posterior probability of Xt = Zt given Z T
˜Z (cid:48)
2 · · · ˜Z (cid:48)

, where ˜Z := [ ˜Z (cid:48)
1

that pZ = f (Z)

1

f (Z)+f ( ˜Z)

1 = ˜Z T
1 = Z T
1 and X T
1 i.e., P r(Xt = Zt|Z T
T ](cid:48). Then, E(Xt|Z T
(cid:104)(cid:0)Xt − E(Xt|Z T
= EXt|ZT
= pZ(1 − pZ)2(Zt − ˜Zt)(Zt − ˜Zt)(cid:48)
Z(Zt − ˜Zt)(Zt − ˜Zt)(cid:48)

+ (1 − pZ)p2

1

1 , where ˜Zt is α−
1 ) will be equal to P r(X T

t (Zt) and ˜Xt is α−
1 |Z T
1 ) = pZZt + (1 − pZ)( ˜Zt). With this,
1 )(cid:1)(cid:48)(cid:105)

1 )(cid:1) (cid:0)Xt − E(Xt|Z T

1 = Z T

RXt|ZT

1

t (Xt).
1 ) := pZ. We note

= pZ(1 − pZ)(Zt − ˜Zt)(Zt − ˜Zt)(cid:48)

DE =

=

=

1
T

1
T

1
T

EZ

EZ

EZ

T
(cid:88)

t=1
T
(cid:88)

t=1
T
(cid:88)

t=1

(cid:16)

tr

RXt|ZT

1

(cid:17)

(cid:16)

pZ(1 − pZ)(Zt − ˜Zt)(Zt − ˜Zt)(cid:48)(cid:17)

tr

pZ(1 − pZ)tr

(cid:16)

(Zt − ˜Zt)(Zt − ˜Zt)(cid:48)(cid:17)

=

=

1
T

1
T

EZ

EZ

T
(cid:88)

t=1
T
(cid:88)

t=1

pZ(1 − pZ)(cid:107)Zt − ˜Zt(cid:107)2

fX (Z)fX ( ˜Z)
(fX (Z) + fX ( ˜Z))2

(cid:107)Zt − ˜Zt(cid:107)2.

Now, Z T

fZ(Z) = fX (Z)+fX ( ˜Z)

1 is the transmitted symbols if X T
. Thus DE,

2

1 = Z T

1 and key was zero or if {Xt = ˜Zt, ∀t ∈ [T ]} and key was one. So

=

=

=

=

EZ

(cid:90)

1
T

1
T

T
(cid:88)

t=1

fX (Z)fX ( ˜Z)
(fX (Z) + fX ( ˜Z))2

(cid:107)Zt − ˜Zt(cid:107)2

T
(cid:88)

fZ(Z)

fX (Z)fX ( ˜Z)
(fX (Z) + fX ( ˜Z))2

(cid:107)Zt − ˜Zt(cid:107)2dZ

1
2T

1
2T

(cid:90) T

(cid:88)

t=1
T
(cid:88)

t=1

EX

t=1
fX (Z)fX ( ˜Z)
fX (Z) + fX ( ˜Z)
fX ( ˜X)
fX (X) + fX ( ˜X)

(cid:107)Zt − ˜Zt(cid:107)2 dZ

(cid:107)Zt − ˜Zt(cid:107)2

=

1
2T

EX

T
(cid:88)

t=1

fX (α−(X))
fX (X) + fX (α−(X))

(cid:107)Xt − α−

t (Xt)(cid:107)2,

which proves (8). Again, if we can choose St’s, bt’s where αt() is mirroring across planes given by Stx = bt such that,
fX (X) = fX (α−1(X)), ∀X ∈ RnT ,

the distortion DE becomes,

DE =

=

1
4T

EX

1
T

T
(cid:88)

t=1

T
(cid:88)

t=1

(cid:107)Xt − α−

t (Xt)(cid:107)2(a)
=

1
T

T
(cid:88)

t=1

EXt(cid:107)StXt − bt(cid:107)2

tr (StRXtS(cid:48)

t + (bt − StµXt)(bt − StµXt)(cid:48)) ,

where (a) follows as αt(.) is mirroring across plane given by Stx = bt, and thus αt(x) = α−1
This proves (11).

t (x) = (I − 2S(cid:48)

tSt)Xt + 2S(cid:48)

tbt.

B. Proof of Theorem III.5

Since given Z, there are 2k possibilities of X T

1 ; X T

1 = α−1(K)(Z), K ∈ [0 : 2k − 1], we start by computing,

p(K)
Z

:= P r(Xt = α−(K)

t

(Zt)|Z) = P r(X = α−(K)(Z)|Z)

=

(a)
=

1
fZ(Z)

P r(Z|X = α−(K)(Z))fX (α−(K)(Z))

fX (α−(K)(Z))

2k−1
(cid:80)
j=0

fX (α−(j)(Z))

, K ∈ [0 : 2k − 1],

where (a) follows by noting that P r(Z|X = α−(K)(Z)|Z) is equal to the probability of the key being equal to K, which is

1/2k. Let S =

2k−1
(cid:80)
j=0

fX (α−(j)(Z)). Then E(Xt|Z) equals

2k−1
(cid:88)

K=0

α−(K)(Zt)p(K)

Z =

1
S

2k−1
(cid:88)

K=0

α−(K)(Zt)fX (α−(K)(Z)).

We can then compute tr (cid:0)RXt|Z

(cid:1) as,

EXt|Z(cid:107)Xt −E(Xt|Z)(cid:107)2 =

1
S3

2k−1
(cid:88)

K=0

(cid:16)

fX

α−(K)(Z)

(cid:17) (cid:13)
(cid:13)R(K)
(cid:13)

t

(cid:13)
2
(cid:13)
(cid:13)

,

where R(K)

t =

fX (α−((cid:96))(X))

(cid:16)

α−((cid:96))
t

(Xt) − α−(K)

t

(cid:17)

(Xt)

. Plugging tr (cid:0)RXt|Z

(cid:1) in the expression of DE gives

(14).

2k−1
(cid:80)
(cid:96)=0

Moreover, if condition (15) is met, (14) simpliﬁes to (16).

C. Proof for Theorem V.3

Let the shared key K is (K1, K2, . . . , Kn) where all Ki’s are i.i.d. and uniformly distributed in {0, 1}3. Let us also assume
that X = (X (1), X (2), . . . , X (n)), where each X (i) ∈ R. Similar to the scheme for scalar case, we create a random vector
Σii, and encode V (i) using key Ki as in the case of a scalar for all
V = (V (1), . . . , V (n)) where V (i) = (X (i) − µ(i))/
i ∈ [n]. Thus, the distortion DW will be,

√

DW = min

Z

tr(RX|Z) = min

Z

n
(cid:88)

i=1

Var(X (i)|Z)

= min

Z

n
(cid:88)

(Σii)Var(V (i)|Z) =

i=1

n
(cid:88)

i=1

(Σii) min

Z

Var(V (i)|Z)

=

n
(cid:88)

i=1

(Σii) min
Z(i)

Var(V (i)|Z (i)) = c

n
(cid:88)

(Σii) = c tr(Σ),

i=1

where c = 0.9998. And since tr(Σ) is the expected distortion even when the adversary has no observations, and as we can not
beat this by (6), this is optimal.

D. Proof for Theorem V.4
Distortion at the adversary’s end. Based on the coding scheme we can see that the adversary get BUt +wt by just subtracting
AZt from Zt+1 for t ∈ [1 : T − 1]. So the adversary’s information is given by following set:

Einfo = {Z1, BUt + wt, t ∈ [1 : T − 1]}

= {f (X1, K), BUt + wt, t ∈ [1 : T − 1]} .

Thus, D(t, Z T

1 ) = D(t, Einfo) = tr(RXt|Einfo). Next, we can write

D(t + 1, Z T

1 ) = tr(RXt+1|Einfo) = tr(R(AXt+BUt+wt)|Einfo)

(b)
= tr(RAtX1|f (X1,K))

(a)
= tr(RAtX1|Einfo)
= tr(AtRX1|Einfo(At)(cid:48)) = tr((At)(cid:48)AtRX1|Einfo)
(c)
≥ c · tr (cid:0)(At)(cid:48)AtΣ(cid:1) = c · tr (cid:0)(At)H AtΣ(cid:1)
= c · tr (cid:0)V (ΛH )tΛtV H Σ(cid:1) = c · tr

(d)

(cid:16)

V |Λ|2t V H Σ

(cid:17)

= c · tr

(cid:16)

|Λ|2t V H ΣV

(cid:17) (e)

= c · tr

(cid:16)

|Λ|2t Σ

(cid:17) (f )

≥ = c · tr(Σ)

where (a) follows by noting that Einfo contains BUt + wt, ∀t ∈ [1 : T − 1]; (b) follows because Ut and wt are independent
on Xt; (c) follows because (At)(cid:48) At is a positive semi-deﬁnite matrix and RX1|Einfo being a diagonal matrix with the diagonal
entries being element vise greater than cΣ; (d) follows by writing the singular value decomposition of A as A = ΦΛV H ; (e)
follows by noting that λi is the i-th singular value of A, and V is a unitary matrix; (f ) follows for dynamic systems where
|λi| ≥ 1.

REFERENCES

[1] G. K. Agarwal, M. Karmoose, S. Diggavi, C. Fragouli, and P. Tabuada, “Distorting an adversary’s view in cyber-physical systems,” in IEEE Conference

on Decision and Control (CDC), Dec 2018, pp. 1476–1481.

[2] J. Wan, A. B. Lopez, and M. A. A. Faruque, “Exploiting wireless channel randomness to generate keys for automotive cyber-physical system security,”

in 2016 ACM/IEEE 7th International Conference on Cyber-Physical Systems (ICCPS), April 2016, pp. 1–10.

[3] B. Zan, M. Gruteser, and F. Hu, “Key agreement algorithms for vehicular communication networks based on reciprocity and diversity theorems,” IEEE

Tran. Vehicular Tech., vol. 62, no. 8, pp. 4020–4027, Oct 2013.

[4] W. Trappe, R. Howard, and R. S. Moore, “Low-energy security: Limits and opportunities in the internet of things,” IEEE Security Privacy, vol. 13,

no. 1, pp. 14–21, Jan 2015.

[5] P. Koopman and C. Szilagyi, “Integrity in embedded control networks,” IEEE Security Privacy, vol. 11, no. 3, pp. 61–63, May 2013.
[6] A. B. Alexandru and G. J. Pappas, Secure Multi-party Computation for Cloud-Based Control. Singapore: Springer Singapore, 2020, pp. 179–207.

[Online]. Available: https://doi.org/10.1007/978-981-15-0493-8 9

[7] K. Kogiso and T. Fujita, “Cyber-security enhancement of networked control systems using homomorphic encryption,” in 2015 54th IEEE Conference

on Decision and Control (CDC), 2015, pp. 6836–6843.

[8] F. Farokhi, I. Shames, and N. Batterham, “Secure and private cloud-based control using semi-homomorphic encryption,” IFAC-PapersOnLine, vol. 49,

no. 22, pp. 163 – 168, 2016, 6th IFAC Workshop on Distributed Estimation and Control in Networked Systems.

[9] Y. Shoukry, K. Gatsis, A. Alanwar, G. J. Pappas, S. A. Seshia, M. Srivastava, and P. Tabuada, “Privacy-aware quadratic optimization using partially

homomorphic encryption,” in 2016 IEEE 55th Conference on Decision and Control (CDC), Dec 2016, pp. 5053–5058.

[10] T. Fujita, K. Kogiso, K. Sawada, and S. Shin, “Security enhancements of networked control systems using rsa public-key cryptosystem,” in 2015 10th

Asian Control Conference (ASCC), May 2015, pp. 1–6.

[11] C. E. Shannon, “Communication theory of secrecy systems,” Bell system technical journal, vol. 28, no. 4, pp. 656–715, 1949.
[12] A. Tsiamis, K. Gatsis, and G. J. Pappas, “An information matrix approach for state secrecy,” in 2018 IEEE Conference on Decision and Control (CDC),

Dec 2018, pp. 2062–2067.

[13] A. D. Wyner, “The wire-tap channel,” The bell system technical journal, vol. 54, no. 8, pp. 1355–1387, 1975.
[14] H. Yamamoto, “A rate-distortion problem for a communication system with a secondary decoder to be hindered,” IEEE Transactions on Information

Theory, vol. 34, no. 4, pp. 835–842, July 1988.

[15] C. Schieler and P. Cuff, “Rate-distortion theory for secrecy systems,” IEEE Trans.Info. Theory, vol. 60, no. 12, pp. 7584–7605, Dec 2014.
[16] C. Tsai, G. K. Agarwal, C. Fragouli, and S. Diggavi, “A distortion based approach for protecting inferences,” in 2017 IEEE International Symposium

on Information Theory (ISIT), June 2017, pp. 1913–1917.

[17] A. Tsiamis, K. Gatsis, and G. J. Pappas, “State-secrecy codes for networked linear systems,” CoRR, vol. abs/1709.04530, 2017.
[18] ——, “State estimation with secrecy against eavesdroppers,” 20th IFAC World Congress, vol. 50, no. 1, pp. 8385 – 8392, 2017.
[19] T. Tanaka, M. Skoglund, H. Sandberg, and K. H. Johansson, “Directed information and privacy loss in cloud-based control,” in 2017 American Control

Conference (ACC), May 2017, pp. 1666–1672.

[20] W. A. Malik, N. C. Martins, and A. Swami, LQ Control under Security Constraints. Heidelberg: Springer Int. Publishing, 2013, pp. 101–120.
[21] J. Corts, G. E. Dullerud, S. Han, J. L. Ny, S. Mitra, and G. J. Pappas, “Differential privacy in control and network systems,” in 2016 IEEE 55th

Conference on Decision and Control (CDC), Dec 2016, pp. 4252–4272.

[22] M. Wiese, T. J. Oechtering, K. H. Johansson, P. Papadimitratos, H. Sandberg, and M. Skoglund, “Secure estimation and zero-error secrecy capacity,”

IEEE Transactions on Automatic Control, vol. 64, no. 3, pp. 1047–1062, 2018.

[23] V. Kumar and N. Michael, “Opportunities and challenges with autonomous micro aerial vehicles,” The International Journal of Robotics Research,

vol. 31, no. 11, pp. 1279–1291, 2012.

