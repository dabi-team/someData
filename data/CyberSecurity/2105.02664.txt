Exploiting Partial Order of Keys to Verify Security
of a Vehicular Group Protocol

Felipe Boeira and Mikael Asplund
Dept. of Computer and Information Science
Link¨oping University, Sweden

1
2
0
2

v
o
N
5
2

]

R
C
.
s
c
[

2
v
4
6
6
2
0
.
5
0
1
2
:
v
i
X
r
a

Abstract—Vehicular networks will enable a range of novel
applications to enhance road trafﬁc efﬁciency, safety, and reduce
fuel consumption. As for other cyber-physical systems, security is
essential to the deployment of these applications and standardis-
ation efforts are ongoing. In this paper, we perform a systematic
security evaluation of a vehicular platooning protocol through
a thorough analysis of the protocol and security standards.
We tackle the complexity of the resulting model with a proof
strategy based on a relation on keys. The key relation forms a
partial order, which encapsulates both secrecy and authenticity
dependencies. We show that our order-aware approach makes
the veriﬁcation feasible and proves authenticity properties along
with secrecy of all keys used throughout the protocol.

I. INTRODUCTION

Security of cyber-physical systems are increasingly becom-
ing a societal concern, as both the attack surfaces and the
potential consequences of attacks have increased considerably
in recent years. In the automotive domain, connected and
automated vehicles (CAV) promise considerable improvements
in safety and efﬁciency, but also require very strict security
processes to be trustworthy. Today, the most advanced and
complex collaborative vehicular application comes in the form
of vehicular platooning where a group of vehicles are jointly
controlled by a leader. In this paper we consider the security of
platooning as a starting point to investigate automated security
proofs, partially ordered key structures, and the process of
transforming informal and semi-formal standardisation text to
formal models.

Our work was inspired by Basin et al. [1] who in their
security analysis of the 5G AKA protocol make a compelling
argument for the need of formal models and security speci-
ﬁcations to complement protocol standards. In particular, the
authors point to under-speciﬁcation of security properties and
assumptions that can in some cases lead to vulnerabilities.
Our analysis is focused on a cyber-physical protocol that is
currently in the pre-standardisation phase and described in
the European Ensemble project, and which also builds on the
existing ETSI ITS-G5 and IEEE vehicular networking stan-
dards (including security). Together, these form an interesting
study object since (i) they will have a real and signiﬁcant
impact on the way future commercial vehicles are operated and
controlled, (ii) they represent a typical standardisation product
composed of multiple cross-references documents (in our case
8 documents and 617 pages), and (iii) the protocol and the
associated security speciﬁcation describe a complex system

with dynamically joining and leaving nodes and a non-trivial
key structure.

We perform a structured and formal security analysis of
the Ensemble platooning protocol. To perform this analysis
several interesting challenges must be overcome. One such
challenge is the transformation from informal and semi-formal
standard documents - where descriptions are often spread
out over multiple documents, contain optional parts, and
sometimes overrides previous statements - to a formal model.
We show how ASN.1 speciﬁcations signiﬁcantly improve this
process and discuss potential beneﬁts of a fully automatic
transformation process. Moreover, our analysis also identiﬁes
the lack of a corresponding language to capture the behaviour
of security checks since the speciﬁcations currently included
only capture the structure of security information, not the
mechanisms that make use of that information. This gives rise
to potential weaknesses depending on the interpretation of the
standard.

The second major challenge is of course the model com-
plexity which causes a state space explosion. In our case, even
a simple fact such as the secrecy of a long-term key could
not be proven on a large computing cluster without manual
intervention. Previous work have shown how this process
can be aided with so called helper lemmas and oracles. The
difﬁculty with such mechanisms is that they are inherently
speciﬁc to the problem at hand, and hard to generalise. In this
work we explore how the structure of the model can be used
to guide the proof strategy. In particular, by considering the
ordered structure of the cryptographic keys in the model we
make the problem tractable, thereby allowing a more generic
proof guidance mechanism.

Secure protocols are often created so that multiple secret
keys form dependency chains where the secrecy of one key
is dependent on the secrecy of another. This naturally allows
formulating provable properties in a way that together satisfy
the overall security speciﬁcation (e.g., see [2]). However, we
are not aware of any previous work that formalises the two
forms of dependencies (authenticity and secrecy dependencies)
into a partial order on keys and translate it into a security
veriﬁcation proof strategy.

We formulate relevant security properties of vehicular com-
munication protocols and instantiate our model and proof guid-

 
 
 
 
 
 
ance1 in the TAMARIN veriﬁer tool [3]. In our case study there
are 10 classes of keys with up to a dependency depth of six,
and potentially inﬁnitely many instances of keys on a protocol
run. Our improved proof strategy allows us to identify the
security properties that are met by current protocols and under
what circumstances. Overall, our assessment is that security
standards for vehicular networks can provide strong security
properties, but that ambiguities and implicit assumptions in
the standards potentially give room for implementations with
lacking security checks.

To summarise, the contributions of this paper are as follows.
• Formulation of a joint secrecy and authenticity relation
on a set of keys that potentially forms a partial order,
together with an automated proof strategy, a key hierarchy
extractor for TAMARIN protocol models that exhibit such
partial orders of keys.

• An assessment of the state of security for current vehic-
ular networking protocols and a formal and structured
security analysis of vehicular platooning.

• A structured approach for interpreting security standards
in order to create models that allow formal reasoning,
identiﬁcation of what is lacking in current standards, and
recommendations for future vehicular security standardi-
sation activities.

The remainder of this paper is organised as follows: Sec-
tion II introduces the area of vehicular networking protocols
at large, the Ensemble platooning protocol in particular and
formal veriﬁcation of security protocols. Section III introduces
our model of the platooning protocol and the security prop-
erties that we verify. Section IV introduces the partial order
of keys, and explains how this ordering relation is used to
create the proof guidance. The outcome of verifying security
protocols under different settings and assumptions is presented
in Section V. Finally, Section VI describes related work and
Section VII concludes the paper and outlines future work.

II. BACKGROUND
In this section we introduce the standards for vehicular
communication and security that are employed in Ensemble.
We describe the overall design of the protocol, and provide an
overview of how the protocol security properties are veriﬁed
using the TAMARIN security veriﬁcation tool.

A. Vehicular network and security standards

In recent years, organisations such as the Institute of
Electrical and Electronics Engineers (IEEE) and European
Telecommunications Standards Institute (ETSI) have been
actively working towards standardisation of vehicular network
protocols and applications. The Ensemble protocol [4], [5] is
built on top of these existing standards and makes use of their
services, so one must understand how these ﬁt together to
understand the security implications for vehicular platooning.
Fig. 1 represents the protocol stack and the associated stan-
dards for each layer. In Europe, the physical layer and the data

1The full model will be made available in a public repository, and is

provided as supplementary material for the reviewers.

link layer are grouped together into the Access layer and are
part of ITS-G5. More recently, the 5G standard has emerged
as a potential replacement at the access layer. Ensemble is
designed to work on ITS-G5 together with the Geonetworking
(GN) protocol and the Basic Transport Protocol (BTP) which
compose the network and transport layer. A set of security
proﬁles for vehicular applications is deﬁned by ETSI based
on the primitives and message types deﬁned by IEEE, and
are applied to GN and Ensemble messages. We proceed to
describe each of these standards brieﬂy (starting from the
lowest layer).

7
9
0

3
0
1

I

S
T
E

/

.

2
9
0
6
1
E
E
E

I

Facilities Layer

DENM

[...]

ENSEMBLE

Networking and Transport Layer

Basic Transport Protocol (BTP)

Geonetworking (GN)

Access Layer

EN 302 663 (ITS-G5)

3GPP V2X (5G)

Fig. 1. ENSEMBLE protocol stack.

ITS-G5 (ETSI EN 302 663). At the bottom of the vehicular
networking stack we ﬁnd the access layer, which is of limited
interest from a security standpoint, but still relevant to provide
context. In Europe and US,
the dominating access layer
standard for vehicular networks has been based on a ﬂavour
of IEEE 802.11 (i.e., essentially wiﬁ) operating at 5.9GHz.

3GPP V2X (5G Release 15+). There are ongoing efforts
to integrate 5G as an alternative access layer in the vehicular
networking stack [6]. Provided that GN is compatible with
V2X as intended [7], we argue that our analysis will still
be relevant as the cryptographic operations occur from the
networking and transport layer upwards.

GeoNetworking (ETSI EN 302 636-4-1). The GN proto-
col [8] provides packet routing in vehicular networks with the
use of geographical locations for packet transport. In Ensemble
only the single hop broadcast (SHB) mode is used.

BTP (ETSI EN 302 626-5-1). BTP [9] deﬁnes two header
variants: BTP-A for interactive packet transport and BTP-B
for non-interactive. Given that BTP does not carry relevant
information for our analysis and is included in higher layers’
cryptographic operations, we have decided to omit it in our
model.

Security Services for Applications and Management
Messages (IEEE 1609.2). The primitives for providing se-
curity capabilities to vehicular messages are primarily deﬁned

by IEEE 1609.2 [10] and its two amendments [11], [12]. The
standard deﬁnes several data structures for encapsulating data
based on the type and origin of the key that is used to encrypt
it, and a SignedData structure for storing signature infor-
mation. The 1609.2 standard uses the concept of recipients to
transfer data encryption keys to other nodes, and a sequence
of recipients may be included in a message. For instance,
a recipient of type pskRecipInfo is used whenever the
data encryption key is pre-shared between the participants.
Alternatively, a node might use an ephemeral data encryption
key and a key encryption key to protect the ephemeral. In
particular, two recipient types that employ ephemeral keys are
used in Ensemble:

• symmRecipInfo speciﬁes that the ephemeral data en-

cryption key was encrypted using a symmetric key.

• rekRecipInfo speciﬁes that the ephemeral data en-
cryption key was encrypted using a public response en-
cryption key that was not obtained from a SignedData
structure.

Security header and certiﬁcate formats (ETSI TS 103
097). While IEEE 1609.2 deﬁnes low-level primitives and
data structures to build vehicular messages, the ETSI TS 103
097 [13] speciﬁes message proﬁles based on the deﬁnitions
from 1609.2. For instance, ETSI speciﬁes that Decentralized
Environmental Notiﬁcation Messages (DENMs) shall include
the certiﬁcate as the signer information instead of its digest
only. The Ensemble project extends the deﬁnitions contained
in this standard to reﬂect the requirements of the messages
exchanged in the protocol.

B. Platooning protocol

Ensemble works as a group formation protocol with key
establishment and distribution. It consists of four operational
modes: idle, join, platoon, and leave. In idle mode,
vehicles announce their interest to form a platoon through
the ﬂag isJoinable, which is included in a Cooperative
Awareness Message (CAM). Neighbouring vehicles may send
a request to join the platoon and, if accepted, will receive a
join response. These two messages compose the join mode,
which enables the joiner to start receiving and sending control
messages in the platoon mode. The latest vehicle to join the
platoon may ﬂag isJoinable to allow other neighbours to
join, up to a certain length of the platoon. Finally, the leave
mode is activated whenever a vehicle wishes to depart from
the platoon or if no control messages have been received for a
predetermined period of time. More details on the protocol are
provided in Section III where we describe how it is formally
modelled.

C. Protocol security veriﬁcation

To formally prove security properties of a protocol such
as Ensemble, there are at least three things to consider, how
to model the protocol, how to model the attacker, and what
security properties to verify.

There are two protocol models generally considered for
creating cryptographic protocol representations: computational

and symbolic [14]. In the computational model [15], [16],
terms are represented as bitstrings, cryptographic primitives
are functions on these bitstrings, and the adversary is any
probabilistic Turing machine. In the symbolic model (which
we consider in this work) bitstrings are abstracted to algebraic
terms, and cryptographic primitives are represented by an
theory. Messages are terms of these equations,
equational
for instance, consider the symmetric encryption/decryption
equation where the term m is encrypted/decrypted using the
key k in Equation 1.

sdec(senc(m, k), k) = m

(1)

The symbolic model allows the reasoning to be automated,
although complex protocols usually require the solver to be
guided with some proof strategy as we will discuss in the later
sections of this work. Given proper heuristics, TAMARIN has
been shown to work with protocols that exhibit complex state
machines that may include loops and agent memory [1], [17]–
[20]. For these reasons, the symbolic model and TAMARIN tool
are well-suited to our work.

To represent an attacker that acts throughout the execu-
tion of the protocol, a threat model deﬁnes capabilities on
computation and on observing and manipulating the network
communication. A Dolev-Yao [21] threat model assumes a
powerful attacker who is able to tamper with public com-
munication channels, knows public constants, has unbounded
computational and communication resources, and is able to
employ cryptographic primitives as long as the required terms
are known.

We now provide a brief overview of modelling in TAMARIN.
Protocols and adversary actions are modelled as multiset
rewriting rules and security properties are deﬁned through
(temporal) ﬁrst-order logic. Rules are composed by premise,
action, and conclusion facts as follows:

[p1, ..., pi] –[a1, ..., aj]→ [c1, ..., ck]

The solver maintains a multiset of facts that can be consumed
as premises to activate the execution of a rule (there are also
persistent facts that can be consumed an arbitrary number of
times and are deﬁned with a starting ’!’). The special facts In()
and Out() are used to model receiving and sending messages
over the network (which can be intercepted by the attacker),
and Fr() to generate fresh terms. In addition, the action fact
KU() logs terms that are known by the attacker. The execution
of rules creates a trace of action facts, and the security
properties are formulas that reason about possible traces of the
protocol. For instance, consider an action fact Secret(x) that
marks the term x as secret whenever the corresponding rule is
executed. The following formula formalises the property that
an adversary cannot know a secret term x at any time point
j (an action fact a that occurs at time point j is denoted as
a@j).

∀x i. Secret(x)@i ⇒ ¬(∃ j. KU(x)@j)

To construct traces for which formulas will be checked,
TAMARIN uses a backwards constraint solving approach that
checks all possible sources for a given constraint. For a more
detailed discussion and presentation of TAMARIN we refer the
reader to [22]–[26].

III. PROTOCOL MODEL

This section describes our approach to analysing the stan-
dards and interpreting semi-formal descriptions to create a
formal protocol model. We describe how we leverage ASN.1
(Abstract Syntax Notation One) speciﬁcations to support this
process and present
the
platoon formation statically and dynamically), the veriﬁcation
goals, and assumptions we have considered.

the resulting models (we model

A. Protocol messages interpretation

Some of the complexities to model protocols lie in collect-
ing information that is scattered across different documents
and connecting information that is deﬁned sparsely, as well
as interpreting possibly ambiguous speciﬁcations with regards
to, for example, whether to include certain optional ﬁelds in
a message. In our analysis, basic data structures and message
types are deﬁned by IEEE 1609.2, which is extended by two
amendments, and ETSI 103 097 deﬁnes proﬁles based on these
deﬁnitions. Finally, the protocol speciﬁcation itself uses and
extends the proﬁles in distinct ways (Ensemble).

We have used ASN.1 speciﬁcations that are included in
several of the standards that we analyse to guide our mod-
elling of the protocol messages. First, we collect the required
modules from distinct standards (data structures and message
types can be deﬁned and imported as modules): ITS Container,
CAM, IEEE 1609.2, ETSI 103 097, and Ensemble. Then, we
employ an ASN.1 compiler to generate sample packets of the
data structures we are interested in modelling. With the ﬁnal
sample packet, we can refer back to the standards so that the
expected behaviour of the agents towards the data included
those packets can be modelled. We reﬁne and choose what to
model in a message type if a given data structure transmits or
modiﬁes cryptographic material, and whether it affects the way
the agents handle the messages (e.g., the presence of a node
identity in a message can be matched with expected senders
by a receiver).

In this work, the transition from ASN.1 packet descriptions
to a formal model was performed manually. Given that large
portions of the TAMARIN model are based on the content of
messages as they are exchanged between different nodes, much
of this process should be possible to automate. If properly
implemented, this would signiﬁcantly simplify the process of
model validation.

However, even if ASN.1 formalises data structures and
its encoding/decoding operations, there are no formal spec-
iﬁcations of the sanity/security checks to be performed on
received data. This makes standards susceptible to ambiguous
or misinterpretations that may lead to vulnerabilities in the
implementation. Therefore, even though the sample packets
provide an overview of the contents of messages, it is still

necessary to carefully analyse natural language in standards
so that the expected behaviour of the agents towards data
contained in messages is captured. Having a well-speciﬁed
language for expected behaviour and security checks as part
of the standardisation process would both mitigate problems
related to vulnerabilities in implementations as well as improve
the ability to formally verify security properties.

B. Model overview

The security veriﬁcation of Ensemble was performed
through two TAMARIN model variants which we deﬁne as
static and dynamic. Fig. 2 depicts the main steps of the
protocol operation. Our static model has a ﬁxed sequence of
actions from steps S1 to S7 between three agents that includes
the announcement of a platoon, a join operation followed by
a second join to form a platoon with three members, a leave
from the third member and a re-keying process to update
the group key. The dynamic model supports the same steps,
however with an unlimited number of vehicles that can form an
unbounded number of platoons (although with the limitation
that each vehicle engages in only one session). This model
enables the ﬂexibility of many different scenarios, which
include unbounded number of joins, a leave from any of the
followers, a key update request to the leader, and propagation
of the new group key through a series of key update messages
until the interaction ends. We have not analysed the growth
of a platoon after a leave has occurred (however, this growth
would involve the same interactions from S2 to S4 as shown
in Fig. 2).

To support several platoons in the dynamic model, we
follow the Ensemble ASN.1 deﬁnitions to include a platoon
identiﬁer in messages subsequent to the join response, and
leverage such identiﬁers to claim the honesty of vehicles in
a certain platoon (i.e., restrict the revealing of keys in the
platoon).

Our models consist of rules that represent the public key
infrastructure, initialisation of the vehicles and platoons, send-
ing and receiving messages, and the revealing of keys by the
attacker. The rules and properties take approximately 900 lines
of text to be deﬁned, and we use let bindings to make the
messages more readable and clearer to maintain.

We model certiﬁcates as the persistent fact deﬁned below,
and it essentially captures the binding between an identity and
a public key by a trusted certiﬁcate authority (CA with a long-
term key ltkCA). In our diagrams, the certiﬁcate for a public
identity n is represented as Certn.

Deﬁnition 1. A certiﬁcate for an identity n is modelled via
the following persistent fact:

!Cert((cid:104)n, pk(ltkn), sign((cid:104)n, pk(ltkn)(cid:105), ltkCA)(cid:105)),

where pk(ltkn) is the public key for n and sign() is the signing
operation

We now proceed to explain the protocol model in two steps.
First, we show the interaction that occurs when a new vehicle
joins the platoon (Join procedure). Then we describe a full run

start

S1

CAM

S2

JR

S3

JRE

S4

LEAVE

S5

KUR

S6

KU

S7

Fig. 2. Simpliﬁed diagram of protocol steps (Cooperative Awareness Message (CAM), Join Request (JR), Join Response (JRE), Leave, Key Update Request
(KUR), and Key Update (KU)).

CAM

Vehicle n (the joinable)

APP ← ’CAM’
GN ← APP, sign(APP, ltkn), Certn

Vehicle n + 1 (the joiner)

Cooperative Awareness Message

generate key pair jrek, pk(jrek)
APP ← ’JoinRequest’, pk(jrek), n
GN ← APP, sign(APP, ltkn+1), Certn+1

Join Request

generate key pgk if n = 1
generate keys eJoin, ppkn
rekRecipInfo ← h(pk(jrek)), aenc(eJoin, pk(jrek))
ciphertext ← senc((cid:104)ppkn, pgk(cid:105), eJoin)
APP ← ’JoinResponse’, rekRecipInfo, ciphertext, P, n + 1
GN ← APP, sign(APP, ltkn), Certn

Join Response

Agreement on ppkn, pgk

Fig. 3. The modelled Ensemble join operation.

of the protocol with two joins and one leave (Full run). The
diagrams consider messages of the more expressive dynamic
model, which includes platoon identiﬁers and vehicle position
multisets.

1) Join procedure: The sequence diagram in Fig. 3 shows
a join operation from Vehicle n + 1 (the joiner) to Vehicle
n (the joinable). The join begins with the joinable sending
a CAM to neighbours announcing the availability to join the
platoon (or to create one). The CAM is unencrypted at the
application layer and follows the signing of messages in the
GeoNetworking layer (all messages are signed and carry the
vehicle’s certiﬁcate).

Whenever the joiner receives a CAM advertising a platoon
that it wishes to join, a join request message is pre-
pared. The joiner generates a short-term asymmetric key pair
jrek, pk(jrek) and includes the public key in the request sent
to the joinable along with the identity of the target joinable
vehicle.

Once the joinable vehicle n receives the join request,
it generates three keys: a platoon participant key (ppkn), a
platoon group key (pgk in case it is the ﬁrst join, otherwise
re-transmit previously generated), and an ephemeral join key
(eJoin). Both ppkn and pgk are encrypted with eJoin, and
eJoin itself is encrypted with the public key of jrek which

was sent by the joiner. Recall from Section II-A the use of
rekRecipInfo when an ephemeral key is encrypted with a
public key that was not obtained from a certiﬁcate.

Note that using the rekRecipInfo is discouraged by the
security standards as it may introduce misbinding attacks. In
Ensemble, the inclusion of an intended receiver in the join
response mitigates such risk according to our analysis,
however, we show in Section V-D the possible outcome if
an intended receiver is omitted or not checked. The following
is a quotation from the IEEE 1609.2 standard:

[IEEE 1609.2] It is therefore recommended that secure
data exchange entity designers who use public key encryp-
tion make use of either public keys in certiﬁcates or public
keys in signed secured protocol data units (SPDUs), and
avoid “raw” public keys because they do not mitigate this
misbinding threat.

The join response transmits the keys along with the
current platoon identiﬁer P , the intended receiver, and the
platoon position of the joiner. Note that we simplify the
intended receiver and platoon position in the diagram denoted
as n + 1, whereas the model uses a public identity for the
intended receiver and a multiset for the platoon position as

previously discussed.

2) Full run: In a real case, there is no upper bound on the
number of steps that can be taken in the Ensemble protocol.
Even if there is a limit on the number of platoon members,
nodes can keep joining and leaving indeﬁnitely. However, we
consider it a full run when all message types have been sent.
We now describe a scenario where two nodes join a leader
node so that the platoon reaches a length of three. Once the
third node has joined the platoon it initiates a leave procedure
which causes a key update mechanism.

In Fig. 4 we simplify the diagram by omitting the join
messages. In practice, each join procedure box can be inter-
preted as an instance of the interactions from Fig. 3. From
the sequence diagram represents a leave from
then on,
Vehicle 3 and a key update procedure so that the remaining
members agree on a new platoon group key (which we denote
pgkUpdate).

A leave message contains the identity of the leaving
vehicle, its position and reason to leave, and is encrypted with
an ephemeral leave (eLeave) symmetric key. The eLeave key
is encrypted with the platoon group key (pgk) and is included
in a symmRecipInfo recipient data structure. In our model,
we represent the position as a multiset and reason as a constant
given that no checks are performed on this term.

As soon as Vehicle 2 receives the leave broadcast, it
prepares a key update request (KUR) message so that
the leader instantiates a new group key. The leader pro-
ceeds to generate a pgkU pdate key and includes it
in a
KeyUpdate message. Both KUR and KeyUpdate messages
employ symmRecipInfo, however, while the former uses
pgk to encrypt the ephemeral key, the latter uses ppkn which
is private to every pair of adjacent vehicles. Note that in
both KUR and KeyUpdate we simply encrypt the message
name constants since the contents of these messages are
currently under speciﬁed in the documentation. The agreement
on pgkU pdate is shown at the end of the interaction in the
ﬁgure.

C. Veriﬁcation goals

The veriﬁcation goals are divided into liveness, secrecy, and
authenticity. Liveness ensures that our model can be executed
as expected. See Section V for details of the liveness checks
that are performed.

For every key (class of keys in the dynamic model) em-
ployed in the life cycle of the protocol, we introduce a
secrecy veriﬁcation lemma based on Deﬁnition 2. There is one
important variation in the action facts and lemma construction
between the static and dynamic models. Since the static model
is composed of one static run, the nodes that participate in the
protocol are marked as honest globally. In the dynamic model,
since many platoons can be created, honesty claims are done
in a per-platoon basis. This allows an attacker to compromise
keys of vehicles that are not members of the platoon for which
a property is being veriﬁed. In the following deﬁnitions we
consider the use of a platoon identiﬁcation. Our rules contain
Honest(P, n) action facts that mark an identity n in a platoon

P as a benign vehicle (participated in the protocol run and
satisﬁed checks such as signature veriﬁcation). Therefore, the
secrecy formulas deﬁne that terms considered secret can not be
deduced by an attacker unless it has revealed (through a reveal
rule that contains a Rev() action fact) any subset of keys on
which the secret depends. We explain such key dependency
relations further in Section IV-A.

Deﬁnition 2. Secrecy lemma with platoon identiﬁcation:

∀ P x i. Secret key(P, x)@i ⇒
(¬(∃ j. KU(x)@j)
| (∃ n k r h. Rev(’c’, n, k)@r & Honest(P, n)@h))

Intuitively, a secret x instantiated in a platoon with identiﬁer
P is either (1) not known by the attacker, or (2) an honest
vehicle in the platoon P revealed a secret k of class ’c’
on which x depends. We employ variations of this lemma
structure to account for necessary dependencies.

For the authenticity properties we follow Lowe’s hierar-
chy [27] and the standard formula deﬁnitions according to the
TAMARIN manual. In the dynamic model, we also consider the
platoon identiﬁcation as part of the agreed data. Namely, we
specify aliveness, weak agreement, and non-injective agree-
ment properties. Since our models support a single session per
vehicle, we have not analysed injective agreement properties
in this work.

To verify these authenticity formulas we annotate the model
rules with Running(m, n, t) and Commit(n, m, t) action facts
that specify that vehicles n and m agree on their roles
and the data represented by t. For a full description of the
interpretation of these properties we refer to the TAMARIN
manual.

D. Assumptions

In this section we describe assumptions related to the
replay protection of messages, random numbers, and pattern
matching used in the model.

In order to determine whether a vehicle should accept
replayed messages, we have identiﬁed several places where
this concept
is mentioned in the relevant documents. The
GeoNetworking layer could potentially be used to reject re-
played messages. However, all Ensemble messages are single-
hop packets which do not carry sequence numbers, so this
cannot be used to prevent message replay, and ETSI 103 097
does not discuss replays. The IEEE 1609.2 standard describes
a mechanism that can be used to avoid message replay attacks
since it states that identical signed messages are not accepted
for a given predetermined time as follows.

[IEEE 1609.2] The replay detection service indicates
that a signed SPDU is a replay if the entire encoded
signed SPDU, including signature and other ﬁelds such
as generation time inserted by the secure data service, is
identical to a recently received SPDU.

Vehicle 1

Vehicle 2

Vehicle 3

Join procedure (Agreement on ppk1, pgk)

Join procedure (Agreement on ppk2, pgk)

generate key eLeave
symmRecipInfo ← h(pgk), senc(eLeave, pgk)
leaveMsg ← 3, position, ’Reason’
ciphertext ← senc(leaveMsg, eLeave)
APP ← ’Leave’, symmRecipInfo, ciphertext, P
GN ← APP, sign(APP, ltk3), Cert3

Leave

generate key eKUR
symmRecipInfo ← h(pgk), senc(eKUR, pgk)
ciphertext ← senc(’KUR’, eKUR)
APP ← ’KUR’, symmRecipInfo, ciphertext, P
GN ← APP, sign(APP, ltk2), Cert2

Key Update Request

generate keys eKupdate, pgkUpdate
symmRecipInfo ← h(ppk1), senc(eKupdate, ppk1)
ciphertext ← senc((cid:104)’KeyUpdate’, pgkUpdate(cid:105), eKupdate)
APP ← ’KeyUpdate’, symmRecipInfo, ciphertext, P
GN ← APP, sign(APP, ltk1), Cert1

Key Update

Agreement on pgkUpdate

Fig. 4. The modelled Ensemble protocol interactions (the join messages from Fig. 3 are omitted).

Ensemble does not explicitly specify that the replay pro-
tection from IEEE 1609.2 must be enforced. Having optional
security mechanisms is clearly a potential weakness since it
delegates important security aspects to choices made in the
implementation stage. Still, we believe that the most reason-
able assumption according to this statement is that message
replay is prevented by the protocol (valid re-transmissions of
messages can be done by updating the timestamp, and agents
check for uniqueness given a recentness parameter).

We formalise this replay protection as a restriction of
traces (only consider those that satisfy the restriction formula)
by annotating every message reception with Message(x, n)
where x is a signed message and n is the identity of the
receiver.

Deﬁnition 3. Replay protection is modelled via the following
restriction formula:

∀ x n i j. Message(x, n)@i & Message(x, n)@j ⇒ i = j

We include this restriction for completeness only since we
have not identiﬁed any speciﬁc attack that could be launched if
the restriction is not present (nor ruled it out). Such an analysis

would require a model that allows entities to be present in
multiple runs and is therefore out of scope for this paper.

Another assumption in the model is that vehicles verify the
signature with the corresponding public key of the sender that
was included in the certiﬁcate, and match the identity in the
certiﬁcate with the identity stored in a state fact of that run of
the protocol.

Moreover, we assume that the certiﬁcate authority is trust-
worthy, i.e., the attacker is unable to compromise its long-
term key ltkCA. In practice, one of the possibilities for the
attacker would be to forge certiﬁcates with arbitrary identities
and public keys in order to conduct identity theft of other
vehicles.

Finally, our model assumes that fresh terms (for instance,
ephemeral keys) are unique across all runs of the protocol.
In addition, when receiving messages, we employ pattern
matching instead of deconstruction. Deconstruction explicitly
decomposes the terms by applying equations, selecting speciﬁc
terms from tuples, and performing sanity checks on decom-
posed terms. Because of this, pattern matching implicitly
checks for message formats and expected data types which
must be done explicitly in real software.

IV. PROOF STRATEGY

In this section we deﬁne secrecy and authenticity relations
between keys, and explain how a partial order of these
relations is employed in our proof strategy. In addition, we
provide details of the goal prioritisation of the oracle that
guides the constraint solver.

A. Key ordering

The combination of keys deﬁned in Ensemble, the pub-
lic key infrastructure, and ephemeral keys used in message
proﬁles from the security standards considerably increases
the complexity of our analysis. Our strategy towards making
the analysis tractable is to deﬁne the relations between the
keys and break the complexity into smaller parts that can be
combined to prove the security properties. We ﬁrst present how
this can be done for a static case where all keys are known
at design time, and then discuss the extension to the dynamic
case where we know the classes of keys.

Let K be the set of symmetric and asymmetric keys. We
deﬁne a secrecy dependency relation → ⊆ K × K such that
for two keys kA, kB ∈ K, kA → kB holds if revealing the
key kB allows the attacker to learn kA. We consider that
kA → kB whenever senc(kA, kB) or aenc(kA, pk(kB)) occurs
in a message sent over the network (rule 1). We note that the
secrecy dependency relation is reﬂexive (i.e., k → k for all
keys k since revealing a key means that the attacker knows it).
Moreover, under the assumption that revealing/compromising
a key is a stateless operation (i.e., it does not otherwise change
any state in the system), then the secrecy dependency relation
is also transitive. This means that if kA → kB and kB → kC,
then kA → kC. In most applications this relation is also
anti-symmetric, thus giving rise to a partial order of keys.
To deﬁne our authenticity relation, we consider compromising
a term x as either revealing it or being able to generate a
x(cid:48) that will be accepted by other nodes as x. We deﬁne an
authenticity dependency relation (cid:57)(cid:57)(cid:75) ⊆ K × K such that for
two keys kA, kB ∈ K, kA (cid:57)(cid:57)(cid:75) kB holds if compromising
kB allows the attacker to create another key k(cid:48)
A that will
be accepted by the other nodes as the legitimate kA, which
thereby becomes compromised (rule 2). For instance, if node
n generates a fresh term f and signs it with its long-term key
ltkn, then f (cid:57)(cid:57)(cid:75) ltkn. The authenticity dependency relation is
irreﬂexive (knowing a long-term key does not allow creating a
new long-term key), transitive (proof in appendix), and should
be anti-symmetric since otherwise the protocol has a cyclic
authenticity dependency.

In Ensemble, the two key relations → and (cid:57)(cid:57)(cid:75) are both
anti-symmetric (there are no cases where two different keys
depend on each other). By taking the union of the two relations
(a relation is a set of pairs, so the union of two relations is
the aggregation of all pairs from both relations) we arrive at
a third relation whose transitive closure forms a partial order
(cid:32)⊆ K × K. Intuitively, whenever kA (cid:32) kB, compromising
kB will allow the attacker to compromise kA, either directly,
or through a chain of learned/replaced keys in which the
attacker appears as the legitimate entity that controlled kB.

Note that the joint dependency relation can in some cases be
automatically deduced from a formal description of a protocol
through rules 1 and 2 as we describe in the next subsection.
The dependency relation we have described here assumes
a static set of keys, and also that the relation itself is time-
invariant. In reality, there are several situations where these
assumptions do not hold. In the case of Ensemble, the static
model can be immediately analysed as all keys are known
a-priori. For the dynamic model on the other hand, we have
to consider classes of keys by, for example, considering all
ppk keys as if they were a single key. This means that if
some ppk key depends on another key k, then the class of
ppk will depend on the class of k. Another situation where
the assumptions do not hold is if the reveal/compromise can
be limited to happen only a ﬁnite number of times. In this
case, transitivity is not guaranteed to hold so compromising a
top-level key does not necessarily mean that all keys ”under”
also become compromised. Finally, the dependency relation
does not specify when a key can be compromised, so it does
not account for perfect forward secrecy formulations. Taken
together, the dependency graph that we consider should be
seen as an abstraction in which a dependency actually means a
possible dependency. Since the purpose of the ordering relation
is to guide the prover on which lemmas/goals to prioritise,
having spurious dependencies does not cause erroneous re-
sults, but can potentially reduce its usefulness. An extension
of our approach would be to let the prover maintain a dynamic
key hierarchy at runtime which would at least account for a
changing set of keys. We discuss this further in the future work
section.

B. Key dependency extractor

The dependencies formalised through rules 1 and 2 can be
automatically extracted from a TAMARIN model to support
oracle and reusable lemmas construction. To implement this
extractor we have extended the Tamarin to alice&bob transla-
tor [28] in order to parse the model, extract key dependencies,
identify term equivalences (for instance, keys with different
names across distinct rules) through uniﬁcation, and then
grouping equivalent keys to output a graph of the hierarchy.
The process of extracting the key dependency is summarised
as follows:

1) The model is parsed to instantiate an internal representa-
tion [28] and an empty directed acyclic graph (DAG) of
keys is instantiated.

2) Terms are identiﬁed in each multiset rule of the TAMARIN
model and subsequently added as nodes to the DAG of
keys. Relations are added as edges according to rules 1
and 2 deﬁned in the previous subsection (duplicates may
be merged through uniﬁcation in later steps).

3) Instantiate empty premise and conclusion lists. Premise
and conclusion facts are added to the premise and con-
clusion lists, respectively.

4) Facts from the premise and conclusion lists with same
name and arity (as well as inputs and outputs from
the network) are uniﬁed if possible (we use maude for

this [29]). This results in a set of term substitutions
(uniﬁers) which we use to ﬁnd equivalent keys.

5) A new DAG of equivalent keys is instantiated given the
prior DAG of keys and the resulting sets of equivalent
keys. Its topological sort represents the key ordering.

We illustrate the partial order of keys in the Ensemble
protocol extracted from the dynamic model using our tool in
Fig. 5. We see that at the top of this partial order is the long-
term key of the certiﬁcate authority, and at the bottom are the
ephemeral keys as well as the pgkUpdate key. Edges that are
covered by the transitivity of the relations have been omitted
in the graph.

Fig. 5. Key dependency graph automatically extracted from our dynamic
model.

Proving security properties involving keys at the bottom
of this order requires that one is ﬁrst able to prove the
secrecy of the keys in the upper layers. More concretely, if
kA (cid:32) kB, then any security property (secrecy or authenticity)
that depends on kA also depends on kB. Thus, one should
ﬁrst show the secrecy of kB. In a simple protocol with few
the more complex the
keys,
key relationships become, the more important it is that the
veriﬁer is aware of the key ordering. Often this is implicit in
the helper lemmas or oracle instrumentation made for each
security property.

this order matters little, but

Due to limitations in the model parser, we remove union
operations (enabled by the multiset built-in theory) from
TAMARIN models and other theories are not currently sup-
ported (such as XOR and Difﬁe-Hellman). The relations for
such theories could be derived from the message deconstruc-
tion rules used in TAMARIN, but are out of the scope of our
current analysis. In addition, we note that some models might
generate cyclic graphs which are currently not supported.

tool

Despite these limitations, we have employed our proof-
of-concept
in the analysis of a recent work in 5G
handover protocols [30]. These models also present a complex
relation on keys, and required the modellers to consider the
dependencies during the speciﬁcation of lemmas and oracles.
For instance, given that the model allows the revealing of
some keys, the secrecy lemmas must restrict the revealing of
dependencies. Furthermore, the oracles also seem to consider
some dependencies in the prioritisation, similar to what we
present in this work. While we have not enhanced the proving
efﬁciency of these models that had already been carefully
optimised by experts, we argue that applying the strategies

described in this work could be useful during the analysis and
modelling of such protocols. Examples of the extracted graphs
and further discussions are included in Appendix B.

C. Inductive helper lemmas

The possibility to instantiate inﬁnitely many vehicles and
platoons associated to the fact that each platoon can grow
indeﬁnitely aggregates further complexity to our dynamic
model. The model
in
non-termination when using standard backwards search in
TAMARIN. To handle such behaviour, TAMARIN allows the
speciﬁcation of inductive lemmas which we employ as inter-
mediate helpers.

therefore enables loops that result

Recently, Cremers et al. have analysed IEEE 802.11’s
WPA2 protocol [20], which also contains complex state ma-
chines with loops and evolving states. In their work, they
specify Wellfoundedness, Uniqueness, and Ordering lemmas.
We follow their approach in the creation of such inductive
intermediate helper lemmas, and in conjunction employ our
key hierarchy prioritisation.

D. Oracle strategy

We now describe how the use of the linear extension of
the partial order of keys is used to guide the solver. Recall
from Section II-C that TAMARIN checks possible sources for
constraints to generate traces that will be used to prove or
ﬁnd a counterexample for a given property. The choice of
which constraint to solve (goal) at a given step can be tailored
by using oracles. To perform the Ensemble veriﬁcation, we
structured the lemmas and developed an oracle so that they
leverage the key ordering from our key dependency extractor.
Due to space constraints, we only present the main pri-
oritisation activities performed by the oracle, which leverage
the selection of reusable lemmas to avoid unnecessary case
distinctions during proving.

Ordered helper lemmas iff a knowledge goal for the
corresponding key exists in the constraint system: In order
to create contradictions earlier, the helpers are prioritised if
there is currently a goal for an attacker knowledge of the
corresponding key k as KU(k). Algorithm 1 performs this
prioritisation. The algorithm runs for each k according to the
ordering of keys.

Data: Proof goals G; Linearised key ordering K(cid:32)
Result: Ordered list of goals G(cid:32)
foreach k ∈ K(cid:32) do

foreach g in G do

if g is a helper lemma for k and KU (k) ∈ G
then

add g to G(cid:32)

end

end

end
Algorithm 1: Oracle priority pseudocode for helper lem-
mas

eKupdateeLeavejrekpgkppkeJoinpgkUpdateltkCAltkeKURSignature of protocol messages: Following our hierar-
chical key approach, we introduce helper lemmas that prove
that the attacker cannot obtain any long-term key unless it
performs a reveal of those keys. Since the authenticity of
messages depend on the secrecy of the respective long-term
keys (because of the signatures), we prioritise these goals to
determine that the attacker is not able to forge signatures or
act on behalf of an honest node.

V. RESULTS AND DISCUSSION

In this section we present the Ensemble veriﬁcation results
using our TAMARIN model variants and their respective proven
properties. In addition, an evaluation of our proof strategy is
conducted in order to show that leveraging an order-aware
oracle is effective.

A. Security veriﬁcation results

Considering the security veriﬁcation goals described in Sec-
tion III-C we prove three kinds of properties, model liveness,
secrecy and authenticity. For each of these we describe the
resulting security lemmas in the context of our model.

a) Liveness: To ensure protocol executability in our
static variant, we prove that a full run with three vehicles
exists. In the dynamic variant we verify that the following
is possible: two platoons can be formed with four members
each, there exists a leave from a member in a platoon, as well
as a key update request and key updates are performed for
remaining members.

b) Secrecy: We prove secrecy of all long-term and short-
term keys. We use one lemma per key in the static model as
they are instantiated in distinct rules, so there is a total of
15 secrecy lemmas. The dynamic model contains one secrecy
lemma for every class of keys (e.g., one lemma proves the
secrecy of all platoon participant keys).

c) Authenticity: We have one lemma each for the authen-
ticity properties aliveness, weak agreement and non-injective
agreement (cf. Section III-C).

The properties have been proven for both static and dynamic
the veriﬁcation

models. This required making use of all
strategies described in Section IV.

B. Veriﬁcation strategy evaluation

To assess the effectiveness and impact of the proof strate-
gies, we use two experiments: a synthetic protocol generator
and a variation of conﬁgurations for proving the static model.
The experiments are run on a cluster of the Swedish National
Supercomputer Centre, where each compute node is equipped
with Intel(R) Xeon(R) Gold 6130 CPU @ 2.10GHz with 32
cores and 96 GiB of main memory.

The synthetic protocol consists of a simple ’ping-pong’ pro-
tocol in which two nodes communicate and in every interaction
instantiate a new symmetric key which is encrypted with the
previously received key (the ﬁrst instance is derived from a
pre-shared key). We use the standard TAMARIN heuristics and
only provide annotations in the model to prioritise certain
facts (state, pre-shared key, symmetric encryption, and attacker

knowledge of secret). The lemmas are created according to the
linear dependency of keys, and the proving is evaluated with
and without the reuse of lemmas. In addition, we perform
an experiment with the reuse of lemmas that are randomly
ordered (for this, the prover is executed ten times with random
orders for each key depth).

Each run was granted 8 cores of CPU for 30 minutes and
20 Gib of RAM. Table I presents the results. TAMARIN is
able to automatically prove the secrecy of keys in a depth of
2 in all cases, and up to a depth of 8 when reusing ordered
lemmas according to the key hierarchy, which shows how
our strategy makes such proofs tractable. In some cases, the
random ordering resulted in a possible automatic proof, but
took signiﬁcantly more time to terminate as it was not the
optimal order. The key depth of 10 could not be proven and
would require further manual intervention (e.g., through an
oracle).

TABLE I
RESULTS OF PROVING THE SYNTHETIC MODELS WITH DISTINCT KEY
DEPENDENCY DEPTH

Key
depth

2
4
6
8
10

Without reuse
(ordered by
dependency)
(cid:52)
(cid:54)
(cid:54)
(cid:54)
(cid:54)

With reuse
(random order)

(cid:52)
3/10
2/10
(cid:54)
(cid:54)

With reuse
(ordered by
dependency)
(cid:52)
(cid:52)
(cid:52)
(cid:52)
(cid:54)

In our second set of experiments, we run TAMARIN on the
the static model of Ensemble with several different parameter
conﬁgurations and measure how many of the security lemmas
can be proven with these settings and the computational
resources that are used.

We run the prover with four different conﬁgurations, out-

lined as follows.

• Bare TAMARIN - In this conﬁguration we try to prove
the security properties of the protocol without any added
proof strategies or helper lemmas.

• Lemma reuse - Lemmas that for example assert secrecy
of keys are set as reusable so that the veriﬁer can assume
these lemmas to be true when searching for the proof.
• Oracle only - Here we make use of the order-aware
therefore

oracle but do not reuse lemmas, and must
reprove all relevant subresults for every property.

• Order-aware - In this conﬁguration we use both the

order-aware oracle and reuse helper lemmas.

The ﬁrst two conﬁgurations should be considered as base-
lines. The reason for including both the ”Oracle only” and
”Order-aware” conﬁgurations rather than just a single good
strategy is to investigate the relative impact of the different
aspects of the generated oracle as the ordering of reusable
lemmas according to the key hierarchy is an important aspect
of its design (see Section IV-D).

In addition to the amount of successfully proven lemmas,
we measure the resource consumption in terms of computation

TABLE III
AUTHENTICATION FAILURE IN THE ABSENCE OF INTENDED RECEIVER

Security property

Aliveness
Weak agreement
Non-injective
agreement

Intended
receiver
(cid:52)
(cid:52)
(cid:52)

No intended
receiver
(cid:52)
(cid:54)
(cid:54)

D. Identity misbinding attack

An identity misbinding attack [31], [32], also referred to
as an unknown key-share attack [33], [34] occurs when two
honest parties establish a common session key without a
consistent view of each other’s identities. In IEEE 1609.2, the
use of rekRecipInfo can possibly create a vulnerability to
misbinding since the public key is not bound to an identity.
In Ensemble, even though this data structure is used in a Join
Response, misbinding can be mitigated because the identity of
the intended receiver is included in the application payload.
However, it is not stated explicitly that this information should
be validated. The receiver must check that the intended re-
ceiver included in the message matches its own identity. In an
implementation of the protocol where this is not done, some
security properties will be violated. We ran the veriﬁcation
with a modiﬁed variant of the static model that captures this
aspect. The results can be seen in Table III where we see that
the weak and non-injective agreement authenticity properties
are not satisﬁed.

The possible attacker behaviour is described as follows (see
also Fig. 3). Provided that the check of intended receiver is
absent, an inside attacker (who has a valid long-term key
and certiﬁcate) could replay the CAM (from Vehicle 1) that
advertises a joinable platoon to another Vehicle 2, which will
send a join request. The attacker extracts the public key
of jrek from that message and uses it in a join request signed
with his own long-term key. Vehicle 1 will send a join
response to the attacker, which will transmit it back to
Vehicle 2. At the end of the procedure, Vehicle 1 believes
that the attacker has joined, whereas Vehicle 2 believes it has
joined Vehicle 1, and both share the participant and group keys
(note that the attacker can not compromise the secrecy).

VI. RELATED WORK

Vehicular network security standardisation and its formal
analysis is rather recent. Whiteﬁeld et al. [35] analyse V2X
certiﬁcate revocation of malicious or misbehaving vehicles
with the REWIRE scheme using TAMARIN. In their analysis,
they are able to identify an authentication weakness and pro-
pose an extension to mitigate it. Li et al. propose a lightweight
privacy-preserving authentication protocol that is veriﬁed with
BAN logic and PROVERIF [36].

In mobile networks, Basin et al. [1] formalise the 5G
authentication and key agreement protocol, and verify security
properties using TAMARIN. The authors found in their analysis
that security goals and assumptions were under-speciﬁed or
missing. We show a similar situation in our analysis of
standards in the vehicular domain. While data structures are

Fig. 6. The number of lemmas proven within a given time for the different
proof strategies (logarithmic x axis).

time and memory usage. Each lemma was run as a separate
job in the cluster, and given an allocation of 2 hours on 8
cores and 22 GiB of memory. Jobs that exceeded either the
time or memory limit were aborted.

C. Effectiveness of proof strategies

We now proceed to present the outcome of the second
experiments. Table II shows an overview of how the four
different prover conﬁgurations performed in terms of proving
the 20 different security properties. The Oracle and Reuse
columns summarise the key differences between the different
conﬁgurations (with or without the key-aware oracle, and with
or without reusable lemmas). The ﬁnal three columns show
how many of the lemmas that could be proven in the three
different categories.

TABLE II
OVERVIEW OF PROVABILITY FOR DIFFERENT PROOF STRATEGIES

Proof method
Bare TAMARIN
Lemma reuse
Oracle only
Order-aware

Oracle
N
N
Y
Y

Reuse
N
Y
N
Y

Liveness
1/1
1/1
1/1
1/1

Secrecy Authenticity

0/15
4/15
15/15
15/15

0/3
1/3
3/3
3/3

The results clearly demonstrate the effectiveness of the key-
aware oracle, which seems to be the deciding factor to making
the model tractable for the veriﬁer.

Another perspective on the performance of the different
strategies is shown in Fig. 6. The graph shows time on the
X axis (logarithmic scale) and the number of lemmas proven
within this time on the Y axis. There is a signiﬁcant (and
expected) performance difference observed when making use
of, and ordering, previously proven lemmas. In particular, the
fastest 15 lemmas were veriﬁed in 86 seconds by the order-
aware strategy whereas it took over 10 minutes when lemmas
were not reused (Oracle only).

 0 5 10 15 20 25 30 10 100 1000 10000Verified lemmas (out of 19)Time (s)Order-awareOracle onlyLemma reuseBare Tamarinoften well deﬁned, under-speciﬁcation of data checks and
behaviour can lead to misinterpretation and potential security
vulnerabilities.

XOR, Multiset, Difﬁe-Hellman, and other equational theories
are required to support a large class of models. We consider
these challenges to be important contributions in future work.

With respect to veriﬁcation and solving theory, Cremers
and Mauw [37] employ partial order reduction to lower the
number of traversed states in checking secrecy of terms in a
cryptographic protocol in their tool SCYTHER. They build on
the fact that exchanging two events in a trace might result in
equivalent traces with respect to the veriﬁed property. In our
work, we explore the fact that solving for the knowledge of
some terms might not be relevant, and that solving for the
knowledge of some terms before others is more efﬁcient.

Schmidt et al. [38] develop an algorithm to verify protocol
group key agreement protocols that can handle Difﬁe-Hellman
exponentiation, bilinear pairing, and AC-operators. In their
work they extend the operators set and provide constraint
reduction rules in TAMARIN to support them. They argue for
the analysis of dynamic join and leave operations in group
protocols, which is also present in our model.

VII. CONCLUSION AND FUTURE WORK

We have formally analysed the security of Ensemble, a
protocol for vehicular group formation with key establishment
and distribution which is currently in pre-standardisation. To
conduct the veriﬁcation, we deﬁne secrecy and authentication
relations that are applied in a proof strategy based on their
partial order. We automate the key hierarchy extraction from
our TAMARIN models and create oracles to guide the prover
based on the ordering of keys. To reﬁne the model of the
protocol messages we use ASN.1 deﬁnitions from standards
and a compiler to generate sample packets, which was useful
to avoid misinterpretations or ambiguities from multiple docu-
ments. Through our assessment of vehicular network security
standards by IEEE and ETSI, we show that although they
provide solid security message formats, the implementations
may still be susceptible to weaknesses if the expected agent
behaviour is not enforced. We show an example of such a
weakness in the form of a misbinding attack when appropriate
checks are not performed by the vehicles. An interesting point
for discussion in the context of standardisation work lies in
formally describing agent behaviour towards received data and
appropriate security checks.

TAMARIN enables the formal analysis of several complex
protocols, and may require manual tuning in some cases. We
believe that, ideally, an automated security analysis should
be able to derive, without manual intervention, the set of
conditions for each cryptographic term in a protocol to remain
secret and provide the corresponding proof (currently, mod-
ellers must identify such conditions and specify them in the
lemmas). Our work to automatically extract key dependencies
is a step towards this long-term goal, and many interesting
challenges remain. An integration of the dependency analysis
in TAMARIN at runtime (during proving) would allow much
richer reasoning. For instance, this could allow the possibility
to consider time and properties that involve forward secrecy. In
addition, the extension of dependency relations to account for

REFERENCES

[1] D. Basin, J. Dreier, L. Hirschi, S. Radomirovic, R. Sasse, and
V. Stettler, “A formal analysis of 5g authentication,” in Proceedings of
the 2018 ACM SIGSAC Conference on Computer and Communications
Security, ser. CCS ’18. New York, NY, USA: Association for
Computing Machinery, 2018, p. 1383–1396.
[Online]. Available:
https://doi.org/10.1145/3243734.3243846

[2] L. C. Paulson, “Relations between secrets: two formal analyses of the

yahalom protocol,” Journal of Computer Security, 2001.

[3] S. Meier, B. Schmidt, C. Cremers, and D. Basin, “The tamarin prover
for the symbolic analysis of security protocols,” in Computer Aided
Veriﬁcation, N. Sharygina and H. Veith, Eds.
Berlin, Heidelberg:
Springer Berlin Heidelberg, 2013, pp. 696–701.

[4] Ensemble, “D2.8 Platooning protocol deﬁnition and communication

strategy,” 2018.

[5] Ensemble, “D2.9 Security framework of platooning,” 2019.
[6] 3GPP, “TR 21.915 Summary of Rel-15 Work Items (Release 15),

v15.0.0,” 2019.

[7] ETSI, “TS 102 636-4-3 Media-dependent functionalities for LTE-V2X,

v1.1.1,” 2020.

[8] ——, “EN 302 636-4-1 GeoNetworking; Part 4: Geographical address-
ing and forwarding for point-to-point and point-to-multipoint communi-
cations; Sub-part 1: Media-Independent Functionality, v1.4.0,” 2019.

[9] ——, “EN 302 636-5-1 Basic Transport Protocol, v2.2.0,” 2019.
[10] IEEE, “Std 1609.2 Security Services for Applications and Management

Messages,” 2016.

[11] IEEE, “Std 1609.2a Security Services for Applications and Management

Messages - Amendment 1,” 2017.

[12] ——, “Std 1609.2b Security Services for Applications and Management
Messages - Amendment 2: PDU Functional Types and Encryption Key
Management,” 2019.

[13] ETSI, “TS 103 097 Security header and certiﬁcate formats, v1.3.1,”

2017.

[14] B. Blanchet, “Security protocol veriﬁcation: Symbolic and computa-
tional models,” in Principles of Security and Trust, P. Degano and J. D.
Guttman, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2012,
pp. 3–29.

[15] S. Goldwasser, S. Micali, and R. L. Rivest, “A digital signature
scheme secure against adaptive chosen-message attacks,” SIAM J.
Comput., vol. 17, no. 2, p. 281–308, Apr. 1988. [Online]. Available:
https://doi.org/10.1137/0217017

[16] S. Goldwasser and S. Micali, “Probabilistic encryption,” Journal of

Computer and System Sciences, vol. 28, no. 2, pp. 270 – 299, 1984.

[17] C. Cremers, M. Horvat, S. Scott, and T. van der Merwe, “Automated
analysis and veriﬁcation of tls 1.3: 0-rtt, resumption and delayed
authentication,” in 2016 IEEE Symposium on Security and Privacy (SP),
2016, pp. 470–485.

[18] R. K¨unnemann, “Automated backward analysis of pkcs#11 v2.20,” in
Principles of Security and Trust, R. Focardi and A. Myers, Eds. Berlin,
Heidelberg: Springer Berlin Heidelberg, 2015, pp. 219–238.

[19] C. Cremers, M. Dehnel-Wild, and K. Milner, “Secure authentication
in the grid: A formal analysis of dnp3: Sav5,” in Computer Security
– ESORICS 2017, S. N. Foley, D. Gollmann, and E. Snekkenes, Eds.
Cham: Springer International Publishing, 2017, pp. 389–407.

[20] C. Cremers, B. Kiesl, and N. Medinger, “A formal analysis of {IEEE}
802.11’s wpa2: Countering the kracks caused by cracking the counters,”
in 29th {USENIX} Security Symposium ({USENIX} Security 20), 2020,
pp. 1–17.

[21] D. Dolev and A. Yao, “On the security of public key protocols,” IEEE
Transactions on Information Theory, vol. 29, no. 2, pp. 198–208, 1983.
[22] S. Meier, “Advancing automated security protocol veriﬁcation,” Ph.D.

dissertation, ETH Zurich, Z¨urich, 2013.

[23] B. Schmidt, “Formal analysis of key exchange protocols and physical

protocols,” Ph.D. dissertation, ETH Zurich, Z¨urich, 2012.

[24] J. Dreier, L. Hirschi, S. Radomirovic, and R. Sasse, “Automated un-
bounded veriﬁcation of stateful cryptographic protocols with exclusive
or,” in 2018 IEEE 31st Computer Security Foundations Symposium
(CSF), 2018, pp. 359–373.

[25] V. Cortier, S. Delaune, and J. Dreier, “Automatic generation of sources
lemmas in tamarin: Towards automatic proofs of security protocols,” in
Computer Security – ESORICS 2020, L. Chen, N. Li, K. Liang, and
S. Schneider, Eds. Cham: Springer International Publishing, 2020, pp.
3–22.

[26] J. Dreier, L. Hirschi, S. Radomirovi´c, and R. Sasse, “Veriﬁcation
of Stateful Cryptographic Protocols with Exclusive OR,” Journal of
Computer Security, vol. 28, no. 1, pp. 1–34, Feb. 2020. [Online].
Available: https://hal.archives-ouvertes.fr/hal-02358878

[27] G. Lowe, “A hierarchy of authentication speciﬁcations,” in Proceedings
10th Computer Security Foundations Workshop, 1997, pp. 31–43.
[28] D. Kozmai, “Converting tamarin to extended alice&bob protocol speci-

ﬁcations,” Bachelor’s Thesis, ETH, Z¨urich, 2016.

[29] M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Martı-Oliet, J. Meseguer,
and J. Quesada, “Maude: speciﬁcation and programming in rewriting
logic,” Theoretical Computer Science, vol. 285, no. 2, pp. 187–243,
2002,
[Online]. Available:
https://www.sciencedirect.com/science/article/pii/S0304397501003590

rewriting Logic and its Applications.

[30] A. Peltonen, R. Sasse, and D. Basin, “A comprehensive formal analysis
of 5g handover,” in Proceedings of
the 14th ACM Conference on
Security and Privacy in Wireless and Mobile Networks, ser. WiSec ’21.
New York, NY, USA: Association for Computing Machinery, 2021, p.
1–12. [Online]. Available: https://doi.org/10.1145/3448300.3467823
[31] H. Krawczyk, “Sigma: The ‘sign-and-mac’ approach to authenticated
difﬁe-hellman and its use in the ike protocols,” in Advances in Cryp-
tology - CRYPTO 2003, D. Boneh, Ed. Berlin, Heidelberg: Springer
Berlin Heidelberg, 2003, pp. 400–425.

[32] W. Difﬁe, P. C. Van Oorschot, and M. J. Wiener, “Authentication and
authenticated key exchanges,” Designs, Codes and cryptography, vol. 2,
no. 2, pp. 107–125, 1992.

[33] B. S. Kaliski Jr, “An unknown key-share attack on the mqv key
agreement protocol,” ACM Transactions on Information and System
Security (TISSEC), vol. 4, no. 3, pp. 275–288, 2001.

[34] S. Blake-Wilson and A. Menezes, “Unknown key-share attacks on the
station-to-station (sts) protocol,” in Public Key Cryptography. Berlin,
Heidelberg: Springer Berlin Heidelberg, 1999, pp. 154–170.

[35] J. Whiteﬁeld, L. Chen, F. Kargl, A. Paverd, S. Schneider, H. Treharne,
and S. Wesemeyer, “Formal analysis of v2x revocation protocols,” in
Security and Trust Management, G. Livraga and C. Mitchell, Eds.
Cham: Springer International Publishing, 2017, pp. 147–163.

[36] X. Li, T. Liu, M. S. Obaidat, F. Wu, P. Vijayakumar, and N. Kumar, “A
lightweight privacy-preserving authentication protocol for vanets,” IEEE
Systems Journal, vol. 14, no. 3, pp. 3547–3557, 2020.

[37] C. J. F. Cremers and S. Mauw, “Checking secrecy by means of partial
order reduction,” in System Analysis and Modeling, D. Amyot and A. W.
Williams, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2005,
pp. 171–188.

[38] B. Schmidt, R. Sasse, C. Cremers, and D. Basin, “Automated veriﬁcation
of group key agreement protocols,” in 2014 IEEE Symposium on Security
and Privacy, 2014, pp. 179–194.

APPENDIX A
AUTHENTICITY RELATION
In this appendix we prove that the authenticity relation
deﬁned in Section IV-A is transitive. We recall the following
deﬁnitions:

• Compromising a term p means either revealing it or being
able to generate a p(cid:48) that will be accepted by other nodes
as p. We assume that both of these actions (revealing and
generating a new key) can be performed inﬁnitely often.
• If K is a set of keys, then the authenticity dependency
relation (cid:57)(cid:57)(cid:75) ⊆ K × K is is deﬁned so that for two keys
kA, kB ∈ K, kA (cid:57)(cid:57)(cid:75) kB holds if compromising kB
allows the attacker to create another key k(cid:48)
A that will
be accepted by the other nodes as the legitimate kA.
We now proceed to prove that (cid:57)(cid:57)(cid:75)⊆ K × K is transitive.

Proof. Assume that there exists keys kA, kB, kC ∈ K such that
kA (cid:57)(cid:57)(cid:75) kB and kB (cid:57)(cid:57)(cid:75) kC. To prove transitivity, we then must

Fig. 7. Approximation of the dependency graph from the N2-based inter-RAN
variant of 5G handover.

show that kA (cid:57)(cid:57)(cid:75) kC. Assume that kC has been compromised,
then by the second deﬁnition above, the attacker can create
another key k(cid:48)
B that will be accepted by other nodes as kB.
By the ﬁrst deﬁnition, this means that kB is compromised.
Since kB is compromised and kA (cid:57)(cid:57)(cid:75) kB, then the attacker
can create a key k(cid:48)
A that will be accepted by other nodes as
kA. Thus kA (cid:57)(cid:57)(cid:75) kC.

APPENDIX B
5G HANDOVER GRAPHS

In this appendix we present approximations of the key
dependencies extracted automatically with our tool from a
5G handover model [30]. In addition to the steps described
in Section IV-B, a custom key derivation function (KDF with
arity 2) present in the 5G handover models must be considered.
Given a term k = KDF(a, b), then it holds that both a and
b must be known by an attacker in order to construct k.
This type of conjunctive dependency is not supported by our
current dependency relation, hence we approximate it in a
pessimistic (but safe) manner by creating two separate secrecy
dependencies k → a and k → b. Intuitively, we state that an
attacker could construct k by learning either a or b, whereas
in reality it must know both terms. This approximation (in
addition to our secrecy and authentication relations presented
in this work) of the (N2-based inter-RAN) 5G handover model
resulted in the graph illustrated in Fig. 7, which is unlabelled
for simplifying the presentation.

In order to give a concrete example of the structure of this
relation, we present in Fig. 8 a subgraph of Fig. 7 which
includes the all dependencies originating from a chosen term
’K-AMF3’. The secrecy of derived ’K-AMF’ keys is one of the

Fig. 8. Subgraph of dependencies extracted for target secret ’K-AMF3’.

veriﬁed properties of the 5G handover analysis. A ’K-AMF’
can either be derived directly from keys ’SUPI’ and ’K-SEAF’,
or from another ’K-AMF’ itself (we refer the reader to the
paper [30] for more details). Fig. 8 shows classes of keys (there
are several distinct classes of ’K-AMF’) and their relations. In
addition to the dependencies described earlier, the graph also
includes SUPI → sk-HN due to the asymmetric encryption of
’SUPI’ with the public key of the home network pk(sk-HN).

SUPI1K-AMF2K-AMF3K-AMF1sk-HN1K-SEAF1