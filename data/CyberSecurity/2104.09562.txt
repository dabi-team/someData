FLAW3D: A Trojan-based Cyber Attack on the
Physical Outcomes of Additive Manufacturing

Hammond Pearce (Member, IEEE), Kaushik Yanamandra, Nikhil Gupta (Senior Member, IEEE),
Ramesh Karri (Fellow, IEEE)

1

1
2
0
2

r
p
A
9
1

]

R
C
.
s
c
[

1
v
2
6
5
9
0
.
4
0
1
2
:
v
i
X
r
a

Abstract—Additive Manufacturing (AM) systems such as 3D
printers use inexpensive microcontrollers that rarely feature
cybersecurity defenses. This is a risk, especially given the rising
threat landscape within the larger digital manufacturing domain.
In this work we demonstrate this risk by presenting the design
and study of a malicious Trojan (the FLAW3D bootloader) for
AVR-based Marlin-compatible 3D printers (>100 commercial
models). We show that the Trojan can hide from programming
tools, and even within tight design constraints (less than 1.7
kilobytes in size), it can compromise the quality of additively
manufactured prints and reduce tensile strengths by up to 50%.

Index Terms—Cybersecurity, additive manufacturing, boot-

loader trojan, ﬁrmware trojan

I. INTRODUCTION

Additive Manufacturing (AM), also known as 3D printing,
is a technique whereby materials are deposited and fused to
produce volumetric parts. In recent years there have been con-
siderable advances in the ﬁeld, and AM is increasingly being
adopted across a range of industries (e.g. within aerospace [1],
biomedical
[2], and others). The advantages are numerous:
AM allows for the creation of complex and bespoke products
without complex tooling, allows for pull-based manufacturing
of products on demand rather than in advance, and rapid
prototyping to iterate over product designs.

With the increasing attention on AM cyber-physical systems
(CPSs), there has been an increased scrutiny on the cyberse-
curity of the production process. Potential vulnerabilities have
been highlighted at every step of the digital and physical sup-
ply chains [3]–[6]. The impacts and implications of successful
AM cyber attacks have been explored, with demonstrations
showing that parts can be modiﬁed at print using malicious
ﬁrmware [7]. Even subtle modiﬁcations can have insidious
consequences [8] (e.g. defects being introduced in drone
propellers causing them to fail prematurely in ﬂight [9]).

However, while these works highlight

the potential for
exploitation, they do not examine the actual pathways for
doing so within an AM CPS – yet in order to craft suitable
defenses for attacks on AM CPS, we must have an idea of
how they might be performed. In this paper we examine how
a malicious modiﬁcation can be introduced in a 3D printer
ﬁrmware so as to compromise print quality. This is a realistic
threat due to the hidden complexity of ﬁrmware in printers

from the ‘hobbyist’ to the ‘commercial grade’, and potentially
malicious and/or insecure code has already been highlighted
as a likely attack vector [5], [7]. While initial work studied
common printer ﬁrmware (such as in Marlin and Repetier [4])
for vulnerabilities, these analyses overlook the elemental piece
of the ﬁrmware/software stack, the bootloader.

Within the AM context, bootloaders are small ﬁrmware
components fundamental to the operation of the printer soft-
ware. Typically, they are not replaced/updated during the prod-
uct lifecycle. Bootloaders do two tasks: (1) install the higher-
level ﬁrmware into the controller memory when requested.
(2) launch the installed ﬁrmware after a normal power up
sequence. Crucially, bootloaders are generic, and often used
across different products – a common occurrence within the
culture of 3D printer implementations, which often share
hardware and software designs (e.g. those popularized via
the open-source RepRap project [10]). This means a single
bootloader Trojan may be utilized to target a large number of
AM machines, making it an attractive attack mechanism.

In this work we consider the bootloaders installed into the
low-level controllers within commercial 3D printers (where
they might be one part of the control system) and in hobbyist
3D printers (where they can be the only controller). However,
though this paper frames and demonstrates an attack around
low-end desktop 3D printers,
these mechanisms could be
used to target any CPS with embedded ﬁrmware running on
insecure hardware (e.g. PCB printers, IC fabrication and test).

A. Contributions

This is the ﬁrst comprehensive study of a bootloader-based
attack on AM CPS. Contributions are 4-fold, and organized
in this paper as follows: §II presents a study of the related
work and attack surface for 3D printers given their underlying
implementations. §III presents a design space exploration of
a proof-of-concept ﬁrmware Trojan FLAW3D (pronounced
‘ﬂawed’) which targets Marlin-compatible AVR controllers in
3D printers. §IV performs a qualitative and quantitative eval-
uation of the Trojan by examining two different mechanisms
that can compromise print quality, and in §IV-E we provide
a discussion and walkthrough of how the Trojan could be
detected and prevented. Finally, §V concludes.

H. Pearce is with the Dept. of Electrical and Computer Engineering, New

York University, NY 11201 USA (e-mail: hammond.pearce@nyu.edu)

K. Yanamandra is with the Dept. of Mechanical and Aerospace Engineering,

New York University, NY 11201 USA (e-mail: vsy212@nyu.edu)

N. Gupta is with the Dept. of Mechanical and Aerospace Engineering, New

York University, NY 11201 USA (e-mail: ngupta@nyu.edu

R. Karri is with the Dept. of Electrical and Computer Engineering, New

York University, NY 11201 USA (e-mail: rkarri@nyu.edu)

II. BACKGROUND AND RELATED WORK

A. Attacker Motivation and Attack Taxonomies

The two major motivations for an attack on an AM CPS
are [3]: (1) IP theft via product reverse engineering and/or
counterfeiting, and (2) sabotage of either the printed part or the
3D printer producing them. Both result in ﬁnancial outcomes,

 
 
 
 
 
 
2

Reference

Type

Summary

Moore et al. [4]
Moore et al. [7]
Belikovetsky et al. [9]
ESET [11]
Slaughter et al. [12]
Zeltmann et al. [8]
OSHA [13]
Mahesh et al. [6]
Prinsloo et al. [14]
Graves et al. [15]
Yampolskiy et al. [16]
Yampolskiy et al. [17]
Gupta et al. [3]

Vulnerability analysis
Speciﬁc compromise
Speciﬁc compromise
Speciﬁc compromise
Speciﬁc compromise
Speciﬁc compromise
Safety violation example
Survey
Survey
Survey
Survey
Taxonomy
Survey / Taxonomy

Automatic checking of 3D printer ﬁrmware for vulnerabilities.
Demonstrates the potential for malicious 3D printer ﬁrmware to introduce defects into 3D printed parts.
Automatically adding defects to 3D printed drone blades.
ACAD/Medre.A worm in AutoLISP steals engineering CAD ﬁles.
Temperature manipulation reliably introduces defects in metal AM.
Discusses how subtle defects can be deliberately introduced to 3D prints that reduce print quality.
Company ﬁned for 3D printer workplace safety violations leading to explosion.
Survey of cybersecurity state of the art for AM. Attack / defense modelling, taxonomies, case studies.
Security risks within the Industry 4.0 manufacturing domain.
Risk survey and attack / defense modelling for AM, noting differences with traditional manufacturing.
Survey and analysis of potential avenues for 3d printers to be ’weaponized’.
Specifying manipulations as tuples of {inﬂuenced elements, inﬂuences} giving {affected elements, impacts}.
Examining the supply chain and build process for AM cybersecurity vulnerabilities.

Table I: Survey of literature discussing attacks on AM printers.

either in the attacker gaining proprietary (valuable) knowledge,
or in reducing the reputation or value of the attacked system.
Overall in the literature a number of potential and realized
attack strategies have been published, with a summary of
these presented in Table I. Many of the works focus on the
motivations, taxonomy, and theoretical basis for attacks, rather
than the speciﬁc technical steps required to achieve them. In
addition, where speciﬁc attack methodologies are detailed,
attack implementation is either considered out of scope or
implemented within the higher-level cyber realm (such as
within [9] and [11]). Importantly, when considering attacks in
this higher-level area, many defenses already exist via standard
information and cybersecurity best practices (e.g. ensuring
trusted software updates, ﬁrewalls, virus scanning, etc.). The
state of the art is less detailed when considering attacks on
the low-level hardware of 3D printers. The two major works
in this space come from [4], which detailed an exploration of
3D printer ﬁrmware vulnerabilities (e.g. to denial of service
and data corruption attacks), and in [7], which augments 3D
printer ﬁrmware directly to add malicious code. However,
while effective, their implementation strategy of their attacks
on the 3D printer ﬁrmware has several technical shortcomings
– speciﬁcally, it relies on simply changing ﬁrmware codes
directly, re-compiling, and re-downloading. If a program’s
source code can be changed in your attack model (e.g. by a
malaﬁde insider), then any behavior change is possible. As a
result, it is a primary focus of designers to audit their ﬁrmware
(as in [4]) and detect these changes before deployment.

In this paper we wish to expand the vision for low-level
attack strategies and motivate the need for more defensive
mechanisms within 3D printers. For this, we present an attack
strategy which does not rely on changing the 3D printer
ﬁrmware directly. We present this through an examination of
a complete attack life-cycle, performing a deep dive into the
technical details of how common 3D printers function, and
include installation mechanisms, exploitation strategies and
triggers, and mechanisms to avoid detection and removal.

B. Software and Hardware Trojans

In the cybersecurity domain, ‘Trojan Horses’ refer to de-
liberate fault-like modiﬁcations made to a design for mali-
cious aims, either to steal information or to cause system
failure [18] (aligning them closely with the aforementioned
CPS attack motivations!). Trojans, which may be created
by malicious actors working in a product’s design team or

from compromised CAD tools used during product creation,
have three essential characteristics: malicious intent, evasion
detection, and activation rarity [19]. A Trojan may seek to
leak cryptographic information / design ﬁles, cause digital
/ real-world damage, reduce operational reliability / product
life-time. While typically software-based [20], there has been
recent attention on hardware Trojans embedded in systems,
for instance within integrated circuits [19] or encoded into
PCBs [21]. Although out of scope for this work, this does
raise interesting recursive possibilities within AM for PCBs
(i.e. PCB printers [22]). Here, a ﬁrmware Trojan in the printer
could insert hardware Trojans into produced PCBs.

C. The 3D Printer Attack Surface

Printer

Commercial
grade?

“Open”?

Marlin
compatible?

Native
networking?

Support F/W
updates?

Stratasys Elite
Ultimaker S5 Pro
Ultimaker 2+
Makerbot Replicator Z18
Makerbot Replicator (orig.)
Anet A8
Printrbot Simple

Y
Y
Y
Y
N
N
N

N
N
Y
N
Y
Y
Y

N
N
Y
N
Y
Y
Y

Y
Y
N
Y
N
N
N

Y
Y
Y
Y
Y
Y
Y

Table II: Features of select commercial / hobbyist 3D printers

Thanks largely to the quality and success of the open source
3D printer projects, many 3D printer implementations (hard-
ware and software) are closely related. The RepRap 3D printer
project [10], itself based on early industrial Fused Deposition
Modelling (FDM) printers, has inspired at least 81 models of
3D printers directly [23] (with the derivatives often going on
to inspire further designs). Table II summarizes some exam-
ples. 3D printers are a mix of “open” (i.e. open schematics,
hardware layouts, and software) and “closed” (more likely the
commercial printers with trade secrets). The (listed) printers
all have some method for updating the installed ﬁrmware.
In general, “open” printers are often compatible with third-
party ﬁrmware – the most popular being the Arduino-based
Marlin [24], which supports over 100 printer models [25].
While formerly a premium feature, increasing numbers of
3D printers are also beginning to include native support for
networking. Where this isn’t included, 3D printers may be
networked by wiring connections to external print servers, e.g.
Octoprint [26]. A “networked” 3D printer may just include
an Octoprint server internally! Overall,
the networking of
3D printers is becoming a concern, especially when they
are exposed to the wider internet (e.g. IoT scanning website
Censys estimates > 2500 Octoprint servers exposed globally1).

1Search using https://censys.io/ipv4?q=octoprint

3

Figure 1: Generic DM architecture for a 3D printer

All 3D printers have their low-level hardware control (e.g.
control of the sensors and actuators) managed by time-
predictable microcontrollers. Computationally intensive func-
tionality such as GUIs and networking (if present) are man-
aged by more powerful embedded or general purpose devices
(e.g. as in the Ultimaker S5 Pro) or by external connected
devices. An example of this kind of hierarchy can be seen
in a generalized 3D printer architecture, detailed in Figure 1.
Here, the high-level functionality (networking, slicing, and so
on) is provided by an external general purpose computer - for
example, a Raspberry Pi, which could be running software
such as Octoprint or Ultimaker Cura. This is interfaced with
the printer control ﬁrmware, which is distributed across a
network of microcontrollers. Crucially, unlike in the Raspberry
Pi (and other general purpose computers), where mechanisms
such as “Veriﬁed Boot” [27] or “Secure Boot” [28]) can
be used to ensure the security of the low-level ﬁrmware,
there is no speciﬁc functionality to perform this in low-end
microcontrollers. Security instead becomes the responsibility
of the installed bootloader (if deemed necessary) – which may
include features for cryptographically checking the ﬁrmware
updates before installation [29]. Of course, if the bootloader
itself is replaced (either via external hardware circuitry or via
the network-connected high-end embedded systems), nothing
may verify that the replacement bootloader is free of malice.
Further, as the bootloader is not part of the ﬁrmware (e.g.
Marlin), even if the ﬁrmware is audited for security risks,
the bootloader may be excluded from this analysis. This
is especially a concern in desktop / hobbyist AM, where
bootloaders are often provided in binary form (preventing
adequate auditing of their source codes) and re-used across
many compatible devices.

If the adversary has (or has had) physical access to the
printer-under-attack or is otherwise able to trick someone with
physical access into installing the malicious bootloader, then
four attack vectors are possible, as depicted in Fig. 2: (1) the
original manufacturer of the printer or a malicious insider, (2)
a malicious user with access to the printer, (3) a third-party
(e.g. a website) provides a pre-compiled malicious bootloader
or (4) a third-party provides malicious bootloader source code
and a na¨ıve user installs it without adequate auditing.

This risk is expanded by the presence of the network of
microcontrollers. As can be seen in Fig. 1, which represents
a common architecture used within 3D printers, there are
two different microcontrollers which could each individually

Figure 2: Attack surface for FLAW3D.

interfere with the correct operation of the device. This only
becomes more challenging given commercial and industrial-
grade additive manufacturing machines, which can feature tens
to hundreds of microcontrollers all running different code.

III. THE FLAW3D BOOTLOADER

A. Goals

In this section we discuss the design space exploration for
the creation of a new ﬁrmware Trojan called FLAW3D. It will
target AVR-based desktop 3D printers which run the Marlin
printer ﬁrmware. We note that the attack will not target any
speciﬁc feature of any printer, rather, it aims to misuse features
from the underlying AVR microcontrollers and the operating
Marlin ﬁrmware. We also note that the general methodology
in this section can be used to target other printers, including
at the ‘commercial grade’ by malaﬁde insiders.

Overall we will consider an adversary that aims to sabotage
a design ﬁrm by reducing the quality of printed designs. In
order to achieve this we seek to give the Trojan the ability to
both relocate and remove printed material.

the
We must also work within constraints: speciﬁcally,
Trojan must not increase the compiled size of the bootloader
beyond the boot ﬂash size limit. For example, in the AT-
mega2560, a microcontroller commonly used in 3D printers,
this is just 8192 bytes, of which 5786 bytes are already taken
by the existing bootloader code, leaving approx. 2406 bytes
for the Trojan).

B. Arduino-compatible bootloaders for AVR

Marlin is installed on AVR-based 3D printers via compatible
software (e.g. the Arduino IDE, the Ultimaker Cura slicer)
running on a secondary machine (e.g. a Raspberrry Pi, or a
general purpose Windows or Linux computer). The gatekeeper
for this process is the AVR-based bootloader which resides
on the target microcontroller. Upon power-up it executes a
simple state machine, which initializes a UART communi-
cation peripheral and awaits valid bootloader commands. If
the existing main
no commands arrive before a timeout,
ﬁrmware is initialized if available. If a command does arrive,
the bootloader will execute it. These commands, which are
based on a subset of the STK500 standard [30],
include
instructions to read and write ﬂash and EEPROM memory.
Three observations are important.
Observation One: though both bootloaders and applications
are installed into the microcontroller ﬂash memory,
they
do not run simultaneously. Bootloaders run ﬁrst, eventually
loading the main ﬁrmware. When this happens, bootloaders

Sensors, Actuators..."Interface Board""Main Board"Connected PC (e.g. Raspberry Pi)ExternalNetworkUSB translation(e.g. ATmega16U2)Main Firmware uC(e.g. ATmega2560)OLED DisplayMotor Drivers,Sensors, Heaters...SDCardButtonsfunc()bad()001011011001(1)(3)(4)NaïveuserMalicioususerMaliciousManufacturerMaliciousWebsites(2)for bootloaders to install

are entirely unloaded, with the stack and global memory reset
and reconﬁgured for the main application.
Observation Two:
the main
ﬁrmware, all memory values for the binary must pass through
them both during upload (installation) and download (veri-
ﬁcation). A secure bootloader could perform cryptographic
and data integrity checks, but regular Arduino-compatible
bootloaders do not. Instead, data veriﬁcation is managed by
the off-chip toolchain reading all memory addresses after
installation and ensuring they match the expected.
Observation Three: though Arduino-compatible bootloaders
do not
the underlying hardware
supports this. Interrupts function by preempting control ﬂow
to speciﬁc locations in memory (known as interrupt vector
tables). As the bootloader and the main ﬁrmware are distinct
applications, they must have different vector tables. Hence, the
AVR architecture supports changing the address of the vector
table using a special control register IVSEL.

tend to utilize interrupts,

C. Design of a generic Arduino-compatible Trojan for AVR

Using the bootloader source code provided by Arduino
at [31] as a start point, we now craft a Trojan for an
ATmega2560, noting that the steps for other common AVR
microcontrollers are largely the same. Firstly, in order for the
Trojan to function it needs to be able to inject instructions
into the program executed by the main ﬁrmware. Based on
Observation Three, this is achieved via the interrupt vector
table select register IVSEL. By default this register is conﬁg-
ured to make interrupts jump to the vector table associated
with the main ﬁrmware. If changed, the machine will instead
jump to bootloader program space upon an interrupt occurring.
Crucially, the startup code (i.e the code that runs ‘before
main()’) generated by the AVR compiler avr-gcc does not
check or set the IVSEL register — nor does the ﬁrmware
we are interested in hijacking (Marlin). This means that
if we deﬁne our own bootloader interrupt service routines
(ISRs), and set IVSEL before booting the main application,
the bootloader ISRs will replace the main application’s.

However, if the main application deﬁnes ISRs, and those
ISRs are never called (because the hardware is calling the
wrong interrupt vectors) then the presence of the Trojan will
be easily noticed. Thus, the Trojan must embed within its ISRs
calls to the main application ISRs (using the addresses of the
original vector table). In this way it wraps the application ISRs
– allowing injection of both prologue and epilogue instructions
to each routine. Code to perform these injections, using the
avr-gcc compiler, is presented in Listings 1 and 2.

While this structure allows for the injection of instructions,
declaring state (variables) that will persist outside of the ISRs
is a separate, more difﬁcult issue, as the processor memory is
reinitialized by the main application (Observation One). In
other words, the Trojan has no safe way of storing global or
static variables outside of ISR invocations.

To resolve this we consider the implementation of the AVR’s
Harvard-style memory architecture. The data memory, which
is separated from the instruction memory, is partitioned into
register space (in the ﬁrst 256 bytes) and general RAM. In the

4

/ / i n j e c t
ISR ( . . .

c o d e i n t h i s v e c t o r

v e c t ) {

. . .

/ / p r o l o g u e

i n j e c t i o n h e r e

a d d r e s s

t h e n r u n CLI
r e t u r n
a f t e r

ISR w i l l
i n t e r r u p t s

i s

t h i s

a p p l i c a t i o n ’ s v e c t o r
i m p o r t a n t a s

/ / c a l l
/ /
/ / u s i n g RETI , which r e − e n a b l e s
/ /
asm v o l a t i l e ( ” c a l l

t h e n e x t

[ . . .

t h e app .

” c l i \n \ t ” ) ;

. . .

/ /

e p i l o g u e

i n j e c t i o n h e r e

i n s t r u c t i o n − a CLI p r e v e n t s

t h i s

v e c t a d d r ] \ n \ t ”

1

2

3

4

5

6

7

8

9

10

11

12

13

14
15 } / / o u r

ISR w i l l

r e t u r n w i t h a n o t h e r RETI

Listing 1: Structuring an AVR bootloader ISR to ‘inject’ code

1 v o i d main ( v o i d ) {
2

temp ;

/ / c r e a t e a copy o f MCUCR
c h a r
temp = MCUCR;
/ / E n a b l e c h a n g e o f
MCUCR = temp |
/ / P o i n t
MCUCR = temp |

i n t e r r u p t s

(1<<IVCE ) ;

(1<<IVSEL ) ;

. . .

/ / r e s t o f

t h e b o o t l o a d e r

3

4

5

6

7

8

9

10
11 }

I n t e r r u p t V e c t o r

l o c a t i o n

a t B o o t l o a d e r F l a s h s e c t i o n

Listing 2: Two-step process changes IVSEL in main()

general RAM, static objects and global variables are placed in
the low addresses by the C compiler, and the stack (which
stores local variables and function return addresses) grows
from the highest address downwards.

To keep track of the stack’s position, two registers are
provided – SPH and SPL (for the high and low byte of the
16-bit address respectively). During the startup code of an
AVR application one of the ﬁrst tasks that is performed is
re-initialization of these two registers. An example which
sets SPH/SPL to 0x21/0xFF can be seen in the ATmega2560
startup disassembly in Listing 3. Note that, given the stack
grows downwards, if the values loaded into SPH and SPL
are decreased, then the addresses above their new value are
excluded from the stack. This would free them for the Trojan.

1 00000000 < v e c t o r s >:
0 : 0 c 94 e7 10
2
. . .
. . .

e t c

;

3

jmp 0 x39dc ;

4
5 000039 dc < d t o r s e n d >:
6

r 1

r1 ,
0 x3f ,

e o r
o u t

c l e a r SREG

;
39 dc : 11 24
39 de : 1 f be
; c o d e t o s e t SPH / SPL
39 e0 :
c f e f
39 e2 : d1 e2
39 e4 : de b f
39 e6 : cd b f
. . .

l d i
l d i
o u t 0 x3e ,
o u t 0 x3d ,

e t c

. . .

;

r28 , 0xFF ;
r29 , 0 x21 ;
r 2 9 ;
r 2 8 ;

r 1

7

8

9

10

11

12

13

14

jump < d t o r s e n d >

l o a d 0xFF t o R28
l o a d 0 x21 t o R29
s e t SPH t o R29 ( 0 x21 )
s e t SPL t o R28 ( 0 xFF )

Listing 3: Disassembled Marlin ATmega2560 startup code

Now, recall Observation Two: all instructions making up
the main application are passed through the bootloader during
installation. That is, the bootloader is responsible for receiving
the compiled application binary over UART and saving it
into ﬂash memory. In addition, though the startup code which
initializes SPH and SPL may be located unpredictably within
the binary, the speciﬁc instructions that make it up do not
change from application to application, and further, are usually
located at the ﬁrst jump from the vector at program address
0000 (the reset vector). This means that during the installation

loop,
the bootloader can scan for the pattern of 8 bytes
which sets SPH/SPL (Lines 10-13 in Listing 3) and then alter
those bytes that represent the data address before saving the
program into application ﬂash. To minimise detection, the
Trojan should change the value only slightly (otherwise the
application has a higher chance of running out of memory
unexpectedly during operation), so it alters the instruction ldi
r28, 0xFF to ldi r28, 0xF0 (subtracting 15). This way 15
bytes of data memory are excluded from the stack for use by
the Trojan for saving variables to global state.

While the edit to the program binary can be detected in the
normal case, now recall again Observation Two: speciﬁcally
that the veriﬁcation of the binary is also done via reading out
the saved binary using the same bootloader. This means that
by simply performing the edit step in reverse, the bootloader
can change the binary values back to the expected when
the programming tool attempts to ensure that the program
has been uploaded correctly. This means that based on the
described Trojan design, programming tools which rely on
the bootloader to upload, download, and verify the installed
program cannot detect the malicious modiﬁcations.

D. Design of FLAW3D

Returning to the original goal of subvert printing quality,
consider now the ﬂow of information in a 3D printer. Print
commands, which detail control sequences for the motors,
extruders, and heaters of the printer, are speciﬁed in textual
g-code language. These originate from a computer running
a slicer program that converts 3D computer aided design
models into the g-code. From the point of view of the
controller running the printer, the commands arrive character-
by-character via the UART peripheral.

It is thus the goal of FLAW3D to edit this incoming g-code,
using the Trojan framework from §III-C as the starting point.
Using the ISR code injection mechanism the reception of
valid g-code can be compromised and intercepted ‘in-ﬂight’.
The Trojan can then edit received commands before they are
processed by the main application.

While it might appear that this can be done by interfering
with the UART peripheral, (e.g. editing the received character
during the injection), two hardware constraints prevent this:
(1) the UART RX register is read-only, and (2) reading from
the UART RX register has side effects; once read, it unlocks
the hardware for further reception. We thus instead consider
how the bootloader can interfere with the higher level ﬁrmware
(Marlin). Marlin, prior to processing the received g-code with
the main process loop, uses its UART RX ISR to store received
characters in a ring buffer (depicted in Fig. 3).

As the AVR has no memory protection, the Trojan can
access the entire memory space from the compromised ISRs.

Figure 3: Ring Buffer implementation in Marlin.

1 00000000 < v e c t o r s >:
. . .
. . .
2
5 0 : 0 c 94 b7 83
. . .
. . .

e t c

e t c

;

;

3

4

jmp 0 x1076e ;

5

jump t o UART RX ISR

5
6 0001076 e < v e c t o r 2 0 >:
7

;

. . .

e t c

. . .
1 0 7 8 6 : 20 91 24 03
1078 a : e0 91 23 03
. . .

e t c

. . .

;

8

9

10

l d s
l d s

r18 , 0 x0324
r30 , 0 x0323

Listing 4: Disassembly of UART RX ISR in Marlin on AVR

If the location of the ring buffer can be deduced, the Trojan can
read and edit the g-code commands prior to their processing
by the main application. To accomplish this, consider Obser-
vation Two. As the Trojan can access the ﬂash memory of the
microcontroller, it can scan the UART ISR of Marlin, revealing
two distinctive lds commands near the start (Listing 4).

The addresses in these two instructions correspond to the
location in memory of the head and tail pointers of the
ring buffer. By default the compiled Marlin ﬁrmware’s data
structure layout will place these pointers 128 bytes after of
the ring buffer itself. This means that the smaller of the two
addresses (e.g. 0x0323) minus 128 gives the root address in
memory of the ring buffer where the incoming g-code is
stored. FLAW3D thus encodes this behavior as a function
find ring buffer() to do this task automatically prior
to launching the main application ﬁrmware. The function
performs this by traversing the binary of the main application,
starting from the (constant) UART RX ISR vector location,
and following the program jumps and the linear path of
execution until it ﬁnds these back-to-back lds commands. If
it does not identify them within 256 instructions, it aborts,
and the Trojan is rendered dormant. If it succeeds, it stores
the head pointer, tail pointer, and root address in the global
state variables that we established earlier (in the top 15 bytes
of the AVR memory). FLAW3D can then use these pointers
with string manipulation code injected as an epilogue of the
main application UART RX ISR: and now, incoming g-code
can be edited.

As standard string manipulation in C (performed by func-
tions such as sscanf to read out variables and sprintf
to rewrite them) are too large to use within the context of
a bootloader, FLAW3D relies on a simple embedded state
machine. This examines incoming g-code strings character by
character, and can internally convert received ASCII-encoded
ﬂoating point values into integer-type ﬁxed-point notation. If
the bootloader detects that a target value to edit is arriving, it
suppresses the Marlin ﬁrmware’s normal behavior by editing
the ring buffer head pointer addresses to hide the incoming
characters. Then, once the target value has been entirely
received, the bootloader can process and edit it before restoring
the correct pointer value and allowing Marlin to detect and
process the command.

IV. INDUCING DEFECTS WITH FLAW3D

A. Overview

FLAW3D scans and alters incoming g-code before process-
ing by Marlin. Given the restricted space for Trojan code (e.g.
∼2406 bytes on ATmega2560), the edits need to be simple.

1 X12.3 Y45.6 E78.9G\nHead (read)Tail (write)Start addr.End addr.Messages can wrap aroundReceive characters hereProcess g-code from hereNewline triggers processingComplex edits may also cause noticeable delays. Given these
constraints, we present two Trojan methodologies, with code
compiled using avr-gcc version 5.4.0 with optimization -Os.
To measure the impact of the Trojans on print quality, strength
tests were performed using the tensile test specimen design E8
from ASTM A370-20 [32] (Fig. 4). To check consistency, sam-
ples were printed with two different sets of slicing parameters
using two different anonymized commercially available AVR-
based 3D printers which use Marlin internally (Table III).

d
e
z
i
l
a
m
r
o
N

)

%

(

t
n
e
m
e
r
u
s
a
e
m

100
80
60
40
20
0

Max. load (N/N)

Mass (g/g)

6

0

10

20

30

40

50

Reduction in material (%)

Printer info.

(Print) Slicing settings

ID

A
B

Cost (New)
(USD)

Layer height
(mm)

Line width
(mm)

Inﬁll
strategy

Inﬁll line
distance (mm)

2499
599

0.15
0.15

0.35
0.4

Cubic (18%)
Grid (10%)

5.83
8.0

Table III: Printers and print settings.

While it is customary to report strength in the form of
maximum load sustained divided by the cross-section area,
as the Trojan modiﬁes the printer g-code the exact cross-
sectional area may vary from test to test. Hence, in this paper
the normalized maximum load sustained by the specimens
before failure is compared, as all specimens have the same
origin test geometry. This is performed destructively using an
Instron 4467 universal test system. Though it is deterministic,
to minimize printer “noise” each sample is printed ﬁve times
and test results averaged.

B. Trojan Attack 1: Material Reduction

This Trojan attack reduces the amount of printed material.
FLAW3D uniformly scans for the G1 commands (linear move)
in the incoming g-code which include the extrusion command
(character E). Then, the extrusion value is decreased by some
percentage. For instance, a command G1 X2 Y3 E4, which
moves to (X,Y) (2,3) and extrudes 4mm of ﬁlament can be
edited to G1 X2 Y3 E2 to reduce the material by 50%. While
this reduces the maximum tensile strength of the specimen,
the attack is easily detectable, both by weight tests and by
visual inspection in severe cases (Fig. 5).

The normalized test results are given in Fig. 6 and 7. As
can be seen, material reduction reduces mass and reduces
maximum tensile load fairly linearly. The attack increases the
bootloader size from 5786 bytes to 7422 bytes, an increase of
1636 bytes.

Figure 4: Example control group test specimen.

Figure 6: Printer A - Max. tensile load vs material reduction.

d
e
z
i
l
a
m
r
o
N

)

%

(

t
n
e
m
e
r
u
s
a
e
m

100
80
60
40
20
0

Max. load (N/N)

Mass (g/g)

0

10

20

30

40

50

Reduction in material (%)

Figure 7: Printer B - Max. tensile load vs material reduction.

C. Trojan Attack 2: Material Relocation

In the g-code, the extrusion values are presented within an
absolute frame of reference. This means that if one extrusion is
removed, the next extrusion will deposit extra material to keep
the values consistent. Consider three back-to-back commands
(G1 X1 Y2 E3), (G1 X2 Y3 E4), and (G1 X3 Y4 E5). The
total extruded material is 3mm after the ﬁrst command, 4mm
after the second (it deposits 1mm), and 5mm after the third.
If the Trojan alters the second command to (G0 X2 Y3), no
material is extruded during its execution, although the head
continues along the same route. Crucially, the third command
now deposits 2mm and the total material used remains 5mm.
This is the basis of the second attack, which scans for G1
linear movement commands with extrusions, and converts a
subset (either 1-in-4, 1-in-3, or 1-in-2) into G0 linear move-
ment commands with no extrusions. To further reduce the
visibility of the attack, we also add a new activation trigger:
we preclude the Trojan from activating until 25% of the part
is printed, and deactivate it after 75% is printed. For this,
we track the M73 commands which are used to update the
percentage remaining on printer displays. Fig. 8 shows the
consequences on a specimen cross section.

The results of this attack are depicted in Fig. 9. All printed
objects remain within 1-2% of the control masses, and despite
the edits, the parts are visually similar (example: Fig. 10).
While all edits weakened the parts, the attack on Printer B was
more effective than the attack on Printer A, which is likely

Figure 5: Example 50% material reduction.

Figure 8: Simulation of (L) original and (R) 1-in-2 relocation.

7

Printer A

Printer B

0
0
1

0
0
1

5
8
.
8
9

1
7
.
7
9

8
6
.
4
9

4
4
.
8
8

2
8
.
3
9

7
7
.
9
7

100

80

60

d
e
z
i
l
a
m
r
o
N

)

%

(

d
a
o
l

.

x
a
m

C ontrol

4

1 in

3

1 in

2

1 in

Figure 9: Material relocation Trojan.

Figure 10: Example 1-in-2 material relocation. No obvious
changes are visible w.r.t. specimen quality.

due to the different slicing inﬁll strategies (10% compared to
18%). This attack increases the bootloader size to 6986 bytes,
a 1200 bytes increase, smaller than the previous attack due to
the simpler string manipulations even with M73 tracking.

D. Discussion

Different attacks can change the strength proﬁles of printed
parts in different ways. Reducing the printed material is simple
and reliable, but noticeable (e.g. via weight). Material reloca-
tion is harder to detect, but less consistent, as evident from
the differing effectiveness on Printer A compared to Printer
B. Given its small size, (<1.4KiB) the attack surface for such
Trojans within AM CPS is enormous, since a large number of
microcontrollers are present in complex ‘commercial-grade’
systems which have large feature sets. In addition, the Trojan
could be made elusive by altering its trigger. While in this
study the attack activated in every print, it would be insidious
to activate rarely, with the intent of lowering the average
quality of service /
institutional reputation. Parts that are
unpredictably faulty can get through certain quality controls,
and if targeted at critical products could have catastrophic con-
sequences (for instance consider a Trojan within 3D printers
for aerospace components [1] or bespoke medical parts [2]).

E. Starving FLAW3D

Since this is a bootloader Trojan, it is difﬁcult to detect at
the software level – especially since it has the ability to alter
high-level ﬁrmware prior to its installation. In other words,
even if the defenses are encoded within user applications, they
could be detected and disabled prior to activation.

However, as FLAW3D alters the printer’s behaviour, it is
not
impossible to detect. Side channels can be monitored
with external devices such as cameras and microphones from
an arms length – though this would be intricate as the
Trojan effects extrusions and not the head movement. Careful
measurement of the ISR delays could reveal the presence of
injected instructions. External programming tools could be
utilised – if monitored with a debugger, the alternate ISR

Figure 11: Debugger observing code injection ISR

jumps can be noticed. An example of this is presented in
Fig. 11, which shows how the Atmel Studio debugger for an
ATmega328P can be used to deduce a bootloader performing
a code injection using the methodology in §III-C. Here the
Trojan is designed to ﬂip the ﬁfth bit of PORTB whenever the
target interrupt occurs. Within the debugger, we can observe
that the assembly at (a) is the interrupt target, which then
jumps to the injection exploit at (b), ﬂipping a bit in PORTB
before the correct ISR is jumped to at (c).

That said, in order to perform this test the embedded system
must be designed to allow access to the AVR’s debugging
(JTAG) port, and toolchains must be utilized that support ﬁrst-
class debugging (e.g. not the Arduino IDE, which offers no live
debugging facilities). This access is not guaranteed, especially
given the design constraints of the chosen AVR device and
embedded system. For instance, on the ATmega2560,
the
JTAG pins are multiplexed with four of the ADC inputs. This
means that when the ADCs are in use then the JTAG port
is rendered unavailable. This is the case in Printer A. An
alternative that does not require the debugging port is to export
the bootloader itself from the ﬂash memory of the AVR. As
this is performed using the programming hardware of the AVR
chip itself, there is no way for the bootloader to edit itself
before download. Then, the bootloader may be disassembled /
decompiled and audited for malicious behaviour, though this
will require specialist tools and knowledge.

As low-end microcontrollers do not support features such
as secure boot, further prevention within the hardware can
come if they are exchanged for something with more features.
Policies surrounding ﬁrmware installation/inspection (includ-
ing bootloaders) could be introduced to mitigate the attack
vectors in §II-C. Overall this work motivates the inclusion of
a trusted execution environment [33] within AM printers.

V. CONCLUSIONS

The cybersecurity of AM CPS is important. We examine a
case study in detail, presenting the design space exploration of
a bootloader Trojan, including (a) methodology for inclusion,
(b) evasion of detection, (c) trigger customization, and (d)
malicious payload. Even within tight constraints (both attacks
less than 1.7KB in size!), we were able to craft attacks which
lowered the strength of printed parts by up to 50%. Though

8

[13] “After explosion, US Department of Labor’s OSHA cites 3-D printing
ﬁrm for exposing workers to combustible metal powder, electrical
hazards | Occupational Safety and Health Administration.” [Online].
Available: https://www.osha.gov/news/newsreleases/region1/05202014

[14] J. Prinsloo, S. Sinha, and B. von Solms, “A Review of Industry
4.0 Manufacturing Process Security Risks,” Applied Sciences, vol. 9,
no. 23, p. 5105, Jan. 2019, number: 23 Publisher: Multidisciplinary
Digital Publishing Institute. [Online]. Available: https://www.mdpi.com/
2076-3417/9/23/5105

[15] L. M. G. Graves, J. Lubell, W. King, and M. Yampolskiy, “Characteristic
Aspects of Additive Manufacturing Security From Security Awareness
Perspectives,” IEEE Access, vol. 7, pp. 103 833–103 853, 2019.
[16] M. Yampolskiy, A. Skjellum, M. Kretzschmar, R. A. Overfelt, K. R.
Sloan, and A. Yasinsac, “Using 3D printers as weapons,” International
Infrastructure Protection, vol. 14, pp. 58–71,
Journal of Critical
Sep. 2016. [Online]. Available: https://www.sciencedirect.com/science/
article/pii/S1874548215300330

[17] M. Yampolskiy, P. Horv´ath, X. D. Koutsoukos, Y. Xue, and
J. Sztipanovits, “A language for describing attacks on cyber-
Infrastructure
physical systems,” International Journal of Critical
Protection, vol. 8, pp. 40–52,
[Online]. Available:
https://www.sciencedirect.com/science/article/pii/S1874548214000602

Jan. 2015.

[18] J. Vosatka, “Introduction to Hardware Trojans,” in The Hardware Trojan
War: Attacks, Myths, and Defenses, S. Bhunia and M. M. Tehranipoor,
Eds. Cham: Springer
International Publishing, 2018, pp. 15–51.
[Online]. Available: https://doi.org/10.1007/978-3-319-68511-3 2
[19] S. Bhunia, M. S. Hsiao, M. Banga, and S. Narasimhan, “Hardware
Trojan Attacks: Threat Analysis and Countermeasures,” Proceedings of
the IEEE, vol. 102, no. 8, pp. 1229–1247, Aug. 2014.

[20] C. E. Landwehr, A. R. Bull, J. P. McDermott, and W. S. Choi,
“A taxonomy of computer program security ﬂaws,” ACM Computing
Surveys, vol. 26, no. 3, pp. 211–254, Sep. 1994. [Online]. Available:
https://doi.org/10.1145/185403.185412

[21] S. Ghosh, A. Basak, and S. Bhunia, “How Secure Are Printed Circuit
Boards Against Trojan Attacks?” IEEE Design Test, vol. 32, no. 2, pp.
7–16, Apr. 2015.

[22] B. Inc., “BotFactory SV2 PCB Printer.” [Online]. Available: https:

//www.botfactory.co/page/botfactory-sv2-pcb-printer

[23] “RepRap Options - RepRap.” [Online]. Available: https://reprap.org/

wiki/RepRap Options

[24] S. Lahteine, R. Neufeld, C. Pepper, B. Kuhn, and E. v. d. Zalm, “Home

| Marlin Firmware.” [Online]. Available: https://marlinfw.org/

[25] “Release 2.0.5.3 · MarlinFirmware/Conﬁgurations.” [Online]. Available:

https://github.com/MarlinFirmware/Conﬁgurations/releases/tag/2.0.5.3
[26] G. H¨außge, “OctoPrint.org.” [Online]. Available: https://octoprint.org/
[27] T. Rigas,
Apr.
enabling-veriﬁed-boot-on-raspberry-pi-3/

3,”
https://blog.nviso.eu/2019/04/01/

“Enabling Veriﬁed
[Online]. Available:

on Raspberry

2019.

boot

Pi

[28] R. Wilkins and B. Richardson, “UEFI Secure Boot in Modern Computer
Security Solutions,” UEFI Forum, Tech. Rep., Sep. 2013.
[On-
line]. Available: https://www.ueﬁ.org/sites/default/ﬁles/resources/UEFI
Secure Boot in Modern Computer Security Solutions 2013.pdf
[29] D. Lau, “Secure Bootloader implementation,” Freescale Semiconductor,
Tech. Rep. AN4605, Oct. 2012. [Online]. Available: https://www.nxp.
com/docs/en/application-note/AN4605.pdf

[30] “STK500 Communication Protocol,” Atmel (Microchip), Tech. Rep.
[Online]. Available: http://ww1.

AN2591 / AVR068,
microchip.com/downloads/en/Appnotes/doc2591.pdf

Jun. 2006.

[31] “arduino/Arduino-stk500v2-bootloader,” Apr. 2021, original-date: 2011-
https://github.com/arduino/

[Online]. Available:

09-24T00:18:59Z.
Arduino-stk500v2-bootloader

[32] “ASTM A370-20, Standard Test Methods

for
Mechanical Testing of Steel Products,” ASTM International, West
Conshohocken, PA, Tech. Rep., 2020. [Online]. Available: www.astm.
org

and Deﬁnitions

[33] M. Sabt, M. Achemlal, and A. Bouabdallah, “Trusted Execution Envi-
ronment: What It is, and What It is Not,” in 2015 IEEE Trustcom/Big-
DataSE/ISPA, vol. 1, Aug. 2015, pp. 57–64.

we frame the issue around desktop AM devices, we stress that
the issues we highlight in this paper are not restricted to these
models. Indeed, the more complex an AM CPS is, the greater
the attack surface for embedded Trojans, and ‘commercial
grade’/‘industrial scale’ 3D printers have complex internal net-
works of microcontrollers and embedded systems. This work
serves as a reminder that these components can hide malicious
surprises, especially when they support complex and powerful
conﬁguration options that can be misused. It takes only one
component to be infected by a malaﬁde insider or malicious
third party with access to cause insidious and catastrophic
consequences. We believe that procedures for bootloader and
ﬁrmware veriﬁcation should be introduced across the AM
CPS space, alongside potential automatic monitoring (e.g. via
side channels) which could be developed to detect and ﬂag
anomalous behaviour.

ACKNOWLEDGMENTS

This work was supported in part by National Science
Foundation SaTC-EDU grant DGE-1931724. We also thank
Gary Mac for his help with the CAD modelling.

REFERENCES

[1] L. Nickels, “AM and aerospace: an ideal combination,” Metal Powder
Report, vol. 70, no. 6, pp. 300–303, Nov. 2015. [Online]. Available:
http://www.sciencedirect.com/science/article/pii/S0026065715003446
[2] J. K. Placone and A. J. Engler, “Recent Advances in Extrusion-Based 3D
Printing for Biomedical Applications,” Advanced Healthcare Materials,
vol. 7, no. 8, p. 1701161, 2018.

[3] N. Gupta, A. Tiwari, S. T. S. Bukkapatnam, and R. Karri, “Additive
Manufacturing Cyber-Physical System: Supply Chain Cybersecurity and
Risks,” IEEE Access, vol. 8, pp. 47 322–47 333, 2020.

[4] S. Moore, P. Armstrong, T. McDonald, and M. Yampolskiy, “Vulnera-
bility analysis of desktop 3D printer software,” in 2016 Resilience Week
(RWS), Aug. 2016, pp. 46–51.

[5] D. Wu, A. Ren, W. Zhang, F. Fan, P. Liu, X. Fu,

and
J. Terpenny, “Cybersecurity for digital manufacturing,” Journal of
Manufacturing Systems, vol. 48, pp. 3–12, Jul. 2018. [Online]. Available:
http://www.sciencedirect.com/science/article/pii/S0278612518300396
[6] P. Mahesh, A. Tiwari, C. Jin, P. R. Kumar, A. L. N. Reddy, S. T. S.
Bukkapatanam, N. Gupta, and R. Karri, “A Survey of Cybersecurity of
Digital Manufacturing,” Proceedings of the IEEE, pp. 1–22, 2020.
[7] S. B. Moore, W. B. Glisson, and M. Yampolskiy, “Implications of
Malicious 3D Printer Firmware,” Hawaii International Conference on
System Sciences 2017 (HICSS-50), Jan. 2017. [Online]. Available:
https://aisel.aisnet.org/hicss-50/st/digital forensics/5

[8] S. E. Zeltmann, N. Gupta, N. G. Tsoutsos, M. Maniatakos, J. Rajendran,
and R. Karri, “Manufacturing and Security Challenges in 3D Printing,”
JOM, vol. 68, no. 7, pp. 1872–1881, Jul. 2016. [Online]. Available:
https://doi.org/10.1007/s11837-016-1937-7

[9] S. Belikovetsky, M. Yampolskiy, J. Toh, J. Gatlin, and Y. Elovici,
“dr0wned – Cyber-Physical Attack with Additive Manufacturing,”
in 11th USENIX Workshop on Offensive Technologies
(WOOT),
2017. [Online]. Available: https://www.usenix.org/conference/woot17/
workshop-program/presentation/belikovetsky

[10] R. Jones, P. Haufe, E. Sells, P. Iravani, V. Olliver, C. Palmer, and
A. Bowyer, “RepRap – the replicating rapid prototyper,” Robotica,
vol. 29, no. 1, pp. 177–191, Jan. 2011.

[11] “ACAD/Medre.A,”

Available:
https://www.welivesecurity.com/wp-content/uploads/200x/white-papers/
ESET ACAD Medre A whitepaper.pdf

[Online].

2012.

Jun.

[12] A. Slaughter, M. Yampolskiy, M. Matthews, W. E. King, G. Guss,
and Y. Elovici, “How to Ensure Bad Quality in Metal Additive
Manufacturing:
In-Situ Infrared Thermography from the Security
Perspective,” in Proceedings of the 12th International Conference on
Availability, Reliability and Security, ser. ARES ’17. New York, NY,
USA: Association for Computing Machinery, Aug. 2017, pp. 1–10.
[Online]. Available: https://doi.org/10.1145/3098954.3107011

