9
1
0
2

b
e
F
9

]

Y
S
.
s
c
[

1
v
4
6
0
4
0
.
2
0
9
1
:
v
i
X
r
a

REAFFIRM: Model-Based Repair of Hybrid
Systems for Improving Resiliency(cid:63)

Luan Viet Nguyen, Gautam Mohan, James Weimer, Oleg Sokolsky, Insup Lee,
and Rajeev Alur

Department of Computer and Information Science, University of Pennsylvania, PA,
USA

Abstract. Model-based design oﬀers a promising approach for assisting
developers to build reliable and secure cyber-physical systems (CPSs) in
a systematic manner. In this methodology, a designer ﬁrst constructs
a model, with mathematically precise semantics, of the system under
design, and performs extensive analysis with respect to correctness re-
quirements before generating the implementation from the model. How-
ever, as new vulnerabilities are discovered, requirements evolve aimed
at ensuring resiliency. There is currently a shortage of an inexpensive,
automated mechanism that can eﬀectively repair the initial design, and
a model-based system developer regularly needs to redesign and reim-
plement the system from scratch.
In this paper, we propose a new methodology along with a MATLAB
toolkit called REAFFIRM to facilitate the model-based repair for im-
proving the resiliency of CPSs. REAFFIRM takes as inputs 1) an original
hybrid system modeled as a Simulink/Stateﬂow diagram, 2) a given re-
siliency pattern speciﬁed as a model transformation script, and 3) a safety
requirement expressed as a Signal Temporal Logic formula, and outputs
a repaired model which satisﬁes the requirement. The overall structure
of REAFFIRM contains two main modules: a model transformation and
a model synthesizer built on top of the falsiﬁcation tool Breach. We
also introduce a new model transformation language for hybrid systems,
which we call HATL to allow a designer to specify resiliency patterns.
To evaluate the proposed approach, we use REAFFIRM to automatically
synthesize repaired models for an adaptive cruise control (ACC) system
under a GPS sensor spooﬁng attack, for a single-machine inﬁnite-bus
(SMIB) system under a sliding-mode switching attack, and for a missile
guidance system under gyroscopes sensor attack.

1

Introduction

A cyber-physical system (CPS) consists of computing devices communicating
with one another and interacting with the physical world via sensors and ac-

(cid:63) This material is based upon work supported by the Defense Advanced Research
Projects Agency (DARPA) and Space and Naval Warfare Systems Center Paciﬁc
(SSC Paciﬁc) under Contract No. N6600118C4007, the National Science Founda-
tion (NSF) GRFP under Grant No. DGE-1845298, and sponsored in part by ONR
N000141712012.

 
 
 
 
 
 
2

Luan Nguyen et al.

Fig. 1. REAFFIRM overview.

tuators. Increasingly, such systems are everywhere, from smart buildings to au-
tonomous vehicles to mission-critical military systems. The rapidly expanding
ﬁeld of CPSs precipitated a corresponding growth in security concerns for these
systems. The increasing amount of software, communication channels, sensors
and actuators embedded in modern CPSs make them likely to be more vul-
nerable to both cyber-based and physics-based attacks [40,41,23,4,17]. As an
example, sensor spooﬁng attacks to CPSs become prominent, where a hacker
can arbitrarily manipulate the sensor measurements to compromise secure infor-
mation or to drive the system toward unsafe behaviors. Such attacks have suc-
cessfully disrupted the braking function of the anti-lock braking systems [37,4],
and compromised the insulin delivery service of a diabetes therapy system [27].
Alternatively, attackers can gain access to communication channels to either ma-
nipulate the switching behavior of a smart power grid [30] or disable the brake
system of a modern vehicle [25]. Generally, constructing a behavioral model at
design time that oﬀers resiliency for all kinds of attacks and failures is notoriously
diﬃcult. Traditionally a model of a CPS consists of block diagrams describing
the system architecture and a combination of state machines and diﬀerential
equations describing the system dynamics [5]. Suppose a designer has initially
constructed a model of a CPS that satisﬁes correctness requirements, but at a
later stage, this correctness guarantee is invalidated, possibly due to adversarial
attacks on sensors, or violation of environment assumptions. Current techniques
for secure-by-design systems engineering do not provide a formal way for a de-
signer to specify a resiliency pattern to automatically repair system models based
on evolving resiliency requirements under unanticipated attacks.

In this paper, we propose a new methodology and an associated toolkit, called
REAFFIRM, to assist a designer in repairing the original model so that it con-
tinues to satisfy the correctness requirements under the modiﬁed assumptions.
The proposed technique relies on designing a collection of potential edits (or
resiliency patterns) to the original model to generate the new model whose pa-

A. Overview  1. Reaffirm Overview Suppose the designer has initially constructed a model of a cyber-physical system that satisfies correctness requirements, but at a later stage, this correctness guarantee is invalidated, possibly due to the emergence of new requirements, or adversarial attacks on sensors, or violation of environment assumptions. The goal of the Reaffirm methodology is to assist the designer to repair the model to generate a resilient version.               Figure 1: Reaffirm overview   STL Requirement Repaired SLSF Model Original SLSF  Model Model Transformation Resiliency Pattern Parametrized  SLSF Model Model Synthesizer    Breach Title Suppressed Due to Excessive Length

3

rameters values can be determined by solving the parameter synthesis problem.
Figure 1 shows an overview of REAFFIRM, which contains two mains modules
1) a model transformation, and 2) a model synthesizer built on top of the falsi-
ﬁcation tool Breach [12]. REAFFIRM takes the following inputs 1) the original
system modeled as a Simulink/Stateﬂow (SLSF) diagram, 2) the resiliency pat-
tern speciﬁed by the designer and 3) the safety requirement expressed as a Signal
Temporal Logic (STL) [31] formula, and outputs the repaired SLSF model that
satisﬁes the safety requirement.

To allow a designer to specify resiliency patterns we have developed a new
model transformation language for hybrid systems, called HATL (Hybrid Au-
tomata Transformation Language). A HATL script is a sequence of statements
that describe the modiﬁcations over the structure of hybrid systems modeled as
hybrid automata [5]. Examples of edits to a model include creating new modes
of operations, duplicating modes, adding transitions, modifying switching condi-
tions, and substituting state variables in ﬂow equations. The proposed language
allows the designer to write a resiliency pattern in a generic manner, and pro-
grammatically modify the initial design without knowing the internal structures
of a system. The HATL interpreter is implemented in Python with an extensible
backend to allow interoperability with diﬀerent hybrid systems modeling frame-
works. The current implementation of HATL supports MATLAB and performs
transformations on SLSF models.

For evaluation, we apply REAFFIRM to automatically synthesize the re-
paired models for three case studies in the domains of automotive control, smart
power systems and aerospace applications. The ﬁrst case study is a simpliﬁed
model of an adaptive cruise control (ACC) system under a GPS sensor spooﬁng
attack, and the resiliency pattern to ﬁx the model is to ignore the GPS measure-
ment and only use the wheel encoders, which are additional (redundant) sensors
for estimating a vehicle’s velocity. REAFFIRM automatically synthesizes the
condition that triggers a switch to a copy of the model that ignores the GPS
measurement. The second case study is a single-machine inﬁnite-bus (SMIB)
model, which is an approximation of a smart power grid, under a sliding-mode
attack. In this case, the mitigation strategy is to increase the minimal dwell-time
to avoid rapid changes between diﬀerent operation modes. Thus, the resiliency
pattern adds a dwell-time variable in each mode of the model, and the minimal
dwell-time can be synthesized automatically by REAFFIRM. The third case
study is the missile guidance system (MG) provided by Mathworks, which is a
good representative of a practical MG system as it has more than 300 SLSF
blocks. The principle of a spooﬁng attack on the gyroscopes of the MG system
is similar to the GPS spooﬁng attack of the ACC system, and then we can apply
the same resiliency pattern used to ﬁx the ACC model for repairing the MG
model.

In summary, the main contributions of the paper are as follows.

1. The methodology to facilitate the model-based repair for improving the re-

siliency of CPSs against unanticipated attacks and failures,

4

Luan Nguyen et al.

2. the design and implementation of an extensible model transformation language

for specifying resiliency patterns used to repair CPS models,

3. the end-to-end design and implementation of the toolkit, which integrates the
model transformation and the model synthesis tools to automatically repair
CPS models,

4. the applicability of our approach on three proof-of-concept case studies where

the CPS models can be repaired to mitigate practical attacks.

The remainder of the paper is organized as follows. Section 2 presents an
overview of our proposed methodology through a simpliﬁed example of the ACC
system, and introduces the architecture of REAFFIRM. Section 3 describes our
model transformation language used to design a resiliency pattern for hybrid
systems. Section 4 presents the model synthesizer of REAFFIRM. Section 5
presents three case studies that illustrate the capability of REAFFIRM in au-
tomatically repairing the original models of a) the ACC system under a GPS
sensor spooﬁng attack, b) the SMIB system under a sliding-mode attack, and c)
the MG system under a gyroscopes sensor attack. Section 6 reviews the related
works to REAFFIRM, and Section 7 concludes the paper.

2 Overview of the Methodology

In this section, we will explain our methodology through a simpliﬁed example of
the adaptive cruise control (ACC) system. Assume that a designer has previously
modeled the ACC system as a combination of the vehicle dynamics and an ACC
module, and GPS measurements were considered trusted in the initial design. In
the following, we will describe the ACC system as originally designed, an attack
scenario, and an example of resiliency pattern to repair the ACC model1. Then,
we present how REAFFIRM can automatically perform a model transformation
and synthesis to construct a new ACC model with resiliency.

2.1 A Simpliﬁed Example of ACC System

For simplicity, we assume that the designer initially models the ACC system
(including vehicle dynamics) as a hybrid system shown in Figure 2. The original
ACC system operates in two modes: speed control and spacing control. In speed
control, the host car travels at a driver-set speed. In spacing control, the host
car aims to maintain a safe distance from the lead car. The vehicle has two
state variables: d is the distance to the lead car, and v is the speed of the host
vehicle. The ACC system has two sensors that measure its velocity v via noisy
wheel encoders, venc = v + nenc, and a noisy GPS sensor, vgps = v + ngps, where
nenc and ngps denote the encoder and GPS noises, respectively. Additionally,
the ACC system has a radar sensor that measures the distance to the lead

1 We note that the ACC model presented herein is not a representative of the com-
plexity of a true ACC system, but a simpliﬁed example in which the dynamics and
control equations are chosen for simplicity of presentation.

Title Suppressed Due to Excessive Length

5

vehicle, drad = d + nrad, where nrad captures a corresponding noise. The ACC
system decides which mode to use based on the real-time sensor measurements.
For example, if the lead car is too close, the controller triggers the transition
gsd to switch from speed control to spacing control. Similarly, if the lead car is
further away, the ACC system switches from spacing control to speed control
by executing the transition gds. The safety speciﬁcation of the system is that d
should always be greater than dsaf e, where dsaf e = v + 5. We will describe the
ACC model in more details in Section 5.

Fig. 2. An original ACC model.

Safety violation under GPS sensor attack. In this example, we assume
that after designing and verifying the initial ACC system, it is determined that
the GPS sensor can be spoofed [38,22]. GPS spooﬁng occurs when incorrect GPS
packets (possibly sent by a malicious attacker) are received by the GPS receiver.
In the ACC system, this allows an attacker to arbitrarily change the GPS velocity
measurement. Thus, a new scenario occurs when the original assumption of GPS
noise, e.g., |ngps| ≤ 0.05 is omitted, and the new assumption is |ngps| ≤ 50. As a
result, the safety speciﬁcation could be violated under the GPS sensor attacks,
and a designer needs to repair the original model using a known mitigation
strategy.

Fig. 3. A repaired ACC model without a reference to GPS sensor under spooﬁng
attacks.

Example of resiliency pattern: ignoring GPS measurement. Since the
ACC system has redundancy in the sensory information of its estimated velocity,
to provide resilience against the GPS attacks, a mitigation strategy is to ignore
the GPS value, and use only the wheel encoders to estimate velocity. Thus, a
potential ﬁx is ﬁrst to create a copy of the original model where the controller

1Spacing Control(    ,    )Spacing Control(    ,    )Updated Spacing Control ′ (    )Updated Spacing Control ′ (    ) (    ,    )Speed Control  (    ,    ,    )Speed Control  (    ,    ,    )Spacing Control  (    ,    ,    )Spacing Control  (    ,    ,    )      SafeSpeedControl   (    ,    )SafeSpeedControl   (    ,    )SafeSpacing Control   (    ,    )SafeSpacing Control   (    ,    )       (    ,    ) (    ,    )Speed Control  (    ,    ,    )Speed Control  (    ,    ,    )Spacing Control  (    ,    ,    )Spacing Control  (    ,    ,    )      1Spacing Control(    ,    )Spacing Control(    ,    )Updated Spacing Control ′ (    )Updated Spacing Control ′ (    ) (    ,    )Speed Control  (    ,    ,    )Speed Control  (    ,    ,    )Spacing Control  (    ,    ,    )Spacing Control  (    ,    ,    )      SafeSpeedControl   (    ,    )SafeSpeedControl   (    ,    )SafeSpacing Control   (    ,    )SafeSpacing Control   (    ,    )       (    ,    ) (    ,    )6

Luan Nguyen et al.

simply ignores the GPS reading as it can no longer be trusted. Then, adding new
transitions from the modes of the original model to the corresponding instances
of the copy that uses only the wheel encoder to measure velocity. We note that
this transformation is generic, that is, it can be applied in a uniform manner to
any given model simply by creating a duplicate version of each original mode
and transition, copying the dynamics in each mode, but without a reference to
the variable vgps.

Figure 3 illustrates the repaired model in which the transition from the orig-
inal speeding and spacing control modes to their copies is an expression over
vgps and venc. Observe that while it would be possible to use only the wheel
encoders all the time, a better velocity estimate can be obtained by using an
average velocity measurement (from both the GPS and wheel encoders) when
the GPS sensor is performing within nominal speciﬁcations. The main analy-
sis question is when should the model switch from the original modes to the
copied modes during the spooﬁng attack. From a practical standpoint, such a
transition should occur when the GPS measurement signiﬁcantly deviates from
the wheel encoder measurement, and a transition condition can be speciﬁed
as g(vgps, venc) = |vgps − venc| ≥ θ, where θ is an unknown parameter. Since
venc = v + nenc and vgps = v + ngps, we can rewrite the transition condition as
g(vgps, venc) = |ngps −nenc| ≥ θ. Then, one needs to synthesize the suitable value
of the parameter θ that speciﬁes the threshold for switching from the original
copy to the new copy so that the safety requirement is satisﬁed.

2.2 REAFFIRM Toolkit

Our REAFFIRM prototype for the model-based repair is built in MATLAB
and consists of two main modules, corresponding to model transformation and
parameter synthesis. To synthesize the model with resiliency to unanticipated
attacks, users need to provide the following inputs to REAFFIRM:

• the initial design of a hybrid system modeled in MathWorks SLSF format,
• the resiliency pattern speciﬁed as a model transformation script that trans-
forms the initial model to the new model with resiliency to unanticipated
attacks, and

• the correctness (safety) requirement of the system speciﬁed as an STL formula.

In the case of the ACC example, the inputs of REAFFIRM are the initial
SLSF model shown in Figure 2, the resiliency pattern that creates the copied
version of the original model without a reference to the variable vgps, and the
safety requirement encoded as an STL formula,

ϕACC = (cid:3)[0,∞)d[t] < 5 + v[t].

(1)

The model transformation tool of REAFFIRM takes the initial SLSF model and
the resiliency pattern (e.g., the transformation script shown in Figure 4), and
then generates the new SLSF model that contains a parameter θ that appears

Title Suppressed Due to Excessive Length

7

in the switching condition based on the diﬀerence between the GPS measure-
ment and the wheel encoder measurement. Then, the model synthesizer tool of
REAFFIRM takes the parametrized ACC model in SLSF and the STL formula
ϕACC as inputs, and then performs a parameter synthesis to ﬁnd the desired
value of θ over a certain range, to ensure that ϕACC is satisﬁed. Internally,
the model synthesizer of REAFFIRM utilizes an open-source model falsiﬁcation
tool—Breach [12] to synthesize the desired parameters values. If the synthesizer
can ﬁnd the best value of θ over the given range, then REAFFIRM outputs a
competed SLSF model which satisﬁes ϕACC under the GPS attacks. Otherwise,
the tool will suggest the designer to either search over diﬀerent parameter ranges
or try diﬀerent resiliency patterns to repair the ACC model.

3 Model Transformation

3.1 Representation of Hybrid System

Hybrid automata [5] are a modeling formalism popularly used to model hybrid
systems which include both continuous dynamics and discrete state transitions.
A hybrid automaton is essentially a ﬁnite state machine extended with a set of
real-valued variables evolving continuously over time [5]. The main structure of
a hybrid automaton H includes the following components.

• X : the ﬁnite set of n continuous, real-valued variables.
• P: the ﬁnite set of p real-valued parameters.
• Mode: the ﬁnite set of discrete modes. For each mode m ∈ Mode, m.inv is
an expression over X ∪ P that denotes the invariant of mode m, and m.ﬂow
describes the continuous dynamics governed by a set of ordinary diﬀerential
equations.

• Trans: the ﬁnite set of transitions between modes. Each transition is a tuple
τ ∆= (cid:104)source, destination, guard , reset(cid:105), where source is a source mode and
destination is a target mode that may be taken when a guard condition guard ,
which is an expression over X ∪ P, is satisﬁed, and reset is an assignment of
variables in X after the transition.

We use the dot (.) notation to refer to diﬀerent components of tuples, e.g.,
H.Trans refers to the transitions of automaton H and τ.guard refers to the guard
of a transition τ . Since our goal is to repair a hybrid automaton syntactically, we
will not discuss its semantics in this paper, but refer a reader to [5] for details. We
note that the model transformation language proposed in this paper transforms
a hybrid automaton based on modifying the syntactic components of the hybrid
automaton in a generic manner. The transformation tool of REAFFIRM can
take a HATL transformation script and translate it into an equivalent script
that performs a model transformation for diﬀerent modeling framework of hybrid
automata including a continuous-time Stateﬂow chart.

Continuous-time Stateﬂow chart. In this paper, we represent hybrid au-
tomata using continuous-time Stateﬂow chart, which is a standard commercial

8

Luan Nguyen et al.

r e t r i e v e d from command l i n e a r g u m e n t s

i s

# o r i g i n a l model
model_copy = model . copyModel () # make a model c o p y
# s t a r t a t r a n s f o r m a t i o n
model . addParam ( " theta " ) # add new p a r a m e t e r
formode m = model . Mode {

t h e t a

m_copy = model . addMode ( m )
m . replace ( m_copy . flow , " ngps " ," nenc " )
model . addTransition (m , m_copy , " abs ( ngps - nenc ) > theta " )

}
fortran t = model_copy . Trans {

s o u r c e and d e s t i n a t i o n modes o f

# g e t
src = t . source
dst = t . destination
# r e t r i e v e
src_copy = model . getCopyMode ( src )
dst_copy = model . getCopyMode ( dst )
model . addTransition ( src_copy , dst_copy , t . guard )

c o p i e s o f

s o u r c e and d e s t i n a t i o n modes

t r a n s i t i o n t

}
# end o f

t h e t r a n s f o r m a t i o n

Fig. 4. An example of a resiliency pattern written as a HATL script for the ACC
system.

modeling language for hybrid systems integrated within Simulink. A continuous-
time Stateﬂow chart supplies methods for engineers to quickly model as well as
eﬃciently reﬁne, test, and generate code for hybrid automata. The syntactic
description of a continuous-time Stateﬂow chart is basically a hybrid automa-
ton, with a small few diﬀerences. In particular, a mode is a state associated
with diﬀerent types of actions including a) entry action executed when entering
the state, b) exit executed when exiting the state, and c) during (or du) action
demonstrates the continuous-time evolution of the variables (i.e., ﬂow dynamics)
when no transition is enabled. A variable can be speciﬁed as parameter, input,
output, and local variable. Also, an SLSF model which includes a continuous-
time Stateﬂow chart is deterministic since its transition is urgent and executed
with priorities [7].

3.2 Hybrid Automata Transformation Language

In our approach, the partial model of the system, which satisﬁes functional but
not necessarily resiliency requirements is originally modeled in the form of hybrid
automata. The model transformation that is at the core of the REAFFIRM tool
will then attempt to modify the components of the automata such as modes,
ﬂows, or switching logic, by applying user-deﬁned resiliency patterns.

In order to specify resiliency patterns for hybrid automata, we introduce a
new language for model transformation called HATL (Hybrid Automata Trans-
formation Language). The goal of HATL is to allow a designer to repair an
original model in a programmatic fashion. HATL scripts abstract model imple-
mentation details so engineers do not need to learn the intricacies of an individual
framework. A key use of HATL is to write generic scripts that are applicable to
many models, promoting resiliency scripts which are reusable. A script written

Title Suppressed Due to Excessive Length

9

in HATL is a sequence of statements that specify the changes over the structure
of given hybrid automata. HATL’s syntax and semantics are designed to make
it intuitive to anyone who is familiar with imperative languages. HATL includes
loop statements that iterate over sets of objects, such as modes or transitions of
a model. It uses dot references to index into structures to obtain data ﬁelds or to
call object-speciﬁc methods. Assignments are mutable, and scoped within state-
ment blocks. Functions and methods can have variable numbers of arguments
which are eagerly evaluated.

The model transformation tool built in REAFFIRM takes a resiliency pattern
in the form of a HATL script, and then translates each of the statements of the
script into equivalent transformation operations on continuous-time Stateﬂow
models. Figure 4 shows an example of a HATL script that speciﬁes a trans-
formation from the original ACC model shown in Figure 2 to the parametrized
model shown in Figure 3. In this script, we ﬁrst create a copy of the original
model. Next, we iterate over each mode of the model by calling the formode
loop, make a copy with replacing the variable ngps by nenc, and then add a new
transition from the original mode to the copied mode with a new guard condi-
tion. This guard condition is a constraint speciﬁed over the diﬀerence between
ngps by nenc (i.e., the diﬀerence between vgps and venc) and a new parameter θ,
which is added into the model using a function call addParam. Finally, we need
to copy all transitions between original modes (stored in a copied version of the
original model) and assign them to the corresponding duplicated modes.

3.3 Implementation

Our current implementation dynamically interprets HATL scripts in Python and
translates them into SLSF model transformations via the MATLAB Engine. Our
interpreter checks argument values at runtime to ensure only valid transformed
models are produced. If a malformed program statement is detected, HATL will
throw a verbose error message and roll back any changes it has applied already
before exiting. Additionally, these error messages are reported in terms of generic
HATL models, so an engineer writing a resiliency pattern does not need to worry
about the underlying implementation.

Currently, HATL provides enough programming abstraction to express con-
cise model transformations that function as valid resiliency patterns, and more
examples of these scripts will be introduced in Section 5. There is room for future
improvement, such as adding language constructs like type checking to verify the
type correctness of the model before and after repair.

4 Model Synthesis

In this section, we present the model synthesizer incorporated in REAFFIRM
which takes a parameterized model produced by the model transformation, and
a correctness requirement as inputs, and then generates a completed model with
parameter values instantiated to satisfy the correctness requirements. Since the

10

Luan Nguyen et al.

structure of the completed model is already determined after the model trans-
formation, the model synthesis problem then reduces to the parameter synthesis
problem. Let Ps be the set of parameters of the transformed model ˜H, given a
safety speciﬁcation ϕ and sets of parameter values ¯Ps , ﬁnd the best instance
values of Ps over ¯Ps so that ˜H |= ϕ. For example, the transformation of the ACC
model shown in Figure 3 introduces a new parameter θ whose value needed to
be determined so that the completed model will satisfy the safety requirement
with respect to the same initial condition of the state variables and parameters
domains of the original model.

4.1 Overview of Breach

We incorporated Breach into the model synthesizer of REAFFIRM as an analysis
mechanism to perform the falsiﬁcation and parameter synthesis for hybrid sys-
tems. Given a hybrid system modeled as an SLSF diagram, an STL speciﬁcation
described the safety property, and speciﬁc parameter domains, Breach [12] can
perform an optimized search over the parameter ranges to ﬁnd parameter val-
ues that cause the system violating the given STL speciﬁcation. The parameter
mining procedure is guided by the counterexample obtained from the falsiﬁca-
tion, and it terminates if there is no counterexample found by the falsiﬁer or the
maximum number of iterations speciﬁed by a user is reached. On the other hand,
Breach can compute the sensitivity of execution traces to the initial conditions,
which can be used to obtain completeness results by performing systematic sim-
ulations. Moreover, Breach provides an input generator for engineers to specify
diﬀerent testing input patterns such as step, pulse width, sinusoid, and ramp
signals. This input generator is designed to be extensible, so users can write a
speciﬁc input pattern to test their model against particular attack scenarios.

We note that although Breach cannot completely prove the system correct-
ness, it can eﬃciently ﬁnd bugs existing in the initial design of CPS that are
too complex to be formally veriﬁed [21]. These bugs are essential for an engi-
neer to specify resiliency patterns to repair the model. Moreover, the general
problem of verifying a CPS modeled as a hybrid system is known to be unde-
cidable [18]. Instead, the falsiﬁcation algorithms embedded within Breach are
scalable and work properly for black-box hybrid systems with diﬀerent classes of
dynamics. Thus, in practice, engineers prefer to use counterexamples obtained
by a falsiﬁcation tool to reﬁne their design. Our prototype REAFFIRM utilizes
the advantages of SLSF modeling framework and the falsiﬁcation tool Breach to
design a resiliency pattern and perform the model synthesis for a repaired CPS
model with resiliency.

4.2 Model Synthesis using Breach

Next, we describe how REAFFIRM uses Breach to synthesize parameters values
for the parametrized model returned from the model transformation tool. The
parameter synthesis procedure consists of following steps.

Title Suppressed Due to Excessive Length

11

1. We ﬁrst specify the initial conditions of state variables and parameters, the
set of parameters Ps that need to be mined, the sets of parameter values ¯Ps,
and the maximum time (or number of iterations) for the optimization solver
of Breach.

2. Next, we call the falsiﬁcation loop within Breach to search for a counterexam-
ple. For each iteration, if the counterexample is exposed, the unsafe values of
Ps will be returned. Based on these values, the tool will automatically update
the sets of parameter values ¯Ps to the new sets of parameter values ¯P (cid:48)
s ⊂ ¯Ps,
and then continue the falsiﬁcation loop.

3. The process repeats until the property is satisﬁed that means the falsiﬁer
cannot ﬁnd a counterexample and the user-speciﬁed limit on the number of
optimized iterations (or time) for the solver expires.

4. Finally, the tool returns the best (and safe) values of Ps, updates the parametrized
model with these values, and then exports the completed model. If the syn-
thesizer fails to ﬁnd the values of Ps over the given sets of parameter values
¯Ps so that the safety requirement is satisﬁed, it will recommend a designer to
either search over diﬀerent parameter ranges or try another resiliency pattern.

Monotonic Parameters. The search over the parameter space of the synthesis
procedure can be signiﬁcantly reduced if the satisfaction value of a given prop-
erty is monotonic w.r.t to a parameter value. Intuitively, the satisfaction of the
formula monotonically increases (respectively decreases) w.r.t to a parameter p
that means the system is more likely to satisfy the formula if the value of p is
increased (respectively decreased). In the case of monotonicity, the parameter
space can be eﬃciently truncated to ﬁnd the tightest parameter values such that
a given formula is satisﬁed. In Breach, the check of monotonicity of a given
formula w.r.t speciﬁc parameter is encoded as an STM query and then is de-
termined using an STM solver. However, the result may be undecidable due to
the undecidability of STL [20]. In this paper, the synthesis procedure is based
on the assumption of satisfaction monotonicity. If the check of monotonicity is
undecidable over a certain parameter range, a user can manually enforce the
solver with decided monotonicity (increasing or decreasing) or perform a search
over a diﬀerent parameter range.

5 Model Repair for Resiliency

In this section, we demonstrate the capability of REAFFIRM to repair CPSs
models under unanticipated attacks. We ﬁrst revisit the ACC example and eval-
uate three resiliency patterns that can be applied to repair the ACC model under
the GPS sensor spooﬁng attack. Second, we investigate a sliding-mode switching
attack that causes instability for a smart grid system and how REAFFIRM can
use a dwell-time pattern to repair the model under this attack automatically.
Finally, we apply the three resiliency patterns used to ﬁx the ACC model to
repair the MG system under gyroscopes sensor attacks.

12

Luan Nguyen et al.

Model BD Attack

Resiliency Pattern

Unknown Condition PR

SV

TT ST

ACC 11 GPS spooﬁng

measurement, use

Pattern 2

a safe copy

Ignore GPS,

Pattern 1 When to switch to

wheel encoders value

Pattern 3

Ratio of GPS/encoders

measurements

θ ∈ [0, 50]

7.08515

7.08515

2

2

88

88

θ ∈ [0.1, 0.9] 0.1543

1.75 55.78

SMIB 15

Sliding-mode

Add a dwell-time to

Pattern

switching

avoid rapid switching

dwell-time

Minimal dwell-time

θ ∈ [0, 0.3]

0.12

MG

310

Gyroscopes

spooﬁng

Ignore untrusted,

Pattern 1 When to switch to

measurements, use

Pattern 2

a safe copy

θ ∈ [0, 0.5]

0.06714

0.06714

the trusted ones

Pattern 3

Ratio of gyroscopes

measurements

θ ∈ [0.01, 0.1] 0.01127

1.75 55

2

2

2

45

78

92

Table 1. REAFFIRM performance results for the ACC, SMIB, and MG case studies.
BD is the number of blocks in SLSF models. PR is the parameter range. SV is the
synthesized value. TT is the transformation time (s). ST is the synthesis time (s).

REAFFIRM was tested using MATLAB 2018a and MATLAB 2018b exe-
cuted on an x86-64 laptop with 2.8 GHz Intel(R) Core(TM) i7-7700HQ proces-
sor and 32 GB RAM. All performance metrics reported were recorded on this
system using MATLAB 2018a. In Breach, we choose the CMAES solver, and the
maximum optimization time is 30 seconds for each iteration of the falsiﬁcation
loop. REAFFIRM and all case studies investigated in this paper are available
to download at https://github.com/LuanVietNguyen/reaffirm. The overall
performance2 of REAFFIRM in repairing the initial models of three case studies
to mitigate their corresponding attacks is summarized in Table 1. Next, we will
describe three case studies in more details.

5.1 Adaptive Cruise Control System

Original SLSF model. We previously introduced the simpliﬁed example of the
ACC system in Section 2 to illustrate our approach. In this section, we present
the ACC system in more details. The ACC system can be modeled as the SLSF
model shown in Figure 5. The model has four state variables where d and ed
are the actual distance and estimated distance between the host car and the
lead vehicle, v and ev represent the actual velocity and estimated velocity of
the host car, respectively. In this model, we assume that the lead vehicle travels
with a constant speed vl. The transition from speed control to spacing control
occurs when the estimate of the distance is less than twice the estimated safe
distance, i.e., ed < 10 + 2ev. A similar condition is provided for switching from
spacing control to speed control, i.e., ed ≥ 10 + 2ev. In this case study, we
assume that the designer has veriﬁed the initial SLSF model of the ACC system
against the safety requirement ϕACC under the scenario when d(0) ∈ [90, 100],

2 The transformation time reported in the table is the actual time required for the
model transformation by neglecting the overhead of loading the MATLAB Engine
in Python.

Title Suppressed Due to Excessive Length

13

Fig. 5. The original SLSF model of the ACC system.

v(0) ∈ [25, 30], |d(0) − ed(0)| ≤ 10, |v(0) − ev(0)| ≤ 5 , vl = 20, |nrad| ≤ 0.05,
|nenc| ≤ 0.05 and |ngps| ≤ 0.05.

GPS sensor attack. To perform a spooﬁng attack on the GPS sensor of the
ACC model, we continuously inject false data to manipulate its measurement
value. In this case, we omit the original assumption |ngps| ≤ 0.05, and employ
the new assumption as |ngps| ≤ 50. Using the input generator in Breach, we
can specify the GPS spooﬁng attack as a standard input test signal such as a
constant, ramp, step, sinusoid or random signal. The following evaluations of
three diﬀerent resiliency patterns used to repair the ACC model are based on
the same assumption that the GPS spooﬁng occurs at every time point, speciﬁed
as a random constant signal over the range of [-50, 50] during 50 seconds.

Model Repair for the ACC system. Under the GPS sensor spooﬁng attack,
the original SLSF model does not satisfy its safety requirement and a designer
needs to apply a certain resiliency pattern to repair the model. The ﬁrst resiliency
pattern for repairing the ACC system has been introduced in Section 2, which
makes the copy of the original model where the controller ignores the GPS
reading as it can no longer be trusted. However, we need to determine the best
switching condition from the original model to the copy. Figure 11 in Appendix A
shows the completed model, where the switching condition is determined by
synthesizing the value of θ over the range of [0, 50] using Breach.

The second resiliency pattern for the ACC model is the extended version
of the ﬁrst one where it includes a switching-back condition from the copy to
the original model when the GPS sensor attack is detected and mitigated. An
example of such a switching-back condition is when the diﬀerence between the
nenc and ngps are getting smaller, i.e., |ngps − nenc| < θ − (cid:15), where (cid:15) is a positive
user-deﬁned tolerance. For this pattern, the model transformation script can be
written similar to the one shown in Figure 4 with adding the addTransition func-
tion from the copy mode to the original mode with the guard condition labeled
as |ngps − nenc| < θ − (cid:15) in the formode loop. The performance of REAFFIRM
for the second pattern is similar to the ﬁrst pattern with the same synthesized
value of θ = 7.08515 and (cid:15) = 0.

Spacing_Controldu:d_dot	=	-v+vl;v_dot	=	2*vl	-	v	-	ev	-	0.25*(10	+	2*ev	-	ed);ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-	ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(ngps	+	nenc)-	0.25*(10	+	2*ev	-	ed);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;Speed_Controldu:d_dot	=	-v+vl;v_dot	=		2*vl	-	v	-	ev;ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-	ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(ngps	+	nenc);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;[ed	>=	10	+	2*ev][ed	<	10	+	2*ev]{d	=	d0;	v	=	v0;	ed	=	ed0;	ev	=	ev0;}14

Luan Nguyen et al.

# s t a r t a t r a n s f o r m a t i o n
model . addParam ( " theta " ) # add a new p a r a m e t e r
formode m = model . Mode {

t h e t a

m . replace ( m . flow , " ngps " , " 2* theta * ngps " )
m . replace ( m . flow , " nenc " , " 2*(1 - theta )* nenc " )

}
# end o f

t h e t r a n s f o r m a t i o n

Fig. 6. The third resiliency pattern for the ACC system based on the linear combination
of nenc and ngps.

Alternatively, the third resiliency pattern, where we do not need to modify the
structure of the original model, is to model the redundancy in the sensory infor-
mation as a linear combination of diﬀerent sensor measurements. For example,
instead of taking the average of ngps and nenc, we can model their relationship as
θngps +(1−θ)nenc, and then synthesize the value of θ so that the safety property
is satisﬁed. The transformation script of this resiliency pattern is given in Fig-
ure 6. For this pattern, we assume that a designer still wants to use all sensor
measurements even some of them are under spooﬁng attacks and would like to
search for the value of θ over the range of [0.2, 0.8] (instead of [0, 1]). Given the
same attack model for the other patterns, the synthesizer in REAFFIRM fails
to ﬁnd the value of θ within the given range to ensure that the safety property
is satisﬁed. However, if we enlarge the range of θ to [0.1, 0.9], the synthesizer
successfully ﬁnds the safe value θ = 0.1543.

5.2 Single-Machine Inﬁnite-Bus System

Next, we study a class of cyber-physical switching attacks that can destabilize
a smart grid system model, and then apply REAFFIRM to repair the model to
provide resilience. A smart power grid system such as the Western Electricity Co-
ordinating Council (WECC) 3-machine, 9-bus system [36], can be represented as
a single-machine inﬁnite-bus (SMIB) system described in [14]. The SMIB system
is considered as a switched system in which the physical dynamics are changed
between two operation modes based on the position of the circuit breaker. The
system has two states, δ1 and ω1, which are the deviation of the rotor angle and
speed of the local generator G1 respectively. The stability (safety) property of
the system can be speciﬁed as the following STL formula,

ϕSM IB = (cid:3)[0,T ](0 ≤ δ1[t] ≤ 3.5) ∧ (−2 ≤ ω1[t] ≤ 3),

(2)

where T is a simulation duration.

Original SLSF Model. In this paper, we model the SMIB system as the SLSF
model displayed in Figure 7. The model contains two operation modes whose
nonlinear dynamics characterize the transient stability of the local generator G1
presented in [14]. The transitions between two operation modes depend on the
status of the circuit breaker which is connected or disconnected to the load. In

Title Suppressed Due to Excessive Length

15

the model, δ1 and ω1 are represented by delta and omega, respectively; and
the initial conditions are delta0 ∈ [0, 1.1198] and omega0 ∈ [0, 1]. The discrete
variable load captures the open and closed status of the circuit breaker.

Fig. 7. The original SLSF model of the SMIB system.

Sliding-mode attack. The SMIB system has an interesting property known as
a sliding mode behavior. This behavior occurs when the state of the system is
attracted and subsequently stays within the sliding surface deﬁned by a state-
dependent switching signal s(x) ∈ R [11,29]. When the system is conﬁned on a
sliding mode surface, its dynamics exhibit high-frequency oscillations behaviors,
so-called a chattering phenomenon, which is well-known in the power system
design [35]. At this moment, if an attacker forces rapid switching between two
operation modes, the system will be steered out of its desirable equilibrium
position. As a result, the power system becomes unstable even each individual
subsystem is stand-alone stable [29]. The sliding-mode attack model of the SMIB
system in SLSF format and the unstable behavior of the system under the attack
are described in more details in Appendix A.

Model Repair for the SMIB system. A potential strategy to mitigate a
sliding-mode attack is to increase the minimum switching time of the circuit
breakers. Indeed, the designer can repair the original model by including a mini-
mum dwell time in each mode of the system to prevent rapid switching. Figure 8
shows a resiliency pattern written as a HATL script that introduces the clock
variable as a timer, and the switching time relies on the value of θ.

The model transformation of REAFFIRM takes the dwell-time pattern shown
in Figure 8, and then convert the model to a new version that integrates the pat-
tern with the unknown parameter θ. Then, the model synthesis of REAFFIRM
calls Breach to search for the best (i.e., minimum) value of θ over and the range
of [0, 0.3] that ensures the ﬁnal model satisﬁes ϕSM IB (with T = 10 seconds)
under the sliding-mode attack. The ﬁnal model, which is stable, is displayed
in Figure 9, where the synthesized value of θ equals to 0.12.

5.3 Missile Guidance System

Original SLSF Model. We consider the example of the missile guidance sys-
tem (MG) provided by Mathworks, which is a good representative of a practical

Plant_2du:delta_dot	=	omega;omega_dot	=	-10*sin(delta)	-	omega;delta_out	=	delta;omega_out	=	omega;Plant_1du:delta_dot	=	omega;omega_dot	=	9	-10*sin(delta)	-	omega;delta_out	=	delta;omega_out	=	omega;{	omega	=	omega0;	delta	=	delta0;	}[load	==	0][load	==	1]16

Luan Nguyen et al.

# s t a r t a t r a n s f o r m a t i o n
model . addParam ( " theta " ) # add a new p a r a m e t e r
model . addLocalVar ( " clock " ) # add a c l o c k v a r i a b l e
formode m = model . Mode {

t h e t a

m . addFlow ( " clock_dot = 1 " )

}
fortran t = model . Trans {
# a t r a n s i t i o n o n l y
t . addGuardLabel ( " && " ," clock > theta " )
# r e s e t a c l o c k a f t e r e a c h t r a n s i t i o n
t . addResetLabel ( " clock = 0 " )

t r i g g e r s

a f t e r

t h e t a s e c o n d s

}
# end o f

t h e t r a n s f o r m a t i o n

Fig. 8. A dwell-time resiliency pattern for the SMIB system.

Fig. 9. The repaired SMIB model with a synthesized dwell-time.

MG system. The original SLSF model has more than 300 blocks. The details
of the model can be found at https://www.mathworks.com/help/simulink/
examples/designing-a-guidance-system-in-MATLAB-and-simulink.html. In
our study, we make a slight modiﬁcation in the Sensors of the Airframe & Au-
topilot subcomponent of the original MG model. In the modiﬁed version, we
model the missile body rate measurements as an array of two diﬀerent gyro-
scopes, and the body rate estimation is obtained by using the average of the
measurements obtained from the two gyroscopes. Such modiﬁcation is reason-
able as a practical MG system usually uses an array of gyroscopes to estimate
the body rate of a missile. The correctness requirement of the model is that the
missile will eventually approach the target where their distance is less than 10.
This requirement can be formulated as an STL formula

ϕM G = ♦[0,T ]range[t] < 10.

(3)

In the original setting, the MG model satisﬁes the STL requirement and the
noisy levels of two gyroscopes are assumed as |ngyro1| ≤ 0.05 and |ngyro2| ≤ 0.05,
respectively.

Gyroscopes Sensor Attack. The principle of a spooﬁng attack on the gy-
roscopes of the MG system is similar to the GPS spooﬁng attack of the ACC
system. In this case, we omit the original assumption |ngyro2| ≤ 0.05, and em-

Plant_2du:delta_dot	=	omega;omega_dot	=	-10*sin(delta)	-	omega;delta_out	=	delta;omega_out	=	omega;clock_dot	=	1;Plant_1du:delta_dot	=	omega;omega_dot	=	9	-10*sin(delta)	-	omega;delta_out	=	delta;omega_out	=	omega;clock_dot	=	1;[load	==	1	&&	clock	>	0.12]	{clock	=	0;}[load	==	0	&&	clock	>	0.12]	{clock	=	0;}{omega	=	omega0;	delta	=	delta0;}Title Suppressed Due to Excessive Length

17

(a) Original noise estimator

(b) Modiﬁed estimator using pattern3

(c) Modiﬁed estimator using
pattern1

(d) Modiﬁed estimator using
pattern2

Fig. 10. The original and modiﬁed noise estimators using three resiliency patterns.

ploy the new assumption as |ngyro2| ≤ 1. As a result, the MG model no longer
satisﬁes the STL requirement under this assumption.

Model Repair for the MG System under Gyroscopes Sensor Attack.
To repair the MG model under the gyroscope spooﬁng attack, we can reuse the
three diﬀerent patterns used to ﬁx the ACC model under GPS spooﬁng attack.
Figure 10 shows the original gyroscope noise estimator which is vulnerable to the
spooﬁng attack and three diﬀerent repaired versions generated using the three
resiliency patterns, respectively. For each resiliency pattern, the synthesized val-
ues of θ and the performance of our Reaﬃrm toolkit is reported in Table 1.

6 Related Work

Model-based design of resilient CPSs. Examples of model-based approaches
to ensure resiliency include the approach proposed in [15] that can be used to
design a resilient CPS through co-simulation of discrete-event models, a model-
ing and simulation integration platform for secure and resilient CPS based on
attacker-defender games proposed in [26] with the corresponding testbed intro-
duced in [33], the resilience proﬁling of CPSs presented in [19], and the recent
works of the design, implementation, and monitor of attack-resilient CPSs in-
troduced in [42,34]. Although these approaches can leverage the modeling and
testing for a resilient CPS, they do not oﬀer a model repair mechanism or a
generic approach to design a resiliency pattern when vulnerabilities are discov-
ered. Our proposed method is complementary to these eﬀorts as we provide a
generic, programmable way for a designer to specify a potential edit that can
eﬀectively repair the model for improving resiliency.

Formal analysis of hybrid systems. Our approach utilizes Breach to synthe-
size an SLSF model due to its advantages in performing falsiﬁcation, systematic

Noise_estimatoren:	gynoise	=	0.5*(ngyro1	+	ngyro2);Noise_estimatoren:	gynoise	=	0.5*(2*(1-theta)*ngyro1	+	2*theta*ngyro2);Noise_estimator_copyen:	gynoise	=	0.5*(ngyro1	+	ngyro1);Noise_estimatoren:	gynoise	=	0.5*(ngyro1	+	ngyro2);[abs(ngyro1	-	ngyro2)	>	theta]Noise_estimator_copyen:	gynoise	=	0.5*(ngyro1	+	ngyro1);Noise_estimatoren:	gynoise	=	0.5*(ngyro1	+	ngyro2);[abs(ngyro1	-	ngyro2)	<	theta][abs(ngyro1	-	ngyro2)	>	theta]18

Luan Nguyen et al.

testing and parameter synthesis for hybrid systems. However, Breach cannot
give a formal proof of the system correctness. Depending on diﬀerent types of
hybrid systems, other automatic veriﬁcation tools can be considered to perform
a reachability analysis or formally prove whether a system satisﬁes a given safety
property. For examples, d/dt [6] and SpaceEx [16] are well-known veriﬁcation
tool for linear/aﬃne hybrid systems; Flow*[10] and dReach[24] can be used to
compute a reachable set of nonlinear hybrid automata; and C2E2 is a veriﬁcation
tool for Stateﬂow models [13]. We choose Breach as it is more scalable.

Model transformation languages of hybrid systems. In the context of the
model transformation, GREAT is a metamodel-based graph transformation lan-
guage that can be used to perform diﬀerent transformations on domain-speciﬁc
models [2,1]. GREAT has been used to translate SLSF models to Hybrid Systems
Interchange Format (HSIF) [3]. Such a translation scheme is accomplished by
executing a sequence of translation rules described using UML Class Diagram in
a speciﬁc order. Other approaches that also perform a translation from Simulink
diagrams to hybrid systems formalisms such as Timed Interval Calculus [9], Hy-
brid Communicating Sequential Processes [28], Lustre [39], and SpaceEx [32].
HYST [8] is a conversion tool for hybrid automata which allows the same model
to be analyzed simultaneously in several hybrid systems analysis tools. However,
the problem of designing a scripting language to facilitate transforming models
of hybrid systems has not been addressed before.

7 Conclusion

In this paper, we have presented a new methodology and the toolkit REAFFIRM
that eﬀectively assist a designer to repair CPS models under unanticipated at-
tacks automatically. The model transformation tool takes a resiliency pattern
speciﬁed in the transformation language HATL and generates a new model in-
cluding unknown parameters whose values can be determined by the synthesizer
tool such that the safety requirement is satisﬁed. We demonstrated the appli-
cability of REAFFIRM by using the toolkit to eﬃciently repair CPS models
under realistic attacks including the ACC models under the GPS sensor spoof-
ing attack, the SMIB models under the sliding-model attack, and the MG system
under gyroscopes spooﬁng attack.

References

1. Agrawal, A., Karsai, G., L´edeczi, ´A.: An end-to-end domain-driven software devel-
opment framework. In: Companion of the 18th annual ACM SIGPLAN conference
on Object-oriented programming, systems, languages, and applications. pp. 8–15.
ACM (2003)

2. Agrawal, A., Karsai, G., Shi, F.: Graph transformations on domain-speciﬁc models.

Journal on Software and Systems Modeling 37, 1–43 (2003)

3. Agrawal, A., Simon, G., Karsai, G.: Semantic translation of simulink/stateﬂow
models to hybrid automata using graph transformations. Electronic Notes in The-
oretical Computer Science 109, 43–56 (2004)

Title Suppressed Due to Excessive Length

19

4. Al Faruque, M., Regazzoni, F., Pajic, M.: Design methodologies for securing cyber-
physical systems. In: Proceedings of the 10th International Conference on Hard-
ware/Software Codesign and System Synthesis. pp. 30–36. IEEE Press (2015)
5. Alur, R., Courcoubetis, C., Halbwachs, N., Henzinger, T.A., Ho, P.H., Nicollin,
X., Olivero, A., Sifakis, J., Yovine, S.: The algorithmic analysis of hybrid systems.
Theoretical computer science 138(1), 3–34 (1995)

6. Asarin, E., Dang, T., Maler, O.: The d/dt tool for veriﬁcation of hybrid systems. In:
International Conference on Computer Aided Veriﬁcation. pp. 365–370. Springer
(2002)

7. Bak, S., Beg, O.A., Bogomolov, S., Johnson, T.T., Nguyen, L.V., Schilling, C.:
Hybrid automata: from veriﬁcation to implementation. International Journal on
Software Tools for Technology Transfer pp. 1–18 (2017)

8. Bak, S., Bogomolov, S., Johnson, T.T.: Hyst: a source transformation and transla-
tion tool for hybrid automaton models. In: Proceedings of the 18th International
Conference on Hybrid Systems: Computation and Control. pp. 128–133. ACM
(2015)

9. Chen, C., Dong, J.S., Sun, J.: A formal framework for modeling and validating

simulink diagrams. Formal Aspects of Computing 21(5), 451–483 (2009)

10. Chen, X., ´Abrah´am, E., Sankaranarayanan, S.: Flow*: An analyzer for non-linear
hybrid systems. In: International Conference on Computer Aided Veriﬁcation. pp.
258–263. Springer (2013)

11. DeCarlo, R.A., Zak, S.H., Matthews, G.P.: Variable structure control of nonlinear
multivariable systems: a tutorial. Proceedings of the IEEE 76(3), 212–232 (1988)
12. Donz´e, A.: Breach, a toolbox for veriﬁcation and parameter synthesis of hybrid

systems. In: Computer Aided Veriﬁcation. pp. 167–170. Springer (2010)

13. Duggirala, P.S., Mitra, S., Viswanathan, M., Potok, M.: C2e2: a veriﬁcation tool
for stateﬂow models. In: International Conference on Tools and Algorithms for the
Construction and Analysis of Systems. pp. 68–82. Springer (2015)

14. Farraj, A.K., Hammad, E.M., Kundur, D., Butler-Purry, K.L.: Practical limita-
tions of sliding-mode switching attacks on smart grid systems. In: PES General
Meeting— Conference & Exposition, 2014 IEEE. pp. 1–5. IEEE (2014)

15. Fitzgerald, J., Pierce, K., Gamble, C.: A rigorous approach to the design of re-
silient cyber-physical systems through co-simulation. In: Dependable Systems and
Networks Workshops (DSN-W), 2012 IEEE/IFIP 42nd International Conference
on. pp. 1–6. IEEE (2012)

16. Frehse, G., Le Guernic, C., Donz´e, A., Cotton, S., Ray, R., Lebeltel, O., Ripado, R.,
Girard, A., Dang, T., Maler, O.: SpaceEx: Scalable veriﬁcation of hybrid systems.
In: Computer Aided Veriﬁcation (CAV). LNCS, Springer (2011)

17. Gamage, T.T., McMillin, B.M., Roth, T.P.: Enforcing information ﬂow security
properties in cyber-physical systems: A generalized framework based on compen-
sation. In: Computer Software and Applications Conference Workshops (COMP-
SACW), 2010 IEEE 34th Annual. pp. 158–163. IEEE (2010)

18. Henzinger, T.A., Kopke, P.W., Puri, A., Varaiya, P.: What’s decidable about hy-
brid automata? In: Proceedings of the twenty-seventh annual ACM symposium on
Theory of computing. pp. 373–382. ACM (1995)

19. Jackson, M., Fitzgerald, J.: Resilience proﬁling in the model-based design of cyber-
physical systems. In: 14th Overture Workshop: Towards Analytical Tool Chains,
Technical Report ECE-TR-28. pp. 1–15

20. Jin, X., Donz´e, A., Deshmukh, J.V., Seshia, S.A.: Mining requirements from closed-
loop control models. Computer-Aided Design of Integrated Circuits and Systems,
IEEE Transactions on 34(11), 1704–1717 (2015)

20

Luan Nguyen et al.

21. Kapinski, J., Deshmukh, J., Jin, X., Ito, H., Butts, K.: Simulation-guided ap-
proaches for veriﬁcation of automotive powertrain control systems. In: American
Control Conference (ACC), 2015. pp. 4086–4095. IEEE (2015)

22. Kerns, A.J., Shepard, D.P., Bhatti, J.A., Humphreys, T.E.: Unmanned aircraft
capture and control via gps spooﬁng. Journal of Field Robotics 31(4), 617–636
(2014)

23. Kocher, P., Lee, R., McGraw, G., Raghunathan, A., Moderator-Ravi, S.: Security
as a new dimension in embedded system design. In: Proceedings of the 41st annual
Design Automation Conference. pp. 753–760. ACM (2004)

24. Kong, S., Gao, S., Chen, W., Clarke, E.: dreach: δ-reachability analysis for hybrid
systems. In: International Conference on Tools and Algorithms for the Construction
and Analysis of Systems. pp. 200–205. Springer (2015)

25. Koscher, K., Czeskis, A., Roesner, F., Patel, S., Kohno, T., Checkoway, S., McCoy,
D., Kantor, B., Anderson, D., Shacham, H., et al.: Experimental security analysis
of a modern automobile. In: Security and Privacy (SP), 2010 IEEE Symposium
on. pp. 447–462. IEEE (2010)

26. Koutsoukos, X., Karsai, G., Laszka, A., Neema, H., Potteiger, B., Volgyesi, P.,
Vorobeychik, Y., Sztipanovits, J.: Sure: A modeling and simulation integration
platform for evaluation of secure and resilient cyber–physical systems. Proceedings
of the IEEE 106(1), 93–112 (2018)

27. Li, C., Raghunathan, A., Jha, N.K.: Hijacking an insulin pump: Security attacks
and defenses for a diabetes therapy system. In: e-Health Networking Applications
and Services (Healthcom), 2011 13th IEEE International Conference on. pp. 150–
156. IEEE (2011)

28. Liu, J., Lv, J., Quan, Z., Zhan, N., Zhao, H., Zhou, C., Zou, L.: A calculus for
hybrid csp. In: Asian Symposium on Programming Languages and Systems. pp.
1–15. Springer (2010)

29. Liu, S., Chen, B., Zourntos, T., Kundur, D., Butler-Purry, K.: A coordinated multi-
switch attack for cascading failures in smart grid. IEEE Transactions on Smart Grid
5(3), 1183–1195 (2014)

30. Liu, S., Feng, X., Kundur, D., Zourntos, T., Butler-Purry, K.: A class of cyber-
physical switching attacks for power system disruption. In: Proceedings of the Sev-
enth Annual Workshop on Cyber Security and Information Intelligence Research.
p. 16. ACM (2011)

31. Maler, O., Nickovic, D.: Monitoring temporal properties of continuous signals. In:
Formal Techniques, Modelling and Analysis of Timed and Fault-Tolerant Systems,
pp. 152–166. Springer (2004)

32. Minopoli, S., Frehse, G.: Sl2sx translator: from simulink to spaceex models. In:
Proceedings of the 19th International Conference on Hybrid Systems: Computation
and Control. pp. 93–98. ACM (2016)

33. Neema, H., Potteiger, B., Koutsoukos, X., Karsai, G., Volgyesi, P., Sztipanovits,
J.: Integrated simulation testbed for security and resilience of cps. In: Proceedings
of the 33rd Annual ACM Symposium on Applied Computing. pp. 368–374. ACM
(2018)

34. Pajic, M., Weimer, J., Bezzo, N., Sokolsky, O., Pappas, G.J., Lee, I.: Design and
implementation of attack-resilient cyberphysical systems: With a focus on attack-
resilient state estimators. IEEE Control Systems 37(2), 66–81 (2017)

35. Sabanovic, A., Fridman, L.M., Spurgeon, S., Spurgeon, S.K.: Variable structure

systems: from principles to implementation, vol. 66. IET (2004)

36. Sauer, P.W., Pai, M.: Power system dynamics and stability. Urbana (1998)

Title Suppressed Due to Excessive Length

21

37. Shoukry, Y., Martin, P., Tabuada, P., Srivastava, M.: Non-invasive spooﬁng at-
tacks for anti-lock braking systems. In: Proceedings of the 15th International Con-
ference on Cryptographic Hardware and Embedded Systems. pp. 55–72. CHES’13,
Springer-Verlag, Berlin, Heidelberg (2013)

38. Tippenhauer, N.O., P¨opper, C., Rasmussen, K.B., Capkun, S.: On the requirements
for successful gps spooﬁng attacks. In: Proceedings of the 18th ACM conference
on Computer and communications security. pp. 75–86. ACM (2011)

39. Tripakis, S., Sofronis, C., Caspi, P., Curic, A.: Translating discrete-time simulink
to lustre. ACM Transactions on Embedded Computing Systems (TECS) 4(4), 779–
818 (2005)

40. Wan, J., Canedo, A., Al Faruque, M.A.: Security-aware functional modeling of
cyber-physical systems. In: Emerging Technologies & Factory Automation (ETFA),
2015 IEEE 20th Conference on. pp. 1–4. IEEE (2015)

41. Wasicek, A., Derler, P., Lee, E.A.: Aspect-oriented modeling of attacks in automo-
tive cyber-physical systems. In: Design Automation Conference (DAC), 2014 51st
ACM/EDAC/IEEE. pp. 1–6. IEEE (2014)

42. Weimer, J., Ivanov, R., Chen, S., Roederer, A., Sokolsky, O., Lee, I.: Parameter-
invariant monitor design for cyber–physical systems. Proceedings of the IEEE
106(1), 71–92 (2018)

22

Luan Nguyen et al.

Fig. 11. The repaired ACC model with a synthesized value of θ = 7.08515 w.r.t the
ﬁrst resiliency pattern

.

Fig. 12. The repaired ACC model with a synthesized value of θ = 7.08515 w.r.t the
second resiliency pattern

.

A Appendix: Additional Experimental Results

The repaired ACC models. Figure 11, Figure 12, and Figure 13 show the
repaired models of the ACC system using the ﬁrst, second and third resiliency
patterns, respectively.

Speed_Control_copydu:d_dot	=	-v+vl;v_dot	=		2*vl	-	v	-	ev;ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(nenc	+	nenc);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;Spacing_Control_copydu:d_dot	=	-v+vl;v_dot	=	2*vl	-	v	-	ev	-	0.25*(10	+	2*ev	-	ed);ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-	ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(nenc	+	nenc)-	0.25*(10	+	2*ev	-	ed);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;Spacing_Controldu:d_dot	=	-v+vl;v_dot	=	2*vl	-	v	-	ev	-	0.25*(10	+	2*ev	-	ed);ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-	ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(ngps	+	nenc)-	0.25*(10	+	2*ev	-	ed);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;Speed_Controldu:d_dot	=	-v+vl;v_dot	=		2*vl	-	v	-	ev;ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(ngps	+	nenc);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;[ed	<	10	+	2*ev][ed	>=	10	+	2*ev]1[abs(ngps-nenc)	>	7.08515]2[ed	>=	10	+	2*ev][ed	<	10	+	2*ev]1{d	=	d0;	v	=	v0;	ed	=	ed0;	ev	=	ev0;}[abs(ngps-nenc)	>	7.08515]2Speed_Control_copydu:d_dot	=	-v+vl;v_dot	=		2*vl	-	v	-	ev;ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(nenc	+	nenc);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;Spacing_Control_copydu:d_dot	=	-v+vl;v_dot	=	2*vl	-	v	-	ev	-	0.25*(10	+	2*ev	-	ed);ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-	ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(nenc	+	nenc)-	0.25*(10	+	2*ev	-	ed);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;Spacing_Controldu:d_dot	=	-v+vl;v_dot	=	2*vl	-	v	-	ev	-	0.25*(10	+	2*ev	-	ed);ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-	ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(ngps	+	nenc)-	0.25*(10	+	2*ev	-	ed);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;Speed_Controldu:d_dot	=	-v+vl;v_dot	=		2*vl	-	v	-	ev;ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(ngps	+	nenc);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;[abs(ngps-nenc)	<	0.708515]1[ed	<	10	+	2*ev]2[ed	>=	10	+	2*ev]2[abs(ngps-nenc)	<	0.708515]1[ed	<	10	+	2*ev]1[abs(ngps-nenc)	>	0.708515]2[abs(ngps-nenc)	>	0.708515]2[ed	>=	10	+	2*ev]1{d	=	d0;	v	=	v0;	ed	=	ed0;	ev	=	ev0;}Title Suppressed Due to Excessive Length

23

Fig. 13. The repaired ACC model with a synthesized value of θ = 0.1543 w.r.t the
third resiliency pattern.

Fig. 14. Single-machine inﬁnite-bus system [14].

The SMIB system. Figure 14 represents the general structure of the SMIB
system. In this system, G∞ and G1 correspondingly represent the SMIB and
local generators; B∞ and B1 denote the inﬁnite and local bus, respectively; E∞
is the inﬁnite bus voltage; E1 is the internal voltage of G1; B1∞ is the transfer
susceptance of the line between B1 and B∞; and PM is the mechanical power
of G1. The local load PL is connected or disconnected to the grid by changing a
circuit breaker status.

Sliding-mode attack model of the SMIB system. To perform the sliding-
mode attack on the original SMIB model, we model the attack as the SLSF
model shown in Figure 15. In this model, we assume that the attacker selects a
sliding surface s(x) = δ1+ω1 = 0.2, and the local variable t captures a simulation
duration. We note that two transitions from the ﬁrst mode to the second mode
are executed with priorities such that the load is permanently disconnected at
some instance where t ≥ 2.5 seconds. More details of the stages to construct the
sliding-mode attack can be found in [14].

Figure 16 illustrates the examples of stable (i.e., without an attack) and un-
stable (i.e., a counterexample appearing under the sliding-model attack) behav-
iors of the SMIB system returned by running the falsiﬁer of Breach, respectively.

Speed_Controldu:d_dot	=	-v+vl;v_dot	=		2*vl	-	v	-	ev;ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-	ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(2*0.1543*ngps	+	2*(1-0.1543)*nenc);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;Spacing_Controldu:d_dot	=	-v+vl;v_dot	=	2*vl	-	v	-	ev	-	0.25*(10	+	2*ev	-	ed);ed_dot	=		vl	-	ev	+	10*(d	+	nrad	-	ed);ev_dot	=	2*vl	+	v	-	3*ev	+	0.5*(2*0.1543*ngps	+	2*(1-0.1543)*nenc)-	0.25*(10	+	2*ev	-	ed);d_out	=	d;v_out	=	v;ed_out	=	ed;ev_out	=	ev;[ed	>=	10	+	2*ev][ed	<	10	+	2*ev]{d	=	d0;	v	=	v0;	ed	=	ed0;	ev	=	ev0;}24

Luan Nguyen et al.

Fig. 15. The Stateﬂow chart models the sliding-mode attack to the SMIB system.

The red box deﬁnes the stable (safe) operation region of the SMIB system that
can be formalized by the STL formula ϕSM IB.

Fig. 16. From left to right: 1) the stable system trajectory without an attack, 2)
the counterexample represents the unstable system trajectory under the sliding-mode
attack, and 3) the status of a circuit breaker during the attack, where 0 and 1 represent
the disconnection and connection of the load PL, respectively.

Mode_2du:t_dot	=	1;Mode_1du:t_dot	=	1;[delta	+	omega	>=	0.2]{load_out	=	1;}2[delta	+	omega	<	-0.2]{load_out	=	0;}[delta	+	omega	>=	0.2&&t	>=2.5]{load_out	=	0;}1-1-0.500.511.522.533.541 (rad)-3-2-1012341(rad/s)-1-0.500.511.522.533.541 (rad)-3-2-1012341(rad/s)00.511.522.533.54Time (s)01Load Swiching Status