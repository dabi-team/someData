Fully Homomorphic Encryption via Affine Automorphisms 

Paul Hriljac 

 Embry-Riddle Aeronautical University 

Abstract 

This paper describes a methodology for implementing a form of fully homomorphic encryption. 
The scheme applies to straight line computer programs operating on data sets composed of n-
tuples of integers via a set of mathematical operations based on integral affine automorphisms, a 
classic field of study in algebraic geometry and number theory. The data is encrypted with a new 
type of multivariate encryption originating from the same operations. The potential resiliency of 
the scheme is based on the difficulty of solving or analyzing systems of nonlinear Diophantine 
equations. The impact of this scheme on computation and memory is analyzed and is shown to 
be considerably less than other current methods of fully homomorphic encryption, to an extent 
that could make this scheme practical for some applications. Several working examples of the 
scheme applied to simple programs are included.  

Introduction 

Fully homomorphic encryption (FHE) was first conjectured by Ron Rivest (see [R], [RAD]) who 
noticed that the RSA algorithm was homomorphic with respect to multiplication, and 
conjectured generalization to other types of arithmetic and logical operations. Craig Gentry (see 
[G1],[G2]) created the first FHE scheme. There have been a number of important additional 
results in this area (see [CNT],[DGHV],[GH], [GM], [M],[SS], [RS], etc.) 

Generally, FHE refers to schemes for processing encrypted data without the need for ever 
decrypting it. A FHE scheme is composed of four procedures: key generation, encryption, 
decryption, and program modification that together act on families of programs and data.  The 
program modification procedure transforms programs so that they operate on encrypted data 
without the need for decryption first. Typically, the encryption used is independent of the 
programs, for instance Gentry uses a lattice-based algorithm, then transforms programs using his 
method of bootstrapping.  

The scheme introduced here follows a different order. The modification procedure is applied first 
to a program, and then the encryption and decryption procedures are created that apply to the 
relevant data. The modification process is performed by generating a nonlinear algebraic 
automorphism (a transformation consisting of a system of polynomial functions with an inverse 
of the same form) of the variables of the program, then rewriting the program with this 
transformation. Essentially a new random coordinate system is generated for the state space of 
the program, and all the instructions of the program are rewritten in terms of that coordinate 
system. Data is encrypted by expressing it in that coordinate system. Cryptoanalysis of the 

scheme is equivalent to discovery of the inverse of a system of nonlinear algebraic equations 
with integer coefficients, a problem with known difficulty (see [CLO], [LL],[Y]). The result is a 
scheme that transforms programs with manageable computational impact and has a resilient 
encryption algorithm.  

Acknowledgements 

Thanks to Jon Haass, Hisa Tsutsui, Jim Francis, Ed Poon, Matt Jaffe, David Russell, John Harrel, 
Tim Lewis, Jesse Walker, Drew Dean, Paul Friedrichs, Steve Huffman, Bruce Hoy and Joel 
Bagnal. The research in this paper was partially supported by an AFOSR STTR, USAF contract 
# FA8750-11-C-0141. Some computations in this paper were performed by using MapleTM, a 
product of Maplesoft.  

Overview 

Fully Homomorphic Encryption can be thought of an encrypted data set and functions to process 
the data in such a way that the processing occurs without ever having to decrypt the data, until 
the very end, when the data has been moved to a safe resting place.  An application would be a 
cloud-based bank. Such an organization must process their records on a server they don’t control 
while protecting privacy and data integrity, a data-in-motion problem. We model such situations 
by thinking of the data set as a collection of integer-valued n-tuples and piecewise polynomial 
functions carrying these n-tuples to other n-tuples.  

Model of Computation 

Begin with a computer program P expressed as a straight-line program over the integers, see 
[Ka]. So that we have a finite directed graph with three types of nodes (input, output, and 
computation), a state space ℤn, input space ℤk , output space ℤl  and a collection of integer 
polynomial functions associated with each node of the graph. For simplicity we assume that 
there is only one input node and one output node. Therefore, we have: 

1.  u  ℤk , the input variables to P ; 
2.  v  ℤl, the output variables of P; 
3.  x  ℤn, the state variables of P; 
4.  A polynomial input function 𝑓𝑖𝑛: ℤ𝑘 → ℤ𝑛; 
5.  A polynomial output function 𝑓𝑜𝑢𝑡: ℤ𝑛 → ℤ𝑙; 
6.  A collection of polynomial processing functions 𝑓𝑠𝑠
𝑎  ↔ 𝑐𝑜𝑚𝑝𝑢𝑡𝑎𝑡𝑖𝑜𝑛 𝑛𝑜𝑑𝑒𝑠 𝑜𝑓 𝑡ℎ𝑒 𝑔𝑟𝑎𝑝ℎ 𝑓𝑜𝑟 𝑃 

𝑎: ℤ𝑛 → ℤ𝑛 

The idea behind our process is based on integer-valued affine transformations. These are 
(possibly) nonlinear, invertible polynomial mappings from integer n-tuples to themselves. Such 
mappings have been studied in algebraic geometry for a very long time. Generating these 
mappings are very easy but analyzing them is very hard.  

First Example 

We start with a simple but illustrative example. Consider the following MapleTM program which 
adds and multiplies two numbers: 

We define a pair of automorphisms of integer 2-tuples by 

𝑌1
[
𝑌2
𝑌1
𝑌2

[

𝑋1
𝑋2

] =  𝜓 ([

𝑋1
𝑋2

]) = [ −𝑋1 − 3 ∗ 𝑋2 + 2 ∗ 𝑋22
] = 𝜙 ([
]) = [5 ∗ 𝑌1 + 3 ∗ 𝑌2 + 8 ∗ 𝑌12 + 8 ∗ 𝑌1 ∗ 𝑌2 + 2 ∗ 𝑌22

2 ∗ 𝑋1 + 5 ∗ 𝑋2 − 4 ∗ 𝑋22], 

]. 

−2 ∗ 𝑌1 − 𝑌2

These mappings are algebraic inverses of each other. Using them one can rewrite any algebraic 
relation between the variable X1 and X2 in terms of the variables Y1 and Y2. We rewrite the 
update equations 𝑋1 ← 𝑋1 + 𝑋2 and 𝑋2 ← 𝑋1 ∗ 𝑋2 occurring above in terms of Y1 and Y2, 
resulting in 

Y1←1664*Y1^4*Y2+1728*Y1^3*Y2^2+1536*Y1^5*Y2+1280*Y1^3*Y2^3+362*Y1^2*Y2^2
+232*Y2^4*Y1+440*Y1^3*Y2+132*Y2^3*Y1+96*Y2^5*Y1 
+1920*Y1^4*Y2^2+480*Y1^2*Y2^4+896*Y1^2*Y2^3+72*Y1^2*Y2+36*Y2^2*Y1+25*Y1*
Y2+512*Y1^6+640*Y1^5+48*Y1^3+22*Y1^2+200*Y1^4+7*Y2^2 
+24*Y2^5+8*Y2^6+6*Y2^3+18*Y2^4-3*Y1-2*Y2; 

Y2←-3328*Y1^4*Y2-3456*Y1^3*Y2^2-3072*Y1^5*Y2-2560*Y1^3*Y2^3-724*Y1^2*Y2^2-
464*Y2^4*Y1-880*Y1^3*Y2-264*Y2^3*Y1-192*Y2^5*Y1 
-3840*Y1^4*Y2^2-960*Y1^2*Y2^4-1792*Y1^2*Y2^3-120*Y1^2*Y2-60*Y2^2*Y1-
39*Y1*Y2-1024*Y1^6-1280*Y1^5-80*Y1^3-34*Y1^2-400*Y1^4-11*Y2^2 
-48*Y2^5-16*Y2^6-10*Y2^3-36*Y2^4+6*Y1+4*Y2; 

Using the function 𝜙 allows for input data U1, U2 to be written in terms of Y1 and Y2. The new 
program is  

E(fun1):= proc (U1, U2)  
local X1, X2, Y1, Y2, temp1, temp2;  
Y1 := -U1-3*U2+2*U2^2;  

 
 
 
 
 
 
 
Y2 := 2*U1+5*U2-4*U2^2;  

temp1:=1664*Y1^4*Y2+1728*Y1^3*Y2^2+1536*Y1^5*Y2+1280*Y1^3*Y2^3+362*Y1^2*Y
2^2+232*Y2^4*Y1+440*Y1^3*Y2+132*Y2^3*Y1+96*Y2^5*Y1 
+1920*Y1^4*Y2^2+480*Y1^2*Y2^4+896*Y1^2*Y2^3+72*Y1^2*Y2+36*Y2^2*Y1+25*Y1*
Y2+512*Y1^6+640*Y1^5+48*Y1^3+22*Y1^2+200*Y1^4+7*Y2^2 
+24*Y2^5+8*Y2^6+6*Y2^3+18*Y2^4-3*Y1-2*Y2;  

temp2 := -3328*Y1^4*Y2-3456*Y1^3*Y2^2-3072*Y1^5*Y2-2560*Y1^3*Y2^3-
724*Y1^2*Y2^2-464*Y2^4*Y1-880*Y1^3*Y2-264*Y2^3*Y1-192*Y2^5*Y1 
-3840*Y1^4*Y2^2-960*Y1^2*Y2^4-1792*Y1^2*Y2^3-120*Y1^2*Y2-60*Y2^2*Y1-
39*Y1*Y2-1024*Y1^6-1280*Y1^5-80*Y1^3-34*Y1^2-400*Y1^4-11*Y2^2 
-48*Y2^5-16*Y2^6-10*Y2^3-36*Y2^4+6*Y1+4*Y2;  

Y1 := temp1;  
Y2 := temp2;  
return(Y1, Y2); 
end proc; 

If one were to take values returned by this program and run them through the mappings provided 
by the function 𝜓 so that  

𝑉1
[
𝑉2

] =  𝜓 ([

𝑌1
𝑌2

]) = [5 ∗ 𝑌1 + 3 ∗ 𝑌2 + 8 ∗ 𝑌12 + 8 ∗ 𝑌1𝑌2 + 2 ∗ 𝑌22

] 

−2 ∗ 𝑌1 − 𝑌2

the same output as the original function would be obtained. 

Some Properties of the Algorithm 

We construct procedures KG, F, E, D where: 

I.  KG:    Aut ℤn = the group of all polynomial mappings from ℤn  to itself with an 

inverse  of the same form. This plays the role of the security parameter in this scheme 

II.  E(P) is a new program with directed graph, state space, input, and output all isomorphic 

to those of the original program.  

III.  𝐸𝜙: ℤk→ ℤn is an asymmetric encryption function. 
IV.  D: ℤn→ ℤl is an asymmetric decryption function. 
V.  D(E(P)(E(u))) = P(u), i.e. the transformed program correctly processes encrypted data. 

Some of the properties of the scheme are: 

i.  Let  (x) = (1(x),…,n(x)) be the component polynomials of the map , with x = x1,..., 

xn. Assume that each polynomial 1(x),…,n(x) has been written in standard (dense)  
form. Let d() denote the maximum degree of 1(x),…,n(x). Let|| denote the maximum 

 
 
 
 
 
 
 
 
absolute value of any coefficient of 1(x),…,n(x). Let m() denote the maximum 
number of monomials of 1(x),…,n(x).  Then  

|E(u)| ≤  || m() (|RG||u|)d() 

where |RG| denotes the maximum output of the random number generator used in the 
encryption procedure. Consequently, an input u to the program P, consisting of m b-bit 
numbers, will be encrypted as n B-bit numbers with B =  d()b + log(|| m()), assuming 
that the random number generator also produces b-bit numbers.  
If b  = 32, i.e. the program P  uses ordinary 32-bit integer variables, and   is quadratic 
with each component consisting of at most 4 monomials, each of whose coefficients was 
bounded by 232, then the transformed program would require the use of 98-bit integers.  

ii. 

iii.  Using any measure of complexity, the complexity of transformations E , D are bounded 

by the complexity of   and are independent of the complexity of P. 

iv.  The complexity of the transformed program is expressible in terms of the complexity of 
the original program, along with elementary measures of the security parameter .  
 Under simple and general conditions, the complexity of the transformed program will 
grow by approximately 2 or 3 orders of magnitude over the complexity of the original 
program, which is significantly less than other existing schemes. 

v. 

vi.  The encryption functions E , D are a new type of multivariate encryption, although are 
basically just the methods of Moh, Patarin, Masumoto, Imai, et.al. (see  [Mo],[P], [Mi]), 
in the setting of the integers rather than a finite field. To cryptoanalyze E one must solve 
n nonlinear equations in k unknowns with integer values. There are several techniques for 
attacking this problem, the most common being Grobner basis methods. The complexity 
of these methods is exponential in n (see [CLO],[LA], [LL],[Y]). Consequently the 
difficulty of cryptoanalyzing this encryption algorithm is exponential in n. 

The basis of our method is the exploitation of nonlinear algebraic automorphisms of ℤn. These 
objects can be thought of in several ways. The first is as a system of polynomial functions in 
several variables with integer coefficients. Inverting such an automorphism is equivalent to 
finding rational solutions to the system of equations with integral variables and coefficients. This 
is a hard thing to do, both in the general, theoretical sense and in any practical, computational 
sense, at least when dealing with more than a few variables. Another way to think of these 
automorphisms is as random curvilinear coordinate systems for vector spaces that keep integer 
lattices fixed. Using the first conceptualization of these automorphisms gives a new form of 
multivariate encryption. Using the second conceptualization yields a software obfuscation 
algorithm. 

Constructing automorphisms, the key generation algorithm 

To quantify matters, let S be a polynomial mapping of ℤn, S(x) = (S1(x),…, Sn(x)) with x = x1, 
...xn. Assume that each polynomial S1(x),…,Sn(x) has been written in standard, dense, form. Let 
d(S) denote the maximum degree of S1(x),…,Sn(x). Let |S| denote the maximum absolute value of 

any coefficient of S1(x),…,Sn(x). Let m(S) denote the maximum number of monomials of 
S1(x),…,Sn(x).  Let 𝑚̅ (S) denote the average number of monomials of S1(x),…,Sn(x). We shall 
display an algorithm which furnishes automorphism pairs that are constrained with respect to all 
these measures of complexity. 

When constructing polynomial automorphisms of ℤn, one thing that quickly becomes apparent is 
that the inverses are generically very complex (see [K] and [E]). We describe a way to generate 
nonlinear polynomial automorphisms of ℤn that allows for control on the complexity of the 
inverses. Not surprisingly, these automorphisms are tame, that is, they are constructed by 
composing a sequence of automorphisms which alternate between affine (linear with offset) and 
triangular. Triangular automorphisms are of the form  

T(x1,..., xn) =  (x1 + f1(x2,..., xn), ..., xi + fi(xi+1,...,xn),..., xn + fn) 

where each of the functions fi is a polynomial in the indicated variables.  Such a transformation is 
easily inverted with recursion. If y = T(x), then one can solve for each of the variables xi by 
starting with the last and going in reverse: 

xn  = yn - fn 
xn -1 = yn -1 – fn-1(xn) =  yn -1 – fn-1(yn - fn) 
xn -2 = yn -2 – fn-2( yn -1 – fn-1(yn - fn),  yn - fn) 
… 

From this recursion we obtain xi = gi(yi,...,yn) with  

gn(y) = yn- fn 

and  

Then  

gi(y)= yi - fi(gi+1(y),...,gn(y)) for i = n-1, n-2,....,1. 

T-1(y) = (g1(y),..., gn(y)). 

An important property of triangular automorphisms is that any measure of the inverse 
transformation typically grows very quickly with the number of variables n. For instance, the 
generic situation is that 

degree(gi) = degree(gi+1) degree(fi) 

Consequently, if a generic triangular automorphism T consisted of quadratic terms, the inverse 
would have terms of degree 22n-1
degree and complexity. If such transformations were used as factors of tame transformations and 

.  Even a few variables would result in inverses with enormous 

 
 
applied to program rewrites, things would quickly become untenable. To ameliorate this, 
suppose that the indices {1,...,n} are subdivided into two disjoint sets E1, E2. Suppose that for i  
E2 we have fi = 0. In this case gi(y) = yi.  Suppose also for i  E1 the polynomial fi is dependent 
only on variables whose indices are in E2. Then, for those indices, gi(y) = yi - fi(yi+1,...,yn). We 
call triangular transformations obtained in this way segmented by the partition E1, E2. It is clear 
that for such transformations 

d(T-1) = d(T), |T-1| = |T|, m(T-1) = m(T), 𝑚̅ (T-1) = 𝑚̅ (T). 

We will generate random sparse small segmented triangular nonlinear transformations as 
follows: 

The input to the procedure are parameters , d, , 𝜇̅. 

I. 
II. 
III. 

IV. 

Let E1 = {1,..., ⌈𝑛/2⌉}, E2 = {⌈𝑛/2⌉ + 1, … , 𝑛}. 
For i  E2 set fi = 0. 
For i  E1 randomly generate a number i   in the range [1, ] with mean E[i] = 𝜇̅. 
Generate 2i   monomials mj of degree ≤ d in the variables indexed by E2 with 
coefficients bounded by  in absolute value. Set fi = ∑ 𝑚𝑗
nonlinear, nonhomogenous fi is obtained. 
Set T(x) = (x1 + f1(x2,..., xn), ..., xi + fi(xi+1,...,xn),..., xn + fn). 

. Repeat this process until a 

𝑗

Then it is clear from the construction that: 

i. 
ii. 
iii. 
iv. 

d(T-1) , d(T) ≤ d. 
|T-1| , |T| ≤ . 
m(T-1) , m(T) ≤  . 
E[𝑚̅ (T-1)}, E[𝑚̅ (T)] ≤  𝜇̅. 

Once we have constructed triangular transformations, we generate affine automorphisms of ℤ𝑛, 
then compose these automorphisms to produce 𝜑. These too can result in inverses with large 
coefficients. To prevent this, we create affine transformations as follows: 

Generate small sparse random affine transformations by first generating small sparse unimodular 
matrices. We will do this by first generating a block diagonal matrix consisting of small 
unimodular matrices of sizes 1 by 1 and 2 by 2. We will then multiply the resulting matrix on left 
and right by permutation matrices. 

I. 

To generate small random unimodular 2 by 2 matrices, with norm bounded by  and 
determinant δ = ±1. Proceed as follows: 

1.  Pick two random coprime numbers x11, x12 both with absolute value ≤ .  

 
2.  Solve the equation  x x11-y x12 = δ. Since x11 and x12 are coprime, this equation is 

solvable. Find the solution with minimal absolute value. Then |x|,|y| ≤ .  
𝑦 ] is unimodular with |M|, |M-1| ≤ . 

𝑥11 𝑥12
𝑥

3.  Then 𝑀 = [

II. 

To generate a sparse, small n by n unimodular block diagonal matrix, start with inputs 
 ≥ 1, α in the range [1, n]. Then: 

1.  Generate random numbers δi = ±1, for i = 1, ..., n – 2α + 1.  
2.  Use I. to generate α distinct 2 by 2 unimodular matrices M1, …, Mα with |Mi|,|Mi

-

1|≤  and  det(Mi) = δi. 

3.  Define ∆ by using the matrices M1, …, Mα  along with 1 by 1 matrices  [δi] for i = 

α + 1, ... n – 2α + 1 on the diagonal of ∆ 

The resulting matrix ∆ has the properties: 

i. 
ii. 
iii. 
iv. 

Determinant δ (∆) = ∏ δi,  
|∆|, |∆-1| ≤ ,  
m(∆), m(∆-1) ≤ 2,  
 𝑚̅ (∆) = 𝑚̅ (∆-1) = 1 + 2α/n.  

III. 

To generate an arbitrary small, sparse, unimodular n by n matrices. Start with 
parameters  ≥ 1, 𝜇̅  in the range (1,2). 

1.  Pick a random integer α between 1 and n with expected value n(𝜇̅-1)/2.  
2.  Use II to generate a random unimodular block diagonal matrix ∆. 
3.  Generate two random n by n permutation matrices P1, P2, 
4.  Let M =  P1 ∆ P2 

The resulting matrix M has the properties: 

i. 
ii. 
iii. 
iv. 

δ (M) = ±1 
|M|, |M-1| ≤ , 
m(M), m(M-1) ≤ 2,  
E[𝑚̅ (M)] = E[𝑚̅ (M-1)] = 𝜇̅.  

IV. 

To generate a small sparse affine transformation A, start with parameters  ≥ 1, 𝜇̅, and 
. Let  = log .  
1.  Use III to generate matrices M1,…, M with parameters (/)1/  and  𝜇̅1/ .   
2.  Let M = M1…M. 

The resulting affine transformation has the properties: 

 
 
 
 
 
i. 
ii. 
iii. 

|A|, |A-1| ≤ , 
E[𝑚̅ (A)] = E[𝑚̅ (A-1)] ≤ 𝜇̅.  
m(A) , m(A-1) ≤ . 

To generate tame automorphisms of ℤn, start with parameters b, d, m, 𝑚̅ , k.  

Choose δ(1),…,δ(k) so Π = Πi≤k δ(i) ≤ d. Let Δ(i) = δ(1)∙…∙δ(i), Σ= 1+Δ(1) +…+Δ(k-1). 

Choose t, a so that (at)Σ(a)Δ(k) ≤ m. 

Choose t, a  so that (aatt)Σ(aa)Δ(k) ≤ b. 

Choose 𝜇̅𝑡, 𝜇̅𝑎 so that (𝜇̅𝑎𝜇̅𝑡)Σ(𝜇̅𝑎)Δ(k) ≤  𝑚̅ . 

I. 

Use the affine generation algorithm with parameters a, a, 𝜇̅𝑎 to generate a sequence 
of sparse, small affine transformations A0,…,Ak with the properties that: 

i. 
ii. 
iii. 

-1| ≤ a, 
|Ai|, |Ai
E[𝑚̅ (Ai)] = E[𝑚̅ (Ai
m(Ai) ≤ a. 

-1)] ≤ 𝜇̅𝑎.  

II. 

Use the triangular generation algorithm with parameters t, δ(i), t, 𝜇̅𝑡  sequence of 
small sparse triangular transformations T1,…,Tk with the properties that: 

i. 
ii. 
iii. 
iv. 

-1| ≤ t, 
|Ti|, |Ti
E[𝑚̅ (Ti)] = E[𝑚̅ (Ti
-1) ≤ t. 
m(Ti), m(Ti
-1) ≤ δ(i). 
d(Ti), d(Ti

-1)] ≤ 𝜇̅𝑡.  

Let 𝜑 = A0 T1… Tk Ak.  

 It is easy to see that  

|𝜑| ≤ |A0|m(A0)|T1|m(T1)(|A1|m(A1))Δ(1)(|T2|m(T2))Δ(1)...(|Tk|m(Tk))Δ(k-1)|Ak|Δ(k) 
≤ (aatt)(aatt)Δ(1)(aatt)Δ(2)... (aatt)Δ(k-1)(aa)Δ(k) 
=(aatt)Σ(aa)Δ(k) 

m(S) ≤ m(A0)m(T1)m(A1)Δ(1)m(T2)Δ(1)m(A2)Δ(2)...m(Tk)Δ(k-1)m(Ak)Δ(k) ≤ (at)Σ(a) Σ(k) 

Consequently 𝜑 has the properties that: 

i. 
ii. 

d(𝜑) ≤ Π.  
| 𝜑 | ≤ (aatt)Σ(aa)Δ(k) 

 
 
 
       
iii. 
iv. 

m(𝜑) ≤ (at)Σ(a)Δ(k) 
E[𝑚̅ (𝜑)] ≤ (𝜇̅𝑎𝜇̅𝑡)Σ(𝜇̅𝑎)Δ(k) 

If k  = 1, the bounds above correspond to: 

i. 
ii. 
iii. 
iv. 

d(S) ≤ δ(1).  
|S|, |S-1| ≤ tt(aa) δ(1)+1 
δ(1)+1 
m(S), m(S-1) ≤ ta
E[𝑚̅ (S)], E[𝑚̅ (S-1)] ≤ 𝜇̅𝑡𝜇̅𝑎

δ(1)+1 

We obtain: 

Theorem: The algorithm, with inputs 𝑛, 𝑑, 𝑏, 𝑚, 𝑚̅ described above yields an automorphisms 𝜑 
of ℤ𝑛 such that: 

1.  d(𝜑), d(𝜑 -1) ≤ d . 
2.  | 𝜑 |, | 𝜑 -1| ≤ b. 
3.  m(𝜑), m(𝜑 -1) ≤ m 
4.  E[𝑚̅ (𝜑)], E[𝑚̅ (𝜑 -1)] ≤ 𝑚̅ . 

Examples: 

If n=2, b=3, d=2, m=5,𝑚̅ = 5 a typical automorphism pair is  

If n = 2, b= 1012, d=2, m=5,𝑚̅ = 5 a typical automorphism pair is  

Variations on the key generation system 

 
 
 
 
Our key generation procedure is easily generalized, for example one could require that for 
indices i  E2 the polynomial fi is a constant (rather than 0). Another generalization is that for 
indices i  E1 all but one of the monomials comprising the polynomial fi depends only on 
variables whose indices are in E2. Still another generalization is to compose more than two affine 
transformations with one triangular transformation, for example one could use φ = A0 T1 A1 T2 
A2. Many variations are possible, allowing for the generation of tame automorphisms whose 
inverses are difficult to discover but feasible to use.  

Encryption and Decryption 

Having constructed an algebraic autorphism φ of ℤn , perform encryption as follows.: 

Encryption Algorithm (version 0) 

Encrypt vectors of integers of length n by applying the nonlinear automorphism φ to this vector 
to obtain the ciphertext, a vector of integers of length n so E(u) = φ(u). Decryption uses the 
inverse transformation ψ = φ -1 so D(u) = ψ(u). 

This algorithm furnishes public key encryption. One can publish φ and the random vector 
generator (the public keyed encryption algorithm) and keep ψ private.  

The strength of this encryption algorithm rests on the difficulty of solving systems of nonlinear 
algebraic equations. To break the encryption system, one must be able to solve, in x, the system 
of equations corresponding to the relation φ(x) = y, where y is the ciphertext and x is the 
plaintext. Here x and y can be considered as vectors of length n with integer values. There are 
several methods of solving these systems, the most important relies on Grobner bases to perform 
elimination theory. In all cases, these algorithms are exponential in n (see [LL]). An alternative 
attack is to start with knowledge of the generation algorithm and examine all possible component 
mappings. It is easy to bound the coefficients of these components using the size of the 
coefficients occurring in automorphism appearing in the encryption. However, is also easy to 
prove that the size of the search space grows exponentially with the size of the coefficients and 
super-exponentially with the number of variables.  

There are several methods of adding random number generation to this encryption algorithm that 
are analogous to PKE algorithms employing finite fields rather than integers and are also 
compatible with the program modification procedure of our scheme.  Two such are the 
following.  

Encryption Algorithm (version 1) 

Along with the automorphism φ of ℤn, start with some m < n, and a random number generator G. 
For u ℤm ,  let E(u) = φ(u, g), where g G(n-m) denotes a random vector of length n-m formed 
by using G repeatedly. This method relies on a careful choice of φ to insure that sufficient 

mixing of the input components occur, otherwise some components of E(u) may not exhibit any 
mixing with g. Decryption is D(u,g) = ψ(u,g), followed by truncation of the random component 
g. 

Encryption Algorithm (version 2) 

Along with the automorphism φ of ℤn, some m < n, and a random number generator G, start with 
h: ℤ n-m→ ℤm, H: ℤ n-m→ ℤn-m polynomial mappings with H an automorphism. Define E(u) = 
φ(u+h(g),H(g)) where g G(n-m). Decryption is performed by first applying ψ to obtain (v1, v2) 
with v1 ℤm , v2 ℤn-m ,  followed by (v1, v2) → (v1-h(H-1(v2), v2), followed by truncation. 

This version of encryption guarantees mixing of all the components of the plaintext message 
with random numbers. 

Encrypting the Program 

An automorphism of ℤn can be used to perform a type of encryption of the program. This is a 
new kind of mathematical algorithm that transforms any set of instructions of any straight line 
computer program. 

We start with the description of  a computer program P as above and an automorphism φ of ℤn, 
with inverse ψ. 

Perform a rewrite of expressions in the instruction set of P as follows:  

Define a new set of variables y = (y1,…,yn)  by y = φ(x), so x = ψ(y). Now rewrite P following 
the procedure: 

I.  Replace the computation instruction x←fα(x)  by the instruction y← Fα(y), where Fα(y) is 

a polynomial obtained from ψ(fα(φ(y)) by expanding and simplifying the algebraic 
expression. These instructions are equivalent assuming the relationship y = φ (x),  x = 
ψ(y). However trying to deduce fα(x) from ψ(fα(φ(y)) without knowing φ and ψ is 
generally a difficult problem. Note: this may require the introduction of dummy 
variables, as in the example above. 

II.  Replace the operations x←in(u), v←out(x) by the operations  y← φ(in(u)),   

              v←out(ψ(y)). 

III. Replace the variables x1,…,xn  by the variables y1,…, yn. 

The resulting program is denoted E(P). By construction P and E(P), followed by  D(v)have 
the same input-output relationships. 

Performance metrics 

 
  
 
Let |P| (respectively m(P) , d(P)) denote the maximum of |f|  (resp. m(f) , d(f))  for any instruction 
f appearing in P.  The complexity of the encrypted E(P)  is bounded by the complexities of P, , 
 by the following 

Theorem: 

|E(P)| ≤  ||m()m(P)d()|P|d()||d(P)d() 

d(E(P)) ≤  d()d(P)d() 

m(E(P)) ≤ m()m(P)d()m()d(P)d() 

Example: Under simple conditions a program P would have d(P) = 2 and m(P) = 2. If   and   
= -1 are both quadratic with m() = m()= 2, then d(F(P)) ≤  8 and m(F(P)) ≤ 128. Therefore 
the complexity of the transformed program would only grow by approximately 2 or 3 orders of 
magnitude. 

Program modification  

There are several variants of the procedure F(P) depending on what randomization was used to 
obtain the probabilistic encryption algorithm E.  

FHE Version 0 

In the case that the desired encryption algorithm is of the form E(u) = (u), i.e. deterministic 
encryption, proceed as follows: 

Set n = m.  Generate an automorphism φ of ℤn and use it to Encrypt P. Remove the input 
operation y ← φ(in(u)) and replace with the new input operation y ← w. Remove the output 
operation v ← out(ψ(y)) and replace it with new output operation z←y. The resulting program is 
E(P) . The encryption process is the mapping u → φ(in(u)). The decryption process is the 
mapping z → out(ψ(z)). 

FHE Version 1 

In the case that the desired encryption algorithm is version I, proceed as follows: Initially the 
state variables of P are x’ = (x1,…, xm), the input variables are u’ = (u1,…, uk). Let x’’ = (xm+1,…, 
xn), u’’ = (uk+1,…, uk+n-m). Let x = (x’ , x’’) = (x1,…, xn) be the new, expanded, set of state 
variables. Let u = (u’ , u’’) = (u1,… ,uk+n-m) be the new, expanded set of input variables. Augment 
the original input operation x’← in(u’) by (x’,x’’)← (in(u’),u’’).  Call this new program P’.  
Since x’’ does not appear in any of the instructions used by P, u’’ cannot effect the output of P’.  
Choose an automorphism φ of ℤn and use it to encrypt P’ as above, obtaining E(P’). The new 
state variables are y = φ(x). Remove the input operation of E(P’) and replace it by y← w. 

 
 
Remove the output operation v←out(ψ(y)) of E(P’) and replace it with new output operations z 
← y. The resulting program is F(P).  The encryption process is then Eφ(u) =  φ(in(u), g). The 
decryption process is the mapping Dφ(z) = out(ψ(z)t), here the subscript refers to truncation. If w 
= Eφ(u) is input to F(P), the value of the random input g will not affect the output of Dφ, 
although the processing of the state variables of F(P) will be affected.  

FHE Version 2 

In the case that the desired encryption algorithm is version 2, proceed as follows: Initially 
suppose that the state variables of P are x’ = (x1,…, xm), the input variables are u’ = (u1,…, uk). 
Let x’’ = (xm+1,…, xn), u’’ = (uk+1,…, uk+n-m). Let x = (x’ , x’’) = (x1,…, xn) be the new, expanded 
set of state variables. Let u = (u’ , u’’) =  (u1,… ,uk+n-m) be the new, expanded set of input 
variables. Replace the original input operation x’← in(u’) by (x’, x’’)← (in(u’)+h(u’’),H(u’’)).  
Immediately after this instruction, insert the instruction x  ← (x’-h(H-1(x’’)),K(x)), here K is any 
randomly chosen polynomial.  Call this new program P’.  Since x’’ does not appear in any of the 
instructions used by P, u’’ cannot effect the output of P’, and so neither can the choice of K.  
Choose an automorphism φ of ℤn and use it to encrypt P’ as above. The new state variables are y 
= φ(x). Remove the operation of E(P’) corresponding to the input operation (x’, x’’)← (in(u’) + 
h(u’’), H(u’’)) and replace it by y← w. Remove the output operation v← out(ψ(y)) and replace it 
with new output operation z←y. The resulting program is (P).  The encryption process is then 
Eφ(u) =  φ(in(u) + h(g), H(g)). The decryption process is the mapping Dφ(z) = out(ψ(z)). If w = 
Eφ(u) is input to F(P), the value of the random input g will not affect the output of Dφ, although 
the processing of the state variables of F(P) will be affected. 

One serendipitous feature of this program modification is that the calculations and decisions 
occurring during program execution are randomized and homogenized since every state variable 
is present and modified in every instruction. This acts as a defense against reverse engineering of 
the program by observing the program flow. 

Software Design Implications 

The FHE scheme described in this paper is conceptually easy to implement: One starts with a 
program, identifies the variables in the program, generates an automorphism pair, and then 
rewrites the source code of the program. In practice, things are more complicated. Modern 
source code is modular and dependent on hidden libraries, definitions, etc. Realizing a piece of 
source code with the model assumed in this paper would require extensive analysis. 
Consequently, one would perform this encryption process in an incremental and adaptive 
fashion.  In addition, performing encryption efficiently requires knowledge of the trade-offs 
between complexity and security that the process imposes. Judgment is required as to what trade-
offs are acceptable, which frequently necessitates domain expertise. Finally, the size of integer 
variables and calculations in a modified program grows significantly compared to the original 
program, which requires additional measures to accommodate. 

Encrypting More General Programs 

One might consider applying this method to programs other than straight line programs. The 
following example illustrates the with the problem with this. 

Start with the following program to compute 10! 

Any attempt to encrypt this program using affine transformations will necessitate the rewrite of 
the term X2. This will reveal part of the function 𝜓, resulting in a compromise of the encryption. 

This problem could be ameliorated by modifications of the program, for example by replacing 
the conditional statement by a more complex, but equivalent statement.  

Other Issues 

There are several variations on this encryption which should be explored. One is to finite fields 
and to employ this key generation algorithm or others that come from other forms of multivariate 
encryption. Another is to attempt to employ this method of encryption in the context of floating-
point numbers. Still another is to examine the use of this in a rational number field setting. 

Conclusions 

This paper has described a method of performing Fully Homomorphic Encryption which results 
in modified programs that are fast enough to be employed practically. The scheme uses 
transformations of the program that are derived from the theory of affine automorphisms, a 
branch of algebraic geometry. 

References: 

[BW ] T. Becker, V. Weispfenning (1998). Gröbner Bases. Springer Graduate Texts in 
Mathematics 141. ISBN 0-387-97971-7 

 
[CLO] D. Cox, J. Little, and D. O'Shea (1997).  Ideals, Varieties, and Algorithms: An 
Introduction to Computational Algebraic Geometry and Commutative Algebra. Springer. 
ISBN 0-387-94680-2. 

[CNT] JS. Coron; D. Naccache, M. Tibouchi. "Public Key Compression and Modulus Switching 
for Fully Homomorphic Encryption over the Integers" (PDF). 

[DGHV] M. van Dijk; C. Gentry, S. Halevi, and V. Vaikuntanathan (2009-12-11). "Fully 
Homomorphic Encryption over the Integers" (PDF). International Association for Cryptologic 
Research.  

[E] A. Essen, Automorphisms of Affine Space, 1994, Springer,  ISBN 978-0-7923-3523-8. 

[G1] C. Gentry. "A Fully Homomorphic Encryption Scheme (Ph.D. thesis)" 

[G2]  C. Gentry. “ Fully Homomorphic Encryption Using Ideal Lattices” In the 41st ACM 
Symposium on Theory of Computing (STOC), 2009 

[GH] C. Gentry; S. Halevi. "A Working Implementation of Fully Homomorphic Encryption" 
(PDF).  

[GM] S. Goldwasser, S. Micali (1982). "Probabilistic encryption and how to play mental poker 
keeping secret all partial information". Proc. 14th Symposium on Theory of Computing: 365–
377.  

[Ka] E. Kaltofen. Greatest common divisors of polynomials given by straight-line programs.  
J. ACM, 35(1):231-264, 1988. 

[K] H. Kraft, “CHALLENGING PROBLEMS ON AFFINE n-SPACE”, Seminaire BOURBAKI 
Juin 1995, 47µeme annee, 1994-95, no 802. 
[LA] M. Abramson (2001), "Solving systems of algebraic equations, translation of (Lazard 
1981)", ACM SIGSAM Bulletin 35 (3): 11–37 

[LL] Y. Lakshman , D. Lazard, “On the Complexity of Zero-Dimensional Algebraic Systems”  
in Effective Methods in Algebraic Geometry (1991), edited by Teo Mora, Carlo Traverso, 
Birkhauser, ISBN-13: 978-0817635466 

[Ma] Matsumoto, T. and Imai, H.: Public quadratic polynomial-tuples for efficient signature 
verification and message-encryption. In Advances in Cryptology — EUROCRYPT 1988, volume 
330 of Lecture Notes in Computer Science, pages 419–545. Christoph G. Günther, ed., Springer 
(1988). 

[M] D. Micciancio (2010-03-01). "A First Glimpse of Cryptography's Holy Grail". Association 
for Computing Machinery. p. 96.  

 
 
 
[Mo] T. Moh, “A public key system with signature and master key function”. Communications 
in Algebra, 27(5):2207–2222 (1999). 

[P] J. Patarin, “Hidden Fields Equations (HFE) and Isomorphisms of Polynomials (IP): Two 
New Families of Asymmetric Algorithms”, International Conference on the Theory and 
Applications of Cryptographic Techniques  EUROCRYPT 1996: Advances in Cryptology — 
EUROCRYPT ’96 pp 33-48 

[R] R. Rivest (2002-10-29). "Lecture Notes 15: Voting, Homomorphic Encryption" 

[RAD] R. L. Rivest, L. Adleman, and M. L. Dertouzos. On data banks and privacy 
homomorphisms. In Foundations of Secure Computation, 1978. 

[SS] D, Stehle; R. Steinfeld (2010-05-19). "Faster Fully Homomorphic Encryption" (PDF). 
International Association for Cryptologic Research.  

[RS] R. Riggio; S. Sicari. "Secure Aggregation in Hybrid Mesh/Sensor Networks" (PDF).  

[Y] C.K. Yap. Fundamental Problems of Algorithmic Algebra, 1999, Oxford University Press, . 
ISBN:0-19-512516-9. 

Appendix: A demonstration of the algorithm with randomized state variables. 

A demonstration of the algorithm follows. Start with a simple program P which adds and 
multiplies two numbers: The transforming procedure will follow version 2 of the algorithm.  

The initial program is: 

int main() //program P accepts two integers and returns their sum and product 
{ 

long x1=0,x2=0; 
scanf("%ld %ld",&x1,&x2); 
printf("%ld %ld\n",x1+x2,x1*x2); 
return(0); 

} 

Next, modify the program by including the procedure (x’, x’’)← (in(u’)+h(u’’),H(u’’)) to adjust 
the input into the program as described previously.  The resulting program follows: 

int main() 

//P’, the first modification of the program 

 
  
 
 
 
 
 
 
 
 
 
 
 
{ 

} 

// 
// x <- (u+h(g),H(g)) 
// h(g) = (g1,g1*g2) 
// H(g) = (g1+g2,g2) 
// 
// 

long x1,x2,x3,x4,u1,u2,g1,g2; 
//input 
scanf("%ld %ld",&u1,&u2); 
g1=rand(); 
g2=rand(); 
x1=u1+g1; 
x2=u2+g1*g2;  
x3=g1+g2; 
x4=g2;  
// end of input 
// 
// so  g2=x4  
// g1=x3-x4  
// u1=x1-g1=x1-(x3-x4) = x1-x3+x4  
// u2=x2-g1*g2=x2-(x3-x4)*x4=x2-x3*x4+x4*x4 
//   
x1=x1-x3+x4;  
x2=x2-x3*x4+x4*x4;  
x3=x1+2*x2+3*x3+4*x4; 
x4=x1-6*x3; 
printf("%ld %ld\n",x1+x2,x1*x2); 
return(0); 

// 
//  x <-  (x'-h(H^(-1)(x''),K(x)) 
// x'=(x1,x2)  x''=(x3,x4) 
//K(x) = (x1+2*x2+3*x3+4*x4,x1-6*x3) 

 Introduce an automorphism   and an inverse  of the state vectors by  

𝜑 = [

−4 − 𝑋2 − 2𝑋2𝑋4 − 2𝑋3𝑋4
𝑋4 − 𝑋1 − 𝑋3 + 1
4 + 𝑋2 + 2𝑋2𝑋4 + 2𝑋3𝑥4 − 𝑋4
1 + 𝑋4 − 𝑋1 − 2𝑋2 − 2𝑋3

]            

 𝜓 = [

1 − 2𝑌2 + 𝑌4 − 𝑌1 − 𝑌3
−𝑌1 − 4 − 2𝑌1𝑌4 + 2𝑌1𝑌2 − 2𝑌3𝑌4 + 2𝑌2𝑌3
𝑌1 + 4 − 𝑌4 + 𝑌2 + 2𝑌1𝑌4 − 2𝑌1𝑌2 + 2𝑌3𝑌4 − 2𝑌2𝑌3
−𝑌1 − 𝑌3

] 

Using this automorphism pair, encrypt the program P’.  The resulting program follows: 

int main() 
{ 

//E(P’), the encrypted version of P’ 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  long Y1 = 0, Y2 = 0, Y3 = 0, Y4 = 0, u1, u2, g1, g2; 
  int Y1new, Y2new, Y3new, Y4new; 

g2=rand(); 

  scanf("%ld %ld",&u1,&u2); 
  g1=rand(); 
  Y1new = Y1; 
  Y2new = -Y1-Y3-u1-g1+1+Y4-Y2; 
  Y3new = Y3; 
  Y4new = 1-Y1-Y3-u1-g1+2*Y4-2*Y2; 
  Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 
Y1new = -4-u2-g1*g2+2*u2*Y1+2*u2*Y3+2*g1*g2*Y1+2*g1*g2*Y3+2*Power(Y1, 
2)+2*Y1*Y3+8*Y1+8*Y3-2*Y1*Y4-2*Y3*Y4+2*Y1*Y2+2*Y2*Y3+4*Power(Y1, 
2)*Y4+8*Y1*Y4*Y3-4*Power(Y1, 2)*Y2-8*Y1*Y2*Y3+4*Power(Y3, 2)*Y4-
4*Y2*Power(Y3, 2); 
  Y2new = -Y1+Y2-u2-g1*g2-4-2*Y1*Y4+2*Y1*Y2-2*Y3*Y4+2*Y2*Y3; 
  Y3new = 4+u2+g1*g2-2*u2*Y1-2*u2*Y3-2*g1*g2*Y1-2*g1*g2*Y3-2*Power(Y1, 2)-
2*Y1*Y3-7*Y1-7*Y3+2*Y1*Y4+2*Y3*Y4-2*Y1*Y2-2*Y2*Y3-4*Power(Y1, 2)*Y4-
8*Y1*Y4*Y3+4*Power(Y1, 2)*Y2+8*Y1*Y2*Y3-4*Power(Y3, 
2)*Y4+4*Y2*Power(Y3, 2); 
  Y4new = -2*Y1+Y4-2*u2-2*g1*g2-8-4*Y1*Y4+4*Y1*Y2-4*Y3*Y4+4*Y2*Y3; 
  Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 
Y1new = -7*Y1+2*Y1*Y4-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3-2*Power(Y1, 2)-2*Y1*Y3-
8*Y3-4*Power(Y1, 2)*Y4-8*Y1*Y4*Y3+4*Power(Y1, 2)*Y2+8*Y1*Y2*Y3-
4*Power(Y3, 2)*Y4+4*Y2*Power(Y3, 2)+2*g1*Y1+2*g1*Y3+2*g2*Y1+2*g2*Y3; 
  Y2new = Y1+2*Y2-Y4+4+2*Y1*Y4-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3-g1-g2; 
  Y3new = -2*Y1*Y4+2*Y1*Y2-2*Y3*Y4+2*Y2*Y3+2*Power(Y1, 
2)+2*Y1*Y3+8*Y1+9*Y3+4*Power(Y1, 2)*Y4+8*Y1*Y4*Y3-4*Power(Y1, 2)*Y2-
8*Y1*Y2*Y3+4*Power(Y3, 2)*Y4-4*Y2*Power(Y3, 2)-2*g1*Y1-2*g1*Y3-2*g2*Y1-
2*g2*Y3; 
  Y4new = 2*Y1+2*Y2-Y4+8+4*Y1*Y4-4*Y1*Y2+4*Y3*Y4-4*Y2*Y3-2*g1-2*g2; 
  Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 
Y1new = Y1+2*Y1*Y4-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3+2*g2*Y4-2*g2*Y2; 
  Y2new = g2+Y2+Y1+Y3; 
  Y3new = -Y1-2*Y1*Y4+2*Y1*Y2-2*Y3*Y4+2*Y2*Y3-g2-2*g2*Y4+2*g2*Y2; 
  Y4new = g2+Y4+Y1+Y3; 
  Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new;  Y1new = Y1; 
  Y2new = 2*Y1+Y3+4+2*Y2-Y4+2*Y1*Y4-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3; 
  Y3new = Y3; 
  Y4new = 4+2*Y1+Y3+Y2+2*Y1*Y4-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3; 
  Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 

Y1new = -4*Y3-12*Power(Y1, 2)*Y2*Y3-12*Y1*Y2*Power(Y3, 

2)+12*Power(Y1, 2)*Y4*Y3+12*Y1*Y4*Power(Y3, 2)-8*Y1*Y4*Y3+8*Y1*Y2*Y3-
4*Power(Y1, 3)*Y2+10*Power(Y1, 2)*Y3+8*Y1*Power(Y3, 2)-4*Y2*Power(Y3, 
3)+4*Power(Y1, 3)*Y4+4*Power(Y3, 3)*Y4-Y1*Y2+4*Power(Y1, 2)*Y2-
Y2*Y3+13*Y1*Y3+4*Y2*Power(Y3, 2)+Y1*Y4+Y3*Y4-4*Power(Y1, 2)*Y4-

   
 
 
 
 
4*Power(Y3, 2)*Y4-3*Y1+4*Power(Y1, 3)+7*Power(Y3, 2)+2*Power(Y3, 
3)+6*Power(Y1, 2); 
  Y2new = -4*Y1-4*Y3+Y2-2*Power(Y1, 2)*Y4+2*Power(Y1, 2)*Y2-2*Power(Y3, 
2)*Y4+2*Y2*Power(Y3, 2)-Power(Y3, 2)-4*Y1*Y4*Y3+4*Y1*Y2*Y3-3*Y1*Y3-
2*Power(Y1, 2)-Y1*Y2+Y3*Y4-Y2*Y3+Y1*Y4; 
  Y3new = 5*Y3+12*Power(Y1, 2)*Y2*Y3+12*Y1*Y2*Power(Y3, 2)-12*Power(Y1, 
2)*Y4*Y3-12*Y1*Y4*Power(Y3, 2)+8*Y1*Y4*Y3-8*Y1*Y2*Y3+4*Power(Y1, 3)*Y2-
10*Power(Y1, 2)*Y3-8*Y1*Power(Y3, 2)+4*Y2*Power(Y3, 3)-4*Power(Y1, 3)*Y4-
4*Power(Y3, 3)*Y4+Y1*Y2-4*Power(Y1, 2)*Y2+Y2*Y3-13*Y1*Y3-4*Y2*Power(Y3, 
2)-Y1*Y4-Y3*Y4+4*Power(Y1, 2)*Y4+4*Power(Y3, 2)*Y4+4*Y1-4*Power(Y1, 3)-
7*Power(Y3, 2)-2*Power(Y3, 3)-6*Power(Y1, 2); 
  Y4new = -8*Y1-8*Y3+Y4-4*Power(Y1, 2)*Y4+4*Power(Y1, 2)*Y2-4*Power(Y3, 
2)*Y4+4*Y2*Power(Y3, 2)-2*Power(Y3, 2)-8*Y1*Y4*Y3+8*Y1*Y2*Y3-6*Y1*Y3-
4*Power(Y1, 2)-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3+2*Y1*Y4; 
  Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 

Y1new = 2*Y3+3*Y1-10*Power(Y3, 2)-20*Y1*Y3-10*Power(Y1, 2)-2*Y3*Y4-

2*Y1*Y4; 
  Y2new = 5*Y1+5*Y3+Y2+Y4-1; 
  Y3new = -Y3-2*Y1+10*Power(Y3, 2)+20*Y1*Y3+10*Power(Y1, 
2)+2*Y3*Y4+2*Y1*Y4; 
  Y4new = 10*Y1+10*Y3+3*Y4-2; 
  Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new;  Y1new = -
46*Y4+46*Y2+Y1+16*Power(Y2, 2)-30*Y2*Y4+14*Power(Y4, 
2)+48*Y1*Y4*Y2+12*Y1*Y2-24*Y1*Power(Y4, 2)-24*Y1*Power(Y2, 2)-
24*Y3*Power(Y4, 2)-24*Power(Y2, 2)*Y3+48*Y3*Y4*Y2-12*Y1*Y4; 
  Y2new = -23-7*Y2+7*Y4-6*Y1-12*Y1*Y4+12*Y1*Y2-12*Y3*Y4+12*Y2*Y3; 
  Y3new = 23+39*Y4-38*Y2+Y3+6*Y1-16*Power(Y2, 2)+30*Y2*Y4-14*Power(Y4, 2)-
48*Y1*Y4*Y2-24*Y1*Y2+24*Y1*Power(Y4, 2)+24*Y1*Power(Y2, 
2)+24*Y3*Power(Y4, 2)+24*Power(Y2, 2)*Y3+12*Y3*Y4-12*Y2*Y3-
48*Y3*Y4*Y2+24*Y1*Y4; 
  Y4new = -23-8*Y2+8*Y4-6*Y1-12*Y1*Y4+12*Y1*Y2-12*Y3*Y4+12*Y2*Y3; 
  Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 

printf("%ld %ld\n",-3-2*Y2+Y4-2*Y1-Y3-2*Y1*Y4+2*Y1*Y2-

2*Y3*Y4+2*Y2*Y3,-4+8*Y2+4*Y3-
4*Y4+6*Y1*Y4*Y2+6*Y3*Y4*Y2+4*Y1*Y4*Y3-4*Y1*Y2*Y3+4*Y1*Y2-
2*Y1^2*Y2+2*Y2*Y3+Y1*Y3-2*Y2*Y3^2-3*Y1*Y4-
2*Y3*Y4+2*Y1^2*Y4+2*Y3^2*Y4+3*Y1+Y1^2-4*Y1*Y2^2-4*Y2^2*Y3-2*Y1*Y4^2-
2*Y3*Y4^2); 
  return(0); 
} 

Remove the original input and output statements, which translate from the state variables of the 
program to the input and output variables and replace them with input and output statements 
written in the new state variables. This modification results in F(P). 

int main() 

//  F(P), another encypted version of P 

 
 
 
{ 

long Y1, Y2, Y3, Y4, Y1new, Y2new, Y3new, Y4new; 

scanf("%ld %ld %ld %ld",&Y1,&Y2,Y3,Y4); 
Y1new = Y1; 
Y2new = 2*Y1+Y3+4+2*Y2-Y4+2*Y1*Y4-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3; 
Y3new = Y3; 
Y4new = 4+2*Y1+Y3+Y2+2*Y1*Y4-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3; 
Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 

Y1new = -4*Y3-12*Power(Y1, 2)*Y2*Y3-12*Y1*Y2*Power(Y3, 2)+12*Power(Y1, 
2)*Y4*Y3+12*Y1*Y4*Power(Y3, 2)-8*Y1*Y4*Y3+8*Y1*Y2*Y3-4*Power(Y1, 
3)*Y2+10*Power(Y1, 2)*Y3+8*Y1*Power(Y3, 2)-4*Y2*Power(Y3, 3)+4*Power(Y1, 
3)*Y4+4*Power(Y3, 3)*Y4-Y1*Y2+4*Power(Y1, 2)*Y2-
Y2*Y3+13*Y1*Y3+4*Y2*Power(Y3, 2)+Y1*Y4+Y3*Y4-4*Power(Y1, 2)*Y4-4*Power(Y3, 
2)*Y4-3*Y1+4*Power(Y1, 3)+7*Power(Y3, 2)+2*Power(Y3, 3)+6*Power(Y1, 2); 

Y2new = -4*Y1-4*Y3+Y2-2*Power(Y1, 2)*Y4+2*Power(Y1, 2)*Y2-2*Power(Y3, 

2)*Y4+2*Y2*Power(Y3, 2)-Power(Y3, 2)-4*Y1*Y4*Y3+4*Y1*Y2*Y3-3*Y1*Y3-
2*Power(Y1, 2)-Y1*Y2+Y3*Y4-Y2*Y3+Y1*Y4; 

Y3new = 5*Y3+12*Power(Y1, 2)*Y2*Y3+12*Y1*Y2*Power(Y3, 2)-12*Power(Y1, 

2)*Y4*Y3-12*Y1*Y4*Power(Y3, 2)+8*Y1*Y4*Y3-8*Y1*Y2*Y3+4*Power(Y1, 3)*Y2-
10*Power(Y1, 2)*Y3-8*Y1*Power(Y3, 2)+4*Y2*Power(Y3, 3)-4*Power(Y1, 3)*Y4-
4*Power(Y3, 3)*Y4+Y1*Y2-4*Power(Y1, 2)*Y2+Y2*Y3-13*Y1*Y3-4*Y2*Power(Y3, 2)-
Y1*Y4-Y3*Y4+4*Power(Y1, 2)*Y4+4*Power(Y3, 2)*Y4+4*Y1-4*Power(Y1, 3)-7*Power(Y3, 
2)-2*Power(Y3, 3)-6*Power(Y1, 2); 

Y4new = -8*Y1-8*Y3+Y4-4*Power(Y1, 2)*Y4+4*Power(Y1, 2)*Y2-4*Power(Y3, 

2)*Y4+4*Y2*Power(Y3, 2)-2*Power(Y3, 2)-8*Y1*Y4*Y3+8*Y1*Y2*Y3-6*Y1*Y3-
4*Power(Y1, 2)-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3+2*Y1*Y4; 

Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 
Y1new = 2*Y3+3*Y1-10*Power(Y3, 2)-20*Y1*Y3-10*Power(Y1, 2)-2*Y3*Y4-

2*Y1*Y4; 

Y2new = 5*Y1+5*Y3+Y2+Y4-1; 
Y3new = -Y3-2*Y1+10*Power(Y3, 2)+20*Y1*Y3+10*Power(Y1, 

2)+2*Y3*Y4+2*Y1*Y4; 

Y4new = 10*Y1+10*Y3+3*Y4-2; 
Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new;  Y1new = -

46*Y4+46*Y2+Y1+16*Power(Y2, 2)-30*Y2*Y4+14*Power(Y4, 
2)+48*Y1*Y4*Y2+12*Y1*Y2-24*Y1*Power(Y4, 2)-24*Y1*Power(Y2, 2)-24*Y3*Power(Y4, 
2)-24*Power(Y2, 2)*Y3+48*Y3*Y4*Y2-12*Y1*Y4; 

Y2new = -23-7*Y2+7*Y4-6*Y1-12*Y1*Y4+12*Y1*Y2-12*Y3*Y4+12*Y2*Y3; 
Y3new = 23+39*Y4-38*Y2+Y3+6*Y1-16*Power(Y2, 2)+30*Y2*Y4-14*Power(Y4, 2)-

48*Y1*Y4*Y2-24*Y1*Y2+24*Y1*Power(Y4, 2)+24*Y1*Power(Y2, 2)+24*Y3*Power(Y4, 
2)+24*Power(Y2, 2)*Y3+12*Y3*Y4-12*Y2*Y3-48*Y3*Y4*Y2+24*Y1*Y4; 

Y4new = -23-8*Y2+8*Y4-6*Y1-12*Y1*Y4+12*Y1*Y2-12*Y3*Y4+12*Y2*Y3; 
Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 
printf("%ld %ld %ld %ld \n",Y1,Y2,Y3,Y4); 
return(0); 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
} 

The encryption for input into this program is provided by the translation from the original input 
variables into the new state variables. 

int main() 
{ 

//E, the encryption algorithm for F(P) 

long Y1, Y2, Y3, Y4, u1, u2, g1, g2; 
int Y1new, Y2new, Y3new, Y4new; 

g2=rand(); 

scanf("%ld %ld",&u1,&u2); 
g1=rand(); 
Y1new = Y1; 
Y2new = -Y1-Y3-u1-g1+1+Y4-Y2; 
Y3new = Y3; 
Y4new = 1-Y1-Y3-u1-g1+2*Y4-2*Y2; 
Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 
Y1new = -4-u2-g1*g2+2*u2*Y1+2*u2*Y3+2*g1*g2*Y1+2*g1*g2*Y3+2*Power(Y1, 

2)+2*Y1*Y3+8*Y1+8*Y3-2*Y1*Y4-2*Y3*Y4+2*Y1*Y2+2*Y2*Y3+4*Power(Y1, 
2)*Y4+8*Y1*Y4*Y3-4*Power(Y1, 2)*Y2-8*Y1*Y2*Y3+4*Power(Y3, 2)*Y4-
4*Y2*Power(Y3, 2); 

Y2new = -Y1+Y2-u2-g1*g2-4-2*Y1*Y4+2*Y1*Y2-2*Y3*Y4+2*Y2*Y3; 
Y3new = 4+u2+g1*g2-2*u2*Y1-2*u2*Y3-2*g1*g2*Y1-2*g1*g2*Y3-2*Power(Y1, 2)-

2*Y1*Y3-7*Y1-7*Y3+2*Y1*Y4+2*Y3*Y4-2*Y1*Y2-2*Y2*Y3-4*Power(Y1, 2)*Y4-
8*Y1*Y4*Y3+4*Power(Y1, 2)*Y2+8*Y1*Y2*Y3-4*Power(Y3, 2)*Y4+4*Y2*Power(Y3, 2); 

Y4new = -2*Y1+Y4-2*u2-2*g1*g2-8-4*Y1*Y4+4*Y1*Y2-4*Y3*Y4+4*Y2*Y3; 
Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new;  Y1new = -7*Y1+2*Y1*Y4-

2*Y1*Y2+2*Y3*Y4-2*Y2*Y3-2*Power(Y1, 2)-2*Y1*Y3-8*Y3-4*Power(Y1, 2)*Y4-
8*Y1*Y4*Y3+4*Power(Y1, 2)*Y2+8*Y1*Y2*Y3-4*Power(Y3, 2)*Y4+4*Y2*Power(Y3, 
2)+2*g1*Y1+2*g1*Y3+2*g2*Y1+2*g2*Y3; 

Y2new = Y1+2*Y2-Y4+4+2*Y1*Y4-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3-g1-g2; 
Y3new = -2*Y1*Y4+2*Y1*Y2-2*Y3*Y4+2*Y2*Y3+2*Power(Y1, 

2)+2*Y1*Y3+8*Y1+9*Y3+4*Power(Y1, 2)*Y4+8*Y1*Y4*Y3-4*Power(Y1, 2)*Y2-
8*Y1*Y2*Y3+4*Power(Y3, 2)*Y4-4*Y2*Power(Y3, 2)-2*g1*Y1-2*g1*Y3-2*g2*Y1-
2*g2*Y3; 

Y4new = 2*Y1+2*Y2-Y4+8+4*Y1*Y4-4*Y1*Y2+4*Y3*Y4-4*Y2*Y3-2*g1-2*g2; 
Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 
Y1new = Y1+2*Y1*Y4-2*Y1*Y2+2*Y3*Y4-2*Y2*Y3+2*g2*Y4-2*g2*Y2; 
Y2new = g2+Y2+Y1+Y3; 
Y3new = -Y1-2*Y1*Y4+2*Y1*Y2-2*Y3*Y4+2*Y2*Y3-g2-2*g2*Y4+2*g2*Y2; 
Y4new = g2+Y4+Y1+Y3; 
Y1 = Y1new; Y2 = Y2new; Y3 = Y3new; Y4 = Y4new; 

printf("%ld %ld %ld %ld\n",Y1,Y2,Y3,Y4); 

return(0); 

} 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Cryptoanalysis of this encryption function requires inverting a system of four equations in four 
unknowns, doable, but nontrivial. This problem would be more difficult if more random numbers 
were used.  The difficulty increases exponentially with the number of random numbers 
introduced. 

The new decryption algorithm is 

int main() 
{ 

long Y1, Y2, Y3, Y4; 

scanf("%ld %ld %ld %ld",&Y1,&Y2,&Y3,&Y4); 

printf("%ld %ld\n",-3-2*Y2+Y4-2*Y1-Y3-2*Y1*Y4+2*Y1*Y2-2*Y3*Y4+2*Y2*Y3,-
4+8*Y2+4*Y3-4*Y4+6*Y1*Y4*Y2+6*Y3*Y4*Y2+4*Y1*Y4*Y3-4*Y1*Y2*Y3+4*Y1*Y2-
2*Y1^2*Y2+2*Y2*Y3+Y1*Y3-2*Y2*Y3^2-3*Y1*Y4-
2*Y3*Y4+2*Y1^2*Y4+2*Y3^2*Y4+3*Y1+Y1^2-4*Y1*Y2^2-4*Y2^2*Y3-2*Y1*Y4^2-
2*Y3*Y4^2); 

return(0); 

} 

The resulting program is clearly more complex than the original, but by a manageable amount. 

 
 
 
 
 
 
 
 
