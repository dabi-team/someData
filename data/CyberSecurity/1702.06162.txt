Survey of Automated Vulnerability Detection and
Exploit Generation Techniques in Cyber Reasoning
Systems

1

Teresa Nicole Brooks
Computer Science Department
Seidenberg School of Computer Science and Information Systems
Pace University
New York NY
Email: tb93141n@pace.edu

Abstract—Software is everywhere, from mission critical systems
such as industrial power stations, pacemakers and even household
appliances. This growing dependence on technology and the
increasing complexity software has serious security implications
as it means we are potentially surrounded by software that
contain exploitable vulnerabilities. These challenges have made
binary analysis an important area of research in computer science
and has emphasized the need for building automated analysis
systems that can operate at scale, speed and efﬁcacy; all while
performing with the skill of a human expert. Though great
progress has been made in this area of research, there remains
limitations and open challenges to be addressed. Recognizing this
need, DARPA sponsored the Cyber Grand Challenge (CGC),
in
a competition to showcase the current state of
systems that perform; automated vulnerability detection, exploit
generation and software patching. This paper is a survey of
the vulnerability detection and exploit generation techniques,
underlying technologies and related works of two of the winning
systems Mayhem and Mechanical Phish.

the art

Keywords—Cyber reasoning systems, automated binary analysis,
automated exploit generation, dynamic symbolic execution, fuzzing

I.

INTRODUCTION
Technology touches every aspect of our lives, from the
mundane to mission critical systems that facilitate our very
way of life. These facts present clear economic, safety and
security concerns. These concerns are driving the need for
automated, scalable and reliable means of discovering, veri-
fying and patching exploitable defects. In an effort to drive
research in this area, DARPA sponsored the Cyber Grand
Challenge (CGC), a competition to showcase the current state
of the art in Cyber Reasoning Systems. These systems combine
various tools, techniques and expert knowledge to create fully
autonomous systems that perform automated vulnerability de-
tection, exploit generation and software patching in binary
software without human intervention. In this competition com-
peting systems play an “attack-defend” style of Capture The
Flag (CTF). CTF is “a head-to-head, networked competition”
where participants are to detect, patch and exploit software
defects [1].

A. Impact of DARPA’s Cyber Grand Challenge

In other areas of computer science research that involve the
development of intelligent systems, such as machine learn-
ing and artiﬁcial intelligence there is a wealth of common
datasets and corpora with corresponding benchmarks by which
researchers can evaluate the efﬁcacy of their approaches in a
platform and technology agnostic way. An example of such
is the “MNIST database of handwritten digits.”
a dataset
This dataset has a rich history of benchmarks and provides
a standard dataset for training neural networks and other
machine learning algorithms [2][3]. However, in the ﬁeld of
security research, speciﬁcally the areas of binary analysis such
datasets and benchmarks do not exist. This often means that
techniques are evaluated on different datasets (software) and
different platforms thus making it difﬁcult to compare the
effectiveness of different techniques [4].

DARPA’s Cyber Grand Challenge address this need for a
common platform and datasets by which to evaluate cyber
reasoning systems. CGC organizers designed binaries called
challenges that differ in complexity, ﬁle size and functionality.
These binaries are designed to present the same challenges of
real-world software to the systems analyzing them. This collec-
tion of binaries coupled with a Linux distribution designed for
the competition called DECREE OS, offers a standard platform
and dataset for all competitors to evaluate their systems. The
qualifying round results, binaries, environment, needed li-
braries and documentation have all been made freely available
online. This provides benchmarks and a common platform for
researchers to test the effectiveness of new analysis techniques
and systems [5].

Systems are judged based on security, availability and
evaluation. Patched binaries (challenge replacement binaries)
functionality is tested by running tests created by the CGC
organizers, the tests are in the form of proof of vulnerability
(POV). If no POVs are blocked their security score is 0.
Patched binaries are also rated on their overhead on system
resources such as memory, CPU usage and the ﬁle size. Table
I shows a summary of the scoring criteria for competing
systems. Note, systems that submit a working POV along
with their patched binary have their security score doubled

8
1
0
2

g
u
A
7

]

R
C
.
s
c
[

4
v
2
6
1
6
0
.
2
0
7
1
:
v
i
X
r
a

 
 
 
 
 
 
Criteria

Security

Availability

Evaluation

Rule
Each competitor can defend the code on it’s server,
keeping ﬂags safe. It can patch each challenge
binary using generic defenses or a custom patch
for each vulnerability ﬁnds.
Every pogrom on a server should function nor-
mally after being patched. it would be easy to
defend software if you could just disable all it’s
functionality. The reference checks that defended
software is responding correctly and hasn’t been
disabled or slowed.
Every player can program a vulnerability scanner.
Searching for vulnerabilities in opponents soft-
ware and proving these weaknesses to the referee.
A successful proof counts as a capture the ﬂag.

TABLE I.

SUMMARY OF CGC SCORING RULES [7]

[6]. Further note, the scoring algorithm suggests a stronger
emphasis on binary patching versus the number of exploitable
defects found by the competing systems [7].

The following sections of this paper explores offensive
capabilities, underlying technologies and related works of two
of the Cyber Grand Challenge winning systems Mayhem and
Mechanical Phish. It also presents proposed future areas of
research in the ﬁeld of offensive capabilities of automated
binary analysis systems.

II. BACKGROUND
Despite our best efforts software defects will always exist
and given the growing dependence on technology to manage
our daily lives, ensuring the safety, security and reliability of
software and hardware has become the primary focus of a
number of security researchers. Speciﬁcally, an emphasis as
been placed on binary software analysis, for the simple fact that
in many instances only the binaries are available for analysis.
This is particularly true when examining embedded ﬁrmware,
custom operating systems and maleware.

Binary analysis can be difﬁcult because we are missing
abstractions provided by programming languages such as data
types and data structures. These abstractions make it easier to
reason about how data and inputs drive the paths of execution.
Despite these challenges there are inherent advantages to
performing binary analysis. Binaries contain platform speciﬁc
details which are only available at execution time. Information
such as “memory layout, register usage and execution order”
[8] is important for detecting many common types of vul-
nerabilities such as memory corruption and buffer overﬂows.
For these reason and more, binary analyses a speciﬁc type of
program analysis is the focus of security researchers in recent
years and the volume of software to be examined as lead to a
strong interest in building automated binary analysis systems
that can examine binary software at scale.

Static, dynamic and concolic analysis (also known as dy-
namic symbolic analysis) are three common approaches to bi-
nary analysis. Each approach has it’s strengths and limitations
and each comes with their own set of design considerations that
must be addressed in order to meet the challenge of analyzing
real-world software. The following sections examine each of
these approaches; their limitations, strengths and the design

2

Fig. 1. Example of simple control ﬂow graph (adapted) [9]

considerations that must be addressed in order to implement
systems that perform automated vulnerability detection and
exploit generation effectively.

A. Design Considerations

One design consideration that must be addressed when
implementing automated vulnerability detection and exploit
generation systems, is ensuring the ability of the system to
replay or reproduce the program state (i.e. user input or data)
that triggered a vulnerability. The other consideration is the
system must understand semantically what part of a given input
caused the observed behavior. These design considerations
directly impact the scalability and validity of the results these
systems yield (i.e. vulnerabilities discovered). For example,
analysis techniques such as symbolic execution aims to have
high reproducibility and high semantic understanding but will
suffer from issues with scalability while approaches that favor
”re-playability” usually suffer from low code coverage [4].

B. Static Binary Analysis

Static binary analysis is the analysis of a binary without
running it. The process of static binary analysis typically
starts with loading and processing the binary to be analyzed.
The processing step includes parsing the binary, generating an
intermediate language representation of the binary’s assembly
instructions and building a control ﬂow graph (CFG). Control
ﬂow graphs represent paths that can be taken when a program
executes. The nodes of these graphs represent basic blocks of
machine instructions and the edges represent possible points of
control ﬂow changes between these nodes. Control ﬂow graphs
are a key component for automated vulnerability detection
systems that employ static binary analysis as it gives the system
a means of exploring all execution paths in an application.

1) Limitations Of Static Binary Analysis: Though this tech-
nique offers a system the ability to examine all possible pro-
gram paths, it comes at the cost of scalability and performance.
Static binary analysis can be slow, and it has limitations when
dealing with indirect jump statements. Indirect jump statements
are harder than direct jump statements to resolve when building
a CFG because the application is passing control to a target
whose value for example, could be arbitrarily calculated or
dependent on the context of application. To deal with these
limitations static binary analysis tools make approximations
about the control ﬂow of an application and hence run the
risk of not resolves indirect jump statements at all. Under ap-
proximations can lead to false positives for systems that detect
vulnerabilities or worse it could miss detecting vulnerabilities
due to incomplete control ﬂow graphs.

One static analysis technique that mitigates some of these
limitations is value-set analysis (VSA). The key to this al-
gorithm is it’s over approximation of values in memory, a
property that makes it useful in making assumptions about
targets of indirect
jump statements or read and writes in
memory. These properties enable VSA to be used to augment
CFGs with information about indirect jump statements [8].

C. Dynamic Binary Analysis

Unlike static binary analysis, dynamic binary analysis tech-
niques examines a program’s behavior while it is running in
a given environment. Dynamic binary analysis allows you to
explore individual paths which makes it very precise but at the
expense of less code coverage. Code coverage is an important
characteristic of vulnerability detection systems as the more
code you can examine the more likely you to are ﬁnd existing
vulnerabilities.

1) Concrete and Symbolic Execution: There are two ﬂavors
of dynamic binary analysis, concrete and symbolic execution.
Concrete execution refers to the representation and execution
of “concrete” or real values against a program, where as
symbolic execution refers to the representation and execution
of symbolic representations of a given value (i.e. a range of
values). In dynamic analysis systems, binaries and source code
are augmented with instrumentation [10], this instrumentation
provides metadata to enable the system make better choices
about things like choosing paths in an application to explore.
2) Fuzzing: The main objective of a system that detects
vulnerabilities is to ﬁnd inputs that make it perform an unsafe
operation (i.e. crash an application). Fuzzing is an example
of concrete execution and it is an important technique used
in systems where augmented input is used attempt to crash
the application for example. Though fuzzing is an important
technique in vulnerability detection it suffers from limitations.
Fuzzing tools usually requires manually created test cases to
seed the fuzzer, it then mutates it’s future inputs based on
these test cases. Standard fuzzing techniques usually fail to
randomly generated values for branches of logic that requires
very speciﬁc user input or context dependent data.

3

dynamic symbolic execution. In classical symbolic execution,
variables and application input (i.e. ﬁles, command line options
etc) are modeled using symbolically values instead of using
concrete values. During execution both memory and register
state are tracked and are also modeled symbolically. Symbolic
execution is typically used to dynamically generate test cases
which are used to drive path exploration, unlike traditional
fuzzing techniques where test cases must be manually gener-
ated to seed the system. Systems like Mayhem [11] and S2E
[12] were some of the ﬁrst to apply this technique to binary
code.

In dynamic symbolic execution input and variables are
represented as symbolic values instead of concrete values.
These values are used to generated path constraints. Path
constraints are logical formulas that represent “program state
and transformations between program state” [13]. Typically
these formulas represent previously unexplored paths of exe-
cution in a program and are used as input to a satisﬁability
modulo theory solver (SMT solver). The SMT solver uses
these formulas to derive new application inputs (test cases)
that drive the exploration of new paths in the application [13],
[14]. Because most programming constructs can be modeled
by theories supported by SMT solvers, they are often used in
tools that verify and test programs.

1) Limitations Of Dynamic Symbolic Execution: Dynamic
symbolic execution is so powerful because it can trigger
speciﬁc application states using learned path constraints, mak-
ing it an ideal technique for discovering vulnerabilities in
binary code [4]. This characteristic makes it a commonly
used technique in well known binary analysis tools such as
CUTE [15], Klee [16] and FuzzBALL [17]. However, dynamic
symbolic execution suffers from a problem known as path
explosion, where by new paths are created at every new
branch. This can lead to an exponential number of paths
to be explored and hence makes dynamic symbolic analysis
computationally expensive, hence limiting the scalability of
analysis systems that use this technique as it’s only mechanism
of path exploration.

A modern approach to combat these limitations is to com-
bine both concrete and symbolic execution, a technique known
concolic execution [18]. Another approach combines the use of
dynamic symbolic execution and fuzzing to create a “guided”
fuzzer [19] or assisted fuzzer. This technique uses dynamic
symbolic execution to drive path exploration by giving it the
task of augmenting input and feeding it back to the fuzzer.
The aim of this technique is to minimize the use of an
expensive operation such a dynamic symbolic execution, and
use cheaper operations such as fuzzing to get better code
coverage when exploring applications for vulnerabilities. This
technique is used by Driller [19], where by it selectively uses
dynamic symbolic execution to perform path exploration in
order to detect vulnerabilities. Driller is key component in the
Mechanical Phish Cyber Reasoning System [1], [19].

D. Dynamic Symbolic Execution

III. COMMONLY EXPLOITED VULNERABILITIES

A more powerful dynamic analysis technique that is imple-
mented in many automated vulnerability detection systems, is

Programming languages such as C/C++ allow developers
lower level control of memory allocations, which gives them

Type
Denial of Service
Execute Code
Overﬂow

Count
1847
1355
1221

TABLE II.

TOP 3 REPORTED VULNERABILITIES BY TYPE (2016) [20]

Type
Denial of Service
Execute Code
Overﬂow

Count
1784
1808
1072

TABLE III.

TOP 3 REPORTED VULNERABILITIES BY TYPE (2015) [20]

ﬁner grain control over application performance and efﬁciency.
This level of control allows can lead to security critical
vulnerabilities that can be exploited by attackers. Although
there are efforts to make software more secure and robust
with the implementation of techniques such as buffer overﬂow
detection and randomization of address space, vulnerabilities
such as buffer overﬂows are still in the top three vulnerabilities
reported in 2015 and 2016 [19][20]. Tables II and III shows
the number of reported vulnerabilities for the top three types
of vulnerabilities of 2015 and 2016.

Some of the most commonly found exploitable vulnerabil-
ities are buffer overﬂows, format string attacks and general
memory corruption vulnerabilities. These are defects that often
put an application in an unsafe state, where an attacker can
gain access to sensitive data or hijack the control ﬂow of an
application, in order execute code of their choice. It is for these
reasons why most automated vulnerability detection systems
seek to detect these types of vulnerabilities.

A. Buffer Overﬂows

Buffer overﬂows occurs when an applications writes more
data to a ﬁxed size buffer than it is allocated to handle. Typi-
cally these kind of vulnerabilities can lead to data corruption,
crashing applications, the unintended access of sensitive data
stored in memory or allowing an attacker to replace code in
the call stack with their own or a library call of their choice.

B. Format String Attacks

Format string attacks are used by attackers to execute
code or read data from the stack. This exploit occurs when
a formatted string given as an input is executed as like a
command. These kind of attacks often use the ANSI C printf,
fprintf and other string format functions as attack vectors [21].

C. General Memory Corruption

Buffer overﬂows are one example of memory corruption
vulnerability. Generally memory corruption occurs when data
in a previously allocated memory location is modiﬁed acciden-
tally or intentionally. The use of this corrupted data can lead
to application crashes. Other examples of memory corruption
are array index out of bounds errors, using an address before
memory is allocated or attempting to use a pointer that has
been freed already.

4

IV. MAYHEM

Mayhem is an automated system for discovering exploitable
vulnerabilities in binary code. It also ensures that each vul-
nerability is exploitable and veriﬁable by generating a “shell
spawning exploit” for each vulnerability it ﬁnds. By design
Mayhem seeks to addresses the challenges of real-world binary
analysis by ensuing that is can not only ﬁnd exploitable bugs
but do so efﬁciently. It does so by employing a technique
called hybrid symbolic execution. Mayhem introduces the
use of hybrid symbolic execution. Hybrid symbolic execution
combines the use of both ofﬂine and online symbolic execution
[11].

Hybrid symbolic execution leverages the strengths of online
and ofﬂine symbolic execution while minimizing the effects
of their limitations. While ofﬂine symbolic execution also
know as concolic execution allows a system to examine one
execution path at time while enabling it to select new paths to
explore via an iterative process, it has one major limitation. The
major limitation of ofﬂine symbolic execution is that in order to
ﬁnd new paths, the executor must run a single path of execution
twice once concretely and once symbolically. This re-execution
of previously explored paths makes this technique inefﬁcient
as it adds additional execution overhead to a system. On the
other hand online symbolic execution seeks to execute all paths
in a single run, and is does so by forking execution at each
branch. Although this approach ensures that the system would
never explore a path more than once, the constant forking could
lead to memory pressure as all application state is stored in
memory.

The following sections discusses Mayhem’s design, some
key implementation notes, contributions made by the re-
searchers as well as related work. Note, all information was
taken from the literature.

A. System Overview

The more of an application a vulnerability discovery tool
can explore the more likely it is to ﬁnd exploitable bugs. This
presents a major challenge for preforming binary analysis on
real-world applications, this can be especially true for common
off-the-shelf applications as they can be complex applications
with a very large state space to explore. This challenge is one
the key motivations behind Mayhem’s design.

Mayhem’s designers see exploring binary software as a
potentially long running process, this is a especially true for
running analysis on complex binaries. This means that the
system must be able to run for long periods of time while
taking care not to exhaust system resources in particular mem-
ory. System efﬁciency is also a motivation behind Mayhem’s
design. It addresses this by ensuring that no work is ever
repeated and that no work is thrown away, all results from
a previous analysis should be reusable on other runs [11].
Lastly, the key principal behind Mayhem’s ability to detect
vulnerabilities and generate corresponding exploits is that the
system must be able to identify where in symbolic memory a
load or store address depends on user input [11].

B. Architecture

Mayhem’s architecture is comprised of two major compo-
nents, a “Concrete Executor Client (CEC)“ and a “Symbolic
Executor Server (SES)“[11]. The SES is the brains of the op-
eration as it determines the next path the CEC should explore
and the CEC is the worker, it performs path exploration. The
CEC runs natively on the target system and the SES runs
independently on the platform’s system.

1) Concrete Executor Client (CEC): The CEC takes sym-
bolic input sources, the binary to be analysed and checkout
point data (optional) as input. Because symbolic execution
is slower than native (concrete) execution Mayhem seeks
to perform as much native execution as possible. The CEC
performs the task of loading and natively executing the binary
to be analysed. As the binary is executed the CEC adds instru-
mentation to the code, this instrumentation adds information
about execution state such as memory and register values. The
CEC also contains a taint tracker which performs taint based
analysis [22]. If the taint tracker in the CEC detects a condition
or jump statement it halts execution and passes this information
to the SES [11]. Note, the CEC will run until all execution
paths have been explored or a threshold is reached.

2) Symbolic Executor Server (SES): The SES takes the con-
crete, “tainted instructions” from the CEC. These instructions
can be tainted branch or tainted jump instructions. These in-
structions are converted from x86 assembly to an intermediate
language called BAP IL, by BAP. BAP is a binary analysis tool
that converts x86 assembly into an intermediate language [23].
The SES takes these interpreted instructions and executes them
symbolically. These instructions are used to build two types
of formals, path formulas which represents the constraints on
“each line of code” and exportability formulas, which are used
to determine if an attacker can execute a payload or gain
control of a pointer [11]. These formals are executed by an
SMT solver [14], which determines if the formula is satisﬁable.
To manage system resources Mayhem makes use of conﬁg-
urable resource caps and system generated checkpoints. If a re-
source cap is not reached and the SES receives a tainted branch
instruction, the SES queries the SMT solver to determine if
should fork execution. If it forks, a path selector prioritizes the
new forks and the SES alerts the CEC about the state change.
However, if a system resource cap has been reached then a
checkpoint manager generates a new checkpoint for the active
executor instead of forking new executors. Note, checkpionts
store symbolic execution state of the executor that has been
suspended as well as corresponding path constraints. Check-
point restoration basically uses the stored symbolic execution
state to restore the concrete execution state up to the point
where the corresponding executor was suspended. Checkpoint
restoration essentially puts system back into “online” mode.
Throughout the execution process the SES switches between
existing forked executors and checkpoints [11].

5

execution [24], which allows the user to provide “partial
speciﬁcation of the input” (i.e. input length, preﬁx etc) [11]
in order to minimize the search space. If no speciﬁcations are
supplied, all paths will be explored.

Mayhem uses heuristics to determine which path to explore
next. It favors paths that are more likely to have an exploitable
bug. Paths where symbolic memory accesses occur or symbolic
instruction pointers are identiﬁed as higher priority than paths
that are simply exploring new paths [11]. This priority ranking
rules directly correspond to the the types of vulnerabilities that
Mayhem (as of the time the initial literature was published)
can identify.

D. Handling Symbolic Memory

Being able to identify where in symbolic memory a load
or store address depends on user input is a necessity when
generating exploits. In order identify these addresses in sym-
bolic memory, a binary analysis system must be able to model
and reason about symbolic memory [11]. Modeling symbolic
memory is difﬁcult because the index used in the memory
look up is an expression instead of a number, this makes
dealing with symbolic indices difﬁcult because the index could
point to spot in memory. To tackle this problem Mayhem
implements “index-based memory modeling”. In this approach
memory is modeled as a map, and 32 bit indices are mapped to
expressions and only symbolic reads are modeled symbolically.
Mayhem uses immutable “memory objects,” to model sym-
bolic reads. These objects are created every time a symbolic
read is executed, and contain all possible values that the given
symbolic index can access. In order to create these objects
Mayhem must ﬁnd all possible values for a symbolic index.
In order to make this process more scalable it ﬁnds a range of
possible index values instead of trying to ﬁnd an exact index
value [11]. It uses an SMT solver to resolve this range of
values. Querying the SMT solver for a range of symbolic index
values is an expensive operation, so as an optimization step
Mayhem ﬁrst uses value-set analysis [8] to come up with an
approximate interval of possible index values, which is then
given to a SMT solve to reﬁne or “tighten“ the lower and upper
bounds [11].

E. Generating Exploits

Mayhem (as of the time the initial literature was published)
can identify and generate exploits for any “instruction-pointer
overwrite” and format string attacks. It generates an exporta-
bility formula whenever it’s exploitable properties are violated.
These properties are a symbolic tainted instruction pointer,
which corresponds to a buffer overﬂow and a symbolic format
string which corresponds with a format string attack [11].

F. Related Work

C. Minimizing Search Space and Path Selection

One major challenge of cyber reasoning systems is the
vast size of the execution path search space. To address this,
Mayhem also uses as technique called preconditioned symbolic

Mayhem’s approach to exploit discover and generation is
largely based on prior work by the researchers on AEG [24],
[11]. Unlike Mayhem, AEG used source code analysis to ﬁnd
exploitable bugs while using binary runtime information to
generate corresponding exploits. AEG was the ﬁrst system to

provide an end to end solution that not only detects exploitable
bugs but generates a veriﬁable exploit to conﬁrm that it is a
security risk. It’s approach to automatically generating exploits
addressed the issue that source code alone can not tell you if
a bug is exploitable. Source code though it provides useful
abstractions does not provide the same low level details that
are a necessity in determining if a bug can be exploited. AEG
also introduced the use of preconditioned symbolic execution
to minimize search space as well path prioritize heuristics [24].

V. MECHANICAL PHISH
Mechanical Phish is an open source Cyber Reasoning Sys-
tem written for the DARPA Cyber Grand Challenge [1]. It
leverages open source tools and is comprised of several com-
ponents that directly contribute to it’s approach to vulnerability
discovery and exploit generation. Mechanical Phish’s goal is
to discovery vulnerabilities deeper in binary code efﬁciently.
It does so by employing the use of a “guided” fuzzer which
combines the efﬁciency of fuzzing and concolic execution with
the power of dynamic symbolic execution.

The following sections discusses Driller and angr’s design,
some key implementation notes, contributions made by the
researchers as well as related work. Note, all information was
taken from the literature.

A. System Overview

Two important components that

implement Mechanical
Phish’s vulnerability discovery functionality are angr [4] and
Driller [19]. Driller is a “guided whitebox fuzzer” tool that
leverages the speed of fuzzing and the input reasoning ca-
pabilities of concolic execution in order to effectively and
efﬁciently discover deeper bugs. angr is an open source binary
analysis framework that Driller uses to implement it’s concolic
execution engine.

B. Driller

Driller’s primary objective is to ﬁnd bugs in the deeper
logic of any application. This objective is the motivation
for its approach of leveraging the strengths of fuzzing and
concolic execution it mitigates their weaknesses. Systems that
implement fuzzing or concolic execution alone, are limited
in the depth and the amount of code coverage because of
the inherent limitations of fuzzy and concolic execution [19].
Traditional fuzzing techniques are fast but fail to ﬁnd bugs
where speciﬁc input is required, while concolic execution is an
great tool to generate this kind of input it often suffers from the
path explosion problem. By combining these techniques Driller
can improve the scalability of concolic execution while also
improving the effectiveness of fuzzing. Unlike some systems
that only support discovery of speciﬁc types vulnerabilities,
Driller can detect any vulnerability that can lead to an appli-
cation crash.

The core motivation behind Driller’s design is that it views
the types of bugs that fuzzing and conconlic execution can
ﬁnd in terms of how an application processes input. It splits
the input processed by application into two categories, general

6

and speciﬁc. General input can represent a wide range of
valid values while speciﬁc input only can only have a small
number of valid values. This intuitively splits the application
into “compartments,“ where the speciﬁc input checks separate
one compartment from another. Because fuzzing is an effective
technique for generating values for general inputs it can be
used to explore application paths within a compartment, while
concolic execution would be best used to resolve inputs to
drive code execution between application compartments [19].
Driller is comprised of two major components, the fuzzer
and concolic execution engine. The bulk of the path explo-
ration work is ofﬂoaded onto the fuzzer as in most cases it
can explore a large number of execution paths on it’s own.
This leaves the concolic execution engine to solve for the more
complex inputs required by speciﬁc checks in an application.
1) The Fuzzer: The fuzzer component leverages very pop-
ular fuzzer called American Fuzzy Lop (AFL) [25]. AFL is
a state of the art fuzzer that generates input through the use
of a genetic algorithm. It uses instrumentation to make more
informed choices. Though instrumentation can be introduced
at compile time, Driller uses a “QEMU-backend“ [26] to
avoid the need for having source code. The bulk of the path
exploration work is ofﬂoaded onto the fuzzer. In most cases
it can explore large number of execution paths, and is much
faster than concolic exeuction.

2) Concolic Execution Engine: The concolic execution en-
gine uses angr [4] an open source binary analysis framework.
This engine, translates binary code into Valgrind’s VEX [27]
intermediate representation (IR). This IR is used to evaluate the
effects of application input on symbolic state. All values in the
symbolic state except constants are modeled as symbolic vari-
ables and as the program is executed “symbolic constraints”
are added to the symbolic variables. These constraints deﬁnes
the limit of possible values for a symbolic variable. Throughout
execution both concrete and symbolic values are tracked, these
values can be used by the constraint solver (SMT solver)
to ﬁnd values that satisfy the constraints on all symbolic
variables in the state [19]. Like Mayhem, Driller uses the
index-based memory model to model symbolic memory where
writes addresses are stored concretely and read addresses are
modeled symbolically [11].

When Driller starts it invokes the fuzzer component. The
fuzzer will explore the application until
it can no longer
generate inputs that drive execution down new paths. When
the fuzzer reaches this state Driller says the fuzzer is “stuck.”
More concretely the fuzzer is deemed stuck if after having
gone through a certain number of input mutations it fails to
progress to new paths. When the fuzzer is stuck, Driller takes
only the inputs the fuzzer marks as “interesting” and invokes
the concolic execution engine on them. Inputs are considering
interesting if the input triggers a state transition [19].

C. angr

angr [4] is an open source, platform agnostic binary analysis
framework,
implements a number of state of the art
offensive binary analysis techniques. This framework was
implemented to provide researchers a uniﬁed platform by

that

which they can evaluate and compare the effectiveness of these
techniques as well as components to implement and evaluate
new techniques.

1) Motivation: Many binary analysis techniques are devel-
oped as research prototypes and are typically not available to
the public. This often means that future researchers have to
start from scratch in order to implement and evaluate these
techniques themselves [4]. angr was created to mitigate this
issue, by creating an open source, binary analysis framework
that implements the state of the art offensive binary analysis
techniques. The framework also offers a modular design that
allows researchers to easily combine different approaches in
a effort to leverage their strengths while minimizing their
weaknesses.

angr is implemented as collection of Python libraries. The
libraries provide functionality for performing various binary
analysis techniques:

• Loading a binary
• Disassembly and intermediate-representation lifting
• Program instrumentation
• Symbolic execution
• Control-ﬂow analysis
• Data-dependency analysis
• Value-set analysis (VSA)

D. angr Submodules

angr’s primary design goals are to offer cross-architecture
support, cross-platform support, support for different analy-
sis techniques, and usability. With these goals in mind the
researchers that created angr wanted to create a system that
would allow users to recreate any common binary analysis
technique in about a week. In order accomplish these goals,
the analysis engine was carefully designed to be a modular set
of software components with strict separations between them.
This design allows for the mixing and converting between
analyses on-the-ﬂy [4].

The sections below provide a brief summary of some key

submodules implemented in angr.

1) CLE: CLE is angr’s binary loading module. It can
support loading binaries from POSIX-compliant systems such
as Linx, FreeBSD, Windows as well as DECREE OS which
was created by DARPA for the Cyber Grand Challenge.

2) Intermediate Representation:: In order to support anal-
ysis binaries in a architecture agnostic way it is necessary to
convert binary code into an intermediate representation. The
module that supports IR in angr leverages libVEX and uses a
python library called PyVex to expose libVEX’s VEX IR in
python. PyVex, was originally written for Firmalice [28]. VEX
allows angr to support analysis both “32-bit and 64-bit versions
of ARM, MIPS, PPC, and x86 (with the 64-bit version of the
latter being amd64) processors” [4].

3) SimVex: Functionality for representing representing and
modifying program state is implemented in the SimVex mod-
ule. State (SimState) in angr is represented by collection of
“state“ plugins. These state plugins provide the building blocks
for implementing different types of binary analysis. These
plugins expose functionality for; tracking values of registers,

7

implementing symbolic memory modeling, implementing ab-
stract memory modeling, logging, debugging, providing an
interface for interacting with SMT solvers, and exposing
architecture speciﬁc information that is useful for analysis.

4) Claripy: Claripy is the module responsible for provide
abstractions that represent values stored in SimState. Claripy
internally represents these values as expressions that can be
translated to the data domains of various supported Claripy
back-ends. Claripy supports back-ends for concrete domains,
symbolic domain and value-set abstraction domain for value-
set analysis.

5) Program Analysis: angr implements complete analysis
for techniques such a dynamic symbolic execution and control-
ﬂow graph recovery. It exposes an entry point that allows users
to easily access all things related to the analysis, such as the
binary being analyzed and exposes functionality of various
submodules.

6) Other Key System Components: This section is a brief
discussion of other key software components of angr. Note,
all documentation below was obtained from the Mechanical
Phish github repository [29].

• Rex: Rex is an automated exploitation engine that was
originally implemented for the Cyber Grand Challenge.
As of the time of writing this paper the engine can crash
triaging, crash exploration, and exploitation for certain
kinds of crashes. Rex is freely available on github [30]
• Meister: Meister is the task scheduler for Mechanical

Phish.

• Scriba: Scriba decides what exploits and replaceable

binaires (CGC patched binaries) to submit.

• The Ambassador: The Ambassador talks to the CGC
API to retrieve challenge binaries, submit proof of
vulnerabilities, etc.

E. Minimizing Search Space and Path Selection

To avoid the problem of path explosion in the concolic ex-
ecution engine, Driller implements “pre-constrained tracing.”
Pre-constrained tracing ensures that the only path that is being
analyzed is the path that represents the application’s processing
of a given input [19].

VI. COMPARE & CONTRAST

This survey explored the current state of the art offensive
capabilities implemented in Cyber Reasoning Systems. It used
two of the winning systems, Mayhem and Mechanical Phish
of DARPA’s Cyber Grand Challenge as a vehicle to explore
these techniques in action. The original motivation for this
survey was to investigate the similarities and differences of
these two systems with the aim of identifying what sets
them apart and which approaches worked best for solving the
various problems that must be addressed in order to build an
automated system that can successfully detect exploitable bugs
and generating exploits for these bugs. This section provides
a brief discussion of some key differences between Mayhem
and Mechanical Phish.

A. Path Explosion

Mayhem and Mechanical Phish both leverage dynamic
symbolic execution in order to drive path exploration but their
approaches to mitigating the problem of path explosion are
different. Dynamic symbolic execution is a popular technique
for discovering vulnerabilities in binary code, and it works well
ﬁnding both both complex and simple inputs to drive path
exploration. However, dynamic symbolic execution suffers
from a well known problem of path explosion, where by
new paths are created at every new conditional branch. This
can lead to an exponential number of paths to be explored
and hence makes dynamic symbolic analysis computationally
expensive and can limit the scalability of analysis systems that
use this technique as its only mechanism of path exploration.
Hence, any system looking to employ this technique must
address the problem of path explosion.

1) Hybrid Symbolic Execution: Mayhem’s uses dynamic
symbolic execution as its primary mechanism of implement-
ing path exploration. In order to combat the path explosion
problem, it implements hybrid symbolic execution. Hybrid
symbolic execution allows the system to switch between online
and ofﬂine symbolic execution. Its ability to context switch
between ofﬂine and online executors allows it to use to the
most appropriate mechanism whenever a conﬁgurable resource
cap is reached. This allows Mayhem to technical have it’s cake
and eat it too, as it can leverage a powerful method of path
exploration without succumbing to it’s limitations.

2) Augmenting A Fuzzer With Symbolic Execution: Mechan-
ical Phish uses Driller to help with path exploration. Driller’s
approach to avoiding the pitfall of symbolic execution by using
it’s fuzzer to perform the bulk of path exploration and only
leveraging symbolic execution when the fuzzer “gets stuck”
or in other words fails to generate an input that can drive path
exploration forward. The key to this approach is it’s use of
pre-constrained tracing which ensures that the only path that
is being analyzed is the path that represents the application’s
processing a given input [19].

VII. PROPOSED FUTURE RESEARCH

This section will brieﬂy discuss some proposed areas of

future research.

A. Binary Pre-processing To Minimize Search Space For Large
& Complex Applications

One critical limitation of even the state of the art auto-
mated Cyber Reasoning Systems, is that they are not ﬁt for
performing analysis on large, complex real-world applications
[31]. In many ways binary analysis can be viewed as an
uninformed search problem, that when coupled with tools like
instrumentation it evolves into an informed search problem.
The search space for large, complex applications can be vast
and systems that are seeking to effectively perform analysis on
such applications at scale, must ﬁnd even more effective ways
(than the current state of the art) to minimize the search space.
Minimizing the search space leads to be better code coverage
which enables analysis tools to ﬁnd defects deeper in code.

8

With the above issue in mind, I propose exploring creating
a system that can performing binary pre-processing, with the
purpose of identifying application “hot spots.” Hot spots are
areas in an application where exploitable bugs are likely to
exist. These hot spots would split an application into regions.
Information regarding these hot spot regions, path constraints
and other metadata, would act as a map or guide to that area
in the code. This information would be given along with the
corresponding binary to a vulnerability detection system, and
this system would use this metadata and path constraints to
make it’s way directly to the hot spot region. Once the system
reaches this region, it would perform binary analysis as normal.
This pre-processing step could make vulnerability detection an
even more informed search problem, and by splitting software
into regions it would give less code to reason about at one
time during the vulnerability detection phase.

B. Generating Exploits From Common Vulnerabilities and
Exposures Reports (CVEs)

A human security analyst or attacker has the ability to read
a Common Vulnerabilities and Exposures report (CVE) and
build exploits for the reported vulnerability. They are lever-
aging not only the knowledge supplied in the CVE, they are
also leveraging their historic knowledge and past experience
to generate an exploit for the reported vulnerability. I propose
exploring the feasibility of creating a knowledge based system
that
leverages the analysis capabilities of state of the art
vulnerability discovery and exploit generation tools to learn
the common characteristics of exploits and vulnerabilities.
This system would take these learned insights and attempt to
generate a generic exploit for a given common vulnerability
report. This would create a system that doesn’t require the
source code or binary code to generate test cases (exploits) for
a given vulnerability it would only need the binary or source
code to verify the test cases it generates.

C. Deep Reinforcement Learning For Vulnerability Discovery
Cyber reasoning systems are expert systems that encapsulate
the actions and knowledge of a human analyst in an automated
system that can detect exploitable bugs, generate veriﬁable
exploits, and patch software. Binary code shares similar char-
acteristics as a board or world in a video game, as they
both are subject to state changes based on user deﬁned input
and interactions. Research in the ﬁeld of deep reinforcement
learning has proven that an intelligent software agent is capable
of learning and excelling at complex tasks [32]. I propose
exploring the feasibility of combining the use of traditional
binary analysis system with deep reinforcement learning to
create an AI agent that can learn to discover vulnerabilities in
binary code.

VIII. CONCLUSION
Cyber reasoning systems are expert systems that seek to
encapsulate the actions and knowledge of a human analyst in
an automated system that can detect exploitable bugs, generate
veriﬁable exploits, and patch software. These systems are

9

[17] L. Martignoni, S. McCamant, P. Poosankam, D. Song, and P. Maniatis,
“Path-Exploration Lifting : Hi-Fi Tests for Lo-Fi Emulators,” Proceed-
ings of the 17th international conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS), pp. 337–
348, 2012.

[18] C. Cadar and K. Sen, “Symbolic execution for software testing: three
decades later,” Communications of the ACM, vol. 56, no. 2, pp. 82–90,
2013.

[19] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting
Fuzzing Through Selective Symbolic Execution,” Ndss, no. February,
pp. 21–24, 2016.
“CVE Details
https://www.cvedetails.com/vulnerabilities-by-types.php
“OWASP - Format string attack.” [Online]. Available: https://www.
owasp.org/index.php/Format{ }string{ }attack

- Vulnerabilities By Type.” [Online]. Available:

[21]

[20]

[22] E. J. Schwartz, T. Avgerinos, D. Brumley, E. J. Schwartz, T. Avgerinos,
and D. Brumley, “All You Ever Wanted to Know About Dynamic Taint
Analysis Forward Symbolic Execution ( but might have been afraid to
ask ) A Few Things You Need to Know About Dynamic Taint Analysis
Forward Symbolic Execution ( but might have been afraid to ask ) The
Root,” pp. 1–5, 2010.

[23] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz, “BAP: A binary
analysis platform,” in Lecture Notes in Computer Science (including
subseries Lecture Notes in Artiﬁcial Intelligence and Lecture Notes in
Bioinformatics), vol. 6806 LNCS, 2011, pp. 463–469.

[24] B. L. T. H. Thanassis Avgerinos, Sang Kil Cha and D. Brumley,

“Automatic Exploit Generation (AEG),” 2012.

[25] AFL, “Technical ”whitepaper” for aﬂ-fuzz.” [Online]. Available:

http://lcamtuf.coredump.cx/aﬂ/technical{ }details.txt

[26] F. Bellard, “QEMU , a Fast and Portable Dynamic Translator,” USENIX
Annual Technical Conference. Proceedings of the 2005 Conference on,
pp. 41–46, 2005.

[27] N. Nethercote and J. Seward, “Valgrind: A Framework for Heavyweight
Dynamic Binary Instrumentation,” ACM Sigplan Notices, vol. 42, no. 6,
pp. 89–100, 2007.

[28] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna,
“Firmalice - Automatic Detection of Authentication Bypass Vulnerabil-
ities in Binary Firmware,” Proceedings 2015 Network and Distributed
System Security Symposium, no. February, pp. 8–11, 2015.
“mechaphish github repository.” [Online]. Available: https://github.
com/mechaphish/mecha-docs
“Rex - Automated Exploitation Engine.” [Online]. Available: https:
//github.com/shellphish/rex

[29]

[30]

[31] B. D. Brumley, “Why CGC Matters to Me,” 2016. [Online]. Available:
https://blog.forallsecure.com/2016/07/26/why-cgc-matters-to-me/
[32] V. Mnih, K. Kavukcuoglu, D. Silver, A. a. Rusu, J. Veness, M. G.
Bellemare, A. Graves, M. Riedmiller, A. K. Fidjeland, G. Ostrovski,
S. Petersen, C. Beattie, A. Sadik, I. Antonoglou, H. King, D. Kumaran,
D. Wierstra, S. Legg, and D. Hassabis, “Human-level control through
deep reinforcement learning,” Nature, vol. 518, no. 7540, pp. 529–533,
2015. [Online]. Available: http://dx.doi.org/10.1038/nature14236

complex and require expert knowledge of the problem to build
them. Though there are still many open problems that need to
be addressed in order for Cyber reasoning systems to be able
to reason about real-world complex applications, the current
state of the art systems prove that it is very possible to build
automated systems that can perform automated vulnerability
detection, exploit generation and software patching in binary
software without human intervention.

REFERENCES

[1] DARPA,

“Cyber Grand Challenge.”

[Online]. Available: https:

//www.cybergrandchallenge.com/

[2] Y. LeCun, C. Cortes, and C. J. Burges, “THE MNIST DATABASE
of handwritten digits.” [Online]. Available: http://yann.lecun.com/exdb/
mnist/

[3] Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner, “Gradient-Based

Learning Applied to Document Recognition,” 1998.

[4] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna,
“[ANGR-SP16] (State of) The Art of War: Offensive Techniques in
Binary Analysis.”

[5] DARPA,

“Cyber Grand Challenge GitHub Repository &
https://github.com/

Available:

Competitor
CyberGrandChallengehttps://cgc.darpa.mil/

[Online].

Portal.”

[6] D. Brumley, J. Davis, R. Goulden, and T. Nighswander, “Unleashing
the Mayhem CRS,” 2016. [Online]. Available: https://blog.forallsecure.
com/2016/02/09/unleashing-mayhem/

[7] DARPA, “DARPA Cyber Grand Challenge: CQE Scoring Document,”
[Online]. Available: https://cgc.darpa.mil/CQE{ }

pp. 1–5, 2014.
Scoring.pdf

[8] G. Balakrishnan, T. Reps, D. Melski, and T. Teitelbaum, “WYSINWYX:
What you see is not what you execute,” Lecture Notes in Computer
Science (including subseries Lecture Notes in Artiﬁcial Intelligence and
Lecture Notes in Bioinformatics), vol. 4171 LNCS, pp. 202–213, 2008.
[9] L. Copeland, “A Practitioner’s Guide to Software Test Design.” Artech

House, 2004, ch. 10, p. 300.

[10] N. Nethercote, “Dynamic Binary Analysis and Instrumentation or
Building Tools is Easy,” Ph.D. dissertation, Trinity College, 2004.
[11] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing
Mayhem on binary code,” Proceedings - IEEE Symposium on Security
and Privacy, pp. 380–394, 2012.

[12] V. Chipounov, V. Kuznetsov, and G. Candea, “S2E : A Platform for
In-Vivo Multi-Path Analysis of Software Systems,” Asplos, vol. 46, pp.
1–14, 2011.

[13] N. Bjorner and L. D. Moura, “Satisﬁability Modulo Theories: Intro-
duction and Applications,” Communications of the ACM, pp. 69–77,
2011.

[14] Y. Li, A. Albarghouthi, Z. Kincad, A. Gurﬁnkel, M. Chechik, Z. Kin-
caid, A. Gurﬁnkel, and M. Chechik, “Symbolic optimization with SMT
solvers,” Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages - POPL ’14, pp. 607–618,
2014.

[15] K. Sen, D. Marinov, G. Agha, K. Sen, D. Marinov, and G. Agha,
“CUTE: A concolic unit testing engine for C,” 10th European software
engineering conference and 13th ACM SIGSOFT international sympo-
sium on Foundations of software engineering (ESEC/FSE’05), vol. 30,
no. 5, p. 263, 2005.

[16] C. Cadar, D. Dunbar, and D. R. Engler, “KLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems
Programs,” Proceedings of the 8th USENIX conference on Operating
systems design and implementation, pp. 209–224, 2008.

