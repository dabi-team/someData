2
2
0
2

r
a

M
2
2

]

R
C
.
s
c
[

3
v
1
7
6
0
1
.
3
0
1
2
:
v
i
X
r
a

1

Wisecr : Secure Simultaneous Code
Dissemination to Many Batteryless
Computational RFID Devices

Yang Su, Michael Chesser, Yansong Gao, Alanson P. Sample and Damith C. Ranasinghe

Abstract—Emerging ultra-low-power tiny scale computing devices run on harvested energy, are intermittently powered, have limited
computational capability, and perform sensing and actuation functions under the control of a dedicated ﬁrmware operating without the
supervisory control of an operating system. Wirelessly updating or patching ﬁrmware of such devices is inevitable. We consider the
challenging problem of simultaneous and secure ﬁrmware updates or patching for a typical class of such devices—Computational
Radio Frequency Identiﬁcation (CRFID) devices. We propose Wisecr , the ﬁrst secure and simultaneous wireless code dissemination
mechanism to multiple devices that prevents malicious code injection attacks and intellectual property (IP) theft, whilst enabling remote
attestation of code installation. Importantly, Wisecr is engineered to comply with existing ISO compliant communication protocol
standards employed by CRFID devices and systems. We comprehensively evaluate Wisecr ’s overhead, demonstrate its
implementation over standards compliant protocols, analyze its security, implement an end-to-end realization with popular CRFID
devices and open-source the complete software package on GitHub.

Index Terms—RFID, Computational RFID, WISP, ISO 18000-63 Protocol, EPC Protocol, Secure Wireless Firmware Update.

1 INTRODUCTION

The maturation of energy-harvesting technology and ultra-
low-power computing systems is leading to the advent of
intermittently-powered, batteryless devices that operate en-
tirely on energy extracted from the ambient environment [1].
The batteryless, low cost simplicity and the maintenance
free perpetual operational life of these tiny scale computing
platforms provide a compelling proposition for edge devices
in the Internet of Things (IoT) and Cyber-Physical Systems.
Recent developments in tiny scale computing devices
such as Wireless Identiﬁcation and Sensing Platform (WISP)
[2], MOO [3] and Farsens Pyros [4], or so called Compu-
tational Radio Frequency Identiﬁcation (CRFID) devices, are
highly resource limited,
intermittently-powered, battery-
less and operate on harvested RF (radio-frequency) energy.
CRFID type devices are more preferable in scenarios that
are challenging for traditional battery-powered sensors, for
example, pacemaker control and implanted blood glucose
monitoring [5] as well as domains where batteries are
undesirable, for example, wearables for healthcare appli-
cations [6]. While, signiﬁcant industrial applications are
exempliﬁed by asset management, such as monitoring and
maintenance in the aviation sector [7]–[10].

Despite various embodiments, the fundamental archi-
tecture of those devices include: microcontrollers, sensors,
transceivers, and, at times actuators, with the most signiﬁ-

• Y. Su, M. Chesser and D. C. Ranasinghe are with Auto-ID Lab, School
of Computer Science, The University of Adelaide, Australia. (yang.su01,
michael.chesser, damith.ranasinghe)@adelaide.edu.au

• Y. Gao is with School of Computer Science and Engineering, Nanjing
University of Science and Technology, China. yansong.gao@njust.edu.cn

• A. P. Sample is with Electrical Engineering and Computer Science,

University of Michigan, USA. apsample@umich.edu

• We acknowledge support from the Australian Research Council Discovery
Program (DP140103448). We also acknowledge support from the National
Natural Science Foundation of China (62002167) and National Natural
Science Foundation of JiangSu (BK20200461).

(cid:70)

cant component, the code or software imparting the devices
with the ability to communicate and realize interactive
tasks [11], [12]. Consequently, the update and patching of
this ﬁrmware is inevitable. In the absence of standard proto-
cols or system level support, ﬁrmware is typically updated
using a wired programming interface [3], [13]. In practical
applications, the wired interface results in a potential attack
vector to tamper with the behavior of the devices [14] and a
compromised device can be further hijacked to attack other
networked entities [15]. Disabling the wired interface after
the initial programming phase at manufacture can prevent
further access. But, leaves the wireless update option as
the only method to alter the ﬁrmware or to re-purpose the
devices post-manufacture.

Fig. 1. (a) An attacker may: i) commit a malicious code injection attack
such as alter code to inject bugs or load unauthorized code; ii) attempt
to prevent a new ﬁrmware installation and spoof the acknowledgment
signal of a successful update; and iii) commit IP theft by exploiting the
insecure wireless channel. (b) A typical device architecture where the
amount of power available for harvesting decreases exponentially with
distance d from a powering source.

However, point-to-point communications protocols over lim-
ited bandwidth communication channels characteristic of RFID
systems poses problems for rapid and secure update of
ﬁrmware over a wireless interface, post-manufacture. No-
tably, Federal Aviation Administration (FAA) in the United
States has granted the installation of RFID tags and sensors
on airplanes in 2018 [16], an increasing number of CRFID
sensors are integrated with small aircraft and commercial
airliners for maintenance history logging [7] and aircraft

Host and RFIDreader (Server)AttackerBatterylessdevicesIP theftIncomplete firmwareinstallationMaliciouscode injectionMicrocontroller(load)ImpedancematchingPowerharvesterEnergybufferRegulatorRFantennaA typical device  operating on harvested energy (a)(b)Available power: 
 
 
 
 
 
health monitoring [9]. In such a scenario, a high-efﬁciency
(simultaneous) and secure ﬁrmware update is desirable to
ensure operational readiness and ﬂight safety.

The recent Stork [7] protocol addressed the challenging
problem of fast wireless ﬁrmware updates to multiple CR-
FID devices. But, as illustrated in Fig. 1, Stork allows any
party, authorized or not, armed with a simple RFID reader
to: i) mount malicious code injection attacks; ii) attempt to
spoof the acknowledgment signal of a successful update to
fool the Server; and iii) steal intellectual property (IP) by
simply eavesdropping on the over-the-air communication
channel. Although a recent protocol [17] addressed the prob-
lem of malicious code injection attacks where by a single
CRFID device is updated in turn, it neither supports simul-
taneous updates to many devices nor protects ﬁrmware IP
and lacks a mechanism to validate the installation of code
on a device.

Why Secure Wireless Firmware Update is Challenging?

Constructing a secure wireless ﬁrmware update mechanism
for ultra-low power and batteryless devices is non-trivial;
designing a secure method is challenging. We elaborate on
the challenges below.

Fig. 2. The distribution of available clock cycles (top) and corresponding
time (bottom) before brownout—exhaustion of available energy under
computational load—for the open hardware and open software CRFID,
WISP5.1LRG [13] built with a MSP430 microcontroller. We executed a
message authentication code as the computational load and the device
location is increased from 40 cm to 60 cm above a powering source—
RFID reader antenna. We can observe that available MCU clock cycles and
operational time periods before state loss are limited per charging-brownout
cycle.

Limited and indeterminate powering. Energy-harvesting
systems operate intermittently, only when energy is avail-
able from the environment. To operate, a device gradually
buffers energy into a storage element (capacitor). Once
sufﬁcient energy is accumulated, the device begins oper-
ations. However, energy depletes more rapidly (e.g. mil-
liseconds) during an operation compared to energy accu-
mulation/charging (e.g. seconds). Further, energy accumu-
lation in RF energy harvesting is sacriﬁced in backscatter
communication links since a portion of the incident energy
is reﬂected back during communications. Therefore, power
failures are common and occur in millisecond time scales [7], [18],
[19] as experimentally validated in Fig. 2.

Timing of power loss events across devices are ad-
hoc. For example, harvested energy varies under differing
distances; therefore, a computation task may only execute
partially before power failure and it is hard to predict when
it will occur.

Further, saving and subsequently retrieving state at code
execution checkpoints for a long-run application via an
intermittent execution model [20] is not only: i) costly in

2

terms of computations and energy [21]—saving state in non-
volatile memories such as Flash or Electrically Erasable Pro-
grammable Read-Only Memory (EEPROM) consumes more
energy than static RAM (SRAM) whilst reading state from
Ferroelectric Random Access Memory (FRAM) consumes
more energy than writing as we demonstrate in Fig. 5; but
also: ii) renders a device in a vulnerable state for an attacker
to exploit when checkpoint state is stored on an off-chip
memory, due to the lack of internal MCU memory, where
non-invasive contact probes can be used to readout contents
when the memory bus used is easily accessible [22]. For
example, common memory readout ports such as the I2C
(Inter-Integrated Circuit) bus used by a microcontroller for
connecting to external memory devices are often exposed
on the top layer of a printed circuit board (PCB). Hence,
the content stored in an off-chip NVM can be easily read
out using contact probes without any damage to the hard-
ware [23].

These issues make the execution of long-run security
algorithms, such as Elliptic Curve Difﬁe-Hellman (ECDH)1
key exchange, difﬁcult to deploy securely.

Consequently, power must be carefully managed to
avoid power loss and leaving the device in a potentially
vulnerable state; and, we must seek computationally efﬁ-
cient security schemes.

Unavailability of hardware security support. Highly
resource-constraint devices lack hardware security support.
Thus, security features, including a trusted execution en-
vironment (TEE)—for example, ARM Trustzone [26]—and
dedicated memory to explicitly maintain the secrecy of a
long term secret keys, as in [27], are unavailable.

Constrained air interface protocols.
The widely used
wireless protocol for Ultra High Frequency (UHF) RFID
communication only provides insecure unicast communica-
tion links and supports no broadcast features or device-to-
device communication possible in mesh networking typical
of wireless sensor networks.

Unavailability of supervisory control from an operating
system. Unlike wireless sensor network nodes, severely re-
source limited systems, such as CRFID, do not operate
under the supervisory control of an operating system to
provide security or installation support for a secure dissem-
ination scheme.

1.1 Our Study

We consider the problem of secure and simultaneous code
dissemination to multiple RF-powered CRFID devices op-
erating under constrained protocols, device capability, and
extreme on-device resource limitations—computing power,
memory, and energy.

The scheme we developed overcomes the unique chal-
lenges, protects the ﬁrmware IP during the dissemination

1. We are aware of optimized public key exchange implementations such as
ECDH and Ring-LWE [24], [25]; however, they are impractical for passively
powered resource-constrained devices. For example, ECDH [24] with Curve25519
still requires 4.88 million clock cycles on a MSP430 MCU. In contrast, there are
a very limited number of clock cycles available from harvested-energy before
energy depletion [17], [18]—e.g. 400,000 clock cycles expected even at close
proximity of 50 cm from an energy source, see Fig. 2—and there is very limited
time available for computations where a CRFID must reply before strict air
interface protocol time-outs are breached.

405060Operational range (cm)2040Brownout MCU clock cycles (x100,000)0101800.51010180101860Time beforeProbabilityBrownout (ms)process, prevents malicious code injection attacks and en-
ables remote attestation of code installation. More speciﬁ-
cally, we address the following security threats:

• Malicious code injection: code alteration, loading unautho-
rized code, loading code onto an unauthorized device,
and code downgrading.

• Incomplete ﬁrmware installation
• IP theft: reverse engineering from plaintext binaries.

Consequently, we fulﬁl the urgent and unmet security
needs in the existing state-of-the-art multiple CRFID wire-
less dissemination protocol—Stork [7].

1.2 Our Contributions and Results

Contribution 1 (Section 2)—Wisecr is the ﬁrst secure and
simultaneous (fast) ﬁrmware dissemination scheme to
multiple batteryless CRFID devices. Wisecr provides three
security functions for secure and fast updates: i) preventing
malicious code injection attacks; ii) IP theft; and iii) attes-
tation of code installation. Wisecr achieves rapid updates by
supporting simultaneous update to multiple CRFID devices
through a secure broadcasting of ﬁrmware over a standard
non-secure unicast air interface protocol

Contribution 2 (Section 3 & 4)—A holistic design trajec-
tory, from a formal secure scheme design to an end-
to-end implementation requiring only limited on-device
resources. Ultra-low power operating conditions and on-
device resource limitations demand both a secure and an
efﬁcient scheme. First, we built an efﬁcient broadcast ses-
sion key exchange exploiting commonly available hardware
acceleration for crypto on microcontroller units (MCUs).

Second, to avoid power loss and thus achieve uninter-
rupted execution of a ﬁrmware update session, we propose
new methods: i) adaptive control of the execution model
of devices using RF powering channel state information
collected and reported by ﬁeld deployed devices; ii) reduc-
ing disruptions to broadcast data synchronization across
multiple devices by introducing the concept of a pilot tag
selection from participating devices in the update scheme
to drive the protocol. These methods avoid the need for
costly, secure checkpointing methods and leaving a device
in a vulnerable state during power loss.

Third, in the absence of an operating system, we develop
an immutable bootloader to: i) supervise the control ﬂow
of the secure ﬁrmware update process; ii) minimize the
occurrence of power loss during an update session whilst
abandoning a session in case an unpreventable power loss
still occurs; and iii) manage the secure storage of secrets by
exploiting commonly available on-chip memory protection
units (MPUs) to realize an immutable, bootloader-only ac-
cessible, secrets.

Contribution 3 (Section 4 and Appendix B)—ISO Standards
compliant end-to-end Wisecr implementation. We de-
velop Wisecr from speciﬁcation, component design to ar-
chitecture on the device, and implementation. We eval-
uate Wisecr extensively, including comparisons with cur-
rent non-secure methods, and validate our scheme by an
end-to-end implementation. Wisecr is a standard compli-
ant secure ﬁrmware broadcast mechanism with a demon-
strable implementation using the widely adopted air in-
terface protocol—ISO-18000-63 protocol albeit the proto-

3

col’s lack of support for broadcasting or multi-casting—
and using commodity devices from vendors. Hence, the
Wisecr scheme can be adopted in currently deployed sys-
tems. We demonstrate the ﬁrmware dissemination process
here https://youtu.be/GgDHPJi3A5U.

Contribution 4—Open source code release.
The tool
sets and end-to-end implementation is open-sourced on
GitHub: https://github.com/AdelaideAuto-IDLab/Wisecr.

Paper Organization. Section 2 presents the threat model,
security requirements and Wisecr design; Section 3 details
how the demanding security requirements are met under
challenging settings; Section 4 discusses our end-to-end im-
plementation, followed by performance and security evalu-
ations; Section 5 discusses related work with which Wisecr
is compared. Section 6 concludes this work.

2 Wisecr DESIGN

In this section, we describe the threat model including a
summary of notations in Table 1, followed by details of
Wisecr design, and then proceed to identify the minimal
hardware security requirements needed to implement the
scheme.

S

T
DB

TABLE 1. Table of Notations

Server S is a single entity consisting of a host computer
and a networked RFID reader.
Tokens T is a set of individual (CRFID) devices Ti.
Server’s database, where each element is a three-tuple
describing each CRFID token: i) the unique and im-
mutable identiﬁcation number idi; ii) the device speciﬁc
secret key k; and iii) a ﬂag denoting a device requiring
an update valid.

ﬁrmware The new ﬁrmware binary for the update.
ﬁrmware(j)The jth block of the ﬁrmware.
nver

ver
sk
s
c, r
(cid:3)(cid:48)

(cid:3)i

(cid:104)(cid:3)(cid:105)

The new version number (a monotonically increasing
ordinal number with a one-to-one correspondence with
each updated ﬁrmware).
A token’s current version number.
The broadcast session key.
The MAC tag computed by the Server.
Attestation challenge and response, respectively.
An apostrophe denotes a value computed by a different
entity, e.g., s(cid:48) the MAC tag computed by a Token.
A subscript i denotes a speciﬁc entity, e.g., ki is the
device key of the ith Token.
Encrypted data, e.g. (cid:104)ski(cid:105) denotes the encrypted session
key sk, with the ith token’s key ki.
A cryptographically secure random number generator.

RNG()
SKP.Enc() Symmetric Key Primitive encryption function described
by (cid:104)m(cid:105) ← SKP.Encsk(m). Here, the plaintext m is
encrypted with the sk to produce the ciphertext (cid:104)m(cid:105).

SKP.Dec() Symmetric Key Primitive decryption function where

MAC()

SNIFF()

PAM()

Query

m ← SKP.Decsk((cid:104)m(cid:105)).
Message Authentication Code function. By append-
ing an authentication tag s to the message m, where
s ← MACk(m), a message authentication code (MAC)
function can verify the integrity and authenticity of the
message by using the symmetric key k.
The voltage Vti established by the power harvester
within a ﬁxed time t from boot-up at token i, is mea-
sured by SNIFF() described by Vti ← SNIFF(t).
Family of functions employed by the Power Aware
Execution mode of operation proposed for the token to
mitigate power-loss (brown-out) events.
We denote EPC Gen2 commands using typewriter fonts.

2.1 Threat Model

Communication with an RFID device operating in the
UHF range is governed by the widely adopted ISO-18000-
63:2015—also known as the EPCglobal Class 1 Generation
2 version 2 (C1G2v2)—air interface protocol or simply the
EPC Gen2.

Fig. 3. (a) System overview. (b) Control/data ﬂow over the EPC Gen2
air interface. Firmware update will take place once a device enters
the Access state and by implementing Wisecr over Access command
speciﬁcations such as Authenticate.

Fig. 3 illustrates the communication channels in a net-
worked RFID system. The RFID reader resides at the edge of
the network and is typically connected to multiple antennas
to power and communicate with RFID or CRFID devices
energized by the antennas. The reader network interface is
accessed by using a Low-Level Reader Protocol (LLRP) from
a host machine. Communication with an RFID device oper-
ating in the UHF range is through the EPC Gen2 protocol.

Our focus is on the insecure communication channel
between the RFID reader connected antenna and the CRFID
transponder or token Ti ∈ T . Hence, we assume that the
communication between a host and a reader is secured
using standard cryptographic mechanisms [28]. Therefore,
a host computer and a reader are considered as a single
entity, the Server, denoted as S (a detailed execution of an
EPC Gen2 protocol session to singulate a single CRFID device
from all visible devices in the ﬁeld can be found in [7], [18]).
We assume a CRFID device can meet the pragmatic
hardware security requirements, detailed in Section 2.3. Fur-
ther, after device provisioning, the wired interface for pro-
gramming is disabled—using a common technique adopted
to secure resource-constrained microcontroller based de-
vices [17], [19]. Subsequently, both the trusted party and
adversary A must use the wireless interface for installing
new ﬁrmware on a token.

Building upon relevant adversary models related to
wireless ﬁrmware update for low-end embedded de-
vices [29], [30], we assume an adversary A has full control
over the communication channel between the Server S
and the tokens T . Hence, the adversary A can eavesdrop,
manipulate, record and replay all messages sent between the
Server S and the tokens T . This type of attacker is referred
to as an input/output attacker [31].

We assume the ﬁrmware (application), potentially pro-
vided by a third party in the form of a stripped binary,
may contain vulnerabilities or software bugs that can cause
the program to deviate from the speciﬁed behavior with
potential consequences being corruption of the bootloader
and/or the non-volatile memory (NVM) contents. Such an
occurrence is possible when ﬁrmware is frequently written
in unsafe languages such as C or C++ [32], [33]. Hence, the

4

ﬁrmware (application) cannot be trusted. In this context,
similar to [29], [30], we also assume that the adversary
cannot bypass any of the memory hardware protections
(detailed in Section 2.3) and an adversary cannot mount
invasive physical attacks to extract the on-chip non-volatile
memory contents. Such an assumption is practical, espe-
cially in deeply embedded applications such as pacemaker
control [18] where wireless update is the only practical
mechanism by which to alter the ﬁrmware and physical
access is extremely difﬁcult.

As in [34], we also assume the adversary A cannot
mount implementation attacks against the CRFID, or gain
internal variables in registers, for example, using invasive
attacks and side-channel analysis. We do not consider De-
nial of Service (DoS) attacks because it appears to be im-
possible to defend against such an attacker, for example,
that disrupts or jams the wireless communication medium
in practice [29].

2.2 Wisecr Update Scheme

Wisecr enables the ability to securely distribute and update
the ﬁrmware of multiple CRFID tokens, simultaneously.
Given that a Server S must communicate with an RFID
device T using EPC Gen2, Wisecr is compatible with EPC
Gen2 by design. Generally, our scheme can be implemented
after the execution of the anti-collision algorithm in the
media access control layer of the EPC Gen2 protocol, where
a reader must ﬁrst singulate a CRFID device and obtain
a handle, RN 16, to address and communicate with each
speciﬁc device. After singulating a device, the server can
employ commands such as: BlockWrite, Authenticate,
SecureComm and TagPrivilege speciﬁed in the EPC
Gen2 access command set [35], to implement the Wisecr
scheme. We describe the update scheme in Fig. 4 and defer
the details of our scheme implemented over the EPC Gen2
protocol to the Appendix B.

As described in Table 1, the Server S maintains a
database DB of provisioned tokens, issues the new ﬁrmware
and the corresponding version number (nver).

Each token Ti has a secure storage area provisioned with:
i) an idi, the immutable identiﬁcation number; ii) ki, the
device speciﬁc secret key stored in NVM that is read-only
accessible by the immutable bootloader. The ki assigned to
different devices are assumed to be independent and identi-
cally distributed (i.i.d.); iii) veri, the token’s current ﬁrmware
version number. The secure storage area is only accessible
by the trusted and immutable bootloader provisioned on the
device; this region is inaccessible to the ﬁrmware (applica-
tion) and therefore cannot be modiﬁed by it.

We describe a dissemination session in four stages:
i) Prelude; ii) Security Association; iii) Secure Broadcast; and
iv) Validation. An update can be extended with an optional,
v) Remote Attestation to verify the ﬁrmware installation.

STAGE 1: Prelude (Ofﬂine). In this stage, the Server S
undertakes setup tasks. The Server uses RNG() to generate
a broadcast session key (sk).

The new ﬁrmware is divided into segments—or
block; each block j is encrypted as (cid:104)ﬁrmware(j)(cid:105) ←
SKP.Encsk(ﬁrmware(j)), where (cid:104)ﬁrmware(j)(cid:105) denotes the
encrypted ﬁrmware block j. The division of ﬁrmware is
necessary as the narrow band communication channel and

EPC Gen2HostReaderCRFID devicesNetworkReaderCRFIDSingulationQuery/QueryRepRN16ACKEPCAccessReq_RNHandleAuthenticateReplyEPC Gen2BlockWriteReplySecureCommReply(a)(b)Low Level Reader Protocol(LLRP)Server S
DB = (idi, ki, veri) for i = 1...m Tokens
ﬁrmware, nver

sk ← RNG()
ﬁrmware = (ﬁrmware(1)(cid:107)...(cid:107)ﬁrmware(n))
(cid:104)ﬁrmware(j)(cid:105) ← SKP.Encsk(ﬁrmware(j)), for j = 1...n

Prelude

5

Tokens T = {T1...Tm}

idi, ki

for each Token Ti ∈ T

if idi /∈ DB then reject and abort
else si ← MACki(ﬁrmware(cid:107)veri(cid:107)nver)

(cid:104)ski(cid:105) ← SKP.Encki(sk)
(tLPMi, tactivei) ← PAM.Get(Vti)

Simultaneously broadcast the new ﬁrmware
to all Tokens Ti ∈ T

for each Token Ti ∈ T

if veri == nver then update successful

for each Token Ti ∈ T

Security Association
idi do, veri, Vti
←−−−−−−−−−

Vti ← SNIFF(t)

(cid:104)ski(cid:105), si, nver, tLPMi, tactivei
−−−−−−−−−−−−−−−−−−−−→ sk ← SKP.Decki((cid:104)ski(cid:105))

Secure Broadcast
(cid:104)ﬁrmware(1)(cid:105)
−−−−−−−−−−−−→
. . .
(cid:104)ﬁrmware(n)(cid:105)
−−−−−−−−−−−−→

Validation

idi, veri
←−−−−−−−
Remote Attestation

PAM.Enter(tLPMi, tactivei)
ﬁrmware(j) ← SKP.Decsk((cid:104)ﬁrmware(j)(cid:105)), for j = 1, ..., n
ﬁrmware = (ﬁrmware(1)(cid:107)...(cid:107)ﬁrmware(n))

s(cid:48)
i ← MACki(ﬁrmware(cid:107)veri(cid:107)nver)
PAM.Exit()
if si == s(cid:48)

i then accept and apply update

veri ← nver
else reject and abort

sk ← RNG(), c ← RNG(), (cid:104)ski(cid:105) ← SKP.Encki(sk)
M ← memory segment size to attest
r ← MACsk(c(cid:107)selected segment (ﬁrmware)(cid:107)idi(cid:107)veri)

(cid:104)ski(cid:105), c, elaborate, M
−−−−−−−−−−−−−−−→ sk ← SKP.Decki((cid:104)ski(cid:105))

if r == r(cid:48) then Attestation successful else failure

r(cid:48)
←−−−−
Fig. 4. Wisecr: The proposed wireless, secure and simultaneous code dissemination scheme to multiple tokens. Notably, the functions SNIFF() and
PAM() facilitate the secure and uninterruptible execution of an update session. A single symmetric key cipher SKP can be exploited in practice to
realise all of the primitives needed, including the MAC() function, to address the demands of a resource limited setting.

r(cid:48) ← MACsk(c(cid:107)selected segment (ﬁrmware)(cid:107)idi(cid:107)veri)

the EPC Gen2 protocol does not allow arbitrary size payloads
to be transmitted to a token.

STAGE 2: Security Association.
In this stage, the Server
S distributes the broadcast session key (sk) to all tokens
T and builds a secure broadcast channel over which to
simultaneously distribute the ﬁrmware to multiple tokens.
More speciﬁcally, each token in the energizing ﬁeld of
the Server responds with idi, Vti and veri. The token will
not be included in the following update session if: i) the
idi of the responding token is not in Server’s DB; or ii) the
token is not scheduled for an update (validi == False).
For tokens selected for an update, the Server computes a
MAC tag si ← MACki (ﬁrmware||veri||nver). In practice,
we cannot assume that each token is executing the same
version of the ﬁrmware, therefore a token speciﬁc MAC tag
is generated over the device speciﬁc key whilst the ﬁrmware
is encrypted with the broadcast session key.

The Server establishes a shared session key with each
token Ti by sending (cid:104)ski(cid:105), where (cid:104)ski(cid:105) ← SKP.Encki (sk)
and ki is speciﬁc to the ith token, and nver. The (cid:104)ski(cid:105) and
si are transmitted to each token Ti. Each token decrypts
the broadcast session key sk ← SKP.Decki ((cid:104)ski(cid:105))—thus, all
tokens selected for an update now possess the session key.

Notably, as detailed in Section 3.2.2, each token mea-
sures its powering channel state or its ability to harvest
energy by measuring the voltage Vti established by the
power harvester within a ﬁxed time t from boot-up, as
Vti ← SNIFF(t) to transmit to the Server. There are two
important reasons for measuring Vti. First, to facilitate
the power aware execution model (PAM) employed to
mitigate power-loss at a given token. The Server uses the

reported Vti to control the execution model of the ith
token. Speciﬁcally, the reported Vti is used by the Server
to determine the length of time that a token dwells in low
power mode (LPM) tLMPi and active mode tactivei when
executing computationally intensive tasks in the Secure
Broadcast and Validation stages; here, the server determines
(tLPMi, tactivei ) ← PAM.Get(Vti). Second, the Server uses
the reported Vti to realize the Pilot-Observer Mode of opera-
tion where one token is elected based on its Vti, termed the
Pilot, to control the ﬂow in the Secure Broadcast stage by
responding to server commands as detailed in Stage 3.

STAGE 3: Secure Broadcast.
In this stage, the encrypted
ﬁrmware blocks (cid:104)ﬁrmware(1..n)(cid:105) are broadcasted; and each
token stores the new encrypted ﬁrmware blocks in its
application memory region (Segment M deﬁned in Sec-
tion 3.1). Once the broadcast is completed, each token starts
ﬁrmware decryption and validation. The (cid:104)ﬁrmware(cid:105) is
decrypted using the session key sk as ﬁrmware(j) ←
SKP.Decsk((cid:104)ﬁrmware(j)(cid:105)).

To realize a secure and power efﬁcient logical broadcast
channel under severely energy constrained settings, we use
the Pilot-Observer mode. Herein, all tokens, except the Pilot
token elected by the Server, enters into an observer mode.
The tokens in the observer mode silently listen and store
encrypted data disseminated by the server; the Pilot token
performs the same operation whilst responding to the server
commands. We employ two techniques within the Pilot-
Observer Mode to mitigate power-loss and to achieve a
secure broadcast to tokens: i) disabling energy consuming
communication command reply from observers; and ii) the

concept of electing a Pilot CRFID device to drive the update
session as detailed in Section 3.2.2.

Notably, the techniques described in Stage 2 and 3 form the
foundation for the uninterrupted execution of the bootloader to
ensure security and enhance the performance of the ﬁrmware
dissemination under potential power-loss events.

STAGE 4: Validation. In this stage, ﬁrmware is validated
before installation. More precisely, a token speciﬁc MAC
tag s(cid:48)
i ← MACki(ﬁrmware||veri||nver) is computed by
each token Ti. If the received MAC tag si matches the device
computed s(cid:48)
i , the integrity of the ﬁrmware established and
the issuing Server is authenticated by the token. Subse-
quently, the new ﬁrmware is updated and the new version
number nver is stored as veri. Otherwise, the ﬁrmware is
discarded and the session is aborted. Notably, the EPC Gen2
protocol provides a reliable transfer feature. Each broadcast
payload is protected by a 16-bit Cyclic Redundancy Check
(CRC-16) error detection method. Hence, the notiﬁcation
of a CRC failure to the Server results in the automatic re-
transmission of the packet by the Server. Therefore, a MAC
tag mismatch is more likely to be adversarial and discarding
the ﬁrmware is a prudent action. At stage completion, each
token switches from the observer or Pilot to the normal mode
of operation after a software reset (reboot). Subsequently, all
the temporary information such as session key sk and the
token speciﬁc MAC tag s(cid:48)
i in volatile memory will be erased.
Once the ﬁrmware is installed, the Server is acknowl-
edged with the status of each participating token in the
session. This is achieved by performing an EPC Gen2 hand-
shake after a reboot of the tokens, and comparing the ver-
sion number veri reported from each token speciﬁed by idi
to the new ﬁrmware version number nver expected from
the token. If the veri is up-to-date, the Server is acknowl-
edged that the token Ti has been successfully updated.
Remark. It is theoretically possible to include a MAC tag in
the acknowledgment message at the end of the Validation
stage to authenticate the acknowledgment. But the imple-
mentation of this in practice is difﬁcult under constrained
protocols and limited resources typical of intermittently
powered devices. This is indeed the case with the EPC Gen2
air interface protocol and CRFID devices we employed. We
discuss speciﬁc reasons in Appendix B where we detail
implementation of the Wisecr Update Scheme over the EPC
Gen2 air interface protocol.

STAGE 5 (Optional): Remote Attestation.

The Server can elect to verify the ﬁrmware installation
on a token by performing a remote attestation; a mechanism
for the Server to verify the complete and correct software
installation on a token. Considering the highly resource
limited tokens, we propose a lightweight challenge response
based mechanism re-using the MAC() function developed
for Wisecr. The server sends a randomly generated challenge
c ← RNG() and evaluates the corresponding response r(cid:48) to
validate the installation. We provision a new session key sk
to enable the remote attestation to proceed independent of
the previous stages, whilst avoiding the derivation of a key
on device to reduce the overhead of the attestation routine.
We propose two modes of attestation; a fast mode and
an elaborate mode to trade-off veracity of the veriﬁcation
against computational and power costs. The fast mode only
examines the token serial number (idi) and the version

number (veri). While the elaborate mode traverses over an
entire memory segment. The elaborate mode is relatively
more time consuming but allows the direct veriﬁcation of
the code installed on the target token Ti.

6

We illustrate (in Fig. 4) and demonstrate (in Sec-
tion 4.5) the elaborate mode (more veracious and com-
putationally intensive) where response r(cid:48) ← MACsk
(c(cid:107)selected segment
the
application memory segment containing the installed
ﬁrmware. In contrast, the fast method computes the re-
sponse as r(cid:48) ← MACsk(c(cid:107)idi(cid:107)veri).

(ﬁrmware)(cid:107)idi(cid:107)veri)

attests

2.3 Token Security Requirements and Functional
Blocks

Our design is intentionally minimal and requires the follow-
ing security blocks.
Immutable Bootloader (Section 3.1) We require a static
NVM sector Mrx that is write-protected to store the
executable bootloader image to ensure the bootloader
can be trusted post deployment where, for example,
ﬁrmware (application) code vulnerabilities or software
bugs do not lead to the corruption of the bootloader
and the integrity of the bootloader can be maintained.
Secure Storage (Section 3.1) To store a device speciﬁc se-
cret, e.g., ki, we require an NVM sector M read-only
accessible by the immutable bootloader in sector Mrx.
This ensures the integrity and security of non-volatile
secrets post deployment since the ﬁrmware (applica-
tion) code cannot be trusted, for example, due to poten-
tial vulnerabilities or software bugs that can lead to the
corruption of non-volatile memory contents).

Uninterruptible Bootloader Execution (Section 3.2) Dur-
ing the execution of the bootloader stored in sector Mrx,
execution cannot be interrupted until the control ﬂow
is intentionally released by the bootloader.

Efﬁcient Security Primitives (Section 3.3) The update
scheme requires: i) a symmetric key primitive; and ii)
a keyed hash primitive for the message authentication
code that are both computationally and power efﬁcient.
In Section 3 we discuss how the associated functional
blocks are engineered on typical RF-powered devices built
with ultra-low power commodity MCUs.

3 ON-DEVICE SECURITY FUNCTION ENGINEERING

To provide comprehensive evaluations and demonstrations,
we selected the WISP5.1LRG [13] CRFID device with an
open-hardware and software implementation for our to-
ken T . This CRFID device uses the ultra-low power MCU
MSP430FR5969 from Texas Instruments. Consequently, for a
more concrete discussion, we will refer to the WISP5.1LRG
CRFID and the MSP430FR5969 MCU in the following.

3.1 Immutable Bootloader & Secure Storage

For resource limited MCUs, several mechanisms—detailed
in the Appendix A—exists for implementing secure storage:
i) Isolated segments; ii) Volatile keys; iii) Execute only mem-
ory; and iv) Runtime access protections. We opt for achiev-
ing secure storage and bootloader immutability using Run-
time Access Protection by exploiting the MCU’s memory

protection unit (MPU), which offers ﬂexibility to the boot-
loader. In particular, the MPU allows read/write/execute
permissions to be deﬁned individually for memory seg-
ments at power-up—prior to any ﬁrmware (application)
code execution. Wisecr requires the following segment per-
missions to be deﬁned by the bootloader to prevent their
subsequent modiﬁcations through application code by lock-
ing the MPU:
Segment M is used as the secure storage area. During
application execution, any access (reading/writing) to
this segment results in an access violation, causing the
device to restart in the bootloader.

Segment Mrx contains the bootloader, device interrupt vec-
tor table (IVT), shared code (e.g., EPC Gen2 implemen-
tation). During application execution, writing to this
segment results in an access violation.

Segment Mrwx covers the remaining memory, and is used

for application IVT, code (ﬁrmware) and data.

3.2 Uninterruptible Bootloader Execution

The execution or control ﬂow of the bootloader on the token
must be uninterruptible by application code and power-
loss events to meet our security objectives but dealing with
brownout induced power-loss events is more challenging.
Power loss leaves devices in vulnerable states for attackers
to exploit; therefore, we focus on innovative, pragmatic
and low-overhead power-loss prevention methods. Our ap-
proach deliberately mitigates the chances of power-loss. In
case a rare power-loss still occurs, the token will discard all
state—including security parameters such as the broadcast
session key; subsequently, the Server will re-attempt to up-
date the ﬁrmware by re-commencing a fresh update session
with this token. We detail our solution below.

3.2.1 Managing Application Layer Interruptions

The bootloader must be uninterruptible (by application
code) for security considerations. For instance, the ap-
plication code—due to an unintentional software bug or
otherwise—could interrupt the bootloader while the device
key is in a CPU register, so that the application code (ex-
ploited by an attacker) can copy the device key to a location
under its control, or completely subvert access protections
by overriding the MPU register before it is locked.

Recall, the memory segment Mrx (see Section 3.1) in-
cludes the memory region containing the IVT. This ensures
that only the bootloader can modify the IVT. Since the IVT is
under the bootloader’s control, we can ensure that any non-
maskable interrupt is unable to be directly conﬁgured by the
application code, whereas all other interrupts are disabled
during bootloader execution. Consequently, the interrupt
conﬁguration cannot be mutated by application code.

3.2.2 Managing Power-Loss Interruptions

Frequent and inevitable power loss during the bootloader
execution will not only interrupt the execution, degrading
code dissemination performance but also compromise se-
curity. Although intermittent computing techniques relying
on saving and retrieving state at check-points from NVM—
such as Flash or EPPROM—is possible, these methods im-
pose additional energy consumption and introduce security
vulnerabilities revealed recently [22].

7

Confronted with the complexity of designing and im-
plementing an end-to-end scheme under extreme resource
limitations, we propose an on-device Power Aware execu-
tion Model (PAM) to: i) avoid the overhead of intermittent
computing techniques; and ii) enhance security without
saving check-points to insecure NVM.

We observe that only a limited number of clock cycles
are available for computations per charge and discharge
cycle (Intermittent Power Cycle or IPC) of a power har-
vester, as illustrated via comprehensive measurements in
Fig. 2. Further, the rate of energy consumption/depletion
is faster than energy harvesting. We recognize that there
i) (CPU) energy
are three main sources of power-loss:
required for function computation exceeding the energy
supply capability from the harvester; ii) (FRAM.R/W) mem-
ory read/write access such as in executing Blockwrite
commands; and iii) (RFID) power harvesting disruptions
from communications—especially for backscattering data in
response to EPC Gen2 commands.

Fig. 5. Impact of four key device tasks on power-loss: CPU (compu-
tations); FRAM.R/W (memory read/write accesses); and RFID (com-
munications). The data above are collected by using special ﬁrmware.
The power-loss event is captured by monitoring through a GPIO pin.
We conduct 10 repeated measurements and report the mean time
before power-loss. The plot provides a lateral comparison among four
operations. The data is measured from a single CRFID device with
oscilloscope probes attached to measure the device’s internal state.

To understand the severity of these four causes, we mea-
sure the maximum time duration before brownout/power-
loss versus the harvested power level for each task—CPU,
FRAM.R, FRAM.W and RFID. In the absence of a controlled
RF environment (i.e., anechoic chamber), it is extremely
difﬁcult to maintain the same multipath reﬂection pattern.
Especially when changing the distance between the radiat-
ing reader antenna and an instrumented CRFID device con-
sidering the multipath interference created by the probes,
cables, and the nearby oscilloscope and researcher to moni-
tor the device’s internal state. To minimize the difﬁculty of
conducting the experiments, we place the CRFID device at
a ﬁxed distance (20 cm) whilst keeping all of the equipment
at ﬁxed positions, and adjust the transmit power of the
RFID reader through the software interface. According to
the free-space path loss equation [36], adjusting the transmit
power of the RFID reader or changing the distance can be
used to vary the available power at the CRFID device. We
describe the detailed experimental settings in Appendix H.
For experiments without the requirement for monitoring
the device’s internal state, we still employ distance-based
measurements as in previous studies [7], [17], [21].

The results are detailed in Fig. 5. For a transmit power
greater than 800 mW, the CRFID transponder continuously
operates without power failure within 100 seconds. If the
reader transmit power is below 800 mW, the average operat-
ing time of the RFID task drops as the power level decreases.
This is because the RFID communication process invokes

1002003004005006007008009001000102103104105Time (ms)CPURFIDFRAM.RFRAM.W180200220240260Reader Transmit power (milliwatts)shorting the antenna, during which the energy harvesting is
interrupted. Notably, different from Flash memory, reading
data from FRAM (FRAM.R) consumes more power than
writing to it (FRAM.W) as a consequence of the destructive
read and the compulsory write-back [37]. Consequently, we
developed:

• The Pilot-Observer Mode to reduce the occurrence of
RFID tasks by enabling observing devices to listen to
broadcast packets in silence whilst electing a single Pilot
token to respond to the Server.

• The Power Aware Execution Model (PAM) to ensure mem-
ory access (FRAM tasks) and intensive computational
blocks of the security protocol (CPU tasks) do not exceed
the powering capability of the device.

8

CRFID device is realized. Notably, this execution scheduling task
is outsourced to the resourceful Server.

In this context, we assume the distances between the
antenna and target CRFID devices are relatively constant
during the short duration of a ﬁrmware update. Firmware
updates are generally a maintenance activity where CRFID
integrated components are less likely to be mobile to ease
maintenance, such as during the scheduled maintenance of
an automated production line [39]; night time updates in
smart buildings when people are less likely to be present
and facilities are inoperative [40]; or the pre-ﬂight main-
tenance or inspection of aircraft parts while parked on an
apron [9]. Further, it is desirable to maintain a stable pow-
ering channel in practice by ensuring a consistent distance
during the maintenance or patching of devices for a short
period. This is a more reasonable proposition than the wired
programming of each device. Hence, the relatively ﬁxed dis-
tance is a reasonable assumption in practice. Notably, given
the challenging nature of the problem, previous non-secure
ﬁrmware update methods, such as R3 [21] and Stork [7],
were evaluated under the same assumption.

Fig. 6. A sequence diagram describing our proposed PAM and illus-
trating the interaction between the Token’s CPU execution and the
hardware timer. One PAM execution cycle consists of an active mode
followed by a low power mode (LPM), one complete task may involve
multiple PAM cycles. Other operations, such as RFID communications
and FRAM access, are coordinated by the token CPU. If the CPU is
in the LPM state, the entire system will be halted to allow energy to
accumulate.

Power Aware Execution Model
(PAM). The execution
mode enables a token to dynamically switch between active
power mode and lower power mode (LPM)—LPM pre-
serves (SRAM) state and avoids power-loss while executing
a task. PAM is illustrated in Fig. 6. In active power mode, the
token executes computations, and switches to LPM before
power-loss to accumulate energy; subsequently, the token
is awoken to active power mode to continue the previous
computation after a period of tLPM.

Our PAM model builds upon [17], [38] in that, these are
designed for execution scheduling to prevent power-loss from
brownouts. Compared to [17], we consider dynamic schedul-
ing of tasks and in contrast to [38] sampling of the harvester
voltage (only possible in speciﬁc devices) within the application
code, we consider dynamic scheduling determined by the
more resourceful Server S using a single voltage measure-
ment reported by a token T (see Appendix C for detailed
comparison). We outline the means of achieving our PAM
model on a token below.

During the Security Association stage shown in Fig. 4,
a token measures and reports the voltage Vti ← SNIFF(t)
to the Server. The Vti measurement indicates energy that
can be harvested by token Ti under the settings of the
current ﬁrmware update session. According to Vti, the
Server determines the active time period tactive and LPM
time period tLPM for each CRFID device (detailed develop-
ment of a model to estimate tactive and tLPM from Vt is
in Appendix D). Consequently, each CRFID device’s execution
model is conﬁgured by the Server with device speciﬁc LPM and
active periods at run-time. Hence, an adaptive execution model
customized to the available power that could be harvested by each

Fig. 7. Experimental evaluation of the latency and success rate of
our proposed power aware execution model (PAM) compared to the
Intermittent Execution Mode (IEM) method in [17] and a typical
continuous execution model (CEM). The long-run task used in this
evaluation is a MAC computation over a 1,536-Byte random message
typically requiring 125.5 ms to complete in CEM. Notably, CEM fails
when the reader transmit power is below 200 mW. We conduct 100
repeated measurements and report the mean.

PAM Experimental Validation. To understand the effective-
ness of our PAM method to reduce the impact of brownout,
we execute a computation intensive module, MAC() using
PAM, at power-up on a CRFID. We employ a few lines
of code to toggle GPIO pins to indicate the successful
completion of a routine. Notably, it is difﬁcult to track a
device’s internal state without a debug tool attached to the
device; however, if the debug interface is in use, it will either
interfere with powering, or affect the timing by involving
additional
Joint Test Action Group (JTAG) service code.
We measure the time taken to complete the MAC() execution
(latency) and success rate (success over 10 repeated attempts
under wireless powering conditions) with digital storage
oscilloscope connected to GPIO pins indicating a successful
execution before power loss. We compute a MAC over a
1,536-Byte randomly generated message to test the effective-
ness of PAM in preventing a power loss event due to brown-
out and compare performance with the execution method—
denoted IEM—of a ﬁxed LPM state (30 ms) programmatically
encoded during the device provisioning phase as in [17].

The results in Fig. 7 show the effectiveness of PAM to
mitigate the interruptions from power loss. This is evident

Token CPUToken TimerCount downfrom tactiveStartcpmpuationTimer underﬂowPauseCount downfrom tLPMEnter LPMTimer underﬂowEnterActive modeCount downfrom tactiveResume......FinishStopOne PAM execution......tactivetactivetLPM020406080100316251237224211200188178Success Rate (%)Reader transmit power (mW)0100200300400500600Latency (ms)PAM(Ours)IEMCEM9

Fig. 8. (a) Our proposed Pilot-Observer method. Only the elected Pilot using the Vti based election method responds while observers listen silently.
(b) Evaluation of Pilot Token selection strategies. Measured Tokens are placed 40 cm above the reader antenna, where the powering condition
is critical; we defer the reader to Appendix F for further results from other operational distances. The number of attempts to have all 4 CRFIDs
(Tokens) updated (pie chart) and the corresponding latency (scatter plot) over 100 repeated measurements. The mean number and the standard
division for successful updates for all four tokens are also labeled in the scatter plot with (mean, std) given in seconds.

.

when the success rate results without PAM—using the con-
tinuous execution model (CEM)—is compared with those
of PAM at decreasing operating power levels. However, as
expected, we can also observe that the dynamically adjusted
execution model parameters (tLPM and tactive) of PAM at
decreasing power levels to prevent power loss events and
increase latency or the time to complete the routine. When
PAM is compared with IEM, the dynamically adjusted ex-
ecution model parameters allow PAM to demonstrate an
improved capability to manage interruptions from power-
loss at poor powering conditions; this is demonstrated by
the higher success rates when the reader transmit power
is at 188 mW and 178 mW. Since IEM encodes operating
settings programmatically during the device provisioning
phase [17], we can observe increased latency at better pow-
ering conditions when compared to PAM which allows a
completion time similar to that obtained from CEM when
power is ample. Thus, PAM provides a suitable compromise
between latency and successful completion of a task at
different powering conditions.

Notably, the RFID media access control (MAC) layer on a
CRFID device is implemented in software as assembly code
and executed at speciﬁc clock speeds to ensure strict signal
timing requirements in the EPC Gen2 air interface protocol.
Additionally, protocol message timing requirements places
strict limits on waiting periods for devices responses. Hence,
we do not consider the direct control of the execution
mode during communication sessions for managing power
consumption and instead rely on the Pilot-Observer mode
method we investigate next.

TABLE 2. Execution overhead of pilot and observer tokens when
receiving broadcast packets.

Clock Cycles1 Memory Usage (Bytes)
ROM

RAM

Operation

Pilot token receiving

Pilot token replying

Observer token receiving

23,082

1,131

22,002

12

0

12

2

0

2

apply decoding,
prepare reply (e.g., compute CRC)

communication (backscattering)

apply decoding

1Numbers are collected using a JTAG debugger where the reported values are
averages over 100 repeated measurements. We provide a detailed discussion of
the experiments and analysis process in Appendix G.

Pilot-Observer Mode. We observed and also conﬁrmed
in Fig. 5 that the task of responding to communication
commands will likely cause power loss. During the Secure
Broadcast stage shown in Fig. 4, communication is domi-
nated by repeated SecureComm commands with payloads
of encrypted ﬁrmware and the data ﬂow is uni-directional.
Intuitively, we can disable responses from all the tokens to

save energy. However, the SecureComm command under
EPC Gen2 requires a reply (ACK) from the token to serve as
an acknowledgment [35]. An absent ACK within 20 ms will
cause a protocol timeout and execution failure.

To address the issue, we propose the pilot-observer
mode inspired by the method in Stork [7]. A critical and
distinguishing feature of our approach is the intelligent
election of a pilot token from all tokens to be updated—we
defer to Appendix E for a more detailed discussion on
the differences. As illustrated in Fig. 8(a), our approach
places all in-ﬁeld tokens to be updated into an observer
mode except one token elected by the Server to drive the
EPC Gen2 protocol—this device is termed the Pilot token.
By doing so, observer tokens process all commands such as
SecureComm—ignoring the handle designating the target
device for the command—whilst remaining silent or muting
replies to all commands whilst in the observer mode. Muting
replies signiﬁcantly reduce energy consumption and disrup-
tion to power harvesting of the tokens.

We propose electing the token with the lowest reported
Vt as the pilot based on the observation: measuring pow-
ering channel state from the token, obtained from Vti ←
SNIFF(t), is the most reliable measure of power available to
a given device (see the discussion in Appendix D).

We recognize that it is very difﬁcult to implement an
explicit synchronization method to ensure the observer to-
kens stay synchronized with the pilot token in the secure
broadcast update session. This is due to the level of com-
plexity and overhead that an explicit method would bring
and the consequence of such an overhead would be the
increased occurrence of failures of a secure broadcast update
session due to the additional task demands on tokens—
we discuss the problem further in section 6. Although syn-
chronization between the pilot and observer tokens are not
explicit, the Pilot-Observer method implicitly enforces a de-
gree of synchronicity. The selected pilot token—tasked with
responding to the Host commands during the broadcast—
has to spend more time than observer tokens to prepare the
uplink packet and send a reply (ACK) to the Host (RFID
reader) to meet the EPC Gen2 speciﬁcation requirements
as summarized in Table 2; hence the update process is
controlled by the slowest token. Further, since we elect the
token with the lowest powering condition as the pilot,
the update is controlled by the most energy-starved token.
This strategy leads to other tokens having higher levels
of available power and extra time to successfully process

RandomLatency (s)HighestLowestHighest RSSILowest RSSIHighest VtLowest VtAttemptsRead RateRead RateHostReaderAntennaAll In-field devices measureVtiVtiThe Host elects as the pilotand report powering channel state (      )ServerPilot CRFID the device with the(b)Observer CRFIDs(a)Lowest VtVtiPercentage of successfulupdates to all 4 tokensMeasurements1(89%)23050100050100(11, 4)100%1(73%)234 5Fail050100(23, 11)98%1(66%)234 5Fail050100(28, 22)91%1(29%)234 5Fail050100(23, 15)56%1(35%)234 5Fail050100(39, 26)67%1(6%)234 5Fail050100(26, 12)50%1(47%)234Fail050100050100(21, 12)74%the broadcasted ﬁrmware and remain synchronized with
the update process. Hence, if the pilot succeeds, observers are
expected to succeed.

Validation of Pilot Election Method. To demonstrate the
effectiveness of our pilot token election method, we con-
sidered seven different pilot token selection methods based
on token based estimations of available power and indirect
methods of estimating the power available to a token by
the server: 1) Lowest Vt: this implies the pilot is selected
based on the most conservative energy availability at token;
2) Highest Vt: the pilot has to reply to commands, hence
we may expect higher power availability to prevent the
failure of a broadcast session due to brownout at the pilot;
3) Lowest Read Rate: a slow pilot allows observers to gather
more energy during the broadcast and remain synchronized
with the protocol to prevent failure of the observer tokens;
4) Highest Read Rate: a faster pilot could reduce latency; 5)
Lowest Received Signal Strength Indicator (RSSI): success-
ful communication over the poorest channel may ensure all
observers are on a better channel (RSSI acts as an indirect
measure of the powering channel at a token); 6) Highest
RSSI: prevent pilot failure due to a potentially poor pow-
ering channel at the pilot token; and 7) Random selection:
monkey beats man on stock picks.

We have extensively evaluated and compared all of the
above seven pilot token selection methods. The experiment
is conducted by placing 4 CRFID tokens at 20 cm, 30 cm,
40 cm and 50 cm above an reader antenna; each CRFID is
placed in alignment with the four edges of the antenna (See
Fig. 12.(d)). We repeated the code dissemination process 100
times at each distance test, for each of the 7 different pilot
selection methods. We recorded two measures: i) latency
(seconds); and ii) number of times the broadcast attempt up-
dated all of the 4 in-ﬁeld devices.As illustrated in Fig. 8.(b),
at 40 cm where the power conditions are more critical at a
token, the selected pilot token with the lowest token voltage
(Vt) shows an enormous advantage, in terms of both la-
tency and attempt number. Overall, our proposed approach
(electing the lowest Vt) ensures that most observer tokens
are able to correctly obtain and validate the ﬁrmware in a
given broadcast session on the ﬁrst attempt in the critical
powering regions of operation (we provide a theoretical
justiﬁcation in Appendix D).

We also evaluated the reduction in power consumption
achieved from computational tasks, in addition to elimi-
nating the communication task. While we provide a de-
tailed discussion of the experiments and analysis process
in Appendix G, we summarize our experimental results in
Table 2. The measurements show that the observer tokens,
compared to the pilot token, consumes 2,211 less clock
cycles per ﬁrmware packet from the Host. This is a reduction
of 9.13% to process each ﬁrmware packet sent from the Host.

10

3.3 Efﬁcient Security Primitives

Wisecr requires two cryptogrpahic primitives: i) symmetric
key primitive SKP(); and ii) a keyed hash primitive for
the message authentication code MAC(). When selecting
corresponding primitives in the following, two key factors
are necessary to consider:
1) Computational cost: The CPU clock cycles required for
a primitives quantiﬁes both the computation cost and
energy consumption. Therefore, clock cycles required for
executing the primitives need to be within energy and
computational limits of the energy harvesting device.
2) Memory needs: On-chip memory is limited—only 2 KiB of
SRAM on the target MCU—and must be shared with: i)
the RFID protocol implementation; and ii) user code.
Symmetric Key Primitives. We ﬁst compare block ci-
phers via software implementation benchmarks—clock cy-
cle counts and memory usage—on our target microcon-
troller [41], [42]. We also considered the increasingly avail-
able cryptographic co-processors in microcontrollers: our
targeted device uses an MSP430FR5969 microcontroller and
embeds an on-chip hardware Advanced Encryption Stan-
dard (AES)
accelerator (we refer to as HW-AES) [43].
Based on the above selection considerations, HW-AES is
conﬁrmed to outperform others. Speciﬁcally, HW-AES to
encrypt/decrypt a 128-bit block consumes 167/214 clock
cycles with a power overhead of 21 µA/MHz; therefore we
opted for HW-AES for SKP.Dec function implementation
on our target device. We conﬁgured AES to employ the
Cipher-Block Chaining (CBC) mode2 similar hardware AES
resources can be found in a variety of microcontrollers,
ASIC, FPGA IP core and smart cards. In the absence of HW-
AES, a software AES implementation, such as tiny-AES-c
can be an alternative.
Message Authentication Code.
MACs built upon
BLAKE2s-256, BLAKE2s-128, HWAES-GMAC and HWAES-
CMAC on our targeted MSP430FR5969 MCU were taken
into consideration [17]. We selected the 128-bit HWAES-
CMAC—Cipher-based Message Authentication Code3—
based on AES since it yielded the lowest clock cycles per
Byte by exploiting the MCU’s AES accelerator (HW-AES).

3.4 Bootloader Control Flow

We can now realize an uninterruptible control ﬂow for an
immutable bootloader built upon on the security properties
identiﬁed and engineered to achieve our Wisecr scheme
described in Section 2.2. We describe the bootloader control
ﬂow in Fig. 9.

At power-up, 1 the token performs MCU initialization
routines, 2 setup MPU protections for bootloader exe-
cution and carries out a self-test to determine whether a
ﬁrmware update is required, or if there is a valid application
installed. If no update is required and the user application
is valid, 3 the bootloader conﬁgures MPU protections for
application execution, before handing over control to the

Summary. Our pilot-election based method effectively reduces
the chance of power failure as well as de-synchronization of
the observer tokens during a ﬁrmware broadcast session. Our
approach is able to ensure that more of the observer tokens are
able to correctly obtain and validate the ﬁrmware during a single
broadcast sessions.

2. We are aware of CBC padding oracle attacks; however, in our implementa-
tion, the response an attacker can obtains is to the CMAC failure or success and
not the success or failure of the decryption routine. Alternatively, the routines can
be changed to employ authenticated encryption in the future, with an increase in
overhead.

3. The implementation in NIST Special Publication 800-38B, Recommendation for

Block Cipher Modes of Operation: the CMAC Mode for Authentication is used here.

11

Fig. 9. Wisecr Bootloader control ﬂow. The Bootloader manages Security Association, Secure Broadcast, Validation and Remote Attestation stages.

application. During the application execution, 4 the user
code is executed, 5 then the token T waits for command
from the Server S, the Server S may send an Inventory
commands to instruct the token T to 6 send back e.g.,
sensed data, or in 7 setup the WisecrMode ﬂag and trigger
a software reset in preparation for an update.
Security Association. Upon a software reset, a set Wise-
crMode ﬂag directs the token T to enter the Security
Association stage. 8 Subsequently, the token waits for
further instructions from the Server. On reception of an
Authenticate command, carrying an encrypted broadcast
session key (cid:104)sk(cid:105)i and the MAC tag si of the new ﬁrmware,
9 the token T decrypts (cid:104)sk(cid:105)i with its device key ki and
acquires the session key sk.
Secure Broadcast. Recall, at this stage, all tokens selected for
update will be switched into the observer mode except the
pilot token that is set to respond to the Server. The pilot to-
ken in state 10 receives a new chunk of encrypted ﬁrmware
(cid:104)ﬁrmware(j)(cid:105), and 11 stores it into the speciﬁed memory
location. 12 The pilot token sends reply to the Server. In 13 ,
for tokens in observer mode, they silently listen to the com-
munication trafﬁc between the Server and the Pilot token
without replying. In other words, tokens under observer
mode receives the encrypted ﬁrmware chunks, 14 store
chunks in memory but ignores unicast handle identifying
the target device; this signiﬁcantly saves observers’ energy
from replying as detailed in Section 3.2.2. Once an End of
Broadcast (EOB) message is received, all tokens stop waiting
for new packets and start ﬁrmware decryption 15 .
Validation. The token computes a local MAC tag s(cid:48)
i, in-
cluding the decrypted ﬁrmware, and compares it with the
received MAC tag si 16 . The ﬁrmware is accepted, applied
to update 17 the token, if s(cid:48)
i and si are matched, and 19
the WisecrMode ﬂag is reset; otherwise, 18 the ﬁrmware
is discarded and the update is aborted. Subsequently, each
token performs a software reset to execute the new ﬁrmware
or reinitialize in bootloader mode if the ﬁrmware update is
unsuccessful.
Remote Attestation. On reception of an Authenticate
command with an instruction to perform remote attestation,
20 the token ﬁrst decrypts the session key sk and reads 21
idi, veri and ﬁrmware from the NVM according to the

speciﬁed memory address and size (ﬁrmware is only used
in the elaborate mode, in the fast mode 23 only idi and veri
are involved). The attestation response is then computed as
r ← MACsk(c(cid:107)selected segment (ﬁrmware)(cid:107)idi(cid:107)veri) if
the elaborate mode is selected 22 or r ← MACsk(c(cid:107)idi(cid:107)veri)
if using the fast mode 24 . Subsequently, the response r is
sent back to the Server S, 25 the WisecrMode ﬂag is cleared
and 19 the device is reset.

Notably, a power-loss event during the control ﬂow will
result in a reset and rebooting of the token T and a transition
out from the ﬁrmware update state. Most signiﬁcantly, in
such an occurrence, the immutable bootloader functionality
is preserved. Although the loss of state implies that a Server
S must reattempt the secure update, we prevent the token
from being left in a vulnerable state to inherently mitigate
security threats posed in the power off state [22].

4 END-TO-END IMPLEMENTATION AND EXPERI-
MENTS

This section elaborates on software tools, the end-to-end
implementation of Wisecr and extensive experiments con-
ducted to systematically evaluate the performance of Wisecr.

4.1 End-to-End Implementation

We implement a bootloader and a Server Toolkit to wirelessly
and simultaneously update multiple CRFID transponders
using commodity networked RFID hardware and standard
protocols. We realize the Wisecr scheme in Fig. 4 and the
identiﬁed security property requirements. Speciﬁcally, we
employ MSP430FR5969 MCU based WIPS5.1LRG CRFID
devices. The MSP430FR5969 microcontroller has a 2 KiB
SRAM and a 64 KiB FRAM internal memory. The imple-
mentation is a signiﬁcant undertaking and includes software
development for the CRFID as well as the RFID reader and
backend services for the server update mechanisms. Given
that we have open sourced the project, we describe: i) the
bootloader in Section 4.2; and ii) the Sever Toolkit and the
protocols for Host-to-RFID-reader and Reader-to-CRFID-
device communications for implementing Wisecr over EPC
Gen2 in Appendix B.

MCUinitialization Executeuser codeWait forcommandTransmit dataAuthenticateWait fornew packetStore〈firmware(j)〉Compute MAC tagDiscardupdateAccept andapply updateYesNoDecrypt skSecureCommBootloaderexecution 1910111618Power-on resetand power failureDecryptfirmwareWait forcommandSetWisecrModeflag 71517Triggersoftware resetWisecrMode  set or invalid  firmware YesNoEOB56ObserverModeFlag is set? NoYesSend reply12Wait fornew packetStore〈firmware(j)〉1314SecureCommTriggersoftware resetResetWisecrMode  flag 819Setup MPUprotections forbootloader executionApplicationexecution  24Setup MPU  protections forapplication executionand lock the MPU 3InventoryMAC tag matched?Enter  SecureBroadcast modeEnterApplicationexecution  mode? YesNoNoNoelaborate  mode?Read idi , verifrom NVM23Read idi, veri ,firmware from NVM 21Compute attestationresponse in fast mode24Compute attestationresponse in elaborate mode22YesNoSend backresponse 25YesAuthenticateEOBYesSecure BroadcastRemote AttestationSecurity AssociationValidationDecrypt sk20Enter Attestation  mode?4.2 Bootloader and Memory Management

Wisecr Bootloader. The immutable bootloader supervises
ﬁrmware execution while needing to be compatible with
standard protocols, we developed our bootloader based
on the Texas Instrument’s recent framework for wireless
ﬁrmware updates—MSP430FRBoot [44] —and the code base
from recent work [17] employing the framework. Such
construction ensures a standard tool chain for compilation
and update of new ﬁrmware whilst the usage of industry
standards is likely to increase adoption in the future. We
compile the ﬁrmware code into ELF (Executable and Link-
able Format) made up of binary machine code and linker
map specifying the target memory allocation—the memory
arrangement is illustrated Fig. 10.

Fig. 10. Memory Protection Unit (MPU) segmentation diagram and
memory arrangement during bootloader execution (left) and appli-
cation code execution (right). Due to hardware limitations, only 3
segments can be deﬁned, and the secure storage area must be at least
1 KiB in size due to segment boundary alignment requirements [45]

Wisecr Memory Management. For implementing the Secure
Storage component, several different mechanisms are avail-
able (as summarized in Appendix A). In Wisecr, we select to
use the Runtime access protection (e.g. using MPU segments
at run-time)
In this scheme, secure storage is available
on device boot-up, but is locked (until next boot-up) by
the bootloader before any application code is executed.
We employed this method and the implemented memory
arrangement is described in Fig. 10. Switching to privilege
mode is done by the bootloader on boot up, and the ap-
plications do not need to make any speciﬁc modiﬁcations.
If an application attempts to access a privileged resource,
e.g. overwriting the bootloader segment, a power-up clear
(PUC) will be triggered by the MPU to cause reboot, before
any risky operation.

Importantly, any power-on reset, regardless of the cause,
will result in a reboot and the execution of the bootloader
before transferring control to application code—see Ap-
plication execution stage in Fig. 9. Prior to entering the
application execution stage, the bootloader enforces the
MPU policy for application execution (see 3 ). This step
is necessary with the target MCU used in our implementa-
tion as it only allows deﬁning three memory segments for
protection. Thus, we are able to rely on the very limited
protections provided by the MCU to achieve the security
objectives of a trusted bootloader; recall, in our threat model,
the bootloader is trusted, and we realize this in practice
by ensuring that the bootloader provisioned is immutable
where the secrets stored on device must remain inaccessible
and immutable to the application ﬁrmware. Now, it is infea-
sible to revoke the policy enforced during the application
execution stage, unless the device is power-cycled. But, the
device will enter the bootloader stage after a reboot and
MPU protections will be re-enabled prior to executing any

12

application code. We summarize the memory protections
developed using the limited MPU conﬁgurations to realize
Wisecr security requirements in bootloader and application
execution modes in Section 3.2; therein, we also discuss
alternative methods to realize such protections to ensure the
generalization of Wisecr to other MCUs.

Fig. 11. (a) Token memory and allocations, (b) fast mode, (c) elaborate
mode.

Remote Attestation. As shown in Fig. 11 (a) Remote Attesta-
tion routine is an integral part of the immutable bootloader,
it has access to all memory segments: Token device key ki,
version number veri, tag serial number idi and the installed
user application code ﬁrmware. A challenge c is a one-time
use random string that is generated by the Server S. The r(cid:48) is
the report to be transferred back to the Server. On receiving
an encrypted session key (cid:104)ski (cid:105), the Token decrypts it with
SKP.Dec and obtains the session key sk. In the fast mode
illustrated in Fig. 11 (b), the response r(cid:48) is calculated based
on idi and veri. In contrast, the response r(cid:48) is computed
over an entire memory segment, such as the ﬁrmware, in
the elaborate mode as depicted in Fig. 11 (c).

4.3 Wisecr Implementation Overheads

We ﬁrst evaluate the execution and implementation over-
head of each Wisecr security functional block; results4 are
summarized in Table 3. The execution overhead is measured
in terms of clock cycles for installing a ﬁrmware of 240
Bytes. The implementation overhead is measured in mem-
ory usage, consisting of ROM for code and constants and
RAM for run-time state. Secondly, we assess the necessary
hardware modules such as hardware AES accelerator (HW-
AES), analog-to-digital converter (ADC) and Timer. All
functional blocks are implemented in platform independent
C source ﬁles. We summarize the implementation costs
for each stage; the most signiﬁcant implementation and
execution overhead is from the Validation stage because of
the computationally heavy MAC() function—recall Remote
Attestation is an optional stage.

In Table 3, we also compare with SecuCode5; presently,
the only CRFID ﬁrmware update scheme considering
security—notably, the scheme only prevents malicious code
injection attacks and is designed to update a single de-
vice at a time as highlighted in the method comparison
Table 4. In summary, Wisecr consumes 49.97% more clock
cycles, 40.95% more ROM and 97.43% more RAM space
than the SecuCode. However, Wisecr can update multiple

4. Tested under the CCS 9.0.1.0004 development environment, with compiler

TI v18.12.1.LTS Optimization settings: -O = 3; -opt for speed = 5.

5. In [17], the device key is derived from SRAM PUF responses. In our
comparison, we opt for a device key in the protected NVM instead to make a
fair overhead comparison. Further, the key derivation module only adds a ﬁxed
overhead at start-up.

Application (firmware)executionBootloader &RFID MAC layerApp Code (firmware)Device IVTDownload areaSecure storageBootloader &RFID MAC layerApp Code (firmware)Download areaSecure storageBootloader execution0x13FFF0x100000x04400App IVTBoot startBoot start – 4 KBMMMMMMrwrwrwxrxrxSecure StorageApp Code(firmware)k  , veridfirmwareDevice Info.(a)id  || vercMACskr'(b)cMACskr'firmware || id  || ver(c).Token's on-chipmemory......addrsizeSKP.Dec<sk   >sk13

TABLE 3. Wisecr Implementation and Execution Overheads

Clock Cycles

Memory Usage (Bytes)
ROM

RAM

HW Requirement

Functional blocks
sk ← SKP.Decki((cid:104)ski(cid:105)) (For a 16-Byte block)
ﬁrmware(j) ← SKP.Decsk((cid:104)ﬁrmware(j)(cid:105)) (For a 16-Byte block)
si ← MACsk(ﬁrmware||veri||nver)
Vti ← SNIFF(t)
PAM.Enter(tLPMi , tactivei ) and PAM.Exit()3
Setup MPU for bootloader execution
Setup MPU for application execution
Secure Storage (used for ki, idi and veri)
Stages
Security Association
Secure Broadcast
Validation
Remote Attestation (elaborate mode)
Remote Attestation (fast mode)
Total
Wisecr (excluding Remote Attestation, for the pilot Token)
SecuCode (using ﬁxed key, updates a single token)

772
772
26,6981
1,530
51
76
91
0

2,302
11,6041
26,7241
18,3604
5,574

40,6301
27,0921

7062
690
2,374
276
86
58
60
19

982
760
2,390
3,172
3,172

3442
2442

62
62
72
12
6
0
0
0

74
68
77
80
80

154
78

HW-AES
HW-AES
HW-AES
ADC
Timer
MPU
MPU
MPU

ADC, HW-AES
HW-AES, Timer
HW-AES, Timer
HW-AES
HW-AES

All of the above
HW-AES, Timer

1For a typical 240-Byte ﬁrmware
44,397 clock cycles for the setup routine–a constant overhead for any block size, 1,060 clock cycles for each 16-Byte block and n + 2 clock cycles for an n-Byte padding
to form a 16-Byte block, if required.

216 Bytes of this value incorporates the device key ki in secure storage

3A single PAM execution, as deﬁned in Fig. 6

devices simultaneously to attain a performance advantage
as we demonstrate in Section 4.3 because SecuCode only
updates one device at a time. In addition, Wisecr provides
IP protection (encryption of the ﬁrmware transmitted over
the insecure wireless channel) and validates ﬁrmware in-
stallation. As expected, the performance improvements and
additional security features are achieved at an increased
implementation overhead.

4.4 Experiment Designs and Evaluations

We employed four WIPS5.1LRG CRFID devices and an
Impinj R420 RFID reader with a 9 dBic gain antenna to
communicate with and energize the CRFID devices. All of
the experiments are conducted with the RFID reader feeding
the antenna with 30 dBm output power. Given that, the
recent EPC Gen2 V2.0 [35] security commands such as the
SecureComm are not yet widely supported by commercial
RFID readers, like the Impinj Speedway R420, we map
the unsupported EPC Gen2 command to the BlockWrite
command as in [17]. We summarize our evaluations below6:
• We evaluate performance—latency and throughput in
Section 4.5—and compare with: i) SecuCode [17], the
scheme only prevents malicious code injection at-
tacks and is designed to update a single device
at a time as shown in the method comparison Ta-
ble 4; ii) Wisecr intentionally set to sequential mode—
broadcasting/updating one token at a time—termed
Wisecr (Seq), to assess the gains from Wisecr broad-
casting ﬁrmware to multiple devices simultaneously;
and iii) non-secure multi-CRFID dissemination scheme,
Stork [7] (see Section 5.1)

• We evaluate the efﬁcacy of our Power Aware Execution
Model (PAM) and Pilot Token selection method (results
in the Section. 3.2.2).

• We demonstrate Wisecr

in an end-to-end imple-
mentation (see Section 4.6 and demonstration video
at https://youtu.be/GgDHPJi3A5U)

4.5 Performance Evaluation and Results

i) end-to-end latency;
We use two performance metrics:
and ii) throughput (bits per second). Latency is the time

6. Notably, our extensive experiments to evaluate techniques and modules we

developed are detailed in the Appendices with references in the main article

elapsed from the Server Toolkit transmitting the ﬁrmware
to an RFID reader using LLRP commands to the time the
Server Toolkit conﬁrms the acknowledgment of successfully
updating all chosen tokens. Throughput is the total data
transferred over the latency, where T hroughput (bps) =
(|ﬁrmware| × Num. of Tokens)/ Latency. Our evaluation is
carried out under three different controlled variables: i) dis-
tance; ii) number of tokens; and iii) ﬁrmware size. In each
experiment, only one variable is changed and our results
are collected over 100 repeated measurements, with outliers
outside of 1.5 times upper and lower quartiles removed.

First, we transfer the same ﬁrmware code (a 407 Byte
accelerometer service) to four target devices located at dis-
tances from 20 cm to 40 cm, covering good to poor powering
channel states, to evaluate the stability of the Wisecr scheme.
As expected, we can observe in Fig. 12(a) that the perfor-
mance of all three schemes downgrades with increasing
distance. Notably, Wisecr and SecuCode outperforms the
Wisecr (Seq). Because, Wisecr (Seq) incurs a larger overhead
through the need for executing a Security Association stage
to setup the broadcast security parameters, for each device.
Further, SecuCode (without IP protection) does not need
to execute the power intensive ﬁrmware decryption oper-
ations, and thus is less likely to encounter power-loss and
update session failure or require the extra time necessary
by Wisecr to decrpyt the ﬁrmware. As expected, Wisecr
outperforms albeit the added security functions provided
in comparison to SecuCode.

Second, following the method and metrics in Stork [7],
we tested the performance of the schemes by increasing the
number of CRFID devices to be updated. We can see in
Fig. 12(b) that the latency of both Wisecr (Seq) and SecuCode
increases linearly while Wisecr remains relatively steady
regardless of the number of devices to update. Conse-
quently, Wisecr exhibits signiﬁcantly improved throughput
as the number of device increases. Further, we examine
performance under increasing ﬁrmware size: 115 Bytes; 407
Bytes (a sensor service code); and 1280 Bytes (a computation
code ﬁrmware). Efﬁcacy of broadcasting to multiple devices
simultaneously is validated by latency and throughput per-
formance detailed in Fig. 12(c).

Third, all three candidates show improved efﬁciency as
larger ﬁrmware sizes are transmitted; Wisecr’s signiﬁcantly

14

Fig. 12. Comparing Wisecr, Wisecr (Seq)—Wisecr operating in sequential mode, SecuCode [17] with no secure broadcast
support under increasing: (a) Distance (4 Tokens with a 407 Byte ﬁrmware), (b) Number of Tokens (at 20 cm with 407
Byte ﬁrmware) and (c) Firmware size (at 20 cm with 4 Tokens). The experimental setup illustrated in (d) shows 1 a
host PC, 2 a RFID reader, 3 a reader antenna and 4 four CRFID devices mounted on a foam frame, supported by
a wooden tripod.

better efﬁciency can be attributed to the broadcast method.

4.6 Case Study

We also conducted an evaluation of the execution over-
head (latency) introduced by the remote attestation routines.
Since remote attestation is performed on one singulated
token at an instance, we only examine its impact on one
individual device. The latency can be aggregated for multi-
ple devices. As illustrated in Fig. 12, the remote attestation
in fast mode always completes in 1.1 ms, regardless of the
ﬁrmware size. While the time required to complete the
elaborate mode scales from 1.3 ms to 6.5 ms with respect
to ﬁrmware sizes from 115 Bytes to 1280 Bytes.

Fig. 13. The execution overhead of the attestation function with respect
to different ﬁrmware sizes in an end-to-end experiment setting. Mean
values over 100 repeated measurements are plotted.

Fig. 14. (a) Application scenario: wirelessly updating the ﬁrmware of
four CRFID sensor devices embedded in an unmanned aerial vehicle
(UAV) rotor prototype7. With Wisecr, we simultaneously, securely and
wirelessly updated the four devices with a 391-Byte code. Experimental
results when: (b) the rotor assembly is attached to the UAV; and (c)
when the rotor assembly is free standing over the antenna. The green
bar graph denotes the percentage of successful updates to all 4 devices.

7. The UAV rotor aerodynamic model

is adopted and modiﬁed from:

https://grabcad.com/library/4-bladed-propeller-experimental-1

As shown in Fig. 14, we employ four CRFID devices em-
bedded in a 3D printed unmanned aerial vehicle (UAV)
rotor prototype. The CRFID devices are factory programmed
with ﬁrmware for monitoring the centrifugal load and the wired
programming interface is disabled prior to embedding and de-
ployment. All four CRFID devices are required to be updated
wirelessly and securely with code for monitor the blade ﬂapping
vibration in a wind tunnel test.

We employed Wisecr to simultaneously, securely and
wirelessly update the four CRFID sensor devices with the
391-Byte ﬁrmware code. The experimental results summa-
rized in Fig. 14 show successful updates for 100 repeated
attempts in two settings: i) when the rotor is attached to the
UAV Wisecr updated all of the devices in the ﬁrst attempt in
76% of the time with an average latency of 28.12 seconds;
and ii) when the rotor assembly is free standing, Wisecr
updated all of the devices in the ﬁrst attempt in 89% of the
time with an average latency of 14.27 seconds8.

A demonstration of the secure ﬁrmware update pro-
cess in using our end-to-end implementation illustrated in
Fig. 14 is available at https://youtu.be/GgDHPJi3A5U. We
open source the complete source code for Wisecr and related
tools at https://github.com/AdelaideAuto-IDLab/Wisecr.

4.7 Security Analysis

Under the threat model in Section 2.1, we analyze Wisecr
security against: i) IP theft (code reverse engineering); ii)
malicious code injection attacks under code alteration, load-
ing unauthorized code, loading code onto an unauthorized
device, and code downgrading; and iii) incomplete code
installation.
IP Theft or Code Reverse Engineering. The wirelessly
broadcasted ﬁrmware is encrypted using a one-time 128-
bit broadcast session key ski. Without the knowledge of
the broadcast session key, the adversary A is unable to
obtain the plaintext ﬁrmware through passive eavesdrop-
ping. Once the ﬁrmware is decrypted on the token, the
binaries cannot be accessed outside the immutable boot-
loader. Therefore, the probability of a successful IP theft
is now determined by the security provided by the size
of the selected keys—we employ 128-bit keys in the Wisecr
implementation.

8. Although previous studies have performed experiments with static tags, we
also attempted to update the tokens while the rotor blades are mobile by rotating
them at approximately 1 RPM. We were able to update tokens over 50% of the
time. As expected, the changing powering conditions dramatically reduced the
update rate (see details in Appendix I)

153045Latency (s)WisecrWisecr(Seq)SecuCode(FixKey)203040Distance (cm)012Throughput (Kbps)WisecrWisecr(Seq)SecuCode(FixKey)1530451154071280Fimware size (Byte)0241530451234Token Number0246(a)(b)(c)④③②①(d)1154071,280Firmware size (byte)02468Executionoverhead (ms)Fast modeElaborate mode                          CRFID devices embedded in UAV rotor blades UAV body UAV rotor blades RFID reader antenna Latency (s)Latency (s)Attempts (c) (b) (a) Attempts Measurements234 5Measurements34 5Fail1(76%)1(89%)050100050100(28,  17)93%050100050100050100(14,  3)100%050100Loading Unauthorized Code. The security property of a
MAC tag si ← MACki (ﬁrmware||veri||nver) ensures that
the adversary A cannot commit a malicious ﬁrmware in-
jection attack without the knowledge of the session key
sk —recall that the sharing of sk is protected through a
secure channel established with a token speciﬁc private
key ki. Hence, only the Server with the session key sk is
able to produce a valid MAC tag to a token T . Hence, the
probability of launching a successful attack by the adversary
A is limited to the probability of successfully obtaining
the device key ki and/or the session key sk in a man-
in-the-middle attack to successfully construct a MAC tag
and disseminate a malicious ﬁrmware that will be correctly
validated by the target tokens. Therefore, without knowl-
edge of ki or sk, the probability of fooling a token T to
inject a malicious ﬁrmware by A is no more than the brute-
force attack probability 2−128 determined by the key size
|ki|= 128.
Code Alteration. For each ﬁrmware update, a MAC tag
si ← MACki (ﬁrmware||veri||nver) is used to verify code
integrity. Therefore, without knowledge of the session key
sk, the adversary A can not generate a valid MAC tag for an
altered ﬁrmware. Any attempted changes to the ﬁrmware
during the code dissemination will be detected and, thus,
ﬁrmware discarded by the token.

Loading Code onto an Unauthorized Device. Each au-
thorized device i maintains a unique and secret device
speciﬁc key ki only known to the Server S. Therefore, an
unauthorized device cannot decrypt the session key ski
to install a recorded ﬁrmware encrypted with ski of an
authorized device.
Code Downgrading. The adversary A can attempt to down-
grade the ﬁrmware to an older version to facilitate exploita-
tion of potential vulnerabilities in a previous distribution.
This can be attempted through a replay attack by imper-
sonating the Server. However, for each ﬁrmware update, a
speciﬁc MAC tag: si ← MACki (ﬁrmware||veri||nver) is
generated based on two monotonically increasing version
numbers: veri and nver. Without direct access to modify
the Secure storage contents in region M to re-write the
current version number of a device to an older version, the
attacker cannot replay a recorded MAC tag from a previous
session to force a token to accept an older ﬁrmware. By
virtue of the monotonically increasing version numbers, and
the secure MAC primitive protected by the session key sk, a
successful software downgrade using a replay attack cannot
be mounted by the adversary A.
Incomplete Firmware Installation. In a man-in-the-middle
attack, the adversary A may attempt to prevent a new
ﬁrmware installation and spoof a device response with
an updated version number during an interrogation—the
version number is public information and sent in plaintext
as shown in Fig. 4. Hence, a token may be left executing
an older ﬁrmware version with potential ﬁrmware vulnera-
bilities. The Server can verify that a speciﬁc disseminated
ﬁrmware deployed by the token is the same as the one
issued by the Server by performing a remote attestation. In
our Wisecr scheme, we have considered an optional remote
attestation stage (detailed in Section 2.2) to allow the Server
to verify the ﬁrmware installation on a given token. In
general, both code installation and attestation are bounded

15

to the device key ki, thus, it is infeasible to fool the Server
without knowledge of the device key.
Related-key Differential Cryptanalysis Attack.
In our
security association stage, the session key sk is encrypted
multiple times with different device keys ki. A related-
key differential cryptanalysis of round-reduced AES-128 is
demonstrated in [46]. The prerequisite to mount such an
attack is that the attacker knows or is able to choose a
relation between several secret keys and gain access to both
plaintext and ciphertext [47]. In our approach, as mentioned
in Section 2.1, ki chosen by the server are i.i.d., and only the
ciphertext is publicly available where the attacker is not able
to force the server to encrypt a plaintext of their choosing.
Therefore related-key attacks cannot be mounted under our
threat model. Even if such an attack is possible, to the best
of our knowledge, there is no successful full-round related-
key differential cryptanalysis attack against AES-128, which
serve as the SKP function in our implementation.

5 RELATED WORK AND DISCUSSION
Here, we discuss related works in the area of wireless code
dissemination to CRFID devices. Notably, the topic of wireless
code updating has been intensively studied for battery pow-
ered Wireless Sensor Network (WSN) nodes. For example,
a recent study by Florian et al. [29] proposed updating
the ﬁrmware and peer-to-peer attestation of multiple mesh
networked IoT devices. Physical unclonable functions [17]
and blockchains [48] have also been utilized in code dis-
semination

But, such schemes [29], [48] are designed for battery
powered WSN nodes featuring device-to-device communication
capability, and supervisory control of operating systems (e.g
TinyOS), absent in batteryless CRFID devices (see challenges
in Section 1). Further, batteryless devices operate under
extreme energy and computational capability limitations. In
particular, harvested energy is intermittent and limited and
thus devices face difﬁculties supporting security functions
such as key exchange using Elliptic Curve Difﬁe-Hellman
used in [29]. Therefore, we focus on research into wireless
dissemination schemes for CRFID like devices in our discus-
sions. Further, we also discuss and compare our work with
existing wireless methods developed for CRFID to highlight
the aim of our scheme to fulﬁll unmet security objectives for
simultaneous wireless ﬁrmware update to multiple CRFIDs.
Wireless Code Dissemination to CRFID. Given the recent
emergence of the technology, there exists only a few studies
on code dissemination to CRFID devices. Wisent from Tan et
al. [18], and R3 from Wu et al. [21] demonstrate a wireless
ﬁrmware update method for CRFIDs. Subsequently, Aan-
tjes et al. [7] proposed Stork, a fast multi-CRFID wireless
ﬁrmware transfer protocol. Stork forces devices to ignore
the RN16 handle in down-link packets—a form of promis-
cuous listening—to realize a logical broadcast channel in
the absence of EPC Gen2 support for a broadcast capability;
RN16 speciﬁes the designated packet receiver. This tech-
nique enables Stork to simultaneously program multiple
CRFIDs to achieve fast ﬁrmware dissemination. Our Pilot-
Observer mode (Section 3.2.2) is based on a similar concept,
but instead of always selecting the ﬁrst seen device, as in
Stork, we strategically elect the token with the lowest Vt as
the Pilot to achieve higher broadcast success. Brown and Pier

16

Fig. 15. We repeated the ﬁrmware update process for Wisecr (ours) and Stork to compare between Stork (providing no security properties) and our
Wisecr scheme under three different test settings: (a) increasing operational range; (b) increasing number of tokens, and (c) payload sizes.

from Texas Instrument (TI) developed MSPBoot [49] in late
2016. They demonstrate an update using a UART or SPI bus
to interconnect a MSP430 16-bit RISC microcontroller and
a CC1101 sub-1GHz RF transceiver. However, none of the
schemes, Wisent, R3, Stork and the work in [49], considers
security when wirelessly updating ﬁrmware. SecuCode [17]
took the ﬁrst step to prevent malicious code injection attacks
where a single CRFID device is updated. But SecuCode
lacks scalability and performs device by device updates,
cannot protect the ﬁrmware IP, and provides no validation
of ﬁrmware installation.

Remote Attestation. Attestation enables the Server to estab-
lish trust with the token’s hardware and software conﬁgu-
ration. Existing mainstream remote attestation methods are
unsuitable for a practicable realization in the context of in-
termittently powered, energy harvesting platforms we focus
on. For example, peer-to-peer attestation adopted in [29] is
impractical in the CRFID context due to the lack of a device-
to-device communication channel. In boot attestation [50],
a public-key based scheme is proposed to ﬁt ownership
and third party attestation, however public-key schemes are
too computationally intensive for the batteryless devices we
consider. Recently, a publish/subscribe mechanism based
asynchronous attestation for large scale WSN is presented
in SARA [51], however, such a publish/subscribe paradigm
is yet to be supported over a standard EPC Gen2 protocol.
In contrast, our lightweight-remote-attestation mechanisms
(see Section 2.2) are inspired from the recent study in [19]
where methods are designed for resource limited platforms
and require no additional building blocks besides those
necessary for Wisecr.

TABLE 4. Comparison with Related Studies.

Power-loss mitigation

Security

Work

Multiple
devices

Commun.
Energy
Reduction

Adaptive
IEM

Wisent [18]
R3 [21]
Stork [7]
SecuCode [17]
Wisecr (Ours)

(cid:56)
(cid:56)
(cid:51)
(cid:56)
(cid:51)

(cid:56)
(cid:56)
(cid:51)
(cid:56)
(cid:51)

(cid:56)
(cid:56)
(cid:56)
(cid:56)
(cid:51)

Prevent
Malicious
Code
Injection
(cid:56)
(cid:56)
(cid:56)
(cid:51)
(cid:51)

Prevent
IP
Theft

Code
instal.
attest.

(cid:56)
(cid:56)
(cid:56)
(cid:56)
(cid:51)

(cid:56)
(cid:56)
(cid:56)
(cid:56)
(cid:51)

Public
source
code
release

(cid:51)
(cid:56)
(cid:51)
(cid:51)
(cid:51)

Comparisons. Table 4 summarizes a comparison of Wisecr
with wireless code dissemination studies speciﬁc to passive
CRFID devices. Wisecr is the only secure scheme (prevent IP
theft and malicious code injection, and provide attestation of
ﬁrmware installation) for simultaneous update of passively
powered devices. We have also extensively compared the
performance of Wisecr with the non-secure code update
method of Stork to provide an appreciation for the security
overhead in an end-to-end implementation below.

5.1 Comparison with Stork (Insecure Method)

We extensively compared the performance of our secure
Wisecr scheme with Stork [7]. Both methods aim to offer
multiple CRFID wireless ﬁrmware updates, but security
objectives are not considered by Stork. Comparisons are
carried out under three different test settings:

• Four different operating ranges from 20 to 50 cm.
• Updating 1 to 4 tags concurrently in-ﬁeld to evaluate re-
duced latency to update (or improvements to scalability)
(as in Stork, tags are at 20 cm from the antenna).

• Consider three different ﬁrmware sizes (as in Stork, tags

are at 20 cm from the antenna).

We measured two performance metrics: i) latency; and ii)
throughput as deﬁned in Section 4.5 for each test setting.
For both Stork and Wisecr, we used the same binary ﬁles
generated from the same compilation. The settings in the
Wisecr Server Toolkit are: 10 attempts per broadcast run;
lowest voltage Vti pilot token selection method; Send Mode
is set to Broadcast. Meanwhile, the settings in Stork are:
BWPayload is set to throttle; Update Only is set to True;
Reprogramming Mode is set to Broadcast; Compression is
Disabled (as compression simply reduces the size of the
ﬁrmware, we did not enable this option). Results are mean
values from 100 repeated protocol update runs. Comparison
results from our experiments are detailed in Fig. 15:

• From Fig. 15 (a): when powering channel state is rea-
sonable i.e. from 20 cm to 40 cm, Wisecr outperforms
Stork, as Wisecr does not need per-block checking and
relies on the pilot token selection method to improve
broadcast performance. However, Stork performs better
than Wisecr at 50 cm when the powering channel con-
dition is very poor because Stork is able to continue
to transmit the ﬁrmware across power failures since
the stork scheme does not need to meet any security
requirements and therefore is able to send ﬁrmware
payload in plaintext from the last correctly received
payload. In contrast Wisecr gracefully fails when a power
interruption cannot be prevented and all states (such as
the session key) are lost and a new broadcast attempt
must be made by the Server Toolkit.

• From Fig. 15 (b): Wisecr exhibits signiﬁcantly better la-
tency and throughput as the number of tokens increases.
• From Fig. 15 (c): both protocols show improved efﬁ-
ciency as larger payload/ﬁrmware sizes are transmitted.
Notably, Wisecr exhibits much better efﬁciency attributed
to the signiﬁcantly reduced latency experienced during
the broadcast method.
The gains in performance and faster updates to many
devices achieved by Wisecr can be attributed to: i) our
pilot token selection method to drive the protocol where

01530Latency (s)WisecrStork203040Distance (cm)012Throughput(Kbps)WisecrStork015301154071280Fimware size (Byte)024015301234Token Number036(a)(b)(c)a signiﬁcantly large proportion of in-ﬁeld tokens are up-
dated in a single attempt; and ii) our validation method
of complexity O(n · 1) where n is the number of tokens—
although computationally intensive—is more lightweight
than the read back mechanism of Stork, O(n · k) where k
is the code size, relying on the narrow band communication
channel employed by CRFID devices.

6 CONCLUSION AND FUTURE WORK

Our study proposed and implemented the ﬁrst secure
and simultaneous wireless ﬁrmware update to many RF-
powered devices with remote attestation of code installa-
tion. We explored highly limited resources and innovated
to resolve security engineering challenges to implement
Wisecr. The scheme prevents malicious code injection, IP
theft, and incomplete code installation threats whilst being
compliant with standard hardware and protocols. Wisecr
performance and comparisons with state-of-the-art through
an extensive experiment regime have validated the efﬁcacy
and practicality of the design, whilst the end-to-end imple-
mentation source code is released to facilitate further im-
provements by practitioners and the academic community.

Limitations and Future Work: Our study is not without
limitations. Although the Wisecr reasonably assumes (as
in R3 [21] and Stork [7]) that the devices are at relatively
constant distances from an RFID reader antenna during the
short duration ﬁrmware update process (approximately 16 s
in the application demonstration), occasionally this assump-
tion may not hold. For example, when re-programming
devices on a conveyor belt, it is desirable to not delay the
movement of the tags and to re-program whilst distances are
changing. Development of a solution to the problem in the
context of resource limited devices operating over a highly
constrained air interface protocol is a challenging problem
and an interesting direction for future work.

Additionally, every BlockWrite command used to
broadcast the ﬁrmware contains a CRC-16 ﬁeld for error
detection [35]. In our Pilot-Observer mode, only the pilot-
detected CRC errors are indicated to the Host; future work
could consider the problem of broadcast reliability further.
Notably, developing a method is non-trivial given the limi-
tations of the EPC Gen2 air interface protocol.

In our secure update method, the pilot token and observer
tokens do not explicitly synchronize progress due to the
constrained air interface protocol not supporting token-
to-token communications as well as the extremely limited
available power. This also makes it difﬁcult for the server
to immediately, i.e. during the Secure Broadcast stage, to
detect an observer token that has de-synchronized. Any
synchronization would need to involve the Host performing
this function, such as reading back of memory contents
from a token’s download region and re-transmitting missing
packets, at set intervals [7]. Hence, developing an explicit
synchronization method in the context of a secure broadcast
method forms an interesting direction for future work.

Further, it will be interesting to consider alternative
mechanisms for validating the installation of ﬁrmware, such
as the exploitation of the reply signal to the ﬁnal packet
delivering ﬁrmware to tokens. We leave this interesting
direction to explore for future work.

17

REFERENCES

[1] B. Lucia, V. Balaji, A. Colin, K. Maeng, and E. Ruppel, “Inter-
mittent computing: Challenges and opportunities,” in Summit on
Advances in Programming Languages, 2017.

[2] A. P. Sample, D. J. Yeager, P. S. Powledge, A. V. Mamishev, and
J. R. Smith, “Design of an RFID-based battery-free programmable
sensing platform,” IEEE Trans. Instrum. Meas., vol. 57, no. 11, pp.
2608–2615, 2008.

[3] H. Zhang, J. Gummeson, B. Ransford, and K. Fu, “Moo: A
batteryless computational RFID and sensing platform,” Uni. of
Massachusetts Comput. Sci. Technol. Report UM-CS-2011-020, 2011.

[4] Farsens, “Pyros-0373 UHF RFID battery-free temperature sensor
tag,” http://www.farsens.com/en/products/pyros-0373/,
(ac-
cessed: Mar. 19, 2022).

[5] A. J. Bandodkar, P. Gutruf, J. Choi, K. Lee, Y. Sekine, J. T. Reeder,
W. J. Jeang, A. J. Aranyosi, S. P. Lee, J. B. Model et al., “Battery-free,
skin-interfaced microﬂuidic/electronic systems for simultaneous
electrochemical, colorimetric, and volumetric analysis of sweat,”
Science Advances, vol. 5, no. 1, p. eaav3294, 2019.

[6] R. L. Shinmoto Torres, R. Visvanathan, D. Abbott, K. D. Hill, and
D. C. Ranasinghe, “A battery-less and wireless wearable sensor
system for identifying bed and chair exits in a pilot trial in
hospitalized older people,” PLOS ONE, vol. 12, no. 10, pp. 1–25,
2017.

[7] H. Aantjes, A. Y. Majid, P. Pawełczak, J. Tan, A. Parks, and J. R.
Smith, “Fast Downstream to Many (Computational) RFIDs,” in
Proc. IEEE Int. Conf. on Comput. Commun. (INFOCOM), 2017.
[8] D. Marasov´a, P. Koˇsˇc´ak, N. Staricna, S. Mako, and D. Matiskov´a,
“Digitization of air transport using smart tires,” in New Trends in
Aviation Development (NTAD), 2020, pp. 164–167.
S. Yang, M. Crisp, R. V. Penty, and I. H. White, “RFID enabled
health monitoring system for aircraft landing gear,” J. Radio Fre-
quency Identiﬁcation, vol. 2, no. 3, pp. 159–169, 2018.

[9]

[10] M. D. SANTONINO III, C. M. Koursaris, and M. J. Williams,
“Modernizing the supply chain of airbus by integrating RFID
and blockchain processes,” Intern. J. of Aviation, Aeronautics, and
Aerospace, vol. 5, no. 4, p. 4, 2018.

[11] W. Li, H. Song, and F. Zeng, “Policy-based secure and trustworthy
sensing for internet of things in smart cities,” Internet of Things J.,
vol. 5, no. 2, pp. 716–723, 2017.

[12] M. Noura, M. Atiquzzaman, and M. Gaedke, “Interoperability in
internet of things: Taxonomies and open challenges,” Mobile Net.
and App., vol. 24, no. 3, pp. 796–809, 2019.

[13] A. Parks, “WISP 5,” https://github.com/wisp/wisp5, 2016, (ac-

cessed: Mar. 19, 2022).

[14] Z. Ning and F. Zhang, “Understanding the security of arm debug-
ging features,” in Proc. IEEE Symp. on Secur. and Privacy (S&P),
2019, pp. 602–619.

[15] F. Xu, W. Diao, Z. Li, J. Chen, and K. Zhang, “BadBluetooth:
Breaking android security mechanisms via malicious bluetooth
peripherals.” in Proc. Network and Distributed Syst. Secur. Symp.
(NDSS), 2019.

[16] FAA,

“Airworthiness

approval
(RFID)

of
tags

installed
and

radio
sensors,”

identiﬁcation

frequency
www.faa.gov/regulations˙policies/advisory˙circulars/
index.cfm/go/document.information/documentid/1034630,
Nov 2018, (accessed: Mar. 19, 2022).

[17] Y. Su, Y. Gao, M. Chesser, O. Kavehei, A. Sample, and D. Ranas-
inghe, “Secucode: Intrinsic puf entangled secure wireless code
dissemination for computational rﬁd devices,” IEEE Trans. on
Dependable and Secur. Comput., vol. 18, no. 4, pp. 1699–1717, 2021.

[18] J. Tan, P. Pawełczak, A. Parks, and J. R. Smith, “Wisent: Ro-
bust downstream communication and storage for computational
RFIDs,” in Proc. IEEE Int. Conf. on Comput. Commun., 2016, pp. 1–9.
[19] D. Dinu, A. S. Khrishnan, and P. Schaumont, “SIA: Secure inter-
mittent architecture for off-the-shelf resource-constrained micro-
controllers,” in IEEE Int. Symp. on Hardware Oriented Secur. and
Trust (HOST), 2019, pp. 208–217.

[20] K. Maeng, A. Colin, and B. Lucia, “Alpaca: intermittent execution
without checkpoints,” Proc. of the ACM on Programming Languages,
vol. 1, no. OOPSLA, p. 96, 2017.

[21] D. Wu, L. Lu, M. J. Hussain, S. Li, M. Li, and F. Zhang, “R3:
Reliable over-the-air reprogramming on computational RFIDs,”
ACM Trans. on Embedded Comput. Syst., vol. 17, no. 1, p. 9, 2018.

[22] A. S. Krishnan and P. Schaumont, “Exploiting security vulnerabil-
ities in intermittent computing,” in Int. Conf. on Secur., Privacy, and
Applied Cryptography Eng. (SPACE), 2018, pp. 104–124.

[23] Y. Su and D. C. Ranasinghe, “Leaving your things unattended is no
joke! memory bus snooping and open debug interface exploits,” in
Proc. IEEE Int. Conf. on Pervasive Comput. and Commun. Workshops
(PerCom Workshops), 2022, pp. 643–648.

[24] Z. Liu, H. Seo, Z. Hu, X. Hunag, and J. Großsch¨adl, “Efﬁcient
implementation of ECDH key exchange for MSP430-based wire-
less sensor networks,” in Proc. ACM Symp. on Inf., Comput. and
Commun. Secur. (CCS), 2015, pp. 145–153.

[25] Z. Liu, H. Seo, S. S. Roy, J. Großsch¨adl, H. Kim, and I. Ver-
bauwhede, “Efﬁcient ring-LWE encryption on 8-bit AVR proces-
sors,” in Int. Workshop on Crypto. Hardw. and Embed. Syst. (CHES),
2015, pp. 663–682.

[26] F. Brasser, D. Gens, P. Jauernig, A.-R. Sadeghi, and E. Stapf,
“Sanctuary: Arming trustzone with user-space enclaves.” in Proc.
Network and Distributed Syst. Secur. Symp. (NDSS), 2019.

[27] T. Frassetto, P. Jauernig, C. Liebchen, and A.-R. Sadeghi, “IMIX: In-
process memory isolation extension,” in Proc. 27th USENIX Secur.
Symp. (USENIX Security), 2018, pp. 83–97.

[28] C. Jin and M. van Dijk, “Secure and Efﬁcient Initialization and
Authentication Protocols for SHIELD,” IEEE Trans. Depend. Secur.
Comput., 2017.

[29] F. Kohnh¨auser and S. Katzenbeisser, “Secure Code Updates for
Mesh Networked Commodity Low-End Embedded Devices,” in
Proc. Springer Eur. Symp. Res. Comput. Secur., 2016, pp. 320–338.
[30] W. Feng, Y. Qin, S. Zhao, Z. Liu, X. Chu, and D. Feng, “Secure code
updates for smart embedded devices based on PUFs,” in Proc. Int.
Conf. on Crypto. and Net. Secur. (CANS), 2017, pp. 325–346.

[31] F. Piessens and I. Verbauwhede, “Software security: Vulnerabilities
and countermeasures for two attacker models,” in Proc. Conf. on
Design, Automation & Test in Europe (DATE), 2016, pp. 990–999.
[32] M. Sammler, R. Lepigre, R. Krebbers, K. Memarian, D. Dreyer,
and D. Garg, “Reﬁnedc: automating the foundational veriﬁcation
of c code with reﬁned ownership types,” in Intern. Conf. Program.
Language Design Implementation, 2021, pp. 158–174.

[33] A. Levy, B. Campbell, B. Ghena, D. B. Gifﬁn, P. Pannuto, P. Dutta,
and P. Levis, “Multiprogramming a 64kb computer safely and
efﬁciently,” in Symp. Operat. Syst. Principles, 2017, pp. 234–251.
[34] A. Aysu, E. Gulcan, D. Moriyama, P. Schaumont, and M. Yung,
“End-to-end design of a PUF-based privacy preserving authenti-
cation protocol,” in Proc. Springer Int. Workshop on Crypto. Hardw.
and Embed. Syst (CHES), 2015, pp. 556–576.

[35] G. EPCglobal, “Inc.,“EPCTM Radio-Frequency Identity Protocols
Class-1 Generation-2 UHF RFID Protocol for Communications at
860MHz-960MHz Version 2.0.1,” EPCGlobal Inc., Tech. Rep., 2015,
(accessed: Mar. 2, 2022). [Online]. Available: https://www.gs1.
org/sites/default/ﬁles/docs/epc/Gen2 Protocol Standard.pdf

[36] H. T. Friis, “The free space transmission equation,” Proc. IRE,

vol. 34, p. 254, 1946.

[37] P. Thanigai and W. Goh, “Msp430 fram quality and reliability,”

Texas Instruments, SLAA526A, 2014.

[38] M. Buettner, B. Greenstein, and D. Wetherall, “Dewdrop: an
energy-aware runtime for computational RFID,” in Proc. USENIX
Symp. on Net. Syst. Design and Impl., 2011, pp. 197–210.

[39] K. Fischer, “Advancements in control system data authentication
and veriﬁcation,” in ASNE Intelligent Ships Symp., 2017, pp. 25–25.
[40] A. Elmangoush, R. Steinke, T. Magedanz, A. A. Corici, A. Bour-
reau, and A. Al-Hezmi, “Application-derived communication pro-
tocol selection in M2M platforms for smart cities,” in Proc. Intern.
Conf. Intell. in Next Gen. Netw., 2015, pp. 76–82.

[41] B. Buhrow, P. Riemer, M. Shea, B. Gilbert, and E. Daniel, “Block
cipher speed and energy efﬁciency records on the MSP430: System
design trade-offs for 16-bit embedded applications,” in Proc. Int.
Conf. on Crypto. and Inf. Secur. in Latin America (LATINCRYPT),
2014, pp. 104–123.

[42] D. Dinu, Y. Le Corre, D. Khovratovich, L. Perrin, J. Großsch¨adl,
and A. Biryukov, “Triathlon of lightweight block ciphers for the
internet of things,” J. of Crypto. Eng., vol. 9, no. 3, pp. 283–302,
2019.

[43] T. Instruments, “MSP430FR58xx, MSP430FR59xx, MSP430FR68xx,
and MSP430FR69xx Family User’s Guide,” Texas Instruments, 2014.
[44] R. Brown and K. Pier, “MSP430FRBoot – Main Memory
Bootloader and Over-the-Air Updates for MSP430™ FRAM Large
Memory Model,” Dec 2016, (accessed: Mar.19, 2022). [Online].
Available: http://www.ti.com/lit/an/slaa721b/slaa721b.pdf
[45] T. Instruments, “MSP430 fram technology,” jun 2014, (accessed:
Mar.19, 2022). [Online]. Available: https://www.ti.com/lit/an/
slaa628b/slaa628b.pdf

18

[46] P.-A. Fouque, J. Jean, and T. Peyrin, “Structural evaluation of AES
and chosen-key distinguisher of 9-round AES-128,” in Springer
Annual Cryptology Conf., 2013, pp. 183–203.

[47] A. Biryukov and D. Khovratovich, “Related-key cryptanalysis of
the full AES-192 and AES-256,” in Springer Intern. conf. on the theory
and application of cryptology and info. security, 2009, pp. 1–18.
[48] B. Lee and J.-H. Lee, “Blockchain-based secure ﬁrmware update
for embedded devices in an internet of things environment,” The
Journal of Supercomputing, vol. 73, no. 3, pp. 1152–1167, 2017.
[49] L. Reynoso, “Mspboot – Main Memory Bootloader for MSP430
™ Microcontrollers,” jun 2013, (accessed: Mar. 19, 2022). [Online].
Available: http://www.ti.com/lit/an/slaa600d/slaa600d.pdf
[50] S. Schulz, A. Schaller, and et al., “Boot attestation: Secure remote
reporting with off-the-shelf IoT sensors,” in Proc. Eur. Symp. on
Res. in Comput. Secur. (ESORICS), 2017, pp. 437–455.

[51] E. Dushku, M. M. Rabbani, M. Conti, L. V. Mancini, and S. Ranise,
“SARA: Secure asynchronous remote attestation for IoT systems,”
IEEE Trans. on Info. Forensics and Secur., pp. 3123–3136, 2020.
[52] D. E. Holcomb, W. P. Burleson, and K. Fu, “Power-up SRAM state
as an identifying ﬁngerprint and source of true random numbers,”
IEEE Trans. on Comput., vol. 58, no. 9, pp. 1198–1210, 2008.

[53] P. V. Nikitin, R. Martinez, S. Ramamurthy, H. Leland, G. Spiess,
and K. Rao, “Phase based spatial identiﬁcation of UHF RFID tags,”
in Proc. IEEE Int. Conf. on RFID (IEEE RFID), 2010, pp. 102–109.

[54] J. Tan, Robust downstream communication and storage for computa-
tional RFIDs. Department of Software Technology, Delft Univer-
sity of Technology., 2015.

[55] Y. Su, A. Wickramasinghe, and D. C. Ranasinghe, “Investigating
sensor data retrieval schemes for multi-sensor passive RFID tags,”
in Proc. IEEE Int. Conf. on RFID (IEEE RFID), 2015, pp. 158–165.

Yang Su (S’14) Yang Su received the B.Eng.
degree with ﬁrst class Honours in Electrical and
Electronic Engineering from The University of
Adelaide, Australia in 2015. He worked as a Re-
search Associate at The University of Adelaide
from 2015-2016 and he is currently pursuing
the Ph.D. degree. His research interests include
hardware security, physical cryptography, em-
bedded systems and computer security.

Michael Chesser received his B.Sc Advanced
degree in 2016 and his Honours (First Class)
degree in Computer Science in 2017 from The
University of Adelaide, Australia. Michael has
worked as a consultant at Chamonix Consulting
and, more recently, at the School of Computer
Science, The University of Adelaide as a Re-
search Associate. His research interests are in
compilers, embedded systems, system security
and virtualization.

Yansong Gao received his M.Sc degree from
University of Electronic Science and Technology
of China in 2013 and Ph.D degree from the
School of Electrical and Electronic Engineering
in the University of Adelaide, Australia, in 2017.
He is now with School of Computer Science and
Engineering, NanJing University of Science and
Technology, China. His current research inter-
ests are AI security and privacy, hardware se-
curity, and system security.

Alanson Sample received his Ph.D. in electrical
engineering from the University of Washington
in 2011. He is currently an Associate Professor
in the department of Electrical Engineering and
Computer Science at the University of Michigan.
Prior to returning to academia, he spent the ma-
jority of his career working in academic minded
industry research labs. Most recently Alanson
was the Executive Lab Director of Disney Re-
search in Los Angeles. Prior to joining Disney, he
worked as a Research Scientist at Intel Labs in
Hillsboro. He also held a postdoctoral research position at the University
of Washington. Dr. Sample’s research interests lie broadly in the areas
of Human-Computer Interaction, wireless technology, and embedded
systems.

Damith C. Ranasinghe received the Ph.D. de-
gree in Electrical and Electronic Engineering
from The University of Adelaide, Australia. From
2005 to 2006, he was a Visiting Scholar with
the Massachusetts Institute of Technology and
a Post-Doctoral Research Fellow with the Uni-
versity of Cambridge from 2007 to 2009. He
joined The University of Adelaide in 2010, and is
currently an Associate Professor with the School
of Computer Science. His research interests in-
clude embedded systems, system security, au-

tonomous systems, and deep learning.

19

APPENDIX A
MEMORY MANAGEMENT COMPARISON
For implementing the Secure Storage component, several
different mechanisms can be used:

1) Isolated segments (e.g. using IP encapsulation hard-
ware). Requirements and limitations: It requires hardware
features (such as IP encapsulation) to implement.

2) Volatile secret keys (see, for example, SRAM PUF [52]).
Requirements and limitations: It might be computation-
ally expensive to derive and erase the secret key, need
a mechanism to ‘restore’ the volatile area on device
restart, and a different mechanism is required to ensure
the bootloader is immutable.

3) Execute only memory (e.g. using MPU segments
at compile time) In this scheme secure memory is
encoded as instructions (e.g. MOV) in execute only
memory (XOM) (see [29]). Requirements and limitations:
Implementation can be complex, since any code in this
region must ensure that it does not leak data (e.g.
in CPU registers or volatile memory), including from
arbitrary jumps into the code. Additionally, since the
bootloader is also unable to write to this region, it
cannot be used to protect dynamic secrets (e.g. the
broadcast session key).

4) Runtime access protection (e.g. using MPU segments
at runtime) In this scheme, secure storage is available
on device boot-up, but is locked (until next boot-up)
by the bootloader before any application code is exe-
cuted. We selected this method in Wisecr. Requirements
and limitations: Method requires MPU hardware with
runtime conﬁguration and locking, and the implemen-
tation must ensure that the MPU is always conﬁgured
correctly before any application code is executed.

APPENDIX B
DETAILED Wisecr UPDATE SCHEME
Server Toolkit. Our Server Toolkit can be executed on a
host with network connectivity to an RFID reader. The
App loads in the ELF ﬁle generated from the compilation
process, parses and slices it into MSPBoot speciﬁed 128-
bit-long commands suitable for the RFID reader. The App
then uses LLRP commands to construct AccessSpecs and
ROSpecs. These encode EPC C1Gen2 protocol commands
such as BlockWrite and SecureComm commands to dis-
cover, engage and conﬁgure a networked RFID reader to
execute the Wisecr protocol. Notably, we follow the same
protocols for Host-to-RFID-reader and Reader-to-CRFID-
device communications as in [7], [17] and detail implemen-
tation of Wisecr over EPC Gen2 in the Fig. 3.
Wisecr Update Scheme Over EPC Gen2. As described
in Fig. 4, Wisecr enables the ability to distribute and up-
date ﬁrmware of multiple CRFID tokens, simultaneously.
Given that a Server S communicates with an RFID device
using EPC Gen2, a practicable, scalable and secure code
dissemination scheme must be implemented over EPC Gen2.
This requires communication between three separate en-
tities: i) the host machine; ii) the reader; and iii) CRFID
transponders—see main text Fig. 3. Our scheme descrip-
tion here focuses on the communication between CRFID
devices—tokens T —and the RFID reader—the Server S
over the EPC Gen2 protocol as illustrated in Fig. 16—our

20

Fig. 16. Wisecr protocol implemented over the EPC Gen2 protocol. To
reduce complexity, we only provide the protocol sessions after a device
is placed in the WisecrMode—as described in Fig. 9—and highlighted
here.

open source code base provides a complete description
(https://github.com/AdelaideAuto-IDLab/Wisecr).
Authenticating the Acknowledgment in the Validation
Stage. It is theoretically possible to compute and include a
MAC tag in an acknowledgment message at the end of the
Validation stage but the implementation of this in practice

(Set device in                      )if mode == elaborater←MAC(c,ﬁrmware)r←MAC(c,ver ,id )Tokenid  , k ver  Security AssociationPower UPQueryReply	(RN16 )ACK	(RN16 )EPC	(id  ,ver  ,Vt)sk← RNG() ← SKP.Encsk(ﬁrmware)= ()seq= (seq,...,seq)if id  ∉ DB or valid  == Falsereject and abortelses  ← MAC(ﬁrmware|| ver  || nver)  ← SKP.Enck  (sk)(t LPM  ,tactive  )← PAM.GET(Vt )DB = ((id,k,valid),...,(id,k,valid))ﬁrmware= (ﬁrmware,...,ﬁrmware)  nver, setupReq_RN (RN16  )Reply	(handle  )Authenticate(handle  ,nver, t LPM  ,tactive  )sk← SKP.Deck  (  )Save sk and s  (handle )Secure BroadcastPreludeSecureComm	(handle,seq,)Store  into code memory at seq...PAM.Enter(tLPM  ,tactive  )ﬁrmware←SKP.Decsk()ValidationEPC	(ID  ,ver  ,Vt)Power CycleQueryReply	(RN16  )ACK	(RN16  ) if ver   == nverdone   ← TrueEOB	(handle)Vt  ← SNIFF(t)s'  ← MAC(ﬁrmware|| ver  || nver)PAM.Exit()if s  == s'	  accept and apply changever  ← nverelse reject and abortVt ← SNIFF(t)(handle )SecureComm (handle    ,s  )                                       Remote AttestationReq_RN (RN16  )Reply	(handle  ) (handle, cmode)Reply	(r'	)if r   == r' Attestation successesAttestation fails   if mode == elaborater'  ←MAC (c,ﬁrmwarer'  ←MAC    ,done,done(c,ver ,id )  ,ver ,id   ),ver ,id   c← RNG()k   <sk > <sk >,   <sk ><firmware> <firmware> <firmware  >,..., <firmware  >1111mmmm <firmware   >  <firmware   >1SecureComm	(handle,seq,)  <firmware   >Store  into code memory at seq <firmware   >= () <firmware> <firmware   >,..., <firmware   ><firmware>k   Server, addr, size, addr, size,Memory.read(                ) addr, size←ﬁrmware( )n( ) 1( )n( )1( )n( )1( )n( )1( )n( )1( )n( )1( )n( )  1( )n( )else else else sk← RNG()    ← SKP.Enck  (sk)  <sk >sk sksksk,   <sk >sk← SKP.Deck  (  )    <sk >RFID singulation phaseRFID singulation phaseAuthenticateReply	Reply	,handle   EPCQueryReply	(RN16  )ACK	(RN16  )  RFID singulation phase   WisecrMode(Set device in                      )WisecrMode (handle ) Reply	The Pilot(handle ) Reply	The Pilotis not possible. Our current acknowledgment signal is based
on exploiting the last message in a singulation session—see
RFID singulation phase in the Validation stage in Fig. 16.
This last message returns the the unique device identiﬁer
or EPC (electronic product code). We piggy back the current
version number veri in the data ﬁeld part of this message as
our soft validation signal. This is possible because at power-
up (whether it be software or hardware reset) the device
executes the bootloader and during its execution copies the
idi and veri to a global SRAM memory region for use
after the MPU (memory protection unit) prevents access to
this content stored in the secure storage area (see memory
protection unit segmentation diagram in Fig. 10.

Notably, even if a MAC tag was computed by the
bootloader after power cycling (reboot) in the Validation
stage, and stored in global memory for access after MPU
protections to be used during the singulation phase that
follows, the data ﬁeld in the last EPC message is limited
to 96 bits. Thus, there is inadequate room to piggyback a
128-bit MAC tag. Further, this would be an added overhead
since the MAC computation would need to occur each time
a CRFID device is powered (booted), irrespective of whether
the MAC is needed or not.

Thus, it is better to compute a MAC tag after reboot,
on demand and when necessary by: i) singulating a token
ﬁrst; ii) instructing the token to compute the MAC tag; and
iii) requesting the MAC tag. This is essentially the method
we employ in the Remote Attestation stage that follows the
Validation stage.

APPENDIX C
LOW OVERHEAD EXECUTION SCHEDULING
Buettner, et al. proposed Dewdrop [38] execution model
to prevent a brownout event under unreliable powering
by executing tasks only when they are likely to succeed
by monitoring the available harvested power. Dewdrop
explores a dynamic on-device task scheduling method,
however, requires the overhead of collecting samples of
the harvester voltage and task scheduling by the device’s
application code.

In addition, Dewdrop is only suitable for CRFID devices
equipped with a passive charge pump, such as WISP4.1 [2]
since Dewdrop requires directly measuring the charging
rate of the reservoir capacitor—charge storage element. In
the follow-up, WISP version 5.1, the passive charge pump is
replaced with a S-882z active charge pump and the reservoir
capacitor is only connected to the load when Vcap developed
across the capacitor exceeds the reference voltage of 2.4 V
(Vref ). Consequently, in WISP5.1LRG the voltage delivered
to the microcontroller is a sharp step-up, rather than a
ramp-up function related to harvested power. Therefore, the
charging-up process cannot be directly monitored by the
technique in Dewdrop.

APPENDIX D
POWERING CHANNEL STATE MEASUREMENT AND
POWER AWARE EXECUTION MODEL (PAM)

Observation. Generally, increasing distance of the token
from a powering source lowers the harvester output power,
RSSI and Read Rate of a given token.

21

Proposition. Measure powering channel state from the to-
ken is the most reliable measure of power available at a
device.
Validation.

RSSI = PtG2

t G2

pathK where Gpath =

(cid:18) λ

(cid:19)2

4πdo

|H|2 (1)

H = 1 +

N
(cid:88)

i=1

tgiΓi
gi

do
di

e−jk(di−de)

(2)

Although RSSI or received message rate (Read Rate) [18]
measured by an RFID reader (Server) could provide a sim-
ple method to measure the powering channel state at a CR-
FID transponder, we observed these measures to be highly
unreliable. This can be mostly understood by considering
the complexity of the signal propagation model [53]—see
equations (1) to (2) for details. We can see that RSSI depends
not only on the transmit power Pt, the transmitter antenna
gain Gt and backscatter coefﬁcient K, but also the path
gain Gpath. However, Gpath depends on signal wavelength
λ, line of sight distance d0 and the multi-path factor H;
where H is a complex function of angle alignment of the
t and the device gi, angle-dependent reﬂection
transmitter gi
coefﬁcient Γi of i-th object, i-th path length for a total of N
multi-paths—and the inﬂuences from the random access na-
ture9 of the media access control protocol used by the RFID
air interface affecting RSSI and read rate measurements.

Therefore, the powering channel state is best estimated by the ﬁeld
deployed CRFID device harvesting available power at the device.

Thus, we introduce a power aware execution model

where:

• The powering channel state at a CRFID tag is measured
by the device using a single measurement of harvested
power at boot-up (called a Power Sniff denoted as Vti ←
SNIFF(t) in the update scheme). The voltage measure,
Vti, is used to estimate the power that can be harvested
by a given CRFID device in the ﬁeld; and

• The workload of scheduling execution of on-device tasks
is determined by the resourceful Server (RFID reader
and network infrastructure) as opposed to the resource
limited CRFID device based on the channel state mea-
surements from a CRFID.
We consider a harvesting device operating under the
commonly used charge-burst mode where charge is ﬁrst
accumulated in a storage element—often a capacitor—and
charge is released for useful work when an adequate mount
of charge (measured in terms of the voltage) is reached at
the charge storage element. Our power aware execution
model (PAM) requires the Server (RFID reader and/or host)
involved in the update to derive two parameters: i) time
estimation to charge to a set voltage (tc); ii) time estimation
to a brown-out (tb) based on the CRFID reported measure-
ment Vti. Here, we reason that the distance between the antenna
and the given CRFID device does not change during a given
update session. Therefore, the power estimated at the begining
of the session is valid during the entire session.

Unfortunately, the RF energy harvester on a CRFID de-
vice is a non-linear circuit component whose output voltage

9. Notably, the RFID air interface relies on a slotted ALOHA media access

control protocol.

TABLE 5. Comparing the Settings of Tokens

Method

Pilot/Non-Overhearing
role selection

Transponder mode

Stork [7]
(insecure protocol)
Wisecr
(Our secure protocol)

First seen by Host

The lowest Vt Token

Overhearing
non-Overhearing
Observer
Pilot

Ignore handle in
SecureComm/
BlockWrite
(cid:51)
(cid:56)
(cid:51)
(cid:56)

SecureComm/
BlockWrite
response
(cid:56)
(cid:51)
(cid:56)
(cid:51)

22

PAM function formulation. From our results, we can con-
clude: i) for V t ≥ 2.393 V, the CRFID token may continu-
ously operate with no power loss. In such cases, tLP M =
0, and tactive = ∞ is used (execution does not need to be
altered; ii) for V t within 2.183 V and 2.393 V, we can employ
tLP M = 10 ms and tactive = 29 ms (90% the measured tb ) for
a conservative approach to prevent power failures; iii) for
V t within 2.143 V and 2.183 V, use tLP M = 15 ms and tactive
= 14 ms; iv) for V t within 2.140 V and 2.143 V, use tLP M =
25 ms and tactive = 11 ms; and v) if V t ≤ 2.140 V, then the
CRFID device cannot accumulate adequate energy under
such a condition to complete a computation intensive task,
and we strongly suggest to not perform a code update in this
case. We describe (tactive, tLP M ) ←PAM.Get(V t) function in
equation (3).

PAM.Get(V t) =






[∞, 0]
[29 ms, 10 ms]
[14 ms, 15 ms]
[11 ms, 25 ms]
[9 ms, 30 ms]

V t ≥ 2.393 V

,
, 2.393 V > V t ≥ 2.183 V
, 2.183 V > V t ≥ 2.143 V
, 2.143 V > V t ≥ 2.140 V
,

V t < 2.140 V

(3)

APPENDIX E
TRANSPONDER MODES & BROADCAST CHANNEL
Stork [7] proposed exploiting promiscuous listening by
choosing one in-ﬁeld token (CRFID) to stay in the non-
overhearing mode and the rest in overhearing (observer
or promiscuous listening) mode to create a logical broad-
cast channel. This method overcomes the unicast media
access layer protocol to facilitate wireless code dissemina-
tion to multiple CRFID devices. Building upon Stork, our
Pilot-Observer mode (Section 3.2.2) makes a key improve-
ment. In contrast to Stork [7], for the token under Non-
overhearing/Pilot mode, instead of selecting the ﬁrst device
responding to an interrogation signal from the Server, we
elect the the device with the lowest reported voltage (Vt) as
the pilot token. The similarties and differences between our
work and the Stork are summarized in Table 5.

This method forces the broadcast session to be driven by
the device with the lowest available energy, and the highest
probability to brownout; thus, increasing the chance of all
non responding tags remaining in synchronicity with the
the processing of the broadcasted ﬁrmware, simply because
these devices are able to harvest more power than the pilot
token whilst also not having to respond to the Server.

APPENDIX F
PILOT ELECTION EXPERIMENTS
We have collected experiments for 20 cm, 30 cm, 40 cm and
50 cm as shown in Fig. 18. Generally, at 20 cm and 30 cm,
all methods can succeed, with little differences in terms
of the number of attempts and latency. In comparison, all
methods failed to update all four tokens in 10 attempts at
50 cm; although several devices were often updated, no attempt
resulted in all four tokens being updated at this powering level,

Fig. 17. Power measurements. (a) Charging while the MCU is in LPM
mode and (b) discharging when the MCU is in active mode (we
employed a MAC computation for the task). The charge and discharge
experiments at each ﬁxed distance were repeated 10 times to obtain a
mean response.

changes over time as input RF power level varies. Therefore,
it is non-trivial to model the RF energy harvester [38].
Therefore, instead of relying on an analytical model, we
adopt an experimental method to derive the parameters for
PAM empirically. We measure, in repeated measurements,
the output voltage generated by the power-harvesting net-
work on the WISP CRFID. We also measure the expected
workload we can obtain from a CRFID device, before a
brownout causes power loss. We extrapolate from these
measurements to construct an empirical model for the PAM()
function employed by the Server to determine the best set
of execution parameters from the reported voltage V t at
runtime.

As depicted in Fig. 17 (a), the output voltage from the
charge pump grows at different rates and as a function of
received power. The traces do not intersect, therefore, if
we measure the charge pump output voltage at an early
time, e.g, 30 ms as labeled in the picture, we can obtain a
voltage across the reservoir capacitor Vcap, with which we
can predict the time required for the reservoir capacitor to
be charged to a certain voltage level. The charging rate of
a capacitor becomes slower following a logarithm trend. It
is too conservative to use the time to charge to nearly 100%
saturated voltage; we empirically determined an adequate
LPM time. We use the time to charge to approximately 63%
of the saturated voltage, then compared to waiting for a
nearly fully charged capacitor, we can reduce charge time
by 75% and still accumulate adequate energy to execute the
chunk of task under the active time period tactive.

The time before brownout is also a function of received
power. We can observe in Fig. 17 (b), when the powering
condition is good, the CRFID device can execute the MAC
computation we employed for the load, continuously; start-
ing from ta = 110 ms without power failure. However, the
device starts to fail or brown-out causing a power loss at
t = 142.92 ms, giving a time to brown out of tb = ta+
32.93 ms for V t below 2.183 V. As expected, we can see
that tb decreases as the received power decreases.

Vb=1.8Vt=30 ms0.10.110.120.130.140.150.160.170.180.190.2Time (s)01234ta=110 mstb=ta+10.43 mstb=ta+12.63 mstb=ta+12.79 mstb=ta+15.23 mstb=ta+32.93 ms(b)Vt = 3.612 VVt = 2.581 VVt = 2.393 VVt = 2.183 VVt = 2.143 VVt < 2.140VRF Energy Harvester output Voltage (V)Time (s)(a)hence the success rate is reported as zero. However, in the
regions where devices are likely to operate at the threshold
of powering, seen at 40 cm in our experiments, our proposed
pilot election method performs best. Further, the proposed
method is also seen to perform more consistently; indicated
by the consistent success rate across different powering
conditions achieved with different distances.

APPENDIX G
EXECUTION OVERHEAD FOR RECEIVING BROAD-
CAST PACKETS

It is non-trivial to analyze the clock cycles for receiving a
packet and sending a reply, as opposed to other tasks, as
they are executed under a constant clock speed. Notably,
the CRFID tokens do not have a hardware implementa-
tion of the wireless communication protocol. The RFID
communication protocol is implemented in software. Since
RFID communications require strict timing requirements,
the CPU clock is dynamically conﬁgured and the relevant
source code is written in assembly language to meet the
strict timing requirements. For example, when the device
is receiving a packet, the CPU works at 16 MHz. When
the device is sending a reply by modulating its antenna
impedance, the CPU works at 12 MHz. So it is difﬁcult
to employ our previous method to predict clock cycles by
monitoring GPIO pins.

To overcome the above challenge, we used debugger
tools to read the CRFID device’s internal states by inserting
three breakpoints: Breakpoint 1: before the receiving routine
is called; Breakpoint 2: in between the receiving routine and
the reply routine; Breakpoint 3: after the reply routine (as
illustrated in Fig. 19). Clock cycles for receiving and replying
can be acquired by looking at the clock proﬁle counter at
each breakpoint.

The SecureComm command in the EPC Gen2 speciﬁ-
cation is yet to be widely supported in commercial RFID
hardware. Therefore, as we mentioned in Section 3.2.2, we
implement this command over the existing BlockWrite
speciﬁed to support variable payload size as described
in [35]. However, the impinj R420 RFID reader we used in
experiments implements it in a distinct manner. Irrespec-
tive of the speciﬁed payload size, the Impinj R420 reader
(software version 5.12.3.240) always splits the payload into
multiple BlockWrite commands, each command carrying
a payload of only 2 Bytes [54]. Further, busy waiting is
used while receiving a command from the RFID reader
(for example, at https://git.io/J1lO8). Hence, clock cycle
results can vary from measurement to measurement. Hence,
in our experimental results, we report the average clock
cycles for such BlockWrite commands over 100 repeated
measurements. We summarize the results below:

• Pilot token’s cycles to receive a BlockWrite packet

(with 2 Byte payload): 23,082

• Pilot token’s cycles to send a reply to the BlockWrite

packet: 1,131

23

at Breakpoint 2, over the average obtained from 100 mea-
surements). This is because the observer does not need to
prepare the reply packet (ACK), which requires a CRC-6
calculation, as illustrated in Fig. 19.

The total number of packets required in an update can

be computed with:

Npackets =

ﬁrmware size (in Bytes)
2 Bytes per BlockWrite command

The number predicted using the above equation is in an
ideal case, the actual number may be higher considering
retransmissions, for example, due to communications errors
identiﬁed using the CRC.

APPENDIX H
EXPERIMENT SETUP TO ACCESS TOKEN’S INTER-
NAL STATE

Some of our experiments require to measure the internal
states of the token. For example the impact of four key
device tasks on power-loss and the evaluation of our pro-
posed power PAM method in Section 3.2.2. However, we
do not have a precisely controlled RF environment (i.e.,
anechoic chamber) to remove the impact of the multipath
signals constructively and destructively interfering with the
RF powering of a device.

The measurement processes for Fig. 5 and Fig. 7 were
different and complicated by the probes and wires that we
need to attach to the device, the Digital Storage Oscilloscope
(DSO) we need to keep near the setup as well as the close
proximal presence of the researcher to operate the DSO to
enable taking the measurement as shown in Fig. 20.

To try to mitigate the inﬂuence of factors discussed
above, we conducted these experiments following the
method we describe below:

• Ensure we used the same CRFID device for both exper-

iments.

• Try our best to keep the multipath environment the
same across the two experiments. Hence, instead of
adjusting the distance (which suffers from different
multipath reﬂection and interference) and the changing
positions of the probes and wires, we have the CRFID
device ﬁxed at 20 cm above the reader antenna, and
adjusted the transmit power of the RFID reader following the
method in [55].
We can employ this method because, according to the
free-space path loss equation [36] given below, adjust-
ing the transmit power Pt of the RFID reader has a
similar impact on the received power Pr as chang-
ing the distance d. Because, the RF wavelength λ is
relatively constant (notably RFID employs frequency
hopping regulations) whilst the RFID reader antenna
gain Gt and CRFID device antenna gain Gr are ﬁxed.

Pr = PtGtGr

(cid:19)2

(cid:18) λ
4πd

• Observer token’s cycles to receive a BlockWrite

packet (with 2 Byte payload): 22,002
The clock cycles for an observer token to receive a
BlockWrite packet is 1,080 smaller than the pilot token
(this number is obtained by calculating the difference be-
tween the pilot and observer tokens’ clock cycle counter

Notably, in the evaluation of PAM, what we are inter-
ested in is the available harvested power, distance is just one
factor we can use to control the available power at the device
in our experiments. Adjusting the transmit power endows
us with a more accurate form of control over the available
power as that can be done using the RFID reader software,

24

Fig. 18. Evaluation of the pilot token selection strategies we propose. Four tokens were placed at 20 cm, 30 cm, 40 cm and 50 cm above a reader
antenna. The pie chart shows the number of attempts to have all 4 CRFID devices or tokens updated. The scatter plot shows the corresponding
latency for successful updates. The results are obtained over 100 repeated measurements, where each measurement included 10 attempts to update
all four CRFID devices. The bar graph denotes the number of successful updates—deﬁned as all four tokens being updated over the 100 repeated
measurements. Here (mean, standard deviation) latency statistics are given in red text.

programmatically, and without interfering with the devices
setup (such as changing distances and the arrangement of
the probe wires and the multi-path environment).

APPENDIX I
FIRMWARE UPDATE TO MOBILE TOKENS
We tested ﬁrmware updates to mobile CRFID devices. We
rotated the rotor by hand, with a rotation speed of approxi-
mately 1 RPM (revolutions per minute) and conducted 100

Lowest VtLatency (s)Highest VtRead RateRead RateLowest RSSIHighest RSSIRandomLatency (s)Latency (s)Latency (s)LowestHighestAttemptsLowest VtHighest VtRead RateRead RateLowest RSSIHighest RSSIRandomLowestHighestLowest VtHighest VtRead RateRead RateLowest RSSIHighest RSSIRandomLowestHighestLowest VtHighest VtRead RateRead RateLowest RSSIHighest RSSIRandomLowestHighestAttemptsAttemptsAttempts20 cm30 cm40 cm50 cmPercentage of successfulupdates tp all 4 tokens1234 5FailPercentage of successfulupdates tp all 4 tokensPercentage of successfulupdates tp all 4 tokensPercentage of successfulupdates tp all 4 tokens1(90%)050100050100(11, 3)100%1(85%)050100(10, 3)100%1(88%)050100(11, 4)100%1(86%)050100(11, 3)100%1(92%)050100(13, 3)100%1(84%)050100(10, 3)100%1(83%)050100050100(11, 4)100%1(92%)050100050100(12, 4)100%1(87%)050100(11, 4)100%1(90%)050100(11, 3)100%1(94%)050100(11, 3)100%1(88%)050100(11, 3)100%1(91%)050100(13, 3)100%1(85%)050100050100(12, 4)100%Fail0501000501000%Fail0501000%Fail0501000%Fail0501000%Fail0501000%Fail0501000%Fail0501000501000%1(89%)050100050100(11, 4)100%1(73%)050100(23, 11)98%1(66%)050100(28, 22)91%1(29%)050100(23, 15)56%1(35%)Fail050100(39, 26)67%1(6%)050100(26, 12)50%1(47%)050100050100(21, 12)74%25

Fig. 19. Method to measure clock cycles for receiving a packet and
acknowledging a received packet.

Fig. 20. Experiment setup and instrumented CRFID device used for
the experiments summarized in Fig. 5 and Fig. 7. Notably conducting
the experiments require a researcher to be seated next to the DSO. The
probes, the changing positions of the wires leading from the probes,
especially at different distances, and the orientation of the researcher
signiﬁcantly impacted these measurements.

repeated ﬁrmware updates to the four CRFID devices in
the rotor blades (as illustrated in the video https://youtu.
be/AVrf0rNM0z8). Here, as in other experiments, for each
ﬁrmware update, the Host makes 10 attempts to update
all 4 devices. The result in Fig. 21 shows that 3 updates
resulted in disseminating ﬁrmware to all four tokens, and in
51 updates, at least one token is updated. We can conclude
that updating ﬁrmware to mobile CRFID devices is possible
but the success rate can be expected to reduce dramatically.

Fig. 21. Attempt to update ﬁrmware while the UAV rotor is rotated by
hand at approximately 1 RPM. The pie chart shows the number of CR-
FID devices updated in the 100 repeated ﬁrmware update executions.

RFIDreaderObservertokenSave dataPilot tokenSave dataPrepare reply  (e.g., compute CRC)Send replyBreakpoint 2Breakpoint 1Breakpoint 3Digital storage oscilloscope (DSO)CRFID device (token)ProbesProbesResearcher sits here to operate the  DSOWiresconnectingprobes to the DSOto theRFID readerRF cableProbes to measure harvested voltageand the internal state of CRFID deviceTokens successfully updated0 token1 token2 tokens3 tokens4 tokens49%(7%)(29%)(12%)(3%)