0
2
0
2

r
p
A
9
2

]

R
C
.
s
c
[

2
v
2
4
4
2
1
.
4
0
0
2
:
v
i
X
r
a

Airmed: Efficient Self-Healing Network of Low-End Devices

Sourav Das∗
University of Illinois at
Urbana-Champaign
souravd2@illinois.edu

Samuel Wedaj
Department of Computer Science and
Engineering., Indian Institute of
Technology Delhi
samuel.wed@cse.iitd.ac.in

Kolin Paul
Department of Computer Science and
Engineering., Indian Institute of
Technology Delhi
kolin@cse.iitd.ac.in

Umesh Bellur
Department of Computer Science and
Engineering, Indian Institute of
Technology Bombay
umesh@cse.iitb.ac.in

Vinay Joseph Ribeiro
Department of Computer Science and
Engineering, Indian Institute of
Technology Bombay
vinayr@iitb.ac.in

ABSTRACT
The proliferation of application specific cyber-physical systems
coupled with the emergence of a variety of attacks on such systems
(malware such as Mirai and Hajime) underlines the need to secure
such networks. Most existing security efforts have focused on only
detection of the presence of malware. However given the ability
of most attacks to spread through the network once they infect a
few devices, it is important to contain the spread of a virus and at
the same time systematically cleanse the impacted nodes using the
communication capabilities of the network. Toward this end, we
present Airmed - a method and system to not just detect corrup-
tion of the application software on a IoT node, but to self correct
itself using its neighbors. Airmed’s decentralized mechanisms pre-
vent the spread of self-propagating malware and can also be used
as a technique for updating application code on such IoT devices.
Among the novelties of Airmed are a novel bloom-filter technique
along with hardware support to identify position of the malware
program from the benign application code, an adaptive self-check
for computational efficiency, and a uniform random-backoff and
stream signatures for secure and bandwidth efficient code exchange
to correct corrupted devices. We assess the performance of Airmed,
using the embedded systems security architecture of TrustLite in
the OMNeT++ simulator. The results show that Airmed scales up
to thousands of devices, ensures guaranteed update of the entire
network, and can recover 95% of the nodes in 10 minutes in both
internal and external propagation models. Moreover, we evaluate
memory and communication costs and show that Airmed is effi-
cient and incurs very low overhead.

KEYWORDS
Device Correction; Internet-of-Things; Low End Devices; Malware
Containment.

1 INTRODUCTION
Application-specific low-end devices have become ubiquitous in
safety-critical systems such as hazard control, airplanes, nuclear
reactors, etc. A recent Gartner report estimates that there will be
more than 20 billion Internet-of-Things (IoT) devices by the end of

the year 2020 [2].1 As the use of such devices becomes imperative in
mission critical systems, their security is of immense concern [30].
Attacks on a nuclear power plant using Stuxnet [39], large scale
Distributed-Denial-of-Service (DDoS) attacks using IoT Botnets
such as Mirai and Hajime [7, 29], potential disruption of power-
grids using high wattage devices [37], and malware which can
rapidly spread citywide using deployed Phillips hue bulbs, illustrate
the importance of ensuring that such networks are secure and/or
can recover quickly and cheaply from attacks [33].

Existing security research on low-end devices only focuses on
detecting the presence of malware using Remote Attestation (RA) [5,
8, 36] and Machine Learning (ML) [10, 20]. RA allows a trusted
verifier to detect a compromised device or network of connected
devices. Similarly, the core idea behind the ML-based detection of
an attack is to train an ML model with historical network traces
and use inferences to detect network intrusion in real-time.

Although these approaches are useful, their scope is limited.
This is because, corrupt devices can not only malfunction, they
can even spread the malware to other nodes. Furthermore, as we
illustrate (ref. §5) an intelligent adversary can fatally prevent a
significant fraction of honest nodes from correcting themselves
via updates. Existing approaches fail to restrict a self-propagating
malware from compromising the entire network [7, 11, 18, 29, 33].
Also, they do not tackle how to recover a compromised device in
the presence of a root privileged adversary. A naive scheme of
deploying a vulnerability patch over the network to update the
corrupt device would not work because an adversary with access
to the incoming network messages can simply drop the update
messages. Finally, such efforts also make strong assumptions such
as the trusted party can communicate with the network at all times;
corrupted devices voluntarily communicate with a trusted party,
and so on that rarely hold in real cyber-physical networks.
Motivated by the above, we answer the following questions:

•

•

How to securely and efficiently detect the presence of a self-
propagating malware (including zero-day attacks) in a network
of heterogeneous low-end devices?
Once malware is detected, how to prevent it from spreading to
the entire network and how to securely heal the corrupt devices
in a decentralized manner without the intervention from an
external trusted party while ensuring minimal overhead?

∗Part of the work was done when the author was at IIT Bombay

1We use the terms “device” and “node” interchangeably in the paper.

1

 
 
 
 
 
 
As our solution, we present Airmed2, the first decentralized
mechanism to recover a heterogeneous network of low-resource
cyber-physical systems (CPS) in the presence of self-propagating
malware. In addition to device correction, Airmed further assists
in the critical issue of over-the-air code updates. Specifically, it
ensures that all devices in the network get updated. We would like
to emphasize that, to ensure that our solution remain applicable in a
more general sense, we deliberately avoid implementation specific
details of IoT devices and study the problem in abstract sense.

At its core, every device in Airmed performs a periodic self-
check of the application that the device is running. Airmed assumes
(readily available) minimal hardware support for the self-check [1,
17, 27]. During the self-check, if a device detects that it has been
corrupted, it disables the execution of its application code. Then
the device seeks assistance from its neighbors to recover itself with
the correct/updated code. We refer such a device as blank device.
Although, execution of applications are disabled in a blank device,
we ensure (ref. §2.2) that it can still communicate with its peers and
run the recovery protocol.
Challenges. The resource-constrained nature of low-end devices
raises a series of challenges in designing secure and efficient cor-
recting protocols. First challenge is to reduce the trade-off between
bandwidth usage and delay in the correction. Specifically, if a de-
vice has N neighbors, the procedure of asking each neighbor to
transmit the correct application program has a high bandwidth cost.
Alternatively, asking the neighbors transmit the correct applica-
tion in a round-robin manner can lead to long delay in correction.
Furthermore, these approach also introduces security vulnerability,
as a malicious neighbor can send an incorrect application code to
exhaust the bandwidth resources of an honest device.

Second challenge arises due to the fact that each self-check is
expensive and involves interrupting normal execution flow. Hence,
we want self-checks to be rare, but a rare self-check will allow the
malware to stay undetected for longer duration leading to a faster
spread.

A third challenge is to efficiently identify the modified portion
of the application code to avoid downloading the entire application.
This can significantly reduce the bandwidth overhead in devices
with large application code. Naive approaches, such as storing a
hash of chunks of the application code in a secure memory, increases
the size of secure memory. Alternate approach of participating
in an interactive protocol as in [23], requires O(log z) rounds of
communication in the worst case to identify a single modified code
chunk from a total of z chunk.

Additional challenges include efficient authentication of mes-
sages to prevent replay attacks, identifying appropriate and realistic
network constraints to ensure that a blank device can communicate
with its neighbors. We address all of these challenges in this paper.
In summary we make the following contributions:

•

We present Airmed, the first decentralized, secure and a resource-
efficient mechanism that ensures recovery of devices in the
presence of a self-propagating malware in a heterogeneous
network without the intervention of a trusted entity. We also

2Goddess of healing (in Irish mythology), known for her prowess in healing those who
fell in battle [3].

2

•

•

demonstrate that Airmed mitigates several critical limitations
of prevalent secure device update schemes.
We perform a rigorous theoretical analysis of various mecha-
nisms used in Airmed and illustrate their efficiency over naive
schemes. We prove that Airmed guarantees the recovery and
update of all the devices and under specific assumptions.
We present a thorough empirical analysis of Airmed with mul-
tiple topologies using OMNeT++ simulator. Our evaluation
illustrates that Airmed can scale to 1000s of devices, heal 95%
network in 10 minutes, and guarantee update of the entire
network, while ensuring low overheads.

Organization. We present the System Overview, Threat Model
and Required Connectivity in §2. Details about device initialization
and network setup are given in §3. §4 presents our detailed design
of device correction followed by details of code update in §5. We
then, theoretically analyze our design choices in §6. Simulation and
Evaluation details are given in §7 and §8. A few related works are
described in §9. We finally conclude with a discussion in §10.

O

2 SYSTEM MODEL
We consider a connected network of N low-end devices, where ith
device, ni , runs a set of applications Bi . Further, we allow devices to
store binaries Ci (.bin files) of other applications and transfer these
Ci .
binaries on request from a device connected to it. Let Ai = Bi ∪
All devices and the associated binaries are initialized and deployed
by a trusted third party
. As devices often have heterogeneous
resources such as memory, bandwidth, and power, based on the
resources available at these devices, we classify them into Low
Resource (LR) and High Resource (HR) devices. A LR device only
communicates with the devices it is directly connected to; such as
devices in its wireless transmission range. Furthermore, LR device
only responds to a code request of a neighbor if and only if it already
possesses the requested data. In contrast, HR devices can employ
fault-tolerant routing algorithms such as Ariadne [21], SAR [44]
to communicate with HR devices through a sequence of other HR
devices. Also, HR device forwards all kinds of messages as long as
it can validate the signature that the message carries. Note that,
Airmed will also work in network with only LR or HR devices as
long as the connectivity requirement specified in §2.3 are satisfied.

2.1 Threat Model
A device is called corrupt if any of its binaries from Ai is modified
by an adversary
. Similar to existing works, we consider software-
only-attacks [5, 8, 17]. Hence, at the application layer, a corrupt
device can arbitrarily deviate from the specified Airmed protocol.
Also,
can drop arbitrary network packets that arrive or leave a
corrupt device. Next, based on the malware propagation model, we
into two categories: Internal and External.
classify

A

A

A

With an internal adversary, we assume

has, at time 0, cor-
rupted f fraction of devices. Each corrupt device, say ni , spreads
the malware as follows. First, ni chooses one of its neighbors at
random, waits from a time-interval drawn from an exponential
distribution with parameter λint and corrupts the chosen neighbor.
If the neighbor is already corrupt, its state remain unchanged. All
corrupt devices independently repeat this process for the entire
duration they remain corrupt. Intuitively this model captures the

A

setting where a corrupt device repeatedly tries to corrupt a ran-
domly chosen neighboring device and in each trial it successfully
corrupts the device with tiny probability. Such a model approxi-
mately captures the true propagation of a malware [42, 45].

Alternatively, an external adversary corrupts a device by directly
connecting to it, and not through one of its neighbors. Specifically,
first chooses a random device from the network and waits for a
A
time drawn from an exponential distribution with parameter λext
repeats this till it is forcefully
and corrupts the chosen device.
A
disconnected from the network. Such an adversary captures prox-
imity attacks where the attacker enters the wireless range of the
victim and corrupts it [33].

2.2 Hardware Modules
We next describe the memory organization and communication
requirements of devices in Airmed. This memory organization is
already considered in embedded trust anchors such as SMART [17],
TyTAN [13], and TrustLite [27]. TrustLite and TyTAN have been
implemented on Intel’s Siskiyou Peak research architecture [1].
Memory Organization. The memory of each device is divided
into four parts where each part serves a distinct purpose and has dif-
ferent access control. The first part is the Read-Only Memory (ROM)
whose contents are fixed during manufacturing and are indepen-
dent of the application running on the device. ROM stores all proce-
dures required for secure execution of the Airmed protocol. ROM
is executable, and its contents are publicly accessible. One crucial
thing to note is that procedures present in ROM can be only in-
voked starting at designated pre-specified entry points and are
executed atomically without any interrupts.

The remaining memory regions are non-volatile and are divided
into three parts: code, data, and SecRAM region. code region is
executable, stores all application binaries, i.e., Ai of device ni . The
data region is non-executable and is used to store data, and run-
time environments such as stack and heap for both procedures in
both code and ROM regions. Hence,
can run modified binaries
only if they are stored in the code region.

A

A

Lastly, SecRAM (Secure RAM) is non-executable and is inaccessi-
ble to procedures present in code. SecRAM is used to store mission-
critical mutable data that needs protection from
. We achieve
this property using Execution Aware Memory Access Control (EA-
MAC) introduced in SMART architecture and later improved by
TrustLite [27]. EA-MAC enforces read/write controls depending
upon the address of the instruction that is currently being exe-
cuted. During secure boot of a device, EA-MAC allows a user to
specify tuples of memory range say (c, m) with the semantics that
memory range m can only be accessed by instructions present in
memory range c. For example, TrustLite achieves EA-MAC through
its Memory Protection Unit (MPU). Figure 1 summarizes the memory
organization of Airmed along with their access permissions.
Communication Stack. In Airmed, we require blank devices to
communicate. We achieve this using the fact that low-end devices
are often equipped with separate micro-controller for the network-
ing stack. For example, SimpleLink Wi-Fi CC3000 connectivity
module from Texas Instruments is one such commercially available
micro-controller with separate networking stack. CC3000 supports
IEEE 802.11 b/g and has an embedded IPv4 TCP/IP stack [15]. As

3

(a)

(b)

Figure 1: Figure (a) illustrates the memory layout of each device. Ta-
ble (b) summarizes the read-write permission of each memory re-
gion. For example, read and write access to SecRAM is only given to
network operator

, and the code present inside ROM.

O

networking stack can be isolated from the underlying application
or operating system that the device is running, we assume that
the networking micro-controller and the software inside it remain
functional in a blank device and communicates as follows.

Figure 2: Proposed architecture of a device for enabling a blankde-
vice to communicate with the network. The gray message handler
belongs to the running application and can be corr. However, the
message handler stored inside the ROM is immutable.

Let NIC (Network Interface Card) denote the micro-controller
managing the networking stack. When the device is honest, all
incoming messages are first handled by the Message Handler of
the application or the operating system (OS). Then it is the respon-
sibility of the application’s message handler to invoke procedures
from ROM whenever a message is intended for ROM. However, in
a blank device, procedures in ROM directly communicate with the
NIC module using the secure message handler stored inside ROM.
Figure 2 illustrates this architecture.

2.3 Connectivity and Network Requirements
For any given application b, the basic requirement of Airmed is that
a blank device for b should be able to heal itself as long as there exist
one honest device in the network that has b. A necessary condition
to achieve this is that the induced sub-graph formed by devices
with code of b and devices through which they can communicate is
connected. To see why, consider the example in Figure 3 containing
. Devices n1 and n3 are HR devices running
three devices
application b1 and device n2 is an LR device running application b2.
In this network, if n1 gets corrupted, it cannot correct itself despite
the presence of a correct application code at n3. This is because
device n2 will refuse to forward messages from n3 to n1.

n1, n2, n3}
{

Figure 3: A network of three devices
HR devices running application b1 where n1 is corrupted by
is a LR device running application b2.

where n1 and n3 are
. n2

n1, n2, n3 }

A

{

Generalizing the above, any given network G =

V , E
must
⟨
meet the following requirement. Let V ′b ⊆
V be the set of devices
that either runs or stores application b. Let Hb be the set of HR

⟩

Anonymoussubmission#9999toACMCCS2019(a)Regionreadperm.writeperm.executabledataeveryoneeveryonenoSecRAMROM,OROM,OnocodeeveryoneeveryoneyesROMeveryonenoneyes(b)Figure1:Figure(a)illustratesthememorylayoutofeachdeviceinD￿￿￿￿.Table(b)summarizestheread-writepermissioncorrespond-ingtoeachmemoryregion.Forexample,readandwriteaccesstoSecRAMisonlygiventoOandthecodepresentinsiderROM.separatemicro-controllerwithindependentnetwork-interfacecardareused.SimpleLinkWi-FiCC3000connectivitymodulefromTexasInstrumentsisonesuchcommerciallyavailablemicro-controllerwithseparatenetworkingstack.CC3000supportsIEEE802.11b/gandhasembeddedIPv4TCP/IPstack[19].Asnetworkingstackscanbeisolatedfromtheunderlyingappli-cationoroperatingsystemthatthedeviceisrunning,weassumethatthenetworkingmicro-controllerandthesoftwareinsideitremainfunctionalinablankdevice.Thisensuresthatevenblanknodescancommunicatewiththeirneighbors.Atthispoint,itisimportanttonotethat,wedonotmakeanyassumptiononnetwork-ingwhenthedeviceiscompromised.Thisisbecauseancorruptoperatingsystemcanalwayspreventmessagesfromgettingdeliv-eredtotheuser-levelapplications.Nextwesuggestanarchitecturalchangesinlow-enddevicestorealizetheabovementionedassump-tionswithminimaloverhead.RecallcorecomponentofD￿￿￿￿’scorrectionmechanismre-quiresexchangesofmessagesbetweenfunctionsstoredinROMofneighboringdevices(see§??).Eachsuchmessagehandlingrequirescontextswitchingoutoftheoperatingsystemandinvokingfunc-tionsfromROMandswitchingbacktoOSonceROMexecutionterminates.Ascontextswitchinghashigh-overhead,wewanttocontextswitchonlywhenmessagesareaddressedtoproceduresinROM.Keepingthisinmind,weproposethefollowingarchitectureforhandlingincomingmessages.LetRFdenotethemicro-controllerthatmanagesthenetworkingstack.Onreceivingamessagemsgfromthenetwork,RFwritescontentsofthemsgintoasharedbu￿erbufandgeneratesaninterrupt.Onsuchinterrupt,thehardwareprocessortransfersthecontroltotheinterrupthandler.ThisinterrupthandleriscontrolledbytheOSinaOSbaseddeviceorbytheapplicationitself.Interrupthandler￿rstchecksthedestinationofthemsg.IfmsgwasaddressedtotheproceduresinROM,theinterrupthandlerinvokesproceduresinROMbyjumpingtodedicatedROMentrypoint.Otherwise,interrupthandlerhandlesmsginaregularmanner.WeillustratesthisinFigure2.Notethat,intheproposedarchitecture,unlessthemsgisaddressedtoROMprocedures,handlingmessagesdonothaveanyextraoverhead.Withourproposedarchitecture,D￿￿￿￿allowsblanknodestoreceivemessagesbyoverwritingtheinterrupthandlerwithaseriesofNoOps(nooperations).HenceeverymessageinablanknodewillbedirectlyhandledbythefunctionsinROM.Lastly,tosendamessage,D￿￿￿￿hasaprocedureinsideROMthatwritesintosentbu￿eroftheRFandaskittotransmitthemessageaccordingly.Interrupt	Handler1.	receive	 from	networkBuffer	2.	store	 in	buffer	3.	generate	interruuptProcessor4.	Change		to	interrupt	handler5.1.	If		for	5.2.	If		not	for	EntryFigure2:Stepstakenduringparsingamessagemsgfromthenet-workwhentheOSishonest.SinceROMproceduresaretheonlyallowedexecutablesinablanknode,triviallyallmessagesinitiatedbyablanknodearetransmittedtothenetwork.2.2ConnectivityandNetworkassumptionsRecallthatbasedonresourcesavailableatadevice,weclassifythemaseitherHRorLRdevices.Therearetwoprimarydi￿erencebetweenaHRandaLRdevice:￿rst,LRdevicescommunicateonlythroughbroadcastwhereasHRdevicescanemployfaulttolerantroutingalgorithmssuchasAriadne[27],SAR[52]etc;second,weassumethatLRdevicesdonotoperateasarelaytoforwardD￿￿￿￿relatedmessage.Speci￿cally,LRdevicesrespondsonacoderequestofaneighbornodeifandonlyiftheLRdevicealreadyhastheneededdata.Alternatively,HRdeviceforwardsallkindsofmes-sagesaslongasthedeviceisabletovalidatethesignaturethatthemessagecarry.Wenextdescribetheconnectivityassumptionsnecessaryandsu￿cientforD￿￿￿￿tohealtheentirenetwork.ConnectivityRequirement.We￿rstdemonstratethatwiththepropertiesofheterogeneousdevicesmentionedabove,itisimpos-sibletodesignaprotocolthatcorrectscorruptednodesinalltypesconnectednetwork.ThisholdstrueeveninthesettingwhereAdonotcorruptadditionalnumberofdeviceswithtime.Toseewhy,considertheexampledemonstratedinFigure3containingthreedevices{n1,n2,n3}.Figure3:Anetworkofthreenodes{n1,n2,n3}wheren1andn3areHRnodesrunningapplicationb1wheren1iscorruptedbyA.n2isaLRdevicerunningapplicationb2.Devicesn1andn2areHRdevicesrunningapplicationb1anddevicen2isaLRdevicerunningapplicationb2.Inthisnetwork,ifn1getscorrupted,itcan’tcorrectitselfdespitethepresenceofacorrectapplicationbinaryatn3.Thisisbecausenoden2willsimplyrefusetoforwardmessagesfromn3ton1.Thisdemonstratesthat,unlessadditionalassumptionsaboutthenetworkstructureareenforced,noprotocolcanguaranteerecoverabilityofthenetwork.Alternatively,ifthefollowingadditionalsetofconditionsholdinanetwork,D￿￿￿￿cancorrecteverycorrupteddevicegivenacorrectbinaryexistinthenetwork.4Message	HandlerBuffer	ProcessorEntryMessage	HandlerNetworkMemorydevices in G that are connected to at least one device in V ′b
either
Hb and
directly or through a sequence of HR devices. Let Vb = V ′b ∪
G be the induced subgraph of G with the vertex set Vb .
let Gb ⊆
We prove in Theorem 6.4 that Airmed can correct all applications
whose Gb forms a connected component and at least one honest
device that stores program of application b exists in Gb under some
specific assumptions. In our example in Figure 3, Gb1 consisting
of device n1 and n3 is not connected. Hence, for Airmed to be
most effective, network designer must ensure that Gbi for all i are
connected, which can be achieved by first creating a spanning tree
among devices running same application and later add more devices
to the spanning tree.

|

|

|

{

M

←

0, 1

m
|

ℓ denote the set of all bit strings of length ℓ.

denote the number of elements in a finite set M. If m is a inte-
means the bit-length of m. Furthermore,

2.4 Notations
Let
ger (or bit string), then
let
}
attest(k, d) is an algorithm that takes an input
Attestation. v
k, a bit string d and computes a deterministic digest v of the d.
Also, attest guarantees w.h.p 3 that for any pair of keys k, k ′ and
data d, d ′, attest(k, d) =attest(k ′, d ′) iff k = k ′ and d = d ′, where d
corresponds to the contents of the code region.
Signature. A signature scheme is a tuple of probabilistic poly-
keygen(1ℓ)
nomial time algorithms (keygen, sign, ver). (pk, sk)
N. sk and pk are the signing and verification key respec-
where ℓ
∈
sign(sk, d) is the algorithm to sign string d using key
tively, σ
←
sk. Lastly, ver(σ , d, pk)

is the verification algorithm.

0, 1

←

Unless otherwise stated, throughout the paper we use cert(d) to
, d) and verification of cert(d) implies verification
, public key of the operator

denote sign(sk
of the signature using pk

O

.

∈ {

}

O

O

O

3 NETWORK SETUP
3.1 Device Initialization
The ROM of each device stores the functions involved in malware
detection and device correction, and is initialized at the time of
manufacturing. This can be easily extended to the setting where
contents of ROM can be modified using a hardware switch present
in the device. Hence,
instantiates the remaining regions of mem-
ory. Executable files of all applications in Ai are stored in the code
region. SecRAM of each device is initialized with pk
, a freshly
generated asymmetric key pair (pki , ski ) unique to ni along with
the certificate cert(pki ). For each application in Ai ,
stores their
version numbers ver(Ai ), cert(ver(Ai )), and cert(Ai ) in SecRAM.
The reason behind storing these certificates is to allow the device
to prove correctness of its code to other devices in the network.
also initialize each device with the self-check rate λ, the
Lastly,
maximum allowable self-check rate λmax, and the minimum allow-
able self-check rate λmin. A detailed description of these self-check
rates are given in §4.

O

O

O

Once initialized, each device locally generates a cryptographic
symmetric key ki , attest key aki , and a sequence key qi as uni-
ℓ. The attest key is
formly distributed random numbers in

0, 1

{

}

3For any security parameter ℓ > 0, an event happening with high probability w .h .p
o(1/poly(ℓ)). Here poly(ℓ) refers
implies that the event happens with probability 1
to class of all polynomials with parameter ℓ.

−

4

used to compute attestation over the contents of code, and qi is
used to prevent replay attacks. Let vi be the output of the attesta-
tion procedure. ni next generates a set of keys L, of size κ =
L
,
|
which is used to initialize a bloom filter F of size µZ /t. Here Z is
the size of the code region whose contents are divided into chunks
of size t bits each. Refer [26] for more details of bloom filters.

|

3.2 Device Rendezvous
Every device in the network periodically announces itself to other
devices in its transmission range by broadcasting a hello message.
On hearing a new device, say nj with public key pkj , device ni
rendezvous with it to validate each other’s certificate cert(pki ) and
cert(pkj ). On successful validation, they securely exchange their
keys (qi , ki ) and (qj , kj ). As a device rendezvous with other devices
only once, the key exchange mechanism can be realized using
the key-exchange scheme of TLS 1.3 [12]. Let Ni be the set of all
devices in ni ’s transmission range with whom ni has rendezvous
with, hereon we refer to the devices in Ni as the neighbors of ni .
Hence at the end of rendezvous, ni will have a set of
Ni .
Note that, in our scheme, each device shares the same key with all
its neighbors. We do this primarily for efficiency. This can be easily
extended to establish a unique symmetric key between each pair of
devices. Table 1 summarizes the memory contents of each device
at the end of initialization and rendezvous.

kj , qj }∀
{

∈

j

Table 1: Memory content of a device after initialization and device
rendezvous phase.

Region

Manufacturing/Initialization

Rendezvous

SecRAM

code
ROM

O

pk

, (pki, ski ), ver(Ai ), cert(Ai ),

cert(pki ), cert(ver(Ai )), λi , λmin, λmax
ki , qi , (aki, vi ), F
Ai
selfcheck(), attest(), sign(), rectify(), . . .

kj, qj

{

}

4 DESIGN OF AIRMED
At a very high-level, correction of a corrupt device in Airmed
involves the following steps. Each device periodically initiates a
self-check procedure to detect whether it is corrupt or not. In case
the device is found to be corrupt, its hardware disables execution
from its code region. Then the device queries its neighbors for a
correct application code. We next look at each of these procedures
in detail.

4.1 Detecting Malware
Every device performs periodic self-check with the time interval
between two consecutive self-checks chosen from an exponential
distribution with parameter λ. As expected value of exponential
distribution with parameter λ is 1
λ [32], the expected time between
two consecutive self-check is 1
λ . We pick time intervals from an
exponential distribution due to their memoryless property [32].
As the rate of propagation of malware depends crucially on the
time a device remains infected, memoryless self-checks will pre-
vent
from strategically infecting devices to increase the duration
for which the device remain corrupt. Furthermore, memoryless
self-checks prevents a mobile adversary from evading detection by
uncorrupting a infected nodes just before the next self-check [31].

A

}

{

λ

←

exp

Let δ
be one such realization of the time interval. Start-
ing from last self-check, δ is decremented by one in every clock
cycle. When δ reaches zero, the processor generates a hardware
interrupt. On this interrupt, the processor pauses the running appli-
cation, records the run-time state of the application in a non-volatile
memory and invokes selfcheck() procedure from ROM. Also, all
interrupts are disabled to allow atomic execution of selfcheck.

{

λ = 1

Procedure selfcheck() first invokes procedure attest() with its
input as aki and entire contents of the code region. Let v ′i be the
attestation result. If v ′i equals to vi , i.e., the contents of code are
not tampered, Airmed increments the expected wait time between
self-checks, that is 1
λ + 1 as long as it does not exceed a pre-
λmin, λ/(λ +
defined upper bound. In other words, it sets λ to max
1)
. Next, interrupts are enabled and the control is given back to
}
= vi implies modification of
the application. On the contrary, v ′i ̸
the application code. In such a situation, instead of resuming the
application, selfcheck sets a hardware bit to make the code region
non-executable, and invokes rectify(), another secure procedure
from ROM. The pseudocode of selfcheck() is given in Algorithm 1
where we use [code] to refer to the contents of the code region.
Malware localization. Once the tampering has been detected, the
next goal is to identify the tampered region of the code to avoid
downloading the entire application program. A naive approach of
dividing the entire [code] into chunks of size t and storing hash
of each chunk in SecRAM has high memory usage. Specifically, if
, than this approach would require storing ℓZ /t bits of
Z =
additional storage in SecRAM, where ℓ is the size of the output of
the hash function.

[code]

|

|

In Airmed we reduce this storage overhead through novel use
of bloom-filters. Recall from (§3.1), that a µZ /t bit long (for small
constant µ) bloom filter F is initialized with partitions of [code] us-
ing the set of secret keys L. Hence, to localize the malware, rectify()
finds all chunks that are absent in F . The idea is, since
is un-
aware of keys in L, the chunks modified by the adversary will most
likely be absent in the F and hence will be detected by rectify(). For
example, in Figure 4, adversary modifies ith chunk to c ′i , which is
absent in the filter F . As a result, instead of the entire application
code the blank device will query its neighbors only for the chunks
that are marked as absent in the bloom filter.

A

Figure 4: Adversary modifies i th chunk to c ′i which is absent from
the filter F .

However, since bloom filters have non-negligible false positive
rates, it is possible (albeit rarely) that rectify() fails to identify all the
modified chunks. In such situation, the blank device downloads the
entire application program. Also, we we keep t and number of keys
in L parameterizable that can be picked for any desired false positive
rate. For example, with Z = 16384, i.e., 16KB of executable memory,
which is typically the case in MSP430 micro-controllers [15], µ = 8,
= 4, and Z /t = 32, we show in §8.3 that a blank device will
L
|
download the entire application program less than 2% of the time.
Refer to [32] for detailed analysis of false-positives in bloom filters.

|

Once the corrupted chunks has been identified, interrupts are
re-enabled. We call a device with disabled execution as a blank
device. Recall (ref. §2.2), in all blank devices all incoming messages
are directly handled by functions in ROM (ref. §2.2).

4.2 Correcting blank Devices
The basic idea of correction is that once a device ni becomes blank,
it asks one of its neighbors to send the correct version of the com-
. ni on receiving
promised code along with the certificate from
these chunks validate their correctness by checking the certificate
from
. On successful validation, it installs them in its code region
and starts normal execution of the application program. Further,
in scenarios where devices in Ni are running different versions of
the code, it is desirable to download the most recent version of the
application among all available versions. Here we are implicitly as-
suming that recent versions of application programs have a higher
version number.

O

O

A naïve approach is to send a message to each neighbor and
request for the necessary chunks of code. On receiving the applica-
tion programs from each neighbors, ni locally identify the highest
version, validates it and then installs it. This approach is bandwidth
inefficient as it requires each neighbor to transmit all codes, which
might be relatively large in a resource constrained setting.

⊆

An alternate approach is to first ask neighbors for the version
number of application b they are running, and then request the
neighbor running the highest version to send the code. Although
this approach is bandwidth-efficient, it has several limitations. First,
this approach does not protect ni from requesting code from a ma-
licious neighbor that might deny or delay the response to the code
request by merely dropping or delaying the code request message.
Further, in the case of dense network the cost of transmitting so
many version messages could still be overwhelming. Also, none
of these approaches prevent a corrupt device from sending spu-
rious version and code request to honest devices and drain their
bandwidth and computation resources.
[Z ] denote the set of corrupt chunk
Our Approach. Let Π
indices at the blank device ni . For simplicity, let us assume that
all of the corrupted chunks belong to a single application b with
its version being zi =ver(b). Also, let us assume that Π includes all
modified indices, i.e., there is no false positive due to the bloom filter.
Let N (b)
Ni denote the set of devices among neighbors which are
in Gb , i.e., the induced subgraph of G for application b (ref. §2.3).
We assume that ni is unaware of the identities of devices in N (b)
.
To request correct code, ni broadcast to its neighbors a mes-
Ni |
as its payload. Unless
sage MSGreq with
otherwise stated, we assume that all messages are tagged with a
message Message Authentication Code, source of messages can be
established for every message transmitted in the wireless range,
and sequence number qi is incremented by ni after every message.
Tag req in message payload specifies that this message is to request
for binaries. Sequence number qi assists devices in Ni to establish
validity and freshness of MSGreq.
Adaptive self-check rate. Each honest device nj ∈
ing MSGreq first updates its self-check rate as:

Ni on receiv-

, zi , b, Π
⟩

req, ttl, qi ,

i ⊆

⟨

i

|

5

λ

←

1ttl>0 min

2λ, λmax}

{

+ 1ttl

0λ

≤

(1)

1101110Bloom	Filter	where 1x is a indicator function which is equal to value 1 if x is
true and 0 otherwise. ttl in the message payload is the parameter to
limit broadcast of device corruption message. Additionally, when
ttl > 0, device nj broadcasts a warning message to all its neighbors,
i.e., devices in Nj informing about corruption of ni with parameter
Ni updates their
ttl
self-check rate according to equation 1 and recursively forwards it
to their neighbors as long as ttl reaches zero. Figure 5 (a) and (b)
illustrates the self-check rate of neighbors of n3, before and after
n3 broadcasts MSGreq with ttl = 1.

1. Similar to devices in Ni , devices in Nj \

−

Figure 5: Self-check rate of neighbors of a device n3 before (a) and
after (b) n3 broadcasts MSGreq with ttl = 1. As a result, honest neigh-
bors n1, n2 and n5 updates their λ using equation 1. Also, n3 sets its
own self-check rate to λmax.

Code transmission with random-backoff. To address the issue
of redundant code transmission, each neighbor nj of a blank node
ni , performs a uniform random-backoff with backoff delay τj as:
zi ), 0

τj = max

(0, 1)

θ +

(2)

∆

θ

Ni |

}|

⌊U

Ni |⌋

|

(zj −

−

{

U

where ∆ estimate of maximum difference in version numbers among
devices running a particular application. Similarly, θ is a protocol
parameter denoting the approximate upper bound on time required
to transmit the requested chunks, zj is the version number of b
(0, 1) is a value chosen uniformly randomly between
at nj , and
(0, 1). The intuition behind this approach is two fold: first, we prior-
itize responses from devices running a higher version of the same
application; second among devices running the same version of the
application, we aim to spread the time when these device transmits
the requested chunks. Device nj only starts the timer if zj ≥
zi ,
otherwise nj simply discards the message. Figure 6 illustrates the
the distribution of transmission time at neighbors of n1. Pseudocode
in 2 describes the steps taken by each device in Ni .

Figure 6: Distribution of time at which neighbors of blank node n1,
i.e., N1 =
transmits the requested chunks of code.
{
Here, ∆ = 1,
= 4, node n5 is corrupt, version of n2, i.e., z2 = 2 and
all remaining node has version 1. Red dot on the time axis in each
graph, is one realization of the transmission time.

n2, n3, n4, n5 }
N1 |
|

N (b)
i

Without loss of generality, let nj ∈

be the honest device
with smallest back-off interval τj among all honest devices in N (b)
.
Once τj expires, nj sends a single chunk to ni and waits for an
acknowledgement from ni . On receiving the acknowledgement
message from ni , nj sends the remaining chunks. If more than one

i

honest device simultaneously sends the first chunk, ni sends ac-
knowledgement to only one of them. We present a detailed analysis
of such scenarios in §6.2.
Stream Signatures. If we use a signature scheme in which a blank
device ni must receive all chunks before verifying their signatures,
it will allow an adversary to waste a lot of bandwidth by sending
invalid chunks and ni will not know they are invalid till the very end.
We mitigate this attack using on-line variant of stream signature
, signs first
introduced in [19]. In stream signature, the signer
chunk and embeds in each chunk ci the hash of the next chunk ci+1.
Figure 7 illustrates this. As a result, a bogus chunk can be detected
immediately.

O

Figure 7: In stream signature messages are divided into chunks and
each chunk (except the last chunk) contains the hash of the next
chunk, i.e., ci contains H(ci +1). The signer only signs the c1.

|

|

i

θ +

Ni |

Ni |

Lastly, once ni receives all chunks in Π, it broadcasts a MSGdone
to its neighbors indicating that it has successfully corrected itself.
Honest neighbors on hearing MSGdone cancel their back-off timers
(if any) corresponding to ni ’s code request. Alternatively, if ni do
θ , ni
not receive all the correct chunks within time ∆
rebroadcasts MSGreq with the updated Π after a time delay of δ
λ
drawn from exp
. Such as situation could possibly arise if either
}
{
all devices in N (b)
are running a lower version of b, or they are in
blank or corrupt state. Algorithm 3 presents the pseudocode for
handling a response to MSGreq message.
Fast Correction. Airmed also enables fast correction of a cluster
of blank devices. With solely the method just described above, if
the nearest honest device is r hops away, correction of di takes in
the best case an expected time of r /λmin. To enable faster correc-
tion, whenever a device nj is corrected, it immediately broadcasts
a message containing information about the corrected code, its
version number, and the corresponding certificates. On hearing this
message, blank device seeking the appropriate binaries can actively
request it from device nj . As a result, the corrected binaries spreads
through the network much faster without waiting for the timers of
blank devices to expire.

5 UPDATE OF APPLICATION BINARIES
So far we have only looked at how a compromised device self-
corrects itself with the help of its neighbors. We now consider the
behavior of the whole network that is running the Airmed protocol
specifically in situations where
updates the application program
O
executed with newer versions. To expound Airmed’s applicability
for updating binaries in a network of low-end devices we consider
a prevalent update technique motivated from [9, 28, 35], study it
in our threat model and show its limitations. We then make minor
modifications to the Airmed protocols described so far, and show
that Airmed when combined with this network update technique
overcomes these limitations. For brevity we will only focus on
the network Gb for a specific application b. This can be easily
extended to the entire network. Also, each newer version comes
with a monotonically increasing version number.

6

(a)		before	self-check	at	(b)		after	self-check	at	n1, . . . , n8 }
Figure 8: code update in a network of 8 devices
version v1 of the application. Let v2 > v1 be the updated version, then without a correction mechanism only
n1, n3, n4, n5 }
However, when deployed along with Airmed the entire network will get updated once n2 and n6 perform self-check (c).

with device n2 and n6 corrupt prior to update (a). Initially all device run the same
will be updated (b).

{

{

O

Consider the following recursive swarm update mechanism
of [9]. Here
first must find one device which is honest and then
update it with a newer version of the application. Finding an honest
device is important because a corrupt device can simply drop the
update messages. This originator device then updates its neighbors
and so on to form a virtual update tree.

neighborhood that are running an obsolete version of the applica-
tion. Stated differently, when n6 corrects itself it then behaves as a
new originator and updates n7 and n8 as shown in Figure 8(c). This
is analogous to a temporary pause of the original update procedure
due to adversarial devices in the path and its resumption later as
the devices enter the blank state as a part of the protocol.

This scheme has several shortcomings. First, in case a large
fraction of devices are corrupted,
may have to contact many
devices to find one honest one. Hence it allows malware to spread
for longer duration. Second, the above approach can only update
devices connected to the
through a sequence of honest device
and all other devices may still remain corrupted.

O

O

Suppose we use Airmed along with this recursive update pro-
cedure. Even if a large number of devices are corrupt, they will
become blank and then get corrected over time. Thus
has a higher
chance of encountering a device which is either blank or running
is in contact with κ devices (say
a correct application. In fact, if
O
in wireless communication range of them), then from elementary
probability theory, the expected time for at least one of them to
become blank is at least 1/((κ + 1)λmin)).

O

We now show how the second problem of the update scheme
in [9], namely the inability of the update to reach any corrupted
device, is solved. The update propagates on an honest virtual tree
as before. Consider a corrupt device which has a neighbor in this
tree. After it performs a self-check it becomes blank and then ob-
tains the latest version from its neighbors. We now make a minor
modification to Airmed. This device then acts like a new root and
propagates the latest version to its neighbors who are honest but
do not have the latest version. This increases the size of the virtual
tree running the latest version, until the virtual tree encompasses
the entire Gb . This is illustrated in the transitions of Figure 8.

n1, . . . , n8}
{

Let the network shown in Figure 8(a) be the Gb consisting of
for application b with v1 as the current version.
devices
Let n2 and n4 be the corrupted devices. With this initial state of
the network,
will successfully initiate the update procedure with
at-most two trials. Let v2 > v1 be the newer version of b. Without
any correction mechanism the update will fail to reach honest
device
. Also the corrupt devices will not be updated as
well. Figure 8(b) illustrates this.

n7, n8}
{

O

However, in Airmed, as soon a corrupt device performs a self-
check and detects that it has been compromised, it will download
the updated code from one of its neighbors. Further, it will forward
the information about the newer update to all the devices in its

7

|

|

|

|

L

L

6 ANALYSIS
6.1 Secure Memory Cost
Recall (ref. §3.1), for malware localization, Airmed uses a bloom
filter of size µZ /t and
keys for input to the hash function of the
bloom filter. Hence, Airmed stores ℓ
+µZ /t bits of information
in secure memory. Where as, naive approach of storing hash of
each chunk would have required ℓZ /t bits of memory. Next, with
the help of Table 1, we evaluate the size of SecRAM required to
store the remaining information for a single application. This can
be easily extended to multiple applications. Each device ni stores
two asymmetric public key, pk
and pki , one asymmetric private
O
key ski . Let
ski |
pk
= 1024. If each certificate is of size
|
|
256 bits, each device stores one certificate for its public key and
two certificates for each application. Also we use same number of
λmax|
λmin|
bits for all three self-check parameters, i.e.,
= 32.
Similarly, let ℓ =
qi |
ki |
= 128. Lastly, for each of its
=
|
|
neighbor in Ni , a device needs to store 256 = 2
128 for the shared
symmetric key and the sequence number. Summarizing the above,

pki |
|

aki |

vi |
|

O |

×

=

=

=

=

=

=

λ

|

|

|

|

|

SecRam

|

= 3

pk
|

|

|

+(4 +

L

|

|

)ℓ + 3

µZ
t

+

|

cert

|

+ 3

λ

|

|

+2

k
|

Ni |

||

(3)

6.2 Communication Cost.
The first major source of communication is due to the fact that
a blank device in Airmed only requests for the modified chunks.
However, as bloom filter has non-negligible false-positive rates
and it is possible (albeit rarely) that the bloom filter fail to localize
the malware. Thus for any given Z , t, µ and L, we compute the
expected number of chunks a blank device needs to download to
correct itself.

Let κ be the number of chunks modified by the adversary. Since,
the bloom filter keys are inaccessible to the attacker, from ele-
mentary cryptography, the attacker can not make strategic modi-
fications to evade the bloom filter check [26]. Hence, we assume
modifications of these chunks to be arbitrary. Let p be the false
positive rate for a single chunk; then with the above assumptions,
p = (1
|. Refer to [26] for more details.

/µ )|

e−|

L

L

|

−

Honest	device.	Not	updatedHonest	Device.	UpdatedCorrupt	DeviceLink	betweenHonest	&	CorruptSuccessful	updateLinkDevice	correctionLinkFailed	updateLinkLink	betweenHonest	&	Honest(a)	Network	state	before	update(b)	Post	update	state	without	correction.(c)	Post	update	state	with	correction.Theorem 6.1. Assuming hash functions are ideal, if an adversary
corrupts κ chunks from a total of Z /t chunks in a device which uses
bloom filter scheme of [26] with µZ /t bit filter and
hash functions,
then the probability that the blank device download the entire code is:

L

|

|

Pr[download entire code] = 1

1
− (

−

p

κ
)

(4)

Also, expected number of chunks the blank device will download is:

Z
t

(cid:0)1

1

p

κ (cid:1) + κ
)

1

(

p

κ
)

−

−

− (

(5)

Proof. Whenever, the device all κ modified chunks, it only
downloads κ chunks. This gives us the second term of equation 6.
Alternatively, even with a single false positive among κ chunks, the
device downloads all Z /t chunks. Combining this with equation (4),
□
we get the first term of our result.

The next source of communication improvement is due to the ran-
dom back-off procedure used for reducing the number of neighbors
that transmit the requested chunks. The following theorem (proof
in Appendix) illustrates that the expected number of neighbors that
will transmit the requested chunks.

Theorem 6.2. If a device has m neighbors, then the expected num-

ber of neighbors that transmits the requested chunks are
k (cid:0)m
k

1
m
(cid:88)
−

(cid:1)(m

j)(m

m(cid:88)

k )

−

(cid:33)

(cid:32)

−
mm

+

m
mm

j=1

k =1

(6)

6.3 Recoverability
Next, we theoretically argue that Airmed recovers and guarantees
update of the entire network in the presence of both internal and
external adversary under specific assumptions (Proofs in Appen-
dix C). For an heterogeneous network G =
of devices, we
define the graph Gb ⊆

V , E
⟨
G for application b as:

⟩

Definition 6.3. For any given application b, let V ′b ⊆

V be the
subset of devices that either runs or stores the application b. Let
Hb be the set of HR devices in G that are connected to at least one
device in V ′b
either directly or through a sequence of HR devices.
Let Vb = V ′b ∪
Hb . Then Gb is the induced subgraph of G due the
vertex set Vb .

Theorem 6.4. If Gb is connected and no additional device gets
corrupted after a given time t0 and there exits at least one honest device
running or storing application b at time t0, then Airmed corrects all
devices in Gb .

Theorem 6.5. If Gb is connected and if the update patching the
in at least one device in Gb ,
vulnerability is successfully initiated by
then Airmed guarantees update of the entire network in the presence
of both internal and external adversary.

O

×

O

Network Topology. We test Airmed on three different topology
with approximately 1024 LR devices each, with all devices run-
ning the same application. Our first topology is a connected Mesh
wireless network of 1024 devices spread uniformly across an area
4 km. Each device has a wireless transmission range of
of 4 km
200 meters around it. The intent behind this topology was to cap-
ture scenarios such as the ad-hoc deployment of sensor network
that are ubiquitous in Military application, agriculture, forest fire
monitoring system, etc. [24, 25, 40]. The remaining two topologies
we simulate are Binary and Ternary tree. We pick them to cap-
ture Industrial IoT, Building management etc [16]. In all the above
topologies, we use the same 20 ms average transmission delay be-
tween each pair of connected devices, as it is the average value in
connects
ZigBee sensor networks [38]. Lastly, during an update,
to a randomly chosen device and update it with a newer version.
Internal Adversary. To evaluate the effect of internal adversary
A int, for each the topology we corrupt f = 30% of the randomly
chosen devices to begin with. We also vary the malware propa-
gation rate, λint and the number of hops in the limited broadcast
to inform neighboring device about the presence of an adversary
in the network. For each topology, we consider two different ini-
tial configuration depending upon the positioning of the corrupt
devices. Namely, we consider configuration C0 and C1. In C0, the ini-
tial fraction of corrupt devices are distributed uniformly randomly
across the entire network. In C1, the corrupt devices form a single
island, i.e., corrupt device form a single connected network. To
create these initial configurations, we first enumerate all the device.
For configuration C0, we then pick f
unique device uniformly
randomly. For C1, we first select a device uniformly at random and
f device
starting at this chosen device; and then we pick up to
by performing breadth-first-search.
A ext corrupts uniformly
External Adversary. External adversary
randomly independent of the devices corrupted in the past. Unlike
A ext starting from network with
A int, we evaluate the effect of
all honest device. Also, we disconnect, i.e., disallow
A ext from
corrupting more devices after a specified period. In practice, one
A ext from further corruption by isolating it from
can disconnect
the internet. Let λext be the corruption rate of
A ext.
A ext corrupts
a randomly chosen device after intervals drawn from a exponential
distribution with parameter λext. Also, once
A ext is disconnected
from the network, no additional device gets corrupt.
Correction and Update For all our simulations, we use initial λ =
1/100, i.e., the average inter-arrival time between two consecutive
self-check is 100 seconds. To evaluate the network behavior with an
adaptive self-check rate, we run all our experiments with ttl = 0, 1, 4.
Note that, ttl = 0 is the baseline situation where neighboring devices
do not increase their self-check rate on hearing warning messages
from their neighbor. In all these experiments we keep λmax and
λmin to be 1/100 and 1/400, respectively.

N

N

|

|

|

|

7 SIMULATION
Since the cost of evaluating Airmed on a large scale network con-
sisting of thousands of device would be high, we test Airmed by
simulating it in OMNeT++ version 5.5.1 [4]. We simulate both inter-
nal and external malware propagation with update scheme of [9].

8 EVALUATION
All the results presented in this section corresponds to simulation
of Airmed for 1000 seconds. These results are averaged after 10
simulations with distinct randomness seed. Unless otherwise stated,
A ext are scheduled at 500 and
updates in the presence of

A int and

8

700 seconds respectively, from the start of the simulation.
A ext is
disconnected at time 300 seconds from the start of the experiment.

8.1 Internal Adversary

U0;

U1;

B0;

B1;

T0;

T1

s
e
c
i
v
e
d
f
o
n
o
i
t
c
a
r
F

0.3

0.2

0.1

0

0.3

0.2

0.1

0

0

200

400

600

0

200

400

600

time (in seconds)

(a) Corrupt

time (in seconds)

(b) Blank

Figure 9: Fraction of (a) corrupt and (b) blank devices in the pres-
A int with f = 0.30 and λint = λmax for configuration C0. Here
ence of
B0 and B1 refer to Binary Tree topology with ttl = 0 and ttl = 1 re-
spectively. Similarly, we use U0,U1 and T0,T1 for Mesh and Ternary
tree topology respectively.

Varying Network Topology. Figure 9a and 9b illustrates the frac-
tion of corrupt and blank devices respectively at any given time for
all three network topologies with configuration C0, initial corrupt
fraction f = 0.30, and λint = λmax. Notice that, for all three topolo-
gies, the fraction of corrupt devices starts decreasing almost from
the start of the simulation. This is because the effective malware
spread rate in these topologies are lower than λ. In Binary tree topol-
ogy, approximately half of the initial corrupt devices will be leaf
devices. All these devices only have one neighbor, and also often
this neighbor is shared between multiple corrupt devices. Hence,
these leaf devices will repeatedly try to corrupt an already corrupt
device. A similar situation arises in Ternary tree topology as well.
Further, the rate of reduction of corrupt devices closely follows
the tail of an exponential distribution. This is due to exponential
distribution of interarrival between consecutive self-checks. Notice
that the fraction of blank node in Mesh topology remains almost
zero for the entire duration, whereas it first increases in the tree
topologies and then decreases. Again, this is because approximately
half the devices in tree topologies have only one neighbor. Thus
these nodes cannot self-correct themselves unless their neighbor
corrects itself. Also, as expected, we observe a lower fraction of
corrupt and blank devices for ttl = 1 as devices will perform more
frequent self-checks and will recover sooner.
Adaptive self-check with varying Configuration. Figure 10
represents the time required for 95% of the network to become
correct, starting with 30% of devices being corrupt for varying
ttl = 1, 2, 4. Devices in C0 (solid lines) correct themselves quickly
than devices in C1 (dashed lines). This is because in C1, at any given
time, only devices positioned at the edge of the corrupted island
can correct themselves whereas devices positioned inside the cor-
rupt island need to wait for their neighbor devices get corrected.
Interestingly, non-zero ttl introduces a larger drop in correction
time in C1. This is because corrupt devices at the boundary of the
corrupt island share a considerable fraction of honest neighbors.
Hence, these honest devices perform faster self-checks as they will

update their self-check period more frequently. We do not see ma-
jor improvements from ttl = 1 to ttl = 4 due to the local nature of
malware propagation. One exception here is the Mesh topology in
C0. This was expected as each device in Mesh topology has a higher
number of neighbor and hence higher ttl cautions nodes farther
apart to update their self-check rate.

U-C0

U-C0

B-C0

B-C1

T-C0

T-C1

)
s
d
n
o
c
e
s
n

i
(

e
m
T

i

1,000

800

600

400

200

1,000

900

800

700

0

2

ttl

4

0

2

ttl

4

(a) λint = λmax

(b) λint = 2λmax

Figure 10: Time when 95% of the devices in the network becomes
correct starting from a initial fraction of 30% corrupt devices in Bi-
nary (B), Mesh (U), and Ternary (T) topologies for varying ttl. Solid
and dashed lines corresponds to C0 and C1 respectively.

Update with different Configuration. Figure 11 illustrates the
fraction of updated device over time in all topologies for configu-
ration C0 and C1 with f = 0.30. In all the experiments, eventually,
almost all devices get updated. In both C0 and C1, update in tree
topologies takes longer because, a single corrupt device can tem-
porarily stop updates in its entire subtree. Update in tree topology
for C0 takes longer time than C1, because corrupt devices are more
evenly spread across the network and hence code update temporar-
ily halts more often in C0. Ternary tree topology has a faster update
than Binary tree due shorter tree height and large average number
of neighbors.

B0;

B1;

U0;

U1;

T0;

T1

1

0.8

0.6

)
s
e
c
i
v
e
d
f
o
n
o
i
t
c
a
r
F

1

0.8

0.6

600

800

1,000

600

800

1,000

time (in seconds)

(a) Configuration C0

time (in seconds)
(b) Configuration. C1

Figure 11: Fraction of updated devices in the presence of an inter-
nal adversary with f = 0.30, malware spread rate λ(cid:82) = λmax for
Binary (B) tree, Ternary (T) tree, and Mesh (U) network topology.
Figure (a) and (b) corresponds to C0 and C1 respectively. Solid and
dashed lines correspond to ttl = 0 and ttl = 1 respectively.

8.2 External Adversary
Varying network topology. Red and black plots in Figure 12a
and 12c illustrates the fraction of corrupt devices for Mesh and
Binary tree topology with λext = λmax, 2λmax respectively. We omit
the results for the Ternary tree as it is very similar to the results
of Binary tree topology. For both topologies, the fraction of unde-
tected corrupt device increases approximately until 100 seconds

9

s
e
c
i
v
e
d
f
o
n
o
i
t
c
a
r
F

0.6

0.4

0.2

0

0.1

0.05

0

0.6

0.4

0.2

0

0.6

0.4

0.2

0

0

200

400

600

0

200

400

600

0

200

400

600

0

200

400

600

time (in seconds)
(a) Corrupt fraction, Mesh

time (in seconds)
(b) Blank fraction, Mesh

time (in seconds)

time (in seconds)

(c) Corrupt fraction, Binary Tree

(d) Blank Fraction, Binary Tree

λint = λmax;

λint = 2λmax;

Threshold, λint = λmax;

Threshold, λint = 2λmax;

Figure 12: Fraction of corrupt and blank device in Mesh and Binary Tree topology in the presence of an external adversary
A ext. Solid lines
corresponds to the adaptive case with ttl = 1 and dashed lines corresponds to non-adaptive case, i.e., ttl = 0. Plots for the situation where the
interarrival time between two consecutive self-checks are

and then gradually starts decreasing. This is because we initialize
λ = λmax = 1/100. Interestingly, after 100 seconds, although the
adversary is corrupting additional devices, the fraction of corrupt
nodes decreases even for λext = 2λmax. This is because adversary
randomly chooses device for corruption and since more than 50% of
the devices are already corrupt or blank by time 100s, the effective
corruption rate is lower than λmax.

The fraction of blank devices is higher in Binary tree topology be-
cause blank devices in Binary tree have fewer neighbors, and hence
they remain blank till one of their neighbor corrects itself. Alterna-
tively, in Mesh topology average number of neighbors per device
is higher, which increases the likelihood of one honest neighbor
at any given time. This also explains the rapid decrease in frac-
tion of corrupt device in Binary tree topology. As blank devices
are immune to corruption, the probability of corrupting an honest
device is lower in Binary tree topology. Once
A ext is disconnected
from the network, i.e., after 300s, the rate of reduction in fraction
of corrupt device follows the tail of exponential distribution.
Varying Spread Rate. Black plot in Figure 12 corresponds to λext =
λmax and red plot corresponds to λext = 2λmax. As expected with
higher λext, a higher fraction of devices gets corrupt. Also, for the
same reason, the fraction of the correct device is lower for the
lower corruption rate. Interestingly, the fraction of corrupt devices
is higher in Binary tree topology after 200s for λext = 2λmax. As
discussed earlier, this is due to the higher fraction of blank devices
in the network which reduces the effective malware spread rate.
Thresholding self-check rate. So far we have only considered
the scheme where the interarrival time between consecutive self-
checks at honest devices are drawn from an exponential distribution
with parameter λ. An issue with this approach is the unbounded
interarrival time. Thus, we evaluate Airmed with the modification
where we upper bound the self-check period by 50 seconds, i.e.,
δ
λ
. Blue and orange plots in Figure 12 illustrates
{
this results in the presence of
A ext. Observe that, thresholding
reduces the fraction of corrupt and blank devices. This is because,
devices are performing frequent self-checks, hence detecting the
malware earlier. But this comes at the cost of higher energy usage.
Also, for both Mesh and binary tree topologies, at time instants that
are multiples of 50, a large number of devices detects and hence
corrects themselves. Interestingly, the fraction of corrupt device

min

exp

, 50

←

}

}

{

does not reach zero at time instants because additional devices
whose first self-check interval was less than 50 gets corrupted.

|

L

8.3 Performance
As we describe in §6.1, our bloom filter based approach requires
ℓ
+µZ /t bits of SecRAM space in contrast to ℓZ /t bits of space
|
using the naive approach. Therefore, for Z = 16384 Bytes, i.e., 16 KB
which is typically the case with Texas Instrument’s MSP430 micro-
controllers [15], for t = 256 Bytes,
= 4 and µ = 8 we will only
require 128 Bytes of additional space in SecRAM. This gives us an
improvement over the naive system with ℓ = 128. Moreover, by
8
×
substituting these numbers in equation (5), we get that the expected
number of chunks, a blank device needs to download for κ = 4, i.e.,
when adversary modifies content of four chunks, is
×
better than the naive scheme of downloading all the chunks. Lastly,
using equation (6), we get that the expected number of the honest
neighbors who will transmit the requested chunks for different
values of m, the number of honest neighbor in the worst case are:

10. This is 6

≈

L

|

|

# neighbors, m
E[# neighbors to transmit code]

2
1.50

5
1.57

10
1.57

20
1.58

This shows even in dense network, in expectation, less than two
neighbors will end up transmitting the requested chunks. This is
significantly better than all the naive approaches.

9 RELATED WORK
Airmed falls into the genre of Device Swarm Security. While our
work focuses on correction and updation in the presence of an ad-
versary, most of the previous works looked only at only attestation
in the presence of an adversary or updation with no adversary.

Proposals such as [5, 8, 14] assume a Single External Verifier to
carry out swarm attestation while others [22, 43] use a Decentral-
ized approach where each member device is attested by a genuine
node in its neighborhood. Ambrosin M. et al. designed a collective
attestation scheme for IoT swarms for Highly Dynamic Swarm
Topologies [6]. These methods do not address updating or correc-
tion of code, however.

In SAFEd [41], a pair of embedded devices in a swarm attest to
each other without the need of an external verifier. Similar to [43],
SAFEd also removes a single-point-of-failure issue by allowing
swarm members to coordinate and self-protect the underlying net-
work. The SAFEd network forms multiple overlays among swarm

10

members that replicate proofs indicating the correctness of prover
devices. Recently, Ibrahim et al. proposed HEALED [23], a new
attestation scheme capable of detecting corrupt device and healing
upon compromise. Every corrupt device in HEALED, interact with
honest device to localize modified memory regions. This approach
requires O(log z) rounds of communication to identify a single
corrupt region for a application program of size z. Also, none of
the above approaches consider propagating malware. Furthermore,
they make strong assumptions such as: a corrupt device voluntarily
tries to correct itself; every device in the network can perform se-
curely route messages to other honest devices despite the presence
of a Byzantine adversary in the network.

Regarding code updation, N. Asokan et al. extended The Update
Framework [34] and proposed an architecture for secure firmware
update [9]. This work takes various stakeholders such as manu-
facturer, software distributor, domain controller and end devices
in IoT firmware update ecosystem; and establishes an end-to-end
security between devices manufactures and IoT devices. This work
also suffers from the limitations described in §5.

10 CONCLUSION
In this paper, we presented Airmed - a novel decentralized, scalable,
efficient, and secure mechanism of recovering a network of hetero-
geneous low-end devices in the presence of self-propagating mal-
ware. Furthermore, unlike prior works, Airmed guarantees update
of entire network. For efficiency, we used bloom-filters to identify
compromised code chunks, random back-off and stream signatures
to reduce bandwidth overhead and enhance security. Evaluation,
of our approach using OMNeT++, illustrates that Airmed scales
upto 1000s of device and can recover the entire network in min-
utes. We also evaluated the memory and communication costs of
Airmed and showed that it incurs very low overhead. Addressing
these issues with dynamic swarms and run-time attacks could be
an interesting avenue for future researches.

ACKNOWLEDGMENTS
The authors would like to thank Nitin Awathare, Aashish Kolluri,
Jong Chan Lee, Archit Patke, Soundarya Ramesh, Ling Ren, and Qi
Wang for helpful discussion and feedback on the early version of
the paper.

REFERENCES
[1] 2018. TrustLite, A Platform Security Framework for Tiny Embedded Devices.
(2018). https://www.informatik.tu-darmstadt.de/systemsecurity/researchsys/
projectssys/previousprojects/trustinmobileandembeddedsystems/trustlite/
trustlite1 .en.jsp

[2] 2019. Gartner Says a Thirty-Fold Increase in Internet-Connected Physical Devices
by 2020 Will Significantly Alter How the Supply Chain Operates. (2019). http:
//www.gartner.com/newsroom/id/2688717

[3] 2020. Gods and Goddesses of Healing. (2020). https://www.learnreligions.com/

gods-and-goddesses-of-healing-2561980

[4] 2020. OpenSim Ltd. OMNeT++ discrete event simulator.

(2020). http://

omnetpp.org/.

[5] Moreno Ambrosin, Mauro Conti, Ahmad Ibrahim, Gregory Neven, Ahmad-Reza
Sadeghi, and Matthias Schunter. 2016. SANA: secure and scalable aggregate net-
work attestation. In Proceedings of the 2016 ACM SIGSAC Conference on Computer
and Communications Security. ACM, 731–742.

[6] Moreno Ambrosin, Mauro Conti, Riccardo Lazzeretti, Md Masoom Rabbani, and
Silvio Ranise. 2018. PADS: Practical Attestation for Highly Dynamic Swarm
Topologies. arXiv preprint arXiv:1806.05766 (2018).

11

[7] Manos Antonakakis, Tim April, Michael Bailey, Matt Bernhard, Elie Bursztein,
Jaime Cochran, Zakir Durumeric, J Alex Halderman, Luca Invernizzi, Michalis
Kallitsis, et al. 2017. Understanding the mirai botnet. In 26th
Security
Symposium (

Security 17). 1093–1110.

USENIX

USENIX

}

{

[8] N Asokan, Ferdinand Brasser, Ahmad Ibrahim, Ahmad-Reza Sadeghi, Matthias
Schunter, Gene Tsudik, and Christian Wachsmann. 2015. Seda: Scalable embedded
device attestation. In Proceedings of the 22nd ACM SIGSAC Conference on Computer
and Communications Security. ACM, 964–975.

{

}

[9] N Asokan, Thomas Nyman, Norrathep Rattanavipanon, Ahmad-Reza Sadeghi,
and Gene Tsudik. 2018. ASSURED: Architecture for Secure Software Update
of Realistic Embedded Devices. IEEE Transactions on Computer-Aided Design of
Integrated Circuits and Systems 37, 11 (2018), 2290–2300.

[10] Amin Azmoodeh, Ali Dehghantanha, and Kim-Kwang Raymond Choo. 2018.
Robust malware detection for internet of (battlefield) things devices using deep
eigenspace learning. IEEE Transactions on Sustainable Computing (2018).
[11] Elisa Bertino and Nayeem Islam. 2017. Botnets and internet of things security.

Computer 2 (2017), 76–79.

[12] Karthikeyan Bhargavan, Bruno Blanchet, and Nadim Kobeissi. 2017. Verified
models and reference implementations for the TLS 1.3 standard candidate. In
2017 IEEE Symposium on Security and Privacy (SP). IEEE, 483–502.

[13] Ferdinand Brasser, Brahim El Mahjoub, Ahmad-Reza Sadeghi, Christian Wachs-
mann, and Patrick Koeberl. 2015. TyTAN: tiny trust anchor for tiny devices. In
Proceedings of the 52nd Annual Design Automation Conference. ACM, 34.
[14] Xavier Carpent, Karim ElDefrawy, Norrathep Rattanavipanon, and Gene Tsudik.
Lightweight swarm attestation: a tale of two LISA-s. In Proceedings of the 2017
ACM on Asia Conference on Computer and Communications Security.

[15] Dung Dang, Mione Plant, and Mehrvash Poole. 2018. Wireless connectivity for
the Internet of Things (IoT) with MSP430™ microcontrollers (MCUs). (2018).
https://www.ti.com/lit/wp/slay028/slay028.pdf

[16] Kaustubh Dhondge, Rajeev Shorey, and Jeffrey Tew. 2016. Hola: Heuristic and
opportunistic link selection algorithm for energy efficiency in industrial internet
of things (iiot) systems. In 2016 8th international conference on communication
systems and networks (COMSNETS). IEEE, 1–6.

[17] Karim Eldefrawy, Gene Tsudik, Aurélien Francillon, and Daniele Perito. 2012.
SMART: Secure and Minimal Architecture for (Establishing Dynamic) Root of
Trust.. In NDSS, Vol. 12. 1–15.

[18] Earlence Fernandes, Jaeyeon Jung, and Atul Prakash. 2016. Security analysis
of emerging smart home applications. In 2016 IEEE Symposium on Security and
Privacy (SP). IEEE, 636–654.

[19] Rosario Gennaro and Pankaj Rohatgi. 1997. How to sign digital streams. In

Annual International Cryptology Conference. Springer, 180–197.

[20] Hamed HaddadPajouh, Ali Dehghantanha, Raouf Khayami, and Kim-Kwang Ray-
mond Choo. 2018. A deep Recurrent Neural Network based approach for Internet
of Things malware threat hunting. Future Generation Computer Systems (2018).
[21] Yih-Chun Hu, Adrian Perrig, and David B Johnson. 2005. Ariadne: A secure
on-demand routing protocol for ad hoc networks. Wireless networks (2005).
[22] Ahmad Ibrahim, Ahmad-Reza Sadeghi, and Gene Tsudik. 2018. AID: autonomous

attestation of IoT devices. In SRDS.

[23] Ahmad Ibrahim, Ahmad-Reza Sadeghi, and Gene Tsudik. 2019. Healed: Healing
& attestation for low-end embedded devices. In International Conference on
Financial Cryptography and Data Security. Springer, 627–645.

[24] Brian Jalaian, Timothy Gregory, Niranjan Suri, Stephen Russell, Laurel Sadler,
and Michael Lee. Evaluating LoRaWAN-based IoT devices for the tactical military
environment. In 2018 IEEE 4th World Forum on Internet of Things (WF-IoT).
[25] Frank T Johnsen, Zbigniew Zieliński, Konrad Wrona, Niranjan Suri, Christoph
Fuchs, Manas Pradhan, Janusz Furtak, Bogdan Vasilache, Vincenzo Pellegrini,
Michał Dyk, et al. Application of IoT in military operations in a smart city.
In 2018 International Conference on Military Communications and Information
Systems (ICMCIS). IEEE.

[26] Adam Kirsch and Michael Mitzenmacher. 2006. Less hashing, same performance:
building a better bloom filter. In European Symposium on Algorithms. Springer.
[27] Patrick Koeberl, Steffen Schulz, Ahmad-Reza Sadeghi, and Vijay Varadharajan.
2014. TrustLite: A security architecture for tiny embedded devices. In Proceedings
of the Ninth European Conference on Computer Systems. ACM, 10.

[28] Florian Kohnhäuser and Stefan Katzenbeisser. 2016. Secure code updates for
mesh networked commodity low-end embedded devices. In European Symposium
on Research in Computer Security. Springer, 320–338.

[29] Constantinos Kolias, Georgios Kambourakis, Angelos Stavrou, and Jeffrey Voas.

2017. DDoS in the IoT: Mirai and other botnets. Computer 50, 7 (2017), 80–84.
[30] Deepak Kumar, Kelly Shen, Benton Case, Deepali Garg, Galina Alperovich,
Dmitry Kuznetsov, Rajarshi Gupta, and Zakir Durumeric. 2019. All things
considered: an analysis of IoT devices on home networks. In 28th
Security Symposium (

Security 19). 1169–1185.

USENIX

USENIX

}

{

[31] Di Ma, Claudio Soriente, and Gene Tsudik. 2009. New adversary and new threats:
security in unattended sensor networks. IEEE network 23, 2 (2009), 43–48.
[32] Michael Mitzenmacher and Eli Upfal. 2017. Probability and computing: random-
ization and probabilistic techniques in algorithms and data analysis. Cambridge

{

}

university press.

[33] Eyal Ronen, Adi Shamir, Achi-Or Weingarten, and Colin O’Flynn. 2017. IoT goes
nuclear: Creating a ZigBee chain reaction. In 2017 IEEE Symposium on Security
and Privacy (SP). IEEE, 195–212.
Justin Samuel, Nick Mathewson, Justin Cappos, and Roger Dingledine. 2010.
Survivable key compromise in software update systems. In Proceedings of the
17th ACM conference on Computer and communications security. ACM, 61–72.

[34]

[35] Arvind Seshadri, Mark Luk, Adrian Perrig, Leendert van Doorn, and Pradeep
Khosla. 2006. SCUBA: Secure code update by attestation in sensor networks. In
Proceedings of the 5th ACM workshop on Wireless security. ACM, 85–94.

[36] Arvind Seshadri, Adrian Perrig, Leendert Van Doorn, and Pradeep Khosla. 2004.
Swatt: Software-based attestation for embedded devices. In null. IEEE, 272.
[37] Saleh Soltan, Prateek Mittal, and H Vincent Poor. 2018. BlackIoT: IoT Botnet
Security

of high wattage devices can disrupt the power grid. In 27th
Symposium (

Security 18). 15–32.

USENIX

USENIX

{

}

[38] George Spanogiannopoulos, Natalija Vlajic, and Dusan Stevanovic. 2009. A
simulation-based performance analysis of various multipath routing techniques
in ZigBee sensor networks. In International Conference on Ad Hoc Networks.
Springer, 300–315.

{

}

[39] Lawrence J Trautman and Peter C Ormerod. 2017. Industrial cyber vulnerabilities:
Lessons from Stuxnet and the Internet of Things. U. Miami L. Rev. 72 (2017), 761.
[40] Deepak Vasisht, Zerina Kapetanovic, Jongho Won, Xinxin Jin, Ranveer Chandra,
Sudipta Sinha, Ashish Kapoor, Madhusudhan Sudarshan, and Sean Stratman.
2017. Farmbeats: An iot platform for data-driven agriculture. In 14th
{
NSDI
Symposium on Networked Systems Design and Implementation (
}

[41] Alessandro Visintin, Flavio Toffalini, Mauro Conti, and Jianying Zhou. 2019.
SAFEˆ d: Self-Attestation For Networks of Heterogeneous Embedded Devices.
arXiv preprint arXiv:1909.08168 (2019).

USENIX
).

{

}

[42] Yang Wang, Deepayan Chakrabarti, Chenxi Wang, and Christos Faloutsos. Epi-
demic spreading in real networks: An eigenvalue viewpoint. In 22nd International
Symposium on Reliable Distributed Systems, 2003. Proceedings. IEEE.

[43] Samuel Wedaj, Kolin Paul, and Vinay J Ribeiro. 2019. DADS: Decentralized
attestation for device swarms. ACM Transactions on Privacy and Security (TOPS)
(2019).

[44] Seung Yi, Prasad Naldurg, and Robin Kravets. 2001. Security-aware ad hoc routing
for wireless networks. In Proceedings of the 2nd ACM international symposium
on Mobile ad hoc networking & computing. ACM, 299–302.

[45] Cliff Changchun Zou, Weibo Gong, and Don Towsley. 2002. Code red worm
propagation modeling and analysis. In Proceedings of the 9th ACM conference on
Computer and communications security. ACM, 138–147.

A ALGORITHMS

Algorithm 1 selfcheck

attest(aki , [code])

1: Input aki , vi , [code]
2: v ′i ←
3: if v ′i = vi then
λ/(λ + 1), λmin}
λ
λ
4:
{
{
←
enable interrupt; resume application.

max

exp

; δ

←

5:
6: else
7:

8:

mark [code] as non-executable.
rectify()

Ni

Algorithm 2 handleCodeRequest at device nj ∈
ttl, si ,
1: input MSGreq =
2: global Aj , ∆, θ, λ, λmax
Aj then
3: if b
ver(b)
4:

, zi , b, Π

Ni |

⟩

⟨

|

∈
zj ←
if zj ≥
τj ←
⌊U
set transmit code timer after τj

zi then
(∆

(zj −

Ni |

zi ))

θ +

−

|

(0, 1)

5:

6:

Ni |⌋

|

θ

7:
8: if ttl > 0 then
λ
9:
←
{
10: if ttl > 0 then
11:

min

2λ, λmax}

; ttl

ttl

1

−

←

broadcast a message warning devices in Nj

Algorithm 3 handleCodeResponse at device ni

1: input Π
2: while true do
3:

new response MSGresp =
while next pos

Π

posj , dataj }⟩
do

⟨{
MSGresp}

∈ {
MSGresp[pos]

∩

data
if stream signature of data is valid then

←

load data to code;
Π
else

←

Π

pos; MSGresp ←

\

MSGresp \ {

pos, data

}

break
if Π is empty then

λmax; update interrupt handler

λ
broadcast MSGdone; restart ni

←

else
δ
re-broadcast MSGreq after δ time interval.

exp

←

λ

{

}

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

15:

16:

B NOTATION TABLE

Notation

O

pk

O
, sk
O
N
ni
pki , ski
Bi , Ci
Ni
N (b)
i
ki
qi
λ
aki , vi

Description
Network operator/Owner
public-private key pair of

O

Total number of nodes in the network
ith device
public-private key pair of ni
Application binaries executed and stored by ni
Neighbors of ni after successful rendezvous
Devices in Ni that runs/stores binary b
Symmetric key shared by ni
Sequence number of ni
Self-check rate
Attestation key and value at ni
Bloom filter and the corresponding keys
Internal and External Adversary resp.
Corruption rate of
A ext

A int, and

C PROOFS
To prove Theorem 6.2 we will first prove Lemma C.1. Let the time
interval where devices running an identical version of the code,
transmits the requested chunk be called as an epoch. Observe that,
each epoch mθ long. Let each epoch be divided into m time intervals
called a slot. Note that, in Airmed devices running different versions
always sends the requested chunks in disjoint epochs. Also, within
an epoch, once an honest device sends the requested chunk, the
recipient device broadcasts to each of its neighbors to stop them
from redundantly sending the same chunks (ref. §4.2). Hence, if
only neighbor sends the requested chunk in the first non-empty
slot, there would be no-redundancy at all.

Lemma C.1. Let there be m neighbors running the same version of
application b for any given device. Also, let X j for 1
1 be
≤
the random variable denoting the number of devices which sends the
X j nodes transmits
requested chunks in slot j when the remaining m

m

−

≤

j

−

12

}

lj }
F , L =
{
A int,
A ext
λint, λext

in a slot greater than j. Then,

Pr[X j = k] =

(cid:0)m
k

(cid:1)(m

j)(m

k )

−

(7)

−
mm

Proof. We use counting arguments to prove this theorem. There
are total mm possibilities of arranging m devices in m slot. Among
these possibilities, the number of ways X j = k can occur if: (i)
(cid:1) possible
Any subset of k devices transmits in slot j; there are (cid:0)m
k
ways of selecting these devices. and (ii) the remaining m
k device
−
k ways of doing
transmits in slots j + 1 to m; there are (m
−
□
this. Putting them together gives us the desired result.

j)m

−

Corollary C.2. The probability that only one neighbor device
will transmit the requested code in the situation described above is:

Pr[One device transmits code] =

(cid:19)(m

1)

−

(cid:18)

1
m
(cid:88)
−

j=1

j
m

1

−

(8)

Proof. (Theorem 6.2) The first term directly follows Lemma C.1
and the second term corresponds to the case where all device trans-
□
mits the requested chunk in the mth slot.

Proof. (Theorem 6.4) Let Hb denote the set of honest devices
> 0. Consider a
Hb |
at any given time after t0, by our assumption
|
Gb which is initially ν hops away from
corrupt or blank device nd ∈
Hb and na be the penultimate
the nearest honest device in nh ∈
node on the path from nd to nh . By definition, na is corrupt. After
an exponentially distributed waiting time, na performs a self-check
and recovers itself one of its honest neighbors. This is guaranteed
N (b)a . Thus di now joins Hb . This reduces
to happen since nh ∈
the distance between nd and the nearest honest by at least one unit.
Since, there are only finite number of nodes in the network, this
□
distance will eventually become zero.

Proof. (Theorem 6.5) Let Ub ⊆

Gb be the set of updated devices
at time t0. By definition all non-updated devices in the neighbour-
hood of devices in Ub . Thus, whenever one of these devices say
nv performs self-check, it will get updated with the newer version
and join Ub . Device nv then broadcast the newer version to update
all non-updated honest devices in its neighborhood. Hence, the
number of updated device increases by at least one. Since, there are
only finite number of devices, eventually the entire network will
□
get updated.

13

