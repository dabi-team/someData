0
2
0
2

r
a

M
3
1

]

R
C
.
s
c
[

1
v
7
2
1
6
0
.
3
0
0
2
:
v
i
X
r
a

Fail-safe Watchtowers and Short-lived Assertions for Payment
Channels
Pawel Szalachowski
Singapore University of
Technology and Design
Singapore
pawel@sutd.edu.sg

Bowen Liu
Singapore University of
Technology and Design
Singapore
bowen_liu@mymail.sutd.edu.sg

Siwei Sun
State Key Laboratory of Information
Security, Institute of Information
Engineering, Chinese Academy of
Sciences
School of Cyber Security, University
of Chinese Academy of Sciences
Beijing, China
sunsiwei@iie.ac.cn

ABSTRACT
The recent development of payment channels and their extensions
(e.g., state channels) provides a promising scalability solution for
blockchains which allows untrusting parties to transact off-chain
and resolve potential disputes via on-chain smart contracts. To pro-
tect participants who have no constant access to the blockchain, a
watching service named as watchtower is proposed – a third-party
entity obligated to monitor channel states (on behalf of the par-
ticipants) and correct them on-chain if necessary. Unfortunately,
currently proposed watchtower schemes suffer from multiple secu-
rity and efficiency drawbacks.

In this paper, we explore the design space behind watchtowers.
We propose a novel watching service named as fail-safe watchtow-
ers. In contrast to prior proposed watching services, our fail-safe
watchtower does not watch on-chain smart contracts constantly.
Instead, it only sends a single on-chain message periodically con-
firming or denying the final states of channels being closed. Our
watchtowers can easily handle a large number of channels, are
privacy-preserving, and fail-safe tolerating multiple attack vectors.
Furthermore, we show that watchtowers (in general) may be an
option economically unjustified for multiple payment scenarios
and we introduce a simple, yet powerful concept of short-lived as-
sertions which can mitigate misbehaving parties in these scenarios.

KEYWORDS
Blockchain; Smart Contract; Payment Channel; Watchtower; Short-
lived Assertions

1 INTRODUCTION
Scalability is seen as the main limitation of currently deployed per-
missionless blockchain systems [10]. Mainstream platforms like
Bitcoin or Ethereum can handle from a few to several transactions
per second, and clearly, without handling high transaction volumes
these systems are unlikely to achieve mass adoption. While more
performant consensus algorithms are being constantly proposed
(i.e., layer-1 solutions) [8, 18, 25, 33, 34], the concept of payment
channels has emerged in parallel. Payment channels and network
build upon them, like Lightning Network [35] or Raiden [4], are
layer-2 solutions which involve on-chain smart contracts only for
channel management (i.e., creation, termination, or dispute) while

all regular transactions are exchanged off-chain. That allows un-
trusting parties to transact off-chain as simple and fast as exchang-
ing signed messages which is especially important for micropay-
ments.

A party can close a channel by sending the latest statement to the
smart contract, which verifies whether the statement is properly
signed by both parties and transfers the tokens accordingly. The
smart contract does not know what is the off-chain state, thus the
payout operation is timeouted to give another party time to dispute.
Disputes are resolved by the contract itself, simply accepting the
freshest message (e.g., messages can be ordered by unique ascending
counters). One security assumption in this setting is that a party has
to be online to detect and prevent misbehavior of its peer sending
a stale message to close the channel.

To relax the always online assumption, the concept of outsourc-
ing arbitration to so-called watchtowers (or monitors) was pro-
posed [2]. They are highly available third parties which are con-
tacted by transacting parties with every transaction. Therefore, an
involved watchtower knows the current off-chain payment state
and its duty is to monitor the on-chain state. In the case of a mis-
behavior, i.e., when a party tries to close the channel using a stale
state, the watchtower will be able to trigger the dispute process by
providing the current state on behalf of the inactive party.

Unfortunately, watchtower schemes present in the literature
have some important limitations (see details in Section 2). They
need to observe every channel contract separately, and they are
not fail-safe, allowing misbehavior under their unavailability, or
still requiring a significant payout timeout.1

To mitigate these drawbacks we propose a concept of fail-safe
watchtowers. In our construction, watchtowers do not watch chan-
nel contracts constantly anymore. Instead, they observe and as-
sert off-chain transactions, and periodically send a message to the
blockchain, encoding the latest states of watched payment chan-
nels. A party closing its channel has to authorize this operation
by confirming its state with the fresh information submitted by
the watchtower. Sending a “positive” information can eliminate
long timeouts present in current systems where watchtowers send
only “negative” information (correcting an incorrect state). More-
over, our design of watchtowers incentivizes them to confirm (or
reject) a given state as soon as possible. This construction allows

1Long payout timeouts are undesired as a party’s deposit cannot be used during this
time.

 
 
 
 
 
 
to implement quick channel termination in the common case (i.e.,
when the watchtower is online), is fail-safe as a longer timeout
will be triggered only when the watchtower is offline, and allows
watchtowers to scale better as they can be implemented as light
blockchain clients. Furthermore, we show that for a large num-
ber of payment channels, watchtower schemes in general may be
economically ineffective. To improve security in these cases we
introduce short-lived assertions, that allow channel contracts to
distinguish fresh and stale assertions and process them accordingly
(minimizing timeouts and misbehavior impact).

In this work we make the following contributions:

(1) we propose a novel construction of watchtowers, which in
contrast to prior proposals, minimize payout delays in the
common case (i.e., when the parties are honest), are fail-safe,
efficient, and privacy-preserving (see Section 4),

(2) we show the economic limitations of watchtower schemes
and introduce novel short-lived assertions for payment chan-
nels, which is a complementary solution suitable for multiple
scenarios, like micropayments (see Section 7),

(3) we implement and evaluate the proposed systems to demon-
strate their security, feasibility, and efficiency (see Section 5).

2 MOTIVATION AND RELATED WORK

Payment Channels. Currently existing decentralized permis-
sionless blockchain platforms (e.g., Bitcoin and Ethereum) can
hardly compete against those centralized financial service providers
like VISA or Paypal in terms of processed transactions per second
(TPS). To put this into perspective, Bitcoin only supports up to 7
TPS [10], while VISA can handle an average of 150 million trans-
actions every day or around 1736 TPS [6]. Today, the scalability
problem of such blockchains has been regarded as a main obstacle
for their further adoption as large scale payment networks.

The community has put forth various proposals to increase the
throughput of blockchain platforms. Reparameterization of block
sizes and block intervals of existing systems has been proved to
be ineffective [17] in boosting the performance. Designing new
consensus protocols from scratch [16, 27] is promising, but requires
significant implementation, deployment, and adoption costs to be
used in practice. Moreover, it takes a long time to understand and
build up the security confidence of new consensus protocols.

Another line of research is to minimize the interactions with
blockchains by using off-chain protocols — the so-called layer-2
solutions. Recently developed payment channels and state channels
together with their extensions [9, 19, 28] belong to this approach.
The main idea of layer-2 solutions is to make payments and state
transitions by exchanging off-chain messages among small groups
of parties privately, and use the blockchain as a backstop only when
disputes arise. As a result, parties can make a huge number of off-
chain transactions, while only their initial deposit and the finalized
balances will be included on-chain. Moreover, this approach is back-
ward compatible with existing systems and is orthogonal to other
scalability solutions, thus it has become a promising approach for
improving the scalability of blockchains and cryptocurrencies.

The layer-2 payment protocols have evolved from simplex and
probabilistic payment channels [13, 21, 22, 32] to fully duplex

payment channels [12, 14, 19, 26], based on which payment net-
works [4, 24, 30, 35] can be constructed where users can send pay-
ment to each other without establishing a direct channel from
scratch. Besides, state channels [15] generalize the concept of pay-
ment channels to support not only payments but also the execution
of arbitrary state transitions. We refer the readers to [20, 23] for a
more comprehensive discussion of the layer-2 off-chain protocols.
In this work, we mainly focus on enhancing the security of pay-
ment channels, although our schemes can be generalized to state
channels.

Watching Service. The dispute resolution mechanisms of pay-
ment channels require that the parties are online and synchronized
with the blockchain to prevent the channels from finalizing with
invalid stale states. To alleviate this strong always-online require-
ment, schemes outsourcing the responsibility of monitoring the
blockchains and issuing challenges in case of disputes to third-party
watching services are proposed. Users outsource their latest off-
chain states to the watching service before parting offline. Watching
services then act on behalf of the users to protect their funds. Users
can still verify the correct behavior of watching services and punish
them in case of ineligibility and non-compliance [20].

Monitor [2] is a watching service for the Lightning network.
However, due to the nature of replace-by-revocation channels in
the Lightning network, the Monitor has to store all transactions
within the channel, making it inefficient to provide service to a large
number of busy channels simultaneously. The WatchTower scheme
proposed by Osuntokun [31] reduces the storage requirement of
Monitor from O(N ) to O(1). But this improvement relies on a new
opcode to parse and verify a signed message, which is currently
unavailable in Bitcoin. Therefore, WatchTower cannot take the
place of Monitor without updating the underlying layer-1 protocol.
More importantly, both Monitor and WatchTower lack a mechanism
for customers to recourse when the watching service fails to settle
a dispute, since no verifiable evidence is provided.

To address the inefficiencies and limitations of prior watching
services, PISA is proposed which works for generic state chan-
nels [29]. In PISA, the third party (named as a custodian) appointed
by customers to watch the state channel and cancel execution forks
only needs to store the hash of the most recent state, and thus
only O(1) storage is required. Moreover, PISA provides publicly
verifiable cryptographic evidence in case the custodian fails, based
on which the involved customer is able to penalize the custodian.
However, the customer of custodian is implicit to the public and
the custodian can use the same deposit as a safety for all customers.
The always-online assumption is moved in PISA from parties
to a custodian and moreover the system is not designed in a fail-
safe way – i.e., an unavailable/failed custodian silently accepts
malicious disputes, thus to mitigate it payout timeouts should be
set long enough, freezing deposits of parties.

The Disclose Cascade Watch Commit (DCWC) scheme [7] pro-
poses to incentivize multiple third parties to provide watching
services, where only watchtowers whose participating evidences
are included on chain get paid. However, each party has to be re-
sponsive and synchronized with the blockchain at all times. While
DCWC relates to node failures as well, security in general and

topology-based attacks in particular have been mostly neglected,
though.

Watching Services and Trust. Although it may be counter-
intuitive that parties of a decentralized platform employ a central-
ized entity (i.e., a watchtower) for dispute resolution, there are
essential differences between these approaches and the centraliza-
tion of the underlying blockchain platform. First of all, watching
services (as well as payment channels and other upper-layer ap-
plications) are external to the platform and its consensus rules,
therefore they do not violate the decentralization of the platform
itself. Second, the trust placed in watching services is “local” to the
parties that deploy it, i.e., no other blockchain participants have to
trust (or even be aware of) such a service. Moreover, some designs
(including ours) allow a client to be represented by a watching
service in a way opaque even to the peer of the payment channel.
Finally, designs of watching services can benefit from the proper-
ties of the underlying platforms, which include transparency of
service actions (allowing early detection of misbehavior) or cryp-
toeconomic incentives aiming to facilitate correct service behavior
by punishments and rewards.

3 PRELIMINARIES
3.1 Blockchain and Smart Contract
Over the last decade, the blockchain technology has been pioneered
by Bitcoin [11] which enables mutually untrusted parties to reach
consensus over the state of a distributed and decentralized global
ledger confirming and serializing “transactions”. By using a similar
consensus protocol and extending the scripting language of Bitcoin
to a Turing complete programming language, Ethereum [1] was
built – a general-purpose blockchain system with its native cryp-
tocurrency ether which can execute programs over a decentralized
and replicated state machine named as the Ethereum Virtual Ma-
chine (EVM). Due to the Turing completeness, with Ethereum one
can implement self-enforcing programs called smart contracts with
nearly arbitrary business logic.

To prevent parties from intentionally or unintentionally abus-
ing the system resources, computation and memory utilization in
Ethereum are charged in gas which can be purchased with ether
with certain exchange rate. Therefore, maintaining a smart con-
tract storing data objects of large size and performing complex
computations can be very expensive. To facilitate lightweight com-
munication between smart contracts and deploying them clients,
a mechanism of events and logs is introduced in Ethereum. Smart
contracts can emit events and write logs to the blockchain. When
they are called, the emitted messages are stored in the transaction’s
log associated with the address of the contract. Log and event data
are not accessible from within contracts but can be captured by
clients reading (part of) the blockchain.

3.2 Payment Channels
A payment channel is a relationship established between two partic-
ipants that wish to transact, such that bi-directional payments can
be made by exchanging off-chain messages if both parties behave
honestly. The state of the relationship resulted from those off-chain
transactions will eventually be recorded on blockchain, which only

happens when the payment channel is finalized. A set of rules are
enforced by the blockchain to guarantee that the channel is final-
ized with the correct state even if all parties are malicious. The
life cycle of a payment channel can be divided into the following
phases.

Setup. Before the payment channel is established, the involved
parties need to deposit certain amount of coins to a payment chan-
nel contract that both parties agree on. These coins are going to be
redistributed continuously among them during the payment phase.

Payment. During this phase the participants of the channel
can make an arbitrary number of payments (within the channel
capacity induced by the initial deposit) to each other by exchanging
jointly signed off-chain messages. Since there is no interaction
with the blockchain, the transaction throughput is only limited by
computing resources and the actual communication network for
exchanging messages between the parties, effectively bypassing
the bottleneck due to the underlying consensus mechanism of the
blockchain.

Closure. Any party can try to close the payment channel by
issuing a state signed by both parties to the blockchain. Before
the channel is finalized with this submitted state, the payment
channel reserves a time window for the other party to intervene
and invalidate the previously submitted state with a newer signed
state. Eventually, the most recent state seen by the blockchain will
be accepted after a timeout. According to this rule, the payment
channel may end up with a non-latest state against the legitimate
interest of one side who fails to provide proper evidence to the
payment channel contract showing the invalidity of the previously
submitted state within the time window. Therefore, it is essential
to observe the blockchain constantly to ensure that only the latest
state will be accepted by the blockchain.

4 FAIL-SAFE WATCHTOWERS
4.1 Overview
Before proceeding with the details, we give a brief overview of our
design, which is depicted in Figure 1.

Figure 1: Protocol Overview.

Two participants first register with a payment channel contract
by depositing some initial funds there. Then, through the tower con-
tract they can employ a third party called a watchtower to protect

Channel Contract (CC)Watch TowerTower Contract (TC)EstablishDisputeMonitorChannel StatesPeriodically UpdateCollect StatesPaymentConﬁrmation SetSetupPayMonitorManageEnquiryPayoutExchangeClosurethe payment state of their own channel. Afterwards, the regis-
tered channel participants communicate off-chain to authorize and
make payments with each other, redistributing the initial deposits
amongst themselves. To keep track of the transactions, a monotonic
transaction counter is incremented for every transaction appear-
ing in the channel. The watchtower receives and verifies every
off-chain transaction, and records the latest state of the payment
channel. A watchtower can monitor the off-chain states of multiple
channels simultaneously. It manages a tower contract and periodi-
cally updates it with the so-called confirmation set which is used
to determine payout process. To close the channel, a party submits
a closure transaction to the channel contract which delegates the
final payout decision to the tower contract. Any participant is able
to invoke dispute if any disagreement happens.

We design protocol with the following goals in mind:

Security. We assume an adversary who cannot compromise

• the underlying cryptographic primitives (e.g., digital signa-

tures, hash functions, etc.),

• the properties of the underlying blockchain platform,
• the smart contract runtime environment,
• a watchtower (but an adversary can be one peer of the pay-
ment channel); however, we discuss some cases of misbehav-
ing watchtowers.

Under these assumptions our watchtower protocol should pre-
vent unregistered parties from bypassing identity authorization. In
particular, any unauthorized party should not be allowed to trigger
channel closure and the potential dispute processes. Moreover, any
unauthorized payment state should not be verified by a channel
contract successfully. In addition, we aim the watchtower service
to be fail-safe, i.e., an unavailable watchtower (e.g., attacked via a
(D)DoS) should not silently accept channel closures and its default
behavior should be rejective (in practice, a long timeout should be
triggered in that case as otherwise parties would not recover from
an unavailable watchtower).

Efficiency and Low Cost. Our protocol should operate as effi-
ciently as possible. There should be no efficiency bottlenecks with
respect to throughput, storage, latency, etc. which could hinder
its applicability in real-world scenarios. Moreover, the cost of ap-
plying proposed solutions in terms of storage, computation, and
blockchain-related fees should be minimized.

Scalability. Watchtowers should be able to handle a large num-
ber of payment channels and the overheads introduced should not
increase significantly with the increasing number of channels and
transactions.

Privacy. Transaction details should be known only to transact-
ing parties. In particular, watchtowers should not learn transactions
or their patterns while protecting the channel. We emphasize, that
in the case of dispute or channel closure, privacy of these “closing”
transactions may not be achieved as these actions are conducted
over a publicly readable blockchain.

Accountability. Watchtowers should fulfill duties once received
payment from parties. In particular, employed watchtowers should
collect messages and record the latest state for a given channel. They
also need to deal with closure events, resolve potential dispute, and

proceed payout in time. Otherwise, an honest party should always
be able to prove the wrongdoing of a watchtower and withdraw
payment.

In the following sections, we will introduce the details and inter-

actions of our protocol.

4.2 Channel Setup
We assume two mutually untrusting parties, Alice and Bob, that
wish to establish and use a bidirectional payment channel. To this
end, one of them has to deploy a payment channel contract on
the blockchain as shown in Algorithm 1. Afterwards, the unique
address cid of this payment channel contract is used to reference
the payment channel. The life cycle of the channel contract can be
divided into three phases (⊥, OK, and DISPUTE), which is indicated
by a global flag of the contract.

Alice and Bob then register their public keys (pkA, pkB ) and
deposit coins into the contract for their subsequent transactions
within the channel. To achieve this, one party (say Alice) is respon-
sible for initializing channel using the setup() method. Before
the actual setup, she is supposed to receive a signature from the
counter-party (say Bob) where the signed message is the initial state
(s0) between parties and the balA in s0 represents the amount Alice
is depositing. Then, she deposits balA and assigns a watchtower by
providing the address of a watchtower contract. This watchtower
contract is maintained by a third party who will be employed to
monitor the channel and prevent it from finalizing with outdated
states. The flag transitions from ⊥ to OK. Afterwards, Bob also needs
to get the signature from Alice that signs a new exchange state (s1)
and then he freezes balB in s1 via the deposit() method shown
in Algorithm 1. These atomic exchanges enjoy two advantages: 1)
ensures the amount deposited by each party is signed and agreed
by the counter-party, 2) avoids clash behavior from any party (in
the case of failed setup any party can get its deposit back). For an
honest party, we allow her to get coins back via directly invoking
close request and inputting signed state.

4.3 Watchtower Employment
Before Alice and Bob can securely make off-chain transactions via
the payment channel, they need to employ a watchtower to monitor
the channel. One of the participants pays the watching service via
a watchtower contract shown in Algorithm 2.

Although, watchtowers can be introduced to a channel in many
ways, for a simple description we assume that Bob first deposits
amount in the tower contract and then sends a signature with cid
to the watchtower which verifies the authenticity of the payment
by simply checking if Bob deposits the correct amount. As a re-
sult, the payment channel with cid is protected by the watchtower.
A watchtower is considered trusted, however, a customer (i.e., a
party) should be able to withdraw amount if he proves watchtower
is wrongdoing or not fulfilling eligible job. To successfully with-
draw a deposit, a customer should submit a challenge via the
channel contract that proves the watchtower did not either close
the given channel with the latest state or respond to the channel
contract in time. We employ a tolerance timeout t motivating the
watchtower to respond faster and more efficiently. The watchtower
will not lose anything if it replies to the channel contract before t.

Algorithm 1: Payment Channel Contract.
1 Flaд : ⊥, OK, DISPUTE, s : NU LL
2 ddl : 0, isRspd : NU LL, perc : 0, end : 0
3 event Closure(cid, state, r ), event Dispute(cid, state, r )
4 function setup(party, $bal, wtAddr, wt)
5

assert(Flaд = ⊥)
pkA ← party, balA ← $bal, pkwt ← wt
watchTower ← TContract(wtAddr ), Flaд ← OK

6

7
8 function deposit(party, $bal)
9
10 function close(si , r , Pσk )
11

assert(Flaд = OK), pkB ← party, balB ← $bal

assert(Flaд = OK and veri f y(pkk , (si , r ), Pσk ))
Flaд ← DISPUT E, s ← si
ddl ← now + t, end ← ddl + T , isRspd ← False
watchTower .close(this, si ), emit Closure(this, si , r )

14
15 function dispute(si , r , Pσk )
16

assert(veri f y(pkk , (si , r ), Pσk ) and si .idx > s.idx)
assert(Flaд = DISPUT E and now < end), s ← si
watchTower .close(this, si ), emit Dispute(this, si , r )

19 function payout(si , isPay)
20

assert(Flaд = DISPUT E)
if msд.sender = watchTower then
if now > ddl and !isRspd then
perc ← (now − ddl)/T

isRspd ← T rue
if isPay = T rue then

assert(balA + balB ≥ si .balA + si .balB and si = s)
partyA.trans f er (si .balA), partyB.trans f er (si .balB )
Flaд ← ⊥, s ← si

else

end ← now + T

else if msд.sender = any party then
assert(now > end and si = s)
assert(balA + balB ≥ si .balA + si .balB and si = s)
partyA.trans f er (si .balA), partyB.trans f er (si .balB )
Flaд ← ⊥, s ← si

36 function challenge(si , r , σwt )
37

assert(veri f y(pkwt , (si , r ), σwt ) and now > end)
if (Flaд = ⊥ and si .idx > s.idx) or (isRspd = False) then

watchTower .withdraw(this, msд.sender, 1)

if perc > 0 then

watchTower .withdraw(this, msд.sender, perc)

12

13

17

18

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

38

39

40

41

watchtower does not learn about the balances of Alice and Bob
since it only receives the hash value hsi

.

Figure 2: Payment Exchange

Otherwise, a longer timeout T is initialized and a linear rewarding
would be triggered. This mechanism rewards the watchtower in-
versely proportional to the watchtower’s response time. It prevents
unavailable or failed watchtowers from getting undeserved fees
and incentivizes watchtowers to maintain high availability and to
shorten timeouts.

4.4 Regular Payment
After a watchtower is employed, Alice and Bob are ready to make
off-chain transactions via the payment channel by participating in
an interactive protocol depicted in Figure 2.

As in [14], the payment channel is modeled as a state machine,
and the state transitions from si to si+1 are carried out by off-
chain transactions signed by both Alice and Bob. We encode each
state si as a tuple (balA, balB , idx), where balA and balB are the
corresponding balances of Alice and Bob within the channel, and
idx is a monotonic index starting from 0, which is incremented for
every state transition and the state with the largest idx is considered
the latest state.

=
To make a new transaction, Alice computes the hash value hsi
H(si ∥ r ) with recalculated balances (balA, balB ) and incremented
idx, where r is a large (e.g., 256-bit) random number. Then she
sends the signature

σA = Sign(skA, cid ∥ idx ∥ hsi )
together with the message cid ∥ si ∥ r to Bob. Next, Bob verifies
the signature and authorizes the transaction by sending his own
signature σB = Sign(skB , cid ∥ idx ∥ hsi ) to Alice. Meanwhile,
he verifies the signature σA and sends cid, idx, hsi
, σA and σB
to the watchtower. After successful verification of the signatures,
the watchtower records it as the latest state for the given payment
channel and delivers a receipt σW T = Sign(skW T , cid ∥ idx ∥ hsi )
to both Alice and Bob. The watchtower will not sign and send
newer state to each party once any closure or dispute happened for
avoiding race conditions.

If all parties follow the protocol honestly, then all computations
and message exchanges can be performed off-chain. Moreover, the

AliceBobWatchtowercid,si,r,σAVerifyσAσBVerifyσBcid,hsi,idx,σA,BVerifyσσA,σB,σWTσA,σB,σWTPaymentExchangeAlgorithm 2: Tower Contract.
1 mappinд(inteдer ⇒ <cidArray[], stateArray[]>) Channels
2 mappinд(address ⇒ <customer , deposit >) Balances, k ← 0

3 function deposit(cid)
4

Balances[cid].customer ← msg.sender;
Balances[cid].deposit += msg.value;

5

6 function withdraw(cid, victim, percentaдe)
assert(victim = Balances[cid].customer)
7
assert(cid = msg.sender)
if percentaдe > 1 then
percentaдe ← 1

9

8

10

11

victim.transfer(Balances[cid].deposit × percentage)

12 function close(cid, si )
13

/*find() returns the index of cid

14

15

16

17

18

19

20

21

in cidArray, -1 means non-exist*/
cidIndex ← Channels[k].cidArray.f ind(cid)
if cidIndex = −1 then

Channels[k].cidArray.push(cid)
Channels[k].cidArray.push(si )

else

s ← Channels[k].stateArray[cidIndex]
Channels[k].stateArray[cidIndex] ← si

22 function update(Con f s)
23

assert(msд.sender = owner )
k ← k + 1
respond(Con f s, k − 1)

24

25

26 function respond(Con f s, n)
27

for 0 ≤ j < Channels[n].cidArray.lenдth() do

s ← Channels[n].stateArray[j]
if Confs[j] = 1 then

Channels[n].cidArray[j].call(payout(s, True))

else

Channels[n].cidArray[j].call(payout(s, False))

delete Channels[n]

28

29

30

31

32

33

4.5 Watchtower Contract Management
Tower contracts are deployed and managed by watchtowers. A
tower contract (see Algorithm 2) maintains two mapping (or dictio-
nary) data structures: Balances, Channels, and a bitmap structure
confirmation set (Confs).

Items in Balances can be referenced by Balances[cid], where
cid is the address of a channel contract. There are two fields for
each item and they can be accessed via Balances[cid].customer
and Balances[cid].deposit, which record the account (public
key) of an external owned account and its deposit respectively.

The data structure Channels with integer keys stores tuples
< cidArray[], stateArray[] > whose entries are two arrays, where
stateArray[i] is supposed to keep track of the state of the channel
contract with address (or cid) cidArray[i].

Confs stores a bit-vector (or a bitmap) whose jth bit indicates
whether the channel with address Channels[k].cidArray[j] is

allowed to be closed, where k is an update counter. Such a decision
is encoded via a single bit only. The Confs data structure is period-
ically updated by a watchtower. A rational watchtower wishing to
maximize its profit is expected to respond to a channel contract be-
fore a tolerance timeout t as otherwise its fee will decrease linearly
with the response delay. Since a single watchtower can be employed
by multiple channels, during each update period, a watchtower is
expected to capture multiple channel-closing transactions through
the closure events emitted by the channel contracts, containing the
values of cid, si , and a random number r , which are necessary for
the watchtower to verify the validity of the intended closing state.
Let us assume that during the update period, the watchtower
captures a sequence of closure events for channels with addresses

[cid0, cid1, · · · , cidm−1].
For each channel, the watchtower extracts relevant information
from the corresponding event and checks whether the closing state
si is compatible with its local record of the latest state of the chan-
nel. As a result, a confirmation set [b0, b1, · · · , bm−1] ∈ {0, 1}m is
constructed such that bj = 1 if and only if cidj is allowed to be
closed. Then the watchtower updates Confs in the tower contract
by calling its update() method with the newly constructed con-
firmation set. This triggers the respond() method which in turn
invokes the payout() method of the channel contract.

4.6 Payment Closure
Any payment channel participant who wants to finalize the channel
with a specific state si can initiate the channel closure process by
invoking the close() method of the channel contract presented
in Algorithm 1. After successfully verifying the supplied signatures
together with the associated state si and the random number r , the
channel contract changes its flag to DISPUTE and sets a tolerance
timeout t from now on. Afterwards, the close() method of the
watchtower contract can be called with the state si .

Then the watchtower contract updates the mapping data struc-
ture (Channels) by placing the cid and the state si into cidArray and
stateArray or only updating stateArray when cid already exists in
the cidArray (see line 15 - line 21 of Algorithm 2).

The interaction between the channel contract and the tower con-
tract is finished when the watchtower calls its update() method to
update the confirmation set structure. Then, the update() method
invokes the respond() method of the tower contract to determine
which channels are allowed to close according to values in Confs.
The respond() method will call the payout() method of all chan-
nels appearing in the Channels data structure with the decisions
on if they are allowed to be closed.

To illustrate different cases of this process, we show an example
scenario, where we assume that Alice and Bob have exchanged
three payment tuples:

T1 : (10, 0, 0),T2 : (7, 3, 1),T3 : (4, 6, 2).
As depicted in Figure 3, Alice closes cidi with T3. Once noticed,
a tolerance timeout t (e.g., one hour) would be triggered in the
channel contract that allows the tower contract to confirm the
submitted state and to proceed payout and consequently close the
channel. The tower contract replies to the channel contract based
on a confirmation set updated by the watchtower periodically. In

Table 1: Channel closure cost (per request).

Cost

Verify

Storage

Update

Payout

Misc

Total
USD

Number of Closure Request

100

57561
(14.0%)
151849
(37.0%)
84130
(20.5%)
35001
(8.5%)
82354
(20.0%)
410895
0.198

101

57572
(19.1%)
127812
(42.5%)
8523
(2.8%)
34469
(11.5%)
72409
(24.1%)
300785
0.145

102

57565
(20.6%)
113802
(40.8%)
860
(0.3%)
34472
(12.3%)
72510
(26.0%)
279209
0.135

103

57561
(20.7%)
113793
(40.9%)
167
(0.1%)
34462
(12.4%)
72487
(25.9%)
278470
0.134

5.1 Cost
In our protocol, to invoke the closure procedure, a party sends a
transaction with a proper state si which is verified first by the chan-
nel contract, then the watchtower interacts with the tower contract
which handles the closure event. The main cost is introduced due
to the computation and storage whose utilization is charged by the
Ethereum network. We perform a series of experiments to mea-
sure the cost in terms of gas consumption and its corresponding
monetary cost.

Closure. We conduct experiments for a different number of
channel closure requests, measure their gas cost and present the
results, together with the cost converted to US dollars 3, in Table 1.
We measure the cost of a channel closure for a different number
of requests, i.e., 10i (0 ≤ i ≤ 3) requests. Conservatively, we as-
sume that all the closure requests are submitted during the t-long
time period (i.e., all these requests will be processed using a single
confirmation set). From Table 1, we can see that the dominating
operation cost is due to the storage required for cid addresses and
states si . The cost also slightly decreases with the number of closure
requests due to data structure initialization cost that is paid upfront
when initializing a tower contract. Similarly, the cost of updating a
confirmation set also shows a decreasing trend per request since
a watchtower updates it in batches periodically. The more closure
events happen in t period the less each channel has to pay due to
they share equally. Therefore, as depicted the concept of fail-safe
watchtowers is cost-effective for handling a large number of chan-
nels. The payout procedure is the final step of the whole closure
process which has a stable cost with the channel number scaled.
The overall cost of each channel closure request is around $0.14.

Dispute. As discussed in Section 4.6, our design allows any party
to invoke a potential dispute process. The gas cost of the dispute
process is similar, despite additional verification operations are
required on the channel contract side. We conduct the analogical
experiments as in the previous case and the results are shown in

3The conversion was according to the gas price from https://ethgasstation.info/ at the
time of writing the paper.

Figure 3: Payment Termination.

particular, cidi would be allowed to close only if the corresponding
index is set to 1 in the confirmation set.

An alternative case is when Alice wants to misbehave by sub-
mitting the stale state of T2 and potentially benefiting due to her
higher balance. Therefore, she invokes a new close event passing T2
as the current state. However, in such a case, an honest watchtower
would deny the closure request since T2 is a stale state. Therefore,
the watchtower sets 0 in the corresponding position of the confir-
mation set for cidi . Once disallowed, a longer and fail-safe timeout
T (T ≫ t, e.g., a day or two) is initialized that ensures that the
deposit will not be paid out if any misbehavior happened. A similar
situation will happen when the watchtower does not respond on
time and T is also initialized. We assume that parties can connect to
the blockchain at least once per T, thus Bob would notice the misbe-
havior performed by Alice. Then Bob commits a dispute transaction
with T3 as an input , aiming to prove that T2 is an older off-chain
payment state. In such a case, the watchtower would resolve the
potential dispute and close the channel faster, namely, before T.
Otherwise, payout will be proceeded by any party after T units of
time.

By this design, our construction minimizes waiting times and
achieves fail-safe, as in common case a watchtower would confirm
payouts quickly. Meanwhile, the long timeout T prevents any mis-
behavior from parties or unavailability and wrongdoings from the
watchtower but without additional storage overhead introduced
compared with existing watching service schemes. Moreover, the
watchtower can minimize costs confirming multiple pending chan-
nel closure requests only with sending a single blockchain message.

5 IMPLEMENTATION AND EVALUATION
To evaluate our design, we implemented the payment channel
contract and the tower contract using the Solidity programming
language (compiler version 0.4.24) and we deployed our scheme on
an Ethereum testnet. The off-chain watchtower and two parties,
Alice and Bob, are implemented as a web server running Node.js
v10.2.1 bundled with the node-localStorage package for stor-
ing cid, si , Hs, and signatures. We employ web3.js 2 to interact
with deployed smart contracts. We use the Ethereum’s ECDSA sig-
nature scheme as the default one, as Ethereum provides a native
and optimized support for it.

2https://web3js.readthedocs.io/en/1.0/

AliceBobCCTCWatchtowerUpdateCC.close(si,σ)VerifyσTC.close(cid,si)UpdateAllowedtoCloseTerminatePayoutPayoutPaymentTerminationTable 2: Cost for dispute.

Off-chain Tx

Cost

Gas
USD

Steps

Vst at e Vt ime Closure
326123
30337
22752
0.157
0.015
0.011

Total

379212
0.183

Table 2. To successfully invoke a dispute, a party needs to submit a
newer signed and valid state si . The channel contract also checks
if current time is illegal before verifying the flag and validation of
si ). From Table 2, we can see that the most common closure case
still dominates the main cost within the dispute operation but the
entire cost is reasonably low at $0.183.

Confirmation Set. As discussed in Section 4.6, a watchtower
sends a single message to the blockchain network, creates an up-
dated confirmation set periodically which requires to be stored on
the channel contracts side. The size (and consequently the cost) of
this storage depends on the number of channel-closing requests.
To give insights on the cost, we measure the cost of updating a
confirmation set for the number of 10i (1 ≤ i ≤ 3) channels and
present the obtained results in Table 3. As shown, the cost for the
confirmation set update operation with a small number of channels
increases slightly. With the number of channels growing, our proto-
col shows a good characteristics where the only cost is around $0.1
for 103 channels per update transaction. Such a low cost is achieved
mainly by encoding every channel closure by only a single bit.

Table 3: Cost for set update.

Cost

Number of Channel
102
101

103

Total (gas)
USD

85232
0.043

85990
0.044

167363
0.085

5.2 Throughput
We evaluate the watchtower throughput running an instance on
a system with macOS Sierra 10.12.6, Intel Core i5 CPU (2.7 GHz),
and 8GB of RAM. We create 10i (0 ≤ i ≤ 4) off-chain transactions
between parties, each of them exchanges a state with a watchtower,
then we measure the total time needed by the watchtower to handle
the exchange steps, and compute the average time required per
transaction. The obtained results are summarized in Figure 4, where
we can see that the number of off-chain transactions handled per
second raises when requests are processed in batches. The through-
put becomes stable when the number of requests is greater than
104, with the total time cost around 3.95ms per off-chain exchange.

5.3 Efficiency Comparison
In this section, we compare Lightning Channels, Duplex micro-
payment channels, Raiden, PISA, and our work. All comparisons
are based on the protocol descriptions presented in the context
of Section 2. We focus on the number of signatures/transactions

d
n
o
c
e
s

r
e
p
d
e
l
d
n
a
h
s
n
o
i
t
c
a
s
n
a
r
T

300

200

100

100

101

102
Number of off-chain transaction

103

104

Figure 4: Throughput of the Watchtower.

Table 4: Comparison on the number of signatures/transac-
tions required for each stage.

Cost

Duplex [12]
Lightning [35]
Raiden [4]
PISA [29]
Our work

Setup
(d + 2) × 2
2 × 2
2
1 + 2
2

Stage

Payment

1
1 × 2
1
3
3

Dispute
1 × 2
≥ 3
≥ 2
≥ 3
2

required for each step in the above protocols and the corresponding
cost incurred.

Signatures and Transactions. Table 4 highlights the number
of signatures required for each stage of Duplex [12], Lightning [35],
Raiden [4], PISA [29], and our work. Next, we provide a comparison
on the number of signatures and transactions that are required for
each stage of the protocols. For the fairness of the comparison, we
assume that only two participants are involved in all protocols.

Lightning and Duplex require both participants to sign the chan-
nel’s state first, before cooperatively signing a so-called Funding
Transaction. The state in Lightning is simply a pair of commitment
transactions, thus there should be 2×2 transactions required in to-
tal. While in Duplex the state is the first branch of an invalidation
tree which consists of d nodes and two unidirectional channels. In
Raiden and our work, the channel setup stage requires one party
to sign a transaction to establish the channel with deposit. The
counter-party can sign another transaction that aims to deposit
coins and register identity by himself only. To initialize a channel in
PISA, a customer invokes a setup transaction with registering two
parties each of whom will respectively deposit coins afterwards.

As for the payment stage, Raiden and Duplex are used for a pair of
unidirectional channels which require a single signature generated
from a party to perform a newer payment. The current balance of
both parties should be maintained in Lightning. To update their
own balances and send an off-chain payment, both customers need
to sign a new transaction. Payment exchange in PISA requires
one party to separately sign a command message and new statei .
Both signatures σ cmd
are sent to a counter-party who
responds with a new agreed σ then. In our work, three signatures

and σ st at e
k

k

Table 5: Comparison on the cost for each step.

Step

Create Contract

Channel contract
Custodian contract
Tower contract

Interactions

Channel setup
Withdraw employment

Dispute Process

Party set state
Party initiates dispute
Party submit command
Transit state on-chain
Total resolve dispute

Cost

Cost (PISA)

Cost (Ours)

USD

1892135
1609613
✗

65504
89182

90130
78667
140275
149494
458566

1576314

1314215

0.761
✗ N.A.
0.635

77328
86347

0.037
0.042

✗ N.A.
✗ N.A.
✗ N.A.
✗ N.A.
0.183

379212

are required for every payment, including two from the transacting
parties and another one created by the watchtower.

Our work shows a good performance in the case of a dispute.
Lightning requires the disputer to send commitment transaction
first which is followed by two transactions where each party claims
its final balance and all unlocked conditional transfers. In some
cases, the conditional transfers can be associated with multiple lock
times. Therefore, an additional transaction to claim each conditional
transfer would be incurred which requires ≥3 transactions in total.
In Duplex, both parties must sign the states of the unidirectional
channels that represent their latest payment from the counter-party
and send both transactions to the blockchain. Similarly, each party
in Raiden sends the same two transactions to the network as in
Duplex. However, each conditional transfer that needs to be un-
locked requires the receiver to sign an additional transaction to
claim it, which takes ≥2 transactions to settle the dispute. When a
dispute occurs in PISA, any party within the channel can enforce
an on-chain state transition via the dispute process. First, one party
updates the state via setState then initiates the dispute using trig-
gerDispute. Moreover, PISA allows all parties to input a command
cmd to be considered for the state transition which requires ≥3
transactions in aggregate. In our protocol, one party signs a sin-
gle transaction to enforce a dispute. The channel will wait for a
decision from the tower contract managed by the watchtower who
sends another single message to resolve the dispute.

Cost. To further compare our scheme with the most related
work, we conducted experiments using the PISA implementation.
Table 5 presents the detailed cost comparison of our protocol and
PISA [29]. The result shows that one-time deployment cost of our
channel contract is lower than that of PISA since we remove the
state transition and input methods, and instead employ a tower
contract to handle closure and resolve dispute procedures. A watch-
tower periodically sends single message into tower contract where
only lightweight data structures are deployed to store cid and si .

It is also cost-effective compared with sophisticated logic of the
PISA’s custodian contract. In the channel setup phase, our protocol
needs to store one more information (the address of the watchtower)
while only public keys of both parties are saved in PISA. The cost
of the channel setup is slightly higher than in PISA but the differ-
ence is not significant. Both, our work and PISA allow withdrawing
deposited amount if parties are able to prove a watching service’s
wrongdoing. A customer in PISA first seeks recourse then invokes
the refund process but the cost of these operations is similar in
both protocols. When a dispute happens in PISA, one party first
sets collectively authorized state (setstate) then initiates dispute
process via triggerdispute. Afterwards, the party submits command
list (input) and eventually a state transition is executed on-chain
under the aid of custodian contract. Our work requires one party
to enforce dispute that proves the newer payment state has been
performed off-chain then employ tower contract to resolve. The
total cost is still lower than PISA. In conclusion, our work can be
regarded as more cost-effective.

Payout Timeouts. An important advantage of our design is
that in the common case (i.e., parties are honest and a watchtower
is available) the channel can be closed quickly. To confirm it empiri-
cally, we conducted an experiment to measure a time delay required
to close a channel. In our experiment the channel closures and the
corresponding payouts became part of the blockchain just after one
or two blocks (i.e., between 14-28 seconds on average), which is
significantly faster than in systems which silently accept closures
after a timeout. For instance, the timeouts in Raiden refer to the
number of blocks that are required to be mined from the time that
close() is called until the channel can be settled with a call to settle()
and its value is set by default to 50. With block arrival times of
Ethereum (14 seconds on average [5]) the required time in Raiden
is around 12 minutes. We emphasize, that usually it is a parameter
that parties can adjust; however, in the previous designs it also
constitutes the tolerable unavailability of watching services (thus,
too short timeout may cause the service ineffective).

5.4 Deployment Considerations

Scalability. For simplicity and an intuitive description, we only
give an example in the context of bidirectional payment channels
but our protocol can be easily extended to multiple payment chan-
nels and many users. To support channels with more than two
users, the off-chain exchange (see Section 4.4) would be scaled
without much more cost incurred as the signature verification and
communication expense are relatively cheap. Moreover, watchtow-
ers can easily scale to handle a large number of channels and the
confirmation set is easy to update and scale as well without increas-
ing overhead drastically. In practice, watchtowers can be realized
without incurring significant overheads and costs since they can
be implemented as light blockchain clients. To have a concrete per-
spective on the cost, we measure the communication and storage
overhead for watchtower deployment. As depicted in Figure 5, the
data layout exchanged from parties to watchtower (P → WT ) for
each off-chain exchange is an 198-bytes object, where cid indicates
the observed channel address, Hs encodes the hashed state value,
idx specifies the transaction index, σA and σB are the signatures
from both parties. Meanwhile, the results for the communication

Table 6: Watchtower Deployment Cost.

Cost

Storage

Cost

Communication

Number of channels
101

102

103

0.0011MB 0.1103MB

12MB

Type of communications

P → W T W T → P
195B

198B

P ⇔ P
165B

cost from watchtower to parties (WT → P) and between parties
(P ⇔ P) are shown in Table 6. Moreover, we measure the storage
cost of storing the latest state value for 10i (1 ≤ i ≤ 3) channels.
From Table 6, we can see that it takes only 12MB for a watchtower
to observe 103 channels.

20B

cid

32B

Hs

16B

idx

65B

σA

198 bytes

65B

σB

Figure 5: The layout of data from party to watchtower.

Incentives. The linear rewarding mechanism (see Section 4.3)
motivates watchtowers to maintain high availability and to shorten
payout timeouts. A mechanism punishing unavailable or failed
watchtowers is also implemented in our system where customers
submit the ineligibility proofs to the channel contract (see Algo-
rithm 1) and eventually withdraw their deposit. There are various
options for parties to employ a watchtower according to their per-
formance and commission, which in turn incentivizes watchtowers
to participant our system and provide better services.

6 SECURITY DISCUSSION
First, we show that all successfully verifiable messages created
within our protocol are authentic. As we assume that any party can-
not obtain a valid secret key of its counter-party (see Section 4.1), a
malicious party cannot generate and sign a payment state on behalf
of honest parties. This implies that the newer states are agreed
by all parties in our protocol. All channel closure, and optionally
dispute, transactions require states verification process first (see
in Section 4.6) which ensures that a state submitted by parties is
authentic (i.e., signed by all participants). The only way to obtain
such a state is to be signed and exchanged by both parties within
payment channels.

Next, we formalize our system by the following definitions and

we show its main security properties.

Definition 1. By definition, the protocol Π(P, W, A, ϕ, φ) is a
dynamic process with five components involved, where P denotes
the compliance parties in the payment channel, W represents the
watchtowers entities, A is a potential adversary, and ϕ and φ specify
the payment channel contract and the tower contract, respectively.

Definition 2. Let C = {online,offline} be a set of availability
states for the compliance parties and watchtowers (please note that

we consider a successful (D)DoS attack as the offline state). Then the
function

0/1 ← Fsecur e (PC, WC, A, statei , σst at e )

is triggered before the protocol Π(P, W, A, ϕ, φ) is finalized with
statei . PC and WC reveal the availability state of the honest parties
and watchtowers, statei denotes an off-chain payment transaction
submitted by any party while σst at e is the corresponding signature.
The output 1 means that the statei is the latest off-chain payment
state and the final payout should be performed, while 0 indicates that
there are suspicious misbehavior (e.g., an illegitimate dispute) and
additional actions should be performed to prevent the system from
going into an insecure state.

Observation 1. The channel is allowed to close with a correct

state submitted by honest P.

Proof. When the parties registered in the channel agree to close
the channel with statei , P sends a closure transaction to ϕ and then
the function Fsecur e (Ponline , Wonline , A, statei , σst at ei ) is exe-
cuted and returns 1. Afterwards, W checks the output of Fsecur e ,
□
updates Confs with φ and confirms the final payout with ϕ.

Observation 2. If A plays a strategy that finalizes the payment
channel with a stale state submitted when the counter-party P is in
the offline state (e.g., temporarily away or (D)DoSed), then A cannot
gain any unearned income from the channel.

Proof. We assume that A invokes a closure transaction by sub-
mitting the stale state statei . Before finalizing the channel, the
function Fsecur e (Pof f line , Wonl ine , A, statei , σst at ei ) outputs 0
since an eligible watchtower rejects the state which is not the latest
one. Then the long timeout T is initialized. In Section 4.6, we as-
sume that parties can connect to the blockchain at least once per T,
thus when P become available it would notice the misbehavior per-
formed by A. Then P sends the dispute transaction into ϕ with the
latest signed off-chain payment state. Eventually, W resolves the
dispute and the payment channel finalizes with a correct state. □

Observation 3. If W is unavailable (i.e., offline for a while or
under a (D)DoS attack launched by A), the protocol Π(P, W, A, ϕ, φ)
goes into a fail-safe state and the channel is still able to be finalized
with a correct state.

Proof. The Observation 3 has two implications. First, when W

is offline for a while and becomes inaccessible, the function

0 ← Fsecur e (Ponl ine , Wof f l ine , A, statei , σst at ei )
as it cannot interact with φ on time. Then a long timeout T is
triggered. In this period, the channel participant P submits a dispute
transactions into the blockchain. Afterwards, W is responsible for
resolving the dispute and closing the channel. Second, a similar
situation happens even when W undergoes a (D)DoS attack and
becomes unavailable, in the period of T , P performs dispute and ϕ
records the latest off-chain state. After T , the final payout would
□
be proceeded by any party with the correct state.

MITM Attack or Substitution Attack. To launch a MITM at-
tack, A can eavesdrop and intercept transactions from W to φ and
P to ϕ. For instance, he extracts the Confs and si respectively, then
constructs new transactions with the intercepted data. However, as
shown at the beginning of this section, the malicious transactions
cannot pass the verification procedures on ϕ and φ’s side since A
cannot compromise the underlying cryptographic primitives or
pretend to be the other parties. Any tiny change of the context (i.e.,
si ) will be caught by the signature verification process. Moreover,
other eavesdropping or MITM attacks can be easily mitigated by de-
ploying an end-to-end authenticated and encrypted communication
channel between the protocol parties.

Failure safety. The concept of fail-safe watchtowers ensures
that honest parties are able to close channels with a quick timeout
in most generic cases. However, when an adversary is intentionally
closing a channel with a stale state, a longer but safe-assurance
timeout is introduced. This long timeout avoids wrongdoing or
unavailability of watchtowers. In particular, any unavailable or
compromised watchtower should not accept channel closures in
silence. In contrast to competing systems, this design introduces
longer timeouts only for the worst-case (i.e., a misbehaving peer),
while in the common case (i.e., honest peers and an available watch-
tower) channels are closed quickly and safe.

State privacy. Our protocol provides the so-called state privacy
as proposed in [29], which is an extension of the notion of value
privacy [28]. Unless the details of the state are revealed by the
channel participants in order to finalize the channel, a watchtower
only learns the hash value H(si ∥ r ). Therefore, the metadata of
all intermediate states are invisible to the watchtower, thus the
privacy of the off-chain transactions is protected. Note that the
hash value is computed with a large random number r , which
prevents a watchtower from finding the pre-image by exhausting
si , whose entropy can be fairly low.

Availability. Requiring watchtowers to keep off-chain verified
states and updating confirmation sets introduces a single point of
failure, as with a failed (or (D)DoSed) watchtower it would not be
possible to respond to a channel closure request. Fortunately, as
discussed, in this case a longer timeout will be triggered. Moreover,
a watchtower instance can be easily replicated by replicas running a
traditional distributed consensus protocol to share current channel
states.

7 SHORT-LIVED ASSERTIONS
7.1 Motivation
Although watchtowers increase the security of payment channels,
in small-amount (micro)payment scenarios their deployment may
be economically inefficient. Traditional bank-based transactions
usually incur between 21 to 25 cents (in the US) fees [32] plus a per-
centage of the transaction amount. To better understand fee struc-
tures in blockchain platform, we investigated them for Ethereum
and Bitcoin. For example, a plain transaction in Ethereum (without
executing smart contracts) currently costs around $0.011 4 and simi-
larly in Bitcoin transaction fees are usually at least 0.0001 BTC [32],

4The estimation is from https://ethgasstation.info/

corresponding to between 2.5 and 10 cents over the last five years.
As depicted in Figure 6(a) and Figure 6(d) the average transaction
fees of Bitcoin decreased to around $0.5 in recent six months while
staying around $0.1 in Ethereum. Meanwhile, Figure 6(b) shows a
vivid insight that most transactions fees in Bitcoin stand between
$0.025 and $0.125.

The concept of watchtowers may be economically viable for
most generic payment cases which can achieve quick channel ter-
mination. However, customers in such scenarios like online gaming,
video streaming, or energy markets [3], should perform transac-
tions almost continuously with tiny amounts. In Figure 6(c) and
Figure 6(e), we show that for the Ethereum platform, the median
transaction value transferred in recent half-year is less than $0.15.
Therefore, small payments are still dominating the majority of all
transactions in Ethereum.

Although, it is hard to estimate the transaction distribution in
payment channels (as this data is not public) we can assure a lower
bound for a watchtower profitability. We set Γ to denote the cost
of renting a watchtower and Σtx represents the total expense of
a blockchain transaction in a channel. The value of Σtx includes
the value transferred and transaction fees incurred. When parties
perform tiny-amount transactions, i.e., when

Σtx < Γ

it means that the cost of the watchtower involved is higher than
the cost the contract termination by itself. Therefore, employing a
watchtower in such a case is economically ineffective.

To mitigate this limitation, we introduce short-lived assertions
that allow channel contracts to distinguish out-of-date and rel-
atively fresh payment states without relying on any other third
party.

7.2 Mechanism
A generic limitation of existing payment channels is that smart con-
tracts operating them cannot distinguish whether a given statement
is the latest one, as an on-chain smart contract does not know an
off-chain state without being updated (payment channels exactly
want to limit on-chain updates). As a consequence, a stale signed
assertion can be sent to a contract which without knowing about
its freshness would temporarily accept it as the current one. To
mitigate this issue, we introduce short-lived assertions that allow
a channel contract to distinguish a fresh state from old ones, and
possibly close the channel with a fresh state quicker.

We assume that [PAYk −1, PAYk +1] are off-chain transactions be-
tween Alice and Bob conducted just after arrival of blocks blocki−1
and blocki+1 respectively as depicted in Figure 7. In our construc-
tion, each party appends a block hash value when exchanging a
newer micropayment state, such that a state is extended by a block
hash value which acts as a freshness information (i.e., it implies
that the transaction is newer than the given block). For instance,
PAYk −1 would be generated as:

σP AYk −1

= SignskA, B

(balA ∥ balB ∥ idx ∥ H (blocki−1)),

where H (blocki−1) represents the hash value of the current block.
As our main goal is to eliminate any third party, like a watch-
tower, channel contracts should be able to distinguish by themselves
a possibly stale state from relatively fresh states. Interestingly, that

Figure 6: (a) Historical transaction fees of Ethereum and Bitcoin, (b) Bitcoin transaction fees versus frequency for 1 million
transactions, (c) Historical transaction value of Ethereum, (d) Average transaction fees of Ethereum and Bitcoin in recent 6
months, (e) Median transaction value of Ethereum in recent 6 months.

can be simply realized, as smart contract languages allow contracts
to access recent block hashes, therefore, a channel contract can ver-
ify that the given state is fresh by verifying it against n last recent
block hashes (where n can be a contract-specific parameter). If such
a state is submitted it implies that it was created recently, thus the
channel contract can be closed faster as a) it is likely that the state
is quite accurate, thus even if one party successfully misbehaves,
its benefit will be relatively small or marginal, b) it is likely that the
both parties are still online, thus any party can mitigate potential
misbehavior. If the channel contract receives a state which is stale
(i.e., older than n last blocks), then it triggers a dispute with a long
timeout T .

Short-lived assertion is a complementary solution that can be
applicable for circumstances in which watchtowers are economi-
cally unjustified. We believe that it may be especially interesting
in applications like micro- or nanopayments. Another interesting
property of this solution is that it ensures both parties that they
see the same version of the blockchain (they sign the same recent
block hash with every transaction), thus it can additionally protect
them from some blockchain-fork related attacks.

PAYk −1

PAYk +1

blocki−2

blocki−1

blocki

blocki+1

blocki+2

Figure 7: Short-lived Assertions Example

7.3 Evaluation
In the design of short-lived assertions, each off-chain transactions
is associated with the current block hash value. A channel contract
customizes a freshness limit n to determine whether the statement
is relatively fresh or not via simply checking how old is the block
hash from the statement. The cost incurred depends on the size
of the freshness limit and the statement submitted. The larger the
limit is set, the more gas would be spent as more checks need to
proceed in the worst case. We measure the total cost of short-lived
assertions verification (including state parsing, state verification,
and block hash value freshness verification) for the limit values
set to 2 × i (1 ≤ i ≤ 3) blocks, and describe the data in Table 7.
Please note that the cost results come from the worst case execution
for every different freshness limit, which means that the channel
contract should verify the freshness check of the block hash value

Table 7: Cost for short-lived assertions verification.

Cost

Total (gas)
USD

Relative freshness limit (blocks)

2

110178
0.055

4

163365
0.082

6

203267
0.102

for all blocks within limit. As shown in Table 7, the total cost for
short-lived assertions with the limit set to two blocks is $0.05. With
the freshness limit increasing, more block hash evaluations are
processed thus the cost increases as well.

8 CONCLUSIONS
In this paper, we propose novel fail-safe watchtowers that do not
constantly watch on-chain payment channel contracts but watch
off-chain transactions and only send a single on-chain message
periodically. We show that our watchtowers are fail-safe and effi-
cient, easily handling thousands of payment channels. Our design
minimizes timeouts required in the common case, as a watchtower
can immediately confirm a channel closure without waiting for a
long timeout.

Moreover, we show that watchtowers in general may be econom-
ically ineffective in terms of micropayments and multiple payment
scenarios. We introduce short-lived assertions that allow channel
contracts to distinguish fresh and stale assertions and process chan-
nel closures accordingly. Combinations and extensions of these
frameworks can be an interesting future research topic. In particu-
lar, we would like to investigate fail-safe watchtowers publishing
current channel states with a randomized probabilistic set imple-
mentations (like Bloom filters) instead of a bitmap like presented.

ACKNOWLEDGMENTS
We thank the anonymous reviewers for their valuable comments
and suggestions. This research is supported by the Ministry of
Education, Singapore, under its MOE AcRF Tier 2 grant (MOE2018-
T2-1-111) and by the SUTD SRG ISTD 2017 128 grant.

REFERENCES
[1] 2014. Ethereum: A next-generation smart contract and decentralized application

platform. https://github.com/ethereum/wiki/wiki/White-Paper.

[2] 2016. Unlinkable outsourced channel monitoring. https://bit.ly/2vj8jx1.
[3] 2017. Ethereum Probabilistic Micropayment. https://bit.ly/2iesuFx.
[4] 2018. Raiden network. http://raiden.network/.
[5] 2019. Ethereum Block Time. https://etherscan.io/chart/blocktime.
[6] 2019. Run your business with Visa. https://usa.visa.com/run-your-business/small-

business-tools/retail.html.

[7] Georgia Avarikioti, Felix Laufenberg, Jakub Sliwinski, Yuyi Wang, and Roger
Wattenhofer. 2018. Towards Secure and Efficient Payment Channels. CoRR
(2018).

[8] Iddo Bentov, Rafael Pass, and Elaine Shi. 2016. Snow White: Provably Secure

Proofs of Stake. IACR Cryptology ePrint Archive (2016).

[9] Alessandro Chiesa, Matthew Green, Jingcheng Liu, Peihan Miao, Ian Miers, and
Pratyush Mishra. 2017. Decentralized anonymous micropayments. In Annual
International Conference on the Theory and Applications of Cryptographic Tech-
niques.

[10] Kyle Croman, Christian Decker, Ittay Eyal, Adem Efe Gencer, Ari Juels, Ahmed
Kosba, Andrew Miller, Prateek Saxena, Elaine Shi, Emin Gün Sirer, et al. 2016.
On scaling decentralized blockchains. In International Conference on Financial
Cryptography and Data Security.

[11] Michael Crosby, Pradan Pattanayak, Sanjeev Verma, Vignesh Kalyanaraman, et al.
2016. Blockchain technology: Beyond bitcoin. Applied Innovation (2016).
[12] Christian Decker and Roger Wattenhofer. 2015. A fast and scalable payment net-
work with bitcoin duplex micropayment channels. Symposium on Self-Stabilizing
Systems (2015).

[13] Alexandra Dmitrienko, David Noack, and Moti Yung. 2017. Secure Wallet-Assisted
Offline Bitcoin Payments with Double-Spender Revocation. In Proceedings of the
2017 ACM on Asia Conference on Computer and Communications Security.
[14] Stefan Dziembowski, Lisa Eckey, Sebastian Faust, and Daniel Malinowski. 2017.
PERUN: Virtual Payment Channels over Cryptographic Currencies. IACR Cryp-
tology ePrint Archive (2017).

[15] Stefan Dziembowski, Sebastian Faust, and Kristina Hostáková. 2018. General
state channel networks. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security.

[16] Ittay Eyal, Adem Efe Gencer, Emin Gün Sirer, and Robbert Van Renesse. 2016.
Bitcoin-ng: A scalable blockchain protocol. In 13th USENIX Symposium on Net-
worked Systems Design and Implementation NSDI.

[17] Arthur Gervais, Ghassan O Karame, Karl Wüst, Vasileios Glykantzis, Hubert
Ritzdorf, and Srdjan Capkun. 2016. On the security and performance of proof of
work blockchains. In Proceedings of the 2016 ACM SIGSAC conference on computer
and communications security.

[18] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. In
Proceedings of the 26th Symposium on Operating Systems Principles.

[19] Matthew Green and Ian Miers. 2017. Bolt: Anonymous Payment Channels for
Decentralized Currencies. In Proceedings of the 2017 ACM SIGSAC Conference on
Computer and Communications Security.

[20] Lewis Gudgeon, Pedro Moreno-Sanchez, Stefanie Roos, Patrick McCorry, and
Arthur Gervais. 2019. SoK: Off The Chain Transactions. Cryptology ePrint
Archive, https://eprint.iacr.org/2019/360.pdf.

[21] Mike Hearn. 2013. Micro-payment channels implementation now in bitcoin.

https://bitcointalk.org/index.php?topic=244656.0.

[22] Kexin Hu and Zhenfeng Zhang. 2018. Fast Lottery-Based Micropayments for
Decentralized Currencies. In 23rd Australasian Conference on Information Security
and Privacy.

[23] Maxim Jourenko, Kanta Kurazumi, Mario Larangeira, and Keisuke Tanaka. 2019.
SoK: A Taxonomy for Layer-2 Scalability Related Protocols for Cryptocurrencies.
Cryptology ePrint Archive, https://eprint.iacr.org/2019/352.

[24] Rami Khalil and Arthur Gervais. 2017. Revive: Rebalancing off-blockchain pay-
ment networks. In Proceedings of the 2017 ACM SIGSAC Conference on Computer
and Communications Security.

[25] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017.
Ouroboros: A Provably Secure Proof-of-Stake Blockchain Protocol. In Advances
in Cryptology 37th Annual International Cryptology Conference.

[26] Joshua Lind, Ittay Eyal, Florian Kelbert, Oded Naor, Peter Pietzuch, and Emin Gun
Sirer. 2017. Teechain: Scalable blockchain payments using trusted execution
environments. arXiv preprint arXiv:1707.05454 (2017).

[27] Loi Luu, Viswesh Narayanan, Kunal Baweja, Chaodong Zheng, Seth Gilbert, and
Prateek Saxena. 2015. Scp: A computationally-scalable byzantine consensus
protocol for blockchains. https:// bit.ly/ 2WWUocj (2015).

[28] Giulio Malavolta, Pedro Moreno-Sanchez, Aniket Kate, Matteo Maffei, and Sri-
vatsan Ravi. 2017. Concurrency and privacy with payment-channel networks. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security.

[29] Patrick McCorry, Surya Bakshi, Iddo Bentov, Andrew Miller, and Sarah Meikle-
john. 2018. Pisa: Arbitration Outsourcing for State Channels. IACR Cryptology
ePrint Archive, https:// eprint.iacr.org/ 2018/ 582 (2018).

[30] Andrew Miller, Iddo Bentov, Ranjit Kumaresan, and Patrick McCorry. 2019.
Sprites: Payment channels that go faster than lightning. In Financial Cryptography
and Data Security 2019.

[31] Olaoluwa Osuntokun. 2015. Hardening lightning, harder, better, faster stronger.

https://stanford.io/2IEfpos.

[32] Rafael Pass and Abhi Shelat. 2015. Micropayments for Decentralized Currencies.
In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communi-
cations Security.

[33] Rafael Pass and Elaine Shi. 2017. The Sleepy Model of Consensus. In 23rd Inter-
national Conference on the Theory and Applications of Cryptology and Information
Security.

[34] Rafael Pass and Elaine Shi. 2018. Thunderella: Blockchains with Optimistic
Instant Confirmation. In 37th Annual International Conference on the Theory and
Applications of Cryptographic Techniques.

[35] Joseph Poon and Thaddeus Dryja. 2016. The bitcoin lightning network: Scalable
off-chain instant payments. https://lightning.network/lightning-network-paper.
pdf.

