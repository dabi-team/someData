HYDRA: HYbrid Design for Remote Attestation
(Using a Formally Veriﬁed Microkernel)

Karim Eldefrawy*
Information and Systems Sciences Lab
HRL Laboratories
keldefrawy@hrl.com

Norrathep Rattanavipanon
Computer Science Department
University of California, Irvine
nrattana@uci.edu

Gene Tsudik
Computer Science Department
University of California, Irvine
gene.tsudik@uci.edu

7
1
0
2

r
a

M
4
1

]

R
C
.
s
c
[

2
v
8
8
6
2
0
.
3
0
7
1
:
v
i
X
r
a

Abstract—Remote Attestation (RA) allows a trusted entity
(veriﬁer) to securely measure internal state of a remote untrusted
hardware platform (prover). RA can be used to establish a static
or dynamic root of trust in embedded and cyber-physical systems.
It can also be used as a building block for other security services
and primitives, such as software updates and patches, veriﬁable
deletion and memory resetting. There are three major classes
of RA designs: hardware-based, software-based, and hybrid, each
with its own set of beneﬁts and drawbacks.

This paper presents the ﬁrst hybrid RA design – called HYDRA
– that builds upon formally veriﬁed software components that
ensure memory isolation and protection, as well as enforce access
control to memory and other resources. HYDRA obtains these
properties by using the formally veriﬁed seL4 microkernel.
(Until now, this was only attainable with purely hardware-based
designs.) Using seL4 requires fewer hardware modiﬁcations to
the underlying microprocessor. Building upon a formally veriﬁed
software component
the
overall design of HYDRA and its implementation. We instantiate
HYDRA on two commodity hardware platforms and assess the
performance and overhead of performing RA on such platforms
via experimentation; we show that HYDRA can attest 10MB of
memory in less than 500msec when using a Speck-based message
authentication code (MAC) to compute a cryptographic checksum
over the memory to be attested.

increases conﬁdence in security of

I. INTRODUCTION

In recent years, embedded systems (ES), cyber-physical
systems (CPS) and internet-of-things (IoT) devices, have per-
colated into many aspects of daily life, such as: households,
ofﬁces, buildings, factories and vehicles. This trend of “smart-
iﬁcation” of everything that was previously analog (or at least
not connected) brings many obvious beneﬁts. However, it also
expands the attack surface and turns these newly computerized
gadgets into natural and attractive targets.

Remote Attestation (RA) is the process whereby a trusted
entity called “veriﬁer” securely probes internal state of a
remote and untrusted hardware platform, called “prover.” RA
can be used to establish a static or dynamic root of trust in ES,
CPS and IoT devices. Also, RA can be used as a foundation for
constructing more specialized security services, e.g., software
updates, veriﬁable deletion and memory resetting. There are
three main classes of RA designs: hardware-based, software-
based, and hybrid (blending hardware and software). Each
class has its own advantages and limitations. This paper

*Currently at
karim@csl.sri.com

the Computer Science Laboratory, SRI

International.

introduces the ﬁrst hybrid RA design – called HYDRA –
based upon formally veriﬁed components to provide memory
isolation and protection guarantees. Our main rationale is
that designing RA techniques based upon such components
increases conﬁdence in security of such designs and their
implementations. Of course, ideally, one would formally prove
security of the entirety of an RA system, as opposed to proving
security separately for each component and then proving that
its composition is secure. However, we believe that this is not
yet possible given the state-of-the-art in (automated) formal
veriﬁcation and synthesis of hardware and software.

One recent prominent example illustrating difﬁculty of cor-
rectly designing and implementing security primitives (espe-
cially, those blending software and hardware) is the TrustZone-
based Qualcomm Secure Execution Environment (QSEE) ker-
nel vulnerability and exploit reported in CVE-2015-6639 [19].
ARM TrustZone [4] is a popular System-on-Chip (SoC) and
a CPU system-wide approach to security, it is adopted in
billions of processors on various platforms. CVE-2015-6639
enables privilege escalation and allows execution of code in the
TrustZone kernel which can then be used to achieve undesired
outcomes and expose keying material. This vulnerability was
used to break Android’s Full Disk Encryption (FDE) scheme
by recovering the master keys [1]. Our intention with this
example is to demonstrate difﬁculty of getting both the design
and the implementation right, as well as a motivation to use
formally veriﬁed building blocks, which (we hope) will yield
more secure RA techniques. To this end, our RA design uses
the formally veriﬁed seL4 microkernel to obtain memory iso-
lation and access control. Such features have been previously
attained with hardware in designs such as [7] and [14]. Using
seL4 requires fewer hardware modiﬁcations to the underlying
microprocessor and provides an automated formal proof of
isolation guarantees of the implementation of the microkernel.
To the best of our knowledge, this is the ﬁrst attempt to design
and implement RA using a formally veriﬁed microkernel.

The main goal of this paper is to investigate a previ-
ously unexplored segment of the design space of hybrid RA
schemes, speciﬁcally,
incorporate formally
techniques that
veriﬁed and proven (using automated methods) components,
such as the seL4 microkernel. Beyond using seL4 in our
design, our implementation is also based on the formally
veriﬁed executable of seL4; that executable is guaranteed to
adhere to the formally veriﬁed and proven design. Another

 
 
 
 
 
 
important goal, motivation and feature of our design is the
expanded scope of efﬁcient hybrid RA techniques. While ap-
plicability of prominent prior results (particularly, SMART [7]
and TrustLite [14]) is limited to very simple single-process
low-end devices, we target more capable devices that can
run multiple processes and threads. We believe that
this
paper represents an important and necessary step towards
building efﬁcient hybrid RA techniques upon solid and veriﬁed
foundations. Admittedly, we do not verify our entire design
and prove its security using formal methods. However, we
achieve the next best thing by taking advantage of already-
veriﬁed components and carefully arguing security of the
overall design, considering results on systematic analysis of
features required for securely realizing hybrid RA [8]. To
achieve our goals we make two main contributions: (1) design
of HYDRA – the ﬁrst hybrid RA technique based on the
formally veriﬁed seL4 microkernel which provides memory
isolation and access control guarantees, (2) implementations of
HYDRA on two commercially available development boards
(Sabre Lite and ODROID-XU4) and their extensive analysis
via experiments to demonstrate practicality of the proposed
design. We show that HYDRA can attest 10MB of memory
in less than 500ms when using Speck [20] as the underlying
block-cipher to compute a cryptographic checksum over the
memory to be attested.
Organization: Section II overviews related work, followed
by Section III which presents our goals and assumptions. The
design of HYDRA is presented in Section IV and its security
analysis in Section VI. Implementation issues and performance
assessment are discussed in Sections V and VII.

II. RELATED WORK

Prior work in remote attestation (RA) can be divided into
three approaches: hardware-based, software-based, and hybrid.
a) Hardware-Based Remote Attestation: The hardware-
based approach typically relies on the security provided by a
Trusted Platform Module (TPM) [26]. A TPM is a secure co-
processor designed to protect cryptographic keys, and utilize
them to encrypt or digitally sign data. A TPM can also
produce a summary (e.g., hash) of hardware and software
conﬁgurations in the system. A typical TPM also contains
Platform Conﬁguration Registers (PCR) that can be used as a
secure storage of such a conﬁguration summary. The values
in PCRs can then be used as an evidence of attestation by
accumulating an unforgeable chain of values of the system’s
state since the last reset. A TPM eventually signs these
values with an attestation key along with a random challenge,
provided by a veriﬁer, and submits the computed result to the
veriﬁer. Gasmi et al. [10] presents how to link this evidence
to secure channel end-points.

b) Software-Based Remote Attestation: Despite resisting
all but physical attacks, the hardware-based approach is not
suitable for embedded devices due to its additional software
complexity and expense. Therefore, many software-only RA
approaches have been proposed, speciﬁcally for embedded

devices. Pioneer [22] is among the ﬁrst to study RA with-
out relying on any secure co-processor or CPU-architecture
extensions. The main idea behind Pioneer is to create a
special checksum function with run-time side-effects (e.g.,
status registers) for attestation. Any malicious emulation of
said checksum function can be detected through additional
timing overhead incurred from the absence of those side-
effects. Security of this approach became questionable after
several attacks on such schemes (i.e., [6]) were demonstrated.
c) Hybrid Remote Attestation: The main shortcoming
of the software-based approach is that it makes strong as-
sumptions about adversarial capabilities, which may be un-
satisﬁed in practical networked settings [2]. Thus, several
hybrid software-hardware co-designs have been proposed to
overcome this limitation. SMART [7] presents a hybrid ap-
proach for RA with minimal hardware modiﬁcations to ex-
isting MCUs. In addition to having uninterruptable attestation
code and attestation keys resided in ROM, this architecture
utilizes a hard-wired memory protection unit (MPU) to restrict
access to secret keys to only SMART code. The attestation is
performed inside ROM-resident attestation code by computing
a cryptographic checksum over a memory region and returning
the value to the veriﬁer. TrustLite [14] extends [7] to enable
RA while supporting an interrupt handling in a secure place.
In addition to the above work designing RA schemes,
[8] provides a systematic treatment of RA by presenting a
precise deﬁnition of the desired service and proceeding to
its systematic deconstruction into necessary and sufﬁcient
(security) properties. These properties are then mapped into
a minimal collection of hardware and software components
that results in secure RA. We build on the analysis in [8] and
utilize these properties and components (which are described
in Section III) and show how to instantiate them in new ways
to develop our new hybrid RA design, HYDRA.

III. GOALS AND ASSUMPTIONS

This section presents an overview of HYDRA and the
rationale behind its design, discusses the common remote
attestation (RA) security objective and features, and the ad-
versary model.

A. Design Rationale

Our main objective is to explore a new segment of the
design space for RA schemes. Our hybrid RA design –
HYDRA – requires very little in terms of secure hardware
and builds upon the formally veriﬁed seL4 microkernel. As
shown in Section V, hardware support needed by HYDRA
is readily available on commercial off-the-shelf development
boards and processors, e.g., Sabre Lite and ODROID-XU4
boards. The rationale behind our design is that seL4 offers
certain guarantees (mainly process isolation and access control
to memory and resources) that provide RA features that
were previously feasible only using hardware components. In
particular, what was earlier attained using additional MCU
controls and Read-Only Memory (ROM) in the SMART [7]

2

and TrustLite [14] architectures can now be instantiated using
capability controls in seL4.

To motivate and justify the design of HYDRA, we start
from the work by Francillon, et al. [8]. It provides a systematic
treatment of RA by developing a semi-formal deﬁnition of RA
as a distinct security service, and systematically deconstructing
into a necessary and sufﬁcient security objective, from
it
which speciﬁc properties are derived. These properties are
then mapped into a collection of hardware and software
components that results in an overall secure RA design. Below,
we summarize the security objective in RA and its derived
security properties. In Sections IV and V we show how the
security objective and each property are satisﬁed in HYDRA
design and instantiated in two concrete prototypes based on
the Sabre Lite and ODROID-XU4 boards.

B. Hybrid RA Security Objective and Derived Properties

According to [8], the RA security objective is to allow a
(remote) prover (PRV) to create an unforgeable authentication
token, that convinces a veriﬁer (VRF) that the former is in
some well-deﬁned (expected) state. Whereas, if PRV has been
compromised and its state has been modiﬁed, the authentica-
tion token must reﬂect this. [8] also describes a combination
of platform properties that achieve aforementioned security
objective. The goal of the analysis in [8] is to obtain a set of
properties that are both necessary and sufﬁcient for secure RA.
The security objective is examined and the properties needed
to attain it are identiﬁed. The conclusion is that the following
properties collectively represent the minimal and necessary set
to achieve secure RA on any platform.

• Exclusive Access to Attestation Key (K): the attestation
process (PAttest) must be the only one with access to K.
This is the most difﬁcult property to impose on embedded
(especially, low-end and mid-range) devices. As argued in
[8], this property is unachievable without some hardware
support on low-end devices. If the underlying proces-
sor supports multiple privilege modes and a full-blown
separation of memory for each process, one could use a
privileged process to handle all computations that involve
the key. However, low-end and medium-end processors
generally do not offer such “luxury” features.

• No Leaks: no information related to (or derived from)
K must be accessible after the execution of PAttest
completes. To achieve this, all intermediate values that
depend on the key – except the ﬁnal attestation token to
be returned to VRF – must be securely erased, when
they are no longer needed. This is again applicable to
very low-end devices, with none or minimal Operating
System (OS) support and assuming that memory is shared
between processes. However, if the underlying hardware
and/or software (i.e., OS) guarantees that each process’
memory is inaccessible by any other process, then this
property is trivially satisﬁed.

• Immutability: To ensure that the attestation executable
(Attest) cannot be modiﬁed, SMART [7] and the design
in [8] place it in ROM, which is available on most,

even low-end, platforms. ROM is certainly one relatively
inexpensive way to enforce Attest’s code immutability.
However, owing to seL4’s features, Attest in HYDRA is
resident in, and executed from, RAM.

• Uninterruptability: Execution of Attest must be uninter-
ruptible. This is necessary to ensure that malware does not
obtain the key (or some function thereof) by interrupting
Attest while any key-related values remain in registers or
other accessible locations. As discussed later, HYDRA
achieves this property by assuring that it runs with the
highest possible priority under seL4.

• Controlled Invocation (aka Atomicity): Attest must only
be invocable from its ﬁrst instruction and must exit only
at one of its legitimate last (exit) instruction. This is
motivated by the need to prevent code-reuse attacks.
[8] has one additional property of Secure Reset when someone
attempts to start the attestation executable (Attest) from the
middle. We argue that a complete secure reset is not needed
if controlled invocation is enforced. All that is needed in that
case is to raise an exception as long as the memory space of
Attest is protected and integrity of executable is guaranteed.

C. Adversarial Model & Other Assumptions

Based on the recent taxonomy in [2], adversaries in the RA

context can be categorized as follows:

• Remote Adversaries: exploit vulnerabilities in a prover’s
software to inject (over the network) malware onto it.
• Local Adversaries: locate sufﬁciently near in order to
eavesdrop on, and manipulate, the prover’s communica-
tion channel(s).

• Physical Adversaries: have full (local) physical access to
the prover and its hardware and can perform physical at-
tacks, e.g., side-channel attacks to obtain keys, physically
extract memory values, and modify the states of various
hardware components.

Similar to prior hybrid RA designs, HYDRA aims to protect
against remote and local adversaries, while physical adver-
saries are out-of-scope. We note that, at least in a single-
prover setting1, protection against physical attacks can be
attained by encasing the CPU in tamper-resistant coating and
employing standard techniques to prevent side-channel key
leakage. These include: anomaly detection,
internal power
regulators and additional metal layers for tamper detection.
We consider PRV to be a (possibly) unattended remote
hardware platform running multiple processes on top of seL4.
Once PRV boots up and runs in steady state, the adversary
(ADV) might exercise complete control over all application
software (including code and data) before and after execution
of PAttest. As physical attacks are out of scope, ADV cannot
induce hardware faults or retrieve a stored K using side
channels. ADV also has no means of interrupting execution of
seL4 or the PAttest code when invoked (how this is ensured
will be demonstrated later). Finally, recall that PRV and VRF
must share at least one secret (attestation) key K. This key can

1See [12] for physical attack resilience in groups or swarms of provers.

3

CSpace is managed by, and stored inside, the kernel. Instead, a
thread can invoke an operation on a kernel object by providing
a pointer to a capability that has sufﬁcient authority for that
object to the kernel. For example, sender A in Figure 1 needs
a write capability of EP for sending a message, while receiver
B needs a read capability to receive a message. Besides read
and write, grant is another access right in seL4, available only
for an endpoint object. Given possession of a grant capability
for an endpoint, any capability from the possessor can be
transferred across that endpoint. For instance, if A in Figure 1
has grant access to EP, it can issue one of its capabilities, say
a frame, to B via EP. Also, capabilities can be statically issued
during a thread’s initialization by the initial process. The initial
process is the ﬁrst executable user-space process loaded into
working memory (i.e., RAM) after the seL4 microkernel is
loaded. This special process then forks all other processes.
Section IV-D describes the role, the details and the capabilities
of the initial process in HYDRA design.

seL4’s main “claim to fame” is in being the ﬁrst formally
veriﬁed general-purpose operating system. Formal veriﬁcation
of the seL4 microkernel is performed by interactive, machine-
assisted and machine-checked proof using a theorem prover Is-
abelle/HOL. Overall functional correctness is obtained through
a reﬁnement proof technique, which demonstrates that the
binary of seL4 reﬁnes an abstract speciﬁcation through three
layers of reﬁnement. Consequently (under some reasonable
assumptions listed in Appendix B) the seL4 binary is fully
two
captured by the abstract speciﬁcations. In particular,
important feature derived from seL4’s abstract speciﬁcations,
are that: the kernel never crashes. Another one is that: every
kernel API call always terminates and returns to user-
space. Comprehensive details of seL4’s formal veriﬁcation
can be found in [13].

Another seL4 feature very relevant to our work is: correct-
ness of access control enforcement derived from functional
correctness proof of seL4. [23] and [15] introduce formal
deﬁnitions of the access control model and information ﬂow
in seL4 at the abstract speciﬁcations. They demonstrate the
reﬁnement proof from these modiﬁed abstract speciﬁcations
to the C implementation using Isabelle/HOL theorem prover,
which is later linked to the binary level (by the same theorem
prover). As a result, three properties are guaranteed by the
access control enforcement proof: (1) Authority Conﬁnement,
(2) Integrity and (3) Conﬁdentiality. Authority conﬁnement
means that authority propagates correctly with respect to its
capability. For example, a thread with a read-only capability
for an object can only read, and not write to, that object.
Integrity implies that system state cannot be modiﬁed without
explicit authorization. For instance, a read capability should
not modify internal system state, while write capability should
only modify an object associated with that capability. Finally,
conﬁdentiality means that an object cannot be read or inferred
without a read capability. Thus, the proof indicates that access
control in seL4, once speciﬁed at the binary level, is correctly
enforced as long as the seL4 kernel is active.

We now show how seL4’s access control enforcement

Fig. 1: Sample seL4 instantiation from [23].

be pre-loaded onto PRV at installation time; it is stored as
part of PAttest binaries. We do not address the details of this
procedure.

IV. HYDRA DESIGN

We ﬁrst overview seL4 and discuss how it can be used
in HYDRA to realize previously identiﬁed RA properties. We
then describe the sequence of operations in HYDRA.

A. seL4 Overview

seL4 is a member of the L4 microkernel family, specif-
ically designed for high-assurance applications by providing
isolation and memory protection between different processes.
These properties are mathematically guaranteed by a full-code
level functional correctness proof, using automated tools. A
further correctness proof of the C code translation is presented
in [24], thus extending functional correctness properties to the
binary level without needing a trusted compiler. Therefore,
behavior of the seL4 binary strictly adheres to, and is fully
captured by, the abstract speciﬁcations.

Similar to other operating systems, seL4 divides the virtual
memory into two separated address spaces: kernel-space and
user-space. The kernel-space is reserved for the execution of
the seL4 microkernel while the application software is run in
user-space. By design, and adhering to the nature of microker-
nels, the seL4 microkernel provides minimal functionalities to
user-space applications: thread, inter-process communication
(IPC), virtual memory, capability-based access control and
interrupt control. The seL4 microkernel leaves the implemen-
tations of other traditional operating system functions – such
as device drivers and ﬁle systems – to user-space.

Figure 1 (borrowed from [23]) shows an example of seL4
instantiation with two threads – sender A and receiver B –
that communicate via an EndPoint EP. Each thread has a
Thread Control Block (TCB) that stores its context, including:
stack pointer, program counter, register values, as well as
pointers to Virtual-address Space (VSpace) and Capability
Space (CSpace). VSpace represents available memory regions
that the seL4 microkernel allocated to each thread. The root
of VSpace represents a Page Directory (PD), which contains
Page Table (PT) objects. Frame object representing a region
of physical memory resides in a PT. Each thread also has its
own kernel managed CSpace used to store a Capability Node
(CNode) and capabilities. CNode is a table of slots, where
each slot represents either a capability or another CNode.

A capability is an unforgeable token representing an access
control authorization of each kernel object or component. A
thread cannot directly access or modify a capability since

4

property satisﬁes required RA features.

B. Deriving seL4 Access Controls from Properties

We now describe access control conﬁguration of seL4
user-space that achieves most required properties for secure
RA, as described in section III. We examine each feature
and identify the corresponding access control conﬁguration.
Unlike previous hybrid designs, HYDRA pushes almost all
of these required features into software, as long as the seL4
microkernel boots correctly. (A comparison with SMART and
TrustLite is in Table I.)

a) Exclusive Access to K: directly translated to an access
control conﬁguration. Similar to previous hybrid approaches,
K can be hard-coded into the Attest at production time. Thus,
Attest needs to be conﬁgured to be accessible only to PAttest.
b) No Leaks: achieved by the separation of virtual ad-
the virtual memory used for K-
dress space. Speciﬁcally,
related computation needs to be conﬁgured to be accessible
to only PAttest.

c) Immutability: achieved using combination of veriﬁ-
able boot and runtime isolation guarantee from seL4. At
runtime, Attest must be immutable, which can be guaranteed
by restricting the access control to the executable to only
PAttest. However, this is not enough to assure immutability of
Attest executable because Attest can be modiﬁed after loaded
into RAM but before executed. Hence, a veriﬁable boot of
Attest is required.

d) Uninterruptability: satisﬁed by setting the scheduling
priority of PAttest higher than other processes since the formal
proof of seL4 scheduling mechanism guarantees that a lower
priority process cannot preempt the execution of a higher
priority process. In addition, seL4 guarantees that, once set,
the scheduling priority in seL4 cannot be increased at runtime
(but possible to decrease the priority value).

Note that this feature implies PAttest needs to be the initial
user-space process since the seL4 microkernel always assigns
the highest priority to the initial process.

e) Controlled Invocation: achieved by the isolation of
process’ execution. In particular, TCB of PAttest cannot be
accessed or manipulated by other processes.

With these features, we conclude that the access control
conﬁguration of seL4 user-space needs to (at least) include
the following:
C1 PAttest has exclusive access to Attest; this also includes
K residing in Attest. (Recall that PAttest is the attestation
process, while Attest
is the executable that actually
performs attestation.)

C2 PAttest has exclusive access to its TCB.
C3 PAttest has exclusive access to its VSpace.
Even though this access control conﬁguration can be enforced
at the binary code level, this assumption is based on that
seL4 is loaded into RAM correctly. However, this can be
exploited by an adversary by tricking the boot-loader to
boot his malicious seL4 microkernel instead of the formally
veriﬁed version and insert a new conﬁguration violating above
access controls. Thus, the hardware signature check of the

Fig. 2: Sequence of Operation in HYDRA

seL4 microkernel code is required at boot time. The similar
argument can also be made for PAttest’ code. As a result, ad-
ditional integrity check of PAttest’ code needs to be performed
by seL4 before executing.

C. Building Blocks

In order to achieve all security properties described above,

HYDRA requires the following four components.

a) Read-Only Memory:

region primarily storing im-
mutable data (e.g. hash of public keys or signature of software)
required for secure boot of the seL4 microkernel.

b) MCU Access Control Emulation: high-assurance soft-
ware framework capable of emulating MCU access controls
to attestation key K. At present, seL4 is the only formally
veriﬁed and mathematically proven microkernel capable of this
task.

c) Attestation Algorithm: software residing in PAttest
and serving two main purposes: authenticating an attestation
request, and performing attestation on memory regions.

d) Real-Time Clock: loosely synchronized (with VRF )
real-time clock for detecting replayed, reordered and delayed
requests. If PRV does not have a clock, a secure counter
can replace a real-time clock with a sacriﬁce of the delayed
message detection.

D. Sequence of Operation

The sequence of operations in HYDRA, shown in Figure 2,

has three steps: boot, setup, and attestation.

a) Step 1: Boot Process: Upon a boot, PRV ﬁrst ex-
ecutes a ROM-resident boot-loader. The boot-loader veriﬁes
authenticity and integrity of the seL4 microkernel binary.
Assuming this veriﬁcation succeeds, the boot-loader loads all
executables, including kernel and user-space, into RAM and
hands over control to the seL4 microkernel. Further details of
secure boot in our prototype can be found in Section V.

b) Step 2: seL4 Setup: The ﬁrst task in this step is to
have the seL4 microkernel setting up the user-space and then
starting PAttest as the initial user-space process. Once the
initialization inside the kernel is over, the seL4 microkernel
gathers capabilities for all available memory-mapped locations
and assigns them to PAttest. The seL4 kernel also performs

5

TABLE I: Security Properties in Hybrid RA Designs

Security Property

SMART [7]

TrustLite [14]

Exclusive Access to K

HW (Mod. Data Bus)

SW (programmed MPU)

SW (CQUAL and Deputy)

HW (CPU Exception Engine)

No Leaks

Immutability

HYDRA

SW (seL4)

SW (seL4)

HW (ROM)

HW (ROM) and SW (programmed MPU)

HW (ROM) and SW (seL4)

Uninterruptability

SW (Interrupt Disabled)

HW (CPU Exception Engine)

Controlled Invocation

HW (ROM)

HW (ROM)

SW (seL4)

SW (seL4)

an authenticity and integrity check of PAttest to make sure
that it has not been modiﬁed. After successful authentication,
the seL4 microkernel passes control to PAttest.

With full control over the system, PAttest starts the rest
of user-space with a lower scheduling priority and distributes
capabilities that do not violate the conﬁguration speciﬁed
earlier. After completing conﬁguration of memory capabilities
and starting the rest of the user-space, PAttest initializes the
network interface and waits for an attestation request.

c) Step 3: Attestation: An attestation request, sent by a
veriﬁer, consists of 4 parameters: (1) TR reﬂecting PRV ’s
time when the request was generated, (2) target process p,
(3) its memory range [a, b] that needs to be attested, and (4)
cryptographic checksum CR of the entire attestation request.
Similar to SMART [7], the cryptographic checksum func-
tion used in attestation is implemented as a Message Authen-
tication Code (MAC), to ensure authenticity and integrity of
attestation protocol messages.

Upon receiving an attestation request PAttest checks
whether TR is within an acceptable range of the PRV ’s real-
time clock before performing any cryptographic operation; this
is in order to mitigate potential DoS attacks. If TR is not fresh,
PAttest ignores the request and returns to the waiting state.
Otherwise, it veriﬁes CR. If this fails, PAttest also abandons
the request and returns to the waiting state.

Once the attestation request is authenticated, PAttest com-
putes a cryptographic checksum of the memory region [a, b]
of process p. Finally, PAttest returns the output to VRF . The
pseudo-code of this process is shown in Algorithm 1.

V. HYDRA IMPLEMENTATION

To demonstrate feasibility and assess practicality of HY-
DRA, we implement two prototypes of it on two commercially
available hardware platforms: ODROID-XU4 [11] and Sabre
Lite [5]. We focus here more on the Sabre Lite implementation
due to the lack of an seL4 compatible networking (e.g., Eth-
ernet) driver and a programmable ROM in current ODROID-
XU4 boards. Section VII presents a detailed performance
evaluation of the HYDRA implementation.

A. seL4 User-space Implementation

Our prototype is implemented on top of version 1.3 of
the seL4 microkernel [17]. The complete implementation,
including helper libraries and the networking stack, consists
of 105, 360 lines of C code (see Table II for a more detailed

Algorithm 1: Attest Pseudo-Code
Input

: TR timestamp of request

p target process for attestation
a, b start/end memory region of target process
CR cryptographic checksum of request

Output: Attestation Report

1 begin
2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18
19 end

/* Check freshness of timestamp and verify request */
if ¬ CheckFreshness(TR) then

exit();

end
if ¬ VerifyRequest(CR, KAuth, TR(cid:107)p(cid:107)a(cid:107)b) then

exit();

end
/* Retrieve address space of process p */
M em ← RetrieveMemory(p);
/* Compute attestation report */
MacInit(K);
MacUpdate(TR(cid:107)p(cid:107)a(cid:107)b);
for i ∈ [a, b] do

MacUpdate(M em[i]);

end
out ← MacFinal();
return out

breakdown). The overall size of executable is 817KB whereas
the base seL4 microkernel size is 215KB. Excluding all helper
libraries, the implementation of HYDRA is just 600 lines of
C code. In the user-space, we base our C code on following
libraries: seL4utils, seL4vka and seL4vspace; these libraries
provide the abstraction of processes, memory management and
virtual space respectively. In our prototypes, PAttest is the
initial process in the user-space and receives capabilities to
all memory locations not used by seL4. Other processes in
user-space are spawned by this PAttest. We also ensure that
access control of those processes does not conﬂict with what
we speciﬁed in Section IV. The details of this access control
implementation are described below in this section.

The basic C function calls are implemented in muslc library.
seL4bench library is used to evaluate timing and performance
of our HYDRA implementation. For a timer driver, we rely
on its implementation in seL4platsupport. All source code for
these helper libraries can be found in [16] and these libraries
contribute around 50% of the code base in our implementation.
We use an open-source implementation of a network stack
and an Ethernet driver in the user-space [18]. We argue that

6

TABLE II: Complexity of HYDRA Impl. on Our Prototype

Complexity

HYDRA with
net. and libs

HYDRA w/o
net. stack

HYDRA w/o
net. and libs

seL4 Kernel
Only

LoC
Exec Size

105,360
817KB

68,490
721KB

11,938
N/A

9,142
215KB

this component, even though not formally veriﬁed, should not
affect security objective of HYDRA as long as an IO-MMU is
used to restrict Direct Memory Access (DMA) of an Ethernet
driver. The worst case that can happen from not formally
veriﬁed network stack is symmetrical denial-of-service, which
is out of scope of HYDRA.

Fig. 3: Image Layout in Flash

B. Secure Boot Implementation

Here, we describe how we integrate an existing secure boot

feature (in Sabre Lite) with our HYDRA implementation.

a) Secure Boot in Sabre Lite: NXP provides a secure
boot feature for Sabre Lite boards, called High Assurance
Boot (HAB) [9]. HAB is implemented based on a digital
signature scheme with public- and private-keys. A private-
key is required to generate a signature of the software image
during manufacturing whereas a public-key is used by ROM
APIs for decrypting and verifying the software signature at
boot time. A public-key and a signature are attached to the
end of software image, which is pre-installed into a ﬂash
medium during manufacturing. The digest of a public-key is
fused into a one-time programmable ROM in order to ensure
the authenticity of the public-key and the booting software
image. At boot time, the ROM boot-loader ﬁrst loads the
software image into RAM and then veriﬁes an attached public-
key by comparing it with the reference hash value in ROM.
It then authenticates the software image through the attached
signature and the veriﬁed public-key. Execution of this image
is allowed only if signature veriﬁcation succeeds. Without
a private-key, an adversary cannot forge a legitimate digital
signature and thus is unable to insert and boot his malicious
image.

b) Secure Boot of HYDRA: HAB can be utilized to
ensure that the seL4 microkernel is the ﬁrst program initial-
ized after the ROM boot-loader. Therefore, the entire seL4
microkernel binary code can be covered when computing the
digital signature by HAB during manufacturing. Moreover, the
seL4 microkernel needs to be assured that it gives control
of the user-space to the veriﬁed PAttest. Thus,
the seL4

7

microkernel has to perform an integrity check of PAttest
before launching it. As a result, a hash of Attest needs to be
included in the seL4 microkernel’s binaries during production
time and be validated upon starting the initial process.

With this procedure, a chain of trust is established in the
remote attestation system in HYDRA. This implies that no
other programs, except the seL4 microkernel can be started
by the ROM boot-loader and consequently only PAttest is the
certiﬁed initial process in the user-space, which achieve the
goal of secure boot of remote attestation system. Figure 4
illustrates the secure boot of HYDRA in Sabre Lite prototype.

C. Access Control Implementation

Here we describe how the access control conﬁguration spec-
iﬁed in section IV is implemented in our HYDRA prototype.
Our goal is to show that in the implementation of HYDRA no
other user-space processes, except PAttest, can have any kind
of access to: (1) the binary executable code (including K),
(2) the virtual address space of PAttest, and (3) the TCB of
PAttest. To provide those access restrictions in the user-space,
we make sure that we do not assign capabilities associated to
those memory regions to other user-space processes. Recall
that PAttest as the initial process contains all capabilities to
every memory location not used by the seL4 microkernel.
And there are two ways for PAttest
to issue capabilities:
dynamically transfer via endpoint with grant access right or
statically assign during bootstrapping a new process.

In our implementation, PAttest does not create any endpoint
with grant access, which disallows any capability of PAttest
to transfer to a new process after created. Thus, the only
way that capabilities can be assigned to a new process is
before that process is spawned. When creating a new process,
PAttest assigns only minimal amount of capabilities required
to operate that process, e.g. in our prototype, only the CSpace
root node and fault endpoint (used for receiving IPCs when
this thread faults) capabilities are assigned to any newly
created process. Limited to only those capabilities, any other
process cannot access the binary executable code as well as
existing virtual memory and TCB of PAttest.

Moreover, during bootstrapping the new process, PAttest
creates a new PD object serving as the root of VSpace in
the new process. This is to ensure that any new process’
virtual address space is initially empty and does not overlap
with the existing virtual memory of PAttest. Without any
further dynamic capability distribution, this guarantees that
other processes cannot access any memory page being used
by PAttest. Sample code for conﬁguring a new process in our
prototype is provided in Appendix C.

D. Key Storage

Traditionally, in previous hybrid designs, a prover device
requires a special hardware-controlled memory location for
securely storing K and protecting it from software attacks.
However, in HYDRA, it is possible to store K in a normal
memory location (e.g. ﬂash) due to the formally veriﬁed
access control and isolation properties of seL4. Moreover,

Fig. 4: Secure Boot Sequence in Sabre Lite Prototype

since K is stored in a writable memory, its update can easily
happen without any secure hardware involvement. Thus, in our
prototypes, K is hard-coded at production time and stored in
the same region as Attest.

Besides K, HYDRA contains another key, KAuth, used
for verifying an authenticity of an attestation request. KAuth
can be a separate key and pre-stored next to K during a
production time; or, KAuth can be derived from K through
a key derivation function (KDF) at runtime as well.

E. Timestamp Generation

Recall (Section IV) that a timestamp generated by a loosely
synchronous real-time clock is required for ensuring freshness
of attestation requests. There is currently no implementa-
tion of drivers for real-time clock in seL4. We generate a
pseudo-timestamp by a counter, whose driver is provided by
seL4platsupport, and a timestamp of the ﬁrst validated request,
as follows: When a device ﬁrst wakes up and securely start
PAttest. PAttest promptly loads a timestamp, Tsave, that was
previously saved in a separated location of ﬂash medium
before the last reset. When the ﬁrst attestation request arrives,
PAttest checks its attached timestamp, Tf irst, whether it is
greater than Tsave and proceeds to V erif yRequest if that
is the case. After the assurance of the validated request,
PAttest keeps track of Tf irst and start a counter. At any
time afterwards, a timestamp can be constructed by combining
the current counter value with Tf irst. In addition, PAttest
periodically generates and saves this timestamp value into ﬂash
medium for the next reboot’s usage.

VI. SECURITY ANALYSIS

In this section, we (informally) demonstrate how HYDRA
satisﬁes the minimal set of requirements to realize secure
RA (described in Section III). The following are key features
ensured in the design and implementation of HYDRA:

(1) the seL4 microkernel is the ﬁrst executable that is
loaded in a HYDRA-based system upon boot/initialization.
Correctness of this step is guaranteed by a ROM integrity
check at boot time, e.g., HAB in the Sabre Lite case.

(2) The attestation process (PAttest ) 2 is the ﬁrst user-
space process that is loaded into memory and is bootstrapped

2PAttest is different from Attest per Figure 3. PAttest is what is called
“initial process” in Figure 3 and it contains Attest executable as a component.

by seL4. This is also guaranteed using a software integrity
check step performed by seL4 before spawning the initial
process.

(3) PAttest then starts with the highest scheduling priority
and never decreases its own priority value. This can be
guaranteed by ensuring the code of PAttest does not contain
any system calls to decrease its priority.

(4) Any other subsequent process that is loaded on top of
the seL4 microkernel is spawned by PAttest and does not
receive the highest scheduling priority. This can be ensured by
inspecting the PAttest code and ensuring that all invocations
of other processes are with a lower priority value. Once a
process is loaded with a certain priority, seL4 prevents it
from increasing its priority value; this is formally veriﬁed and
guaranteed in the seL4 implementation.

(5) The software executable and K can only be mapped into
the address space of PAttest. This is guaranteed by ensuring
that in the PAttest code no other process on initialization
(performed in PAttest ) receives the capabilities to access said
memory ranges.

(6) Virtual memory used by PAttest cannot be used by any
other process; this includes any memory used for any compu-
tation touching the key, or related to other values computed
using the key. This is formally veriﬁed and guaranteed in the
seL4 implementation.

(7) Other processes cannot control or infer execution of
PAttest (protected by exclusive capability to TCB’s PAttest).
(8) Access control properties, i.e., authority conﬁnement,
are

integrity
mathematically guaranteed by its formal veriﬁcation.

conﬁdentiality,

seL4’s

binary

and

in

Given the above features, the security properties in Section

III are satisﬁed because:

Exclusive Access to K: (5), (6) and (8) guarantee that only

PAttest can have access to K.

No Leaks: (6) and (8) ensures that intermediate values
created by key-related computation inside PAttest cannot be
leaked to or learned by other processes.

Immutability: (1) and (2) implies that HYDRA is initial-
ized into the correct expected known initial states and that the
correct binary executable is securely loaded into RAM. (5)
also prevents other processes from modifying that executable.

8

(a) MAC Implementations

(b) Memory Mapping in seL4

(c) MacMem and RetrieveMem

(d) MacMem vs Mem Size

(e) MacMem vs Num Processes

Fig. 5: Evaluation of HYDRA in SabreLite prototype

Uninterruptability: (3) and (4) guarantees that other pro-
cesses, always having a lower priority value compared to
PAttest, cannot interrupt the execution of PAttest.

Controlled Invocation: (7) ensures that the execution of

PAttest cannot be manipulated by other applications.

VII. EXPERIMENTAL EVALUATION

We present here performance evaluation of HYDRA using
the Sabre Lite prototype. (Results of HYDRA on ODROID-
XU4 are in Appendix A). We conduct experiments to assess
speed of, and overhead involved in, performing attestation
using different types of keyed Message Authentication Code
(MAC) functions, on various numbers of user-space processes
and sizes of memory regions to be attested. We obtain the
fastest performance using the Speck MAC; HYDRA can attest
10MB in less than 500msec in that case.

a) Breakdown of Attestation Runtime: Recall from Sec-
tion IV, that the attestation algorithm (Algorithm 1) is com-
posed of three operations. V erif yRequest (lines 3 to 9) is
responsible for verifying an attestation request and whether
it has been recently generated by an authorized veriﬁer.
RetrieveM em (line 11) maps memory regions from a target
process to PAttest’s address space and returns a pointer to
the mapped memory. M acM em (lines 13 to 20) computes a
cryptographic checksum (using K) on the memory regions.

As shown in Table III, the runtime of M acM em contributes
the highest amount of the overall Attest runtime: 84% of total
time for attesting 1MB of memory and 90% for attesting 10
KB of memory on Sabre Lite; whereas RetrieveM em and

V erif yRequest together require less than 20% of the overall
time.

b) Performance of RetrieveM em in seL4: Another
important factor affecting the performance of HYDRA is the
runtime of RetrieveM em: the time PAttest takes to map the
attested memory regions to its own virtual address space. As
expected, Figure 5b illustrates the memory mapping runtime
in seL4 is linear in terms of mapped memory size. In addition,
we compare the runtime of RetrieveM em and M acM em on
larger memory sizes. Figure 5c illustrates that the runtime ratio
of RetrieveM em to various implementations of M acM em
is always less than 20%. This conﬁrms that retrieving memory
and mapping it to the address space account for only a small
fraction of the total attestation time in HYDRA. This illustrates
that whatever overhead seL4 introduces when enforcing ac-
cess control on memory is not signiﬁcant and does not render
HYDRA impractical.

c) Performance of M acM em in seL4: Since M acM em
is the biggest contributor to the runtime of our implemen-
tations, we explore various types of (keyed) cryptographic
checksums and their performance on top of seL4. We compare
the performance of ﬁve different MAC functions, namely,
CBC-AES [25], HMAC-SHA-256 [3], Simon and Speck [20],
and BLAKE2S [21], on 1MB of data in the user-space of
seL4. The performance results in Figure 5a illustrate that the
runtime of MAC based on Speck-64-128 3 and BLAKE2S in
seL4 are similar; and they are at least 33% faster than other
MAC functions when running on Sabre Lite.

3Speck with 64-bit block size and 128-bit key size

9

TABLE III: Performance Breakdown of Algorithm 1 on I.MX-
SL @ 1GHz

Operations

1 MB of Memory

10 KB of Memory

Time in cycle

Proportion

Time in cycle

Proportion

V erif yRequest
RetrieveM em
M acM em
Overall

3,992
8,731,858
49,021,846
57,757,696

<0.01%
15.11%
84.89%
100%

3,961
47,136
476,857
527,954

0.75%
8.93%
90.32%
100%

d) Performance of M acM em vs Memory Sizes: Another
factor that affects M acM em’s performance is the size of
memory regions to be attested. We experiment by creating
another process in the user-space and perform attestation on
various sizes (ranging from 1MB to 10MB) of memory regions
inside that process. As expected, the results of this experiment,
illustrated in Figure 5d, indicate that M acM em performance
is linear as a function of the attested memory sizes. This
experiment also illustrates feasibility of performing attestation
of 10MB of memory on top of seL4 in HYDRA using a
Speck-based MAC in less than half a second.

e) Performance on M acM em vs Numbers of Processes:
This experiment answers the following question: How would
an increase in number of processes affect the performance
of HYDRA? To answer it, we have the initial process spawn
additional user-space processes (from 2 to 20 extra processes)
and, then, perform M acM em on 100 KB memory data in one
of those processes. To ensure fair scheduling of every process,
we set priority of all processes (including the initial process)
to the maximum priority. The result from Figure 5e indicates
that the performance of M acM em is reasonably linear as a
function of the number of processes on Sabre Lite.

VIII. CONCLUSIONS

This paper presents the ﬁrst hybrid Remote Attestation
design, HYDRA, that leverages the formally veriﬁed seL4
microkernel to instantiate memory and process isolation, and
enforce access control to memory and other resources; such
isolation and access control have been ensured through hard-
ware in previous designs. We implement HYDRA on two com-
modity hardware platforms and demonstrate feasibility and
practicality of hybrid RA schemes that signiﬁcantly improve
security in contemporary embedded and cyber-physical sys-
tems, and that can work on commodity hardware and require
no modiﬁcation to it while providing security guarantees that
can be assured using automated formal methods.

REFERENCES

[1] Extracting qualcomm’s keymaster keys!
[2] T. Abera, N. Asokan, L. Davi, F. Koushanfar, A. Paverd, A.-R. Sadeghi,
in
In Proceedings of the 53rd Annual Design Automation

and G. Tsudik.
iot systems.
Conference, page 121. ACM, 2016.
[3] Apple Computer, Inc. LibOrange, 2006.
[4] ARM Limited. Arm security technology - building a secure system

trust: on building trust

Invited-things,

trouble,

using trustzone technology, 2009.

[5] Boundary Devices. BD-SL-I.MX6.

10

[6] C. Castelluccia, A. Francillon, D. Perito, and C. Soriente. On the difﬁ-
culty of software-based attestation of embedded devices. In Proceedings
of the 16th ACM conference on Computer and communications security,
pages 400–409. ACM, 2009.

[7] K. Eldefrawy, G. Tsudik, A. Francillon, and D. Perito. SMART: Secure
and minimal architecture for (establishing a dynamic) root of trust. In
Network and Distributed System Security Symposium (NDSS). Internet
Society, 2012.

[8] A. Francillon, Q. Nguyen, K. B. Rasmussen, and G. Tsudik. A
the
minimalist approach to remote attestation.
conference on Design, Automation & Test in Europe, page 244. European
Design and Automation Association, 2014.

In Proceedings of

[9] Freescale Semiconductor, Inc.

i.MX 6 Linux High Assurance Boot

(HAB) User’s Guide. Technical report, 2013.

[10] Y. Gasmi, A.-R. Sadeghi, P. Stewin, M. Unger, and N. Asokan. Beyond
secure channels. In Proceedings of the 2007 ACM workshop on Scalable
trusted computing, pages 30–40. ACM, 2007.

[11] Hardkernel co., Ltd. ODROID-XU4.
[12] A. Ibrahim, A.-R. Sadeghi, G. Tsudik, and S. Zeitouni. Darpa: Device

attestation resilient to physical attacks.

[13] G. Klein, J. Andronick, K. Elphinstone, T. Murray, T. Sewell, R. Kolan-
ski, and G. Heiser.
Comprehensive formal veriﬁcation of an os
microkernel. ACM Transactions on Computer Systems (TOCS), 32(1):2,
2014.

[14] P. Koeberl, S. Schulz, A.-R. Sadeghi, and V. Varadharajan. TrustLite: A
security architecture for tiny embedded devices. In European Conference
on Computer Systems, 2014.

[15] T. Murray, D. Matichuk, M. Brassil, P. Gammie, T. Bourke, S. Seefried,
C. Lewis, X. Gao, and G. Klein. sel4: from general purpose to a proof
of information ﬂow enforcement. In Security and Privacy (SP), 2013
IEEE Symposium on, pages 415–429. IEEE, 2013.

[16] National ICT Australia. seL4 Libraries, 2014.
[17] National ICT Australia. The seL4 Repository, 2014.
[18] National ICT Australia. UNSW Advanced Operating Systems, 2014.
[19] National Vulnerability Database. Vulnerability summary for cve-2015-

6639.

[20] B. Ray, S. Douglas, S. Jason, T. Stefan, W. Bryan, and W. Louis. The
simon and speck families of lightweight block ciphers. Technical report,
Cryptology ePrint Archive, Report./404, 2013.

[21] M. Saarinen and J. Aumasson. The blake2 cryptographic hash and

message authentication code (mac). Technical report, 2015.

[22] A. Seshadri, M. Luk, E. Shi, A. Perrig, L. van Doorn, and P. Khosla.
Pioneer: Verifying code integrity and enforcing untampered code exe-
In ACM Symposium on Operating Systems
cution on legacy systems.
Principles (SOSP), pages 1–16. ACM, 2005.

[23] T. Sewell, S. Winwood, P. Gammie, T. Murray, J. Andronick, and
In International Conference on

G. Klein.
Interactive Theorem Proving, pages 325–340. Springer, 2011.

sel4 enforces integrity.

[24] T. A. L. Sewell, M. O. Myreen, and G. Klein. Translation validation
for a veriﬁed os kernel. In ACM SIGPLAN Notices, volume 48, pages
471–482. ACM, 2013.

[25] The OpenSSL Project. Openssl 1.1.0-pre7-dev, 2016.
[26] Trusted Computing Group. Trusted platform module (tpm).

This material is based on research sponsored by the De-
partment of Homeland Security (DHS) Science and Technol-
ogy Directorate, Cyber Security Division (DHS S&T/CSD)
BAA HSHQDC-14-R-B00016, and the Government of United
Kingdom of Great Britain and the Government of Canada
via contract number D15PC00223. The views and conclusions
contained herein are those of the authors and should not be
interpreted as necessarily representing the ofﬁcial policies or
endorsements, either expressed or implied, of the Department
of Homeland Security, the U.S. Government, or the Govern-
ment of United Kingdom of Great Britain and the Government
of Canada

M acM em runtime. In addition, the MAC runtime, shown in
Figure 6c, is also linear in memory sizes to be attested. Lastly,
runtime of the BLAKE2S-based MAC function achieves less
than 200 milliseconds for attesting 10MB of memory regions
in ODROID-XU4

APPENDIX B
seL4’S PROOF ASSUMPTIONS

seL4’s functional correctness proof is based on the follow-

ing assumptions:

• Assembly - it assumes the correctness of ARM assembly
code mainly for entry to and exit from the kernel and
direct hardware accesses.

• Hardware - it assumes hardware operates according to

its speciﬁcation and has not been tampered with.

• Hardware Management - it assumes the correctness
of the underlying hardware management,
including a
translation look-aside buffer (TLB) and cache-ﬂushing
operations.

• Boot Code - it assumes the correctness of code that boots

the seL4 microkernel into memory.

• Direct Memory Access (DMA) - it assumes DMA is

disabled or trusted.

• Side-channels - it assumes there is no timing side-

channels.

APPENDIX C
SAMPLE CODE FOR STARTING NEW PROCESS
In our implementation, PAttest creates a new empty process

with the default conﬁguration below:

int sel4utils_configure_process_custom(sel4utils_process_t *

process, vka_t *vka, vspace_t *spawner_vspace,
sel4utils_process_config_t config)

(a) MAC Implementations

(b) M acM em vs Num Processes

(c) M acM em vs Mem Size

Fig. 6: Evaluation of HYDRA in ODROID-XU4 prototype

{

APPENDIX A
HYDRA’S PERFORMANCE IN ODROID-XU4

We also evaluate performance of HYDRA in ODROID-XU4
@ 2.1 GHz. Despite not having an Ethernet driver, we evaluate
the core component of HYDRA: M acM em. Unlike the results
in Section VII, BLAKE2S-based MAC achieves the fastest
performance for attesting 10MB on ODROID-XU4 platform.
a) MAC Performance in Linux vs in seL4: Figure 6a
illustrates the performance comparison of various keyed MAC
functions on ODROID-XU4 hardware platform when running
on Ubuntu 15.10 and seL4. The result emphasizes the feasi-
bility of RA in seL4 since the runtime of seL4-based RA can
be as fast as that of RA running on top of widely prominent
Linux operating system.

b) MAC Performance on ODROIX-XU4: The result in
Section VII and the one from above demonstrate that Speck-
and BLAKE2S-based MACs have the fastest attestation run-
time in seL4. We conduct additional experiments on those two
MAC functions in ODROID-XU4 platform. Figure 6b asserts
the linear relationship between number of processes and

int error;
sel4utils_alloc_data_t * data = NULL;
memset(process, 0, sizeof(sel4utils_process_t));
seL4_CapData_t cspace_root_data = seL4_CapData_Guard_new(0,

seL4_WordBits - config.one_level_cspace_size_bits);

/* create a page directory */
process->own_vspace = config.create_vspace;
error = vka_alloc_vspace_root(vka, &process->pd);
if (error) {

goto error;

}

/* assign an asid pool */
if (assign_asid_pool(config.asid_pool, process->pd.cptr) !=

seL4_NoError) {

goto error;

}

/* create a cspace and copy its cap to the new process */
process->own_cspace = config.create_cspace;
if (create_cspace(vka, config.one_level_cspace_size_bits,

process, cspace_root_data) != 0) {
goto error;

}

/* create a fault endpoint and copy its cap to the new

if (create_fault_endpoint(vka, process) != 0) {

process */

goto error;

11

}

/* create a vspace */
sel4utils_get_vspace(spawner_vspace, &process->vspace, &

process->data, vka, process->pd.cptr,
sel4utils_allocated_object, (void *) process);

/* finally elf load */
process->entry_point = sel4utils_elf_load(&process->vspace,

spawner_vspace, vka, vka, config.image_name);

return -1;

}

return 0;

}

if (process->entry_point == NULL) {

goto error;

}

/* create the thread */
error = sel4utils_configure_thread(vka, spawner_vspace, &

process->vspace, SEL4UTILS_ENDPOINT_SLOT, config.
priority, process->cspace.cptr, cspace_root_data, &
process->thread);

if (error) {

goto error;

}

return 0;

error:

/* clean up */
...

return -1;

}

int sel4utils_configure_thread_config(vka_t *vka, vspace_t *

parent, vspace_t *alloc, sel4utils_thread_config_t config,
sel4utils_thread_t *res)

{

memset(res, 0, sizeof(sel4utils_thread_t));

int error = vka_alloc_tcb(vka, &res->tcb);
if (error == -1) {

sel4utils_clean_up_thread(vka, alloc, res);
return -1;

}

res->ipc_buffer_addr = (seL4_Word) vspace_new_ipc_buffer(

alloc, &res->ipc_buffer);

if (res->ipc_buffer_addr == 0) {

return -1;

}

if (write_ipc_buffer_user_data(vka, parent, res->ipc_buffer

, res->ipc_buffer_addr)) {

return -1;

}

seL4_CapData_t null_cap_data = {{0}};
error = seL4_TCB_Configure(res->tcb.cptr, config.

fault_endpoint, config.priority, config.cspace, config
.cspace_root_data, vspace_get_root(alloc),
null_cap_data, res->ipc_buffer_addr, res->ipc_buffer);

if (error != seL4_NoError) {

sel4utils_clean_up_thread(vka, alloc, res);
return -1;

}

res->stack_top = vspace_new_stack(alloc);

if (res->stack_top == NULL) {

sel4utils_clean_up_thread(vka, alloc, res);

12

