An approach to predictively securing critical cloud infrastructures
through probabilistic modeling

Satvik Jain
Dept. of Computer Engineering
Netaji Subhas Institute of Technology
University of Delhi, New Delhi, India
jainsatvik97@gmail.com

Arun Balaji Buduru
Dept. of Computer Science
IIIT Delhi
New Delhi, India
arunb@iiitd.ac.in

Anshuman Chhabra
Dept. of Computer Science
University of California
Davis, USA
chhabra@ucdavis.edu

8
1
0
2

t
c
O
9
2

]
I

A
.
s
c
[

1
v
7
3
9
1
1
.
0
1
8
1
:
v
i
X
r
a

constraints.

Abstract— Cloud infrastructures are being increasingly
utilized in critical
infrastructures such as banking/ﬁnance,
transportation and utility management. Sophistication and
resources used in recent security breaches including those
on critical infrastructures show that attackers are no longer
limited by monetary/computational
In fact,
they may be aided by entities with large ﬁnancial and
human resources. Hence there is urgent need to develop
predictive approaches for cyber defense to strengthen cloud
infrastructures speciﬁcally utilized by critical infrastructures.
Extensive research has been done in the past on applying
techniques such as Game Theory, Machine Learning and
Bayesian Networks among others for the predictive defense of
critical infrastructures. However a major drawback of these
approaches is that they do not incorporate probabilistic human
behavior which limits their predictive ability. In this paper, a
stochastic approach is proposed to predict less secure states in
critical cloud systems which might lead to potential security
breaches. These less-secure states are deemed as ‘risky’ states
in our approach. Markov Decision Process (MDP) is used to
accurately incorporate user behavior(s) as well as operational
behavior of the cloud infrastructure through a set of features.
The developed reward/cost mechanism is then used to select
appropriate ‘actions’ to identify risky states at future time
steps by learning an optimal policy. Experimental results show
that the proposed framework performs well
in identifying
future ‘risky’ states. Through this work we demonstrate
the effectiveness of using probabilistic modeling (MDP) to
predictively secure critical cloud infrastructures.

Keywords: Cloud security, critical infrastructures, predic-
tive security, stochastic environments, probabilistic modeling

I. INTRODUCTION

However, despite the obvious gains of utilizing cloud
infrastructures in today’s service ecosystem, there are many
potential security issues that plague these systems. Securing
cloud infrastructures is a tougher challenge compared to
securing standalone systems due to the inherent ‘shared’
nature of the cloud. Cloud systems not only have to deal
with traditional network based attacks such as Denial of
Service , Man in the Middle, Phishing attacks, but also
counteract speciﬁcally personalized attacks. These include
exploits targeting the use of shared technology [1], attacks
made via insecure interfaces and APIs [2], cloud malware
injection attacks [3], among others.

Since cloud systems are being increasingly adopted in
critical infrastructures such as military, ﬁnance, utilities and
transportation etc. the need of the hour is to build robust
security frameworks. In this paper, we propose a predictive
security framework for critical cloud infrastructures at the
sub-system level. Markov Decision Process (MDP) is used
to model a sub-system and has representational features that
can capture user behavior(s) and operational behavior of the
sub-system. The contributions of the proposed approach can
be summarized into the following three areas: (1) A gener-
alizable security framework with capability to continuously
learn and predict future ‘risky’ states, which in turn can be
used to efﬁciently deploy and enforce security conﬁgurations,
(2) Novel techniques to estimate the reward and utility of the
states, and (3) Incorporation and utilization of probabilistic
user behavior(s) which enables the system to be more robust
and usable

Effective abstraction of services such as computing, net-
working and storage through efﬁcient virtualization and dis-
tributed system technologies have ensured massive success of
cloud applications. In cloud applications, since data is stored
on servers, and the services are provided through software
tools (such as web browsers), it ameliorates problem of scala-
bility and ﬂexibility in the fast-paced and dynamic real world
environments. With minimal investments, organizations and
users can leverage services such as Infrastructure-as-a-
Service (IaaS), Platform-as-a-Service (PaaS) and Software-
as-a-Service (SaaS), among others.

In Section 2 we discuss the existing approaches to protect
critical cloud infrastructures and their limitations. In Section
3 we outline the steps in our approach to predict ’risky’
states in the subsystem of a cloud infrastructure. In Section
4 we detail the approach proposed in this work by discussing
the implementation of each step of the general approach
mentioned in the previous section . In Section 5, we describe
the different experiments performed and results obtained by
evaluating the accuracy of the proposed approach. In Section
6, we conclude by discussing the usefulness of our work
along with directions for future work.

 
 
 
 
 
 
II. RELATED WORK

Given the sophistication and resources used in some of
the recent successful security breaches on critical cloud
infrastructures, relying on reactive security techniques [4],
[5] is no longer sufﬁcient. Providing sufﬁcient deterrence-
based security cover requires large amount of computational
resources since these techniques must be actively deployed
all the time. Further, they lack the ability to detect new
generation threats which are targeted, persistent, stealthy,
and unknown. Hence, there is a pressing need to rely on
intelligent cyber security approaches having predictive ability
to better protect critical cloud infrastructures.

Game theory is one of the most commonly used ap-
proaches to protect cyber infrastructures using predictive
ability [6], [7], [8]. Game theoretic techniques are based
on assumptions such as rationality of players, existence of
a Nash Equilibrium and synchronization in actions of the
attackers and defenders. However these constraints may not
always hold true in real scenarios, which is one major pitfall
of using Game Theoretic Techniques. Further, these tech-
niques are not scalable with realistic sizes and complexity
of the infrastructures.

Recent work has also shown the effectiveness of applying
machine learning and data mining techniques for cyber
security [9], [10], [11], [12]. However in these techniques,
models trained on a particular dataset become speciﬁc to
mimicking the observations from history and therefore take
time to adapt to unforeseen patterns. Keywhan Chung et
al.[13] in turn proposed a Q-Learning model which reacts
automatically to the adversarial behavior of a suspicious
user. However, the model does not provide any measure
for quantifying the rewards of a successful attack or attack
detection and relies on expert knowledge to enumerate the
damage for taking a particular action.

Probabilistic techniques used to protect cyber infrastruc-
tures include Bayesian networks [14] and Markov Chains
[15], [16], [17]. Bayesian methods are able to deal with
complex trafﬁc distributions by using probabilities obtained
from historical data to calculate probability of speciﬁc events.
However it is very difﬁcult to obtain prior distributions of
a normal and an attack state. In the case of Markov chain
models, the computations involved are relatively simple but
there is apprehension in constructing the state proﬁle of com-
plex systems as all transition probabilities between possible
states need to be calculated. Further, the predictive ability
of these approaches is limited as they do not incorporate
probabilistic human behavior in their attacker model. Yau
et. al [18] introduced the possibility of using a combination
of Bayesian networks and MDP for predictive security.
However, the authors presented a very brief overview of their
vision without illustrating how the MDP should be modeled
and do not show any empirical evaluation to validate the
proposed idea.

In an attempt to address the limitations posed by the
predictive cyber security techniques mentioned above- most
crucial being their lack of ability to capture probabilistic

human behavior and in turn the system operational behavior,
we have proposed an MDP based predictive approach for
securing cloud infrastructures. To the best of our knowledge,
an MDP based approach has never been used in the past work
to model cloud infrastructure subsystems and further learn a
policy to predict ‘risky’ states at future time instants. Details
of the proposed framework are presented in the following
sections.

III. PROPOSED APPROACH

In this paper, we aim to predict

less secure states in
a critical cloud sub-system which have potential security
breach risk. These less secure states of the cloud sub-system
are termed as ‘risky’ states in our approach. By identify-
ing these future ‘risky’ states prior to their occurence, the
proposed model enables the cloud/security administrator to
deploy the necessary security provisisons in time. We provide
a predictive security approach by using Markov Decision
Processes (MDP) to model the sub-system and capture the
user and operational behavior(s). The MDP is solved to
obtain an optimal policy which can lead the administrator
to future ‘risky’ states, given that currently the subsystem is
in a ‘safe/non-risky’ state. In contrast to previous techniques
which do not incorporate user behavior/attacker modeling,
our framework includes features representing user behavior.
Since probabilistic human behavior affects the system oper-
ational behavior, it is imperative that predictive approaches
should have some mechanism to facilitate the capturing
and analysis of probabilistic human behavior accurately and
efﬁciently. The policy learnt using our framework is based
on information such as normal usage patterns, malicious be-
havior and subsystem performance metrics. Further, since the
list of features is expandable, the proposed framework offers
ﬂexibility by allowing the incorporation of more information
in the future. Rather than proposing a model that completely
eliminates human intervention, our solution intends to assist
administrators in better deploying and enforcing security.
This allows for more robust security of the infrastructure.

In this section, an outline of the approach with the steps
involved in predicting risky states is provided. Implementa-
tion and speciﬁcs of each step in our model are given in
Section 4. These steps are sequentially represented in Figure
1. Now we describe each step as shown in Figure 1:

A. Gathering data from cloud infrastructure

Critical cloud infrastructures can be thought of as a
composition of multiple subsystems or functional units, each
serving a speciﬁc purpose. Each of these subsystems may be
distributed over one or more virtual machines. To represent
each sub-system as an MDP, data is collected to construct the
features for the state space. Data for a speciﬁc time interval is
collected for a cloud sub-system during which it would have
both malicious as well as non-malicious incoming trafﬁc.

B. Constructing State Features

Each MDP state is deﬁned by a set of features/attributes.
The data collected for a subsystem in the previous step is

obtained is generally very large. State Space Abstraction is
used to reduce the size of state-space of the MDP. Need for
state space abstraction stems from the fact that most dynamic
programming based algorithms that are used to solve the
MDP have high overheads for large state spaces [22], [23].
Commonly used techniques for state space abstraction are
Clustering based abstraction [24],Model-irrelevance abstrac-
tion [25] and a*-irrelevance abstraction [25].

E. MDP tuple construction

A Markov Decision Process (MDP) is deﬁned by tuple (S,
A, P , R), where S represents states, A represents actions, P :
SxAxS → [0, 1] represents a transition probability function
and R : SxA → R represents a reward function for each
state-action pair. Actions are chosen to maximize an expected
cumulative discounted reward:

V (sn) = E[

∞
(cid:88)

γnR(sn, an)]

n=0

(1)

Here, an ∈ A is the action selected for current state sn ∈ S

and γ ∈ (0, 1] is the discount factor.

F. Generating optimal policy

Dynamic programming (DP) based algorithms such as
value iteration [26] policy iteration [27] modiﬁed policy
iteration [28], relative value iteration [29] and Gauss Seidel
value iteration [30] are used to solve the MDP and generate
the optimal policy. The optimal policy aims to maximize the
set of rewards or ‘value’ that can be obtained at each state.

G. Evaluating optimal policy

The evaluation of obatined optimal policy involves, ﬁrst
mapping the optimal policy from the abstracted state space
to the original large state space and then determining it’s
accuracy. Accuracy of the obtained policy can be calculated
as the percentage of instances where the policy correctly
identiﬁed ‘risky’ states. More details on how the optimal
policy is evaluated are presented in Section 4-G.

Fig. 1. Proposed approach as a ﬂowchart

used to populate these features. The feature set can be di-
vided into a ﬁnite number of categories with features in each
category representative of a particular class of information.
To model the cloud subsystem as an MDP we deﬁne the
following three categories of features:

1) Normal User Behavior: This category contains features
which characterize the normal trafﬁc(non-malicious)
incoming on the cloud subsystem.

2) Subsystem Performance: This category contains fea-
tures which characterize the performance of the Virtual
Machine(s) hosting the subsystem.

3) Malicious Activity: Contains features which can de-
scribe different types of attacks such as DoS, CSRF,
XSS and SQL injections on the subsystem.

The above three categories are not exhaustive , however
each of them has a variety of features providing sufﬁcient
information to deﬁne a state of the MDP.

C. State space construction

H. Identify future risky states

To construct a ﬁnite state space, continuous data values
under each feature need to be discretized. Different dis-
cretization techniques can be used such as Standard Binning,
Fayyad and Irani’s MDL method [19], Class-attribute inter-
dependence maximization (CAIM) [20] and Class-Attribute
Contin-gency Coefﬁcient (CACC) [21]

Selection of the method depends on the problem and
data-set at hand. Once each feature has been discretized
into values corresponding to each time step, the size of the
generated state space for N features is evaluated as follows:

|S|= n1 ∗ n2 ∗ n3 ∗ ...nN
In the above expression, n1, n2, n3...nN are the number of

unique values taken by each feature.

D. State Space Abstraction

Even after the feature set comprising of continuous data
has been discretized in the previous step, the state space

If the accuracy achieved by the model at the previous step
is satisfactory, it can be deployed to predict risky states at
future time steps. The technique for identifying risky states
of the critical cloud infrastructure subsystem at future time
steps using the evaluated policy has been illustrated in detail
in Section 4-H.

IV. IMPLEMENTATION AND SPECIFICS

We now describe the speciﬁcs for each step of the
proposed solution outlined in the previous section. Each
step of the previous section is covered here, with details
concerning it’s implementation, algorithm evaluation and
design decisions.

In this paper, to simulate the critical cloud infrastructure, a
Banking application was deployed on Amazon Web Services
using the Elastic Beanstalk platform. The Banking system
consisted of three subsystems:Admin portal,Customer portal

and Staff portal which were differentiated on basis of the
user group accessing them. Cloud resources allocated to each
subsystem included an EC2 instance (web server) and an
RDS instance (database server).

Since the aim of this work is to be able to predict
potentially vulnerable states at
the subsystem level of a
critical cloud infrastructure, the admin portal was chosen
as the subsystem for experimentation. The above choice
of subsystem was not biased and the approach described
in further steps can be replicated for any of the three
subsystems.

A. Simulating trafﬁc to obtain data

The ﬁrst step involves collecting data for state features of
the MDP. Trafﬁc simulations were performed on the cloud
subsystem in which both normal user trafﬁc as well as ma-
licious trafﬁc was injected simultaneously. Now we describe
the deﬁnition, conﬁguration and tools used to simulate the
two categories of trafﬁc:

• Normal user trafﬁc:

The term ‘normal user trafﬁc’ indicates the absence
of any malicious activity in the form of attacks and
comprises of only standard GET/POST http requests
needed to perform various operations in the admin sub-
system. Apache Jmeter was used to simulate the normal
trafﬁc on the EC2 instance hosting the subsystem.

• Malicious trafﬁc:

Three different types of ﬂood attacks- SYN ﬂood at-
tacks, UDP ﬂood attacks and the ICMP ﬂood attacks
were simulated on the EC2 instance hosting the subsys-
tem. The Hping3 tool was used to generate these ﬂood
attacks. At the target server (that is, the EC2 instance
hosting the subsystem) Snort was deployed to detect the
presence of a ﬂood attack and generate corresponding
alerts

Data for 300 seconds was collected from the server. This
data was then used to generate features using the procedure
described in the next step.

B. Generate features using data

We now discuss the description and evaluation of features
in each of the three feature categories explained previously.
Every feature value was evaluated for successive time steps
of 1 second over the 300 second time window:

1) Normal user behavior:

a) Number of http requests: Total number of http-
GET/POST requests on the EC2 server hosting
the sub-system.

b) Number of unique users: Number of users
logged in to the subsystem and performing vari-
ous operations.

c) Requests-user distribution: Distribution of http
requests among the unique users logged into
the subsystem. It is the ratio of number of http
requests and number of unique users.

d) Average bytes

sent: Calculates the average
amount of data in bytes sent to the server through
http requests.

2) Subsystem performance:

a) Average latency: Measures the average server

latency during each 1 second time step.

b) Average response time: Measures the average
server response time during each 1 second time
step.
3) Malicious Activity:

a) DoS attack: This feature describes whether or not
any Denial-of-Service (DoS) attack attempts have
been made on the host server. If any, it also differ-
entiates between the three categories of Flood at-
tacks simulated previously (SYN, UDP or ICMP
based) and indicates the presence/absence of each
during a time step. The presence of an attack
is determined using the corresponding alert gen-
erated from Snort.The reason for selecting DoS
attacks speciﬁcally amongst other attack types in
these experiments is because of the large-scale
harm that DoS attacks are capable of causing.
This feature is discrete-valued and takes 8 dif-
ferent values corresponding to all 8 occurence
combinations of the three ﬂood attacks.
It is important to note that apart from the last feature
(DoS attacks) all the other features have continuous values.
In order to deﬁne a state space having a ﬁnite number of
states, each of these 6 features would need to be discretized.
This is described in the next step.

C. State space construction

Standard binning technique was used to convert the con-
tinuous range of values of the ﬁrst six features into discrete
integral values. This technique was chosen over the other
techniques because of it’s simplicity of evaluation,
thus
adding the least amount of computational overhead at this
intermediate step. Further,
this technique does not make
any assumptions on the structure of data obtained post
discretization nor introduces any bias like the other context
based methods. The number of discrete values obtained for
the 7 features were:

• Number of http requests:5 (Range:0-50, Bin size:10)
• Number of Unique Users: 5 (Range:0-50, Bin size: 10)
• Requests-User Distribution:4 (Range:1-4, Bin size:0.75)
• Average bytes sent:4 (Range:800-1300, Bin size:125)
• Average latency:4 (Range:100-3500, Bin size: 850)
• Average response time:4 (Range:0-8000,Bin size:2000)
• DoS attacks: 8
Based on the number of discrete values obtained for each
feature, the size of state space is 5∗5∗4∗4∗4∗4∗8 = 51200.

D. State space abstraction

As evaluated in the last step, we have constructed a state
space of 51200 states for the Markov Decision Process.
However, as mentioned before, such a large state space is

not practically solvable using most dynamic programming
approaches which is why it becomes necessary to reduce the
state space.

In this paper, we opt for the clustering based abstraction
method. Clustering based techniques perform unsupervised
abstraction based on just
the distribution of data points
while most of the other state abstraction techniques such as
model-irrelevance abstraction and a*-irrelevance abstraction
make some assumptions on the importance of states to
aggregate them. As we cannot label some states as either
important or irrelevant in our model, it is appropriate to use
a fair algorithm that aggregates states without any bias. We
use a number of clustering approaches for generating the
abstracted state space in this step and ﬁnd the one which
gives the optimal performance.

We use the following algorithms to perform the ab-
straction: K-Means using Euclidean distance metric (KME),
K-Means using Mahalanobis distance metric (KMM) and
Gaussian Mixture Models (GMM). To ﬁnd the clustering al-
gorithm best-suited to our use case amongst KME, KMM and
GMM, we employ each of the algorithms and run through
our proposed solution to ﬁnd the highest accuracy achieved
in the evaluation step (Section 4-G). The algorithm which
gives the highest performance is chosen as the algorithm for
carrying out the state space abstraction. The results and the
details of the experiments regarding the choice of clustering
algorithm are described in the Section 5.

E. MDP Tuple construction

Now we deﬁne the action set, reward matrix and transition
matrices for the MDP representing a subsystem of the cloud
banking infrastructure.

1) Action set: : In our action set we deﬁne 2 actions:
• Remain in the same state: When this action is per-
formed, there is a higher probability of remaining in
the same state than of jumping to any different state. In
the remaining text, this action is denoted by the integer
‘0’.

• Jump to a different state: When this action is performed,
no probability restriction is imposed on either jumping
to a different state or remaining in the same state. In
the remaining text, this action is denoted by the integer
‘1’.

The distinction between the above two actions becomes
more clear with the description of the reward function and
the transition function given below.

2) Reward function: : This function returns the reward
value for performing an action a in state s. In our model,
we deﬁne this reward value as follows:
R(s, a) = (w1 ∗ F 1) + (w2 ∗ F 2) + (w3 ∗ F 3) + (w4 ∗ F 4)
+ (w5 ∗ F 5) + (w6 ∗ F 6) + (w7 ∗ F 7) + (wa ∗ Ra)
(2)

In the above expression, w1, w2, w3, w4, w5, w6, w7 are the
weights given to each of the features proportional to their
potential contribution in determining the ‘risk’ associated
with a state.

From the description of features presented in Section 4-B,
it can be seen that the feature category 3 (Malicious activity)
is the most prominent indicator of potential security risk
in a state, followed by features in Category 2 (Subsystem
performance) and ﬁnally Category 1 (Normal user Behavior).
Based on this logic the assigned weight values are w1 =
1000, w2 = 1000, w3 = 1000, w4 = 1000, w5 = 2000,
w6 = 2000, w7 = 3000.

F 1, F 2, F 3, F 4, F 5, F 6, F 7 can take two values: either 0
or 1. If the value of a feature at the current state lies in the
‘safe range’, corresponding value of F i is 0, otherwise it is
1. The ‘safe range’ values for each of the 7 features is taken
as the ﬁrst half of the range of values taken by that feature.
This is based on the logic that as the integral value taken by
a particular feature increases, the corresponding contribution
of the feature in increasing the ‘risk’ of a state also increases.
Accordingly an unbiased approach to assign the ‘safe’ values
is to take the ﬁrst half of the range of discretized values of
a feature.

The last term in the reward metric expression, (wa ∗ Ra)
takes into account the effect of action a performed in a state.
Thus, wa is the weight and Ra is the reward term associated
with action a. To deﬁne the term Ra, we ﬁrst deﬁne two
terms: ‘Risk Metric’ and ‘Risk Threshold’.

Risk metric RM s gives the measure of ‘risk’ associated

with a particular state and is given by:

RM s = w1 ∗ F 1 + w2 ∗ F 2 + w3 ∗ F 3 + w4 ∗ F 4 + w5 ∗ F 5

+ w6 ∗ F 6 + w7 ∗ F 7

‘Risk threshold’ (Rth) is deﬁned as:

(3)

Rth = α ∗ (w1 + w2 + w3 + w4 + w5 + w6 + w7)

(4)

Risk threshold is a ﬁxed value such that if risk metric is
greater than risk threshold, the state is termed as ‘risky’
and if risk metric is less than risk threshold, the state is
considered ‘non-risky’. Moreover, α can be any ﬁxed value
ranging between 0 to 1, depending on the criterion that the
admin managing the cloud infrastructure sets to classify a
state as ‘risky’ or ‘non-risky’. A higher value of α implies a
stricter criterion, and vice-versa. For our experiments, we set
the value of α as 0.5, since dividing the risk metric into two
ranges about the half-way mark introduces the least amount
of bias towards either ’riskiness’ or ’non-riskiness’ of the
state.

Now that we have the risk metric and risk threshold, Ra

is deﬁned using the following conditions:

• If RM s > Rth:

1) If action a is 0, then Ra is +1
2) If action a is 1, then Ra is -1

• If RM s < Rth:

1) If action a is 0, then Ra is -1
2) If action a is 1, then Ra is +1

Since we want our optimal policy to identify the risky
states, a positive reward of +1 is given in case the current
state is ‘risky’ and the action taken is ‘remain in the same

state’ or if the current state is ‘non-risky’ and the action
taken is ‘jump to a different state’. Apart from these two
scenarios, a negative reward of -1 is given corresponding
to the action taken. In order to make the range of the
reward term Ra comparable to RM s so that the outcome
of the action taken has an observable effect on the value
of R(s, a), a weight wa is multiplied with Ra.Value of wa
is taken as average of the other seven weights (w1 to w7)
associated with RM s.Average value has been taken to ensure
fair contribution of the action in determining the reward
value. This average value is approximately 1500.

The reward metric R(s, a) is deﬁned for a single state in
the original state space. For abstract states (containing one
or more states from the original state space) we calculate
the average reward metric R(s(cid:48), a). If s(cid:48) is an abstract state
containing the states s1,s2,s3...sN from the original state
space, then R(s(cid:48), a) is given by the following expression:

R(s(cid:48), a) = (R(s1, a)+R(s2, a)+R(s3, a)+....+R(sN, a))/N

(5)
Finally, a reward matrix of dimensions 1000 x 2 is
generated. The 1000 rows correspond to the 1000 abstract
states and the columns correspond to the actions ‘0’ and ‘1’.
The value of R(s(cid:48), a) derived above is used to generate the
values that are inserted into the matrix.

3) Transition function:: This function generates a prob-
ability value of reaching state s(cid:48) from state s by performing
an action a.

In order to calculate the transition probabilities, we use
the data for the 300 time steps generated from trafﬁc simu-
lations on our cloud banking infrastructure. Each time step
corresponds to a state in the original state space which in
turn belongs to one of the abstracted states in the abstract
state space. Hence, we generate an abstract state transition
vector for the 300 time steps from the original data.

From the abstract state transitions data, the probability of
transitioning from an abstract state s to an abstract state s(cid:48)
is given by:

P (s(cid:48)|s) = N (s(cid:48)|s)/N ((s(cid:48)(cid:48) (cid:54)= s(cid:48))|s)

(6)

In the above equation, N (s(cid:48)|s) represents the number of
transitions from s to s(cid:48) in the abstract state transition vector.
Here, s is the abstract state at time step t, s(cid:48) is the abstract
state at time step t+1. N ((s(cid:48)(cid:48) (cid:54)= s(cid:48))|s) represents the number
of transitions from s to any abstract state s(cid:48)(cid:48) other than s(cid:48),
from the state s, in the abstract state transition vector.

Thus, the transition function metric P (s(cid:48)|s, a) is calculated

from P (s(cid:48)|s) as follows:

• If a is 1 then P (s(cid:48)|s, a) = P (s(cid:48)|s)
• If a is 0 then:

– If s(cid:48) = s, then P (s(cid:48)|s, a) = ts where ts ∈ (0.5, 1]
– If s(cid:48) (cid:54)= s, then P (s(cid:48)|s, a) = (1 − ts). ∗ P (s(cid:48)|s)
P (s(cid:48)|s, a) when s(cid:48) = s is the case of self transitions, hence
if the action taken is ‘0’ (‘remain in the same state’) there is
a very high stochastic probability of making the jump from
s to s itself. Since this probability of self-transition should

be directly dependent on the risk associated with the state s
(risk metric), we linearly map the risk metric of a particular
state with the self-transition stochastic probability associated
with it. The linear transformation is done such that ts take
values greater than 0.5 and less than or equal to 1. Thus the
linear transformation will involve mapping from the RM s
range i.e. from [min(RM s), max(RM s)] to the range of ts,
which is from (0.5,1]. Considering this linear transformation
function to be f (x), we can write:

f (x) = (

x − min(x)
max(x) − min(x)

∗ 0.49) + 0.51

(7)

Using the above function, we get f (RM s) = ts.
This function gives the self-transition probability for
‘risky’ states as greater than 0.75, enforcing the logic that
for these states, the action to ‘remain’ in the same state is
accompanied with a very high stochastic probability.

The non-self transition probability when a is ‘0’ is dis-

tributed from (1-ts) on the basis of P (s(cid:48)|s).

When a is ‘1’, the action taken is ‘Jump to a different
state’. There is no imposed restriction and therefore all
probabilities are calculated directly using P (s(cid:48)|s).

Finally, two transition probability matrices of dimensions
1000 x 1000 corresponding to the actions ‘0’ and ‘1’ are
created. The rows and columns correspond to the 1000
abstract states and the values in both matrices are ﬁlled from
the above derived value of P (s(cid:48)|s, a).

F. Optimal policy generation

Once the MDP is constructed, an optimal policy needs
to be generated. In our case, the optimal policy is a set of
actions that can achieve the task of identifying risky states
i.e. it should aim to ‘jump’ from secure states and ‘remain’
at risky states. Since we construct the MDP on the abstracted
state space consisting of 1000 states, the optimal policy is a
vector of length 1000, containing actions from the action set
of the MDP.

We intend to ﬁnd the DP algorithm which gives us the
‘best’ optimal policy for the MDP framework and also takes
the minimum time to do so. Thus, in the results section
(Section 5), we evaluate the DP algorithms not only on
the basis of their accuracy but also on the time taken
for them to solve the MDP. The intersection of these two
performance metrics is chosen as the MDP solving algorithm
for our framework. The results for these are obtained through
experiments described in the next section.

G. Evaluation of optimal policy

The optimal policy for each of the 1000 states consists
of either ‘jump’ to the next state or ‘remain’ in the current
state. To map this logic back to the original state space, we
award the same ‘optimal’ action in the obtained policy from
the abstracted (cluster) state to all the states in the original
state space that belong to this cluster.

With the reverse mapping available, we can evaluate the
optimal policy on both the abstracted state space and the
original large state space. First, we ﬁnd the ‘risky’ states

Fig. 3. Finding optimal clustering algorithm

Fig. 2. Finding risky states using optimal policy

using the risk metric, RM s (equation (3)) and risk threshold,
Rth (equation (4)). If RM s is greater than Rth, the state is
termed as ’risky’.

With the states labeleled as either ‘risky’ or ‘not-risky’, we
evaluate the performance of the optimal policy by calculating
it’s accuracy. This is done by calculating the ratio of states
where the optimal policy gave a favourable outcome to the
total number of states. Favourable outcomes are ‘remaining’
at ‘risky’ states and ‘jumping’ from ‘non-risky’ states to
identify the risky states. The numerical results of the accu-
racy obtained from the experiments performed are presented
in Section 5.

H. Using the obtained optimal policy to predict risky states

Once the optimal policy is obtained with a sufﬁcient
accuracy using the evaluation criterion mentioned in the
previous step, it is used to identify future ‘risky’ states. It
is assumed that at the current time instant (taken as t=0),
the subsystem is in a ‘non-risky’ or ‘safe state’. At the
current instant, the cloud infrastructure administrator would
deploy the optimal policy starting from that safe state. As
mentioned previously, the expected optimal policy is such
that it generates the action ‘jump to a different state’ in a
non-risky state and ‘remain in the same state’ in a risky state.
Accordingly, once this optimal policy is deployed starting
from the current safe state, a state transition tree is generated
(according to the transition function deﬁned in Section 4-E)
extending into future time instants. This is shown in Figure
2.

As seen from Figure 2, the risky states at any time step t
end up becoming the leaf nodes. This is because according
to the transition function, deﬁned in Section 4-E, the ‘remain
in the same state’ action taken by the optimal policy at
risky states ensures a probability of at least 0.75 (refer to
Section 4-E) of remaining in the same state and hence any
further state transitions from that state would hold negligible
probability. However, in the case of non-risky states, the
action taken is ‘jump to a different state’ and therefore that
state becomes the root of a tree representing transitions from
that state to other states. Therefore, from the tree generated
in this manner, the risky states can be easily identiﬁed for
any future time step as they will constitute all the leaf nodes.

Furthermore, the probability of reaching a risky state can also
be easily calculated by taking the product of the transition
probabilities depicted on the branches of the tree, starting
from the root node to the risky leaf node itself.

Hence, at any given time instant when the subsystem is
secure, the proposed approach can help the infrastructure
administrator identify the risky states at future time steps as
well as the probability of reaching those risky states. This
information can be used to alert the admin so that necessary
action can be taken to prevent the potential security breaches
in time.

V. RESULTS AND ANALYSIS

In this section, we present the results obtained by our
framework using the experimental set-up described in in the
previous section. We undertake three experiments as part of
our proposed solution:

A. Experiment 1: Choice of clustering algorithm for state
abstraction

We choose policy iteration (with discount factor, γ as 0.1)
as our MDP solving algorithm to obtain the optimal policy
and then compute the accuracies on the original state space
by varying the clustering algorithm for state space abstrac-
tion. We run experiments using K-Means with Euclidean
distance metric (KME), K-Means with Mahalanobis distance
metric (KMM) and Gaussian Mixture Models (GMM). We
also vary the number of clusters between 250, 500, 750 and
1000 and see where we obtain the highest accuracy.

It can be seen in Figure 3, that KME for 1000 abstracted
states obtains an accuracy of 96.516% compared to KMM
for 1000 clusters which obtains an accuracy of 88.775% as
well as GMM for 1000 clusters which achieves an accuracy
of just 74.601%. Here, policy iteration (γ is 0.1) is used
to obtain the optimal policy (although even value iteration,
Gauss Seidel value iteration and modiﬁed policy iteration
give the same optimal policies). We can also see in Figure
3 that for 1000 clusters, we obtain the highest original state
space accuracy as compared to other cluster sizes in KME.
However, to reafﬁrm the choice of 1000 clusters, we plot the

Fig. 4. The Elbow curve to ﬁnd optimal cluster size

Fig. 5. Completion times for MDP solving algorithms

mean square error (MSE) obtained while increasing cluster
sizes. This is known as an elbow curve and is shown in
Figure 4. It can be seen that the error tremendously decreases
towards 1000 cluster size and does not decrease much after
that. Therefore, we choose KME with 1000 abstracted states
as our state space abstraction algorithm.

B. Experiment 2: Finding best-suited MDP solving algo-
rithm

Through this experiment, we seek to ﬁnd the optimal
choice for the MDP solving algorithm giving the highest ac-
curacy and minimal computation time. Here we choose KME
with 1000 states as found in the previous experiment, as our
clustering algorithm and compare modiﬁed policy iteration,
policy iteration, value iteration, relative value iteration and
Gauss Seidel value iteration to obtain the optimal policies
and see which algorithm gives the highest original state space
and abstracted state space accuracy. For all DP algorithms
the value of discount factor (γ) is kept as 0.1.

We observe that modiﬁed policy iteration, policy iteration,
value iteration and Gauss Seidel value iteration give the
same optimal policy which achieves the highest original state
accuracy of 96.516% and highest abstracted space accuracy
of 98.5%. We then choose the best-suited algorithm out of
these by ﬁnding the one that takes the minimum time to
compute the optimal policy. As can be seen in Figure 5,
modiﬁed policy iteration is the fastest algorithm out of all
of the four with a completion time of 0.0335149 seconds.
This is a much smaller value compared to even the next
fastest algorithm, value iteration, which has a completion
time of 0.81714 seconds. Therefore, modiﬁed policy iteration
is chosen to be the algorithm to compute the optimal policy
for our framework.

C. Experiment 3: Finding optimal value of discount factor
(γ)

In the previous two experiments, γ was chosen to be 0.1.
However, we also need to experimentally ﬁnd if a better
choice of γ exists that can yield higher accuracy for the
original state space. In this experiment, we choose KME
with 1000 states as the clustering algorithm and run modiﬁed

policy iteration to solve the MDP, but with varying values
of γ.

As can be seen in Figure 6, we vary γ between 0.1 and
0.9 and ﬁnd that on increasing γ,
the accuracy for the
original state space starts to decrease. The earlier obtained
accuracy of 96.516% for γ set to 0.1, is the highest value
of accuracy. Therefore, the optimal value for the discount
factor is chosen to be 0.1.

Therefore, we have been able to ﬁnd the best parameters

and choice of algorithms for our framework. These are:

• K-Means with Euclidean metric for state space abstrac-

tion

• Modiﬁed policy iteration for solving the MDP
• Discount factor (γ) set to 0.1
These settings give state-of-the-art results, with an accu-
racy of 98.5% on abstracted state space and 96.516% on the
original large state space.

Since the obtained optimal policy is highly accurate (per-
formance accuracy is 96.516%) with respect to the expected
optimal policy of ‘remaining’ in risky states and ‘jumping’
to different states while in a non-risky state,
it can be
conﬁdently used to identify future risky states along with
their probabilities using the approach mentioned in Section
4-H.

VI. CONCLUSION AND FUTURE WORK

In this paper, an approach for predictively securing crit-
ical cloud infrastructures is developed and evaluated. The
framework utilizes MDP at the sub-system level to capture
probabilistic user behavior and operational behavior of the
sub-system through a set of features which deﬁne the MDP
state space. Further, a suitable reward function is deﬁned
through which the learnt optimal policy is able to identify
future ‘risky’ states. These ‘risky’ states can lead to potential
security breaches. The step-wise procedure of the proposed
approach have been detailed in the aforementioned sections.
Various experimental evaluations are performed in order to
maximize the prediction accuracy of the generated policy.
These include: (1) comparing different clustering algorithms
for state-space abstraction; (2) empirically determining that

Fig. 6. Finding best value of γ

modiﬁed policy iteration provides the highest accuracy and
has least convergence time among other DP techniques. The
resulting framework is designed based on the above evalu-
ations and achieves an accuracy of 96.516% in identifying
future ‘risky’ states . This reﬂects the effectiveness of using
probabilistic modeling through MDP to predictively secure
critical cloud infrastructures.

Future work primarily aims at expanding the feature set
especially in the ‘malicious activity’ category by includ-
ing more sophisticated and varied attack models to ensure
further robustness of the security framework. In addition,
for experimental feasibility, trafﬁc simulations on the cloud
infrastructure were performed at a relatively small-scale.
The step-wise approach of our proposed framework will
be undertaken for more large scale cloud systems. Further-
more, the proposed MDP framework for predicting security
breaches at the subsystem level of the cloud infrastructure
can be extended by using it in combination with Bayesian
Networks to predict security breaches at the system-wide
level. Each subsystem can send the predicted risky states
to the system-wide Bayesian Network, either directly or
indirectly. Utilization of Bayesian Network has much lesser
overhead and is better equipped to monitor all the events
which occur across subsystems, and thus predict system-wide
security breaches.

REFERENCES

[1] K. Kortchinsky,

“Cloudburst: Hacking 3d (and breaking out
of vm-ware). url: https://www. blackhat. com/presentations/bh-usa-
09/kortchinsky,” BHUSA09-Kortchinsky-Cloudburst-SLIDES. pdf (vid.
p´ag. 13), 2009.

[2] H. Shah, S. S. Anandane, and Shrikanth, “Security issues on cloud
computing,” CoRR, vol. abs/1308.5996, 2013. [Online]. Available:
http://arxiv.org/abs/1308.5996

[3] M. Jensen, J. Schwenk, N. Gruschka, and L. L. Iacono, “On technical
security issues in cloud computing,” in 2009 IEEE International
Conference on Cloud Computing, Sept 2009, pp. 109–116.

[4] A. Benameur, N. S. Evans, and M. C. Elder, “Cloud resiliency and
security via diversiﬁed replica execution and monitoring,” in Resilient
Control Systems (ISRCS), 2013 6th International Symposium on.
IEEE, 2013, pp. 150–155.

[5] K. W. Ullah, A. S. Ahmed, and J. Ylitalo, “Towards building an
automated security compliance tool for the cloud,” in Trust, Security
and Privacy in Computing and Communications (TrustCom), 2013
12th IEEE International Conference on.
IEEE, 2013, pp. 1587–1593.

[6] S. Shiva, S. Roy, and D. Dasgupta, “Game theory for cyber security,”
in Proceedings of
the Sixth Annual Workshop on Cyber Security
and Information Intelligence Research, ser. CSIIRW ’10. New
York, NY, USA: ACM, 2010, pp. 34:1–34:4. [Online]. Available:
http://doi.acm.org/10.1145/1852666.1852704

[7] A. Ptracu and E. Simion, “Game theory in cyber security defence,”
in Proceedings of the International Conference on ELECTRONICS,
COMPUTERS and ARTIFICIAL INTELLIGENCE - ECAI-2013, June
2013, pp. 1–6.

[8] W. Jiang, Z. h. Tian, H. l. Zhang, and X. f. Song, “A stochastic
game theoretic approach to attack prediction and optimal active
defense strategy decision,” in 2008 IEEE International Conference
on Networking, Sensing and Control, April 2008, pp. 648–653.
[9] O. Thonnard and M. Dacier, “Actionable knowledge discovery for
threats intelligence support using a multi-dimensional data mining
methodology,” in 2008 IEEE International Conference on Data Mining
Workshops, Dec 2008, pp. 154–163.

[10] H. Farhadi, M. Amir Haeri, and M. Khansari, “Alert correlation and
prediction using data mining and hmm,” vol. 3, pp. 77–102, 01 2011.
[11] C. Tang, Y. Xie, B. Qiang, X. Wang, and R. Zhang, “Security
situation prediction based on dynamic bp neural with covariance,”
Procedia Engineering, vol. 15, pp. 3313 – 3317, 2011, cEIS 2011.
[Online]. Available: http://www.sciencedirect.com/science/article/pii/
S1877705811021229

[12] S. Kim, S.-j. Shin, H. Kim, K. H. Kwon, and Y. Han, “Hybrid
intrusion forecasting framework for early warning system,” IEICE
- Trans. Inf. Syst., vol. E91-D, no. 5, pp. 1234–1241, May 2008.
[Online]. Available: http://dx.doi.org/10.1093/ietisy/e91-d.5.1234
[13] K. Chung, C. A. Kamhoua, K. A. Kwiat, Z. T. Kalbarczyk, and R. K.
Iyer, “Game theory with learning for cyber security monitoring,” in
2016 IEEE 17th International Symposium on High Assurance Systems
Engineering (HASE), Jan 2016, pp. 1–8.

[14] J. Wu, L. Yin, and Y. Guo, “Cyber attacks prediction model based on
bayesian network,” in 2012 IEEE 18th International Conference on
Parallel and Distributed Systems, Dec 2012, pp. 730–731.

[15] D. H. Kim, T. Lee, S. O. D. Jung, H. P. In, and H. J. Lee, “Cyber threat
trend analysis model using hmm,” in Third International Symposium
on Information Assurance and Security, Aug 2007, pp. 177–182.
[16] D. Man, Y. Wang, W. Yang, and W. Wang, “A combined prediction
method for network security situation,” in 2010 International Confer-
ence on Computational Intelligence and Software Engineering, Dec
2010, pp. 1–4.

[17] D. S. Fava, S. R. Byers, and S. J. Yang, “Projecting cyberattacks
through variable-length markov models,” IEEE Transactions on Infor-
mation Forensics and Security, vol. 3, no. 3, pp. 359–369, Sept 2008.
[18] S. S. Yau, A. B. Buduru, and V. Nagaraja, “Protecting critical
cloud infrastructures with predictive capability,” in 2015 IEEE 8th
International Conference on Cloud Computing, June 2015, pp. 1119–
1124.

[19] U. Fayyad and K. Irani, “Multi-interval discretization of continuous-

valued attributes for classiﬁcation learning,” 1993.

[20] L. A. Kurgan and K. J. Cios, “Caim discretization algorithm,” IEEE
transactions on Knowledge and Data Engineering, vol. 16, no. 2, pp.
145–153, 2004.

[21] C.-J. Tsai, C.-I. Lee, and W.-P. Yang, “A discretization algorithm based
on class-attribute contingency coefﬁcient,” Information Sciences, vol.
178, no. 3, pp. 714–731, 2008.

[22] M. L. Littman, T. L. Dean, and L. P. Kaelbling, “On the complexity
of solving markov decision problems,” in Proceedings of the Eleventh
conference on Uncertainty in artiﬁcial intelligence. Morgan Kauf-
mann Publishers Inc., 1995, pp. 394–402.

[23] C. H. Papadimitriou and J. N. Tsitsiklis, “The complexity of markov
decision processes,” Mathematics of operations research, vol. 12,
no. 3, pp. 441–450, 1987.

[24] P. Berkhin, “A survey of clustering data mining techniques,” in
Grouping multidimensional data. Springer, 2006, pp. 25–71.
[25] L. Li, T. J. Walsh, and M. L. Littman, “Towards a uniﬁed theory of

state abstraction for mdps.”

[26] R. Bellman, Dynamic Programming, ser. Dover Books on Computer
[Online]. Available: https:

Science. Dover Publications, 2013.
//books.google.co.in/books?id=CG7CAgAAQBAJ

[27] L. G. Telser, “Dynamic programming and markov processes. ronald
a. howard,” Journal of Political Economy, vol. 69, no. 3, pp. 296–297,
1961. [Online]. Available: https://doi.org/10.1086/258477

[28] M. L. Puterman and M. C. Shin, “Modiﬁed policy iteration algorithms
for discounted markov decision problems,” Management Science,
vol. 24, no. 11, pp. 1127–1137, 1978.

[29] D. White, “Dynamic programming, markov chains, and the method
of successive approximations,” Journal of Mathematical Analysis and
Applications, vol. 6, no. 3, pp. 373 – 376, 1963. [Online]. Available:
http://www.sciencedirect.com/science/article/pii/0022247X63900179

[30] N. A. J. Hastings, “Optimization of discounted markov decision
the Operational Research Society, vol. 20,
problems,” Journal of
no. 4, pp. 499–500, 1969. [Online]. Available: https://doi.org/10.
1057/jors.1969.112

