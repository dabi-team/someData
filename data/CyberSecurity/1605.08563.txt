6
1
0
2

y
a
M
7
2

]

R
C
.
s
c
[

1
v
3
6
5
8
0
.
5
0
6
1
:
v
i
X
r
a

Towards the Automated Veriﬁcation of Cyber-Physical
Security Protocols: Bounding the Number of Timed
Intruders

Vivek Nigam1, Carolyn Talcott2 and Abra˜ao Aires Urquiza1

1 Federal University of Para´ıba, Brazil, vivek@ci.ufpb.br, abraauc@gmail.com
2 SRI International, USA, clt@csl.sri.com

Abstract. Timed Intruder Models have been proposed for the veriﬁcation of
Cyber-Physical Security Protocols (CPSP) amending the traditional Dolev-Yao
intruder to obey the physical restrictions of the environment. Since to learn a
message, a Timed Intruder needs to wait for a message to arrive, mounting an at-
tack may depend on where Timed Intruders are. It may well be the case that in the
presence of a great number of intruders there is no attack, but there is an attack in
the presence of a small number of well placed intruders. Therefore, a major chal-
lenge for the automated veriﬁcation of CPSP is to determine how many Timed
Intruders to use and where should they be placed. This paper answers this ques-
tion by showing it is enough to use the same number of Timed Intruders as the
number of participants. We also report on some preliminary experimental results
in discovering attacks in CPSP.

1

Introduction

The Dolev-Yao intruder model is one of the cornerstones for the success of protocol ver-
iﬁcation being used in most veriﬁcation tools. The protocol security literature contains
a number of properties about the Dolev-Yao intruder, many of them vital for automated
veriﬁcation. For instance, it has been shown that protocol security veriﬁcation is com-
plete when considering only a single Dovel-Yao intruder in the following sense: if there
is an attack in the presence of one or more (colluding) Dolev-Yao intruders, then the
same attack with a single Dolev-Yao intruder is possible. Such result greatly simpliﬁes
the implementation of tools as it is enough to use only one Dolev-Yao intruder.

However, for the important class of Cyber-Physical Security Protocols (CPSP), the
Dolev-Yao intruder model is not suitable. CSPS normally rely on the physical properties
of the environment where sessions are carried out to establish some physical properties.
For example, Distance Bounding Protocols are used to infer an upper-bound on the
distance between two players V, the veriﬁer, and P, the prover. It works as follows:

V
P

−→
−→

P : m
V : m(cid:48)

The veriﬁer sends a challenge m remembering the time t1, when this message is sent.
The prover responds to the challenge, m(cid:48), and by measuring the round-trip time of the

 
 
 
 
 
 
Fig. 1: The dots are protocol participants and the crosses are intruders.

challenge response round, the veriﬁer can compute (using assumptions on the transmis-
sion channel used) an upper bound on the distance to the prover.

It is easy to check that the Dolev-Yao intruder is not suitable for CPSP veriﬁcation,
as the Dolev-Yao intruder does not obey the physical properties of the system. As the
Dolev-Yao intruder controls the network, he can receive the challenge m and instanta-
neously respond m(cid:48) to the veriﬁer’s challenge. There have been, therefore, proposals to
amend the Dolev-Yao intruder model to CSPS [3, 15] in the form of Timed Dolev-Yao
models. These have been used to prove general decidability of important properties of
CSPS [3, 14] and prove the security of protocols using theorem provers.

In contrast with the traditional Dolev-Yao intruder, who is the whole network, a
timed intruder is placed at some location and in order to learn a message, must wait
until the message arrives to that location. A consequence of this is that a greater number
of colluding intruders may not do as much damage as a smaller number of intruders
that are better placed. For example, consider Figure 1. With a distribution of intruders
shown to the left, there may not be an attack as it might take too long for intercepting
and forwarding messages among intruders (illustrated by the dashed lines), while there
may be an attack with the distribution of intruders shown to the right.

The main contribution of this paper is to answer the question: How many intruders
are enough for veriﬁcation and where should they be placed? We prove that it is enough
to consider one intruder per protocol participant, thus bounding the number of timed
intruders. This result greatly simpliﬁes automated CSPS veriﬁcation as the speciﬁer no
longer has to guess how many timed intruders to consider and where to place them.

Our second contribution is a general speciﬁcation language, which extends strand
spaces [22] by allowing for the symbolic representation of time. Instead of instantiating
time variables and time constraints with explicit values, the semantics of our language
accumulates symbolic time constraints. An execution using symbolic time constraints
corresponds to a set of possible concrete executions, considerably reducing state-space.
We implemented a prototype of our language in Maude [8] with SMT support. Our
preliminary experiments show that it is possible to ﬁnd attacks traversing few states.
While we do not claim (yet) to have a complete tool, our ﬁrst results are promising.

This paper is structured as follows: Section 2 speciﬁes the syntax of our protocol
speciﬁcation language and its semantics extending Strand Spaces [22]. We introduce
the Timed Intruder Model in Section 3. Section 4 contains the deﬁnition of the Timed
Intruder Completeness problem and a solution to it. We revisit some examples in Sec-
tion 5 brieﬂy commenting on our prototype implementation. Finally we conclude by
reviewing related and future work in Section 6.

2 A Speciﬁcation Language for Cyber-Physical Security Protocols

We start ﬁrst by specifying the syntax of our CPSP speciﬁcation language with sym-
bolic time variables and symbolic time constraints. We exemplify the speciﬁcation of
protocols using our language. Then, we formalize the operational semantics of our lan-
guage by extending Strand Spaces [22] to include time variables.

2.1 Syntax

Message Expressions We assume a message signature Σ of constants, and function
symbols. Constants include nonces, symmetric keys and player names. The set of mes-
sages is constructed as usual using constants, variables and at least the following func-
tion symbols:

sk(p)
pk(p)
enc(m, k)
m1, m2, . . . , mn}

Denoting the secret key of the player p;
Denoting the public key of the player p;
Encryption function denoting the encryption of m using key k;
Tuple function denoting a list of messages m1, m2, . . . , mn;

{
where c1, c2, . . . range over constants, n1, . . . , nn range over nonces, k1, k2, . . . range over
symmetric keys, p1, p2 . . . range over player names, v1, v2, . . . range over variables, and
m1, m2, . . . range over messages. For example, the message enc(
, pk(p))
}
denotes the encryption using the public key of p of the pair of messages v1 (not instan-
1 = k if k is a symmetric key.
tiated) and enc(c, k). We deﬁne (pk(p))−
We also write interchangeably the singleton tuple

v1, enc(c, k)
{

1 = sk(p) and k−

and m.

m

For a given scenario with some protocol session instances, we are going to distin-
guish the players that are participating in the protocol sessions, e.g., as veriﬁers and
as provers, which we call protocol participants (brieﬂy participants), from the Timed
Intruders which are not participating explicitly in the protocol sessions in the given
scenario, but are simply manipulating messages and possibly interacting with the par-
ticipants. The symbols p1, p2 . . . will range over participant names while ti1, ti2, . . . will
range over the names of such Timed Intruders.

{

}

Time Expressions We also assume a time signature Ξ which is disjoint to the message
alphabet Σ. It contains:

r1, r2, . . .
tt1, tt2, . . . ,
,
+,
−

×

A set of numbers;
A set of time variables including the special variable cur;
, /, ﬂoor, ceiling, . . . A set of arithmetic symbols and other function symbols.

Time Expressions are constructed inductively by applying arithmetic symbols to time
expressions. For example ceiling((2 + tt + cur)/10) is a Time Expression. The symbols
tr1, tr2, . . . range over Time Expressions. We do not constrain the set of numbers and
function symbols in Ξ. However, in practice, we allow only the symbols supported by
the SMT solver used. All examples in this paper will contain SMT supported symbols
(or equivalent). Finally, the time variable cur will be a keyword in our protocol speciﬁ-
cation language denoting the current global time.

Deﬁnition 1 (Symbolic Time Constraints). Let Ξ be a time signature. The set of sym-
bolic time constraints is constructed using time expressions. Let tr1, tr2 be time expres-
sions, then

tr1 = tr2,

tr1 ≥

tr2

tr1 > tr2,

tr1 < tr2,

and

tr1 ≤

tr2

are Symbolic Time Constraints.

For example, cur + 10 < ﬂoor(tt
range over Time Constraints.

−

5) is a Time Constraint. The symbols tc1, tc2, . . . will

Finally, we let b1, b2, . . ., range over boolean expressions, which include timed com-
parison constraints. We also allow for checking whether two messages m1 and m2 can
be uniﬁed, e.g.,
evaluates to true as they can be uniﬁed by the sub-
stitution
v1 (cid:55)→

v1, v2}
{
p1, v2 (cid:55)→

:=:
{
.
k1}

p1, k1}

{

Deﬁnition 2 (Timed Protocols). The set of Timed Protocols,
, is composed of Timed
Protocol Roles, pl, which are constructed by using commands as speciﬁed by the fol-
lowing grammar, where b is a boolean expression:

PL

pl

:= nil

(new v), pl
(+m), pl
(+m # tc), pl
m), pl
(
−
m # tc), pl
(
−
(if b then pl1 else pl2)
(if b # tc then pl1 else pl2)

|
|
|
|
|
|
|

Empty Protocol
Fresh Constant
Message Output
Timed Message Output
Message Input
Timed Message Input
Conditional
Timed Conditional

We explain some examples intuitively before we formalize the semantics of our
language in the following section. We will elide nil whenever it is clear from the context.

Example 1. The following program speciﬁes the veriﬁer of a (very simple) distance
bounding protocol:

(new v), (+v # tt = cur), (

v # cur

−

tt + 4)

≤

It creates a fresh constant and sends it to the prover, remembering the current global
time by assigning it to the time variable tt. Finally, when it receives the response v it
checks whether the current time is less than tt + 4.

Example 2. Timed conditionals can be used to specify the duration of operations, such
as checking whether some message is of a given form. In practice, the duration of these
operations can be measured empirically to obtain a ﬁner analysis of the protocol [6].

For example, consider the following protocol role:

(new v), (+v), (
venc, vmac}
if (vmac :=: enc(venc, kM)) # tt1 = tt0 + ttMac
then (if (venc :=: enc(v, kE)) # tt2 = tt1 + ttEnc)

# tt0 = cur),

−{

then (+done # cur = tt2) else (+error # cur = tt2))

else (+error # cur = tt1)

This role creates a fresh value v and sends it. Then it is expecting a pair of two messages
vmac and venc, remembering at time variable tt0 when this message is received. It then
checks whether the ﬁrst component vmac is of the form enc(venc, kM)), i.e., it is the cor-
rect MAC. This operation takes ttmac time units. The time variable tt1 is equal to the time
tt0 + ttmac, i.e., the time when the message was received plus the MAC check duration.
If the MAC is not correct, an error message is sent exactly at time tt1. Otherwise, if the
ﬁrst component, vMAC, is as expected, the role checks whether the second component,
venc, is an encryption of the form enc(v, kE)), which takes (a longer) time ttenc. If so it
sends the done message, otherwise the error message, both at time tt2 which is tt1 +ttenc.

We will need to identify a particular command in a Timed Protocol Role. We use a
string of the form i1.i2.i3. . . . .in, called position and denoted by ¯i, where each i j ∈ {
1, 2
}
to specify a path in the control ﬂow of the Timed Protocol. For example, 1.1.1.1.2
in Example 2 leads to (+error # cur = tt1). We denote by
(pl) the set of strings
representing the paths in the Timed Protocol Role pl.

PS

2.2 Timed Strand Spaces and Bundles

We formalize the semantics of Timed Protocols by extending Strand Spaces and Bun-
dles [22] to include time constraints and a network topology.
Network Topology Messages take time to travel between agents, both honest players
and intruders. The network model is speciﬁed by representing the time a message needs
to travel from any agent a to any agent b, speciﬁed by td(a, b) using a function that takes
two names and returns a number.3 Typically, td(a, a) = 0, that is the time for a message
sent from a player to reach himself is 0, but we do not need to enforce this. We also
assume the following axiom for all players a, a1, . . . , an, a(cid:48) (with 1

n):

td(a, a(cid:48))

≤

td(a, a1) + td(a1, a2) +

· · ·

≤
+ td(an, a(cid:48))

(1)

That is, it is faster for a message to travel directly from a to a(cid:48), then to ﬁrst travel through
a1, . . . , an. This is similar to the usual triangle inequality in basic geometry.

A given scenario with some protocol session instances includes the protocol par-
p1, . . . , pn}
=
, who may be manipulating messages. The Network Topology is composed
deﬁned as follows:

ticipants (or simply participants),
ti1, . . . , tim}
{
by two disjoint functions td = td

and a set of Timed Intruders

P

I

=

{

P (cid:93)

td
I
(cid:40)

td(a, b) =

(a, b) if a, b
∈ P
(a, b) otherwise

P

td
td
I

Thus, td
speci-
speciﬁes the time messages take to travel among participants, while td
I
ﬁes the time messages take to travel between Timed Intruders, between a Timed Intruder
and a participant and between a participant and a Timed Intruder.

P

The following deﬁnitions extend Strands and Bundles to include time variables cap-

turing the semantics of Timed Protocols.

3Here we are assuming that two agents share a single transmission channel. We leave to future
work how to incorporate different transmission channels. One way to do so is to add another
parameter to td, which would imply the addition of more axioms.

Deﬁnition 3. A Timed Strand Space is set Π and a trace mapping tr : Π
,
−→ P × GPL
p1, . . . , pn}
is the set of Ground Timed
where
{
Protocol Roles. We denote by tr(s)1 the player name and tr(s)2 the Timed Protocol Role
of a strand s

is the set of player names

GPL

and

Π.

P

∈

For the remainder we ﬁx a Timed Strand Space [Π, tr].

=

,

(cid:104)N

G

⇒ ∪ →(cid:105)

, has nodes

and

N

Deﬁnition 4. The Timed Strand Space Graph,
edges
and
1. A node n is a tuple

as deﬁned below.
p, s, ¯i
@tt with s
(cid:105)
(cid:104)

⇒

→

∈

Π, p = tr(s)1, ¯i

(tr(s)2) is a string
identifying a command in the Timed Protocol, and tt is a time variable timestamping
the node n. The set of nodes is denoted by

;
N
@tt, we denote by term(n), the command at position ¯i in tr(s)2;
p, s, ¯i
2. If n =
(cid:105)
(cid:104)
p, s, ¯i. j
p, s, ¯i
3. If n1 =
@tt1 and n2 =
@tt2 are in
(cid:105)
(cid:104)
(cid:105)
(cid:104)
4. For two nodes n1, n2 ∈ N
, there is an edge n1 →
−
5. If a node n

m # tc2;
, term(n) = new c, then c originates on n, that is, all nodes n(cid:48) such
)∗ is the reﬂexive and

n2;
, then there is an edge n1 ⇒
N
n2 if term(n1) is of the form +m or

+m # tc1 and term(n2) is of the form

)∗ n(cid:48), where (

∈ PS

m or

∈ N

−

that term(n(cid:48)) contains c are such that n (
transitive closure operator.

⇒ ∪ →

·

,

,

=

G

(cid:104)N

⇒ ∪ →(cid:105)

=
→C ∪ ⇒C(cid:105)
over td, denoted by

Deﬁnition 5. Let td be a Network Topology and let
of
. The Timed Constraint Set of
the smallest set of Time Constraints speciﬁed as follows:
1. If n =
tc(cid:48)
2. If
3. If

p, s, ¯i
(cid:104)
(cid:105)
, td) where tc(cid:48) is the Time Constraint obtained by replacing cur by tt;
(
∈ T C
C
p, s, ¯i
@tt1 ⇒C (cid:104)
(cid:105)
(cid:104)
p1, s1, ¯i1(cid:105)
(cid:104)
A Timed Bundle is a subset of the Timed Strand space graph.

(
tt1 ∈ T C
C
tt1 + td(p1, p2)

p, s, ¯i. j
(cid:105)
p2, s2, ¯i2(cid:105)

, such that term(n) is of the form

@tt2, then tt2 ≥

@tt2, then tt2 ≥

@tt1 →C (cid:104)

(
∈ T C

∈ NC

, td);

, td).

(cid:104)NC

C
C

(
C

T C

@tt

C

±

be a subgraph
, td), is

m # tc or myif b # tc, then

,

(cid:104)N

and

⇒ ∪ →(cid:105)

and suppose

is a sub-graph of

⇒C⊆⇒
is a Timed Bundle over td if:

Deﬁnition 6. Let td be a Network Topology. Let
.

,
→C ∪ ⇒C(cid:105)
is ﬁnite and acyclic;

→C⊆→
(cid:104)NC
C
1.
C
2. n2 ∈ NC
is Message Input or a Timed Message Input, then there is a unique n1 ∈ NC
such that n1 →C
n2;
3. n2 ∈ NC
and n1 ⇒
p, s, ¯i
4. n =
(cid:105)
(cid:104)
evaluated to true, then n
and n (cid:59)
p, s, ¯i.1
(cid:105)

is a node such that term(n) is of the form myif b or myif b # tc and b is
p, s, ¯i.2
(cid:105)

n2, then n1 ∈ NC
p, s, ¯i.1

, and n1 ⇒C
and n (cid:59)

; otherwise n
(cid:105)

p, s, ¯i.2

⇒C (cid:104)

⇒C (cid:104)

n2;

C (cid:104)

C (cid:104)

C

=

(cid:105)

;

5. the Timed Constraint Set of

C

over td is satisﬁable, i.e., there is a substitution σ,
, td) by Real numbers

called model of
so that all inequalities in

(
T C

, td), replacing all time variables in
, td) are true.

C

(

(
C

T C

T C

C

Example 3. The following is a graphical representation for a Timed Bundle using the
Distance Bounding Protocol described in Example 1:

.

hp1,newci@tt1hp1,+c#tt=curi@tt2hp1,(−c#cur≤tt+4)i@tt3hp2,−ci@tt4hp2,+ci@tt5tt4, tt3 ≥

tt2, tt2 ≥

It involves two participants p1 and p2 which simply exchange a fresh value c. 4 Its Timed
Constraint Set should be satisﬁable for the assumed Network Topology speciﬁed by the
function td:
(cid:110)

tt2 + td(p1, p2), tt3 ≥

tt5 ≥
Notice that the use of the time symbols in this representation means that this single
object speciﬁes a possibly inﬁnite collection of executions of the Distance Bounding
Protocol, where the time symbols are instantiated by concrete timestamps taken from
the set of non-negative Real numbers R+. This compact representation greatly reduces
the state space during automated protocol veriﬁcation. In our prototype implementation,
we use an SMT solver to check whether the set of Time Constraints is satisﬁable or not.

tt5 + td(p2, p1), tt3 ≤

tt1, tt = tt2, tt4 ≥

tt + 4

(cid:111)

3 Timed Intruder Model

The Timed Intruder Model is similar to the usual Dolev-Yao Intruder Model in the sense
that it can compose, decompose, encrypt and decrypt messages provided it has the right
keys. However, unlike the Dolev-Yao intruder, a Timed Intruder is constrained by the
physical properties of the systems, namely, an intruder is not able to learn any message
instantaneously, instead, must wait until the message arrives.

A Timed Intruder Set is a set of intruder names

a set of initially
known keys KP, which contain all public keys, all private keys of all the intruders, all
symmetric keys initially shared between intruders and honest players, and may contain
“lost keys” that an intruder learned previously by, for instance, succeeding in some
cryptoanalysis. Recall that Timed Intruders are situated at locations speciﬁed by the
(p1, ti1) = 4 denotes that the timed
Network Topology. For instance, td(p1, ti1) = td
I
needed for a message to travel from participant p1 to intruder ti1 is 4.

ti1, . . . , tin}
{

I

=

,

−

m

−{

ti,
(cid:104)

@tt, where t is a text constant;

@(tt1, tt2) denoting the strand

ti,
(cid:104)
−{
the strand
ti,

Deﬁnition 7. An intruder trace is one of the following, where ti is a Timed Intruder
Name, tt, tt1, tt2, tt3 are time variables, and m, m1, . . . , mn, m(cid:48)1, . . . , m(cid:48)p are messages:
– Text Message:
ti, +t
(cid:105)
(cid:104)
– Flushing:
ti,
@tt;
m
−
(cid:105)
(cid:104)
– Forward:
m, +m
ti,
(cid:105)
(cid:104)
−
– Concatenation:
m(cid:48)1, . . . , m(cid:48)p}
m1, . . . , mn}
ti,
m1, . . . , mn}(cid:105)
@tt1 ⇒ (cid:104)
−{
– Decomposing:
m1, . . . , mn}
ti,
(cid:104)
−{
ing the strand
m1, . . . , mi, mi+1, . . . , mn}(cid:105)
ti,
−{
(cid:104)
– Key:
ti, +k
@tt if k
(cid:105)
(cid:104)
– Encryption:
k,
ti,
−
(cid:104)
ti,
@tt1 ⇒ (cid:104)
k

@tt1 ⇒ (cid:104)
(cid:105)
@(tt1, tt2, tt3) denoting
m1, . . . , mn, m(cid:48)1, . . . , m(cid:48)p}(cid:105)
ti, +
{
mi+1, . . . , mn}(cid:105)
ti, +
@tt2 ⇒ (cid:104)

ti,
(cid:104)
4For readability we display graph nodes using the player’s id paired with the node term, rather

@tt2 ⇒ (cid:104)
, +
m1, . . . , mi}
{
m1, . . . , mi}(cid:105)
ti, +
{

KP;
∈
m, +enc(m, k)
−
(cid:105)
@tt2 ⇒ (cid:104)
m
−
(cid:105)

, +
{
m(cid:48)1, . . . , m(cid:48)p}(cid:105)
, +
{

@(tt1, tt2, tt3) denoting the strand

m1, . . . , mn, m(cid:48)1, . . . , m(cid:48)p}(cid:105)

ti, +enc(m, k)
(cid:105)

mi+1, . . . , mn}(cid:105)

@tt1 ⇒ (cid:104)

ti, +m

@tt2;

@tt3

@tt3

@tt3

−{

@(tt1, tt2, tt3) denot-

−

(cid:105)

(cid:105)

(cid:104)

{

than using the strand identiﬁer and trace position.

– Decryption:

1,
ti,
k−
(cid:104)
−
ti,
@tt1 ⇒ (cid:104)
(cid:105)

enc(m, k), +m
−
enc(m, k)
(cid:105)
−

@(tt1, tt2, tt3).
(cid:105)
ti, +m
@tt3
@tt2 ⇒ (cid:104)
(cid:105)

1

ti,
(cid:104)

k−

−

As with the the usual Dolev-Yao intruder model as, e.g., in [22], the Timed Intruder
can send text messages and known keys, receive a message, replay a message, concate-
nate and decompose messages, and ﬁnally encrypt and decrypt messages. There are,
however, two differences with respect to the usual Dolev-Yao intruder model as deﬁned
in [22]. Each node of the trace is associated with an intruder name ti and a time vari-
able tt. These are necessary for extracting the Time Constraints of a Strand Graph (as
described in Deﬁnition 5), specifying the physical restrictions of the Timed Intruder.

As the time when timed intruders receive and manipulate messages cannot be mea-
sured by the protocol participants, they do not have control over the time variables of
timed intruder strands. The following assumption captures this intuition:
Time Variable Disjointness Assumption For any Bundle
appearing in protocol participant strands in
appearing in timed intruder strands in

, the set of time variables
is disjoint from the set of time variables

B

B

.
B

Example 4. Let us return to the distance bounding protocol described in Example 1.
The following is an attack, where two colluding intruders ti1, who is close to p1, and ti2,
who is close to p2, collude by sharing a fast channel to fool p1 into thinking that p2 is
closer than he actually is.

.

The intruders ti1 and ti2 simply forward messages between each other and the players p1
and p2. However, this is a Bundle only if the following Time Constraint Set is satisﬁable:







tt7 + td(ti1, ti2), tt9 ≥
tt10, tt12 ≥
tt2 + 4

tt2 + td(p1, ti1), tt7 ≥
tt4, tt10 ≥
tt12, tt3 ≥

tt6, tt8 ≥
tt5 + td(p2, ti1), tt11 ≥
tt13 + td(ti1, p1), tt3 ≤

tt1, tt = tt2, tt6 ≥
tt2 ≥
tt9 + td(ti1, p2), tt5 ≥
tt13 ≥

tt11 + td(ti2, ti1),

tt4 ≥

tt8,

This set of constraints represents a set of concrete executions, where the Timed Intruders
ti1 and ti2 collude. There is a concrete execution only if the set of Time Constraints is
satisﬁable, which depends on the Network Topology, that is, on the function td.

4 Timed Intruder Completeness

Standard Security Protocol Veriﬁcation is already very challenging. However, auto-
mated veriﬁcation has been very successful in discovering new attacks. A good part
of this success is due to the Dolev-Yao intruder model, which greatly simpliﬁes the
design of veriﬁcation tools. Tools can rely on the important result that just a single

hp1,newci@tt1hp1,+c#tt=curi@tt2hp1,(−c#cur≤tt+4)i@tt3hp2,−ci@tt4hp2,+ci@tt5hti1,−c,+ci@(tt6,tt7)hti1,−c,+ci@(tt12,tt13)hti2,−c,+ci@(tt8,tt9)hti2,−c,+ci@(tt10,tt11)Dolev-Yao intruder is enough, in the sense that if there is an attack in the presence of
multiple (colluding) Dolev-Yao intruders, then there is also an attack in the presence a
single Dolev-Yao intruder [4].

Unfortunately, for Cyber-Physical Security Protocols, it is not the case that a single
Timed Intruder is enough for veriﬁcation. Consider the attack illustrated in Example 4.
There may be a great number of Timed Intruders, but none of them situated between
p1 and p2, as illustrated by Figure 1. In such a scenario there might not be an attack as
the round time to receive and return a message between such a display of intruders may
never be less than the distance bound (4). On the other hand, two strategically placed
Timed Intruders, as in the second picture in Figure 1, may lead to an attack.
Clearly there is an unbounded number of choices based on deciding:

– How many Timed Intruders are there?
– Where are these Timed Intruders located?
This is similar to the challenge in usual security protocol veriﬁcation of determining
how many protocol sessions running in parallel should the scenario have, which is un-
decidable [19]. Fortunately, we are able to prove a completeness result which answers
the two questions above. In order to formalize the completeness statement, we introduce
some notation.

Deﬁnition 8. Let
=
participants
P
restricted to participants
follows:
–

P
N
p, s, ¯i
B
(cid:105)
(cid:104)

where p
– For two nodes n1, n2 in
– If n is a node in

;
∈ P

be a Timed Bundle over the Network Topology td involving the
B
p1, . . . , pn}
{
P

and the Timed Intruders
, is the graph

ti1, . . . , tin}
=
{
, (
P
P
B ∪ →
⇒
B

. The graph
)
(cid:105)

B
speciﬁed as

, written

I
(cid:104)N

BP

P
B

B
, if n1 ⇒

contains only the nodes in

belonging to a participant in

, i.e., of the form

P

N

P
B

, then n1 ⇒
n2 in
P
B
whose term is a message receive,
−
under the relation (

n2;
m or

B

−

m # tc, and n(cid:48) is a

P
B

N

maximal element of the set of predecessors of n in
)∗;

n. We let

(n,

) denote this set of predecessors.

P
B

N

⇒ ∪ →

then n(cid:48) →

P
B

→

P

B

Intuitively, a Bundle restricted to the set of participants speciﬁes the events observable
by the participants without including the moves corresponding to the timed intruders. It
includes all the edges of the original bundle connecting two nodes of
. The “maximal
predecessor” in
encountered when following edges in the
P
N
B
predecessor direction. It is maximal in the partial order on nodes induced by the edges
of the bundle. Thus the terms of nodes in
) contain all the terms used by the
intruders to derive the term at node n.

is the ﬁrst element of

(n,

P
B

P
B

N

N

B

P

The Bundle shown in Example 4 restricted to the participants

p1, p2}

{

is

.

p1, +c # tt = cur
@tt2 → (cid:104)
(cid:105)
(cid:104)

@tt4 in this ﬁgure simply speciﬁes that
The edge
c
(cid:105)
−
using the message, c, sent by p1, the timed intruders were able to send the message c to
the participant p2.

p2,

hp1,newci@tt1hp1,+c#tt=curi@tt2hp1,(−c#cur≤tt+4)i@tt3hp2,−ci@tt4hp2,+ci@tt5For another example, consider the following Bundle, where timed intruder ti uses
, k) to

KP and the messages c1 and c2 to compose the message enc(
{

c1, c2}

∈

his key k
p3:

The corresponding bundle restricted to the participants p1, p2 and p3 is:

.

It captures the fact that the messages sent by p1 and p2 are used to generate the message
received by p3 without explicitly showing how intruders manipulated these messages.
Notice that unlike bundles, a receive node in a restricted bundle may have multiple

incoming edges, reﬂecting the possibility of processing by multiple intruders.

The next two lemmas follow directly from the deﬁnition of Bundles and restricted

Bundles.
Lemma 1. Let p = n (cid:123)1 n1 (cid:123)2 n2 (cid:123)3 · · ·
(n(cid:48),
for 1
P
form:

) to n(cid:48), where (cid:123)i is either

→

⇒

or

B

(cid:123) j

≤

1 n j (cid:123) j n(cid:48) be a path from n in
−
j. Then p is necessarily of the
i

≤

→ (cid:104)

@tt
(cid:105)

ti1, s1(cid:105)

@tt1 (cid:123)2 (cid:104)

@tt2 (cid:123)2 · · ·
p, snd
(cid:104)
where snd is a message send (+m) or a timed message send (+m # tc), rcv is a message
are timed
receive (
−
intruder strands.

m) or a timed message receive (

p(cid:48), rcv
@tt(cid:48)
(cid:105)

m # tc), and for 1

@tt j → (cid:104)

tii, si(cid:105)
(cid:104)

ti2, s2(cid:105)

ti j, s j(cid:105)

1 (cid:104)
−

(cid:123) j

≤

≤

−

j,

i

, td) be the Time Constraint Set of

for a given Network Topology

Lemma 2. Let
B
td. Let p be a path in

T

(

@tt
(cid:105)

p, snd
(cid:104)
→ (cid:104)
Then any satisfying model of

as described in Lemma 1 of the form:
B
@tt1 (cid:123)1 (cid:104)
ti1, s1(cid:105)
(

ti2, s2(cid:105)
, td) will also satisfy the constraint:

@tt2 (cid:123)2 · · ·

ti j, s j(cid:105)

1 (cid:104)
−

(cid:123) j

B

@tt j → (cid:104)

p(cid:48), rcv
@tt(cid:48)
(cid:105)

T
tt + td(p, ti1) + td(ti1, ti2) +

B

tt(cid:48)

≥

+ td(ti j
−

· · ·

1, ti j) + td(ti j, p(cid:48)).

The following speciﬁes the equivalence of two Bundles.

P

Deﬁnition 9. Let
Timed Intruders. Let td1 = td
we say that a Timed Bundle
B1 (cid:27)td2
written
P2 .5
P1 =

be a set of participants and
and td2 = td

I
P (cid:93)
P (cid:93)
B1 over td1 is equivalent to a Timed Bundle
td1 B2, if their Bundles restricted to
P

I(cid:48) be two possibly equal sets of
I(cid:48) be Network Topologies. Then
td
B2 over td2,
are (syntactically) identical, i.e.,

td
I

,

B

B

5It is possible to relax this deﬁnition so that they are identical modulo time variable names,

but this is not needed here.

hp2,+c2i@tt2hp3,−enc({c1,c2},k)i@tt8hp1,+c1i@tt1hti,−c1,+c1i@(tt3,tt03)hti,−c2,+c2i@(tt4,tt04)hti,−c1,−c2,+{c1,c2}i@(tt5,tt05,tt005)hti,+ki@tt6hti,−k,−{c1,c2},+enc({c1,c2},k)i@(tt7,tt07,tt007)hp2,+c2i@tt2hp3,−enc({c1,c2},k)i@tt8hp1,+c1i@tt1Intuitively, the condition

P2 speciﬁes that for the honest participants the two
Bundles are equivalent, although they may have different timed intruders in different
locations manipulating messages in different ways. Thus, if such a
B1 constitutes an
attack, then

B

B

P1 =

B2 also constitutes an attack.
Timed Intruder Completeness Problem:

{

{

=

=

P

P (cid:93)

ti1, . . . , tim}

be a set of participants and

p1, . . . , pn}
Let
timed intruders. Let td
P
subset
and td
I(cid:48) ⊆ I
, there is a Bundle
td
td
I

I(cid:48) such that for any td
B2 over td2 = td
In other words, given a particular scenario with

be a set of
I
be a Network Topology of the participants. Is there a
B1 over td1 =
and any Bundle
B1 (cid:27)td2
I(cid:48) such that
td1 B2?
participants and a Network Topol-
P
ogy for these participants td
involving a collection
P
of Timed Intruders
I(cid:48) that can be used to carry out the same observable events for any
other Network Topology td
with a possibly larger number of Timed Intruders?
I
exists then an automated veriﬁcation tool does not have to
I(cid:48) and td(cid:48)
guess how many timed intruders there are, and where they are located, but simply can
.
use

, is there a Network Topology td(cid:48)
I

If such an

I
P (cid:93)

td

I

I(cid:48) and td(cid:48)

I

4.1 Completeness Proof

We are given a set of participants
ti1, . . . , tim}
{
between participants.

=
, and a Network Topology td
P

P

p1, . . . , pn}
=
{
specifying the time messages take to travel

, a set of Timed Intruders

I

A Solution for the Timed Intruder Completeness Problem: For our solution, we assume
that there are as many timed intruders as participants. If this is not the case, we can
safely add more dummy timed intruders. We associate with each participant pi one
Timed Intruder tipi. Thus:

(cid:48) =

tip1 , . . . , tipn }
Moreover, we assume that the time a message takes to travel between pi to tii is 0 (or
negligible). Moreover, the time for a message to travel between two Timed Intruders tipi
and tip j is the same as the time it takes to travel between their corresponding participants
pi and p j. Thus:

I

{

.

td
td

I(cid:48) (pi, tipi) = td
I(cid:48)(tipi, tip j) = td

P

I(cid:48) (tipi, pi) = 0
(pi, p j)

for all pi ∈ P
;
.
for all pi, p j ∈ P

The Timed Intruders in

I(cid:48) collude in the following form: whenever a Timed Intruder
tpi learns a message m sent by pi, it broadcasts this message m to the remaining Timed
Intruders in
. For example, the Strand for when p1 sends a message is then as
follows:

I(cid:48) \ {

tipi}

hp1,+mi@tt1htip1,−m,+mi@(tt01,tt01)htip2,−m,+mi@(tt2,tt2)htip3,−m,+mi@(tt3,tt3)htipn,−m,+mi@(ttn,ttn)P

tt1 + td
P

tt(cid:48)1 + td
tt1 as td(p1, tip1 ) = 0. Thus, tti ≥

Notice that the message m reaches to a Timed Intruder tipi at time tti which is subject
tt1 + td(p1, tip1 ), which reduces to
(p1, pi)and tt(cid:48)1 ≥
to the Time Constraints tti ≥
(p1, pi). Moreover, if the Timed Intruder
tt1 + td
tt(cid:48)1 ≥
P
tipi forwards this message to the participant pi, then this message will be received at a
(p1, pi), that is, as if the message had traveled directly from p1 to pi
time tt(cid:48)i ≥
without passing through intruders tip1 and tipi.
Proof We will now show that the
I(cid:48) and td
Timed Intruder Completeness Problem. For this, assume given a td
I
over td1 = td

I(cid:48) deﬁned above provide a solution for the
B1
td1 B2. We do so

td
We will construct a Bundle

B2 over td2 = td

I(cid:48) such that

B1 (cid:27)td2

and a Bundle

P (cid:93)

td

I

.

by transforming

B1 into
Let the following be a sub-graph of

B2.

P (cid:93)
B1 restricted to

:

P

i
where for all 1
≤
(+mi # tc), rcv is a Message Input (

≤

Let p be an arbitrary path from node

Lemma 1, p has the shape:

n, sndi is a Message Output (+mi) or a Timed Message Output

−

m) or a Timed Message Input (
@tti to

m # tc).
@tt path in

−

pi, sndi(cid:105)
(cid:104)

p, rcv
(cid:105)
(cid:104)

B1. From

@tti → (cid:104)

pi, sndi(cid:105)
(cid:104)
Moreover, from Lemma 2, any model satisfying

ti2, s2(cid:105)

ti1, s1(cid:105)

@tt1 (cid:123)1 (cid:104)

@tt2 (cid:123)2 · · ·

tti + td(pi, ti1) + td(ti1, ti2) +

tt

≥

· · ·

(cid:123) j

1 (cid:104)
−

p(cid:48), rcv

@tt j → (cid:104)

ti j, s j(cid:105)
@tt
(cid:105)
B1 will also satisfy the constraint:
1, ti j) + td(ti j, p).
+ td(ti j
−

(2)

Given our assumption on the Network Topology (Equation 1), we also have that

td(pi, p)

≤

td(p, ti1) + td(ti1, ti2) +

+ td(ti j

1, ti j) + td(ti j, p)
−

· · ·

That is, the time it takes to travel directly from pi to p is less than or equal to the time it
takes to travel from pi to p via the timed intruders ti1, . . . , ti j.

From our solution, we obtain for the sub-graph shown above the following subgraph
where all the messages m1, . . . , mn are broadcast to all Timed Intruders including the
Timed Intruder tip:

where the intruder tip receives the messages m1, . . . , mn. Notice that for 1
have that tt(cid:48)(cid:48)i ≥

n, we
tti + td(pi, p). At this point the intruder tip has all the information he

≤

≤

i

hp,rcvi@tthp1,snd1i@tt1hp2,snd2i@tt2hpn,sndni@ttnhp1,+snd1i@tt1hpn,+sndni@ttnhtip1,−m1,+m1i@(tt01,tt01)htipn,−mn,+mni@(tt0n,tt0n)htip,−m1,+m1i@(tt001,tt001)htip,−mn,+mni@(tt00n,tt00n)needs to compose the message m. Moreover, he can do so without losing time. Thus he
is able to deliver the message m to p at time tt satisfying the constraints:

tt1 + td(p1, p)

tt

≥

tt2 + td(p2, p)

tt

≥

· · ·

tt

≥

ttn + td(pn, p).

(3)

B1 satisﬁes Eq. 2, the same assignment
As any model of the Time Constraints Set of
for tt1, . . . , ttn, tt will also satisfy the time constraints in Eq. 3. Moreover, if any of
snd1, . . . , sndn is a Timed Output (pi, +mi # tci) or rcv is a Timed Input (p,
m # tc)
the same assignment will also satisfy tci and tc because protocol participant strands and
timed intruder strands do not share time variable (Time Variable Disjointness Assump-
tion).

−

B1 restricted to
as shown above,
I(cid:48) where the only timed intruder strands are those

P

By repeating this procedure for each sub-graph in

we are able to construct
of the intruders

B2 using td
I(cid:48) leading to the following result.
Theorem 1. Let
be participant names and
P
I
I(cid:48) and td
I(cid:48) be as described above. Then
|P|
Completeness Problem.

. Let

be Timed Intruders, such that
I(cid:48) and td

|I| ≥
I(cid:48) solve the Timed Intruder

5 Examples and Preliminary Experimental Results

We illustrate with some examples that our solution is able to identify attacks on CPSP.
We are using the terminology of attacks described in [9].
External Distance Fraud. Assume two honest participants p1 (Veriﬁer) and p2 (Prover).
They exchange some information, normally to authenticate p2, for example [21], using a
standard Needham-Schroeder-Lowe protocol session [16], and then carry-out a distance
bounding protocol session. The following Timed Strand captures this attack:

Notice that the timed intruder tip1 is able to complete the distance bounding session
as he is very close to the veriﬁer p1. This is captured by the Time Constraint Set of
this Bundle. Moreover, here we assume that they exchange a nonce, but if we allow
equational theories specifying, for example xor operations
as done in [12], a similar
Timed Bundle would be obtained.
Attack-in-Between-Ticks The In-Between-Ticks attack [14] is an instance of a Lone
Distance Fraud attack [9], where the prover is dishonest but is not colluding with other
Timed Intruders. This attack exploits the fact that real veriﬁers are running on a proces-
sor with a slow clock speed. When the veriﬁer receives the response from the prover,
he is only able to record the time of receival in the following clock cycle. This is cap-
tured by using the Time Constraint (ﬂoor(cur) + 1) as illustrated by the following Timed
Strand:

⊕

hp1,newni@tt1hp1,+n#tt=curi@tt2hp1,(−n#cur≤tt+4)i@tt3hp2,−ni@tt4hp2,+ni@tt5htip1,−n,+ni@(tt02,tt02)htip2,−n,+ni@(tt4,tt4)It is possible to show that the Time Constraint Set of this Timed Strand,

, is satisi-
ﬁable although the distance between p1 and p2 is greater than the distance bound 4. That
is, it is possible to show that the set
Distance Hijacking In the Appendix, we show the Timed Bundle with the Distance Hi-
jacking attack described in [21] on the protocol that combines the traditional Needham-
Schroeder-Lowe protocol and a distance bounding session.

td(p1, p2) > 4, td(p2, p1) > 4
}

is satisﬁable.

T ∪ {

T

5.1 Prototype Implementation
We developed a prototype implementation of this strategy in a version of Maude [8] in-
tegrated with the SMT solver CVC4 [2]. Our preliminary results seem quite promising.
In addition to symbolic time constraints we implemented a symbolic constraint
solver in order to tackle the state-space explosion due to the fact that a timed intruder
can generate an unbounded number of messages. It works along the same lines as in
usual implementations of such constraint solvers used by tools assuming the standard
Dolev-Yao intruder by not instantiating messages generated by the intruder, but rather
using symbolic constraints.

Our prototype used and implements mechanisms for the main contributions of this

paper:
– Network Topology as a Constraint Set: While here we assume that the Network
Topology is given by a function td which completely determines the time messages
take to travel between agents, our implementation allows the user to specify the Net-
work Topology as a set of constraints. For example, the constraint td(p1, p2) > 4
speciﬁes the set of Network Topologies where the time it takes for a message to
travel from p1 to p2 is greater than 4. This reduces even further the decision choices
needed when specifying some scenario as one does not need to consider grounded
Network Topologies.

– Time Variables and Time Constraints: As described here, we use time variables
and keep track of the Time Constraints of the constructed Timed Strand, which is
initially empty. Whenever a command in our protocol language is executed, we add
the corresponding constraint to the set of constraints following Deﬁnition 5. We then
call the SMT solver to check whether the set of constraints is satisﬁable. If it is not,
then search on this branch of the search tree is aborted.

– Timed Intruders: Our prototype also implements the solution described in Sec-
tion 4.1 for the conﬁguration of timed intruders. This greatly simpliﬁes the number
of decisions needed when specifying a veriﬁcation scenario. Whenever a message is
sent by a participant, his corresponding timed intruder broadcasts this message to all
other Timed Intruders. A timed intruder is only able to learn such a message when
enough time has elapsed. This is implemented also using the SMT solver and adding
appropriate time constraints.

hp1,newni@tt1hp1,+n#tt=ﬂoor(cur)+1)i@tt2hp1,(−n#ﬂoor(cur)+1≤tt+4)i@tt3hp2,−ni@tt4hp2,+ni@tt5htip1,−n,+ni@(tt2,tt2)htip2,−n,+ni@(tt5,tt5)htip2,−n,+ni@(tt4,tt4)htip1,−n,+ni@(tt3,tt3)Scenario

Size of Protocols

No of States

Search Time

External Distance Fraud
Attack-in-Between-Ticks
Simpliﬁed Paywave
Paywave
NSL + Distance Bounding (cid:63)

5
5
14
22
15

12
70
3224
20807
86

31ms
55ms
8s
78s
108ms

Table 1: Preliminary Experimental Results

Table 1 summarizes some preliminary experimental results.
The External Distance Fraud and Attack-in-Between-Ticks are as described above.
The number of states traversed is quite small for ﬁnding these. The distance bounding
protocol scheme is used by many other protocols, such as the protocol described in [21]
(NSL + Distance Bounding) and the lack of its use leads to an attack on the Paywave
protocol [6]. We implemented these to check how our tool scales to larger protocols.
We implemented a simpliﬁed version of the Paywave protocol omitting some of the
steps taken and only concentrating on the core part of the protocol. Our tool was able to
ﬁnd the attack in 8 seconds traversing around 3.2k states. Finally, we implemented the
whole Paywave protocol and our tool was also able to ﬁnd the attack, but now in 78s
traversing 20.8k states.

The use of the SMT solver was essential to reduce the number of states. However, it
seems that it is possible to reduce the overhead caused by each call of the SMT solver.
We also experimented with protocols that fall outside of our language fragment. The
NSL + Distance Bounding protocol described in [21] with a small modiﬁcation car-
ries out a standard Needham-Schroeder-Lowe protocol session, followed by a distance
bounding protocol using xor. Since our tool does not support yet equational theories, a
subject for future work, we modeled the distance bounding session with a pair. Our tool
was able to ﬁnd a terrorist attack in 108 ms traversing 86 states. This attack was not
reported in [21] as they did not assume that intruders are close to the participants.

Finally, we also obtained preliminary results on using the tool for checking whether
there is a privacy attack on a protocol [7]. In order to check for such an attack, we need
to enumerate all possible executions. (The formal deﬁnitions are out of the scope of this
paper.) In order to have an idea of how big this set of executions is, we implemented
the protocol used for RFID in European passports. The total number of states was only
10 states. This is a promising result for extending this work to check for properties that
rely on observational equivalence [5].

6 Related and Future Work

Meadows et al. [18] and Pavlovic and Meadows in [20] propose and use a logic called
Protocol Derivation Logic (PDL) to formalize and prove the safety of a number of
cyber-physical protocols. In particular, they specify the assumptions and protocol exe-
cutions in the form of axioms, specifying the allowed order of events that can happen,
and show that safety properties are implied by the axiomatization used. They do not
formalize an intruder model. Another difference between their work and ours is that
their PDL speciﬁcation is not an executable speciﬁcation.

Another approach similar to [18], in the sense that it uses a theorem proving ap-
proach, is given by Basin et al. [3]. They formalize an intruder model that is similar to
ours in Isabelle, and also formalize some cyber-physical security protocols. They then
prove the correctness of these protocols under some speciﬁc conditions and also iden-
tify attacks when some conditions are not satisﬁed. Their work has been a source of
inspiration for our intruder model speciﬁed in Section 3. However, they do not propose
or investigate the Timed Intruder Completeness Problem.

Chothia et al. [6] investigate empirically the execution times of commands of CPSP
which are carried out by limited resource devices and then, based on these measure-
ments, they propose the inclusion of a distance bounding session to mitigate relay at-
tacks. They proved the security of CPSP by modeling the protocol in different phases.
As we illustrate in Example 2, our language allows the inclusion of the measurements
themselves. We leave a more detailed analysis to future work.

Cheval and Cortier [5] propose a way to prove the observational equivalence with
time by reducing it to the observational equivalence based on the length of inputs. They
are able to automatically show that RFID protocols used by passports suffer a privacy
attack. Their approach is, therefore, different as they do not investigate the Timed In-
truder Completeness Problem. Also it is not clear whether from their language one can
capture attacks such as the Attack-in-Between Ticks which exploits the time constraints
of the veriﬁer. Finally, from our initial experiments with the Passport RFID protocol,
we believe that it is also feasible to check for privacy attacks given the very low number
of states encountered by our tool. This is left for future work.

Finally, Malladi et al. [17] formalize distance bounding protocols in strand spaces.
They then construct an automated tool for protocol veriﬁcation using a constraint solver
to verify a number of examples. There are some similarities between their goals and the
goal we want to achieve, namely, the automated veriﬁcation of CPSP and in the use
of SMT solvers to do so. However, there are some important differences. Firstly, we
formalize and provide a solution to the Timed Intruder Completeness Problem and, sec-
ondly, our language seems to have more expressive features, e.g., our time constraints.
The deﬁnition of restricted bundle to characterize executions from the protocol par-
ticipants perspective is inspired by the notions of skeleton and shape in strand space
based protocol analysis [10, 11].

Arnaud et al. [1] propose a model for specifying and reasoning about secured rout-
ing protocols where nodes communicate in a direct way with their neighbors. It seems
possible to represent our network model using time constraints as they do and not only
reason about the routing of packets, but also the time when these arrive, which is im-
portant for cyber-physical systems where agents use some routing protocol to commu-
nicate. We leave this to future work.

We are currently investigating methods to control even further the state space explo-
sion, for example, using more elaborate symbolic constraint systems for messages and
investigating how to support backward Narrowing as in Maude-NPA [13]. Moreover,
we are extending our implementation to support message signatures with equational
theories using the library available in Maude [12]. Finally, we are investigating deﬁ-
nitions of observational equivalence which involve time and that can be implemented
using SMT-solvers.

References

1. M. Arnaud, V. Cortier, and S. Delaune. Modeling and verifying ad hoc routing protocols.
Information and Computation, 238:30 – 67, 2014. Special Issue on Security and Rewriting
Techniques.

2. C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jovanovic, T. King, A. Reynolds, and
C. Tinelli. CVC4. In Computer Aided Veriﬁcation - 23rd International Conference, CAV
2011, Snowbird, UT, USA, July 14-20, 2011. Proceedings, pages 171–177, 2011.

3. D. A. Basin, S. Capkun, P. Schaller, and B. Schmidt. Formal reasoning about physical prop-

erties of security protocols. ACM Trans. Inf. Syst. Secur., 14(2):16, 2011.

4. I. Cervesato. Data access speciﬁcation and the most powerful symbolic attacker in MSR. In
Software Security – Theories and Systems, Mext-NSF-JSPS International Symposium, ISSS
2002, Tokyo, Japan, November 8-10, 2002, Revised Papers, pages 384–416, 2002.

5. V. Cheval and V. Cortier. Timing attacks in security protocols: Symbolic framework and
proof techniques. In Principles of Security and Trust - 4th International Conference, POST
2015, Held as Part of the European Joint Conferences on Theory and Practice of Software,
ETAPS 2015, London, UK, April 11-18, 2015, Proceedings, pages 280–299, 2015.

6. T. Chothia, F. D. Garcia, J. de Ruiter, J. van den Breekel, and M. Thompson. Relay cost
In Financial Cryptography and Data Security,

bounding for contactless emv payments.
2015.

7. T. Chothia and V. Smirnov. A traceability attack against e-passports. In Financial Cryptog-

raphy and Data Security, pages 20–34, 2010.

8. M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. All
About Maude: A High-Performance Logical Framework, volume 4350 of LNCS. Springer,
2007.

9. C. J. F. Cremers, K. B. Rasmussen, B. Schmidt, and S. Capkun. Distance hijacking attacks
In IEEE Symposium on Security and Privacy, SP 2012,

on distance bounding protocols.
21-23 May 2012, San Francisco, California, USA, pages 113–127, 2012.

10. S. F. Doghmi, J. D. Guttman, and F. J. Thayer. Searching for shapes in cryptographic pro-
tocols. In Tools and Algorithms for Construction and Analysis of Systems (TACAS), volume
4424 of LNCS, page 523538. Springer, 2007.

11. S. F. Doghmi, J. D. Guttman, and F. J. Thayer. Skeletons, homomorphisms, and shapes:
Characterizing protocol executions. In Mathematical Foundations of Program Semantics,
2007.

12. F. Dur´an, S. Eker, S. Escobar, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. Built-in variant
generation and uniﬁcation, and their applications in maude 2.7. In 8th International Joint
Conference on Automated Reasoning, 2016.

13. S. Escobar, C. A. Meadows, and J. Meseguer. Maude-npa: Cryptographic protocol analysis
modulo equational properties. In Foundations of Security Analysis and Design V, FOSAD
2007/2008/2009 Tutorial Lectures, pages 1–50, 2007.

14. M. Kanovich, T. B. Kirigin, V. Nigam, A. Scedrov, and C. Talcott. Discrete vs. dense times
in the analysis of cyber-physical security protocols. In Principles of Security and Trust - 4th
International Conference, POST, pages 259–279, 2015.

15. M. I. Kanovich, T. B. Kirigin, V. Nigam, A. Scedrov, and C. L. Talcott. Towards timed
models for cyber-physical security protocols. Available in Nigam’s homepage, 2014.
16. G. Lowe. Breaking and ﬁxing the Needham-Schroeder public-key protocol using FDR. In

TACAS, pages 147–166, 1996.

17. S. Malladi, B. Bruhadeshwar, and K. Kothapalli. Automatic analysis of distance bounding

protocols. CoRR, abs/1003.5383, 2010.

18. C. Meadows, R. Poovendran, D. Pavlovic, L. Chang, and P. F. Syverson. Distance bounding
protocols: Authentication logic analysis and collusion attacks. In Secure Localization and
Time Synchronization for Wireless Sensor and Ad Hoc Networks, pages 279–298. Springer,
2007.

19. J. K. Millen. A necessarily parallel attack. In In Workshop on Formal Methods and Security

Protocols, 1999.

20. D. Pavlovic and C. Meadows. Deriving ephemeral authentication using channel axioms. In

Security Protocols Workshop, pages 240–261, 2009.

21. S. Santiago, S. Escobar, C. A. Meadows, and J. Meseguer. Effective sequential protocol

composition in maude-npa. CoRR, abs/1603.00087, 2016.

22. F. J. Thayer, J. C. Herzog, and J. D. Guttman. Strand spaces: Proving security protocols

correct. Journal of Computer Security, 7(1):191–230, 1999.

A Distance Hijacking Attack

hp1,newn1i@tt1hp1,+enc({n1,p1},pke)i@tt2hp1,−enc({n1,ne,pe},pk1)i@tt3hpe,newnei@tt7hp2,newn2i@tt11hpe,−enc({n1,p1},pke)i@tt8hpe,+enc({n1,ne,pe},pk1)i@tt9hp2,−enc({n1,pe},pk2)i@tt12hp2,+enc({n1,n2,p2},pke)i@tt13hp1,−n20i@tt5hp1,+n20⊕n1i@tt6hp2,newn20i@tt15hp2,+n20#tt=curi@tt16hp2,+n3⊕n1#cur≤tt+Di@tt17htip1,−enc({n1,p1},pke),+enc({n1,p1},pke)i@(tt18,tt180)hp1,+enc(ne,pke)i@tt4hpe,−enc(ne,pke)i@tt10hp2,−enc(n2,pk2)i@tt14htipe,−enc({n1,ne,pe},pk1),+enc({n1,ne,pe},pk1)i@(tt20,tt200)htip1,−enc({n1,ne,pe},pk1),+enc({n1,ne,pe},pk1)i@(tt21,tt210)htip1,−enc(ne,pke),+enc(ne,pke)i@(tt22,tt220)htipe,−enc(ne,pke),+enc(ne,pke)i@(tt23,tt230)htipe,+pk−1ei@tt24htipe,−pk−1e,−enc({n1,p1},pke),+{n1,p1}i@(tt25,tt250,tt2500)htipe,−{n1,p1},+n1,+p1i@(tt26,tt260,tt2600)htipe,+pei@tt27htipe,−n1,−p1,+{n1,pe}i@(tt28,tt280,tt2800)htipe,+pk2i@tt29htipe,−pk2,−{n1,pe},+enc({n1,pe},pk2)i@(tt30,tt300,tt3000)htipe,−enc({n1,pe},pk2),+enc({n1,pe},pk2)i@(tt31,tt310)htip2,−enc({n1,pe},pk2),+enc({n1,pe},pk2)i@(tt32,tt320)htip2,+pk−1ei@tt34htip2,−pk−1e,−enc({n1,n2,p2},pke),+{n1,n2,p2}i@(tt35,tt350,tt3500)htip2,−{n1,n2,p2},+{n1,n2},+p2i@(tt36,tt360,tt3600)htip2,−{n1,n2},+n1,+n2i@(tt37,tt370,tt3700)htip2,+pk2i@tt38htip2,−pk2,−n2,+enc(n2,pk2)i@(tt39,tt390,tt3900)htip2,−n20,+n20i@(tt42,tt420)htip1,−n20,+n20i@(tt43,tt430)htip1,−n20⊕n1,+n20⊕n1i@(tt44,tt440)htip2,−n20⊕n1,+n20⊕n1i@(tt45,tt450)htipe,−enc({n1,p1},pke),+enc({n1,p1},pke)i@(tt19,tt190)