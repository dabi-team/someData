The TrieJax Architecture: Accelerating Graph Operations
Through Relational Joins

9
1
0
2

y
a
M
7
1

]

B
D
.
s
c
[

1
v
1
2
0
8
0
.
5
0
9
1
:
v
i
X
r
a

Oren Kalinsky
Technion, Israel

Benny Kimelfeld
Technion, Israel

Yoav Etsion
Technion, Israel

ABSTRACT
Graph pattern matching (e.g., ﬁnding all cycles and cliques)
has become an important component in many critical do-
mains such as social networks, biology and cyber-security.
This development motivated research to develop faster algo-
rithms that target graph pattern matching. In recent years, the
database community has shown that mapping graph pattern
matching problems to a new class of relational join algo-
rithms provides an efﬁcient framework for computing these
problems.

In this paper, we argue that this new class of relational
join algorithms is highly amenable to specialized hardware
acceleration thanks to two fundamental properties: improved
locality and inherent concurrency. The improved locality
is a result of the provably bound number of intermediate
results these algorithms generate, which results in smaller
working sets. In addition, their inherent concurrency can
be leveraged for effective hardware acceleration and hiding
memory latency.

We demonstrate the hardware amenability of this new class
of algorithms by introducing TrieJax, a hardware accelerator
for graph pattern matching. The TrieJax design leverages
the improved locality and high concurrency properties to
dramatically accelerate graph pattern matching, and can be
tightly integrated into existing manycore processors. We
evaluate TrieJax on a set standard graph pattern matching
queries and datasets. Our evaluation shows that TrieJax out-
performs recently proposed hardware accelerators for graph
and database processing that do not employ the new class of
algorithms by 7 − 63× on average (up to 539×), while con-
suming 15 − 179× less energy (up to 1750×). systems that
do incorporate modern relational join algorithms by 9 − 20×
on average (up to 45×), while consuming 59 − 110× less
energy (up to 372×).

1.

INTRODUCTION

Analyzing the relationships in a graph has become a key
building block in many domains, including social networks [33],
biology [13], and artiﬁcial intelligence [29]. A recent study [28]
analyzed the common challenges in graph processing and
found that pattern matching problems, namely ﬁnding all
instances of a given pattern in a graph, to be a dominantly
popular problem in graph application domains. Graph pattern
matching problems, however, are known to be computation-
ally intensive and thus challenge algorithm designers.

In recent years, the database community has proposed new
relational join algorithms that efﬁciently map graph problems
to query evaluation over relational databases. In particular, a
new breed of Worst-Case Optimal Join (WCOJ) algorithms
has been introduced and studied [2, 15, 20, 21, 32]. These
algorithms were shown to be theoretically superior to the
traditional join algorithms [4], and WCOJ-based solutions for
graph matching problems have been shown to deliver superior
performance compared to known graph algorithms [24].

From an architectural perspective, pattern matching via
WCOJ algorithms offers two features that make it hardware
friendly. First, WCOJ algorithms bound the number of in-
termediate results they generate, which greatly reduces the
algorithms’ working-set size, reduces data transfers to and
from memory, and makes them more amenable to caching.
In contrast, traditional join algorithms partition multi-way
joins (a join operation on multiple relations, or tables) into
a tree of binary join operations. Each binary join operation
then performs a memory scan on its input relations and gen-
erates a (potentially huge) intermediate relation. Importantly,
many of the intermediate results are typically ﬁltered out by
subsequent join operations. Second, WCOJ algorithms are
highly concurrent. Although the algorithms’ control ﬂow
is non-trivial, which makes them unsuitable for GPGPUs,
their inherent concurrency makes them amenable to hardware
acceleration. In addition, this inherent concurrency allows
specialized accelerators to apply multithreading techniques
to hide memory latency.

In this paper, we argue that WCOJ-based algorithms for
solving graph pattern matching problems are highly amenable
to specialized acceleration. We describe how graph problems
can be mapped to relational join operations and detail how
the new breed of relational join algorithms maps to hard-
ware. We further present TrieJax, an on-die, domain-speciﬁc
accelerator that leverages the hardware-friendly properties
of WCOJ algorithms to accelerate graph pattern matching
problems and dramatically reduce energy consumption.

TrieJax employs a highly-concurrent WCOJ variant [15]
that scans table indexes stored in a tree-based data-structures.
In addition, TrieJax caches partial join results to speed up
computation and minimize memory trafﬁc. Furthermore,
TrieJax is designed to be small enough to serve as a dedicated
core in a standard many-core processor. This design allows
TrieJax to use the same memory system as other cores in the
system, a property that is crucial for operating on large data
sets. This is in contrast to discrete accelerators (e.g., GPG-

1

 
 
 
 
 
 
PUs), which have limited directly-attached memory capacity
and require frequent data transfers between the system mem-
ory and their local memory. We validated the performance,
area, and energy consumption of TrieJax using a synthesized
and placed&routed RTL implementation, whose results drove
a cycle-accurate simulator.

We demonstrate the improved performance and reduced
energy obtained by leveraging WCOJ-based graph pattern
matching algorithms via a comparison of TrieJax to recently
proposed database and graph processing accelerators [10, 34].
Unlike TrieJax, these accelerators employ traditional join
algorithms and are therefore susceptible to the potential ex-
plosion of intermediate results that these algorithms generate.
We also demonstrate the beneﬁts of hardware acceleration
of WCOJ algorithms by comparing TrieJax to two software
database management systems [1, 15] that are based on the
new breed of WCOJ algorithms. Ultimately, TrieJax outper-
forms the state-of-the-art hardware accelerators by 7 − 63×
on average, while consuming 15 − 179× less energy. Com-
pared to the software systems, TrieJax runs 9 − 20× faster
and consumes 59 − 110× less energy.

In summary, we make the following contributions:

• We present the hardware-friendly properties of WCOJ
algorithms and how they can be used for solving graph
matching problems.

• We present a domain-speciﬁc hardware accelerator that
leverages the hardware-friendly properties of WCOJ
algorithms for graph pattern matching.

• We demonstrate the performance and energy beneﬁts
of a WCOJ-based pattern matching accelerator through
a detailed experimental evaluation.

The rest of the paper is organized as follows. Section 2
explains how graph pattern matching algorithms are mapped
to relational join operations and describe the new breed of
WCOJ algorithms in more detail. Section 3 describes the
TrieJax accelerator architecture and how it maps a WCOJ
algorithm to hardware. Finally, Section 4 presents an exper-
imental evaluation comparing the performance and energy
consumption of TrieJax to database and graph analytics ac-
celerators on standard graph pattern matching queries.

2. NEW RELATIONAL JOIN ALGORITHMS
AND GRAPH PATTERN MATCHING
Graph pattern matching problems have become paramount
in different computational domains, including social net-
works [33], biology [13], and artiﬁcial intelligence [29]. Yet
despite the focus in recent years on developing general graph
analytics frameworks (including hardware accelerators and
optimizations [10, 19, 25]), these frameworks mostly beneﬁt
more well-known graph problems (e.g., Breadth-First Search
and PageRank) but often ignore graph pattern matching prob-
lems.

Recent advances in relational database theory have intro-
duced methods for efﬁcient computation of graph algorithms
based on relational join operations. These methods have
been found particularly effective for computing graph pat-
tern matching problems. In this section, we describe how

SELECT *
FROM Posts as R, Likes as S, Follows as T
WHERE R.postID=S.post and S.user=T.followed

Figure 1: A relational join query example

relational join operations can be used for graph analytics and
review the algorithmic advances in relational join algorithms.
We then discuss how these algorithms, unlike traditional
ones, avoid generating a large number of intermediate results,
which makes them amenable to hardware acceleration.

2.1 Relational Join

Relational database management systems (RDBMS) are a
common solution for data management. This type of database
follows the relational model of data. In this model, the data
is stored in relations, also known as tables (e.g., the tables
Posts and Likes mentioned in Figure 1), the table columns are
the attributes (e.g., user and postID), and the rows (tuples)
are the values. Each row in the table can have an attribute
that is a unique primary key. For instance, the Posts table has
the primary key postID. Other tables can reference a speciﬁc
table through its primary key using an attribute known as a
foreign key. In our example, the Likes table can reference a
post using the post attribute as a foreign key to Posts.

A relational join query is a query that analyzes the rela-
tionship between tables via shared attribute values. Figure 1
shows a simple relational join query—the natural join of the
three relations Posts, Likes and Follows. The query computes
information about posts liked by users with followers. More
precisely, the query is asking for tuples where each consists
of a post, a user who likes the post, and a follower of the
user. While there are different types of join operations, in this
work we focus on natural equi-joins where tables are joined
by equality of mentioned attributes.
Relational join for graph analytics. Many graph algo-
rithms can be translated to (SQL-like) join queries, which al-
lows solving graph problems using RDMS solutions. A ﬁnite
graph is commonly represented in an RDBMS by an adja-
cency list relation. Each row in the relation represents an edge
between two vertices in the graph. Graph patterns queries are
translated to join queries. For example, given a graph relation
G, the query Q(x, y, z) = G(x, y) (cid:49) G(y, z) (cid:49) G(z, x) returns
all the triangles in the graph.

Mapping graph pattern matching algorithms to WCOJ-
based systems have been shown to be highly effective, and
WCOJ-based systems can provide speedups of up to two
orders of magnitude compared to low-level graph analytic so-
lutions [4]. Nevertheless, these performance beneﬁts are not
universal across all graph algorithms. For example, Aberger
et al. [1] have shown that problems such as SSSP [14] and
PageRank [26]) do not enjoy similar beneﬁts. In this paper
we focus on the important family of graph pattern matching
problems.
Database and graph analytic acceleration. Acceleration
of database and graph analytics using SIMD, GPGPU, or spe-
cialized hardware accelerator has been a common interest in
both the database and micro-architecture communities. Q100
by Wu et al. [34] was the ﬁrst hardware accelerator that fully

2

supported relational operations. It incorporates relational op-
erators (such as Sort, Select, and Merge-Join) as hardware
components in a hardware accelerator for relational column
stores. Q100 offers a solution that searches the best custom
chip for a speciﬁc query from time and energy perspectives.
Q100 achieves a speedup of 10× on TPC-H compared to
MonetDB, a commonly used column store. Graphicionado
by Ham et al. [10] focuses on graph analytics. It implements
the vertex-programming model in hardware with embedded
programmable units that allow ﬂexible support for graph
algorithms such as PageRank or SSSP. The Graphicionado
hardware accelerator achieves a speedup of 1.76 − 6.5× com-
pared to GraphMat [31], a vertex-programming framework
that scales using sparse matrix representation and MPI.
New relational join algorithms for graph analytics. Re-
cently, the database community established new theoretical
and algorithmic advances in the area of relational join al-
gorithms. Given a join query with more than two relations,
standard join algorithms use the pairwise join approach. The
traditional algorithms, such as hash-join [9] or sort-merge
join [18], join two relations at a time to create a new interme-
diate relation. This intermediate relation will later be joined
with another (input or intermediate) relation until the ﬁnal
result is computed. Recent work by Atserias et al. [4] shows
that pairwise join algorithms can generate many unnecessary
intermediate results that are not part of the ﬁnal result. It
helps deﬁne a tight bound, called the AGM bound, on the
maximum number of results that can be returned from a query
in the worst case.

We illustrate the AGM bound with an example. Given
the relations A, B and C, consider the triangle join query:
Q(x, y, z) = A(x, y) (cid:49) B(y, z) (cid:49) C(z, x). For simplicity, we as-
sume that each relation has N values. The AGM bound proves
3
that the query result Q(x, y, z) contains no more than N
2 re-
sults. However, pairwise join algorithms can generate an
intermediate result with up to N2 values, while many of them
will be ﬁltered by the third relation. Any join algorithm that
provides the same complexity as the AGM bound is called
Worst-Case Optimal Join (WCOJ) algorithm. In contrast,
the traditional pairwise join algorithms are not worst-case
optimal. More formal deﬁnitions and extensions to general
queries can be found in a full survey by Ngo et al. [22].
Systems and acceleration of WCOJ algorithms. Wu et
al. [5] used GPGPU to accelerate a WCOJ algorithm and
achieved 2 − 6× speedups compared to CPU. EmptyHeaded
by Aberger et al. [1] offered a relational query engine that
maps Generic Join, a WCOJ algorithm, to parallel SIMD
operations on a standard CPU. For graph algorithms, Emp-
tyHeaded achieves comparable results to Galois [23], a low-
level hand-tuned query engine comparable to GraphMat. On
graph pattern matching queries, it achieves a 2−60× speedup
compared to other CPU based solutions. Section 4 compares
our TrieJax to the systems above or their baselines.

2.2 Cached TrieJoin

Following the publication of the AGM bound, a plethora
of Worse Case Optimal Join (WCOJ) algorithms was pub-
lished [2, 15, 20, 21, 32]. Experimental analysis by Nguyen
et al. [24] has shown that the WCOJ algorithms provide sig-

Figure 2: Example of tables from a social network (left)
and their trie representation (right). Marked (green) a
Path-4 join result between the three tables.

niﬁcant speedups on complex join queries compared to the
traditional approaches such as state of the art RDBMS, graph
engines and column stores.

LeapFrog TrieJoin [32], also known as LFTJ, is a com-
monly used WCOJ algorithm. Its main idea is to iterate over
trie-based indexes of the relations in a backtracking manner
to generate the join query results. LFTJ does not generate
any intermediate results and thus yields a low memory foot-
print, but it does so at the expense of recomputing recurring
intermediate partial joins. Furthermore, the recurring com-
putations have little memory locality as they repeatedly scan
irregular, tree-based tries. Cached TrieJoin (CTJ) by Kalinsky
et al. [15] eliminates much of the recurring partial join com-
putations by selectively caching partial join results using the
available system memory (without violating the WCOJ prop-
erty). This behavior can beneﬁt low-memory environments
and is therefore used as one of the main building blocks in
our system.

CTJ operates as follows: Given a query, CTJ decomposes
the query structure to detect which attributes can be valid
keys and their respective cached values. Then, it uses the
caching system to drive the TrieJoin, while saving partial join
results in the cache and extracting them later to avoid recur-
rent computations. CTJ shows a 10× speedup on average
compared to LFTJ, and even better speedups compared to
traditional query engines.

2.2.1

Indexes

CTJ saves its relations in tries, a multi-level data structure
commonly used in WCOJ systems [1], column stores and
graph engines [11, 30]. Section 3 elaborates on the phys-
ical layout of our indexes. Given a relation, for example
the R(x, y) relation with two attributes in Figure 2, the trie
representation is as follows:

• Each attribute, such as x, is a level in the trie.

• Each unique path from the root to a leaf is an entry in
the relation. For example, the path (1, 1) corresponds
to the entry of x = 1 and y = 1 in R(x, y).

• The siblings are sorted.

2.2.2 The Cached TrieJoin algorithm

Next, we elaborate on CTJ, one of our main building
blocks. Figure 3 will be used to illustrate the CTJ execu-
tion ﬂow. The algorithm is presented in Figure 4. CTJ ﬁrst

3

S(y,z)1          21   2   3    5    7yzR(x,y)1    2    3    41   2   2    5    4xyTrierepresentationyx1122234455zy1121315272R(x,y)S(y,z)Tableszwwz5234964767T(z,w)T(w,z)2    4    6    75    3    9  4   6Figure 3: Cached TrieJoin execution and caching ﬂow of an example Path-4 query. Each step marks the current partial
join path on the tries (top)

Algorithm CachedTrieJoin(d, inds, cache, res)

res[valIDs] := cached
AdjustTries(inds, res)
next := max(valIDs) + 1
CachedTrieJoin(next, inds, cache, res)

1: if d = n + 1 then
save res
2:
return
3:
4: keyIDs := cacheKeysOf(d)
5: valIDs := cacheValsOf(keys)
6: if res[keyIDs] is a cache hit in cache then
for all cached in cache(res[keyIDs]) do
7:
8:
9:
10:
11:
12:
13:
14: for all matching values a for attribute d in inds do
15:
16:
17:
18:
19:
20: ResetTries(inds, d)

res[d] := a
AdjustTries(inds, res)
CachedTrieJoin(d + 1, inds, cache, res)
if d = max(valIDs) then

ResetTries(inds, min(valIDs))
return

ApplyCaching(cache, res[keyIDs], res[valIDs])

Figure 4: The CachedTrieJoin algorithm

orders the variables (e.g, x → y → z → w). Then, it looks for
matches for each variable in turn from ﬁrst (x) to last (w). Ini-
tially, the cache is empty (line 14 in Fig. 4). Starting from x,
CTJ will search all the tries that contain x (e.g., R(x, y)) for a
match ( 1 in Fig. 3). Each match is found using a variation of
merge-join, called leapfrog-join [32], that uses lowest upper
bound searches to leap over the variable levels until a match
is found. If a match is found, it sets the x value in the result
buffer (line 15 in Fig. 4).

Before continuing to the next variable (e.g., y), CTJ adjusts
the tries (Line 16) such that they align on the children of the
current partial join path (the nodes below the paths marked
in red in Fig. 3). For example, after step 1 , the R trie is

4

Figure 5: System architecture with TrieJax as another
core and the communication between TrieJax and the
memory

set on the y child nodes of R(x) = 1. Finally (Line 17), the
algorithm calls CTJ to look for a match for the next variable y
( 2 ). In practice, CTJ uses queues instead of recursion. Once
all the variables are set ( 4 ), CTJ saves the result (line 2).
If no other matches are found for the current variable, CTJ
resets the adjusted tries (line 20) to focus on the previous
attribute.

CTJ uses cache for partial join results to avoid the compu-
tation of recurrent partial joins. Given a join variable (e.g.,
z), CTJ extracts the variables that can be used as keys for
caching (e.g., y) and the variables that are cached by these
keys (lines 4–5). During the standard execution, CTJ checks
the cache if the value of the current variable is stored in the
cache. If so, it uses the results from the cache and adjusts the
tries accordingly (lines 9–11). For example, 5 ﬁnds y = 2
in the cache and reads the value of z from the cache instead
of recomputing the join for z. Writing to the cache is done
during the standard execution ( 3 ), after ﬁnding a valid match
for a cached entry (line 19).

3. TrieJax ARCHITECTURE

3.1 System-level overview

TrieJax is designed as a small, on-die co-processor that

yz CacheValuesKeyResult BufferwzyxCompute next x1yz CacheValuesKeyResult Bufferwzyx1Compute next y2yz CacheValuesKeyCompute & cache next z3yz CacheValuesKey21Computenextw;Output result4yz CacheValuesKey2,41yz CacheValuesKey2,4172Read nextzfrom cache5yz CacheValuesKey2,4172Computenext w6Standard ExecutionCaching Partial ResultsReading Partial ResultsSRTSRTSRTResult Bufferwzyx11Result Bufferwzyx211SRTResult Bufferwzyx5311SRTSRTResult Bufferwzyx22A fewstepslater…Result Bufferwzyx722SRT(RO)L2TrieJaxRegularCore(RO)L1LLCDirectoryRDRDL2L1RegularCoreL2L1RegularCoreL2L1…DRAMWRCheck   DirectoryName
Path-3
Path-4
Cycle-3
Cycle-4

Query
path3(x, y, z) = R(x, y), S(y, z).
path4(x, y, z, w) = R(x, y), S(y, z), T (z, w).
cycle3(x, y, z) = R(x, y), S(y, z), T (z, x).
cycle4(x, y, z, w) = R(x, y), S(y, z), T (z, w),

U(w, x).

Clique-4

clique4(x, y, z, w) = R(x, y), S(y, z), T (z, w),

U(w, x),V (z, x),W (w, y).

Table 1: Graph pattern matching operations used to eval-
uate TrieJax and their mapping to join queries (shown in
datalog format, for brevity).

integrates to the main processor like an additional core, as
depicted in Figure 5. This design allows TrieJax to use the
main processor’s memory system and avoids the coherence
and data transfer overheads that plague discrete accelerators.
TrieJax uses a local read-only L1 and L2 caches that, in
turn, are used for caching the index data. Since TrieJax stores
its intermediate results in a private scratchpad as we describe
later on, only the ﬁnal results of the join operations are written
to memory. The memory system, therefore, streams these
write operations directly to memory and bypasses the private
caches to avoid cache thrashing and congestion in the cache
queues. For example, on some of the benchmarks we evaluate
(e.g., path4 query), where the size of the resulting join table
is extremely large, bypassing the private caches improves
performance by up to 2.5×.

The regular processor cores communicate with TrieJax
using a co-processor interface similar to that of ARM [3] or
RISC-V [27]. For instance, we use a parallel of the ARM
LDC command to load the query to the TrieJax internal mem-
ory.

3.2 Query language and index memory layout
We use the CTJ compiler [15] to compile SQL join queries
for TrieJax. Table 1 lists the graph pattern matching queries
used in our evaluation (Section 4) and their mapping to join
queries (for brevity, the table uses the compact datalog format
rather than SQL).

Figure 6 illustrates a trie layout in TrieJax. TrieJax uses in-
memory trie indexes (described in Section 2.2) in a physical
layout similar to that of EmptyHeaded [1]. Speciﬁcally, this
layout stores the unique values of the ﬁrst join attribute in the
relation as a sequential array. The next join attribute is then
stored by concatenating the values that match the previous
attribute to a continuous array. To identify which values of the
second join attribute belong to which elements in the previous
attribute, the child ranges array lists the corresponding ranges
of the second attribute. For example, Figure 6 shows that
the values {(1, 1), (1, 2)} in R can be extracted by focusing
on R(x = 1), extracting the ranges of its children from the
respective indexes [0, 2) in the Rx child ranges array, and
accessing the extracted index range in the Ry array.

3.3 The TrieJax operational ﬂow

Figure 7 presents the high-level design of TrieJax and the
communication between the different components it utilizes
to answer graph pattern matching queries. The ﬁve major

Figure 6: Tables for an example query path3(x, y, z) =
R(x, y), S(y, z). (top left), their trie representations (top
right), and their memory layout (bottom)

building blocks are lowest upper bound (LUB), MatchMaker,
Midwife, Cupid and the partial join results cache (PJR cache).
We illustrate the operational ﬂow of TrieJax on the Path3
example query in Figure 6. We begin by describing the op-
erational ﬂow as single threaded. Section 3.4 then describes
how TrieJax incorporates multi-threading internally to hide
memory latency. The micro-architecture and the internal ﬂow
of each component are described in Section 3.6.

The query execution begins by loading the compiled query
to a local read-only store in Cupid, the component that con-
trols the execution of the full join query (marked 1 in Fig-
ure 7). Cupid starts with the ﬁrst join variable x, by extracting
the pointers to the trie arrays of x embedded in the compiled
query structure (e.g., Rx), and sending them to MatchMaker
(marked 2 in Figure 7). Until a response is returned, Cupid
saves the current state (e.g., result buffer, parameter id) in its
local State Store.

MatchMaker is in charge of ﬁnding the ﬁrst matched value
of x in all the tries (based on the Leapfrog Join algorithm
described in Section 2.2). Our running example (Figure 6)
only has one array (Rx), so MatchMaker will request the LUB
unit to ﬁnd the ﬁrst value for x in Rx ( 3 ). LUB performs a
binary search to look up the lowest upper bound of a value
in a given array. The unit will search for the index in the
trie array in which the value is stored ( 4 ), e.g., Rxindex = 0,
and send the result back to MatchMaker. MatchMaker will
send the read value and index (e.g., x = 0, Rxindex = 0) back
to Cupid, which will save the index in the current state of
variable x. Similarly to Cupid, MatchMaker and LUB save
their local state in their State Store when sending a request
and reads the data when receiving the response.

Next, Cupid will continue to the next variable y and look
for a match for y. It will read the Ry and Sy array pointers
from the compiled query. As described above, the Ry array
stores all the values of the child nodes of Rx. To extract the

5

S(y,z)1          21   2   3    5    7yzR(x,y)1    2    3    41   2   2    5    4xyTrierepresentation12340234512245RxRx child rangesRy1203512357SySychildrangesSzTrieLayoutyx1122234455zy1121315272R(x,y)S(y,z)TablesFigure 7: TrieJax core components and its high-level operational ﬂow.

Ry range that belongs to the current x value, Cupid will send
the x index, the Ry pointer, and the Rx child ranges pointer
to Midwife ( 6 ). The Midwife component is in charge of
extracting the children of a node in the trie. For example, to
extract the Ry values for Rxindex = 0, Midwife will read from
the child ranges array the start and end ranges from indexes
0 and 1, respectively. The ﬁnal Ry range (e.g., Ry[0 : 2]) will
be sent to MatchMaker.

Once MatchMaker receives both Sy and Ry array ranges
sent from Cupid and Midwife, it will look for the ﬁrst match
of the two array ranges. It will send the pointer of the ﬁrst
value in Ry and the Sy array pointer to LUB ( 3 ). LUB loads
the value of Ry from memory and uses binary search to look
for its lowest upper bound in Sy (e.g., Sy = 1). The result
is returned to MatchMaker, which extracts its state from the
State Store and checks if a match LdVal was found. If so, it
will return the data to Cupid that, in turn, will set the state for
variable y and continue to the next variable z. If not, it will use
LUB to look for LdVal in the Ry range, using iterative LUB
searches on Sy and Ry until a match is found or it reaches the
end of an array. If no match is found, MatchMaker will return
a failed response to Cupid, which will restore the previous
variable and look for its next match. Once a match is found
for x, y and z, Cupid will write the result to memory. TrieJax
uses a small write buffer and sends results to main memory
when the buffered results exceed the size of a cache line.

3.4 Multi-threading in TrieJax

TrieJax’s use of multi-threading (MT) achieves two per-
formance beneﬁts. First, MT parallelizes the trie join and
thereby extracts memory-level parallelism (MLP), which al-
lows TrieJax to hide memory latency. Second, MT pipelines
the operations on the partial join results cache, and enables
Cupid to lookup pre-computed partial results while the rest
of the accelerator is looking for new results.

Figure 8 presents two different MT schemes, static and
dynamic. The static MT scheme divides the arrays of the

Figure 8: TrieJax MT schemes for the path–3 query.
Static MT (top) divides the query search space statically
based on the ﬁrst join attribute. Dynamic MT (bottom)
can spawn a new thread on every match to continue with
the query while the current thread focuses on the sub-
query given the match.

ﬁrst attribute between the different threads. This scheme is
similar to software MT solution in DBMS systems such as
EmptyHeaded [1] and GPU query engines [5]. The disadvan-
tage of this scheme is an unbalanced workload distribution
between the different TrieJax threads. For example, in Fig-
ure 8, tid1 will generate many results while tid2 will ﬁnish
quickly without any results.

Dynamic MT, on the other hand, balances the load by
dynamically allocating new threads on each match. On a
match, the Cupid unit splits the search space to two sub-
spaces. The original thread is then bound to the search space

6

MidwifeExtract Trie childrenCupidFull joinControl logicMatchmakerFind firstmatch of 2arraysMidwifeExtract Trienode childrenLUBBinary Search LogicLDLDSTTrieJax CoreMemory SystemLocal StorageInsertionBufferPartial JoinResultsCacheThreadStateThreadStateThreadStateThreadStateRDWR2345671QueryS(y,z)1          21   2   3    5    7yzR(x,y)1    2    3    41   2   2    5    4xytid1tid2R(x,y)1    2    3    41   2   2    5    4xytid2tid1S(y,z)1          21   2   3    5    7yzStatic MTDynamic MTcontaining the current partial result, and the new thread will
be bound to the search space after the current match. For
example, in Figure 8, a match is found for x = 1 while using
dynamic MT. After the match, tid1 will compute the results
for x = 1 and tid2 will compute the results for x > 1.

On its own, however, dynamic MT might incur a slow
initialization time for queries with infrequent matches due to
fewer matching opportunities. TrieJax thus combines both
static and dynamic MT.

Each component supports multi-threading by replicating
its internal execution state. As shown in Figure 7, each com-
ponent in the system maintains a small local memory to store
the execution state when waiting for a response from another
component (e.g. when Cupid requests MatchMaker to ﬁnd
the next match for a variable). Replicating this state allows
each component to maintain multiple operations in-ﬂight.
For duplicated components, such as Midwife, we use banked
stores to support parallel accesses. Section 4.2 examines
the performance impact of MT and identiﬁes the number of
threads required to achieve performance/storage balance.

3.5 Caching with threads

Locality across partial join results enables TrieJax to break
query execution into two parallel ﬂows using the TrieJax
In the main ﬂow,
partial join results cache (PJR cache).
Cupid, Midwife, MatchMaker and LUB construct new partial
results. In the other ﬂow, Cupid maintains partial results in
the PJR cache and checks if the stored partial results can be
used instead of executing the main ﬂow and recompute them.
Decoupling the ﬂows and using MT in both allows the units
to execute concurrently.

The PJR cache stores intermediate partial join results based
on the cache structure provided by the TrieJax compiler,
namely which attributes are keys and their corresponding
cached attributes. In our caching example from Section 2.2
(Figure 3), the cache entry of PJR cache stores the partial
join values and indexes of z (e.g., the values 2 and 4 and
their indexes) and it is keyed by a hash of the corresponding
y value (e.g., 1). The indexes in the trie array are stored to
allow the expansion of the children nodes by Midwife.

When Cupid ﬁnds a match on a key attribute (e.g., y), it
searches PJR cache for its partial join results. For instance,
the values of z for the given y (similarly to step 5 in Figure 3).
In the case of a cache hit, it uses the cached results instead of
recomputing them. Otherwise, PJR cache will allocate a new
entry for the array of intermediate results, and Cupid will use
the main ﬂow to compute the values and set them (and their
indexes) in the entry.

Since partial join results can have variable lengths, each
entry contains the number of values currently stored in the
entry. If an entry overﬂows, when it attempts to store more
intermediate results than the entry size, it is deallocated to
avoid storing incomplete results.

A major challenge when using MT to ﬁll the PJR cache
is managing read/write race conditions. We solve this issue
by adding an insertion buffer that stores entries that were not
fully analyzed, meaning that TrieJax did not ﬁnish analyzing
all the paths under the entry key. Once an entry is fully
analyzed it is copied atomically to the PJR cache. Another
MT challenge is write/write races. A keen reader will notice

Figure 9: The logical ﬂow of LUB: 1 If array is empty
or match found return current result. 2 Otherwise, Up-
date array range (namely arr’), read middle of array
from memory ( 4 ) and store current state in local Thread
Store ( 3 ).

that the same partial join result can be accessed from different
paths. If a partial join result is available in the cache, it will
be used by the querying thread. However, if the entry is still
in the insertion buffer, two threads from different paths might
try to append values to the same entry. To avoid this race,
the insertion cache uses all the values leading to the key to
validate that the values are stored from just one path. For
example, when looking on the dynamic MT in Figure 8, we
can see that tid1 computes the results for (x = 1, y = 2), while
tid2 looks for the results of (x = 2, y = 2). If the results for
y = 2 are not in the PJR cache, tid2 will compute the results
and store them in the insertion buffer. While y = 2 is in the
insertion buffer, the value of x for tid2 is different and the
tid2 results will not be stored.

The last caching challenge is how to determine that an
entry is fully analyzed. With dynamic MT, multiple threads
can work on the same cache entry in parallel. New threads
can even be created on the ﬂy to help analyze the cache entry.
To avoid race conditions we add a thread counter to each
entry that maintains the number of threads currently working
on the entry. Each thread that is involved with a cached entry
notiﬁes the cache of its allocation or deallocation to update
the count. Once the count reaches zero, the cached entry
analysis is done and the entry is copied to the PJR cache.

3.6 The TrieJax components

We now turn to describe the microarchitecture and internal

ﬂow in each TrieJax component.
LUB. This component searches for a value in a sorted array
using binary search. If the value does not exist, it returns the
lowest upper bound. This component has a load (LD) unit to
communicate with the memory. Figure 9 presents the logical
ﬂow of LUB. Since most of the read operations issued by
TrieJax are part of binary search operations, encapsulating
the binary search logic in the specialized LUB component
allows us to duplicate the component and generate multiple
memory accesses that look for matches on different sub-
arrays concurrently.
MatchMaker. This component implements the leapfrog
join algorithm described in Section 2.2 for one join variable.
Figure 10 presents the logical ﬂow of MatchMaker and the
queues used to communicate with LUB and Cupid. Given
two array ranges, this unit communicates with LUB to ﬁnd

7

tid, LdValBinary Searchtid, arr, searchVallen(arr) = 0 ORsearchVal= LdValTRUEFALSEtid, arr, ind, searchVal, LdValLdQueueLUBThreadStateLUBDoneQueueMemQueuetid, readPtrThreadStatetid, arr’, searchVal12345Figure 10: The logical ﬂow of MatchMaker: 1 If match
found return True ( 2 ). 3 Otherwise, check if index1 in
range. If not, return False ( 4 ). Otherwise, look for low-
est upper bound in arr2 ( 5 ) and store thread state in the
local Thread Store ( 6 ).

Figure 11: The logical ﬂow of Midwife: 1 Midwife re-
ceives the child range array of a parameter in the trie
and (matched) value index. 2 It reads from memory the
start and end offsets of the next parameter array that
ﬁts the (matched) value. Next, 4 it computes the next
parameter array range and sends it to MatchMaker ( 5 ).

the ﬁrst value that is contained in both arrays. If no such
value is found, the component returns false.

Midwife. This component is used to extract the child nodes
of a value node in the trie data structure, following the logic
presented in Figure 11. The component computes the memory
range in which the child nodes of a given parent node are
stored. The inputs to the unit are a pointer to a child node
array and a parent index. For example, given the Rx child
ranges array in Figure 6 and index 0 of Rx, Midwife extracts
the range [0, 2) and returns the Ry[0 : 2] range (start and end
pointers) to MatchMaker. The LD unit is used to access the
children array. This component is duplicated to handle up to
two child node ranges in parallel.

Cupid. This unit manages the execution of the full join query.
Figure 12 shows the single threaded logical ﬂow of Cupid.
For each join attribute k, it uses the MatchMaker to look for
the next match in all the indexes that contain k. If a match
is found, it updates the result buffer and moves to the next
join attribute. Otherwise, it backtracks and looks for the next
match for the previous join attribute. Finally, the unit uses
its store (ST) unit to save the ﬁnal results to memory. This
component is also in charge of the threads management and
partial join results caching. More information can be found
later in this section.

8

Figure 12: The logical ﬂow of Cupid (single thread, no
cache): 1 If a match is found for the current join vari-
able, 2 check if it is the last join variable. If so, save the
result to memory ( 4 ). If not, save the arrays, matched
indexes and value of the current join variable, and ex-
tract the indexes of the next join attribute from the query
structure ( 5 ). If the join variable is in the ﬁrst trie level
send it directly to MatchMaker, otherwise use Midwife to
extract the parameter values ( 6 ). If a match was not
found, check if it is the ﬁrst join variable ( 3 ). If so, 4
write a DONE token to memory. Otherwise, 8 restore
the previous join variable data and 9 look for the next
match similarly to 6

3.7 TrieJax local memory system

There are three local memory stores in TrieJax. The ﬁrst
is the PJR cache, which is accessed by Cupid. The second is
a constant read-only memory that stores the query structure
and cache structure described in Section 3. Finally, each
component holds a small local memory for maintaining the
thread state. For example, LUB units store the searched value
and array range before sending the request to memory. Once
the request is returned, the thread information is read from
the LUB thread store and continues according to the result.
We use SRAM for the local memory stores. The PJR cache
is the biggest store, amounting to 4 MB (for brevity, we do not
present the full design space exploration for the cache size).
This store uses 4 banks to allow fast concurrent accesses. The
Cupid thread store is the second biggest amounting to 16
KB, while the remaining stores containing less than 512 B.
It supports 32 threads, a conﬁguration which offers the best
performance/storage as examined in Section 4.2.

4. TrieJax EVALUATION

In this section, we present our evaluation of TrieJax when
executing graph pattern queries and compare its performance
and power beneﬁts to four state-of-the-art baselines: Cached
Trie Join (CTJ) [15] and EmptyHeaded [1] are software sys-
tems, and Graphicionado [10] and Q100 [34] are hardware
accelerators. Our evaluation focuses on the following core
questions:

• How does the performance of TrieJax compare to the

baselines?

tid, arr1, ind1, searchVal, LdValtid, arr2, ind2searchVal=LdValTRUEFALSEtid, arr1, ind1, arr2, ind2, searchVal, TRUELUBDoneQueueMatchmakerThreadStateMatchDoneQueueLUBtid, arr2, LdValThreadStatetid, arr1, …145Ind1 ≥len(arr1)2TRUEtid, …, FALSE36tid, startOffset, endOffsettid, arrLdQueueMidwifeThreadStateMatchmakertid, arr’ThreadStatetid, arr235MidwifeQueueSend Memtid, childRangeArr, ind, arrMemQueuetid, childRangeArr[ind:ind+2]1Compute Range4tid, arrays, indexes, matchedtid, …matched?FALSETRUEMatchDoneQueueCupidThreadStateMEMResultThreadState14Last Joinvariable?27FALSEFirst Joinvariable?DONETRUETRUERestorePreviousAttributeFindNextMatchAnalyzeNextAttributeFALSEFindNextMatchMatchmaker/Midwife35689• What is the power consumption of TrieJax compared to

Dataset

#Nodes

#Edges

Category

the baselines?

• What is the effect of the TrieJax multi-threading on

performance?

• How the partial join results cache affect the perfor-

mance?

4.1 Methodology

TrieJax. We implemented all the TrieJax building blocks
using PyRTL [7]. We then used Cadence Innovus and Design
Vision in tandem with the OpenCell 45nm design library to
synthesize and place&route the Verilog code generated by
PyRTL. The design achieves a ﬁxed frequency of 2.38GHz
(critical path of 0.42ns), and the results are for dynamic multi-
threading with 32 threads (unless otherwise noted).

The timing and power ﬁgures obtained by the physical de-
sign were used to drive a cycle-accurate simulator of TrieJax.
The simulator models all micro-architectural components
described in Section 3. We integrated the simulator with
Ramulator [16] to obtain accurate performance of the mem-
ory system. The DRAM energy is simulated with DRAM-
Power [6] using the memory traces from Ramulator. The
performance and power of the on-chip SRAM memory were
simulated using Cacti 6.5 [12]. The TrieJax uses a default
PJR cache size of 4 MB, which includes the insertion buffer.
The off-chip memory is simulated as 64GB of DDR3_1600
DRAM with two channels. The total TrieJax core area is
5.31mm2.
Baselines. We compare TrieJax to the Q100 and Graphi-
cionado hardware accelerators and to CTJ and Emptyheaded
software systems (these baselines are discussed in detail in
Section 2.1). Since we do not have the original code for the
hardware accelerators, we estimate the performance of Q100
and Graphicionado based on their original software baselines,
MonetDB and GraphMat, respectively. We conﬁgured the
original software baselines as described in the original Q100
and Graphicionado papers and scale the baselines’ results
given the best speedup and energy improvement reported in
the papers. We believe this methodology provides a compari-
son that is favorable to both Q100 and Graphicionado.

In addition, we use CTJ and EmptyHeaded as highly tuned
WCOJ software baselines. To achieve a comparison that is
favorable to the baselines, each system is run 3 times and the
minimum value is reported.

To evaluate the power consumption of all software systems
we measured the power of the Package and DRAM using
the Intel Running Average Power Limit (RAPL) meters [8].
We sample the energy consumption during the benchmark
and deduct idle energy consumption measured on the same
machine for the same amount of time. For Q100 and Graphi-
cionado, whose original papers did not report DRAM energy
consumption, we estimate the memory energy consumption
by dividing the DRAM energy consumption of the respective
baseline by the accelerator speedup. Because the accelerators
use similar algorithms to their baselines, our scaling reduces
the idle memory consumption of the DRAM avoided by the
speedup.

Finally, our experimental platform is a Supermicro 2028R-
E1CR24N server. The server is conﬁgured with two Intel

ca-GrQc (grqc)
soc-sign-bitcoin-alpha (bitcoin)
p2p-Gnutella04 (gnu04)
ego-Facebook (facebook)
wiki-Vote (wiki)
p2p-Gnutella31 (gnu31)

5,242
3,783
10,876
4,039
7,115
62,586

14,496
24,186
39,994
88,234
103,689
147,892

Collabor.
Bitcoin
P2P
Social
Social
P2P

Table 2: Dataset statistics

TrieJax

Software frameworks

Processing
Unit

On-chip
memory

Off-chip
memory

TrieJax core @ 2.38GHz
PRJ 4MB SRAM
L1D ReadOnly 32KB 8-way
L2 ReadOnly 32KB 8-way
L3 20MB
4 × DDR3-1600
2 × 12.8GB/s channels

16 × Xeon E5-2630 v3 cores
@ 2.4GHz
L1I/L1D 32KB/core 8-way
L2 512KB/core 8-way
L3 40MB
4 × DDR3-2133
2 × 17GB/s channels

Table 3: Experimental conﬁguration for TrieJax and the
software baselines

Xeon E5-2630 v3 processors running at 2.4 GHz, 64GB of
DDR3 DRAM with two channels, and is running a stock
Ubuntu 16.04 Linux.
Datasets and queries. We test ﬁve query patterns (listed
in Table 1) on 6 different datasets. We focus on common
graph pattern matching queries. Testing on linear algorithms
returned comparable results to the baselines, which follows
the worst-case complexity of the underlying algorithm. We
leave the integration of other operators, such as SORT, to fu-
ture work which can be done similarly to Q100. Our datasets
are real-world graphs taken from Stanford SNAP [17]. Ta-
ble 2 presents the different datasets. Due to the polynomial
complexity of our queries, the runtime of the join query dras-
tically increases on bigger datasets. Therefore, we only use
datasets with simulation time smaller than ﬁve days.

4.2

Impact of multithreading on performance

Figure 14 how using different number of internal threads
affect its performance. By using only 8 internal threads,
TrieJax’s performance is improved by 5.8×, on average,
compared to single-threaded implementation. Similarly, run-
ning 32 internal threads improves the average performance
speedup by 10.8× over single thread version. Using 64
threads, however, has a minor effect on the performance.
We therefore choose to use 32 internal threads in our bench-
marks.

4.3 Performance comparison

Figure 13 shows the speedup of TrieJax compared to the
four baselines (note the logarithmic scale) for the queries
listed in Table 1 and datasets listed in Table 2.

TrieJax consistently outperforms the software baselines.
Compared to CTJ, TrieJax achieves a speedup of 5.5 − 45×
and 20× on average. In comparison to EmptyHeaded, which
uses a highly parallel WCOJ algorithm with SIMD operations,
TrieJax reaches a 2.5 − 44× speedup and 9× on average.

Notably, TrieJax also delivers substantial speedups com-
pared to the hardware accelerators. TrieJax is 7× faster than

9

Figure 13: TrieJax performance speedup compared to the baselines.

Figure 14: Performance speedup of TrieJax limited to
different number of dynamic threads compared to single-
threaded TrieJax

Figure 15: Average energy consumption distribution of
TrieJax for each query. Note that the energy consump-
tion is completely dominated by the memory system.

Graphicionado, on average, ranging between 0.8 − 32×. The
speedup is because TrieJax avoids a large number of unneces-
sary intermediate results, that take the form of messages being
passed between the different graph nodes in Graphicionado.
While TrieJax offers a considerable speedup on average,
Graphicionado was able to perform faster on the Path4 wiki
and Path4 Facebook queries. In these queries, Graphicionado
outperforms TrieJax by up to 1.25×. The reason for this
minor slowdown is that these queries generate a large number
of results, and the TrieJax memory system becomes a bottle-
neck. Nevertheless, these slowdowns may be artifacts of our
optimistic estimation of Graphicionado, which does not limit
its memory bandwidth.

Finally, TrieJax outperforms Q100 by 63×, on average,
ranging from 0.9 − 539×. This is mostly due to the inherent
inefﬁciency of the join algorithm of Q100 that generates
a large number of intermediate results. While the Q100
performance on the Path3 query is comparable to TrieJax for
most datasets, TrieJax outperforms Q100 by up to 539× on
complex queries such as Clique4. Q100 is also outperformed

by Graphicionado, which is aimed for graph operations and
offer better parallelism and sharing of data than Q100 for
large queries such as Cycle4 and Clique4.

To summarize, TrieJax delivers dramatic speedups over
both software and hardware baselines. Thanks to its internal
design that reduces the number of intermediate results and ,
TrieJax is able to serve most of its data from its fast SRAM
caches and minimizes its DRAM accesses. Finally, TrieJax’s
aggressive use of multithreading allows it to hide the latency
incurred by accessing both internal and external memories.

4.4 Energy efﬁciency

In order to understand the potential energy efﬁciency of
TrieJax, we ﬁrst explore how the accelerator’s energy con-
sumption is distributed among its components.

Figure 15 presents the energy distribution in TrieJax for
the examined queries, averaged over the different datasets.
The ﬁgure clearly shows that the lion’s share of the energy
consumed by TrieJax goes to the memory system and only
a fraction of the energy is consumed by the TrieJax core

10

0.11101001000bitcoinfacebookgnu04gnu31grqcWikibitcoinfacebookgnu04gnu31grqcWikibitcoinfacebookgnu04gnu31grqcWikibitcoinfacebookgnu04gnu31grqcWikibitcoinfacebookgnu04gnu31grqcWikiPath 3Path 4Cycle 3Cycle 4Clique 4Speedup of TrieJax (log)Q100/TrieJaxGraphicionado/TrieJaxEmptyHeaded/TrieJaxCTJ/TrieJax0246810124T8T16T32T64TSpeedup over single-threadedNumber of threads89.26%90.41%80.21%73.80%80.13%0%20%40%60%80%100%Path3Path4Cycle3Cycle4Clique4Energy consumption from totalQueryDRAMLLCL2L1PJR cacheTrieJaxCoreFigure 16: Reduction in energy consumption obtained with TrieJax compared to the baselines.

logic. The dominant memory component is DRAM, which
consumes 74 − 90% of the overall energy. DRAM energy
consumption is attributed to explicit read/write operations
(mostly writing the ﬁnal results to memory) and to implicit
DRAM idle power (predominantly DRAM refresh opera-
tions). The second dominant energy consumer is the L1
cache. Although the cache is read-only and is not involved in
writing the ﬁnal results to memory, it serves the trie traversals
triggered by misses in the partial join results cache. Finally,
the PJR cache is responsible for up to 7.8% of the total energy
consumption for the cycle4 query. Note, however, that for
Cycle3 and Clique4 queries there are no valid intermediate
result caches and it does no use any energy.

We now turn to compare the energy consumption of TrieJax
versus that of the baseline systems. Figure 16 presents the
comparison. Importantly, understanding that DRAM is by far
the main energy consumer in TrieJax enables us to explain its
reduced energy consumption compared to the software and
hardware baselines.

When comparing TrieJax to the software baselines, it is
not surprising to ﬁnd that TrieJax much more energy efﬁcient.
TrieJax is 110× more energy efﬁcient on average than CTJ
and 59× more efﬁcient than EmptyHeaded. This is attributed
to three factors. The ﬁrst factor contributing the TrieJax’s
energy efﬁciency is the reduced energy consumption of its
core logic, which is speciﬁcally designed to execute join
operations and is thus much more energy efﬁcient than a
general-purpose core. This factor is slightly less dominant in
the case of EmptyHeaded (which is almost 2× more efﬁcient
than CTJ), since EmptyHeaded uses efﬁcient CPU SIMD
operations. The second contributing factor is the efﬁcient
TrieJax’s on-die caching of intermediate results and reduced
thrashing of the memory system caches, which dramatically
reduces the energy consumption of its memory system. The
ﬁnal contributing factor is the speedups obtained by TrieJax,
which dramatically reduce the DRAM’s idle energy consump-
tion.

TrieJax is also much more energy efﬁcient than other hard-
ware accelerators. Speciﬁcally, TrieJax consumes, on average,

179× and 15× less energy than Q100 and Graphicionado,
respectively. This improved energy efﬁciency is attributed to
two factors. First, the use of a WCOJ algorithm that reduces
the number of intermediate results and eliminates most of the
expensive DRAM accesses executed by Q100 and Graphi-
cionado. Second, the faster run time of TrieJax dramatically
reduces the idle energy consumption of the DRAM, which is
mostly the result of periodic DRAM refresh operations.

To summarize, we see that the energy efﬁciency of graph
and database hardware accelerators is bounded by their mem-
ory system. Primarily, the number of explicit read/write
operations affects both energy consumption and performance.
But the performance impact of the memory system also in-
creases DRAM’s idle energy consumption. TrieJax’s caching
of internal results thus minimizes its reliance on the mem-
ory system, thereby reducing both its active memory energy
(read/write) and idle DRAM energy (implicit refresh).

5. CONCLUSIONS

We presented TrieJax, an on-chip domain-speciﬁc acceler-
ator for graph operations specializing in graph pattern match-
ing. It is driven by new advances in the database community
and a plethora of new join algorithms that outperform tradi-
tional approaches. TrieJax leverages the inherent concurrency
of the algorithm for parallel execution and latency hiding of
irregular memory accesses. Furthermore, it integrates a spe-
cialized store for intermediate results that can drastically
reduce recurrent computations.

We showed that TrieJax outperforms state-of-the-art graph
analytics and database accelerators by 7 − 63× on average,
while consuming 15 − 179× less energy. TrieJax further
outperforms relational database management systems that
use the modern join algorithms by 9 − 20× and consumes
59 − 110× less energy.

We plan to extend our accelerator to other important graph
operations such as aggregations (e.g., triangle counting), and
use novel algorithmic approaches to offer approximate esti-
mations in a fraction of the time.

11

110100100010000bitcoinfacebookgnu04gnu31grqcwikibitcoinfacebookgnu04gnu31grqcwikibitcoinfacebookgnu04gnu31grqcwikibitcoinfacebookgnu04gnu31grqcwikibitcoinfacebookgnu04gnu31grqcwikiPath3Path4Cycle3Cycle4Clique4Reduction in energy consumption with TrieJax (log)Q100/TrieJaxGraphicionado/TrieJaxEmptyHeaded/TrieJaxCTJ/TrieJax6. REFERENCES
[1] C. R. Aberger, S. Tu, K. Olukotun, and C. Ré, “Emptyheaded: A

relational engine for graph processing,” in Intl. Conf. on Management
of Data (SIGMOD), 2016. [Online]. Available:
http://doi.acm.org/10.1145/2882903.2915213

[2] M. Abo Khamis, H. Q. Ngo, and A. Rudra, “FAQ: Questions asked
frequently,” in ACM Symposium on Principles of Database Systems
(PODS), 2016. [Online]. Available:
http://doi.acm.org/10.1145/2902251.2902280

[3] ARM, “ARM ISA,”

https://developer.arm.com/architectures/instruction-sets.

[4] A. Atserias, M. Grohe, and D. Marx, “Size bounds and query plans for
relational joins,” SIAM J. Comput., vol. 42, no. 4, pp. 1737–1767,
2013.

[5] R. Bordawekar, T. Lahiri, B. Gedik, and C. A. Lang, Eds., ADMS,

2014. [Online]. Available: http://www.adms-conf.org/adms_2014.html

[6] K. Chandrasekar, C. Weis, Y. Li, S. Goossens, M. Jung, O. Naji,

B. Akesson, N. Wehn, and K. Goossens, “DRAMPower: Open-source
DRAM power & energy estimation tool,” http://www.drampower.info,
2012.

[7] J. Clow, G. Tzimpragos, D. Dangwal, S. Guo, J. McMahan, and

T. Sherwood, “A pythonic approach for rapid hardware prototyping
and instrumentation,” in Intl. Conf. on Field Programmable Logic and
Applications (FPL), 2017. [Online]. Available:
https://doi.org/10.23919/FPL.2017.8056860

[8] H. David, E. Gorbatov, U. R. Hanebutte, R. Khanna, and C. Le,

“RAPL: memory power estimation and capping,” in Intl. Symp. on Low
power Electronics and Design (ISLPED), 2010. [Online]. Available:
https://doi.org/10.1145/1840845.1840883

[9] D. J. DeWitt and R. Gerber, Multiprocessor hash-based join

algorithms. University of Wisconsin-Madison, Computer Sciences
Department, 1985.

[10] T. J. Ham, L. Wu, N. Sundaram, N. Satish, and M. Martonosi,

“Graphicionado: A high-performance and energy-efﬁcient accelerator
for graph analytics,” in Intl. Symp. on Microarchitecture (MICRO),
2016. [Online]. Available:
http://dl.acm.org/citation.cfm?id=3195638.3195707

[11] S. Hong, H. Chaﬁ, E. Sedlar, and K. Olukotun, “Green-marl: A dsl for
easy and efﬁcient graph analysis,” in Intl. Conf. on Arch. Support for
Programming Languages & Operating Systems (ASPLOS), 2012.
[Online]. Available: http://doi.acm.org/10.1145/2150976.2151013

[12] HP Labs, “CACTI,” https://www.hpl.hp.com/research/cacti/.

[13] T. Ideker, O. Ozier, B. Schwikowski, and A. F. Siegel, “Discovering
regulatory and signalling circuits in molecular interaction networks,”
in Intl. Conf. on Intelligent Systems for Molecular Biology, 2002.

[14] D. B. Johnson, “Efﬁcient algorithms for shortest paths in sparse
networks,” J. ACM, vol. 24, no. 1, pp. 1–13, Jan. 1977. [Online].
Available: http://doi.acm.org/10.1145/321992.321993

[15] O. Kalinsky, Y. Etsion, and B. Kimelfeld, “Flexible caching in trie
joins,” in Intl. Conf. on Extending Database Technology (EDBT),
2017, pp. 282–293. [Online]. Available:
https://doi.org/10.5441/002/edbt.2017.26

[16] Y. Kim, W. Yang, and O. Mutlu, “Ramulator: A fast and extensible

DRAM simulator,” Computer Architecture Letters, vol. 15, no. 1, pp.
45–49, 2016. [Online]. Available:
https://doi.org/10.1109/LCA.2015.2414456

[17] J. Leskovec and A. Krevl, “SNAP Datasets: Stanford large network
dataset collection,” http://snap.stanford.edu/data, Jun. 2014.

[18] P. Mishra and M. H. Eich, “Join processing in relational databases,”
ACM Computing Surveys (CSUR), vol. 24, no. 1, pp. 63–113, 1992.

[19] A. Mukkara, N. Beckmann, M. Abeydeera, X. Ma, and D. Sánchez,
“Exploiting locality in graph analytics through hardware-accelerated
traversal scheduling,” in Intl. Symp. on Microarchitecture (MICRO),
2018. [Online]. Available:
https://doi.org/10.1109/MICRO.2018.00010

[20] H. Q. Ngo, D. T. Nguyen, C. Ré, and A. Rudra, “Beyond worst-case
analysis for joins with minesweeper,” in PODS, 2014, pp. 234–245.
[Online]. Available: https://doi.org/10.1145/2594538.2594547

[21] H. Q. Ngo, E. Porat, C. Ré, and A. Rudra, “Worst-case optimal join

algorithms: [extended abstract],” in ACM Symposium on Principles of

Database Systems (PODS), 2012. [Online]. Available:
https://doi.org/10.1145/2213556.2213565

[22] H. Q. Ngo, C. Ré, and A. Rudra, “Skew strikes back: New

developments in the theory of join algorithms,” SIGMOD Rec., vol. 42,
no. 4, pp. 5–16, Feb. 2014. [Online]. Available:
http://doi.acm.org/10.1145/2590989.2590991

[23] D. Nguyen, A. Lenharth, and K. Pingali, “A lightweight infrastructure
for graph analytics,” in ACM Symp. on Operating Systems Principles
(SOSP), 2013. [Online]. Available:
http://doi.acm.org/10.1145/2517349.2522739

[24] D. T. Nguyen, M. Aref, M. Bravenboer, G. Kollias, H. Q. Ngo, C. Ré,

and A. Rudra, “Join processing for graph patterns: An old dog with
new tricks,” in 3rd. Intl. Workshop on Graph Data Management
Experiences and Systems (GRADES), 2015. [Online]. Available:
https://doi.org/10.1145/2764947.2764948

[25] E. Nurvitadhi, G. Weisz, Y. Wang, S. Hurkat, M. Nguyen, J. C. Hoe,
J. F. Martínez, and C. Guestrin, “Graphgen: An FPGA framework for
vertex-centric graph computation,” in Intl. Symp. on
Field-Programmable Custom Computing Machines (FCCM), 2014.
[Online]. Available: https://doi.org/10.1109/FCCM.2014.15

[26] L. Page, S. Brin, R. Motwani, and T. Winograd, “The pagerank

citation ranking: Bringing order to the web.” Stanford InfoLab, Tech.
Rep., 1999.

[27] RISC-V, “RISC-V ISA,” https://riscv.org/risc-v-isa/.

[28] S. Sahu, A. Mhedhbi, S. Salihoglu, J. Lin, and M. T. Özsu, “The
ubiquity of large graphs and surprising challenges of graph
processing,” Proc. VLDB Endow., vol. 11, no. 4, pp. 420–431, Dec.
2017. [Online]. Available: https://doi.org/10.1145/3186728.3164139

[29] N. Shadbolt, T. Berners-Lee, and W. Hall, “The semantic web

revisited,” IEEE intelligent systems, vol. 21, no. 3, pp. 96–101, 2006.

[30] M. Stonebraker, D. J. Abadi, A. Batkin, X. Chen, M. Cherniack,

M. Ferreira, E. Lau, A. Lin, S. Madden, E. O’Neil, P. O’Neil,
A. Rasin, N. Tran, and S. Zdonik, “C-store: A column-oriented dbms,”
in Intl. Conf. on Very Large Data Bases (VLDB), 2005. [Online].
Available: http://dl.acm.org/citation.cfm?id=1083592.1083658

[31] N. Sundaram, N. Satish, M. M. A. Patwary, S. R. Dulloor, M. J.

Anderson, S. G. Vadlamudi, D. Das, and P. Dubey, “GraphMat: High
performance graph analytics made productive,” Proc. VLDB Endow.,
vol. 8, no. 11, pp. 1214–1225, Jul. 2015. [Online]. Available:
https://doi.org/10.14778/2809974.2809983

[32] T. L. Veldhuizen, “Triejoin: A simple, worst-case optimal join

algorithm,” in ICDT, 2014, pp. 96–106. [Online]. Available:
https://doi.org/10.5441/002/icdt.2014.13

[33] C. Wilson, B. Boe, A. Sala, K. P. Puttaswamy, and B. Y. Zhao, “User

interactions in social networks and their implications,” in EuroSys,
2009. [Online]. Available:
http://doi.acm.org/10.1145/1519065.1519089

[34] L. Wu, A. Lottarini, T. K. Paine, M. A. Kim, and K. A. Ross, “Q100:
The architecture and design of a database processing unit,” in Intl.
Conf. on Arch. Support for Programming Languages & Operating
Systems (ASPLOS), 2014. [Online]. Available:
http://doi.acm.org/10.1145/2541940.2541961

APPENDIX
A. NUMBER OF INTERMEDIATE RESULTS
The design of our system is based on a WCOJ algorithm.
A key beneﬁt is the reduction of intermediate results being
generated during the computation of graph pattern match-
ing queries. We illustrate the beneﬁt in Figure 18, which
compares the number of intermediate results (log scale) on
a representative set of benchmarks using CTJ (WCOJ al-
gorithm) and a pairwise join algorithm. The pairwise join
algorithm is used in both Q100 and Graphicionado.

On Path4 and Cycle4 queries, CTJ generates on average
18× and 36× fewer intermediate results than the pairwise
join algorithm. While the pairwise join must generate all the
intermediate results, CTJ only generates intermediate results

12

Figure 17: Number of memory accesses (log scale) for each baseline.

that are part of the ﬁnal result in compact caching structure.
Furthermore, CTJ only generates intermediate results that
can later be reused to speedup the join. For example, CTJ
does not generate any intermediate results for the Clique4
queries, because they cannot be reused.

B. MAIN MEMORY ACCESSES

Figure 17 shows the number of main memory accesses
for each baseline on a logarithmic scale. The ﬁgure clearly
shows that the WCOJ algorithms, namely EmptyHeaded and
CTJ, generate fewer accesses to main memory than the tra-
ditional approaches, namely Q100 and Graphicionado. On
average, CTJ generates 2.8× fewer memory accesses than
EmptyHeaded, 47× fewer than Graphicionado, and 105×
fewer than Q100. This matches our motivation for using a
WCOJ-based solution for our system.

Figure 18: Number of intermediate results (log scale) be-
ing generated using CTJ compared to the pairwise join
algorithm used in Q100.

13

1101001,00010,000100,0001,000,00010,000,000100,000,0001,000,000,000bitcoinfacebookgnu04gnu31grqcwikibitcoinfacebookgnu04gnu31grqcwikibitcoinfacebookgnu04gnu31grqcwikibitcoinfacebookgnu04gnu31grqcwikibitcoinfacebookgnu04gnu31grqcwikiPath3Path4Cycle3Cycle4Clique4Main memory accesses (log)Q100GraphicionadoEmptyHeadedCTJ1101001,00010,000100,0001,000,00010,000,000100,000,0001,000,000,000 bitcoingrqcwikibitcoingrqcwikibitcoingrqcwikiPath4Cycle4Clique4Number of intermediate results (log)CTJPairwiseJoin