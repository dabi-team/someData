2
2
0
2

r
a

M
1
3

]

R
C
.
s
c
[

1
v
6
9
7
6
1
.
3
0
2
2
:
v
i
X
r
a

1

Delays have Dangerous Ends: Slow HTTP/2
DoS attacks into the Wild and their Real-Time
Detection using Event Sequence Analysis

Nikhil Tripathi, Member, IEEE

Abstract—The robustness principle, written by Jon Postel in an early version of TCP implementation, states that the communicating
entities should be liberal while accepting the data. Several entities on the Internet do follow this principle. For instance, in this work, we
show that many popular web servers on the Internet are generous as they wait for a substantial time period to receive the remaining
portion of an incomplete web request. Unfortunately, this behavior also makes them vulnerable to a class of cyber attacks, commonly
known as Slow Rate DoS attacks. HTTP/2, the recent version of HTTP, is recently found vulnerable to these attacks. However, the
impact of Slow HTTP/2 DoS attacks on real web servers on the Internet has not been studied yet. Also, to the best of our knowledge,
there is no defense scheme known to detect Slow Rate DoS attacks against HTTP/2 in real-time. To bridge these gaps, we ﬁrst test the
behavior of HTTP/2 supporting web servers on the Internet against Slow HTTP/2 DoS attacks. Subsequently, we propose a scheme to
detect these attacks in real-time. We show that the proposed detection scheme can detect attacks in real-time with high accuracy and
marginal computational overhead.

Index Terms—HTTP/2, Slow Rate DoS attacks, Anomaly detection, DoS

(cid:70)

1 INTRODUCTION

A PPLICATION layer Denial-of-Service (DoS) attacks are a

newer class of DoS attacks that exploit vulnerabilities
present in the application layer protocols such as HTTP,
NTP, DHCP [1], [2], [3]. These attacks target speciﬁc services
(e.g., web, mail, ﬁle transfer) running on a victim computer
with a relatively slighter impact on the network resources
[4], [5]. One famous example of application layer DoS at-
tacks is the Slow Rate DoS attack. Slow Rate DoS attack
requires sending multiple incomplete requests to the victim
server to consume its connection queue space. Once this
ﬁnite space is consumed, the server can not entertain further
incoming requests. A few instances of Slow Rate DoS attacks
have also been encountered in the past [6], [7].

HTTP/1.1 is one of the most studied protocols against
Slow Rate DoS attacks [1], [7]. HTTP/2, the successor
of HTTP/1.1, was launched in May 2015 [8], and our
HTTP/2 usage measurement study (see Section 4) shows
that approximately 71% of the websites serve web con-
tent using HTTP/2. The operational differences between
HTTP/1.1 and HTTP/2 make the Slow Rate DoS attacks
against HTTP/1.1 [1] ineffective against HTTP/2. Likewise,
the defense mechanisms known to counter Slow Rate DoS
attacks against HTTP/1.1 are ineffective in detecting Slow
Rate DoS attacks against HTTP/2. In one of our prior
works [9], we performed the vulnerability assessment of
HTTP/2, and proposed ﬁve new Slow Rate DoS attacks that
are effective against it. However, we tested the attacks in
a controlled lab setup only, and we did not observe the
behavior of real HTTP/2 web servers against them. Thus,
it it is essential to evaluate the effects of Slow HTTP/2 DoS

• N. Tripathi is with the Computer Science & Engineering Group at Indian
Institute of Information Technology, Sri City, Chittoor, India 517646.
E-mail: nikhil.t@iiits.in

attacks on the real web servers deployed on the Internet.
Taking motivation from it, in this work, we test the behavior
of HTTP/2 supporting web servers on the Internet against
Slow HTTP/2 DoS attacks, and showed that several popular
web servers are vulnerable to them1. We also propose a
detection mechanism in this work to proactively detect these
attacks. We make the following speciﬁc contributions in this
paper:

• We perform a comprehensive Internet-wide study by
scanning the top 500K Alexa websites to ﬁnd how
many of them support HTTP/2. Our study shows
that approximately 71% of the top 500K websites
support HTTP/2.

• We test the behavior of HTTP/2 supporting web
servers on the Internet against different Slow
HTTP/2 DoS attacks and show that several of them
are vulnerable to the attacks.

• We propose an event sequence analysis-based detec-
tion scheme to detect Slow HTTP/2 DoS attacks in
real-time.

• We test the detection performance of the proposed
scheme in a real network and show that it can
detect attacks with very high accuracy and marginal
computational overhead.

The rest of the paper is organized as follows. We present
the HTTP/2 overview and the literature review in Sections
2 and 3. In Sections 4 and 5, we then discuss our study to
measure HTTP/2 usage on the Internet and the empirical
evaluation of Slow HTTP/2 DoS attacks, respectively. In
Section 6, we discuss the proposed detection scheme and

1. The empirical evaluation results are also presented in our recent

preliminary work [10].

 
 
 
 
 
 
present the experiments conducted to test the detection
performance of the proposed scheme in Section 7. Finally,
the paper is concluded in Section 8.

2 PRELIMINARIES

This section presents some background knowledge on
HTTP/2 and Slow Rate DoS attacks.

2.1 HTTP/2

HTTP/2 is deﬁned in RFC 7540 [8] and recently became
a standard in May 2015. HTTP/2 operation differs signif-
icantly from its predecessor HTTP/1.1 [11], [12]. HTTP/2
was proposed keeping in mind the inability of HTTP/1.1 to
utilize the TCP’s transmission capacity efﬁciently. HTTP/2
achieves higher efﬁciency by using several virtual con-
nections known as streams over a single TCP connection.
HTTP/2 also mitigates head-of-line blocking of the web re-
quests that persists in HTTP/1.1. HTTP/2 also implements
its own ﬂow control mechanism at the application layer.
It is required to prevent the communicating entities from
overwhelming each other by sending data simultaneously
through multiple streams over a single TCP connection.
HTTP/2 also involves using different types of frames for
different purposes [8]. For example, HTTP/2 HEADERS and
CONTINUATION frames are used to transmit the header
part of the web request, while HTTP/2 DATA frames are
used to transmit the message body (e.g., HTML code of a
web page). HTTP/2 SETTINGS frames are used to negotiate
connection parameters, and HTTP/2 GOAWAY frames are
used to close the connection. HTTP/2 WINDOW UPDATE
frame indicates the size of data (in bytes) that the sender can
accept from the receiver in addition to the current window
size. These frames are carried inside the TCP payload and
should not be confused with the link-layer frames. Inter-
ested readers are requested to refer to RFC 7540 [8] for the
list of HTTP/2 frames and their usage.

2.2 Slow Rate DoS Attacks

Slow Rate DoS attacks [13] require sending multiple spe-
cially crafted incomplete requests to a victim server. On
receiving such requests, the server stores them in its con-
nection queue space and waits for a time duration T (pre-
deﬁned in the conﬁguration ﬁle) in the hope of receiving
the remaining portions of the web request. However, the
attacker never sends the remaining portion of the complete
requests. To consume the server’s connection queue space,
the attacker establishes enough connections, and from each
connection, it sends incomplete requests. Once the connec-
tion queue space is consumed, the server can not entertain
further incoming requests, resulting in DoS scenario. It is not
a good approach to mitigate these attacks by terminating
the TCP connections with a connection duration greater
than a predeﬁned threshold. This is because incomplete
requests are not uncommon on the Internet [1], [9], and such
an approach may also terminate the connections from the
benign clients with poor TCP connection quality. Examples
of such clients are remote clients with high latency and
clients on low-grade cellular or satellite networks.

2

3 RELATED WORKS
Several works in the literature discuss DoS/DDoS attacks
against HTTP/1.1 and the defense mechanisms to counter
those attacks [7], [13], [14]. However, the same does not hold
true for its successor, HTTP/2. Since HTTP/2 is a recently
standardized protocol, only a few works discuss possible
attacks against HTTP/2 and the defense mechanisms to
counter them [7]. Moreover, since HTTP/2 operation differs
signiﬁcantly from HTTP/1.1 [11], [12], the existing tech-
niques to detect Slow Rate DoS attacks against HTTP/1.1
[1], [15], [16], [17], [18] are ineffective in detecting Slow
Rate DoS attacks against HTTP/2. As a result, researchers
in the security community recently proposed a few defense
approaches to detect Slow HTTP/2 DoS attacks. This section
ﬁrst mentions DoS/DDoS attacks known against HTTP/2
and, subsequently, the defense mechanisms to counter them.

3.1 DoS/DDoS attacks against HTTP/2

Imperva [19] disclosed some implementation vulnerabilities
in HTTP/2, which can be exploited for creating situations
such as Blue Screen of Death and arbitrary code execution
at the client side. However, these vulnerabilities existed in
the protocol implementations but not in the protocol itself.
Post the vulnerability exposure; the affected implementa-
tions were patched to mitigate these vulnerabilities. Beckett
and Sezer [11], [12] studied how HTTP/2 functionalities
can be exploited to launch ﬂood and ampliﬁcation-based
DDoS attacks. Adi et al. [20] tested how the HTTP/2 web
servers behave if control frame ﬂooding is launched against
them. Praseed and Thilagam [21], [22] demonstrated that the
request multiplexing feature of HTTP/2 can be exploited
to launch asymmetric DDoS attacks on the web servers.
In particular, the attacker sends high workload web re-
quests resulting in heavy computational overhead at the
web server. The multiplexed asymmetric attack may result
in either partial DoS, also known as Reduction-of-Quality
(RoQ), or a complete DoS scenario. The attacks discussed in
these works are distributed in fashion and, thus, typically
fall under the Distributed Denial-of-Service (DDoS) cate-
gory [7]. Since these attacks require sending a large number
of web requests to the server to render it unusable, they are
relatively difﬁcult to launch and easier to detect [23].

Unlike traditional DDoS attacks, Slow HTTP/2 DoS
attacks [9] need small computational power for their ex-
ecution at the attacker’s side. They involve sending very
few requests to the web server to prevent it from serving
benign clients [7], [23]. Since these attacks generate a smaller
amount of trafﬁc, they are stealthier and, thus, difﬁcult to
detect as compared to traditional DDoS attacks [7], [13], [23].
Taking motivation from this, we restrict our focus only to
Slow HTTP/2 DoS attacks in this paper.

Based on the HTTP/2 frame parameters that are altered,
there can be different variants of Slow HTTP/2 DoS attacks.
Interested readers are requested to refer to our previous
work [9] for a detailed working of these attacks. For com-
pleteness, we present a summary of these attacks below:

3.1.1 Advertising Zero Window Size (Attack-1)
In this attack, the attacker sends an HTTP/2 SETTINGS
frame to the server to inform that it does not have any win-
dow space available to receive the data. The server does not

3.1.2 Incomplete POST Request Message Body (Attack-2)

Tripathi and Hubballi [9]

send any data back to the attacker on receiving this frame
unless it receives an HTTP/2 WINDOW UPDATE frame
from the attacker. However, the attacker never sends the
required WINDOW UPDATE frame to the server forcing
the latter to wait.

HTTP/2 uses DATA frames to carry the message body of
a web request (e.g., values in an HTML form). A DATA
frame deﬁnes an END STREAM ﬂag. This ﬂag, when set,
indicates that the frame carries the entire message body and
will not be followed by any other DATA frame. However, to
launch this attack, the attacker sends a DATA frame having
END STREAM ﬂag reset. On receiving this frame, the server
waits to receive more DATA frames such that the last DATA
frame must have the END STREAM ﬂag set. However, the
attacker never sends the subsequent DATA frames, forcing
the web server to wait for the complete message body.

3.1.3 Sending Connection Preface Only (Attack-3)

Connection preface is used to inform a web server that
HTTP/2 will be used for further communication. The at-
tacker only sends the connection preface to launch this
attack and does not send any subsequent HTTP/2 frames.
On receiving the connection preface only, the server waits
to receive further HTTP/2 frames belonging to the web
request.

3.1.4 Incomplete GET/POST Request Header (Attack-4)

HTTP/2 HEADERS frames carry the header part of the web
requests. If the header is large enough not to ﬁt in a single
HEADERS frame, it is split into smaller parts such that the
ﬁrst header part is sent into the HEADERS frame, while the
remaining parts are sent into the CONTINUATION frames.
A HEADERS frame deﬁnes an END HEADERS ﬂag. This
ﬂag, when set, indicates that the HEADERS frame carries
the entire header, and any CONTINUATION frame will not
follow it. However, to launch this attack, the attacker sends
a HEADERS frame having the END HEADERS ﬂag reset.
On receiving this frame, the server waits to receive CON-
TINUATION frames such that the last CONTINUATION
frame must have the END HEADERS ﬂag set. However,
the attacker never sends the subsequent CONTINUATION
frames, forcing the web server to wait for the complete
header.

3.1.5 Unacknowledged SETTINGS frame (Attack-5)

On receiving an HTTP/2 SETTINGS frame, a recipient
(client/server) must acknowledge it by sending an empty
SETTINGS frame back to the sender. The attacker does
not acknowledge an HTTP/2 SETTINGS frame sent by the
server to launch this attack. As a result, the web server keeps
waiting to receive the SETTINGS frame acknowledgment.

3.2 Known Defense Mechanisms

Several works in the literature discuss defense strategies to
counter attacks against HTTP/1.1. However, those strategies
can not detect attacks against HTTP/2 due to the several
operational differences between HTTP/1.1 and HTTP/2
[11], [12]. Moreover, since HTTP/2 is a newly standardized

TABLE 1: Comparison with prior works

3

References

Adi et al. [20]

Empirical
Evaluation
Slow
DoS
(cid:55)

of
HTTP/2

Praseed and Thilagam [21]

Praseed and Thilagam [22]

Beckett and Sezer [11]

Beckett and Sezer [12]

Praseed and Thilagam [24]

Tripathi and Shaji [10]
This paper

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:51)

(cid:51)

Detection
of
Slow
HTTP/2 DoS

(cid:55)
(cid:51)(only
ofﬂine)
(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:51)

protocol, only a few existing works focused on HTTP/2
security. In one of our previous works [9], we proposed
an ofﬂine anomaly detection scheme to detect if a web
server received incomplete web requests in a particular time
interval. However, the detection scheme could detect if the
interval contains attack trafﬁc only after it is elapsed. Thus,
it could not detect the attacks in real-time. In another work,
Praseed and Thilagam [24] proposed an approach to model
an HTTP/2 request set as a fuzzy multiset and subsequently
assign a trust score to distinguish between valid and invalid
request sets. This approach could detect the multiplexed
asymmetric DDoS attack with decent accuracy. However, it
was not designed to detect Slow HTTP/2 DoS attacks.

3.3 Empirical Evaluation of Slow HTTP/2 DoS Attacks

In our recent preliminary work [10], we tested the behavior
of HTTP/2 supporting web servers on the Internet against
Slow HTTP/2 DoS attacks. We showed that several popular
web servers are vulnerable to these attacks. However, we
did not present any defense approach in that work which
can be deployed to counter Slow HTTP/2 DoS attacks.

Table 1 brieﬂy summarizes how our work differs from

the prior works related to HTTP/2 security.

4 MEASURING HTTP/2 USAGE ON THE INTERNET
In September 2021, we conducted a comprehensive study
to measure HTTP/2 usage on the Internet. We took into
account the top 500,000 Alexa domains in this study and
tested if they support HTTP/2. For this purpose, we wrote
a python script that communicates with the web server of
each domain in the Alexa list. In particular, the python
script sends a ‘Client Hello’ message to the web server as
part of the standard TLS handshake. Through this message,
the script informs the web server about the application
protocols that it supports. Examples of these application
protocols are HTTP/2 over TLS (known as h2), HTTP/2
over cleartext (known as h2c), and HTTP/1.1. In response,
the server also sends a ‘Server Hello’ message to the script,
thereby informing about the application protocols that it
supports.

We conducted this measurement study into four iter-
ations. In the ﬁrst iteration, we collected HTTP/2 usage
statistics by performing TLS handshakes with the web

servers of the top 500K domains in the Alexa list. In this
iteration, we received responses from 445315 web servers,
out of which 335854 web servers were found to support
HTTP/2. Moreover, 109461 web servers were found to
support HTTP/1.1. The remaining 54685 web servers did
not respond in the ﬁrst iteration for two reasons. First, the
TCP connections were timed out as there was no response
from some web servers. Second, the authoritative name
servers for some of the domains have an A record for the
hostname www only. For example, the authoritative name
servers for a domain, say, iiits.ac.in have the record
www.iiits.ac.in A 103.21.58.130, but they do not
have the record iiits.ac.in A 103.21.58.130. Thus,
the web server 103.21.58.130 is reachable only when a
web request is sent to the Fully Qualiﬁed Domain Name
(FQDN) www.iiits.ac.in. We also observed that many
domains support HTTP/1.1, but they serve web content
over HTTP/2 if a user visits the FQDN www.<domain> as
the web server mapped to the FQDN www.<domain> sup-
ports HTTP/2, while the web server mapped to <domain>
supports HTTP/1.1 only. The result of the ﬁrst iteration
measurement is shown in Table 2.

In the second iteration, we appended the www keyword
to all those domains (=164146) whose web servers either
supported HTTP/1.1 (=109461) or did not respond (=54685)
in the ﬁrst iteration. This provided us FQDNs of the for-
mat www.<domain>. Subsequently, we collected HTTP/2
usage statistics by performing TLS handshakes with the web
servers corresponding to these FQDNs. The result of the
second iteration measurement is shown in Table 2. It can be
noticed from the table that 17220 more HTTP/2 supporting
domains were found in the second iteration. Also, the num-
ber of domains that either supported HTTP/1.1 (=101841)
or were unresponsive (=45085) was decreased in the second
iteration.

The popular web clients such as Chrome, Firefox, and
Safari support h2 only; however, the debugging and bench-
marking tools such as curl and h2load support h2 as well
as h2c. Thus, popular server-side implementations such as
Apache simultaneously support both h2c and h2 conﬁgura-
tions to avoid compatibility issues. In the ﬁrst and second
iterations, we measured the usage of h2 on the Internet
using the HTTPS scheme. In the third iteration, we measured
the usage of h2c on the Internet using the HTTP scheme.
We checked the HTTP/2 support only for those domains
which either supported HTTP/1.1 or did not respond in
the second iteration. To measure the h2c usage statistics,
our script sends a cleartext HTTP/2 web request to a web
server after the 3-way TCP handshake and subsequently
checks if the response from the web server is an HTTP/2
response. The result of the third iteration measurement is
shown in Table 2. It can be noticed from the table that
no response was received for 144135 domains. Thus, in
the fourth iteration, we appended the www keyword to the
unresponsive domains in the third iteration and obtained
FQDNs of the format www.<domain>. Subsequently, we
collected HTTP/2 statistics by sending cleartext HTTP/2
web requests to the web servers corresponding to these
FQDNs. The result of the fourth iteration measurement is
shown in Table 2. It can be noticed from the table that the
web servers corresponding to 356417 (sum of the numbers

4

Fig. 1: Testbed setup

shown in bold fonts in Table 2) domains were found to
support HTTP/2.

5 EMPIRICAL EVALUATION OF THE ATTACKS

This section presents an empirical evaluation of Slow
HTTP/2 DoS attacks. We created a testbed setup for this
evaluation, as shown in Figure 1.

5.1 Testbed Setup

Our testbed had four entities - 1) an attacker machine, 2)
a transparent forward proxy, 3) an interceptor, and 4) the
target web server.
Attacker: We designated a computer as the attacker machine
and executed on it the attack scripts written in Python.
These attack scripts sent the web servers exactly one incom-
plete HTTP/2 request of each attack (Attack-1 to 5) type.
We sent only one incomplete request to observe the servers’
behavior, and we did not intend to launch the attacks
against the servers by sending multiple attack requests.
Transparent Forward Proxy: As discussed in the previous
section, most of the web servers on the Internet support
HTTP/2 over TLS (h2). Thus, to intercept and monitor
otherwise encrypted HTTPS trafﬁc, we conﬁgured a trans-
parent forward proxy [25] in front of the attacker machine
such that the proxy connects to the web servers on behalf
of the attacker. The proxy takes cleartext HTTP/2 requests
from the attacker as input and establishes TLS connections2
with the web server of the domain present in the HOST
ﬁeld of the HTTP/2 requests. Subsequently, it forwards
the encrypted web request to the server. On receiving the
encrypted HTTP/2 response from the server, the proxy
decrypts the response and forwards it to the attacker. It also
replays the cleartext HTTP/2 trafﬁc from the web server and
the attacker to the interceptor, as shown in Figure 1. Before
replaying the trafﬁc to the interceptor, the proxy modiﬁes
the IP addresses appropriately such that the ultimate end-
points of the trafﬁc become the web server and the attacker.
The proxy uses the PCAP-OVER-IP method to replay the
trafﬁc to the interceptor on a designated port 57012. In this
way, we intercepted the cleartext HTTP/2 trafﬁc so that it
could be analyzed later.
Interceptor: We designated a computer as the interceptor

2. The TLS connections are established only with h2 servers. In the
case of h2c servers, the proxy simply forwarded the cleartext requests.

InternetAttackerInterceptorProxyWeb serverClear-text request sent to the forward proxy.Clear-text request replayed to the interceptor.Encrypted request forwarded to the web server.Encrypted response sent to the forward proxy.Decrypted response replayed to the interceptor as well as forwarded to the attacker.TABLE 2: HTTP usage statistics. h2: HTTP/2 over TLS, h2c: HTTP/2 over cleartext, http/1.1: HTTP/1.1, NA: Not
Applicable

5

1st
iteration
(https://<domain>)
335854
NA
109461

2nd
iteration
(https://www.<domain>)
017220
NA
101841

3rd
iteration
(http://<domain>)
NA
002791
000000

4th
iteration
(http://www.<domain>)
NA
000552
000000

h2
h2c
http/1.1

Responded

Not responded

Total

054685

500000

045085

164146

144135

146926

143583

144135

wait for a particular time duration, it is more effective than
attack-3. The other similar inferences can also be drawn
from the graph shown in Figure 2.

6 PROPOSED DETECTION SCHEME

An HTTP/2 request involves exchanging different types of
HTTP/2 frames, as discussed in Section 2.1. If we treat
the exchange of these frames as unique events that occur
one after the other, we can obtain an event sequence that
is possible during the interaction between a client and an
HTTP/2 server. Since the frames exchanged during the
HTTP/2 request depend upon various parameters such as
the user’s browsing behavior and available window size at
the receiver, several distinct event sequences are possible.
All possible normal event sequences can be stored into
a database of characteristic normal patterns (observed se-
quences of exchanged HTTP/2 frames) and subsequently be
used to detect anomalous sequences. An HTTP/2 request is
considered as attack request if the event sequence generated
corresponding to it does not exist in the normal database
and vice versa. However, simply checking the non-existence
of an event sequence in the database to detect attack re-
quests may result in several false positives. This is because
there can be many possible unique event sequences (see Sec-
tion 7.1.1), and maintaining a database of all the sequences
to capture the complete normal behavior of HTTP/2 would
be a tedious task.

To avoid this issue, we maintain a database of pos-
sible lookahead pairs extracted from the possible event
sequences. Later in Section7.1.1, we show that the database
of possible lookahead pairs can capture the normal behav-
ior of HTTP/2 with more completeness than the database
of possible event sequences. Once we obtain the normal
database of lookahead pairs during the learning phase, we
assign a mismatch score to an event sequence during the
detection phase based on the number of lookahead pairs
extracted from it that do not exist in the normal database.
The event sequence is declared anomalous (and thus, the
request from which it is generated, is declared as attack
request) only when its mismatch score exceeds a predeﬁned
threshold value.

6.1 Learning Phase

During the learning phase, our detection scheme builds a
normal database of lookahead pairs extracted from the pos-
sible event sequences and a database of maximum normal
delay possible between the occurrences of two consecutive
events. Algorithm 1 describes the procedure for generating

Fig. 2: CDF plot of the waiting time of top 500K Alexa web-
sites. Please refer to the color version for better illustration.

that intercepted the cleartext HTTP/2 trafﬁc replayed by the
proxy. The interceptor machine captured the inbound trafﬁc
to port 57012 using tcpdump and stored it in a pcap ﬁle.
Target Web Server: The target web server belongs to the
356417 HTTP/2 supporting web servers that we found on
the Internet.

5.2 HTTP/2 Trafﬁc Analysis

The captured HTTP/2 trafﬁc at the interceptor was analyzed
to compute the connection waiting time for different target
web servers. For each ﬂow3 in the pcap ﬁle, we calculated
the time difference between the connection establishment
(3-way handshake) and its termination (FIN-ACK packet
exchange). In this way, we obtained the time the web server
waited before closing the connection from which an incom-
plete request was sent. A CDF plot of the duration for which
different web servers wait in case of each attack is shown in
Figure 2. We can notice from the ﬁgure that approximately
3% of the web servers waited for more than 360 seconds
before closing a connection from which an attack-3 type web
request was sent. However, approximately 50% of the web
servers were found to wait for the same duration before
closing the connection from which an attack-1 type web
request was sent. Since attack-1 can make more web servers

3. We differentiated the TCP ﬂows using four parameters - source IP,

source port, destination IP, and destination port.

Algorithm 1 Learning Phase

TABLE 3: HTTP/2 frames and translated events

6

seq=‘Start → ∗’;
for f rame in f low do

e=f rame.translateT oEvent();
seq+=‘→ e → ∗’;

end for
seq+=‘→ End’;
l=seq.extractLookaheadP airs()
Dlookahead.append(l)
events = seq.extractEvents();
while i <= len(events) − 1 do

Input: F - Clear-text HTTP/2 ﬂows; n - Window size
Output: Dlookahead, Ddelay
1: Dlookahead={}; Ddelay={}; i=1;
2: for f low in F do
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21: end for
22: return (Dlookahead, Ddelay);

delay=events[i].time()-events[i − 1].time();
str=‘events[i-1] → events[i]’;
if str not in Ddelay then Ddelay[str]=delay;
else

Ddelay[str]=max(delay, Ddelay[str]);

end if
i+=1;
end while

these databases during the learning phase. Below we discuss
the procedure for generating these databases in detail.

6.1.1 Bulding the lookahead pairs database (Dlookahead)

During the learning phase, we ﬁrst collect normal HTTP/2
trafﬁc and subsequently construct individual TCP ﬂows by
combining TCP payloads of all the packets exchanged after
the connection establishment and before the connection ter-
mination. Once ﬂows are constructed, they are parsed using
Deep Packet Inspection (DPI) to spot HTTP/2 frames. These
frames are then translated into events, as shown in Table 3.
After translating the HTTP/2 frames into the corresponding
events, we append the events one after the another to gen-
erate an event sequence. For the event sequence generation,
we consider a TCP connection’s 3-way handshake as the
beginning of the ﬂow (represented by event Start) and the
connection termination (represented by event End) as the
end of the ﬂow. One sample event sequence for a TCP ﬂow
IPA:portA ↔ IPB:portB carrying an HTTP/2 request is
as follows:

Start → ∗ → P ref → ∗ → M ax Con Strm!0 →
Ini W in Size!0 → ∗ → win size incr!0

In this sequence, ‘∗’ event corresponds to the end of an
HTTP2 frame, while ’→’ is not an event and only represents
a transition from one event to another.

Once an event sequence is generated, the lookahead
pairs are extracted from it and stored in Dlookahead. For
this, we slide a window of size n + 1 across the event
sequence and capture which events follow which within the
sliding window. For example, if we consider n = 3 and the
following event sequence:

Frame

3-way handshake

Event
Start

Connection preface
DATA frame with End Stream (ES) reset Data f rame !ES
Data f rame ES
DATA frame with ES set

P ref

HEADERS frame with ES and End
Header (EH) reset

HEADERS frame with ES reset and EH
set

HEADERS frame with ES and End
Header (EH) set

Hdr f rame !(ESEH)

Hdr f rame !ES EH

Hdr f rame (ESEH)

Acknowledgement to SETTINGS frame

Settings ACK

SETTINGS frame with non-zero length

Settings U N ACK

SETTINGS frame having initial window
size=0

SETTINGS frame having initial window
size!0

SETTINGS frame having maximum
concurrent stream!0

SETTINGS frame having maximum
concurrent stream=0

WINDOW frame with increment
window size!0

WINDOW frame with increment
window size=0

in

in

GOAWAY frame

CONTINUATION frame

Connection termination

Ini W in Size = 0

Ini W in Size!0

M ax Con Strm!0

M ax Con Strm = 0

win size incr!0

win size incr = 0

GOAW AY

CON T IN U AT ION

End

TABLE 4: Lookahead pairs for w1

Start

∗

Index-1
∗

-2
M ax Con
Strm!0

-3
Ini W in Size
!0

M ax Con
Strm!0

Ini W in Size
!0

M ax Con
Strm!0

Ini W in Size
!0

Start → ∗ → M ax Con Strm!0 →
Ini W in Size!0 → ∗ → win size incr!0 → ∗ →
P ref

For each event, we capture the event that comes after
it at spot 1, spot 2, and so on, up to spot n, as we slide
the window across the above event sequence. For the ﬁrst
window w1, from index 1 (*) to index 3 (Ini Win Size!0) in
the sequence, we obtain the database having six lookahead
pairs as shown in Table 4.

Similarly, after sliding the window across the complete
event sequence, we obtain the lookahead pairs as shown
in Table 5. A lookahead pair is stored in the database in
the form of ‘event[i] : event[j], k’ where k ≤ n (window
size) and corresponds to the distance between the ith and
jth events in a sequence. Once the database of lookahead
pairs (Dlookahead) is built, our detection scheme refers to it
to assign anomaly scores to the event sequences generated
from incoming HTTP/2 requests during detection phase.

TABLE 5: Lookahead pairs extracted from the complete
event sequence

7

-2
M ax Con
Strm!0

Ini W in Size
!0 ; ∗

-3
Ini W in Size
!0
∗ ; P ref

Algorithm 2 Detection Phase

Input: Dlookahead; Ddelay; n - Window size; - Mismatch

score maximum threshold

Input: F - Incoming TCP ﬂow
Output: D - Declare sequence as anomalous or normal

Start

∗

M ax Con
Strm!0

Index-1
∗

M ax Con
Strm!0
;
win size incr
!0 ; P ref
Ini W in Size
!0

∗

win size incr
!0

Ini W in Size
!0

∗

win size incr
!0

∗

6.1.2 Bulding the maximum delay database (Ddelay)
The proposed detection scheme also maintains a database,
Ddelay, of the maximum normal delay possible between the
occurrences of two consecutive events, A and B. This is
essential to detect the determined attackers who send the
benign HTTP/2 frames to the server but with a prolonged
delay between them to launch the Slow Rate DoS attacks.
An entry in the maximum delay database is stored in the
form ‘event[i] → event[i + 1] = d’ where d is the maximum
delay between the ith and (i + 1)th events in a sequence.

6.2 Detection Phase

Algorithm 2 describes the procedure for detecting an
anomalous event sequence during the detection phase. We
use different threads for executing the functions responsible
for snifﬁng the incoming packets and extracting events from
them, checking timeouts between the events, and assigning
anomaly scores to the sequences. However, for brevity, we
omit these details in Algorithm 2. The proposed scheme
generates an event sequence seq for each incoming HTTP/2
request during the detection phase using the method dis-
cussed in Section 6.1.1. During this phase, the scheme also
inserts a ‘timeout string’ after an event in seq if a time du-
ration t passes after the occurrence of such that t is greater
than the maximum delay possible between the occurrence
of and any other event that can occur immediately after .
The maximum possible delay value is retrieved from Ddelay
database generated during the learning phase, as discussed
in Section 6.1.2.

Once the length of seq exceeds the window size n, we
start extracting lookahead pairs from seq. Subsequently, we
test for the presence or absence of the extracted lookahead
pairs in Dlookahead to assign the mismatch score to seq.

6.2.1 Assigning Mismatch Scores

Consider an example where the database contains the en-
tries as shown in Table 5, and we generate the following
event sequence from an HTTP/2 request at a particular time
instance ti:

Start → ∗ → M ax Con Strm!0 → ∗ →
Ini W in Size!0 → ∗ → win size incr!0 → ∗ →
P ref
For n=3, the lookahead pairs extracted from this event
sequence are shown in Table 6. Since the lookahead pairs
shown in red in Table 6 do not exist in Table 5, these are

1: seq = ‘’;
2: while True do
3:
4:
5:
6:
7:
8:
9:
10:

Continuously sniff packets belonging to F ;
for f rame in F do

e=f rame.translateT oEvent();
seq+=‘→ e → ∗’;

end for
events=seq.extractEvents();
last event=events[−1];
max delay = max(Ddelay[‘last event → E (cid:48)]) where

11:

12:
13:
14:
15:
16:
17:
18:
19:
20:

21:
22:

E belongs to set of all possible events;

if

>
(current.time()-last event.time())
max delay then seq+=‘→ T Oi → ∗’ where i = 1, 2, ...;

end if
mismatch=0;
if len(events) > n then

l=seq.extractLookaheadP airs();
for pair in l do

if pair not in Dlookahead then mismatch+=1;
end if

end for
mismatch=mismatch/(n ∗ (len(events) − (n +

1)/2));

if mismatch > then seq is anomalous;
else if mismatch < and events[−1]==‘End’

then

seq is normal;

23:
24:
end if
25:
26: end while

end if

TABLE 6: Lookahead pairs extracted from the test sequence

Start

∗

M ax Con
Strm!0

Index-1
∗

;

M ax Con
Strm!0
Ini W in Size
!0
;
win size incr
!0 ; P ref
∗

Ini W in Size
!0

win size incr
!0

∗

∗

-2
M ax Con
Strm!0

∗

-3
∗

Ini W in Size
!0
;
win size incr
!0 ; P ref

Ini W in Size
!0

win size incr
!0

∗

∗

P ref

8

approximately 5 GB HTTP/2 trafﬁc between October 8th,
2021, to October 14th, 2021.
User: The users in our testbed were the students of our
institute who accessed the web server to complete their
assignments. They were asked to use the latest HTTP/2
supporting web browsers. We also practiced a few non-
technical formalities to ensure that the students could not
send any malicious trafﬁc to poison the collected trafﬁc.
Reverse TLS Proxy: We conﬁgured a reverse TLS proxy
application called PolarProxy [25] in front of the web server.
This proxy was owned by the website administration and
was responsible for the tasks shown in Figure 3.
Interceptor: We designated a computer as the interceptor
that intercepted the cleartext HTTP/2 trafﬁc replayed by the
proxy. The interceptor machine captured the inbound trafﬁc
to port 57012 using tcpdump.

7.1.1 Capturing the normal behavior of HTTP/2

It is essential to decide what size of the database should be
built to capture the normal behavior of HTTP/2. For this
purpose, we collected 14094 HTTP/2 ﬂows, and for each
ﬂow, we generated an event sequence. It resulted in 7221
unique event sequences. We also extracted the lookahead
pairs from the unique event sequences and obtained 227,
377, 471, 621, and 737 unique lookahead pairs for window
size (n)=3, 4, 5, 6, and 7, respectively. The plots in Figures
4a and 4b show how the number of unique event sequences
and lookahead pairs increases as we increase the number
of HTTP/2 ﬂows. We can notice from Figure 4a that the
number of new event sequences kept increasing with the
increase in the number of ﬂows. Thus, it is not easy to
estimate how much HTTP/2 trafﬁc should be collected
beforehand to obtain the unique event sequences possible
in the case of HTTP/2 interactions.

On the contrary, as can be noticed from Figure 4b,
virtually no new lookahead pairs were witnessed beyond
a point (approximately 9400 ﬂows). Thus, we could assume
that the database of lookahead pairs captured the virtually
complete normal behavior of HTTP2 at . From this study,
we can also establish that a database of lookahead pairs
could capture the normal behavior of HTTP/2 with more
completeness than a database of unique event sequences.

7.2 Detection Phase

During the detection phase, we extended the setup shown
in Figure 3 by including one more entity and designating it
as the attacker. The attacker machine was connected to the
Internet and was responsible for sending the web server a
small number of attack (Attack-1 to 5) requests at regular
intervals. Moreover, the attacker terminated a connection4
from which an attack request was sent as soon as 100
seconds progressed after the connection establishment. This
was to ensure that such attack requests did not deplete
the server’s connection queue space. Closing these connec-
tions deliberately after 100 seconds did not alter the event
sequences generated from the attack requests because our
detection scheme could classify such requests as attack or
benign way before the aforementioned 100 seconds (see

4. A connection was terminated using FIN-ACK TCP packet.

Fig. 3: Testbed setup for the experiments

counted as mismatches. Subsequently, the mismatch score of
the event sequence is computed as the ratio of the mismatch
counts to the total possible mismatch counts. For instance, if
we consider an event sequence of length L and a lookahead
(window size) of n, the maximum pairwise mismatch count
is given by

n(L−n)+(n−1)+(n−2)+...+1 = n(L−(n+1)/2)
Thus, in the example discussed earlier, the mismatch score
of the sequence is 7/21(= 0.33). The mismatch score of
the event sequence is computed after every new event
appended to the event sequence. It will be continued unless
either of the following two conditions is met:
1. The mismatch score of the sequence exceeds the prede-
ﬁned threshold. In this case, the corresponding HTTP/2
request from which the sequence is being generated will
be treated as attack request.
2. The End event is appended to the event sequence.
After appending the End event, if the mismatch score of
the sequence is less than the predeﬁned threshold, the
corresponding HTTP/2 request will be treated as benign.
However, if the score exceeds the threshold, the request will
be treated as attack request.

7 EXPERIMENTS
7.1 Learning Phase

There are no publicly available dataset
for clear-text
HTTP/2 trafﬁc (h2c) [24]. Thus, we created a testbed similar
to the one shown in Figure 3 to capture clear-text normal
HTTP/2 trafﬁc during the learning phase and subsequently
used it to build the lookahead pairs, and maximum delay
databases:
Web Server: The web server was running Ubuntu 20.04
LTS operating system and conﬁgured with Apache 2.4.51
to handle web requests. It had Intel Xeon E3 processor and
64 GB of physical memory. The web server was one of
the academic servers of our institution, and it was hosting
quiz assignments. The students were asked to attempt the
assignments online for their academic grading. During the
COVID-19 pandemic, the students visited the website from
separate locations, and thus, the collected HTTP/2 trafﬁc
exhibited the property of real Internet behavior. We collected

InternetInterceptorReverse TLS ProxyWeb serverUser1User2User nUsers at different geographical locationsHTTP/2-over-TLS request sent to the reverse TLS proxy.Request decrypted and replayed to the interceptor.Request re-encrypted and forwarded to the web server.Encrypted response sent to the forward proxy.Response decrypted and replayed to the interceptor.Response re-encrypted and forwarded to the concerned user.9

(a) Number of possible unique event sequences

(b) Number of possible lookahead pairs for different values of n

Fig. 4: Capturing normal HTTP/2 behavior. Please refer to
the color version for better illustration.

Section 7.2.3). The benign requests were also generated
during the detection phase while the students attempted
their assignments.

The reverse TLS proxy in our testbed captured the be-
nign and attack HTTP/2 requests generated by the students
and the attacker, respectively, and forwarded their clear-text
versions to the interceptor. Our detection scheme running
on the interceptor then generated event sequences from
the requests and subsequently classiﬁed them as normal
or anomalous depending on their mismatch scores. We
conducted this experiment into ﬁve different time intervals
such that the window size n was ﬁxed, but the mismatch
score threshold was varied across the intervals. In this way,
we could analyze the effect of varying on the detection per-
formance of the scheme. We used four metrics to evaluate
the detection performance - Accuracy, False Positive Rate
(FPR), Recall, and Precision. The detection performance of
the scheme in terms of these four metrics is shown in Table

Fig. 5: CDF plot of the mismatch scores of normal and
anomalous sequences for n=5. Please refer to the color
version for better illustration.

7. We can notice from the table that Accuracy and P recision
slightly increased as we increased to 0.02 from 0.01. It
was because of the reduced number of F P cases (a normal
sequence incorrectly classiﬁed as an anomalous sequence)
and the increased number of T N cases. Due to the same
reason, F P R decreased as we increased to 0.02 from 0.01.
However, as we further increased , Accuracy decreased
because of more F N cases (an anomalous sequence incor-
rectly classiﬁed as a normal sequence). Moreover, Recall
and Accuracy decreased drastically as we increased to 0.03
from 0.02. It was because the anomalous sequences with a
mismatch score in the range [0.02, 0.03] were considered as
normal resulting in a large number of F N cases. Due to
these misclassiﬁcations, we obtained lower detection accu-
racy. The same holds true as we further increased the value
of .

7.2.1 Mismatch scores of normal and anomalous event
sequences

It can be noticed from Figure 5 that the number of anoma-
lous sequences with a mismatch score in the range [0, 0.02] is
almost the same across this range, and the mismatch scores
of virtually all normal sequences laid in the range [0, 0.01].
Thus, to minimize the number of F P without any signiﬁ-
cant increase in F N , the mismatch score threshold should
be chosen in the range [0.01, 0.02]. As we increase beyond
0.02, the number of F N would start increasing signiﬁcantly
without any substantial reduction in the number of F P due
to which the detection performance would degrade. Thus,
choosing in the range [0.01, 0.02] would result in the best
detection performance of the scheme, as also apparent from
Table 7.

7.2.2 Detection performance v/s different values of n
To analyze the effect of varying the window size n on
the detection performance of the scheme, we experimented
with four more time intervals of 8 hours each such that

TABLE 7: Detection performance

10

Interval

# of Flows
Benign Attack

1st
2nd
3rd
4th
5th

12423

12423

12120

10605

10620

3242

3225

3222

2860

3070

Mismatch score threshold Window size n Accuracy

FPR

Recall

Precision

0.01

0.02

0.03

0.04

0.05

5

5

5

5

5

98.55

98.65

93.39

88.91

82.80

1.83

1.71

1.64

1.64

1.62

100.00

100.00

074.71

053.88

006.08

93.46

93.83

92.36

89.85

43.23

TABLE 8: Effect of varying n on detection performance

Window size (n) Accuracy

3

5

7

9

98.55

98.35

98.68

98.89

FPR

1.79

2.04

1.63

1.37

Recall

Precision

100

100

100

100

92.94

92.03

93.52

94.52

Fig. 7: CDF plot of the time required to detect anomalous
event sequences

detection scheme could detect all anomalous sequences in
virtually less than 30 seconds.

While the detection scheme was running at the Inter-
preter, we also monitored for 1.5 hours the computational
overhead incurred due to its execution. In particular, we
logged the computer’s overall CPU5 utilization at regular
intervals of 1 second using psutil and plotted the graph
shown in Figure 8. We can notice from the ﬁgure that the
CPU usage, while the detection scheme was running, was
less than ≈7% (dense blue area) in most of the time intervals,
except for some intervals wherein the CPU usage reached
up to ≈16%. Thus, due to the small computational overhead
of the proposed detection scheme, it can be an ideal solution
for detecting Slow HTTP/2 DoS attacks in real-time.

8 CONCLUSION AND FUTURE WORK
Slow Rate DoS attacks are a matter of grave concern for
server administrators because of two prominent reasons.
First, these attacks require signiﬁcantly less computational
power and thus, can be launched even from mobile devices.
Second, these attacks generate minimal trafﬁc, due to which
they are highly stealthy. The effect of these attacks on
HTTP/2 servers on the Internet had not been analyzed ear-
lier. Moreover, the known mechanisms to counter the attacks
against HTTP/1.1 can not counter them against HTTP/2.
Thus, in this work, we attempted to bridge these gaps by

5. The Interpreter computer had AMD Ryzen 7 5800H processor.

Fig. 6: Time required to extract lookahead pairs for different
n

the mismatch score threshold was ﬁxed, but n was varied
across the intervals. We show the results of this experiment
in Table 8. We can notice from the table that varying the
window size does not virtually affect the proposed scheme’s
detection accuracy. However, we also observed from our
experiments that the longer the chosen window size, the
longer time was required to extract the lookahead pairs from
an event sequence, as shown in Figure 6. This results in the
delayed classiﬁcation of an event sequence as a normal or
anomalous sequence. Thus, choosing a smaller window size
is essential so that the mismatch scores can be calculated and
the corresponding decision can be made as soon as possible.

7.2.3 Detection latency and computational overhead

It is essential for an active detection scheme to detect anoma-
lies as soon as possible so that an alarm can be raised and
necessary preventive measures can be taken. Thus, we also
measured how fast our proposed detection scheme could
detect anomalous event sequences. Figure 7 shows the result
of this measurement. We can notice from the ﬁgure that the

11

[10] N. Tripathi and A. K. Shaji, “Defer No Time, Delays have Dangerous
Ends: Slow HTTP/2 DoS Attacks into the Wild,” in Proceedings of
the 14th IEEE International Conference on COmmunication Systems
and NETworkS (COMSNETS), 2022, pp. 194–198.

[11] D. Beckett and S. Sezer, “HTTP/2 Cannon: Experimental Anal-
ysis on HTTP/1 and HTTP/2 Request Flood DDoS Attacks,”
in Proceedings of the International Conference on Emerging Security
Technologies (EST’17), 2017, pp. 108–113.

[12] ——, “HTTP/2 Tsunami: Investigating HTTP/2 Proxy Ampliﬁca-
tion DDoS attacks,” in Proceedings of the International Conference on
Emerging Security Technologies (EST’17), 2017, pp. 128–133.

[13] S. T. Zargar, J. Joshi, and D. Tipper, “A Survey of Defense Mech-
anisms against Distributed Denial of Service (DDoS) Flooding
Attacks,” IEEE Communications Surveys & Tutorials, vol. 15, no. 4,
pp. 2046–2069, 2013.

[14] A. Praseed and P. S. Thilagam, “DDoS Attacks at the Applica-
tion Layer: Challenges and Research Perspectives for Safeguard-
ing Web Applications,” IEEE Communications Surveys & Tutorials,
vol. 21, no. 1, pp. 661–685, 2019.

[15] Core. (2019) Https://httpd.apache.org/docs/2.4/mod/core.html.
(2013) Https://sourceforge.net/projects/mod-
[16] mod antiloris.
antiloris/.

[17] mod limitipconn. (2002) Http://dominia.org/djao/limitipconn.html.
[18] mod reqtimeout. (2019) Https://httpd.apache.org/docs/trunk/mod/

mod reqtimeout.html.

[19] Imperva

(2016): HTTP/2:
of

the
the next generation web protocol.

top four ﬂaws
https://www.imperva.com/docs/Imperva HII HTTP2.pdf.
[20] E. Adi, Z. A. Baig, P. Hingston, and C.-P. Lam, “Distributed Denial-
of-Service Attacks against HTTP/2 Services,” Cluster Computing,
vol. 19, no. 1, pp. 79–86, 2016.

in-depth

analysis

of

[21] A. Praseed and P. S. Thilagam, “Modelling Behavioural Dynamics
for Asymmetric Application Layer DDoS Detection,” IEEE Trans-
actions on Information Forensics and Security, vol. 16, pp. 617–626,
2021.

[22] ——, “Multiplexed Asymmetric Attacks: Next-generation DDoS
on HTTP/2 Servers,” IEEE Transactions on Information Forensics and
Security, vol. 15, pp. 1790–1800, 2019.

[23] E. Cambiaso, M. Aiello, M. Mongelli, and I. Vaccari, “Detec-
tion and Classiﬁcation of Slow DoS Attacks Targeting Network
Servers,” in Proceedings of the 15th International Conference on Avail-
ability, Reliability and Security (ARES), 2020.

[24] A. Praseed and P. S. Thilagam, “Fuzzy Request Set Modelling
for Detecting Multiplexed Asymmetric DDoS Attacks on HTTP/2
servers,” Expert Systems with Applications, vol. 186, p. 115697, 2021.
[25] NETRESEC, “PolarProxy.” [Online]. Available: https://www.

netresec.com/?page=PolarProxy

ACKNOWLEDGMENTS
The authors would like to thank the Netresec team for
supporting this research with a free L1 license of PolarProxy.

Fig. 8: Computational overhead

ﬁrst performing an empirical evaluation of Slow HTTP/2
DoS attacks on the Internet and subsequently proposing a
scheme to detect these attacks in real-time. Our experiments
showed that several HTTP/2 servers on the Internet delay
closing the connections from which incomplete requests are
sent, thus being vulnerable to the Slow Rate DoS attacks.
Our experiments to test the performance of the proposed
detection scheme showed that it could accurately detect the
attacks in real-time with a marginal computational over-
head. In the future, we plan to work on the vulnerability
assessment of HTTP/3, the upcoming version of HTTP. As
of January 2022, HTTP/3 has not been standardized, and it
currently holds the status of an Internet Draft.

REFERENCES

[1] N. Tripathi, N. Hubballi, and Y. Singh, “How Secure are Web
Servers? An Empirical Study of Slow HTTP DoS Attacks and De-
tection,” in Proceedings of the International Conference on Availability,
Reliability and Security (ARES), 2016, pp. 454–463.

[2] N. Tripathi and N. Hubballi, “A Probabilistic Anomaly Detection
Scheme to Detect DHCP Starvation Attacks,” in Proceedings of the
International Conference on Advanced Networks and Telecommunica-
tions Systems (ANTS), 2016, pp. 1–6.

[3] ——, “Preventing Time Synchronization in NTP Broadcast Mode,”

Computers & Security, vol. 102, p. 102135, 2021.

[4] G. Mantas, N. Stakhanova, H. Gonzalez, H. H. Jazi, and A. A.
Ghorbani, “Application-Layer Denial of Service Attacks: Taxon-
omy and Survey,” International Journal of Information and Computer
Security, vol. 7, no. 2/3/4, p. 216–239, 2015.

[5] Gonzalez, Hugo and Gosselin-Lavigne, Marc Antoine and
Stakhanova, Natalia and Ghorbani, Ali A, “The Impact of
Application-Layer Denial-of-Service Attacks,” Case Studies in Se-
cure Computing: Achievements and Trends, vol. 261, 2014.
SANS
Slowloris
Https://isc.sans.edu/forums/diary/Slowloris+and+Iranian+DDoS+attacks
/6622/.

Forums.
DDoS

(2009)
Attacks.

InfoSec

Iranian

and

ISC

[6]

[7] N. Tripathi and N. Hubballi, “Application Layer Denial-of-Service
Attacks and Defense Mechanisms: A Survey,” ACM Computing
Surveys (CSUR), vol. 54, no. 4, pp. 1–33, 2021.

[8] M. Belshe, R. Peon, and M. Thomson, “(RFC 7540) Hypertext

Transfer Protocol Version 2 (HTTP/2),” 2015.

[9] N. Tripathi and N. Hubballi, “Slow Rate Denial of Service Attacks
against HTTP/2 and Detection,” Computers & security, vol. 72, pp.
255–272, 2018.

Nikhil Tripathi is currently working as an Assis-
tant Professor in Computer Science & Engineer-
ing Group at the Indian Institute of Information
Technology, Sri City, India. Prior to his current
role, he worked as a cyber security researcher at
Fraunhofer Institute for Secure Information Tech-
nology (SIT), Germany. He earned his Ph.D.
in Computer Science and Engineering from the
Indian Institute of Technology Indore, India, in
2019. He primarily works on the vulnerability as-
sessment of popular application layer protocols
to explore possible DoS vulnerabilities and devise novel defense mech-
anisms to counter large-scale DoS attacks. He has published research
papers in various reputed journals such as ACM Computing Surveys,
Computers & Security, and conferences like INFOCOM, ARES, and
COMSNETS. He also holds professional memberships of societies such
as IEEE, IEEE Communications Society, and ACM.

