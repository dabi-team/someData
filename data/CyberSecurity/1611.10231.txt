6
1
0
2

v
o
N
0
3

]

R
C
.
s
c
[

1
v
1
3
2
0
1
.
1
1
6
1
:
v
i
X
r
a

00

Android Code Protection via Obfuscation Techniques:
Past, Present and Future Directions

Parvez Faruki, Malaviya National Institute of Technology Jaipur, India
Hossein Fereidooni, University of Padua, Italy
Vijay Laxmi, Malaviya National Institute of Technology Jaipur, India
Mauro Conti, University of Padua, Italy
Manoj Gaur, Malaviya National Institute of Technology Jaipur, India

Mobile devices have become ubiquitous due to centralization of private user information, contacts, messages
and multiple sensors. Google Android, an open-source mobile Operating System (OS), is currently the mar-
ket leader. Android popularity has motivated the malware authors to employ set of cyber attacks leveraging
code obfuscation techniques. Obfuscation is an action that modiﬁes an application (app) code, preserving
the original semantics and functionality to evade anti-malware. Code obfuscation is a contentious issue.
Theoretical code analysis techniques indicate that, attaining a veriﬁable and secure obfuscation is impos-
sible. However, obfuscation tools and techniques are popular both among malware developers (to evade
anti-malware) and commercial software developers (protect intellectual rights). We conducted a survey to
uncover answers to concrete and relevant questions concerning Android code obfuscation and protection
techniques. The purpose of this paper is to review code obfuscation and code protection practices, and evalu-
ate efﬁcacy of existing code de-obfuscation tools. In particular, we discuss Android code obfuscation methods,
custom app protection techniques, and various de-obfuscation methods. Furthermore, we review and ana-
lyze the obfuscation techniques used by malware authors to evade analysis efforts. We believe that, there
is a need to investigate efﬁciency of the defense techniques used for code protection. This survey would be
beneﬁcial to the researchers and practitioners, to understand obfuscation and de-obfuscation techniques to
propose novel solutions on Android.

Additional Key Words and Phrases: Code Obfuscation, Dalvik bytecode, Native code, Payloads, Code Pack-
ing, Dynamic loading

ACM Reference Format:
Parvez Faruki, Hossein Fereidooni, Vijay Laxmi, Mauro Conti and Manoj Gaur. ACM Comput. Surv. 0, 0,
Article 00 ( 2017), 37 pages.
DOI:http://dx.doi.org/10.1145/0000000.0000000

1. INTRODUCTION

ANDROID,

the most popular mobile device OS is

currently the market
leader [Guardian 2014] [Gartner 2014]. The availability of Internet, Global Posi-
tioning System (GPS) and custom apps have increased the popularity of the mobile de-
vices. The ofﬁcial Android market, Google Play is the dominant app distribution plat-
form accessible to all Android devices [Play 2015]. Google Play also allows installation
of third-party developers and app stores [SlideME 2014]. The elevated Android popu-
larity has attracted the attention of malware authors employing advanced code obfus-

Author’s addresses: P. Faruki and V. Laxmi and M. Gaur, Computer Engineering Department, Malaviya
National Institute of Technology, India; H. Fereidooni and M. Conti, Department of Mathematics, University
of Padua.
Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted
without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that
copies show this notice on the ﬁrst page or initial screen of a display along with the full citation. Copyrights
for components of this work owned by others than ACM must be honored. Abstracting with credit is per-
mitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component
of this work in other works requires prior speciﬁc permission and/or a fee. Permissions may be requested
from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701 USA, fax +1 (212)
869-0481, or permissions@acm.org.
c(cid:13) 2017 ACM 0360-0300/2017/-ART00 $15.00
DOI:http://dx.doi.org/10.1145/0000000.0000000

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

 
 
 
 
 
 
00:2

P. Faruki et al.

cation and protection techniques. The malware authors are propagating encrypted and
obfuscated premium-rate SMS malware, evading Google Play security [Castillo 2012].
On the other hand, app developers are concerned about code misuse; hence they em-
ploy code obfuscation, encryption and custom protection techniques. The weak code
protection techniques lower the code integrity and escalate the risk of plagiarism and
malware attacks. For instance, a rooted device facilitates identiﬁcation of app internals
and evades device security.

In software engineering lexicon, reverse engineering is deﬁned as a set of methods
for obtaining the source code from APK archive. The code obfuscation is employed by
malware authors to evade anti-malware. In particular, the architecture-neutral com-
piled Java code is amenable to reverse engineering. The app developers are concerned
about safety and protection of the developed intellectual algorithms and data. Mal-
ware authors use obfuscation, code encryption, dynamic code loading, and native code
execution evading the Google Play protection [Rasthofer et al. 2015a].

Code obfuscation is reported as a reasonable and easy alternative compared to the
other protection techniques [Franz 2010] [Davi et al. 2012]. Code obfuscation is a set
of purposeful techniques to render the code unreadable. Code obfuscation transforms
the code by changing its physical appearance, preserving the intended program logic
and behavior. Furthermore, code obfuscation is useful to protect the software from
reverse engineering. Hence, malware developers have already leveraged the obfusca-
tion by developing recent malware apps evading the Play stores and commercial anti-
malware [Rogers 2014; Minidump 2014]. Android permits app distribution from third-
party developers and other third party app stores. Application developers employ ob-
fuscators to protect the proprietary logic and sensitive algorithms to avoid the misuse.
The code obfuscation techniques can be used to: (i) protect the intellectual property;
(ii) prevent piracy; and (iii) prevent app misuse. The obfuscation techniques employed
by malware authors evade the existing commercial anti-malware solutions. The An-
droid development environment has an in-built obfuscator Proguard [Android 2015b]
for app code protection.

A De-obfuscator is required when app source code is not available. De-obfuscation
can be used to verify correct execution of obfuscated app. A popular app may disguise
as a Trojan with hidden malicious payload. Zhou et al. [Zhou and Jiang 2012] studied
49 Android malware families and reported more than 86% repackaged malware from
1260 APK ﬁles. However, manual analysis is difﬁcult for evaluating 1,490,272 Google
Play apps reported in September 2015 [Appbrains 2015]. There exist several legal and
technical methods to protect the intellectual property of software producers such as
encryption, server-side execution, trusted native code, program encoding, and code ob-
fuscation.

Android is

the dominant mobile platform among users and develop-
ers [Guardian 2014]. The open nature of Android allows apps from third-party
developers and other third-party markets. The popularity is an opportunity for pla-
giarists to clone, obfuscate and hijack the popular apps with their trojanized versions.
Code obfuscation and protection techniques can protect the intellectual property.
However, they can also be used to protect malicious code.

The remainder of this paper is organized as follows. In Section 2, we discuss basics
of Android platform, execution mechanism, and its difference with Java development
model. Section 3 covers types and purpose of code obfuscation with an in-depth descrip-
tion of app protection techniques. Section 4 elaborates obfuscation and optimization
tools used by malware authors. In Section 5, we discuss the code protection techniques
used by code packers. In Section 6, we explore the reverse engineering tools used for
de-obfuscating the protected code. Section 8 elaborates the recent trends in obfuscation
and possible future research directions. Finally, in Section 9, we conclude this survey.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:3

2. ANDROID OVERVIEW

The Android OS is open-source developed by Google and supported by the Open
Handset Alliance (OHA) [Russello et al. 2013; Faruki et al. 2013]. In the following, we
discuss Android OS architecture and app compilation process.

2.1. Android Architecture

The Android software stack has four layers as illustrated in Figure 1: (i) linux kernel;
(ii) native user-space; (iii) application framework; and (iv) application layer. The base
of Android is Linux kernel adapted for limited processing capability, restricted memory
and constrained battery availability. The Android platform customized “vanilla” ker-
nel for resource constrained mobile devices. The Binder driver for inter-process com-
munication (IPC), Android shared memory (ashmem), and wakelocks are important
modiﬁcations to suit the Android devices.

Fig. 1: Android Architecture.

Native Space and Application Framework layers form the Android middleware. The
bottom layer blocks are the components developed in C/C++. However, the top two
layers are implemented in Java. Native components are directly executed on the pro-
cessor, bypassing the DVM. Hardware Abstraction Layer (HAL) is blurred between the
Linux Kernel and Native user-space. Application Framework provides interaction to
the developer. Java classes are compiled into Dalvik executable .dex and interpreted
by the VM. User apps are at the top most layer.

There are many known open-source and commercial tools to reverse engineer the
Android apps. Thus, unprotected apps may unknowingly give away the source code
to the attackers for misuse. Android runs the APK ﬁles on Dalvik Virtual Machine
(DVM), a register-based virtual machine to suit the mobile devices [Faruki et al. 2013].
The JVM is a stack-based, whereas, DVM is register-based [Shi et al. 2008]. JVM em-
ploys Last In First Out (LIFO) stack with PUSH and POP operations. The DVM stores

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:4

P. Faruki et al.

register-based operands in the CPU registers and requires explicit addressing. Fig-
ure 2 illustrates the procedure of converting Java source code to an APK archive.

2.2. Android Compilation

dx is Android SDK tool

that converts Java source code to Dalvik byte-
code [Android 2013]. It merges multiple class ﬁles into a single .dex ﬁle. Android
manifest stores name and version of the app, libraries, declared permissions, assets,
and other uncompiled resources. The content is merged into a single archive, an
[Faruki et al. 2013]. Many open-source and
Android application PacKage (APK)
proprietary tools are available for reverse engineering the application. The unpro-
tected apps may unknowingly give away their source code to the attacker, permitting
visibility to the internals of the APK. The easy availability of source may lead to loss
of revenue, reputation issues, access to intellectual property, and legal liabilities.

Fig. 2: Compilation of Java code to Android APK.

The Android KitKat 4.4 introduced Android RunTime (ART) to replace the DVM.
The new runtime is proposed to improve the Android OS performance. We brieﬂy com-
pare the Dalvik and ART to underline their importance.

(1) Dalvik:

Dalvik VM is the core of Android Dalvik bytecode execution. The Dalvik runtime
is based on the Just-In-Time (JIT) compilation that remains independent of the
machine code. When a user runs an Android app, the .dex code is compiled to the
machine code. Dalvik VM performs JIT compilation and optimization during the
app runtime to improve performance. However, the presence of JIT adds latency
and memory pressure. Though mobile devices are improving their resources, the
new runtime is more efﬁcient in comparison to Dalvik VM.

(2) Android RunTime (ART):

The Android KitKat version 4.4 introduced an optional runtime Android RunTime
(ART) to experimentally replace the DVM to improve performance. In ART, the
APK the bytecode is converted to machine code at install time. Ahead-of-time com-
pilation (AOT), a pre-compilation technique, saves the machine code in persistent
storage. It loads the machine code at runtime, saving the CPU and memory as

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:5

compared to DVM. In particular, the .dex ﬁle is compiled as .oat ﬁle in ELF for-
mat. The ART reads the .dex ﬁle using .dexFile, openDexFileNative from
libart.so library. If the oat ﬁle is not found, ART invokes dex2oat tool for com-
piling .dex to .oat. Otherwise, ART loads the .oat ﬁle in memory cache map.
Once the .oat ﬁle is loaded, ART creates OatFile data structure to store the
information. The ART reduces app startup time as code is converted to native at in-
stall time, which improves battery life. However, the installation takes more time
and space.

3. CODE OBFUSCATION TECHNIQUES

Code obfuscation or mutation techniques alter the code appearance in the exist-
ing binary from one generation to another, to evade the anti-malware. Malware au-
thors employ obfuscation techniques to protect malicious logic to evade the anti-
malware [Preda 2007]. The app developers also use obfuscation and code protection
methods to protect the code against reverse engineering. Plagiarist and malware au-
thors employ obfuscation to evade the security tools. Malware authors also employ
obfuscation to plagiarize the popular and paid apps. Obfuscation provides signiﬁcant
protection and obscures explicit details. Some obfuscation techniques operate directly
on the source code; some obfuscate the bytecode. Collberg et al. classify the obfusca-
tion techniques as: (i) Control-ﬂow; (ii) Data; (iii) Layout; and (iv) Preventive obfus-
cation [Collberg et al. 2002; van Oorschot 2003]. Figure 3 illustrates detailed outline
of existing code obfuscation and protection techniques discussed subsequently. An ob-
fuscator protects the proprietary software and prevents its reverse engineering. The
obfuscated program maintains the semantics of the original app. The original and ob-
fuscated version produce the same output when executed. The malware authors use
code protection and obfuscation techniques to protect malware logic, algorithms and
hide the suspicious information such as strings, domain names and server address to
delay malware being detected.

A de-obfuscator restores the original app from the obfuscated code with reverse en-
gineering tools. The reconstruction of the source may not be possible. For example,
identiﬁer renaming obfuscated variables cannot be restored to their original names
once changed by the obfuscator. According to [Low 1998], code obfuscation or trans-
formation is the most suitable technical protection for type-safe language like Java.
According to Udupa et al. [Udupa et al. 2005], surface obfuscation affects the syntax
of the target program. However, it is not possible to hide the code semantics. If an
identiﬁer is renamed, the program output remains the same. The deep transformation
obfuscates the control ﬂow of target program [Schulz 2014].

Deﬁnition: Collberg et al. deﬁne the obfuscating transformation as the conversion

τ of a source app A into the target app A′ [Collberg et al. 2002] :

τ−→ A′.

A

Transformed app A′ is an obfuscated version of the original program A if:
— App A does not terminate, or ends with an error condition, then A′ may or may not

terminate [Collberg et al. 2002].

— Otherwise, A′ must terminate and generate the output similar to A [Collberg 2015].

Android apps are distributed as archive APK ﬁles available from: (i) Google Play;
(ii) Third-party app marketplaces; and (iii) Android debug bridge. Once installed, the
apps from the devices can be also accessed with Android Developer Tools (ADT). These
APK ﬁles can be reverse engineered to the Dalvik bytecode from classes.dex, the
app executable ﬁle. In the following subsection, existing code obfuscation approaches
are detailed according to the outline made in Figure 3.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:6

P. Faruki et al.

Fig. 3: Obfuscation Classiﬁcation.

3.1. CONTROL FLOW OBFUSCATION

Control ﬂow obfuscation aims to confuse the analyst by breaking up the control ﬂow
of the source code. Functional blocks that belong together are broken apart, and func-
tional blocks that do not belong together are intermingled to confuse the reverse en-
gineering. The control ﬂow transformation changes the execution paths of a program,
still maintains the original functionality. The control ﬂow obfuscation is categorized as
Aggregation, Computation and Ordering obfuscation techniques. The techniques can
be further classiﬁed into following sub-categories as illustrated in Figure 3.

3.1.1. Control ﬂow computation . The control ﬂow obfuscation techniques hide the con-
trol ﬂow and append additional code and complicate APK disassembly. The code in-
sertion can be an additional method or irrelevant code [Martinsen 2008]. However,
the recent compilers remove unused code for execution efﬁciency during the code opti-
mization phase. To counter this, one can insert irrelevant bytecode such as PUSH or POP
within the high-level code. Hence, it is not removed. Computation control obfuscation
can be broken down as described in the following:

(1) Inserting Dead or Irrelevant Code: The dead code block can never be reached;
hence, is never executed. Inserting dead-code statements increases size of code
and analysis time. A programmer can insert code block that is never exe-
cuted [Kovacheva 2013]. For example, one can include extra methods or irrelevant
statement blocks [Stamp and Wong 2006]. For instance, the code snippet before
the Add Dead-code Switch Statements (ADSS) [Faruki et al. 2013] obfuscation is
illustrated in listing 1. The Java bytecode switch construct can be used to insert
control switch that is never executed [Batchelder and Hendren 2007]. However,
the switch increases the connectedness and complexity of the method. Thus, the
obfuscation evades the decompiler that cannot remove the dead switch. Listing 2
illustrates the ADSS obfuscation [Batchelder and Hendren 2007].

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:7

1
2
3
4
5
6
7
8
9
10
11
12

//before ADSS obfuscation
if (writeImage != null) {

try {

File file = new File("out");
ImageIO.write(writeImage, "png", file);

}
catch (Exception e) {
System.exit(1);
}

}

System.exit(0);

Listing 1: before ADSS obfuscation

// ADSS obfuscated code
if(obj != null) {

try {

ImageIO.write((RenderedImage)obj,png,

new File(out));

}

catch(Exception exception2)

{

i += 2;
System.exit(1);

}

}
label_167:
{ while(lI1.booleanValue() == ___)

{ switch (i) {

default: break;
case 3: break label_167;
System.exit(1);
continue;

}

}
System.exit(0);

}

Listing
code [Mcgill 2015]

2:

ADSS

obfuscated

(2) Extend Loop condition: Rewriting the test condition as a complex loop function
introduces obfuscation in the code. It can be accomplished by extending the loop
condition with the addition of more test cases having no effect on the result. The
code in Listing 4 illustrates the extension of a simple if condition.

1
2
3
4
5
6
7
8
9
10

// Before loop extension

// After loop extension obfuscation

int x = 1;

if (x > 200)
{

...
x ++;
Foo(x)

}

Listing 3: code before Loop extension

int x = 1;
while (x> 200 || x%200==0)
{

...
x ++;

// calling function
Foo(x)

}

Listing 4: Loop extension obfuscation

(3) Reducible to Non-Reducible ﬂow-graph obfuscation (RNR) [Collberg 2015]: A
reducible ﬂow graph can be made complex by turning it reducible to non-reducible.
The Java bytecode has a goto instruction. However, the Java language does not
have a corresponding goto statement [freepatents 2015]. Hence, a plagiarist
can misuse the goto bytecode and obfuscate with an arbitrary control-ﬂow
transformation. Java language can only express a structured control ﬂow. Hence,
“the control ﬂow graphs produced by the Java programs is always reducible.
However, Java bytecode can express this as non-reducible ﬂow graphs, thus
obfuscating reducible ﬂow graph to non-reducible” [freepatents 2015]. According
to [Collberg et al. 2002], this is achieved by converting a structured loop into a loop
with multiple headers. Listing 5 and 6 illustrate the effect of RNR obfuscation.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:8

P. Faruki et al.

1
2
3
4
5
6
7
8

// Before:

Statement 1;
while (condition1)
{

Statement2;

}

Listing 5: before RNR Obfuscation.

// After:
Statement 1;
if(condition2) {
Statement2;
while(condition1){

Statement2;

}
else {

while(condition1){

Statement2;

}

}

Listing 6: RNR Obfuscated code.

(4) Add Redundant Operands: Appending insigniﬁcant terms within the code during
basic calculations hinders reverse engineering. For example, let us assume an in-
teger variable p which stores the product of two integer variables a and b. The code
listings 7 and 8 illustrates the code snippets before and after redundant operators
obfuscation. The transformed code generates exactly the same output. However,
the obfuscated snippet appears complex during the analysis.

1
2
3
4
5
6
7
8
9
10

//original code

public int sum{

int a,b = 5, 7;
int p;
p = a * b;
System.out.println(‘‘Product =’’ + p);

}

Listing 7: before redundant operators

//Redundant Operators Obfuscation

public int sum{
int a,b = 5,7;
double i,j = 0.0005, 0.0007;
double p;
p = (a * b) + (i*j);
System.out.println(‘‘Product =’’+ (int) p);
}

Listing 8: redundant operators

(5) Parallelize Code: The introduction of threads can affect the readability due to
increased code complexity. The parallelization improves the performance. How-
ever, the motivation in this case is to hide the correct code ﬂow. Collberg et
al. [Collberg et al. 2002] suggested the following techniques: (i) Creating dummy
processes; or (ii) Splitting sequential sections of a program into multiple concur-
rent and parallel processes.

3.1.2. Control-ﬂow Aggregation (CFA) . The CFA alters the program statements group-

ing [Plasmans 2005]. CFA can be further classiﬁed into:

(1) Inline and Outline methods: In Java, replacing a method call by its actual body
(inlining) make the code complicated and difﬁcult to understand. Code optimizers
use these techniques. It also is a useful obfuscation transformation. Code inlining
removes procedural abstraction from the program. Conversely, outlining selects a
group of statements in a procedure and re-use them to generate a sub-procedure.
For instance, inlining two procedures A and B necessitates the calling one after the
other and outlining a portion of the combined code inside a new procedure.

(2) Method Interleaving (MI): Identifying an interleaved method is a difﬁcult reverse
engineering task. MI merges the body and parameter list of different methods.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:9

Furthermore, it adds parameter to discriminate between calls to the individual
methods [Collberg et al. 2002; Collberg 2015; freepatents 2015].

(3) Method Cloning (MC): A reverse engineer examines the body and signature of a
subroutine to determine code functionality, a necessary step for reverse engineer-
ing. One can create function clones and further introduce repetitive calls to such
functions.

(4) Loop Transformations (LT): In [Collberg et al. 2002], authors observed that some
transformations increase the code complexity. Such obfuscation techniques break
down the iteration space to ﬁt the inner loop cache [Collberg 2015]. The availability
of compile-time loop bounds turns the loop to a compound body with several loops
known as loop ﬁssion [Collberg 2015].

3.1.3. Control-ﬂow ordering (CFO). Control ﬂow ordering obfuscation changes the ex-
ecution order of the code statements. For instance, loops can be iterated backward
rather than forward. Control ordering obfuscations can be categorized into:

(1) Reorder Statements and Expressions (RSE): Changing the order of statements and
expressions has a signiﬁcant effect on the Dalvik bytecode. It can disrupt the link
between Java source and corresponding Dalvik bytecode [Kovacheva 2013].

(2) Reorder Loop (RL): RL transformation can be run backward to confuse the analy-

sis. Code Listing 9 and 10 illustrate the usage of loop reversal obfuscation.

1
2
3
4
5
6

// Original code
x = 0;
while (x < maxNum){

i[x] += j[x];
x++;

}

// Loop reversal to change the control flow
x = maxNum;
while (x > 0)
{

x--;
i[x] += j[x];

}

Listing 9: before loop reversal

Listing 10: loop reversal obfuscation

3.1.4. Control-ﬂow ﬂattening (CFF). CFF transforms the source code such that
static analysis cannot determine the targets of branches. In this technique, the
basic blocks of a program have same predecessor and successor. During execution,
the actual control ﬂow is controlled by a dispatch variable. A switch block has dis-
patch variable and a jump table to switch indirectly towards intended successor.
At runtime, the value of dispatch variable decides which code block to be executed
next. Figure 4(a) illustrates the control-ﬂow graph of Listing 11 and Figure 4(b)
shows the ﬂattened control ﬂow of the mentioned program. Compilers primarily
use such methods during code optimization. However, malware authors leverage
this technique to hide the semantic as well as syntax structure of a malware APK.
This obfuscation technique prevents or at least delays manual analysis.

1
2
3
4
5
6
7
8
9
10
11
12
13

public int fill( int a , int b )
{

int diff = 0;
if ( a > b ) { diff = a-b ;

do
{ b ++;
} while ( a ! = b ) ;

}
else { diff = b-a ;

do { a ++;

} while ( a ! = b ) }
return diff ;

}

Listing 11: control ﬂow ﬂattening

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:10

P. Faruki et al.

Fig. 4: CFG of listing 11

3.2. DATA OBFUSCATION
Data obfuscation techniques can modify the structure of an APK. They can be clas-
siﬁed into following sub-categories as illustrated in Figure 3.

3.2.1. Data aggregation. This obfuscation changes the data grouping. In the fol-

lowing, we list some sub-categories of this technique:
(a) Merging Scalar Variables: This obfuscation involves merging two or more
scalar variables into a single variable. For example, m scalar variables Var1,
Var2,Var3,..,Vark can be merged into a single array variable Varm. Variables,
in a way similar to arrays or integers, can be merged or even promoted as ob-
jects [Collberg et al. 2002; Collberg 2015; freepatents 2015]. As a simple exam-
ple, consider merging two 32-bit integer variables X and Y into a 64-bit variable
Z.

(b) Class Transformations (CT): Class transformations can be leveraged to make
the program analysis difﬁcult. One good way of achieving this is to use inher-
itance and interfaces to create deep class hierarchies to build a complex dis-
tributed application. Further, one or more dummy classes/methods can confuse
the reverse engineer.

(c) Array Transformations (AT): Array transformation is an effective obfus-
cation technique to convert the readable string information as unread-
able [Collberg 2015]. The AT: (i) splits an array; (ii) merge two or more arrays;
(iii) ﬂattens an array dimensions; or (iv) folds or increases the array dimen-
sions.

3.2.2. Data Storage and Encoding (DSE). The DSE affects how the data is stored
and interpreted. Such methods obscure the data structures within the programs.
Data storage obfuscation converts a local variable into a global. Furthermore, data
encoding obfuscations replaces an integer variable i with an expression x*i+y. In
the following, we discuss such techniques.
(a) Change Encoding (CE): Programmers follow some standard conventions to
write code. The encoding transformation techniques exploit this fact. The more
transformations we employ, the less likelihood to understand the code. In fact,
changing encoding reshapes the data into less natural forms. For example,
we can replace all the references initializing an index variable i, with the
expression i= x*i+y, where x=6 and y=5. When the code needs to use the
index value, the obfuscator inserts the expression (i-5)/6. Finally, instead
of incrementing the variable by one, add six to the value. The obfuscation
scales and offsets the index from the desired value to compute the real index.
Listings 12 and 13 illustrates encoding.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:11

1
2
3
4
5
6
7

//Before:
int i = 1;
while (i <= 100)
{

result = arr[i-1];
i++;

}

1
2
3
4
5
6

//After:
int i = 11;
while (i <= 605)
{ result = arr[(i-5)/6];

i+=6;

}

Listing 12: before encoding obfus-
cation

Listing 13: After encoding obfusca-
tion

(b) Class Transformations: Class transformations can be leveraged to make the
program analysis difﬁcult. One good way of achieving this is to use inheritance
and interfaces to create deep class hierarchies that make it more difﬁcult to
understand the application. Inserting a bogus class can confuse the reverse
engineer.

(c) Array Transformations: There exist many different types of transformations
that can be devised to obscure the operations performed on an array. These
transformations consist of splitting an array, merging two or more arrays, ﬂat-
tening an array (i.e., decrease the dimensions of the array), and folding the
array (i.e., increase the dimensions of the array).

The data modiﬁcation techniques can be used to evade the string based malware
detectors. A simple example illustrated in Listing 14 and 15 demonstrates data
modiﬁcation obfuscation.

1
2

// original declaration

int a = 30

.

Listing 14: before integer obfusca-
tion

1
2
3
4
5
6
7

// obfuscating integer declaration
class bar {
public int getValue () {
return 30; }
}
Foo f = new bar () ;
int a = f.getValue () ;

Listing 15: after integer obfusca-
tion

(3) Split Variables (SV): Boolean variables can be replaced by a boolean expression.
The relevant example is illustrated in Table I. Variable b in the original code is
expressed asf (b1, b2). In this example, function F is XOR. However, it can be gener-
alized to any function with any number of variables. This also adds another layer
of obfuscation due to the fact that some assignments of a value have different re-
sults. Let us say b = True. We can further split the variable into b1 = 0 and b2 = 1
in the lookup Table I and convert it to original Boolean value.

b1
0

0

1

1

b2
0

1

0

1

b=F (b1 ⊕ b2)
False

True

True

False

Table I: Lookup table to split variables [Gupta 2005]

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:12

P. Faruki et al.

To split the variable b into b1 and b2, we have to deﬁne: (i) a function, F (b1, b2) that
maps b1 and b2 to variable b, (ii) to the inverse function, F -1(b) that maps b to b1 and
b2, and (iii) new operations deﬁned on b1 and b2. b has been split into two shorter
integer variables b1 and b2. If b1=b2=0 or b1=b2=1 then b is false, otherwise, b is True.
Boolean b are masked as arithmetic operations on the integers b1 and b2 with the
split variable technique [Gupta 2005].

(4) Convert Static to Procedural Data: Strings store critical information such as copy-
right information, license key, and software expiry date. If the static string infor-
mation is converted to procedural data, reverse engineering becomes complicated.
A simple way obfuscate is to convert the string to a program that computes the
string [Wroblewski 2002].

3.2.3. Data Ordering. This obfuscation alters the data ordering. Ordering transfor-
mation randomizes data declaration order within a program. “An array stores a
list of integer numbers. The array has the i-th element in the list at position i.
A function f(i) can be used to determine the position of the i-th element in the
list” [Preda 2007; Low 1998]. Randomizing the declaration order impedes reverse en-
gineering process [Low 1998; Stamp and Wong 2006].

(1) Reorder Methods: randomize the declarations of methods within the code to harden

the reverse engineering.

(2) Reorder Arrays: randomize the order of parameters to methods and use a mapping

function to reorder data within arrays.

(3) Reorder Instance Variables: randomize the declarations of instance variables

within the class.

1
2
3

// original code
int a = 7 + 70/2 + 1 ;
int b = "testing".length();

// obfuscated code
int a = 43;
int b = 7;

Listing 16: before aggregation

Listing 17: aggregation obfuscation

3.3. LAYOUT OBFUSCATION

Layout transformation is used to modify the source and binary structure of a pro-
gram. Different layout transformation techniques are illustrated in Figure 3. The
Layout Obfuscation can be classiﬁed as: (i) identiﬁer scrambling; (ii) output format
changes; (iii) comments, or debug information.

Replacing the identiﬁer names with mandarin non-alphabetical characters in-
creases the code complexity. For example, in code Listing 18 the SmsManager Class
encrypts the string before sending it over the network. However, the original identi-
ﬁers names are amenable to reverse engineering. To avoid code inference, oBad Trojan
employs identiﬁer mangling obfuscation in Listing 19.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:13

1
2
3
4
5
6
7
8
9

package iAmDriving{

public class LetsNavigate{...}

}
package iAmConnecting {

public class MyBluetoothHandle{..}

}
package userIsActive{

public class MainActivity{...}

}

Listing 18: before obfuscation

package d {

public class d { ... }

}
package e {

public class e { ... }

}
package f {

public class f { ...}

}

Listing
ing [Schulz 2014]

19:

identiﬁer

renam-

Listing 19 replaces the strings by a single character. Identiﬁer mangling reduces
the meta-information by replacing them with random alphabets. Random names do
not carry any information about the object or the behavior. Hence, the interpretation
becomes difﬁcult. Proguard obfuscator within the Android SDK implements a similar
approach. oBad Trojan leverages the identiﬁer mangling with character permutations
of “o, O”, “c, C”, “i, I” and “l, L” in lower and upper case [Minidump 2014]. Listing 20
illustrates the identiﬁer renaming obfuscation.

1
2
3
4
5
6
7
8
9
10
11

public final class CcoCIcIf {
private static final byte [ ] COcocOlo;
private static boolean CcoCIcI;
private static long OoCOocll;
private static long OoCOocll;
private static String cOIcOOo;
private static final OoCOocll lOIlloc;
private static ArrayList occcclc;
private static final occccl coclClII;
private static Thread ooCclcC;
}

Listing 20: oBad Trojan Identiﬁer scrambling Obfuscation [Schulz 2014].

3.4. PREVENTIVE TRANSFORMATIONS

Preventive transformation techniques are employed to evade the commercial debug-
ging and de-compilation tools. Preventive obfuscation takes advantage weak or non-
existent mapping between the high-level language and its corresponding bytecode to
inject illegal, unused or rarely used bytecode. Changes in Java bytecode crashes the
decompiler due to the presence of new instructions. Figure 3 illustrates the preventive
obfuscation techniques.

Anti Debugging: This technique is a preventive obfuscation that inserts some val-
idation code to identify the presence of a debugger. Once it identiﬁes being executed in
the debugger, the app behaves benign without revealing the malicious behavior.

Anti De-compilation: The transformation prevents reverse engineering of Dalvik
or Java bytecode to high-level programming constructs. The obfuscator employs goto
constructs valid with the bytecode which are not a part of Java language.

Bytecode Encryption: Bytecode Encryption changes the structure of data. Low
et al. [Low 1998] suggest that encryption methods as an alternative to defeat decom-
pilation. Code transformers encrypt the data with innovative methods to decrypt the
encrypted content.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:14

P. Faruki et al.

Android Manifest Obfuscation: Another technique to obfuscate data in Android
application is Manifest Obfuscation. However, Android middleware veriﬁes the mani-
fest meta-data; some obfuscation techniques have been observed aiming at producing
errors during the binary decoding [Schulz 2014]. In the process of APK ﬁle creation, the
manifest is compiled into a binary XML ﬁle. DexGuard [DexGuard 2015a], the com-
mercial extension of ProGuard [Android 2015b] can obfuscate and optimize the binary
XML ﬁles to avoid detection.

String Encryption: String Obfuscation hides the plain text strings that reveal sen-
sitive information. The sensitive plaintext information can be misused. The strings
must be available in plaintext form at runtime. Hence, the developer prefer to encrypt
the plaintext string. String Obfuscation can be employed with an invertible encryption
function employing AES, DES or XOR encryption. Resultant output replaces the orig-
inal plaintext. The process generates a byte sequence corresponding to each string as
a data array stored in a private static class ﬁeld. The strings are brought back to the
original state at runtime. Hence, the strings are retrieved as plaintext when required.
Dynamic analysis is useful as it extracts runtime information. Code listings 21 and
22 illustrates code snippet before and after string encryption. The encrypted code con-
verts readable string information into an array of strings with ASCII characters and
obscures the code readability.

1
2
3
4
5
6
7
8
9
10
11

//original code
public void onClick(DialogInterface arg1,
int arg2) {

try { Class.forName("java.lang.System")

.getMethod("exit", Integer.TYPE)
.invoke(null, Integer.valueOf(0));

return;
} catch:(Throwable throwable) {
throw throwable.getCause();

}

}

Listing
tion [Strazzare 2014]

21:

before

encryp-

1
2
3
4
5
6
7
8
9
10
11
12
13
14

//String encryption
public void onClick(DialogInterface arg1,
int arg2)
{ try {

Class.forName(COn. Ł (GCOn. [0xA],

COn. [0x09], GCOn. [0xB]))
.getMethod(COn. Ł (i1, i2, i2 | 6),
Integer.TYPE)

.invoke(null, Integer.valueOf(0));
return;

} catch:(Throwable throwable) {

throw throwable.getCause();

}

}

Listing
crypted [Strazzare 2014]

22:

string

en-

Bad Code Injection: Figure 5 illustrates recursive goto sequences with an indi-
rect recursion. This transformation thwarts the existing static analysis tools (disas-
semblers, decompilers) by inserting bytecode statements not available with high-level
language.

Fig. 5: Bad code injection.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:15

Some instructions may be valid in Java. However, their corresponding Dalvik in-
structions may not be available. For example, Java language does not have goto con-
struct. However, when a loop or switch constructs are converted to Dalvik, the goto
statement is generated. Hence, goto can be injected in the Dalvik bytecode. In partic-
ular, a dummy method with recursive goto statements can be used.

Reﬂection: Reﬂection is a powerful Java programming technique to extend
additional functionality such as verifying backward compatibility or dynamically
load methods. It is used in debugging and testing tools [Wognsen et al. 2014]. Java
Reﬂection application programming interface (API) allows a program to access the
class information during execution to [Wognsen 2012; Wognsen et al. 2014]: (1) create
new objects; (2) invoke a method; or (3) modify the code control-ﬂow. Reﬂection can
be alternatively employed as data obfuscation technique. Code listings 23 and 24
illustrate the importance of reﬂection obfuscation.

1
2
3

// A Standard Call in Java
Crypto cryptModule = new Crypto();
privateKey = cryptModule.getPrivateKey();

Listing 23: before obfuscation

1
2
3
4
5
6
7
8
9
10
11

// Invoke using reflection
Object reflectedClassInstance =
Class.forName (pe.mnit.secureApp.Crypto).
newInstance();

Method methodToReflect =
reflectedClassInstance.getClass().
getMethod(getPrivateKey);

Object invokeResult = methodToReflect.invoke
(reflectedClassInstance);

Listing 24: code reﬂection obfuscation

Reﬂections is used in Android for a variety of purposes such as:

(1) Invoking hidden API methods: Certain Android framework features are inten-
tionally hidden from the developers during compilation. The hidden API may not
support all Android devices, or the stable version is yet to be made public.

(2) Providing backward compatibility: New Android versions incorporate addi-
tional features and get released in the incremental higher versions. A developer
may use reﬂection to verify if a particular feature present in older version exists
with the new version. If available, then only calls that feature/method.

(3) Interacting with JSON data: Data from server is loaded in JavaScript Object
Notation format (JSON) from the web. Hence, it is parsed using reﬂections in An-
droid.

(4) Libraries: Native libraries can be loaded in an APK using reﬂection API. Some

applications employ custom native libraries for improved performance.

3.5. Repackaging Popular Apps

Repackaging Android APK is a popular practice among the malware authors. In par-
ticular, malware authors reverse engineer the popular apps. The app is reverse en-
gineering, malware payload is inserted and released at less monitored Android third-
party app markets. In [Crussell et al. 2013], authors discuss a set of methods to replace
the app developer library by the plagiarist ad-libraries to divert the advertisement rev-
enues. Thus, a developer is robbed off the advertisement revenue.

Repackaging is

the widely used Obfuscation technique em-
ployed by malware authors on Android platform [Gibler et al. 2013]. Zhou et

the one of

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:16

P. Faruki et al.

al. [Zhou and Jiang 2012; Zhou et al. 2013] reported 86% repackaged malware among
the 1260 Android Malware Genome dataset. Another study reported 5-13%
repackaged and malicious applications among the well-known six third-party app
stores [Zhou and Jiang 2012]. The other third-party app stores do not have robust app
veriﬁcation and vetting. Hence, there is a higher chance of plagiarized and repackaged
apps. Furthermore, authors in [Gibler et al. 2013] reported around 30% plagiarized,
and cloned apps even at the Google Play. The repackaging process typically employs
following steps:

— Download the popular app from the Play store.
— Disassemble the app with apktool [APKTool 2015].
— Develop malicious payload either in Dalvik bytecode or Java source [Android 2013].
— Add the malicious payload inside a popular app.
— Modify the AndroidManifest.xml and/or resources if required.
— Assemble modiﬁed source with apktool.
— Distribute repackaged app by with another certiﬁcate to the less monitored third-

party markets.

Repackaging is used by malware authors as a technique to evade commercial anti-
malware. Repackaged apps create an imbalance in-app distribution markets, hurt the
developer reputation, and inﬂict monetary loss to the developers [Faruki et al. 2015;
Huang et al. 2013]. Malware authors also employ repacking to divert the advertise-
ment revenues by replacing the original advertisements with their own. AndroRAT
APK Binder [Symantec 2015] repackages and generates trojanized version of popu-
lar, legitimate app appending remote access functionality. The adversary can remotely
force the infected device to send premium-rate SMS, make voice calls, access the de-
vice location, record video and audio and access the device ﬁles without the device user
knowledge.

3.6. CUSTOM OBFUSCATION TECHNIQUES

Malware authors have been very active in developing customized obfuscation
to defeat the anti-malware. In this section, we discuss following custom tech-
niques primarily used by malware writers to protect the malicious code. Apvrille et
al. [Apvrille and Nigam 2016] list some interesting techniques used by malware au-
thors to defeat application analysis and reverse engineering:

Using very long class names: Decompilers tend to crash when the class names
are too long or written in non-ASCII format [Schulz 2012a]. Few malicious apps
have demonstrated use of very long class names to defeat reverse engineering tools
Android/Mseg.A!tr.spy [Strazzere able] reported in the wild has successfully
evaded commercial anti-malware with this technique.

Hide Packages, JAR inside raw resources: Malware developers hide the
malicious executable package inside the resource ﬁles to avoid code inspection.
For example, Android/SmsZombie.A!tr hides malicious package within a jpeg
ﬁle a33.jpg, in the assets directory [Apvrille 2014]. Android/Gamex.A!tr con-
ceal an encrypted malicious package within asset logos.png, again an image
ﬁle [Apvrille 2014]. Table II enlists interesting malicious apps using the discussed
techniques [Apvrille and Nigam 2016].

NOP to modify bytecode control ﬂow: No Operation (NOP) is an assembly lan-
guage instruction, that does nothing at all. A sequence of NOP instructions wastes the
CPU cycles and adds to the code complexity. Malware authors can leverage NOP in-
struction to modify the bytecode ﬂow to hide the actual control ﬂow of the program.
Inserting the NOP instruction changes the syntax structure, a common technique to
evade anti-malware. This approach is easy and used by quite a few malware authors.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:17

Path Obfuscation: Path obfuscation is used to achieve the cloning transforma-
tion [Frederick 2002]. The idea is to change the path such that there are different
methods, but the same meaning. This technique is used within URLs to obfuscate the
HTTP-based attacks [Frederick 2002].

Hiding bytecode: Hiding bytecode obfuscates APK with a variable length ﬁll-array-
data-payload instruction to hide the original bytecode [Schulz 2015]. This technique
can be detected by looking for Dalvik bytecode employing goto obfuscation followed
by ﬁll-array-data opcode, illustrated in Figure 6. The bytecode is hidden in the ﬁll-
array-data which remains invisible to the disassemblers.

Fig. 6: Hiding bytecode in the array of ﬁll-array-data.

Android malware name

Purpose of Obfuscation

Gamex.A!tr

The asset log-os.png is a ZIP. However, it has the capability
of being a valid ZIP ﬁle (for instance, when XOR’ed with the
right key).

SmsZombie.A!tr

Hides malicious package in a33.jpg.

DroidCoupon.A!tr

The Rage Against the Cage (root exploit, commonly used to root
Android phones) is hidden inside a png image in the resources.

Table II: hidden malware payload inside APK resource.

String table: A string table can be used to hide strings. In this technique, a mali-
cious app builds a string table as an array of characters. The table hides suspicious
strings. The reverse engineering tools fails to identify strings. Listing 25 illustrate use
of string table as an obfuscation technique.

1
2
3
4
5
6
7
8
9
10
11
12
13

package Eg9Vk5Jan;
class x18nAzukp {

final private static char[][] OGqHAYqtswt8g;
static x18nAzukp()
{ v0 = new char[][48];
v1 = new char[49];
v1 = {97, 0, 110, 0, 100, 0, 114, 0, 111, ...
v0[0] = v1;}

protected static String rLGAEh9gGn73A(int p2) {
return new String(Eg9Vk5Jan.x18nAzukp.

OGqHAYqtswt8g[p2]);
} ...
new StringBuilder(x18nAzukp.rLGAEgGn73A(43))

Listing 25: String Table

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:18

P. Faruki et al.

Fig. 7: APK Obfuscation and optimization methodology.

4. CUSTOM CODE OBFUSCATION TOOLS
Obfuscation techniques, though not invincible, are very popular among malware writ-
ers. Figure 7 illustrates the steps employed by obfuscation methods to transform and
optimize the code.

4.1. Proguard 1
Proguard

a

is

part

obfuscator

development kit
(SDK) [Android 2015b]. Proguard is a Java source code transformer. Google rec-
ommends Proguard to protect Android APK. Proguard has an in-built optimizer,
shrinker and a weak obfuscator. The Obfuscator “tool removes unused or unnecessary
code, merges the identical code blocks, employs peep hole optimization, removes de-
bug information, renames objects and restructures the original code” [Strazzare 2014].

of Android

software

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

//original code listing
public static String exec(String cmd,
Boolean root) {

BufferReader mybufferReader;
DataStream
Process process;
String string = "sh";
if(root.booleanValue()) {

testdataOutputStream;

string = "su";

}

StringBuild teststringBuilder =

new StringBuilder();
try {
process = Runtime.getRuntime()

.exec(string);

dataOutputStream = new DataOutputStream

(process.getOutputStream());
dataOutputStream.writeBytes(cmd + "\n");
mybufferReader = new BufferedReader(
new InputStreamReader(process
.getInputStream()));

}

Listing
tion [Strazzare 2014]

26:

before

obfusca-

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

// Proguarded output

public static String a(String arg6,
Boolean arg7) {

Process process;
String string = "mksh";
if(arg7.booleanValue()) {

string = "su";

}

testStringBuilder stringBuilder =

new StringBuilder();
try {

.exec(string);

process = Runtime.getRuntime()

DataOutputStream dataOutputStream =

new DataOutputStream(process
.getOutputStream());

dataOutputStream

.writeBytes(String.valueOf(arg6) + "\n");

BufferedReader bufferedReader =

new BufferedReader(

}

Listing
code [Strazzare 2014]

27:

Proguarded

1http://proguard.sourceforge.net (accessed August, 2016.)

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:19

4.2. Allatori2

Allatori [Allatori 2015] is a commercial product from Smardec. Besides identiﬁer
renaming, Allatori tool can also modify the source code. Allatori is a code optimizer,
shrinker, obfuscator and a watermarking tool. The tool obscures the loops within the
program such that reverse engineering tools are easily evaded. Such an approach in-
creases the code size and makes the program logic less readable. Moreover, Allatori
also encrypts the strings and decrypts them at runtime. Allatori has the following
notable features: (i) reduced .dex ﬁle size; (ii) improves APK execution speed; (iii) de-
creases memory usage; (iv) removes debug code; and (v) employs simple obfuscation.

4.3. DexGuard3

DexGuard [DexGuard 2015a] is a professional code optimizer and obfuscator devel-
oped by Eric Lafortune. It performs code optimization, code shrinking, and encryption.
Dexguard converts the class and methods names into non-ASCII values and strings
are encrypted with the encryption algorithms. DexGuard has following features in ad-
dition to Proguard: (i) Reﬂection obfuscation at runtime; (ii) Encrypt strings within an
array; (iii) assets, resource and library encryption; (iv) encrypts Java class names; and
(v) identiﬁes APK tampering.

1
2
3
4
5
6
7
8

// original code

public void onClick(
DialogInterface arg3, int arg4)
{

System.exit(0);

}

Listing 28: before obfuscation

1
2
3
4
5
6
7
8
9
10
11
12
13

// Dexguard obfuscated code
public void onClick(
DialogInterface arg7, int arg8) {

try {

Class.forName

("java.lang.System").getMethod("exit",Integer.
TYPE).invoke(null, Integer.valueOf(0));

return;

} catch:(Throwable throwable) {

throw throwable.getCause();

.

}

}

Listing 29: Dexguarded [Strazzare 2014]

4.4. dalvik-obfuscator4

dalvik-obfuscator is an open-source bytecode transformation tool [Schulz 2012b].
The analyst must provide an APK ﬁle as input to obtain the obfuscated app version.
Dalvik-obfuscator employs the popular junk byte injection approach on the x86 plat-
form. Dalvik-obfuscator is composed of a set of tools/scripts to obfuscate and manipu-
late .dex ﬁles. The obfuscator iterates through all the methods, insert junk bytes and
unconditional branch in the code block, to ensure it is never executed.

4.5. APKfuscator5

APKfuscator is a dead code injection obfuscator [Strazzere 2015]. Available as an
open-source, APKfuscator employs quite a few variations of dead code injection. APK-
fuscator functions on bytecode level and leverages the Unix ﬁlesystem restriction that
does not allow a class name to exceed 255 characters. APKfuscator employs three vari-
ations of dead code injection: (i) insert illegal opcodes; (ii) use legitimate opcodes into

2http://www.allatori.com (accessed August, 2016.)
3 https://www.guardsquare.com/dexguard (accessed August, 2016.)
4https://github.com/thuxnder/dalvik-obfuscator (accessed August, 2016.)
5https://github.com/strazzere/APKfuscator (accessed August, 2016.)

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:20

P. Faruki et al.

“bad” objects; and (iii) inject code inside the .dex header by exploiting a discrepancy
between the claims of the ofﬁcial .dex documentation and DEX veriﬁer.

5. CODE PACKERS AND PROTECTORS

Android code Packers insert new malicious DEX ﬁle and encrypt the classes.dex
in the existing .dex ﬁle within an APK. The new .dex is decrypted in mem-
ory during runtime using DexClassLoader, a Java class loader [Google 2016;
Apvrille and Nigam 2016; SecNeo 2015]. Packers were developed for Android platform
to protect the legitimate app from unwanted tampering and modiﬁcations. However,
malware developers use packers to obfuscate the dalvik bytecode and evade anti-
malware scanners.

5.1. Code Packers

Packing encrypts the executable code to prevent static analysis. The unpacker rou-
tine brings the code in readable form. Malware developers employ executable code
packers to evade reverse engineering of malicious DEX. The runtime unpacking rou-
tine brings the code into its original form. The code protectors can also be used in
conjunction with existing obfuscation techniques to harden static analysis. Figure 8
illustrates working of code packers.

Fig. 8: Code Packing steps.

APK Protect6: is a professional code packing tool with anti-debug, anti-decompile
and anti-disassembly support [Protect 2015]. The packer performs code obfuscation
with string encryption with Base64 encoding. It employs Java reﬂections to load the
code dynamically. APK Protect has following features: (i) debugger detection; (ii) app
encryption; (iii) code reﬂections; (iv) anti-debugging; (v) anti-disassembly; and (vi) anti-
decompilation.

HoseDex2Jar7: is an executable packer to encrypt .dex, repackage encrypted ﬁle,
and store inside 112 header bytes of the target .dex. Figure 9 illustrate code packing
procedure with HoseDex2Jar. The code packer performs: (i) .dex repackaging; and (ii)
code encryption.

6https://sourceforge.net/projects/apkprotect/ (accessed August, 2016.)
7 https://github.com/strazzere/dehoser (accessed August, 2016.)

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:21

Fig. 9: HoseDex2Jar Packer.

Bangcle:8 is an online APK packing tool [SecNeo 2015]. The developer must register
at the Bangcle and use Bangcle Assistant tool to upload the package. The app must be
uploaded with the Keystore to retrieve the protected APK. The packing process changes
the APK name, inserts new assets, native libraries and modiﬁes the Android manifest.
Figure 10 illustrates the code packing procedure. Bangcle packer provides (i) online
APK wrapping; (ii) resists reverse engineering; (iii) online anti-debugging, anti-tamper
and anti-decompilation service.

Fig. 10: Functioning of Bangcle Packer.

PANGXIE9: is a Proof-of-Concept (PoC) packer armed with anti-debugging and anti-
tampering techniques [Strazzare 2014]. The packer encrypts the .dex bundled inside
the assets of an APK. Though, PANGXIE evades static analysis, the obfuscator in-
creases the APK size. Figure 11 illustrates the code unpacking procedure based on
runtime execution.

8https://www.crunchbase.com/organization/bangbang-security/entity (accessed August, 2016.):
9 http://www.packers.com/ (accessed August, 2016.)

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:22

P. Faruki et al.

Packed File during
Static Analysis

In Memory during
Execution

APK FILE

APK FILE

Stub Dex File

Stub Dex File

Injected Code

Injected Code

File System

Decrypted 
Dex File

Fig. 11: Unpacking procedure during Dynamic analysis.

5.2. Comparison of Obfuscation and Protection Techniques

In the following, we evaluate the effectiveness of Packers based on following at-

tributes illustrated in Table III.

Code Obfuscation: This technique prevents the analysis of the code either at
source code or bytecode level [Collberg and Thomborson 2002]. The Android Inte-
grated Development Environment (IDE) has Proguard, an in-built obfuscator to trans-
form the Java class names, ﬁelds, and method names [Android 2015b]. Addition-
ally, the persistent methods like control-ﬂow obfuscation, reorder program ﬂow, read-
able string encryption, and dynamic code loading has been employed by recent mal-
ware [Rastogi et al. 2014; Zheng et al. 2012]. Furthermore, the app developers also use
Java Reﬂection methods and invoke the native code functionality using Java Native
Interface (JNI) to hinder static analysis.

Dynamic Code Modiﬁcation: Android user apps, developed in Java are converted
to Dalvik bytecode using Dx tool [Google 2016; Lin 2015], part of Android SDK. Dalvik
Virtual Machine (DVM) veriﬁes the bytecode, and executes it in the VM. It is difﬁcult
for a programmer to modify bytecode from VM during runtime. Malware developers
use Java Native Interface (JNI) methods to modify and load the bytecode at runtime
DVM [Qian et al. 2014]. ART pre-compiles the .dex ﬁle as oat in the ELF format. To
avoid precompilation, the native code modiﬁes the instructions of .dex and .oat data
structures.

Dynamic Code Loading: Android permits loading of external .jar or a .dex at
runtime. The executable code appears different compared to its static visuals. Malware
authors leverage this facility by encrypting the malicious executable, then decrypting
and loading them in the VM at runtime.

Anti-debugging: Android kernel has in-built GNU debugger (gdb) to attach pro-
cess for debugging. Packers get attached to Ptrace [Lin 2015] tool to evade gdb under
the assumption that only a single process can be attached to the target process for mon-
itoring. Hence, the gdb cannot attach itself to the APK; preventing the APK debugging.
Advanced Packers identify Java Debug Wire Protocol (JDWP) threads being attached
to an APK. Furthermore, the Packers can identify themselves being monitored within
emulated environment.

Table III illustrates a comparison of the crucial methods prevalent among the lead-
ing Packers based upon their properties. The Android Packers are a new phenomenon

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:23

and evolving quickly. We examined known malicious apps on portals and packed with
stand alone Packers during October and November 2015. Table III shows that all of the
Packers use one or more code obfuscation techniques and append shared library. The
comparison shows that few Packers support ART. Except Bangcle and Ijiami, other
packers are not equipped to perform runtime modiﬁcations.

Packer

Code
Obfuscation

Dynamic
Code
Loading

Dynamic
Code
Modiﬁcation

Debugger
Detection

Append
shared
Libraries

Additional
Class
insertion

DVM
Support

ART
Support

Packer Protection Techniques

APKProtect

Ali

Baidu

Bangle

Ijiami

HoseDex2jar

Pangxie

Table III: Comparing packer protection methods

6. ANDROID BYTECODE ANALYSIS

In this section, we discuss various Dalvik bytecode de-obfuscation tools and tech-
niques. To de-obfuscate an APK, the reverse engineered bytecode must be available.
Hence, we discuss the Dalvik bytecode, as it is the nearest readable intermediate code
for disassembly and analysis [Faruki et al. 2014]. Figure 12 illustrates the process of
bytecode extraction and analysis of a normal Android APK ﬁle. This process is followed
by analysts and malware authors for their respective purpose.

6.1. Bytecode and De-Obfuscation Tools

In the following, we brieﬂy discuss open-source and commercial de-obfuscation tools.
the Android software development kit
Dexdump: Dexdump is a part of
(SDK) [Android 2015a]. Dexdump is a Dalvik executable (dex) ﬁle dissection tool that
can be used to disassemble Dalvik bytecode. Dexdump is a linear sweep disassembler
that ﬁnds a valid instruction at the last byte of the instruction being analyzed. Linear
sweep disassembler can be circumvented easily by inserting the junk bytes to prevent
the disassembly.

Smali: Smali is a Dalvik bytecode assembler [smali 2015]. The package contains
baksmali to disassemble the assembled code. Hence, both smali and baksmali can
be used to disassemble, modify and reassemble the Android apps [DexGuard 2015b].
Baksmali performs recursive disassembly by following the address of jump towards
the current instruction.

Androguard: Desnos proposed Androguard, an open-source static analysis tool to
reverse engineer the APK ﬁles [Desnos 2015]. Androguard has a recursive disassembler
and semantic analysis methods to identify similarity, dissimilarity, call graph analysis
and signature of malicious apps. It provides a graphical preview of call graphs to assist
the human analyst to detect cloned and repackaged APK ﬁles.

APKInspector: APKInspector is static, bytecode analysis tool. APKInspector lever-
ages Ded [ded 2015], Smali/Baksmali [smali 2015], APKtool [APKTool 2015] and An-

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

✔
✔
✔
✔
✔
✔
✔
✗
✔
✔
✔
✔
✔
✔
✔
✗
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✗
✔
✔
✔
✔
✔
✔
✔
✗
✔
✔
✔
✔
✔
✔
✔
✗
✔
✗
✗
✔
✗
✔
✗
✗
✗
✗
✔
✔
✗
00:24

P. Faruki et al.

droguard [Desnos 2015] to reverse engineer APK bytecode. APKInspector performs:
(i) meta-data analysis; (ii) sensitive permission usage; (iii) generates bytecode control-
ﬂow graph; (iii) generates call-graph with call-in and call-out structures.

dex2jar: dex2jar is a disassembler to parse both the dex and optimized dex ﬁles,
providing a lightweight API to access [Dex2Jar 2013]. dex2jar can also convert dex
to a jar ﬁle, by re-targeting the Dalvik bytecode into Java bytecode. Moreover, it is
possible to re-assemble the jar into a dex after modiﬁcations.

Dare: Dare project aims at re-targeting Dalvik bytecode within classes.dex to
traditional .class ﬁles using strong type inference algorithm [Octaeu et al. 2015].
This .class ﬁles can be further analyzed using a range of traditional tech-
niques developed for Java applications,
including the de-compilers. Octeau et
al. [Octeau et al. 2012] demonstrated that Dare is 40% more accurate than dex2jar.

Dedexer: Dedexer tool [Paller 2015] disassembles the classes.dex into Jasmin,
an intermediate code format. Furthermore, it creates a separate ﬁle for each class
to maintain the package directory structure for easy readability [Wognsen 2012;
Wognsen et al. 2014]. However, unlike the apktool, it cannot re-assemble the inter-
mediate disassembled class ﬁles.

JEB: JEB [jeb 2013] is a leading professional Android reverse-engineering software
available on Windows, Linux, and Macintosh. The GUI interactive decompiler ana-
lyzes reversed malware app content. App information such as manifest, resources, cer-
tiﬁcates, literal strings can be examined in Java source by providing an easy navigation
through the cross-references. JEB converts Dalvik bytecode to Java utilizing Dalvik
bytecode semantics. JEB has de-obfuscator for obfuscated bytecode [Dex2Jar 2013;
APKTool 2015]. JEB supports plugins by allowing access to the decompiled Java code
Abstract Syntax Tree (AST) through API. The feature is useful to perform custom
analysis.

IDA Pro: IDA Pro [HexRays 2015] is a commercial recursive disassembler popu-
lar for x86 platform. The IDA 6.0 onwards supports the Android Dalvik bytecode
disassembly. IDA has a complete GUI with options to extend the functionality with
supported API plugins to extend analysis functionality. IDA Pro has an additional ca-
pability to disassemble speciﬁc parts of the code in a ﬁle selected by the user. Dalvik
bytecode can be represented as a graph making it easy to follow the control ﬂow within
a program.

Dexter: Dexter is a free online analysis service [Labs 2015] and static analysis tool
to process an input APK ﬁle. It provides rich information about: (i) APK permission; (ii)
obfuscated code and packages; and (iv) mapping between broadcast receivers and the
data-store.

Dexguard: Dexguard is a set of scripts to perform automated strings de-obfuscation
and recovery of the dex ﬁle [Bremer 2015]. This tool is a mix of static and dynamic
analysis consisting of (i) dex File reader; (ii) Dalvik disassembler; (iii) Dalvik emulator;
and (iv) dex File parser.

Radare2: Radare2 [QuantumG and Emmerik 2014b]

is an interactive byte-
code disassembly and analysis tool with precise control during reverse engi-
neering procedure. Radare2 decompiles the code using open-source decompiler
boomerang [QuantumG and Emmerik 2014a]. This tool is a recursive disassembler
that allows a user to specify starting address for decompilation. The hybrid approach
makes Radare2 more efﬁcient against smart obfuscation techniques in comparison to
other approaches.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:25

Java Source
Code

.Class file

Java 
Compiler

dx 
Converter

.xml file

Manifest file

Resources

aapt 
Converter

Disassembly 

Unsigned 
APK File

.dex file

Encoded 
.xml file

Encoded 
Manifest 

Resource 
table

Dalvik bytecode 

APK Tool

AndroidManifest

apktool.yml

assets

lib

res

Smali

Intermediate code

Signed
.apk

.dex file

Encoded 
.xml file

Encoded 
Manifest 

Resource 
table

Resources

JarSigner

Resources

Fig. 12: Disassembly of an APK ﬁle

APK Re-assembling

6.2. Stealth Obfuscation

Malware writers employ different code protection techniques to delay the malware
being reverse engineered. Android malware is following the footsteps of Windows mal-
ware evolution with the recent addition of code packing tools. The Packers are used to
generate unseen variants of known malware apps, further increasing the pressure on
signature-based commercial anti-malware. In this section, we discuss the techniques
that are possibly useful to hide the malicious code. Bremere et al. in [bremer 2013]
demonstrated the possibility of bytecode injection inside any class having a virtual
function. Such techniques can be used by attackers to serve the evil intents like:

(1) To develop a benign app capable of bytecode interpretation and loading.
(2) To read the bytecode from APK or a remote host.
(3) To inject the malicious bytecode inside a benign app.

At present, this technique is limited to return integer values. However, malware au-
thors can misuse the extended version to inject malicious bytecode at runtime. Authors
in [Apvrille 2013a] demonstrated a Proof-of-Concept code to hide the Dalvik methods
against the reverse engineering tools. Furthermore, they presented the methods to de-
tect such hidden methods. Malware authors can place the malicious logic within such
hidden methods and evade anti-malware. However, the authors also developed the
Hidex tool [Apvrille 2013b] to detect invisible methods.

In [Apvrille 2014], the authors developed several methods capable of manipulating
the AES or DES algorithm output and represented the malware payload as custom
PNG, JPG or a sound ﬁle. Furthermore, the authors demonstrated that such payloads
remain undetected with the anti-malware. Malware authors may well be interested
in hiding malware APK inside the assets or resource folders. Besides, malware author
can develop a genuine APK including the customized JPG as its asset. The malicious
app loads the asset at runtime to execute malicious behavior. Following protection,
obfuscation, and optimization techniques are interesting:

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:26

P. Faruki et al.

(1) Using Proguard from Android SDK to protect apps proprietary logic: Proguard
performs variable renaming, leaving the class name un-obfuscated. Hence, it is
easy to identify the obfuscated class as its methods are modiﬁed but the class name
remains un-obfuscated.

(2) Strings encoded with Base64: malware authors exploit various forms of string
transformations such as string encryption using arrays, non-ASCII character re-
placement or, hides resource ﬁles inside the strings encrypted with Base64 encod-
ing methods. Thus, the binary data can also be hidden as Base64 encoded strings.
(3) Dynamic loading: it allows the external code to be downloaded at runtime in an
APK. This technique has also been used by malware authors as discussed in Ta-
ble IV. For the initial automation phase, its presence was only detected by pattern
matching check of the classes for the packages.

(4) Native Code: identiﬁes the presence of native code by ﬁltering the class deﬁnition
table to verify the usage of application code accessing the system related informa-
tion and resources or interfacing with the runtime environment.

(5) Reﬂection: the classes deﬁnition table was ﬁltered for the presence of the Java

reﬂection packages for access to methods, ﬁelds and classes.

(6) Header size: bytecode injection inside the classes.dex header can be exploited
by taking advantage of discrepancy between the dalvik bytecode documentation
and the ﬁle.

(7) Encoding: it veriﬁes the presence of mixed endianness with a ﬂag check.
(8) Cryptographic code: javax.crypto and java.security.spec packages provide
facilities to implement encryption/decryption in classes and interface application
to study misuse of cryptographic functionality.

Malware authors have misused the existing code protection and obfuscation meth-
ods to evade the commercial anti-malware. Table IV summarizes malware obfusca-
tion chronology and illustrates the methods and tools used by to obfuscate APK ﬁles.
Malware writers leveraged custom encryption, string encryption, and URL encryp-
tion. They encrypted network communications and encoded URLs. The recent malware
apps exploit sophisticated techniques like steganography and code obfuscation tools to
harden the malware reverse engineering.

In 2013, malware developer used Dexguard to evade the anti-malware. The mal-
ware writers pushed Javascript payloads inside the resource folder and encrypted non-
Dalvik code in the obfuscated apps. Some malware samples developed in the year 2014
employed online Packing tool services apart from string encryption and obfuscation.
Additionally, malware writer encrypted data.xml ﬁles inside APK archive to evade
anti-malware and harden reverse engineering. Dendroid [Rogers 2014] is a stealth re-
mote administration toolkit employing hidden behavior sending premium-rate SMS,
voice calls, recording audio video without user consent. The Trojan evades the exist-
ing commercial anti-malware techniques. Elish et al. [Elish et al. 2015] proposed user-
intention based anomaly detector to detect such stealth malicious apps.
7. EXISTING SURVEYS AND RELATED WORK

Shabtai et al. [Shabtai et al. 2010] proposed an Android threat taxonomy on An-
droid platform. In [Vidas et al. 2011], the authors survey different attack vectors, and
discuss the attack taxonomy on Android. In [Zhou and Jiang 2012], authors, carried
out Android malware characterization of 49 Android malware families. The authors
reported simple obfuscation techniques employed by malware such as Anserver, and
Bgserv. Enk et al. [Enck et al. 2011] discussed the existing research, primarily tar-
geting Android platform. The authors reviewed the Android platform security and
app analysis methods. Furthermore, the authors discussed limitations of analysis
techniques like rule-based detection, ex-ﬁltration of sensitive information and inter-

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:27

Malware

Year

Obfuscation/Encryption/

Protection/Optimization Method

Tool/Technique used

SlemBunk

2015

Code Obfuscation

Class, Method and Field Obfuscation

Trojan.Dropper.RealShell

2015

Custom APK Obfuscation

Stores ﬁles in Assets Folder

Dendroid.A!tr

SmsSend.ND

Freejar.B

RuSMS.AO

2014

Obfuscated with Dexguard

Dexguard Tool

2014

Packed with APKProtect Packer

Code Packing Tool

2014

Packed with Bangcle Packing service

Online code packing Service

2014

Strings obfuscated, using Adobe Airpush like name

Custom string encryption

SmsSpy.HW!tr.spy

2014

“data.xml” ﬁle is encrypted with Blowﬁsh algorithm

Custom symmetric encryption

Agent.BH!tr.spy

2014

Sends encrypted emails using TL security

Custom encryption

Rmspy.A!tr

oBad

2013

Obfuscated with Dexguard

2013

Obfuscated with Dexguard

Android.Ginmaster

2013

Custom String encryption

Dexguard obfuscator

Dexguard obfuscator

Custom encryption

Android/GinMaster.L

2013

String obfuscation with string table in array

Custom encryption

Stels.A!tr

2013

Custom encoding URL text with Base64

Custom encoding

Pincer.A!tr.spy

2013

Caeser cipher to hide text and telephone No.

Symmetric encryption algorithm

GinMaster.B

2013

Encrypts IMEI, IMSI and strings with Triple DES

Custom symmetric encryption

FakeDefend.A!tr

2013

Encrypted fake infections with AES algorithm

Block cipher encryption

2013

Non Dalvik, Javascript payload in resources

Non Dalvik code encryption

FakePlay.B!tr

SmsSend.N

Plankton.B!tr

2012

Obfuscated with Proguard

2012

Obfuscated with Proguard

DroidKungFu.D!tr

2012

Obfuscated with Proguard

Proguard obfuscator

Proguard obfuscator

Proguard obfuscator

FakeInst.A!tr.dial

2012

PNG ﬁle stores SMS text body and phone numbers

Steganography

NotCompatible.Android!tr.bdr

2012

Encrypted C&C URL in resource folder with AES

Block Cipher encryption

DroidKungFu.G!tr

2012

ELF payload stored as “mylogo.jpg ”

Non Dalvik code encryption

Pjapps.A!tr

2011

Encoded URL

URL encryption

Android/SmsSpy.HW!tr

2011

Encrypted with symmetric key Blowﬁsh algorithm

Symmetric encryption

Android/RootSmart

2011

Symmetric key encryption DES, AES and Blowﬁsh

Block cipher encryption

BaseBridge.A!tr

2011

String encrypted in an array

Encrypted strings

Geinimi.A!tr

2011

Encrypted network communication & obfuscated codes

custom encryption and obfuscation

Table IV: Malware Obfuscation chronology [Apvrille 2014; Apvrille and Nigam 2016;
Apvrille 2013a; Zhou et al. 2012; Inc. 2013; SecNeo 2015]

application privilege escalation attacks. However, the code obfuscation and protection
techniques are not covered in the proposed analysis techniques. The proposed review
gives an extensive insight into the obfuscation techniques and code protection meth-
ods. Furthermore, the review compares various code obfuscation and de-obfuscation
techniques employed by malware authors and anti-malware industry.

Tangil et al. [Suarez-Tangil et al. 2014] discuss the evolution of mobile malware,
their infection and distribution techniques and detail them with different case stud-
ies. The authors survey the greyware and malicious app detection techniques between
2010 and 2013. Furthermore, the authors discuss various research problems, brieﬂy
discussing the impact of malware detection. In [Faruki et al. 2015], authors discuss
the Android security issues, malware penetration and various defense methods for
app analysis and mobile platform security. Furthermore, the authors brieﬂy review

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:28

P. Faruki et al.

obfuscation techniques. However, they concentrate more on malicious repackaging, a
common problem with Android apps.

In [Kovacheva 2013], authors focus on developing efﬁcient Dalvik bytecode obfusca-
tion techniques. They study the Google Play apps to identify the feasibility of availing
the source code with reverse engineering tools. Authors propose efﬁcient obfuscator
design to defeat the existing de-obfuscation tools (i.e., smali, dedexer, ded). Schulz
et al. [Schulz 2014] performed Android bytecode de-obfuscation feasibility. The au-
thors evaluated analysis methods to automate de-obfuscation of Dexguard obfuscated
code. Rastogi et al. [Rastogi et al. 2014] evaluated commercial anti-malware against
trivial code obfuscation techniques. Faruki et al. [Faruki et al. 2014] compare the per-
formance of anti-malware, and static analysis tools against popular x86 transforma-
tion attacks. Harrison et al. [Harrison 2015] investigate the effect of code obfuscation
on Android. They evaluate the limitations of reverse engineering tools against app
repackaging.

Schrittwieser et al. [Schrittwieser et al. 2016] evaluate smartphone code protection
techniques. The authors analyze and evaluate software de-obfuscation techniques. The
survey is more general targeting software protection techniques and analysis methods.
However, our target is, Android speciﬁc obfuscation techniques.

The proposed review is a comprehensive discussion on source code obfuscation,
code protection, Android speciﬁc obfuscation, and code protection tools. To the
best of our knowledge, we are the ﬁrst to investigate code protection and mal-
ware obfuscation techniques for the Android platform. We discuss Collberg taxon-
omy [Collberg and Thomborson 2002], and expand source code, and bytecode obfus-
cation taxonomy.

the

native

malicious

8. FUTURE RESEARCH DIRECTIONS
Malware such as Android/DroidCoupon.A!r, and AndroidSmsZombie.A!.tr
hide
PNG
as
ﬁles [Axelle Apvrille 2015],
[Apvrille and Nigam 2016]. However, the assets are
payloads just named as graphic ﬁles. Making fake payload with such tricks is
prevalent on Android malware applications. Furthermore, authors in [Apvrille 2014]
developed a Proof-of-Concept (PoC) AngeCryption [Apvrille 2014] to illustrate the
possibility of encrypting any given input stored as an image (JPG, PNG). In particular,
an attacker can develop a benign APK ﬁle to hide a malicious image inside resource
or asset to evade the anti-malware.

payloads

JPG,

or

The unsuspected image containing malicious payload can be used to execute the
malicious code. Such an attack may not be noticed at all, as the APK does not contain
obfuscated, protected or wrapped content.

AngeCryption has demonstrated a PoC on the latest Android OS version. Thus, a
malicious dex ﬁle can be embedded inside an image. Furthermore, it can be obfuscated
with obfuscation tool. The dynamic code loading techniques can be used to execute the
malicious payload. At present, methods to detect such attacks are not available. The
functioning of such payloads cannot be determined before runtime image decryption.
The suggested remedy that we aim to investigate in the future are: (i) keep tab on an
APK that decrypts its resource or assets (such apps can be analyzed dynamically to
identify suspicious behavior); (ii) analyze image decryption to an APK as malicious.

The Android devices have constrained processing and limited storage. Obfuscation
techniques does have an adverse impact on battery consumption. The power manage-
ment is an important issue to identify impact of code level modiﬁcations. The Android
Obfuscation has a APK statistical signiﬁcance [Sahin et al. 2016]. An important future
work is to consider a large set of obfuscated APK empirical evaluation. The same can
be extended to different mobile OS and devices. Since the developers do not have access

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:29

to tools like CARAT [Peltonen et al. 2016], they cannot identify the impact on energy
consumption. The ability to identify the impact is important for resource constrained
Android devices.

existing
concentrated

The Android apps have a lot of user interaction and string usage. The malware au-
thors use string encryption and obfuscation techniques to hide the plaintext strings.
In this paper, we have discussed notable malicious apps using such encryption tech-
niques. The authors can implement inter-component communication based inter-
procedural static analysis to reconstruct the encrypted strings to obtain insight into
the string information. Furthermore, authors in [Vsquez et al. 2014] empirically eval-
uated third-party library and obfuscated code usage. To monitor the apps, we propose
to identify the third-party libraries to identify APK cloning. The common use of Google
advertisement network, Facebook ad libraries impacts the categorization. As a part of
future work, we plan to delink the library code from APK ﬁles and evaluate obfuscated
code.
The

heav-
ily
ma-
licious
[Armknecht et al. 2013]
[Brumley et al. 2013]. The relevant literature evaluates obfus-
[Xing et al. 2014]
cation techniques prominently among malicious applications. The real identiﬁcation
of obfuscated code among the normal programs which is important for software pro-
tection, is ignored. The non-malicious code reverse engineering is largely unexplored.
Targeting program obfuscation and related techniques for protecting the digital rights
is an interesting future direction. Inspite of the existing research on obfuscation,
evaluation matrices to verify the existing obfuscation technique resilience are not
available. Formal analysis techniques to evaluate obfuscation and de-obfuscation tech-
niques is still not available. Hence, we summarize code obfuscation, de-obfuscation
tools and techniques to understand the effect in isolation. It would be interesting to
combine different class of obfuscation techniques, and evaluate existing de-obfuscation
tools.

obfuscation
analysis

academic
more

[Zeng et al. 2013]

code
towards

applications

obfuscated

research

of

is

9. CONCLUSION

Android, currently the most popular mobile OS platform is eight-year-old. The
growth and commercial value has attracted the research community and malware au-
thors alike. Since the mobile OS is fast evolving, code protection techniques are imple-
mented by the app developers to harden the reverse engineering of the code propriety.
On the other hand, malware authors are using the protection techniques to delay the
code reverse engineering.

In this survey, we address important and speciﬁc questions about obfuscation and
code protection techniques on mobile platform. In the existing obfuscation research,
evaluation techniques to assess resilience of obfuscation are still not available. Code
analysis and de-obfuscation techniques have similar limitations. We performed review
of the existing code obfuscation and analysis techniques isolated from one another. We
discuss the details of code protection, optimization and obfuscation technique. Further-
more, we explore custom code protection techniques employed by malware authors to
hide malicious payloads. Obfuscation tools and techniques also depends on availabil-
ity of resources for reverse engineering. Existing tools (e.g., Androguard, JEB, dex2jar)
de-obfuscate custom code examples; however, they fail to decode real-world programs.
The complexity of a problem may outdo the existing resources. Hence, simple obfus-
cation techniques can be effective on resource constrained devices. This is one of the
reason of its popularity among malware authors. The ongoing challenge between code
protection and analysis techniques is growing. Speciﬁc obfuscation methods are effec-

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:30

P. Faruki et al.

tive in certain situations. Given time and effort, existing obfuscation techniques can
be decoded by human analyst.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:31

A. OBFUSCATION CODE EXAMPLES

In the following, we discuss FakeInstaller, stealth Android malware em-
ploying different class of obfuscation to evade anti-malware. Listing 30 reverse
jeb 2013]
engineered code of FakeInstaller [fak 2012; Rasthofer et al. 2015b;
at line number 1 checks for the presence of emulator, an alibi
for develop-
ment environment, or automated analysis system. In line number 9, class and
method names are obfuscated to erase the program semantics. For example, a
is decrypted to Android
random string value “VQIf3AInVTTnSaQI+R]KR9aR9”,
android.telephony.SmsManager class. This class is loaded using reﬂection API
at runtime to evade static analysis. The class sends premium-rate SMS without ex-
plicit user consent. The string “BaRIta*9caBBV]a” is decrypted to SendTextMessage
method. Furthermore, in line number 21 getMethod sends the SMS using the text
from the parameters p1 and p2, declared in line number 1. Here, the use of multi-
ple obfuscation, evasion and code protection techniques successfully evades the static
analysis.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24

// Fakeinstall obfuscated code
public static boolean gdadfjrj(String p1,String p2){ [...]

// Anti analysis check to evade emulator

if (zhfdghfdgd()) return;

// Get class instance
Class clz = Class.

forName(gdadfjrj.gdafbj("VQIf3AInVTTnSaQI+R]KR9aR9"));
Object localObject = clz.getMethod(gdadfjrj.gdadfjrj("]a9maFVM.9"), newClass[0])
.invoke(null, new Object[0]);

// Get the method name
String s = gdadfjrj.gdadfjrj("BaRIta*9caBBV]a");

// Build parameter list
Class c = Class.forName(gdadfjrj.gdadfjrj("VQIf3AInVTTnSaQI+R]KR9aR9"));
Class[] arr = new Class[]
{nglpsq.cbhgc, nglpsq.cbhgc, nglpsq.cbhgc, c, c };

// Reflection for invoking the method to send SMS
clz.getMethod(s, arr).invoke(localObject, newObject[] { p1, null, p2, null,null });

Listing 30: Fakeinstall Obfuscation [fak 2012; Rasthofer et al. 2015b]

The partial code snippet in Listing 31 is a variant of zitmo [Li et al. 2015]. As illus-
trated, when the SMS is received, framework callback onReceive() is invoked to stop
the broadcast to default SMS app. The abortBroadcast() method aborts the current
broadcast. Then, an intent that carries the SMS is launched inside the MainService,
a background service task. Further, the stored SMS from the intent is accumulated
in the array called “pdus”. The sender identiﬁcation and message parts are extracted
by getOriginatingAddress() and getMessageBody() methods. Furthermore, the
available values of the “pdus” object are stored inside variables s1, s2 along with
the device Id using method getDeviceId(). The information is encoded inside the
UrlEncodedFormEntity object. Further, the constant URL string is then encoded
with setEntity() to post the data using execute() method.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:32

P. Faruki et al.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

public class mysmsReceiver extends BroadcastReceiver
{

public void onReceive (context pcontext, intent pintent)
{

bundle localBundle=pintent.getExtras();

if((localBundle != null)&&(localBundle.containsKey("pdus")))

abortBroadcast();
Intent.targetService=newIntent(pcontex, MainService.class);

targetService.putExtra("pdus",localBundle);
pcontex.startService(ts);

{

}

}

}

public class MainService extends Service
{

public int onStartCommand(Intent pintent, int pintent1, int pintent2){
Bundle localBundle=pintent.getBundle("pdus");

SmsMessage localSMS=SmsMessage.createFromPdu("pdus");
String S1 = localSMS.getOriginatingAddress ();
String S2 = localSMS.getMessageBody ();
String S3 = localTM.getDeviceId();}

public void postRequest(urlEncodedFormEntity UEFE)

String address="http://stringthrifty.com/security.jsp";

...
DefaultHttpClient ().execute(localHP, BRH);

{

}

}

Listing 31: SMS Obfuscation & IMEI exﬁltration [Li et al. 2015]

ACKNOWLEDGMENTS

The work of Parvez Faruki, Manoj Singh Gaur and Vijay Laxmi is supported by department of Infor-
mation Technology, Government of India project grant “SAFAL-Security Analysis Framework for Android
pLatform”. Hossein Fereidooni is supported by Deutsche Akademische Austauschdienst (DAAD fellow-
ship). Mauro Conti is supported by Marie Curie fellowship funded by the European Commission under
the agreement No. PCIG-GA-2012-321980. This work is partially supported by the TENACE PRIN Project
20123P34XC funded by Italian MIUR, and “Tackling Mobile Malware with Innovative Machine Learning
Techniques” funded by University of Padua.

REFERENCES

2012. FakeInstaller Leads the Attack on android Phones. https://blogs.mcafee.com/mcafee-labs/fakeinstaller-leads-the-attack-on-android-phones.

(Online; 2012).

2013. JEB Decompiler. http://www.android-decompiler.com/. (Online; Last Accessed 11th February, 2016

2013).

Accessed September, 2015. Android tools: ADB, dx, aapt, Emulator, dumpstate, monkey, logcat, sqlite3,

Ptrace. http://elinux.org/Android Tools. ([Online]; Accessed September, 2015).

Accessed September, 2015. ded: Decompiling Android Applications. http://siis.cse.psu.edu/ded/. ([Online];

Accessed September, 2015).

Allatori. Accessed November, 2015. Allatori Obfuscator. http://www.allatori.com/doc.html. ([Online]; Ac-

cessed November, 2015).

Android. 2013. Class to Dex Conversion with Dx. http://developer.android.com/tools/help/index.html. (On-

line;Last Accessed March 5 2013).

Android.

Accessed

November,

2015a.

Android

Open

Source

Project.

Android

sdk.

http://developer.android.com/sdk/index.html. ([Online]; Accessed November, 2015).

Google

Android.

accessed

September,

2015b.

Proguard — Android

Developers.

http://developer.android.com/tools/help/proguard.html. ([Online]; accessed September, 2015).

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:33

APKTool.

Accessed

March

20,

2015.

Reverse

Engineering

with

ApkTool.

https://code.google.com/android/apk-tool. ([Online]; Accessed March 20, 2015).

Appbrains.

Accessed

Android
http://www.appbrain.com/stats/number-of-android-apps. ([Online]; Accessed January, 2015).
Hide

Available

January,

Apvrille.

Number

Playing

Dalvik

2013a.

2015.

Seek

with

and

of

Axelle

Executables.

Apps.

http://www.fortiguard.com/uploads/general/hidex insomni.pdf.. (In Hack.Lu, 2013).

Axelle

Apvrille.

2013b.

Playing

Hide

and

Seek

with

Dalvik

Executables.

Hidex.https://github.com/cryptax/dextools/tree/master/hidex. (In Hack.Lu, 2013).

Axelle

Apvrille.

2014.

AngeCryption:

Hide

Android

Applications

in

Images.

https://www.blackhat.com/docs/eu-14/materials/eu-14-Apvrille-Hide-Android-Applications-In-Images-wp.pdf,.
([Online]; 2014).
Apvrille

Ruchna

Axelle

and
ANDROID

Nigam.
MALWARE,

Accessed
AND

IN

CATION
https://www.virusbtn.com/pdf/magazine/2014/vb201407-Android-obfuscation.pdf.
January, 2016).

HOW

January,
TO

OBFUS-
2016.
FIGHT
BACK.
([Online]; Accessed

Frederik Armknecht, Ahmad-Reza Sadeghi, Steffen Schulz, and Christian Wachsmann. 2013. A Security
Framework for the Analysis and Design of Software Attestation. In Proceedings of the 2013 ACM
SIGSAC Conference on Computer 38; Communications Security (CCS ’13). ACM, New York, NY, USA,
1–12.

Ruchna Nigam Axelle Apvrille. Accessed September, 2015. Obfuscation in Android malware, and how to
ﬁght back. http://www.strazzere.com/papers/DexEducation-PracticingSafeDex.pdf. ([Online]; Accessed
September, 2015).

Michael Batchelder and Laurie J. Hendren. 2007. Obfuscating Java: The Most Pain for the Least Gain.. In
CC (Lecture Notes in Computer Science), Shriram Krishnamurthi and Martin Odersky (Eds.), Vol. 4420.
Springer, 96–110.

Jurrian bremer. 2013. Abusing Dalvik beyond recognition. http://jbremer.org/wp-posts/AbusingDalvikBeyondRecognition.pdf.

(In Hack.Lu, 2013).

Jurrian Bremer. Accessed October, 2015. Automated Deobfuscation of Android Applications.
([Online]; Accessed October,

http://jbremer.org/automated-deobfuscation-of-android-applications/.
2015).

David Brumley, JongHyup Lee, Edward J. Schwartz, and Maverick Woo. 2013. Native x86 Decompilation
Using Semantics-Preserving Structural Analysis and Iterative Control-Flow Structuring. In Presented
as part of the 22nd USENIX Security Symposium (USENIX Security 13). USENIX, Washington, D.C.,
353–368.

Carlos A. Castillo. 2012. Android Malware Past, Present, and Future. Technical Report. Mobile Working

Security Group McAfee.

Collberg. Accessed June 24., 2015. Obfuscation Techniques

for

enhancing software

security.

www.patents.com/us-6668325.html. ([Online]; Accessed June 24., 2015).

Christian Collberg, Clark Thomborson, and Douglas Low. 2002. A Taxonomy of Obfuscating Transforma-
tions. https://researchspace.auckland.ac.nz/bitstream/handle/2292/3491/TR148.pdf. ([Online]; 2002).
Christian S. Collberg and Clark Thomborson. 2002. Watermarking, Tamper-Prooﬁng, and Obfuscation -
Tools for Software Protection. SOFTWARE ENGINEERING, IEEE TRANSACTIONS ON 28, 8 (2002),
735–746.

Jonathan Crussell, Clint Gibler, and Hao Chen. 2013. AnDarwin: Scalable Detection of Semantically Similar
Android Applications. In Computer Security ESORICS 2013, Jason Crampton, Sushil Jajodia, and
Keith Mayes (Eds.). Lecture Notes in Computer Science, Vol. 8134. Springer Berlin Heidelberg, 182–
199.

Lucas Davi, Alexandra Dmitrienko, Stefan N ¨urnberger, and Ahmad-Reza Sadeghi. 2012. XIFER: A Software
Diversity Tool Against Code-Reuse Attacks. In ACM International Workshop on Wireless of the Students,
by the Students, for the Students.

Desnos.

Android
2015.
http://code.google.com/p/androguard/. ([Online]; Accessed May, 2015).

Androguard,

Accessed

May,

Static

analysis

Tool.

Dex2Jar. 2013. Android Decompiling with Dex2jar. http://code.google.com/p/dex2jar/. (Online;Last Accessed

May 15 2013).

DexGuard. Accessed November, 2015b. How does DalvikVM handle switch and try smali code.
http://stackoverﬂow.com/questions/14100992/how-does-dalvikvm-handle-switch-and-try-smali-code.
([Online]; Accessed November, 2015).

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:34

P. Faruki et al.

DexGuard. Accessed

September,

2015a. DexGuard, Android Dalvik Executable Protector.

https://www.saikoa.com/dexguard. ([Online]; Accessed September, 2015).

Karim O. Elish, Xiaokui Shu, Danfeng (Daphne) Yao, Barbara G. Ryder, and Xuxian Jiang. 2015. Proﬁling
User-trigger Dependence for Android Malware Detection. Comput. Secur. 49, C (March 2015), 255–273.
William Enck, Damien Octeau, Patrick McDaniel, and Swarat Chaudhuri. 2011. A Study of Android Applica-
tion Security. In Proceedings of the 20th USENIX Conference on Security (SEC’11). USENIX Association,
Berkeley, CA, USA, 21–21.

P. Faruki, A. Bharmal, V. Laxmi, V. Ganmoor, M.S. Gaur, M. Conti, and M. Rajarajan. 2015. Android Secu-
rity: A Survey of Issues, Malware Penetration, and Defenses. Communications Surveys Tutorials, IEEE
17, 2 (Secondquarter 2015), 998–1022.

Parvez Faruki, Ammar Bharmal, Vijay Laxmi, Manoj Singh Gaur, Mauro Conti, and Muttukrishnan Ra-
jarajan. 2014. Evaluation of Android Anti-malware Techniques against Dalvik Bytecode Obfuscation.
In 13th IEEE International Conference on Trust, Security and Privacy in Computing and Communica-
tions, TrustCom 2014, Beijing, China, September 24-26, 2014. 414–421.

Parvez Faruki, Vijay Ganmoor, Vijay Laxmi, M. S. Gaur, and Ammar Bharmal. 2013. AndroSimilar: Robust
Statistical Feature Signature for Android Malware Detection. In Proceedings of the 6th International
Conference on Security of Information and Networks (SIN ’13). ACM, New York, NY, USA, 152–159.
Michael Franz. 2010. E Unibus Pluram: Massive-scale Software Diversity As a Defense Mechanism. In
Proceedings of the 2010 Workshop on New Security Paradigms (NSPW ’10). ACM, New York, NY, USA,
7–16.

Karen Kent Frederick. 2002. Network Intrusion Detection Signature. http://securityfocus.org/infocus/1553.

([Online]; 2002).

freepatents. 2015. FPO IP Research and Communities. http://www.freepatentsonline.com/. ([Online]; 2015).
Techology Research Gartner. Accessed 17 Sept., 2014. Worldwide Traditional PC, Tablet, Ul-
in 2014.

tramobile and Mobile Phone Shipments Are On Pace
http://www.gartner.com/newsroom/id/2692318. ([Online]; Accessed 17 Sept., 2014).

to Grow 6.9 Percent

Clint Gibler, Ryan Stevens, Jonathan Crussell, Hao Chen, Hui Zang, and Heesook Choi. 2013. AdRob: ex-
amining the landscape and impact of android application plagiarism.. In MobiSys, Hao-Hua Chu, Polly
Huang, Romit Roy Choudhury, and Feng Zhao (Eds.). ACM, 431–444.

Google.

accessed

June

2016.

ART

and Dalvik — Android Open

Source

Project.

https://source.android.com/devices/tech/dalvik/. ([Online]; accessed June 2016).

The Guardian. Accessed 17 Sept., 2014. Three graphs to stop smartphone fans fretting about “market

share.”. http://www.theguardian.com/technology/2014/jan/09/market-sharesmartphones-iphone-android-windows.
([Online]; Accessed 17 Sept., 2014).

Sonali Gupta. September 2005. Obfuscating Data Structures. http://palisade.plynt.com/issues/2005Sep/code-obfuscation-continued.

([Online]; September 2005).

Rowena Harrison. 2015. Investigating the Effectiveness of Obfuscation Against Android Application Reverse
Engineering. Technical Report. Information Security Group, Royal Holloway University of London.
HexRays. Accessed March, 2015. IDA Pro, Disassembler. http://www.hex-rays.com/products/ida/index.shtml.

([Online]; Accessed March, 2015).

Heqing Huang, Sencun Zhu, Peng Liu, and Dinghao Wu. 2013. A Framework for Evaluating Mobile App
Repackaging Detection Algorithms. In Trust and Trustworthy Computing - 6th International Conference,
TRUST 2013, London, UK, June 17-19, 2013. Proceedings. 169–186.

Lookout Inc. 2013. Current World of Mobile Threats. Technical Report. Lookout Mobile Security.
Aleksandrina Kovacheva. 2013. Efﬁcient Code Obfuscation for Android.. In IAIT (Communications in Com-
puter and Information Science), Borworn Papasratorn, Nipon Charoenkitkarn, Vajirasak Vanijja, and
Vithida Chongsuphajaisiddhi (Eds.), Vol. 409. Springer, 104–119.

Dexter Labs. Accessed November, 2015. Dexter, Android Static Analysis Tool. http://dexter.dexlabs.org/.

([Online]; Accessed November, 2015).

Yongfeng Li, Tong Shen, Xin Sun, Xuerui Pan, and Bing Mao. 2015. Security and Privacy in Communication
Networks: 11th International Conference, SecureComm 2015, Dallas, TX, USA, October 26-29, 2015.
Springer International Publishing, Cham, Chapter Detection, Classiﬁcation and Characterization of
Android Malware Using API Data Dependency, 23–40.

Douglas Low. 1998. Java Control Flow Obfuscation. Technical Report.
Egil Aspevik Martinsen. 2008. Detection of Junk Instructions in Computer Viruses. Master’s thesis. Technis-

che Universitt Mnchen. https://www.duo.uio.no/bitstream/handle/10852/9943/Martinsen.pdf
24.,

Obfuscation

Accessed

Mcgill.

2015.

June

Java

Sable

Techniques.

www.sable.mcgill.ca/JBCO/examples.html. ([Online]; Accessed June 24., 2015).

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:35

Contagio

Minidump.

Accesed

December,

2014.

Backdoor.AndroidOS.Obad.a.

http://contagiominidump.blogspot.in/2013/06/backdoorandroid
osobada.html. ([Online]; Accesed December, 2014).

Damien Octaeu, Patrick McDaniel, and Somesh Jha. Accessed September, 2015. DARE: Dalvik Retargeting.

http://siis.cse.psu.edu/dare/. ([Online]; Accessed September, 2015).

Damien Octeau, Somesh Jha, and Patrick McDaniel. 2012. Retargeting Android applications to Java byte-
code. In Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Soft-
ware Engineering. ACM, 6.

Gabor Paller. accessed September, 2015. Dedexer. http://dedexer.sourceforge.net/.

([Online]; accessed

September, 2015).

Ella Peltonen, Eemil Lagerspetz, Petteri Nurmi, and Sasu Tarkoma. 2016. Constella: Crowdsourced sys-
tem setting recommendations for mobile devices. Pervasive and Mobile Computing 26 (2016), 71 – 90.
Thirteenth International Conference on Pervasive Computing and Communications (PerCom 2015).
Marjanne Plasmans. 2005. White-Box Cryptography for Digital Content Protection. Master’s thesis. TECH-

NISCHE UNIVERSITEIT EINDHOVEN.

Google

Play.

Accessed

January,

2015.

All

your

entertainment,

http://googleblog.blogspot.co.uk/2012/03/introducing-google-play-all-your.html.
January, 2015).

anywhere

go.
([Online]; Accessed

you

Mila Dalla Preda.

2007. Code Obfuscation and Malware Detection by Abstract

tation. PhD thesis. Universit‘a
https://www.sec.in.tum.de/assets/Uploads/MAHannesSchulz.pdf

degli Studi

di Verona, Dipartimento

di

Interpre-
Informatica.

APK Protect.

accessed September,

2015. APK Protect: Android APK Security Protection.

http://www.apkprotect.com/. ([Online]; accessed September, 2015).

Chenxiong Qian, Xiapu Luo, Yuru Shao, and Alvin T. S. Chan. 2014. On Tracking Information Flows through
JNI in Android Applications. In 44th Annual IEEE/IFIP International Conference on Dependable Sys-
tems and Networks, DSN 2014, Atlanta, GA, USA, June 23-26, 2014. 180–191.

QuantumG and Mike Van Emmerik. Accessed 17 Sept., 2014a. A general, open source, retargetable de-
compiler of machine code programs. http://boomerang.sourceforge.net/index.php. ([Online]; Accessed 17
Sept., 2014).

QuantumG and Mike Van Emmerik. Accessed September, 2014b. Unix-like reverse engineering framework

and commandline tool. https://github.com/radare/radare2. ([Online]; Accessed September, 2014).

Siegfried Rasthofer, Steven Arzt, Marc Miltenberger, and Eric Bodden. 2015a. Harvesting Runtime Data
in Android Applications for Identifying Malware and Enhancing Code Analysis. Technical Report. EC
SPRIDE.

Siegfried Rasthofer, Steven Arzt, Marc Miltenberger, and Eric Bodden. 2015b. Harvesting Runtime Data in
Android Applications for Identifying Malware and Enhancing Code Analysis. Technical Report TUD-
CS-2015-0031. EC SPRIDE.

Vaibhav Rastogi, Yan Chen, and Xuxian Jiang. 2014. Catch Me If You Can: Evaluating Android Anti-
Malware Against Transformation Attacks. IEEE Transactions on Information Forensics and Security
9, 1 (2014), 99–108. DOI:http://dx.doi.org/10.1109/TIFS.2013.2290431

Mark Rogers. Accessed October, 2014. Dendroid malware can take over your camera, record audio, and
sneak into Google Play. https://blog.lookout.com/blog/2014/03/06/dendroid/. ([Online]; Accessed October,
2014).

Giovanni Russello, Arturo Blas Jimenez, Habib Naderi, and Wannes van der Mark. 2013. FireDroid: Hard-
ening Security in Almost-stock Android. In Proceedings of the 29th Annual Computer Security Applica-
tions Conference (ACSAC ’13). ACM, New York, NY, USA, 319–328.

Cagri Sahin, Mian Wan, Philip Tornquist, Ryan McKenna, Zachary Pearson, William G.J. Halfond, and
James Clause. 2016. How Does Code Obfuscation Impact Energy Usage? Journal of Software: Evolution
and Process (2016). To Appear.

Sebastian Schrittwieser, Stefan Katzenbeisser, Johannes Kinder, Georg Merzdovnik, and Edgar Weippl.
2016. Protecting Software Through Obfuscation: Can It Keep Pace with Progress in Code Analysis?
ACM Comput. Surv. 49, 1 (April 2016), 4:1–4:37.

Hannes Schulz. 2014. Automated De-Obfuscation of Android Bytecode. Master’s thesis. Technische Univer-

sitt Mnchen. https://www.sec.in.tum.de/assets/Uploads/MAHannesSchulz.pdf

Patrick Schulz. 2012a. Code Protection in Android. https://net.cs.uni-bonn.de/ﬁleadmin/user upload/plohmann/2012-Schulz-Code Protection in Android.pdf.

([Online], Available 2012).

Patrick Schulz. 2012b. Dalvik-obfuscator Project github page. https://github.com/thuxnder/dalvik-obfuscator.

(Available Online 2012).

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

00:36

Patrick

November,
http://dexlabs.org/blog/bytecode-obfuscation. ([Online]; Accessed November, 2015).

Accessed

Android

Schulz.

2015.

Bytecode

P. Faruki et al.

Obfuscation.

SecNeo. accessed September, 2015. The Professional service provider for the mobile application security.

http://www.bangcle.com/. ([Online]; accessed September, 2015).

Asaf Shabtai, Yuval Fledel, Uri Kanonov, Yuval Elovici, Shlomi Dolev, and Chanan Glezer. 2010. Google

Android: A Comprehensive Security Assessment. IEEE Security and Privacy 8, 2 (2010), 35–44.

Yunhe Shi, Kevin Casey, M. Anton Ertl, and David Gregg. 2008. Virtual Machine Showdown: Stack Versus

Registers. ACM Trans. Archit. Code Optim. 4, 4 (Jan. 2008), 2:1–2:36.

SlideME. Accessed, Nov. 2014. All your entertainment, anywhere you go. http://slideme.org/. ([Online]; Ac-

cessed, Nov. 2014).

smali. Accessed October, 2015. Smali Dalvik bytecode assembler. http://code.google.com/p/smali/. ([Online];

Accessed October, 2015).

Mark Stamp and Wing Wong. 2006. Hunting for metamorphic engines. Journal in Computer Virology 2, 3

(December 2006), 211–229.

Strazzare. 2014. ANDROID HACKER PROTECTION LEVEL. https://www.defcon.org/images/defcon-22/\dc-22-presentations/Strazzere-Sawyer/DEFCON-22-Strazzere-and-Sawyer-Android-Hacker-Protection-\Level-\UPDATED.pdf.

(2014).

Strazzere. Available. Dex Education: Practicing Safe Dex. http://www.strazzere.com/papers/DexEducation-PracticingSafeDex.pdf.

([Online]; Available).

Tim

Strazzere.

Accessed

September,

2015.

Apkfuscator

Project

github

page.

https://github.com/strazzere/APKfuscator. ([Online]; Accessed September, 2015).

G. Suarez-Tangil, J.E. Tapiador, P. Peris-Lopez, and A. Ribagorda. 2014. Evolution, Detection and Analysis
of Malware for Smart Devices. Communications Surveys Tutorials, IEEE 16, 2 (Second 2014), 961–987.
Symantec. Accessed September, 2015. Remote Access Tool Takes Aim with Android APK Binder.
([Online];

http://www.symantec.com/connect/blogs/remote-access-tool-takes-aim-android-apk-binder.
Accessed September, 2015).

Sharath K. Udupa, Saumya K. Debray, and Matias Madou. 2005. Deobfuscation: Reverse engineering obfus-
cated code. In In Proceedings of the 12th Working Conference on Reverse Engineering. IEEE Computer
Society, 45–54.

Paul C. van Oorschot. 2003. Revisiting Software Protection.. In ISC (Lecture Notes in Computer Science),

Colin Boyd and Wenbo Mao (Eds.), Vol. 2851. Springer, 1–13.

Timothy Vidas, Daniel Votipka, and Nicolas Christin. 2011. All Your Droid Are Belong to Us: A Survey
of Current Android Attacks. In Proceedings of the 5th USENIX Conference on Offensive Technologies
(WOOT’11). USENIX Association, Berkeley, CA, USA, 10–10.

Mario Linares Vsquez, Andrew Holtzhauer, Carlos Bernal-Crdenas, and Denys Poshyvanyk. 2014.
Revisiting Android reuse studies in the context of code obfuscation and library usages. In
Proceedings of the 11th Working Conference on Mining Software Repositories. ACM, 242–251.
DOI:http://dx.doi.org/10.1145/2597073.2597109

Erik

Ramsgaard Wognsen.

Analysis
tion
Software
http://projekter.aau.dk/projekter/ﬁles/63640573/rapport.pdf

Android. Master’s

Static
thesis.

2012.

in

of

Dalvik
Engineering,

Bytecode

Aalborg

and

Reﬂec-
University.

Erik Ramsgaard Wognsen, Henrik Sndberg Karlsen, Mads Chr. Olesen, and Ren Rydhof Hansen. 2014.
Formalisation and analysis of Dalvik bytecode. Science of Computer Programming 92, Part A, 0 (2014),
25 – 55. Special issue on Bytecode 2012.

Gregory

Wroblewski.

2002.

General

Method

of

Program

Code

Obfuscation.

http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.9052. ([Online]; 2002).

Luyi Xing, Xiaorui Pan, Rui Wang, Kan Yuan, and XiaoFeng Wang. 2014. Upgrading Your Android, Elevat-
ing My Malware: Privilege Escalation Through Mobile OS Updating. In Proceedings of the 2014 IEEE
Symposium on Security and Privacy (SP ’14). IEEE Computer Society, Washington, DC, USA, 393–408.
Junyuan Zeng, Yangchun Fu, Kenneth A. Miller, Zhiqiang Lin, Xiangyu Zhang, and Dongyan Xu. 2013.
Obfuscation Resilient Binary Code Reuse Through Trace-oriented Programming. In Proceedings of the
2013 ACM SIGSAC Conference on Computer &#38; Communications Security (CCS ’13). ACM, New
York, NY, USA, 487–498.

Min Zheng, Patrick P. C. Lee, and John C. S. Lui. 2012. ADAM: An Automatic and Extensible Platform to

Stress Test Android Anti-virus Systems. In DIMVA. 82–101.

Wu Zhou, Xinwen Zhang, and Xuxian Jiang. 2013. AppInk: Watermarking Android Apps for Repackaging
Deterrence. In Proceedings of the 8th ACM SIGSAC Symposium on Information, Computer and Com-
munications Security (ASIACCS ’13). ACM, New York, NY, USA, 1–12.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

Android Code Protection via Obfuscation Techniques:Past, Present and Future Directions

00:37

Wu Zhou, Yajin Zhou, Xuxian Jiang, and Peng Ning. 2012. Detecting Repackaged Smartphone Applications
in Third-party Android Marketplaces. In Proceedings of the second ACM conference on Data and Appli-
cation Security and Privacy (CODASPY ’12). ACM, New York, NY, USA, 317–326.

Yajin Zhou and Xuxian Jiang. 2012. Dissecting Android Malware: Characterization and Evolution. In IEEE

Symposium on Security and Privacy’12. 95–109.

ACM Computing Surveys, Vol. 0, No. 0, Article 00, Publication date: 2017.

