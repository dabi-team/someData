An Agnostic 
Implementing 
Christian 
IESE 
Fraunhofer 

Wolschke 

Domain Specific 

Language 
in an Automotive 
Stefan Marksteiner 

f or 

Attacks 

AVL List GmbH 

Use Case 

Kaiserslautern, Germany 

Graz, Austria 

wolsch 
eh risti an. 

ke@iese.fhg.de 

stefan.marksteiner@avl.com 

Braun 
Tobias 
IESE 
Fraunhofer 

Markus Wolf 
AVL List GmbH 

Graz, Austria 

Kaiserslautern, Germany 
tobias.braun@iese.fhg.de 

markus.wolf@avl.com 

Language 
cyber attacks,  agnostic 

(DSL) for 

of the presented 

to specific 
DSL 
of the 
can 
systems 

on arbitrary 

use case. Tue concepts 

Format: 

Wolschke, 

ACM Reference 
Christian 
Wolf. 2021. An Agnostic 
ing Attacks 
Conference 
August 17-20, 
10 pages. 

in an Automotive 
on Availability, 

Stefan Marksteiner, 

Tobias 
Braun, 
Language 

and Markus 
for Implement­

Domain Specific 

Use Case. In The 16th International 

Reliability 

and Security 

(ARES 2021), 

2021, Vienna, Austria. 

ACM, New York, NY, USA, 

https://doi.org/10.1145/3465481.3470070 

The DSL therefore generically describes 

(SUT). 

connected 

The creation 

describing 

trend to improve 

a Domain Specific 

Abstract 
This paper presents 
generically 
system-under-test 
by an automotive 
is motivated 
DSL are generic 
such that attacks 
be addressed. 
The ongoing 
hicles with 
tivity 
attack 
etary nature 
to industrialize 
abstraction mechanism 
to another. 
for the usage with a test case generator 
also described 
vironment) 
and a database 
description 
generate 
(automotive) 

as well as remote accessible 
vectors. 

of potential 
testing 

implementations 

This might also impact 

attack 

SUTs. 

the user experience 
of ve­
connec­
an enhanced 
services implies 
opens potential 

interface 

safety and the propri­
of attack 
SUTs. Reusing 
tests 
SUTs mandates 
them on multiple 
an 
system 
from one 
to port an attack 
attacks 

vectors 

(and execution en­
use this 
in this paper. 
Tue latter 
to 
information 
with SUT-specific 
of different 
for a multitude 

CCS Concepts: • Security 
ification; 
verification 

• Software and its engineering 

and validation; 

Specification 

-t Software 
languages. 

and privacy 

-t Logic and ver­

Keywords: Domain Specific 
Safety Security 

Testing, Automotive 

Cybersecurity 

Language, 

Attack Language, 

ARES 2021, August 17-20, 2021,  Vienna, Austria 
ACM ISBN 
https:/ 

78-1-4503-9051-4/21/08 

.... $15.00 

/doi.org/10.1145/3465481.3470070 

(single 

against 

to the needs 

To provide 

an adaption 

of SUT. If other 

we developed 

in the needed manner, 

a clear separation 

system under test (SUT). 

a means to generically 

for the !mplementation 

performed 
contain 

is typically 
The attacks 

structure 
these attacks, 

been developed 
of the automotive 

about the potential 
be tested 

descriptions 
without 
ALIA aims at the description 
and easy understandable 

is 
known 
describe 
the 6gnostic 
of 6ttacks: 
encoding 
of 
fash­

1  Motivation 
Testing systems against cyber attacks 
for a specific 
knowledge 
SUTs should 
required. 
attacks 
domain-specific 
Icanguage 
attack 
ALIA, which allows 
information. 
SUT-specific 
cyber attacks 
in a compact 
ion. lt has originally 
and requirements 
language supporting 
actions 
parts (e.g. 
mats). 
concepts 
but can be used in different 
paper, 
we will describe 
to an automotive 
security 
by connected services 
functionality 
as well as extended 
interfaces, 
accessible 
External 
possibilities. 
testers 
to test vehicles 
are supposed 
for operation 
fore permission 
test results 
at which places 
added or existing 
functions 
of system 

domain, 
due to enriched 
remotely 
communication 
and certification 
authorities 
against 
attacks 
be­
potential 
the 
Furthermore 
can be given. 
to identify 
need to be 
Based on the list 

abstract 
the resulting 
specific 
not automotive 
in this 
and development 
aligned 
cyber­

according 
domain for an attack 
the atomic 
SUT specific 
IDs and for­

are fed back to system development 
security mechanism 

steps of an attack) 
bus configurations 
its automotive 

use case. In the automotive 
importance 

needs to be extended. 
and the knowledge 

between 
definition and 

such as message 
roots, 

Nevertheless, 

part of ALIA are indeed 

gain increasing 

additional 

which implies 

vehicle's 

its benefits 

domains. 

of generic 

Despite 

threats 

ARES 2021, August 17-20, 2021, Vienna, Austria 

Christian Wolschke, Stefan Marksteiner, Tobias Braun, and Markus Wolf 

architecture, analysis techniques like the security-aware haz­
ard and risk analysis (SAHARA) method [10] can be applied 
to identify possible attack vectors and rank them by their 
critically (in terms of required efforts/knowledge as well 
as safety impact) already in early development phases.  A 
threat library can help to systematically identify weaknesses 
and to develop implementation independent (abstract) attack 
descriptions. However, the translation of abstract attack de­
scriptions into concrete executable attacks is a challenging 
task and requires the adaption to each vehicle's architecture. 
This  adaption  includes  the  consideration of  the  network 
structure and the available ECUs. The knowledge might ei­
ther be given upfront by test engineers or the test system 
may inquire information online while executing the attack. 
In the first case, this knowledge is directly encoded in the 
test. There are two main drawbacks: the technical details 
complicate the test and its comprehensibility and hinder the 
reuse of the same test for different SUTs without manual 
adaption. Secondly, the maintenance of the same test for dif­
ferent platforms is time-consuming and error-prone when it 
comes to changes. The option to inquire information online 
is often rather complex, error-prone and might also create 
the need for adaption this inquiring mechanism to different 
SUTs.  Furthermore,  it  extends  the test time,  might  cause 
undesired side effects, and introduces a non-deterministic 
element that might thwart the comparability of tests. There­
fore, experience leads to the conclusion that using raw attack 
scripts for concrete SUTs alone is not effective in terms of 
efforts and re-usability. Additionally, the executable attack 
implementations are hard to understand and their develop­
ment requires in-depth knowledge of each targeted SUT. Tue 
goal of our approach is therefore to separate the SUT-specific 
information, as well as the used test environment from the 
pure attack description, while simultaneously reducing the 
complexity of developing attacks and the required in-depth 
knowledge of the SUT. This paper will provide an example, 
how an attack scenario is built up in Section 5, afterwards we 
will give an overview of the background of attack languages 
and explain why we have decided to develop our own solu­
tion (2). Tue following sections explain the concepts (3), the 
design (4) and implementation (6) of ALIA. The results are 
summarized in 7 and finally the conclusion is given (8). 

2  Background 
Several attack languages have been presented in the liter­
ature for different purposes  [5]. lt is pointed out that the 
testing may either focus on the correct implementation of a 
security mechanism or on the evaluation of vulnerabilities 
with risk-based testing approaches. Focusing on the vulnera­
bility testing, it should be noted that they are often related to 
unintended side-effect behavior. The Meta Attack Language 
(MAL)  uses the architecture encoded in a domain specific 
language to identify assets, their relationships and access 

techniques  [8].  As language constructs, MAL chooses an 
object orientated approach, in which actions can be applied 
to certain assets. For each action, the next reachable actions 
can be given, so that attack paths can be built up dynami­
cally. Furthermore, it allows to specify timeouts for actions. 
An application of the language to vehicular attacks is given 
by [9]. Tue MAL is well suited to identify potential attack 
paths. It allows for reasoning about assets and their potential 
attacks. Tue downside is that a complex  system may lead 
to a huge variety of attacks and their impact to the risk of 
the system is unclear. Further, the need to model a specific 
attack on an asset and whether it may have an impact on 
the overall system might be hard to determine. Hence, we 
preferred explicit attack modeling for ALIA. 

Tue application of  natural  language concepts to make 
ease-of-use in attack modelling is described by [11]. They 
propose pre- and postconditions per threat flow, which is a 
program containing if-clauses, loops and/or jump statements. 
Our ALIA approach took over these concepts, but extended 
the execution semantics so that even after failed statements 
the execution can proceed. 

Tue  ADeLe  language  [13] is a multi-purpose language 
for exploits, detection, correlation and response. lt is also 
using pre- and postconditions to determine the feasibility of 
executing instructions and to evaluate the results. Tue action 
section, which actually describes the attack implementation, 
is not independent of the SUT. 

Preconditions can also be formulated for each individual 
attack as shown in the Cyber-Physical Attack Description 
Language (CP-ADL) [15]. Tue notion of causes and effects 
allows to select follow-up actions. 

The description of threats on a higher level of abstraction 
via use cases is proposed in [14]. The use case describes the 
step necessary to perform an attack. Pre- and postconditions 
describe when to apply the attack and which outcome is ex­
pected. This adopted the concept of pre- and postconditions 
of [13] and [14], but applied it to each action. 

An alternative to text based attack descriptions are graphi­
cal notations. Tue CORAL approach uses sequence diagrams 
to identify potential attacks and to rate risk associated by 
considering the frequency of  messages  and the potential 
impact [3] [4]. The annotation of sequence diagrams with 
attack trees gives the possibility to model alternatives. Tue 
disadvantage of the language is its lack of formality. The 
language is intended to discuss potential attack scenarios 
and not to derive test cases automatically. 

The specification of attack trees via a planning language 
is proposed by [2]. The idea is to specify actions that can be 
executed under certain preconditions. The effects of actions 
lead to new actions so that an attack tree gets created. They 
applied the Planning Domain Definition Language (PDDL) 
for implementation. The disadvantage of PDDL is that it 
assumes effects to be known in advance, which is not always 
the case of attacks. This would also make it hard to find an 

An Agnostic Domain Specific Language for lmplementing Attacks in an Automotive Use Case 

ARES 2021, August 17-20, 2021, Vienna, Austria 

attack path to violate a safety goal, as the potential attack 
path have to be found by a search strategy.  Our external 
approach will provide more scalability and flexibility than 
the current static parsing solution. 

3  Concepts of DSL for attack descriptions 
As outlined in Section 2, we have studied already existing 
concepts and evaluated the needs within our security testing 
department. Since most of the users do not have in-depth 
knowledge of all technical details of the SUT, we decided to 
store SUT specific aspects outside the attack descriptions. 
As pointed out in Section 1, this concept aims at improving 
re-usability, at reducing the complexity in development and 
at understanding these attack descriptions. Additionally, the 
test engineer should be able to focus on the attack itself and 
not on details of the SUT.  Further requirements and design 
decisions derived from these considerations are: 

•  Imperative  based  notation: Tue imperative approach 
was pursued, as it is close to the existing notion of test 
scripts instead of developing a complex programming 
language able to describe attacks. As alternatives, also 
graphical notations were discussed, which allow for 
easily tracking cross-references between entities, but 
would not have a predefined fixed execution sequence 
of the single attack steps (called actions). Furthermore, 
attack trees were part of the discussion, as they could 
figure out at run-time which attacks could be executed; 
but they could not reveal easily which attack is planned 
for a system. While both concepts are interesting from 
an academic point view, they require changes in the 
established test process and training to be applied cor­
rectly, as well as additional efforts for modeling the 
inputs artefacts compared to the imperative approach. 
•  Attack execution: The attack should be consistent with 
actions, which each execute a certain attack tool and 
retrieve the necessary information. An action should 
group optional pre- and postconditions checked for 
each action, as well as the description of the action to 
be executed in this step. Within the specification of 
the command as well as the pre- and postconditions 
variables can be used. These variables are resolved 
during run-time using a vehicle database that contains 
vehicle specific data for the targeted SUT. If the pre­
conditions are not met,  the execution of the action 
will be skipped, as the preconditions are considered 
mandatory (sine qua non) and an execution is there­
fore not sensible. For an unfulfilled postcondition, a 
failed action will be logged, in order for a test engineer 
to know directly where and which steps failed. Pre­
and postconditions can be linked (i.e. an unfulfilled 
postcondition could lead to an unfulfilled precondition 
for a subsequent step) and therefore allow conditional 
steps and additionally facilitate the interpretation of 

Time Status Debug message 

OK  Precond 1 fulfilled 

1 
2  Failed Attack 
3  Failed Postcond 

1 failed 

1 failed 

OK  Precond 2 fulfilled 
2 executed 
2 failed 

4 
s  OK  Attack 
6  Failed Postcond 
7  Failed Precond 3 failed 

8  skipped Attack 

3 not executed 

3 not 
Postcond 

9  skipped checked 
10  OK  Precond 4 fulfilled 
11  OK  Attack 
4 executed 
12  OK  Postcond 
4 fulfilled 

Figure  1. 

Execution semantic example 

the test execution results (since steps with linked un­
fulfilled preconditions are not executed, see step 8 and 
9 of Figure 1). 

•  Failure semantics: A usual way of checking the success 
of executions are assertions. Assertions can e.g. cause 
a pro gram to terminate or to raise an exception if their 
condition is not met. In the DSL, the failing of a com­
mand would induce an exception within an action that 
should be caught by the test execution environment 
and the test should proceed with the next command. 
An example of the execution is given in Figure 1. lt 
shows how the execution proceeds even after failures 
(as in Attack 1, Postcondition 1 or Postcondition 2). 
Tue failure in Precondition 3 leads to the skipping of 
Attack 3, but further actions are still be executed. 
•  Predefined support for automotive bus systems: Consid­
ering the use case, we decided, that the DSL should 
directly include support for testing automotive sys­
tems and their interactions/communication. Therefore, 
we directly integrated commands for commonly used 
communication buses used by the automotive industry 
(like CAN, FlexRay, MOST, etc.) as well as predefined 
message formats. Regarding the typical communica­
tion patterns, commands that consider the cyclic send­
ing of messages as well as the specification of timeouts 
should be included. 

Tue goal described in Section 1 requires an abstraction 
layer in the test design, which we provide by introducing 
test scenarios as abstract counterparts of test cases. A single 
executable step (a test script  that would e.g. use a specific 
exploit, scan for an interface or send a CAN message) inside 
this test scenario will have to be turned into a generic de­
scription, which we call a test pattern. These test patterns, 
that form a composite scenario, will have to be augmented 
with SUT information of the concrete SUT against which it 
is going to be used. This augmentation is part of the test case 
generation [12]. Figure 2 provides an overview of this pro­
cess. This allows for porting attacks or test cases from one 
SUT to another, maintaining the attack's structure but un­
binding it from the original SUT. Where specific information 
about the SUT or the test environment (e.g. connection of 

ARES 2021, August 17-20, 2021, Vienna, Austria 

Christian Wolschke, Stefan Marksteiner, Tobias Braun, and Markus Wolf 

test bed to the SUT) configuration is required, placeholders 
can be used. Such a generic attack description is based on a 
sequence of actions, with optional pre- and postconditions. 
If an action fails in execution, the test should proceed with 
the further actions, so that other potential weaknesses of 
the SUT could still be detected (see Section 5). To  obtain 
an executable attack implementation, we have implemented 
a generator and test execution environment,  which takes 
the generic attack description (expressed in the developed 
DSL) and identifiers for the target SUT; as well as the test 
environment as an input.  By querying a knowledge base 
containing specific information about the supported SUTs 
and test beds, the generic attack description is translated into 
an executable attack implementation for the selected SUT 
and test environment. Hence, a generic attack description 
specified in the DSL can be applied to different test beds and 
SUTs without modifications, while the generated executable 
attack implementation itself is executable without any fur­
ther information. Tailoring the existing attack descriptions 
to new SUTs and test environment can be done by extend­
ing the database with new SUT-specific information or new 
information about the test environment. To proof and eval­
uate this approach, we have developed an integrated test 
case generator and execution environment along with the 
DSL using Xtext [6] and Python, respectively (see Section 3). 
This process of translating generic attack descriptions into 
concrete implementations could be referred to as turning ab­
stract test patterns (similar to design patterns) into concrete 
test scripts. In the context of this paper a set of patterns is 
named test scenario and a set of attack implementations test 
case [12]. 

We  have  decided  to  use  the  Xtext  [6][1],  which  is  an 

Eclipse-based framework for developing DSLs. 

Tue domain  model and core concepts of our DSL have 
been specified as a meta-model before we started designing 
the concrete syntax of ALIA itself. Figure 3 shows an excerpt 
of this meta-model reduced to the core elements and their 
relations. 

The core idea is that the generic attack descriptions written 
in ALIA are compiled into a representation in the JSON [7] 
data format. This JSON representation is interpreted by test 
execution processes (AXE -Attack Execution Engine). Thereby, 
system variables referring to SUT specific or test environ­
ment specific are resolved during execution by querying a 
provided  knowledge database. For each  executed  test,  the 
results of the actions are stored within a test execution report 
for evaluation. 

The attack description written in ALIA consists of an arbi­
trary number of attack steps that can be used in multiple test 
executions. For the test execution, the attack step denotes 
which kind of command or which kind of control-flow action 
(i.e.  if-then-else or while statement) is to be executed. The 
command is resolved by the AXE to a tool or script execu­
tion in the test environment. Tue attack steps may contain 

preconditions that asserted to determine if the step's execu­
tion is sensible and postconditions that are used evaluate the 
execution's success. Labels are used to link preconditions and 
postconditions to actions. 

4 Design 
Apart  from the  functional  goals of an  automotive  attack 
DSL, our design targets towards allowing attacks to be writ­
ten quickly but even more to enable an easy read- and re­
usability of the resulting scripts. To achieve this, the main 
attribute is the grouping of attack steps into preconditions, 
actions and postconditions  (for the semantics see Section 
3). Each generic attack description consists of a sequence of 
actions (i.e.  atomic attack  steps),  which may link to pre- or 
postconditions via common labels. Variables can be either 
system variables which are resolved at runtime by the vehi­
cle information available, or they can be auxiliary variables 
which store results of tool executions for the evaluation in 
further post- or pre-conditions in subsequent actions. The 
purpose is  that,  in conjunction  with  descriptive function 
naming, an (security) expert could quickly and easily com­
prehend the attack described by the script, i.e. understand 
the type and steps of the attack by a quick look-over. Pre­
and postconditions  consist of simple assertions based on 
variables and their values. Examples for such conditions are, 
the availability of a specific remote interface during execu­
tion of the attack on the SUT or the presence of an open 
shell. Actions primarily contain two types: scan and exploit. 
The former type is used for reconnaissance and targets to­
wards finding vulnerable system components (interfaces, 
ports, APis, etc.), while the latter uses the results of scans 
to execute the attack on the (potential) vulnerable systems. 
If the attack has been successful, the result is returned ( e.g. 
an open shell on the target system). For flow control, ALIA 
also contains Boolean, arithmetic and comparison operators. 
The actions themselves are either of type scan that is used 
for reconnaissance purposes (e.g. to find a Bluetooth target) 
or type exploit  that is used for manipulating systems  (e.g. 
issuing exploit code, executing commands, etc.). The results 
of these types can be written on variables. Furthermore basic 
flow control (conditionals, loops) are part of the language. 
ALIA has been implemented in Xtext (example Listing 1) 
with a translation into a representation in the JSON data 
format (Listing 5). This translation step has been realized 
with Xtend [1]. The generated editor for ALIA has built-in 
support for generating embedded Eclipse editors providing 
syntax highlighting and checking. The implementation also 
generates warnings if system variables are unknown or any 
auxiliary variables are not defined before used (e.g. in the 
example, the misspelled variable uesr is detected and the 
error highlighted). This tool supports enables an easy and 
efficient way to develop attacks using ALIA. 

An Agnostic Domain Specific Language for lmplementing Attacks in an Automotive Use Case 

ARES 2021, August 17-20, 2021, Vienna, Austria 

Figure 2. Abstraction and concretization concept from [12] 

Allow Boolean 

e><pressions with nested 
and/or/not 

operations. 

precondition postcondition 

Compare variablevalues 
againstvariablesvalues  ..._ 
or against numerical 

e)(pressions 

is-a 
�� 

.._  .._

is-a 

Condition 

Knowledge 
Database 

+ Dictionary 
var2sut�value 

Label 

0
� 

l 

Attack 

Step 

1 ,....... ALIA Attack 

Description 

�  Representation 

JSON 

AXE-Attack 

+ Execution 

Engine 

1 

Action 

While 

Statement Statement 

Command � 

1  Right-Hand-Side 
Assignment 

is-a 

Test Execution 

Report 

Figure 3. Meta-model of the ALIA 

Listing 1. Automatie detection of unknown variables with 
ALIA 

1 PreConditions: 

get_su_rights:  con 

3 Actions: 
4  get_con:  con  = exploit(type: OpenADB, 

target:  ip_addr) 

get_su_rights:  exploit(type: 

ScriptExecution,  command:  'su ') 

exe_whoami:  user  =  exploi t (type: 

ScriptExecution,  command:  'whoami ') 

list:  exploit(type: ScriptExecution, 

command:  '1s ') 

s  PostConditions: 

exe_whoami:  uesr  == "root" 

Usting 1 shows an ALIA example  attack description. Tue 
first action tries to open a connection to the SUT via the 
Android Debug Bridge (adb_connect; line 4); the required 
IP address for the connection is expressed via a variable and 
will be resolved at runtime. Tue warning in the  editor in 
line 4 (expressed by the underlining) indicates, that the sys­
tem variable ip_addr is not known to the test environment. 
Before  executing line 5, the precondition associated with 
the label get_su_rights is checked. In the example it is re­
quired that the execution of line 4 was successful. Therefore, 
the precondition in line 2 asserts that the variable con con­
tains an actual result and is not false before executing the 
action labeled get_su_rights. If the precondition is fulfilled, 

ARES 202 1 ,  August 1 7-20, 202 1 ,  Vienna, Austria 

Ch ristian Wolsch ke, Stefan Marksteiner, Tobias Braun, and  Markus Wolf 

the system tries to acquire super user rights by executing 
the action in line 5. The result of the action is stored in the 
variable user, which is then analysed1 using the postcondi­
tion of this action (line 9) against the word "root".  Finally, 
the command "ls" is executed (line 7). As a summary, the 
composition of the language is as follows: Each action has 
a label as an identifier and a function (i.e. scan or exploit), 
which is of a certain type and takes certain input parameters 
(e.g. target, shell, etc.). Tue result may be stored to a variable. 
Each action can optionally have a precondition and/or a post­
condition which both are attributed to the action by using 
the same label. Preconditions ordinarily assert the presence 
of a certain asset  (e.g.  an interface or a target) and cause 
an action to be skipped if not met. Postconditions contain 
expected results after the action (e.g. values a variable should 
have or expected measurements) and are used to evaluate 
the success of an action. 

5 Example Use Case 
As first use case ALIA has been applied to an automotive 
setting, in which an attacker wants to penetrate a vehicle. 
The flow of the specific attack (illustrated in Figure 4) was 
to attack a vehicle's infotainment head unit via a Bluetooth 
attack (1) and then open an Android Debug Bridge (ADB) (3) 
via WiFi to gain root access to the device. As potentially path 
an attacker can indirectly first attack a user's mobile phone 
(1,2),  which is used as a trusted WiFi hotspot for updating 
and streaming. Once connected with elevated privileges, the 
head unit was used to send messages to the connected (via 
an USB tin or, alternatively, a Bluethooth OBD dongle) Con­
troller Area Network (CAN) bus that contain fake speed and 
RPM values  (4),  which eventually manipulated  the  speed 
and RPM gauges. Tue (visible) result was that an a standing 
vehicle  with  active  ignition  (but  still  inactive motor),  the 
respective gauges deflected. lt is planned to keep such an at­
tack agnostic, so that it can be applied also to other vehicles. 
For the given example, this would mean that the attack may 
need to try out several Bluetooth attacks to get the access to 
ADB connection. Even if this part of the attack would fail, we 
would like to have  means which allow to continue the test. 
The argumentation is that the test may figure out whether 
multiple security controls prevent the attack to happen, or if 
only one security control actually prevents the attack. When 
the attack is proceeded with control over the Infotainment 
Head Unit the attacker would require to figure out, which 
busses can be accessed and also which messages may be sent 
to provoke a certain vehicle behavior. Based an this rationale, 
we derived the following requirements regarding the exe­
cution semantic: In order to adapt the test behavior during 
execution, it should be possible to check pre- and/or post­
conditions for each action. If the preconditions for executing 

1 For demonstration purposes, we misspelled the variable  here to demon­
strate the variable checking support of the editor. 

a certain action are not met, the step would be skipped, and 
the execution would resume with the next action. This en­
sures, that if an action fails, the remaining attacks scripts 
can still be executed. Hence allowing for detecting otherwise 
not identified weaknesses which might be abused. Tue case 
that only one action  failed in test execution, but the main 
goal could be reached, might indicate that only one single 
mechanism is effective. This would be worth to investigate 
further and take this into consideration for potential design 
changes. The formulated post-conditions allow for automat­
ically evaluating the outcome of each action and, thereby, 
help in test automation. 

6 Implementation and Test Case 

Generation 

In order to generate an executable test case out of an attack 
description (test scenario ), aJSON representation is compiled 
out of the attack  (see example Listing 5). Tue compilation 
process is implemented in Xtend, which is a language that is 
completely inter-operable with Java. Due to such features as 
lambda expressions, dispatch methods, extension methods 
and type interference as well as multi-line template expres­
sions, it is deemed an appropriate choice for programming 
code  generators  [ 1].  As each attack script  consists of the 
three blocks preconditions, actions and postconditions, each 
line has to be identified and handled accordingly. Inside these 
blocks, every line consists of either a condition or a function 
call, which may be stored to a variable for further use. All pre­
and postconditions are stored in a hash map structure, with 
the label as key and the corresponding command as value 
(see also Listing 3). In this process, for each command of the 
action section, the corresponding pre- and post-conditions 
are looked up via the label and placed before or after the 
corresponding command. Hence, conceptually and action 
consists of optional pre- and postconditions and the attack 
representing the executed command. 

Listing 2 shows the parsing process for function calls. De­
pending an which function is used, the corresponding JSON 
formatted text is added to the output and introduced place­
holders are replaced with actual values if they are present 
in the ALIA script or with placeholders that are used during 
the execution, if they have to be determined at runtime. 

Tue example in Listing 2,  written in Xtend,  shows also 
how the commands of the DSL are translated to the nam­
ing of tools and parameters. Please notice, that the variable 
ip_addr gets translated to the actual value (e.g. "192.168.1.1") 
via the vehicle database containing the SUT specific details, 
which is processed together with the JSON file at the test's 
runtime (for this value is not known a priori and may change 
depending  an the SUT). 

Tue generator shown in Listing 3 is used to parse a previ­
ously defined ALIA script into a JSON output script using 

An Agnostic Domain Specific Language for lmplementing Attacks in an Automotive Use Case 

ARES 2021, August 17-20, 2021, Vienna, Austria 

Attacker 

Bluetooth 

(1) 

ADB over WiFi (2) 

Trusted 

Relati nship 

RPII/Speed 
Gauge 

lnfatalnment 
HaadUnft 

CAN BUS(4) 

Figure 4. Example Attack Schematics 

the defined transformation in Xtend. lt adds a skeleton struc­
ture to produce a valid JSON definition and then reads and 
compiles the input script line by line from the source. 

7  Experimental Results 
In order to put the DSL ALIA to a practical test, the language 
was applied to the specific use case presented in section 5. 
This attack  should be automatically  executed on a test 
system. Therefore,  the attack was modelled  in ALIA and 
subsequently turned into a system-interpretable representa­
tion using Xtend for test case generation. Listing 4 displays 
the resulting (to some extend anonymized) description in 
ALIA. The Xtend rules generate an executable attack script 
out of this description, using a repository of exploit scripts 
(e.g. in line 14), executables and a vehicle database. This ve­
hicle database contains, for instance, SUT-specific concrete 
values for CAN messages, for which the ALIA description 
holds generic identifiers (e.g. MSG_SPD, might translate to 
123#ABCD000000 for one SUT but 200#CAFE123456 for an­
other). In our proof-of-concept setup, the generated attack 
script as JSON file is later on used as input for the AXE, 
which is a platform independent security testing application 
programmed in Python. Its purpose is to execute the com­
mands from the attack script against the SUT and gather 
feedback from it. The generated JSON file from the DSL is 
taken as Input via a HTTP request and every command gets 
executed line by line. Furthermore it manages different shell 
connections and environments automatically, which allows 
for example to execute an exploit in a bash shell and then 

use the resulting reverse shell for further commands. After­
wards, the initial shell may be used again. Depending on the 
pre- and postconditions of the DSL script, some of the com­
mands in the attack can be skipped and all output data from 
executed commands is collected into the response, which 
is sent back via a HTTP response. In the proof-of-concept, 
a malicious CAN message is periodically sent to CAN bus 
of the SUT (in this case a Mazda Model 3 from 2012) with 
the content "201#32C800006464C800". This message lets the 
instrument duster of the vehicle assume that it is moving at 
maximum speed and rpm and therefore it starts to move its 
needles. 

Listing  5  shows  a  snipped  from  a  generated JSON  at­
tack  script for this  example. The  execute block contains 
a sequence of commands. Each command has an environ­
ment and tool and a list of parameters. Besides actions, pre­
and post- condition checks are also translated to the call of 
commands. The parameters may contain variable values, as 
{ip_addr}, which are to be replaced by the actual value by 
the AXE, taken from the vehicle database. These generated 
instructions are sufficient for the AXE to actually execute 
the attack as a fully sequenced test case. 

8  Conclusion and future work 
This paper presents the concept, design and implementation 
of an SUT-agnostic attack language ALIA, that allows for 
describing attacks on automotive systems in a generalized 
manner. ALIA separates the SUT specific information from 

ARES 202 1 ,  August 1 7-20, 202 1 ,  Vienna, Austria 

Ch ristian Wolsch ke, Stefan Marksteiner, Tobias Braun, and Markus Wolf 

Listing 2. Xtend Parsing function of the output generator 

1  priv ate  def  compil e_f unc( F uncCal l  e) 
2  " ' I F   (e. f 1 0 0 0   ! = =  null ) { "env ironment": " 
b ash",  "parameters": [ "connect",  "{ e. 
ip_addr. name} "] ,   "tool ":  "adb "}  EN DI F 
! = =  null ) { "env ironment": "b ash 

3  I F   (e. f 1 0 0 1  

' = =  null ) compil e_f 1 0 1 1  ( e) 

' = =  null ) compil e_f 1 0 1 0 ( e) 

",  "parameters": [ "connect",  "{ e. 
ip_addr. name} "J ,   "tool ":  "e. intf "} 
EN DI F 
(e. f 1 0 1 0 
EN DI F 
(e. f 1 0 1 1 
EN DI F 
(e. f 1 0 2 0   ' = =  null ) compil e_f 1 0 2 0 ( e) 
EN DI F 
(e. f 1 0 3 0   ! = =  null ) compil e_f 1 0 3 0 ( e) 
EN DI F 
(e. f 1 0 4 0   ! = =  null ) compil e_f 1 0 4 0 ( e) 
EN DI F 
(e. f 1 0 5 0   ! = =  null ) compil e_f 1 0 5 0 ( e) 
EN DI F 

4 

I F  

5 

I F  

6 

I F  

7 

I F  

8 

I F  

9 

I F  

10 
11 
12  priv ate  def  compil e_f 1 0 1 0 ( F uncCal l  e) { 
v ar  retv al  =  '{ "env ironment": "adb "'; 
1 3  
retv al  + =   ',  "parameters": [ '; 
14 
retv al  + =   compile_stringf ormat(e. 
1 5  
systemstr,  compile_v arlist( e. 
v arlist) ) ;  
retv al  + =   ']  '; 
retv al  + =   ',  "tool ":  "'+ e. systemstr. 

16 
1 7  

split( "  ") . get(0 ) + '"} '; 

return  retv al ;  

18 
19 } 

the test case. Hence, test cases can be applied to multiple dif­
ferent SUTs. ALIA is capable of abstracting from SUT specific 
tools and parameter values. The execution of ALIA scripts 
is made flexible by integration of pre- and post-conditions 
together with it's attack execution semantics. The first im­
plementation of ALIA with Xtext [6] and the implementa­
tion of the attack execution are demonstrated. lt is planned 
to use ALIA to implement attacks reflecting different sce­
narios for automotive testing system applicable to different 
SUT by providing the according information in the vehicle 
database. Future  work is supposed to extend the provided 
functionality and usability of the ALIA. Usability features 
to be included into the code editor are automatic code com­
pletion and the integration of type system for variables. The 
provided functionality will be extended by adding support 
for additional tools (e.g. penetration and fuzzing tools). lt is 

planned to use the ALIA as a common agnostic test speci­
fication for a multitude of different test vehicles. Plans for 
further enhancement of the ALIA include the integration of 
conditionals (IF-statements) and generalization of various 
different function categories, e.g. a central function for scans 
on different interfaces such as WiFi or BlueTooth. In this case, 
distinction will be made only by the provided parameters. 
Another improvement will be to implement data storage 
classes for used objects such as scans, exploits, interfaces 
or shell-connections and to load the different preconfigured 
flavours of these items from an external database. An entry 
in this database for an exploit may consist of an identifier, a 
description, required input parameters, output source code 
and a version number. This external approach will provide 
more scalability and flexibility than the current static parsing 
solution. 

References 
[1]  Lorenzo Bettini. 2016. Implementing domain-specific languages with 

Xtext and Xtend. Packt Publishing Ltd. 

[2]  Josip Bozic and F. Wotawa. 2020.  Planning-based security testing of 
web applications with attack grammars.  Software Quality Journal 28 
(2020), 307-334. 

[3]  Gencer Erdogan and Ketil St0len. 2017. Design Decisions in the Devel­
opment of a Graphical Language for Risk-Driven Security Testing. In 
Risk Assessment and Risk-Driven Quality Assurance, Jürgen Großmann, 
Michael Felderer, and Fredrik Seehusen (Eds.). Springer International 
Publishing, Cham, 99- 1 14. 

[ 4]  Gencer Erdogan, Ketil St0len, and Jan Aagedal. 2016.  Evaluation of 
the CORAL approach for risk-driven  security testing based on an 
industrial case study. In Proceedings ofthe 2nd International Conference 
on Information Systems  Security  and Privacy (ICISSP 2016).  2 1 9-226. 
https:// doi.org/ 1 0 . 1 3 1 40/RG.2.2.2031 2.29449 

[5]  Michael Felderer, Matthias Büchler, Martin Johns, Achim D. Brucker, 
Ruth Breu, and Alexander Pretschner. 2016. Chapter One - Security 
Testing: A Survey. In Advances in Computers, AtifMemon (Ed.). Vol. 101. 
Elsevier, 1 - 5 1 .   https://doi.org/10.1 0 1 6/bs.adcom.20 1 5. 1 1 .003 

[6]  Eclipse Foundation.  [n.d.] .  Xtext.  https://www.eclipse.org/Xtext/. 

Accessed: 2021-0 1-19. 

[7]  Ecma International.  2017.  ECMA-404: The JSON data interchange 

syntax, 2nd edition. 

[8]  PontusJohnson, Robert Lagerström, and Mathias Ekstedt. 2018. A Meta 
Language for Threat Modeling and Attack Simulations. In Proceedings 
of the  13th International Conference  on Availability,  Reliability and 
Security (Hamburg, Germany) (ARES 2018). Association for Computing 
Machinery, New York, NY, USA, Article 38, 8 pages.  https://doi.org/ 
1 0 . 1 1 45/3230833.3232799 

[9]  Sotirios Katsikeas., Pontus Johnson., Simon Hacks., and Robert Lager­
ström. 2019. Probabilistic Modeling and Simulation of Vehicular Cyber 
Attacks:  An  Application  of the  Meta Attack Language.  In Proceed­
ings of the 5th International Conference on Information Systems Secu­
rity and Privacy - Volume  1: ICISSP,.  INSTICC,  SciTePress,  175-182. 
https:// d o i .org/ 10 .5220/000724790 1 750 1 82 

[10]  G. Macher, H. Sparer, R. Berlach, E. Armengaud, and C. Kreiner. 2015. 
SAHARA: A security-aware hazard and risk analysis method. In 2015 
Design, Automation Test in Europe Conference Exhibition (DATE). 62 1-
624.  https:/ / doi.org/1 0.7873/DATE.20 1 5 .0622 

[11]  P. X. Mai, F. Pastore, A. Goknil, and L. C. Briand. 2018.  A Natural Lan­
guage Programming Approach for Requirements-Based Security Test­
ing. In 2018 IEEE 29th International Symposium on Software Reliability 
Engineering (ISSRE). 58 -69.  https://doi.org/ 1 0. 1 1 09/ISSRE.201 8.000 1 7  

An Agnostic Domain Specific Language for l m plementing Attacks  in  an Automotive  Use  Case 

ARES 202 1 ,  August 1 7-20, 202 1 ,  Vienna, Austria 

1 c l a s s  A t t ac k D S L Ge n e r a t o r  

Listing 
e x t e n d s  

3. Source of the 
A b st ra c t G e n e

output 
r a t o r  { 

file generation 

@ I n je c t  e x te n s i o n  I Q ua l i fie d N a m e P r o
H a s h M a p

l i s t< St r i ng , P re c o n di ti o n> p re c o n d_ h a s h m a p l

v i d e r  

i s t  = n e w  H a s h M a p

l i s t< S t r i ng , 

P re c o n d i  

t i on > ( ); 

A rr a y li s t< A t t a c kS te p >  a t t a c k_ l i s t  = n e w  A r ra y li s t< A t t a c k S t e p
H a s h M a p

l i s t< St r i ng , P o s t c on d i ti o n> p o s t co n d _ h a s h m

> ( ); 
a pl i st  = n e w  H a s h M a p

l i s t< St r i ng , 

P o st c o n d it i on >( ); 

over r i de voi d  d o G e n er a t e(R es o ur c e  r e s o ur c e, I F i le S y s te m A cc e s s 2  fsa, I G e n e rat o r C o n t e x t  

c o n t e x t)  { 

s t or e A s  t ( r e s o u  r c e  ,  f s a) 

w  p re c o n d _ h a s h m
1 1  

a p li st  = n e w  H a s h M a p

> ( ); 
l i s t< S t r i ng , P re c on d i t i o n

a t t a c k_ l i s t  = new A r ra y li s t< At t a c kS t e p> ( ); 
p o s t c o n d _ h a s h m

a p li s t  = n e w  H a s h M a p

l i s t< St r i ng , P o s t c on d i t i on> ( ); 

n 
13 

14  fo r ( e  :  r 
� 
16 

c om p il e( e ); 

} 

e s  o u r  c e . a 

1 1  C o n t e  n t s . t o 

l t  e r  a b  1 e . f 

i l  t e r  ( L i  n e )  ) { 

17 

18 

19 

20 

21 

22 

23 

24 

25 

26 

27 

28 

29 

30 

31 

32 

v a r  r e t v al  = ' {\ n  " ex e c u t e" : [\ n' 
i f  ( at t ac k _l i s t.s i ze( )> = l) {  

for ( cm d c tr :  0 . .  < a tt a c k_ l i s t. si z e( )) {  

r e t v al + =  c o m pi l e_ a t t ac k _ li s t( cm d c tr ); 

} 

r e t v al  r e t v a l. s u bs t r i ng ( 0, r e t v al . l e n g t h  
r e t v al 
} e l s e  { 
r e t v al 

+ =  "  J \ n}" 

+ =  II 

J \ n }" 

( )  - 1 ) ;  

} 
f s a. ge n e r a t e F

i l e( 

r e s o ur c e. UR I. l a st S e g me n t  + " .j son ", 

/ / "t e s t_s c r i pt. py ", 
r e t va l )  

} 

[12]  Stefan Marksteiner, Nadja Marko, Andre Smulders, Stelios Karagiannis, 
Florian Stahl, Hayk Hamazaryan, Rupert Schlick, Stefan Kraxberger, 
and Alexandr Vasenev. 2021. A Process to Facilitate Automated Auto­
motive Cybersecurity Testing. In 2021 IEEE 93rd Vehicular Technology 
Conference (VTC Spring).  1-5.  Accepted paper, yet to appear. 

[13]  Cedric Michel and Ludovic Me. 2001 .  ADeLe: An Attack Description 
Language for Knowledge-Based Intrusion Detection. In  Trusted In­
formation, Michel Dupuy and Pierre Paradinas (Eds.). Springer US, 

Boston, MA, 353-368. 

[14]  M. Shin and Don Pathirage. 2017. Security Requirements for Tolerating 

Security Failures. In SEKE. 

[15]  Mark Yampolskiy, Peter Horvath, Xenofon D.  Koutsoukos, Yuan Xue, 
and Janos Sztipanovits. 2015.  A language for describing attacks on 
cyber-physical systems.  International Journal of Critical Infrastructure 
Protection 8 (201 5), 40 - 52.  https://doi.org/ 1 0. 1 0 1 6/j. ijcip.201 4.09.003 

ARES 2021, August 17-20, 2021, Vienna, Austria 

Christian Wolschke, Stefan Marksteiner, Tobias Braun, and Markus Wolf 

Listing 4. ALIA  example  of an automotive  attack 

b b _ b t _ s c a n :  BT _ I F  
b b _ e x p l o i  t :  my t a r g e t  
o p e n _ h o t s p o t :  b b s h e l l  
i n s t a l l _ p y t h o n _ l i b :  a d b s h e l l  

1  P r e C o n d i  t i o n s : 
2 
3 
4 
5 
6  A c t i o n s : 
7 
8 
9 

b b _ b t _ s c a n :  my t a r g e t   =  s c a n  ( t y p e :  B l u e ß o r n e , 
b b _ e x p l o i  t :  b b s h e l l   =  e x p l o i  t ( t y p e :  B l u e ß o r n e ,  t a r g e t :  my t a r g e t )  
o p e n _ h o t s p o t :  my t a r g e t .  i p   =  e x p l o i  t ( t y p e :  O p e n A n d r o i d H o t s p o t ,  t a r g e t :  my t a r g e t ,  s h e l l : 

i n t e r f a c e :  B T  _ I F )  

b b s h e l l )  

1 0  
1 1  
1 2  

1 3  
14 

a d b _ c o n :  a d b s h e l l   =  e x p l o i  t ( t y p e :  O p e n A D B ,  t a r g e t :  my t a r g e t )  
i n s t a l l _ p y t h o n _ e n v :  e x p l o i t ( t y p e : I n s t a l l P y t h o n E n v ,  t a r g e t : m y t a r g e t )  
i n s t a l l _ a t t a c k _ s c r i p t :  a t t a c k S c r i p t  =  e x p l o i t ( t y p e : I n s t a l l A n d r o i d C A N D o s S c r i p t ,  t a r g e t : 

my t a r ge t )  

i n s t a l l _ p y t h o n _ l i b :  e x p l o i  t ( t y p e :  I n s t a l l P y t h o n l i b ,  t a r g e t :  my t a r g e t ,  s h e l l :  a d b s h e l l )  
c a n _ a t t a c k :  e x p l o i  t ( t y p e :  S c r i p t E x e c u t i o n ,  t a r g e t :  my t a r g e t ,  s h e l l :  a d b s h e l l ,  f i l e : 

C a r C a n A t t a c k S c r i p t )  

1 5  P o s t C o n d i  t i o n s : 
1 6  
1 7  

o p e n _ h o t s p o t :  W I F I   = =   " A n d r o i d "  
c a n _ a t t a c k :  O r a c l e . C A N _ M E S S A G E ( M S G . S P D )  

Listing 5 .  Generated attack script 

" e x e c u t e " : [  

" p a r a m e t e r s " : [ " c o n n e c t " , " { i p _ a d d r } " ] } ,  

{ " e n v i r o n m e n t " : " b a sh " ,   " t o o l " : " a d b " , 
{ " e n v i r o n m e n t " : " a d b " , 
{ " e n v i r o n m e n t " : " a d b " , 
{ " e n v i r o n m e n t " : " a d b " , 
{ " e n v i r o n m e n t " : " a d b " , 
{ " e n v i r o n m e n t " : " a d b " , 
{ " e n v i r o n m e n t " : " a d b " , 

" t o o l " : " w a s _ s u c e s s f u l " ,  
" t o o l " : " s u " , 
" t o o l " : " w h o a m i " ,   " p a r a m e t e r s " : [ J } , 
" t o o l " : " p y t h o n " 
" t o o l " : " w h o a m i " ,   " p a r a m e t e r s " : [ " < > " , " \ " r o o t \ " " J } , 
" t o o l " : " l s " , 

" p a r a m e t e r s " : [ J } ,  

" p a r a m e t e r s " : [ J }  

" p a r a m e t e r s " : [ " l a b e l _ c o n " J } , 

" p a r a m e t e r s " : [ " c o n d c m p . py " , " u s e r " , " = = " , " r o o t " J } , 

] 

1  { 
2 
3 
4 
5 
6 
7 
8 
9 
1 0  
1 1   } 

