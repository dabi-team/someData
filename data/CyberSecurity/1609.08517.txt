6
1
0
2

p
e
S
5
2

]

H
O
.
s
c
[

1
v
7
1
5
8
0
.
9
0
6
1
:
v
i
X
r
a

The curse of variety in computing, and what
can be done about it

J Gerard Wolﬀ∗

November 2, 2021

1 Key insights

• Excess freedom in how computers are used creates problems that in-
clude: bit rot, problems with big data, problems in the creation and
debugging of software, and problems with cyber security.

• To tame excess freedom, “tough love” is needed in the form of a uni-
versal framework for the representation and processing of diverse kinds
of knowledge (UFK).

• The SP machine, based on the SP theory of intelligence, has the poten-
tial to provide that framework and to help solve the problems above.

• There is potential to reduce the near-4000 diﬀerent kinds of computer
ﬁle to one, and to reduce the hundreds of diﬀerent computer languages
to one.

Imagine that, instead of two or three international standards for electrical
plugs and sockets, there were thousands. Imagine that every town and village
had its own standard, that each standard was incompatible with any other
standard, and that each electrical appliance might come ﬁtted with a plug
conforming to any one of the many standards. Travelling around with our

∗Dr Gerry Wolﬀ, BA (Cantab), PhD (Wales), CEng, MBCS, MIEEE; CognitionRe-
search.org, Menai Bridge, UK; jgw@cognitionresearch.org; +44 (0) 1248 712962; +44 (0)
7746 290775; Skype: gerry.wolﬀ; Web: www.cognitionresearch.org.

1

 
 
 
 
 
 
smartphones, tablet computers, electric toothbrushes, and so on, we would
have to carry a large bag full of adaptors, and every shop selling electrical
appliances would have to carry a similarly large range of adaptors.

Although that would be ridiculous, it is exactly the kind of thing we
accept in the world of computing. Wikipedia lists nearly 4,000 diﬀerent
‘extensions’ for computer ﬁles, each one representing a distinct type of ﬁle.1
A small sample is shown here:

• ASE—Adobe Swatch.

• ART—America Online proprietary format.

• BLP—Blizzard Entertainment proprietary texture format.

• BMP—Microsoft Windows Bitmap formatted image.

• CD5—Chasys Draw IES image.

• CIT—Intergraph is a monochrome bitmap format.

• CPT—Corel Photo-Paint image.

Each application is severely restricted in what kinds of ﬁle it can process—
it is often only one—and incompatibilities are rife, even within one area of
application such as word processing or the processing of images. A program
that will run on one operating system will typically not run on any other,
so normally a separate version of each program is needed for each operating
system.

This kind of variety may also be found within individual ﬁles. In a Mi-
crosoft Word ﬁle, for example, there may be text in several diﬀerent fonts and
sizes, information generated by the “track changes” system, equations, Wor-
dArt, hyperlinks, bookmarks, cross-references, Clip Art, pre-deﬁned shapes,
SmartArt graphics, headers and footers, embedded Flash videos, images cre-
ated by drawing tools, tables, and imported images in any of several formats
including JPEG, PNG, Windows Metaﬁle, and many more.

Variety is also alive and well amongst computer languages. Several hun-
dred high-level programming languages are listed by Wikipedia, plus large
numbers of assembly languages, machine languages, mark-up languages, style-
sheet languages, query languages, modelling languages, and more.2

1See “List of ﬁlename extensions”, Wikipedia, bit.ly/28LaT4v, retrieved 2016-08-16.
2See “List of programming languages”, Wikipedia, bit.ly/1GTW05W, retrieved

2016-08-16; see also “Computer language” and links from there, Wikipedia,
bit.ly/2aZ2kag, retrieved 2016-08-17.

2

Some of the variety in types of ﬁle, in formats for information within ﬁles,
and in computer languages, reﬂects variety in the world, and is necessary
and useful. But much of the variety in computing systems is quite arbi-
trary, without any real justiﬁcation, and the source of signiﬁcant problems in
computing, outlined in Section 2. However, despite its harmful eﬀects, that
kind of “excess” variety has become part of the wallpaper of computing—
something that we cease to see or think about because it is so familiar, in
much the same way that people once thought that applying leeches was a
good way to treat an illness, or how it was accepted that the fastest way to
send a letter was via a courier on horseback, with no idea that, one day, it
might take only seconds to send that kind of message to the other side of the
world.

2 Problems with excess variety

Some people may say that the variety of types of computer ﬁle, and variety in
other areas of computing, is to be welcomed as a sign of vigour and creativity
in the computing industry. But, often, excess variety in computing does little
or nothing in terms of the user’s needs or wishes, and is largely without the
value of variety in art, music or literature, or in human cultures and natural
languages. And excess variety in computing systems contributes to four
main kinds of problem: bit rot, problems with big data, problems in the
development and debugging of software, and problems with safety and cyber
security.

The ﬁrst of these, bit rot, is when software or data or both become un-
usable because technologies have moved on. Vint Cerf of Google has warned
that the 21st century could become a second “Dark Age” because so much
data is now kept in digital format, and that future generations would struggle
to understand our society because technology is advancing so quickly that
old ﬁles will be inaccessible.3

With big data—the humongous quantities of information that now ﬂow
from industry, commerce, science, and so on—excess variety in formalisms
and formats for knowledge and in how knowledge may be processed is one of
several problems that make it diﬃcult or impossible to obtain more than
a small fraction of the value in those ﬂoods of data [4, 7]. Most kinds
of processing—reasoning, pattern recognition, planning, and so on—will be
more complex and less eﬃcient than it needs to be [14, Section III]. In par-
ticular, excess variety is likely to be a major handicap for data mining—the

3See, for example, “Google’s Vint Cerf warns of ‘digital Dark Age’ ”, BBC News,

2015-02-13, bbc.in/1D3pemp.

3

discovery of signiﬁcant patterns and structures in big data [14, Section IV-B].
Excess variety in computing also means ineﬃciencies in the labour-
intensive and correspondingly expensive process of developing software and
the diﬃculty of reducing or eliminating bugs in software.

And excess variety means potentially serious consequences for such things
as the safety of systems that depend on computers and software, and the
security of computer systems. With regard to cybersecurity, Mike Walker,
head of the Cyber Grand Challenge at DARPA, has said that it counts as
a grand challenge because of, inter alia, the sheer complexity of modern
software.4

3 Some reforms in computing

So what is to be done? Excess variety is a deep-rooted problem in computing
as it is today and will need some radical rethinking of what computing is and
how things are done. But we can catch some of the ﬂavour of what’s needed
by looking at some reforms that have already been accepted and adopted in
the industry.

Up until the 1970s, it was considered quite acceptable for programs to
contain many of the infamous “go to” statements, allowing jumps from any
part of a program to any other, and often leading to “spaghetti” programs
with complex and tangled control structures that could be diﬃcult to under-
stand or to maintain [2].5

Gradually, people realised that computers, like wayward children, should
not be given total freedom. “Tough love” was needed in the shape of “struc-
tured programming” [3] to constrain the forms that programs could take,
with beneﬁts for comprehensibility, maintainability and reductions in cost.6
Later, “super-nanny” in the shape of software gurus insisted that, for even
greater beneﬁts, computers should operate within the relative straight jacket
of “object-oriented” programming,7 reﬂecting the structure of real-world
things like warehouses or factories in the structure of the software that is
to help manage those things.

4See “Can machines keep us safe from cyber-attack?”, BBC News, 2016-08-02,

bbc.in/2aLGwOu.

5See also “Spaghetti code”, Wikipedia, bit.ly/1Q4AgL2, retrieved 2016-08-03.
6See also “Structured programming”, Wikipedia, bit.ly/1RuSABZ, retrieved

2016-08-03.

7Starting with Simula [1], OO programming developed through Smalltalk to many
other computer languages including the widely-used C++. See also “Object-oriented
programming”, Wikipedia, bit.ly/20Rx76M, retrieved 2016-08-11.

4

4 The SP theory of intelligence

These reforms have been very welcome and useful but the problem of excess
variety persists. Some more tough love is needed but, fortunately, there
appears to be a solution, an unexpected by-product of the SP theory of
intelligence [12, 11] that comes with some compensating beneﬁts including
potential for the development of AI—some sugar to help the medicine go
down.

The SP theory, and its realisation in the SP computer model, is the prod-
uct of a long-term programme of research which has been aiming, in ac-
cordance with Occam’s Razor, to simplify and integrate observations and
concepts across artiﬁcial intelligence, mainstream computing, mathematics,
and human perception and cognition. It is a theory of computing, a successor
to Alan Turing’s concept of a “universal Turing machine” (UTM) as a def-
inition of “computing” but with much of the human-like intelligence which,
as Turing recognised [9, 10], is missing from the UTM.

Distinctive features and advantages of the SP theory are described in [16].
Potential beneﬁts and applications of the SP system are described in several
papers, detailed with download links near the top of bit.ly/1mSs5XT. It is
envisaged that the SP computer model will provide the basis for a new kind
of high-parallel computer, the SP machine.

In brief, the SP theory proposes: 1) that all kinds of knowledge may be
represented with arrays of atomic symbols in one or two dimensions, called
patterns; 2) that all kinds of processing is done by compressing information—
by searching for patterns, or parts of patterns, that match each other and
by the merging or “uniﬁcation” of patterns or parts of patterns that are the
same. This idea—“information compression by the matching and uniﬁcation
of patterns” (ICMUP)—is bedrock in the theory; 3) more speciﬁcally, all
kinds of processing is done by compressing information by the building and
manipulation of multiple alignments, a concept borrowed and adapted from
bioinformatics (more in Section 4.1); 4) Because of the intimate relationship
that exists between information compression and concepts of prediction and
probability [5], the SP system is fundamentally probabilistic. That said, it
has potential, if required, to imitate the clockwork style of computation in
much of mathematics and logic [11, Section 4.4.4, Chapter 10].

As described elsewhere [12, Section 5.2], an important principle in the
unsupervised learning of new knowledge in the SP system, is that it should
conform to the “DONSVIC” principle—the discovery of natural structures via
information compression, where “natural” structures are those that people
would regard as natural, much as in object-oriented programming. There
is evidence that the representation of knowledge in accordance with the

5

DONSVIC principle normally achieves relatively high levels of information
compression.

4.1 Multiple alignments in bioinformatics and in the

SP system

In bioinformatics, multiple alignment means an arrangement of two or more
DNA sequences, or amino-acid sequences, so that, by judicious stretching of
sequences, matching symbols—as many as possible—are brought into line.
An example is shown in Figure 1.

G G A
| | |
G G | G
| | |

C A G G G A G G A
G
|
| | | | | | | | |
G C C C A G G G A G G A
| | | | | | | | | | | |

G G A
G
T G
| | |
| |
|
G G A
| G G C G
| | |
|
| |
G A | G A
A | G A C T G C C C A G G G | G G | G C T G
| | |
|
|
|
G G A
G
| A G
| | |
|
|
|
G G A
G
G
C

| | | | | | | | |
| A G G G A G G A
| | | | | | | |
C A G G G A G G

| | |
G G A A
|
| |
G G C A

Figure 1: A ‘good’ multiple alignment amongst ﬁve DNA sequences.

In the SP system, the multiple alignment concept has been adapted as
illustrated in Figure 2. Here, the pattern in row 0—a simple sentence in this
example—is input from the system’s environment and is classiﬁed as “New”
information. The patterns in rows 1 to 8—which, in this example, represent
grammatical structures including words—are part of a relatively large set of
stored patterns which are classiﬁed as “Old”.

The aim is to ﬁnd a multiple alignment, or sometimes more than one, that
provides a means of encoding the New information economically in terms of
Old patterns ([12, Section 4.1], [11, Section 3.5]). In this example, the best
multiple alignment, shown in the ﬁgure, may be seen as an analysis or parsing
of the input sentence in terms of the stored grammatical structures.

The multiple alignment concept, as it has been developed in the SP
programme of research, has proved to be remarkably versatile in the rep-
resentation of diverse forms of knowledge and modelling diverse aspects of
intelligence, as outlined below.
It has potential to be the “double helix”
of intelligence—as signiﬁcant for an understanding of “intelligence” broadly
construed as is DNA for biological sciences.

6

s
k i t t e n
| | | | | |
|
Nr 5 k i t t e n #Nr |
|
|
#Nr s #N

|

0

1

2

3

4

5

6

8

t w o
| | |
| | |
| | |
N Np Nr
| | |
| |
| | |
D Dp 4 t w o #D | |
|
|
| |
#D N |
NP D
|
|
|
|
|
|
|
|
|
|
|
; NP
|
|
Np
Num PL ;

|

7 S Num

p l a y
| | | |
| | | |
| | | |
| | | |
| | | |
| | | |
| | | |
| | | |
| | | |
Vr 1 p l a y #Vr
|

|

0

1

2

3

4

5

6

#Vr #V

|
#V #S 7

8

|
|
|
#N #NP

|
|
|
| V Vp Vr
| | |
#NP V |
|
Vp

Figure 2: The best multiple alignment created by the SP computer model
with the sentence ‘t w o k i t t e n s p l a y’ as the New pattern and a set of
Old patterns representing grammatical structures, including words.

5 How the SP system may help solve the
problem of excess variety in computing

There are three main reasons why the SP theory may help solve the prob-
lem of excess variety in computing: the versatility of the SP system in the
representation of diverse kinds of knowledge; the versatility of the system in
modelling diverse aspects of intelligence; and the generality of the principles
on which the SP system is based. Versatility and generality in the system
can yield a global simpliﬁcation in computing, as described in Section 6.

5.1 Versatility of the SP system in the representation

of knowledge

SP patterns, within the multiple alignment framework, have proved to be an
eﬀective means of representing several diﬀerent kinds of knowledge, includ-
ing the syntax of natural languages, class hierarchies, part-whole hierarchies,
discrimination networks and trees, entity-relationship structures, relational
knowledge, rules for reasoning, patterns, images, structures in three dimen-
sions, and procedural knowledge. There is more detail throughout [11] and
[12], and there are references to further sources of information in [14, Section
III-B].

7

5.2 Versatility of the SP system in aspects of intelli-

gence

The processing of knowledge in the multiple alignment framework has proved
to be a means of modelling several aspects of intelligence including unsuper-
vised learning, the processing of natural language, fuzzy pattern recognition,
recognition at multiple levels of abstraction, best-match and semantic forms
of information retrieval, planning, problem solving, and several kinds of rea-
soning including: one-step ‘deductive’ reasoning, chains of reasoning, abduc-
tive reasoning, reasoning with probabilistic networks and trees, reasoning
with ‘rules’, nonmonotonic reasoning, Bayesian reasoning with “explaining
away”, causal reasoning, and reasoning that is not supported by evidence
([11, Chapters 5 to 9], [12, Section 10]). The system also has potential in
inference via inheritance of attributes ([12, Section 9.2], [11, Section 6.4]),
spatial reasoning [13, Section IV-F.1], and what-if reasoning [13, Section IV-
F.2].

5.3 Generality of the SP system

There is reason to believe that, in addition to its strengths in the representa-
tion of knowledge and in aspects of artiﬁcial intelligence, the SP system may
be a vehicle for any kind of computing:

• The generality of ICMUP and information compression via multiple
alignment. That the SP system should have wide scope is suggested
by:

– The generality of information compression by the matching and
uniﬁcation of patterns (ICMUP), and, more speciﬁcally, infor-
mation compression via multiple alignment,
in the representa-
tion of knowledge and, more speciﬁcally, in the realisation of the
DONSVIC principle (Section 4).

– The signiﬁcance of information compression in its intimate con-
nection with concepts of prediction and probability [5], mentioned
in Section 4.

• Turing completeness. As described in [11, Chapter 4], the workings
of the SP system may be interpreted in terms of the operations of a
Post canonical system [8]. Since it is accepted that the Post canonical
system is Turing complete [6, Chapters 10 to 14]—meaning that it can
simulate any any single-taped universal Turing machine—the same is
probably true of the SP system.

8

• Modelling programming concepts in the multiple alignment framework.
Although multiple alignments like the one shown in Figure 2 may seem
to be far removed from the programming of ordinary computers, the
relationship is much closer than it may superﬁcially appear. The SP
system with the multiple alignment framework can not only model
“static” kinds of knowledge structure like class hierarchies and part-
whole hierarchies (Section 5.1) but, as described in [15, Section 6.6],
it can also model most of the concepts that are familiar in ordinary
programming, including procedure, variable, value, type, function with
parameters, conditional statement, iteration or recursion, and the ele-
ments of object-oriented programming. There is also potential for the
processing of parallel streams of information as described in [13, Sec-
tions V-G, V-H, and V-I, and Appendix C].

• Compression of information. Although the SP system may, in prin-
ciple, be a vehicle for any kind of computing—because information
compression is a broad church that may encompass low levels of infor-
mation compression as well as high levels—it would normally operate in
a manner that would give priority to well-compressed structures, avoid-
ing the poorly-compressed structures which are prominent in comput-
ing systems as they are now, with excess variety and complexity, and
the associated problems outlined in Section 2.

With regard to the third point—the modelling of programming
concepts—there is the possibility that, with further development, the work-
ings of the SP system would be determined largely by what it learns via
unsupervised learning (an important feature of the SP system), but also,
where necessary, by a version of “programming” that would be similar in
some respects to how computers are programmed now.

Key diﬀerences between SP programming and traditional programming

would be:

• Real-world structures and procedures. That the former should be con-
cerned exclusively with structures and procedures in the world outside
the computer—such as the control of traﬃc lights or processes in a
factory—whereas the latter is concerned partly with aspects of the
world outside the computer and partly with overcoming deﬁciencies in
computing hardware. We shall return to the latter point in Section 6.

• Parsimony in the representation of knowledge. That the former, in ac-
cordance with the principles of object-oriented programming and the

9

DONSVIC principle (Section 4), should aim to model real-world struc-
tures and processes in an economical manner, whereas the latter, in
its concern with the workings of computing hardware, may lose touch
with the need for parsimony in the representation of knowledge.

5.4 Towards a universal framework for the representa-
tion and processing of diverse kinds of knowledge

Overall, the three aspects of generality in the SP system outlined above
suggest that it’s potential is not restricted to the areas mentioned in Sections
5.1 and 5.2 but may extend to all kinds of knowledge and all aspects of
computation and human-like intelligence. It has potential to be a universal
framework for the representation and processing of diverse kinds of knowledge
(UFK), as outlined in [14, Section III-A].

As a UFK, the SP system would be “universal” in the sense that it
would provide for the economical representation of any kind of knowledge
and for any kind of computation, including the kinds of things that are
seen as human-like intelligence—but it would provide more discipline than
in present-day computers, reducing or eliminating unnecessary complexity
in computing and the kinds of excess variety discussed earlier.
It has the
potential to reduce the near-4000 diﬀerent kinds of computer ﬁle to one, and
to reduce the hundreds of diﬀerent computer languages to one.

An analogy is that, with clay, we can in principle create any shape. But
experts in the creation of ceramics know that some kinds of shape work
better than others. Likewise, in computing, we should be seeking to avoid
the excessive complexity that features in so much of modern software.

6 How a global simpliﬁcation in computing

may be achieved

Another way of looking at these issues is via an idea that is already estab-
lished in computer science as the basis for such things as database manage-
ment systems (DBMSs) and shells for expert systems. A lot of eﬀort can be
saved with DBMSs and a lot of complexity can be avoided by creating one
general-purpose system for the storage and retrieval of data and loading it
with diﬀerent kinds of data according to need. Eﬀort can be saved because
there is no need, with each new database, to re-program the procedures for
the storage and retrieval of data. And, correspondingly, there will be an over-
all reduction in the complexity of any collection of several DBMSs. Much

10

the same may be said, mutatis mutandis, about expert systems.

The SP system is more ambitious than DBMSs and shells for expert
systems because, instead of the fairly narrow range of capabilities of those
systems, the SP system aims to provide a much wider variety of capabili-
ties, with human-like versatility and adaptability in intelligence and, where
required, the means of modelling real-world procedures and processes in the
manner of ordinary programming (Section 5.3).

Potential beneﬁts in terms of simplicity are illustrated in Figure 3 which
shows, at the top, a schematic representation of a conventional computer and,
at the bottom, a schematic representation of the SP machine, expressing the
SP theory.

Figure 3: Schematic representations of a conventional computer and the
proposed SP machine, showing potential beneﬁts in terms of simpliﬁcation,
as discussed in the text. Adapted from Figure 4.7 in [11], with permission.

In the conventional computer there is a central processing unit (CPU),
with little or no human-like intelligence—shown on the left in the ﬁgure. On
the right, there is “input” to the computer—a query or some similar smallish
piece of information to be processed; there is also “software” with elements
described in the next paragraph; and, very often, there is the kind of “data”
that may stored in an external ﬁle or database.

The software normally contains two main kinds of information:

11

(cid:67)(cid:80)(cid:85)(cid:73)(cid:110)(cid:112)(cid:117)(cid:116)(cid:32)(cid:43)(cid:32)(cid:83)(cid:111)(cid:102)(cid:116)(cid:119)(cid:97)(cid:114)(cid:101)(cid:32)(cid:40)(cid:111)(cid:102)(cid:116)(cid:101)(cid:110)(cid:45)(cid:114)(cid:101)(cid:112)(cid:101)(cid:97)(cid:116)(cid:101)(cid:100)(cid:105)(cid:110)(cid:115)(cid:116)(cid:114)(cid:117)(cid:99)(cid:116)(cid:105)(cid:111)(cid:110)(cid:115)(cid:32)(cid:43)(cid:32)(cid:107)(cid:110)(cid:111)(cid:119)(cid:108)(cid:101)(cid:100)(cid:103)(cid:101)(cid:41)(cid:32)(cid:43)(cid:8220)(cid:100)(cid:97)(cid:116)(cid:97)(cid:8221)(cid:67)(cid:111)(cid:110)(cid:118)(cid:101)(cid:110)(cid:116)(cid:105)(cid:111)(cid:110)(cid:97)(cid:108)(cid:99)(cid:111)(cid:109)(cid:112)(cid:117)(cid:116)(cid:101)(cid:114)(cid:87)(cid:105)(cid:116)(cid:104)(cid:111)(cid:117)(cid:116)(cid:32)(cid:8220)(cid:105)(cid:110)(cid:116)(cid:101)(cid:108)(cid:108)(cid:105)(cid:103)(cid:101)(cid:110)(cid:99)(cid:101)(cid:8221)(cid:67)(cid:80)(cid:85)(cid:78)(cid:101)(cid:119)(cid:32)(cid:40)(cid:105)(cid:110)(cid:112)(cid:117)(cid:116)(cid:41)(cid:32)(cid:43)(cid:79)(cid:108)(cid:100)(cid:32)(cid:40)(cid:107)(cid:110)(cid:111)(cid:119)(cid:108)(cid:101)(cid:100)(cid:103)(cid:101)(cid:41)(cid:83)(cid:80)(cid:32)(cid:109)(cid:97)(cid:99)(cid:104)(cid:105)(cid:110)(cid:101)(cid:87)(cid:105)(cid:116)(cid:104)(cid:32)(cid:8220)(cid:105)(cid:110)(cid:116)(cid:101)(cid:108)(cid:108)(cid:105)(cid:103)(cid:101)(cid:110)(cid:99)(cid:101)(cid:8221)• Instructions that are designed to make up for the deﬁciencies in the
CPU. These may include procedures for recognising patterns, proce-
dures for searching for information, and procedures for retrieving stored
information. Very often, such procedures, or variants of them, are re-
peated again and again within one program or across many diﬀerent
programs.

• Very often, the software also contains signiﬁcant knowledge about the
world, such as real-world procedures for applying for a driving licence,
booking a seat on a train, and so on.

It is envisaged that the SP machine will be simpler. All processing will
be done in a CPU, shown on the left in the ﬁgure, which will supply all the
human-like intelligence of the system, including procedures for the building
and manipulation of multiple alignments. The rest of the system, shown on
the right, will be New and Old information as described in Section 4.1.

The New information is “input” to the system, as in the conventional
computer, while the Old information is the system’s knowledge about the
world, including what would conventionally be called “data” and the kinds
of knowledge mentioned earlier such as real-world procedures for applying
for a driving licence or for booking a seat on a train.8

The key diﬀerences between a conventional computer and the SP machine
are that, in the latter, all information about how to process information
would be contained in the CPU and there would be a single repository of
knowledge about the world, including knowledge about real-world procedures
and processes.

The CPU in the SP machine is shown a bit larger than the CPU in
the conventional computer to suggest that it is a bit more complex than
a conventional CPU. But, despite this additional complexity, the rectangle
representing the SP machine is shown smaller than the rectangle representing
the conventional computer to indicate that, with the SP system, there can be
a global simpliﬁcation in computing. This is because it will not be necessary
to add instructions, often with repetition, to make up for the shortcomings
of the CPU in the conventional computer, and also because all knowledge in
the SP machine will be highly compressed.

Readers may say “Isn’t this simply a reinvention of the concept of declar-
ative programming, separating information about ‘what’ a program is to do
from the details of ‘how’ the objectives are to be achieved?”9 Yes and no.

8With applications that are purely abstract, such as applications that are specialised
for one or more aspects of mathematics, we may suppose that the Old information would
comprise knowledge of relevant abstract concepts.

9See “Declarative programming”, Wikipedia, bit.ly/2aVJAIE, retrieved 2016-08-15.

12

“Yes” because there are some similarities in the overall concept but “no”
because the SP machine, with multiple alignment at its core, has the poten-
tial to yield much more human-like versatility and adaptability than logic
programming, functional programming, or the like.

7 Conclusion

The SP system was developed mainly to advance AI. But in addition to its
several strengths in that area, it has the potential to reduce or eliminate the
curse of variety in computing. Although it may seem impossibly ambitious,
there is real potential to cut the variety of ﬁle types from nearly 4,000 to one,
and to cut the hundreds of computer languages to one.

The multiple alignment framework has the potential to be a universal
framework for the representation and processing of diverse kinds of knowledge
(UFK). It is envisaged that all kinds of knowledge will be represented with
SP patterns and all kinds of processing will be done via the building and
manipulation of multiple alignments.

Of course, there would still be diﬀerent kinds of application. But instead
of programs containing a mixture of real-world knowledge and often-repeated
instructions needed to make good the shortcomings of conventional CPUs,
each application will comprise nothing but knowledge that is relevant to its
area of application, including knowledge about signiﬁcant real-world entities,
and classes of such entities, and real-world operations with those things.

Probably, the best way to advance these ideas would be, ﬁrstly, to create
a high-parallel version of the SP machine, based on the SP theory as it has
been realised in the SP computer model, and, secondly, to make the SP
machine available to researchers everywhere to see what can be done with
the SP system, and to create new versions of it. How things may develop is
shown schematically in Figure 4.

13

Figure 4: A schematic view of how the SP machine may develop from the SP
theory and the SP computer model. Adapted, with permission, from Figure
6 in [14].

8 Author

Gerry Wolﬀ (jgw@cognitionreseardh.org)
is Director of CognitionRe-
search.org (www.cognitionresearch.org), concentrating mainly on the devel-
opment of the SP theory of intelligence and its realisation in the SP machine.

References

[1] G. M. Birtwistle, O-J Dahl, B. Myhrhaug, and K. Nygaard. Simula

Begin. Studentlitteratur, Lund, 1973.

[2] E. W. Dijkstra. Letters to the editor: go to statement considered harm-

ful. Communications of the ACM, 11(3):147–148, 1968.

[3] M. A. Jackson. Principles of Program Design. Academic Press, New

York, 1975.

[4] J. E. Kelly and S. Hamm. Smart machines: IBM’s Watson and the era
of cognitive computing. Columbia University Press, New York, Kindle
edition, 2013.

14

(cid:83)(cid:80)(cid:32)(cid:116)(cid:104)(cid:101)(cid:111)(cid:114)(cid:121)(cid:32)(cid:97)(cid:110)(cid:100)(cid:32)(cid:83)(cid:80)(cid:32)(cid:99)(cid:111)(cid:109)(cid:112)(cid:117)(cid:116)(cid:101)(cid:114)(cid:32)(cid:109)(cid:111)(cid:100)(cid:101)(cid:108)(cid:83)(cid:80)(cid:32)(cid:116)(cid:104)(cid:101)(cid:111)(cid:114)(cid:121)(cid:32)(cid:97)(cid:110)(cid:100)(cid:32)(cid:83)(cid:80)(cid:32)(cid:99)(cid:111)(cid:109)(cid:112)(cid:117)(cid:116)(cid:101)(cid:114)(cid:32)(cid:109)(cid:111)(cid:100)(cid:101)(cid:108)(cid:83)(cid:80)(cid:32)(cid:77)(cid:65)(cid:67)(cid:72)(cid:73)(cid:78)(cid:69)(cid:83)(cid:80)(cid:32)(cid:77)(cid:65)(cid:67)(cid:72)(cid:73)(cid:78)(cid:69)(cid:72)(cid:105)(cid:103)(cid:104)(cid:32)(cid:112)(cid:97)(cid:114)(cid:97)(cid:108)(cid:108)(cid:101)(cid:108)(cid:73)(cid:110)(cid:32)(cid:116)(cid:104)(cid:101)(cid:32)(cid:99)(cid:108)(cid:111)(cid:117)(cid:100)(cid:79)(cid:112)(cid:101)(cid:110)(cid:32)(cid:115)(cid:111)(cid:117)(cid:114)(cid:99)(cid:101)(cid:71)(cid:111)(cid:111)(cid:100)(cid:32)(cid:117)(cid:115)(cid:101)(cid:114)(cid:32)(cid:105)(cid:110)(cid:116)(cid:101)(cid:114)(cid:102)(cid:97)(cid:99)(cid:101)(cid:82)(cid:101)(cid:112)(cid:114)(cid:101)(cid:115)(cid:101)(cid:110)(cid:116)(cid:97)(cid:116)(cid:105)(cid:111)(cid:110)(cid:32)(cid:111)(cid:102)(cid:32)(cid:107)(cid:110)(cid:111)(cid:119)(cid:108)(cid:101)(cid:100)(cid:103)(cid:101)(cid:78)(cid:97)(cid:116)(cid:117)(cid:114)(cid:97)(cid:108)(cid:32)(cid:108)(cid:97)(cid:110)(cid:103)(cid:117)(cid:97)(cid:103)(cid:101)(cid:32)(cid:112)(cid:114)(cid:111)(cid:99)(cid:101)(cid:115)(cid:115)(cid:105)(cid:110)(cid:103)(cid:83)(cid:101)(cid:118)(cid:101)(cid:114)(cid:97)(cid:108)(cid:32)(cid:107)(cid:105)(cid:110)(cid:100)(cid:115)(cid:32)(cid:111)(cid:102)(cid:32)(cid:114)(cid:101)(cid:97)(cid:115)(cid:111)(cid:110)(cid:105)(cid:110)(cid:103)(cid:80)(cid:108)(cid:97)(cid:110)(cid:110)(cid:105)(cid:110)(cid:103)(cid:32)(cid:38)(cid:32)(cid:112)(cid:114)(cid:111)(cid:98)(cid:108)(cid:101)(cid:109)(cid:32)(cid:115)(cid:111)(cid:108)(cid:118)(cid:105)(cid:110)(cid:103)(cid:73)(cid:110)(cid:102)(cid:111)(cid:114)(cid:109)(cid:97)(cid:116)(cid:105)(cid:111)(cid:110)(cid:32)(cid:99)(cid:111)(cid:109)(cid:112)(cid:114)(cid:101)(cid:115)(cid:115)(cid:105)(cid:111)(cid:110)(cid:85)(cid:110)(cid:115)(cid:117)(cid:112)(cid:101)(cid:114)(cid:118)(cid:105)(cid:115)(cid:101)(cid:100)(cid:32)(cid:108)(cid:101)(cid:97)(cid:114)(cid:110)(cid:105)(cid:110)(cid:103)(cid:80)(cid:97)(cid:116)(cid:116)(cid:101)(cid:114)(cid:110)(cid:32)(cid:114)(cid:101)(cid:99)(cid:111)(cid:103)(cid:110)(cid:105)(cid:116)(cid:105)(cid:111)(cid:110)(cid:73)(cid:110)(cid:102)(cid:111)(cid:114)(cid:109)(cid:97)(cid:116)(cid:105)(cid:111)(cid:110)(cid:32)(cid:114)(cid:101)(cid:116)(cid:114)(cid:105)(cid:101)(cid:118)(cid:97)(cid:108)(cid:77)(cid:65)(cid:78)(cid:89)(cid:32)(cid:65)(cid:80)(cid:80)(cid:76)(cid:73)(cid:67)(cid:65)(cid:84)(cid:73)(cid:79)(cid:78)(cid:83)(cid:77)(cid:65)(cid:78)(cid:89)(cid:32)(cid:65)(cid:80)(cid:80)(cid:76)(cid:73)(cid:67)(cid:65)(cid:84)(cid:73)(cid:79)(cid:78)(cid:83)[5] M. Li and P. Vit´anyi. An Introduction to Kolmogorov Complexity and

Its Applications. Springer, New York, 3rd edition, 2014.

[6] M. L. Minsky. Computation, Finite and Inﬁnite Machines. Prentice

Hall, Englewood Cliﬀs, NJ., 1967.

[7] National Research Council. Frontiers in Massive Data Analysis. The
National Academies Press, Washington DC, 2013. ISBN-13: 978-0-309-
28778-4. Online edition: bit.ly/14A0eyo.

[8] E. L. Post. Formal reductions of the general combinatorial decision

problem. American Journal of Mathematics, 65:197–268, 1943.

[9] A. M. Turing. Computing machinery and intelligence. Mind, 59:433–460,

1950.

[10] C. S. Webster. Alan turing’s unorganized machines and artiﬁcial neural
networks: his remarkable early work and future possibilities. Evolution-
ary Intelligence, 5:35–43, 2012.

[11] J. G. Wolﬀ. Unifying Computing and Cognition: the SP Theory and Its
Applications. CognitionResearch.org, Menai Bridge, 2006. ISBNs: 0-
9550726-0-3 (ebook edition), 0-9550726-1-1 (print edition). Distributors,
including Amazon.com, are detailed on bit.ly/WmB1rs.

[12] J. G. Wolﬀ. The SP theory of intelligence: an overview. Information,

4(3):283–341, 2013. bit.ly/1hz0lFE.

[13] J. G. Wolﬀ. Autonomous robots and the SP theory of intelligence. IEEE

Access, 2:1629–1651, 2014. bit.ly/1zrSemu.

[14] J. G. Wolﬀ. Big data and the SP theory of intelligence. IEEE Access,
2:301–315, 2014. bit.ly/1jGWXDH. This article, with minor revisions,
is to be reproduced in Fei Hu (Ed.), Big Data: Storage, Sharing, and
Security (3S), Taylor & Francis LLC, CRC Press, 2016, pp. 143–170.

[15] J. G. Wolﬀ. The SP theory of intelligence: beneﬁts and applications.

Information, 5(1):1–27, 2014. bit.ly/1lcquWF.

[16] J. G. Wolﬀ. The SP theory of intelligence: its distinctive features and

advantages. IEEE Access, 4:216–246, 2016. bit.ly/21gv2jT.

15

