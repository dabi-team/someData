Enterprise Cyber Resiliency Against Lateral
Movement: A Graph Theoretic Approach

Pin-Yu Chen∗, Sutanay Choudhury†, Luke Rodriguez†, Alfred O. Hero III‡ and Indrajit Ray§
∗IBM Research. Email: pin-yu.chen@ibm.com
†Paciﬁc Northwest National Laboratory. Email: {Sutanay.Choudhury,Luke.Rodriguez}@pnnl.gov
‡Department of Electrical Engineering and Computer Science, University of Michigan, Ann Arbor. Email: hero@umich.edu
§Department of Computer Science, Colorado State University. Email: indrajit@cs.colostate.edu

9
1
0
2

y
a
M
3

]

R
C
.
s
c
[

1
v
2
0
0
1
0
.
5
0
9
1
:
v
i
X
r
a

Abstract—Lateral movement attacks are a serious threat to
enterprise security. In these attacks, an attacker compromises a
trusted user account to get a foothold into the enterprise network
and uses it to attack other trusted users, increasingly gaining
higher and higher privileges. Such lateral attacks are very hard
to model because of the unwitting role that users play in the attack
and even harder to detect and prevent because of their low and
slow nature. In this paper, a theoretical framework is presented
for modeling lateral movement attacks and for proposing a
methodology for designing resilient cyber systems against such
attacks. The enterprise is modeled as a tripartite graph capturing
the interaction between users, machines, and applications, and a
set of procedures is proposed to harden the network by increasing
the cost of lateral movement. Strong theoretical guarantees on
system resilience are established and experimentally validated
for large enterprise networks.

I.

INTRODUCTION

Cyber security is one of the most critical problems of our
time. Notwithstanding the enormous strides that researchers
and practitioners have made in modeling, analyzing and miti-
gating cyber attacks, black hats ﬁnd newer and newer methods
for launching attacks requiring white hats to revisit the problem
with a new perspective. One of the major ways1 that attackers
launch an attack against an enterprise is by what is known
as “lateral movement via privilege escalation”. This attack
cycle, shown in Fig. 1, begins with the compromise of a single
user account (not necessarily a privileged one) in the targeted
organization typically via phishing email, spear phishing or
other social engineering techniques. From this initial foothold
and with time on his side, the attacker begins to explore the
network, possibly compromising other user accounts until he
gains access to a user account with administrative privileges
to the coveted resource: ﬁles containing intellectual property,
employee or customer databases or credentials to manage the
network itself. Typically the attacker compromises multiple
intermediate user accounts, each granting him increasing priv-
ileges. Skilled attackers frequently camouﬂage their lateral
movements into the normal network trafﬁc making these
attacks particularly difﬁcult to detect and insidious.

This work was partially supported by the Consortium for Veriﬁcation Tech-
nology under Department of Energy National Nuclear Security Administration
award number de-na0002534 and by the Asymmetric Resilient Cyber Security
initiative at Paciﬁc Northwest National Laboratory, which is operated by
Battelle Memorial Institute.

1http://www.verizonenterprise.com/DBIR

Fig. 1: An illustration of a cyber attack using privilege esca-
lation techniques.

Such lateral attacks are particularly insidious because au-
thorized users play the role of an unwitting accomplice. End
users have often been recognized as the “weakest links” in
cyber security [1]. They do not follow security advice and
often take actions that compromise themselves as well as
others. While efforts to educate and train end users for cyber
security are important steps, anecdotal evidence shows that
they have not been as effective. Clearly,
there is a need
for designing large enterprises that are resilient against such
lateral movement attacks. Our current work takes a step in this
direction.

Resilient systems accept that not all attacks can be detected
and prevented; nonetheless,
the system should be able to
continue operation even in the face of cyber attacks and
provide its core services or missions even if in a degraded
manner [2]. To build such a resilient system it is important
to be proactive in understanding and reasoning about lateral
movement in an enterprise network, its potential effects on the
organization, and identify ways to best defend against these
threats. Unfortunately, a theoretical framework for such risk
analysis is currently missing. Our goal in this paper is to
establish the theoretical foundations of a systematic framework
for building networks resilient to lateral movement attacks.

We model

lateral movement attack on an enterprise’s
mission as a graph walk on a tripartite user-host-application
network that logically comprises of two subgraphs: a user-
host graph and a host-application graph. Fig. 2 illustrates

 
 
 
 
 
 
(a) A tripartite network

(b) Segmentation

(c) Edge hardening

(d) Node hardening

Fig. 2: (a) Illustration of a tripartite network consisting of a set of users, a set of hosts and a set of applications. (b) Segmentation
- the user Charlie modiﬁes his access conﬁguration by disabling the access of the existing account (Charlie-2) to host H3 and
by creating a new user account (Charlie-1) for accessing H3 such that an attacker cannot reach the data server H5 though the
printer H3 if Charlie-2 is compromised. (c) Edge hardening via additional ﬁrewall rules on all network ﬂows to H5 through
HTTP. (d) Node hardening via system update or security patch installation on H5.

TABLE I: Utility of the proposed algorithms and established
theoretical results.

System Heterogeneity
User-Host
Host-Application
User-Host-Application

Hardening Methods
Algorithms 1, 2
Algorithms 3, 4
all of the above

Theoretical Guarantees
Theorem 2, Corollary 1
Theorem 5, Corollary 2
all of the above

resilience to lateral movement attacks, to assist reading the
utility of the proposed approaches and the established theoret-
ical results are summarized in Table I, and the proofs of the
established mathematical results are placed in the appendices
in the supplementary ﬁle2.

The research contributions of this paper are listed as

the model and our methodology. The user-host-application
paradigm entails richer information than single (homogeneous)
graph models (e.g., host-host communication networks). For
instance, the host-host communication network can be derived
from the host-application subgraph. The user-host-application
paradigm also allows us to develop an abstraction of a mission
in terms of concrete entities whose behavior can be monitored
and controlled, which captures interactions between diverse
categories of users, software and hardware resources (e.g., vir-
tual machines, workstations, mobile devices) and applications.

Deﬁning lateral movements as graph walks allows us to
determine which nodes in the tripartite graph can be reached
starting at a given node. From an attacker’s perspective, these
nodes that can be “reached” are exactly those mission com-
ponents that can be attacked and compromised via exploits.
The larger the number of nodes that can be reached by the
attacker, the more “damage” he/she can cause to the mission.
Given a system snapshot and a compromised workstation or
mobile device, we can deﬁne the “Attacker’s Reachability” as
a measure that estimates the number of hosts at risk through
a given number of system exploits. Now, from a defender’s
perspective, putting some defensive control on one of these
nodes (or edges) allows the walk to be broken at that point.
Intuitively, such a walk can also be used to identify mission
idea is
hardening strategies that reduce risk. This central
illustrated in Fig. 2. The heterogeneity of a cyber system entails
a network of networks (NoN) representation of entities in the
system as displayed in Fig. 2, allowing us to devise effective
hardening strategies from different perspectives, which differs
from works focusing on manipulating the network topology
under the assumption that the graph is homogeneous, that is,
all nodes have an identical role in a cyber system.

As our model considers the heterogeneity of a cyber system
and incorporates several defensive actions for enhancing the

follows.

1)

By modeling lateral movements as graph walks on a
user-host-application tripartite graph, we can specify
the dominant factors affecting attacker’s reachability
(Sec. III), setting the stage for proposing greedy
hardening and segmentation algorithms for network
conﬁguration change recommendation to reduce the
attacker’s reachability (Sec. IV and Sec. V).

2) We characterize the effectiveness of three types of
defensive actions against lateral movement attacks,
each of which can be abstracted via a node or
edge operation on the tripartite graph, which are (a)
segmentation in user-host graph (Sec. IV), (b) edge
hardening in host-application graph (Sec. V), and (c)
node hardening in host-application graph (Sec. V).

3) We provide quantiﬁable guarantees (e.g., submod-
ularity) on the performance loss of the proposed
greedy algorithms relative to the optimal batch al-
gorithms that have combinatorial computation com-
plexity (Theorem 2 and Theorem 5).

tri-
4) We apply our algorithms to a collected real
partite network dataset and demonstrate that
the
proposed approaches can signiﬁcantly constrain at-
tacker’s reachability and hence provide effective con-
ﬁguration recommendations to secure the system
(Sec. VI).

5) We collect traces of real lateral movement attacks in
a cyber system for performance evaluation (Sec. VII).
We benchmark our approach against
the NetMelt
algorithm [3] and show that our approach can achieve
the same reduction in attacker’s reachability by hard-
ening nearly 1/3 of the resources as recommended by
NetMelt.

2Supplementary material: https://goo.gl/h8XHZX

II. BACKGROUND AND RELATED WORK

Laterally moving through a cyber network looking to
obtain access to administrator’s credentials or conﬁdential
information is a common technique in an attacker’s toolbox
[4]. Particularly, privilege escalation through lateral movement
is a critical challenge for the security community [5]–[7]. For
anomaly detection the authors in [8] employ graph clustering
to group activities with similar behavioral pattern and make
change recommendations when the access control methods in
place deviate from the real-world activity patterns. The authors
in [9] use community structure to detect anomalous insiders
in collaborative information systems. For attack prevention the
authors in [10] use a graph partitioning approach to fragment
the network to limit the possibilities of lateral movement. For
risk assessment the authors in [11], [12] use epidemic models
for modeling and controlling malware propagation.

Our work ﬁts into two emerging areas of study, 1) Net-
work of networks (NoN) representing multiple inter-related
networks as a single model, and 2) studies on resilience of
networks. Recently NoN has been an active area of research
with diverse topics such as cascading analysis and control
in interdependent networks [13], [14], improved grouping or
ranking of entities in a network [15], and mapping of domain
problems into the NoN paradigm [16]. Network resilience is
a long studied topic [17], primarily focusing on the physical
topology of communication networks. There has been a surge
in focus on enterprise-level cyber resilience [2], [18], where
the entire enterprise structure is modeled as a NoN.

Recently researches have focused on altering the network
structure to improve its resilience, as measured in terms of the
spectral properties [19], [20]. Preventing contagion in networks
is another attribute for resilience, and approaches such as
[21] suggest algorithms that immunize a subset of nodes as
a preventive measure. We contribute to this research area by
unifying multiple data sources (e.g., different perspectives of
user behaviors) into a single model. Integration of multiple
data sources such as user access control and application trafﬁc
over the network makes the model more comprehensive and
resulting recommendations more profound [22]. This paper is
tailored to providing action recommendations for enhancing
the resilience of a heterogeneous cyber system based on the
associated NoN representation, which differs from previous
works that focus on manipulating the topology of a simple
(homogeneous) network where each node in the graph has an
identical role [3], [23]. To the best of our knowledge, this paper
proposes the ﬁrst representation of a cyber system using the
NoN model for designing algorithms that improve resiliency
against lateral movement attacks.

III. NETWORK MODEL AND ITERATIVE REACHABILITY
COMPUTATION OF LATERAL MOVEMENT

A. Notation and Tripartite Graph Model

TABLE II: List of main notation and symbols.

U/N/K
λmax(X)
⊗
1n
AC
A
P
B
J
r / a
T(x)
Ha(x)

number of users / hosts / applications
largest eigenvalue of matrix X
Kronecker product
n × 1 column vector of ones
User-host graph matrix
Host-application graph matrix
Compromise probability matrix
AT
(P ⊗ 1N )T AT
Reachability / Hardening level vector
Threshold function on vector x
Comparator function of x and a

C AC

the number of elements in the set X . The expression e denotes
the Euler’s number, i.e., the base of the natural logarithm.
The expression ex
i denotes the x × 1 canonical vector of zero
entries except its i-th entry is 1. The expression In denotes the
n × n identify matrix. The expression 1n denotes the n × 1
column vector of ones. The expression colx(X) denotes the x-
th column of X. The expression λmax(X) denotes the largest
eigenvalue (in magnitude) of a square matrix X. The operation
·T denotes matrix or vector transpose. The operation ⊗ denotes
the Kronecker product which is deﬁned in Appendix A. The
operation (cid:12) denotes the Hadamard (entry-wise) product of
matrices. The operator T : Rn
+ (cid:55)→ [0, 1]n is a threshold function
such that [T(x)]i = [x]i if 0 ≤ [x]i ≤ 1 and [T(x)]i = 1 if
[x]i > 1. The operator Ha : [0, 1]n (cid:55)→ {0, 1}n is an entry-
wise indicator function such that [Ha(x)]i = 1 if [x]i > [a]i,
and [Ha(x)]i = 0 otherwise. The tripartite graph in Fig. 2
can be characterized by a set of users Vuser, a set of hosts
Vhost, a set of applications Vapp, a set of user-host accesses
E ⊂ Vuser × Vhost, and a set of host-application-host activities
T ⊂ Vhost × Vapp × Vhost. The cardinality of Vuser, Vhost
and Vapp are denoted by U , N and K, respectively. The main
notation and symbols are listed in Table II.

B. Reachability of Lateral Movement on User-Host Graph

Let GC = (Vuser, Vhost, E) with E ⊂ Vuser × Vhost
denoting the user-host bipartite graph. The access privileges
between users and hosts are represented by a binary U × N
adjacency matrix AC, where [AC]ij = 1 if user i can access
host j, and [AC]ij = 0 otherwise. Let r0 be an N × 1
binary vector indicating the initial host compromise status,
where [r0]j = 1 if host j is initially being compromised, and
[r0]j = 0 otherwise. Given r0, we are interested in computing
the ﬁnal binary compromise vector r∞ when attackers leverage
user access privileges to compromise other accessible hosts.
The vector r∞ speciﬁes the reachability of a lateral movement
attack, where reachability is deﬁned as the fraction of hosts
that can be reached via graph walks on GC starting from r0.
Therefore, reachability is used as a quantitative measure of net-
work vulnerability to lateral movement attacks. Furthermore,
studying r∞ allows us to investigate the dominant factor that
leads to high reachability and more efﬁcient countermeasures.

Throughout this paper a scripted uppercase letter (e.g., X )
denotes a set, a boldfaced uppercase letter (e.g., X or Xk)
denotes a matrix, and its entry in the i-th row and the j-
column is denoted by [·]ij, a boldfaced lowercase letter (e.g.,
x or xk) denotes a column vector, and its i-th entry is denoted
by [·]i, and a plain uppercase or lowercase letter (e.g., X or x)
denotes a scalar unless speciﬁed. The expression |X | denotes

The computation of r∞ can be viewed as a cascading pro-
cess of repetitive walks on GC starting from a set of compro-
mised hosts. Let rt denote the binary compromise vector after
t-hop walks and let wh be the number of h-hop walks starting
from r0 and w0 = r0. The hop count of a walk between
two hosts in GC is deﬁned as the number of traversed users.
We begin by computing r1 from r0: the number of 1-hop walk

T

AT

(cid:80)N

from r0 to host j is [w1]j = (cid:80)U
k=1[AC]ij[AC]ik[r0]k =
CACr0. Let B = AT
eN
CAC, an induced adjacency matrix
j
of hosts in GC, where [B]ij is the number of common users
that can access hosts i and j. Then we have w1 = Br0 and
r1 = T(w1). Generalizing this result, we have

i=1

wh+1 = Bwh = Bh+1r0;
(cid:32) t+1
(cid:88)

(cid:33)

rt+1 = T

wh

.

(1)

(2)

h=1

The term in (2) accounts for the accumulation of compromised
hosts up to t + 1 hops. Note that based on the property of T,
(2) can be simpliﬁed as

rt+1 = T (rt + Brt) .

(Appendix B)

(3)

The recursive relation of reachability in (3) suggests that the
term B is the dominant factor affecting the propagation of
lateral movement. Moreover, from (3) we obtain an efﬁcient
iterative algorithm for computing r∞ that involves successive
matrix-vector multiplications until rt converges.

C. Reachability of Lateral Movement on Host-Application
Graph

The host-application graph contains the information of
host-host communicating through an application. Let Ak be
an N × N binary matrix representing the host-to-host commu-
nication through application k, where [Ak]ij = 1 means host
i communicates with j through application k; and [Ak]ij = 0
otherwise. The N ×KN binary matrix A = [A1 A2 · · · AK]
is the concatenated matrix of K host-application-host matrices
Ak for k = 1, 2, . . . , K. Let P denote the compromise
probability matrix, which is a K × N matrix where its
entry [P]kj speciﬁes the probability of compromising host j
through application k. In addition, each host is assigned with
a hardening value [a]j ∈ [0, 1] indicating its security level.

Similar to Sec. III-B, we are interested in computing the
reachability of lateral movement on the host-application graph.
The hop count of a walk between two hosts in the host-
application graph is deﬁned as the average number of paths be-
tween the two hosts through applications. Let W be an N ×N
matrix where [W]ij is the average number of one-hop walk
from host i to host j. Then we have [W]ij = (cid:80)K
k=1[Ak]ijPkj.
Let wh be an N × 1 vector representing the average number
of h-hop walks of hosts and w0 = r0. Then the j-th entry of
the 1-hop vector w1 is

[w1]j = eT
j

(cid:2)colj(P)T ⊗ In

(cid:3) AT r0. (Appendix C)

(4)

Stacking (4) as a column vector gives

w1 = (P ⊗ 1N )T AT r0.

(Appendix D)

(5)

The 1-hop compromise vector r1 is deﬁned as r1 =
Ha (T (w1)). In effect the operator Ha compares the thresh-
olded average number of walks with the hardening level for
each host, which means a host j can be compromised only
when the thresholded average number of 1-hop walk [T (w1)]j

is greater than its hardening level [a]j. Generalizing this result
to h-hop, we have

wh+1 = (P ⊗ 1N )T AT wh;
(cid:32)
(cid:33)(cid:33)

rt+1 = Ha

T

wh

.

(cid:32) t+1
(cid:88)

h=1

The term in (7) has an equivalent expression
(cid:16)

(cid:16)

rt+1 = Ha

T

rt + (P ⊗ 1N )T AT rt

(6)

(7)

(8)

(cid:17)(cid:17)

,

which is proved in Appendix E. Consequently, for lateral
movement on the host-application graph the matrix J =
(P ⊗ 1N )T AT is the dominant factor, and (8) leads to an
iterative algorithm for reachability computation.

D. Reachability of Lateral Movement on Tripartite User-Host-
Application Graph

Utilizing the developed results in Sec. III-B and Sec. III-C,
the cascading process of lateral movement on the tripartite
user-host-application graph can be modeled by

rt+1 ≡ Ha

(cid:16)

(cid:16)

T

rt +

(cid:104)

B + (P ⊗ 1N )T AT rt

(cid:17)(cid:105)(cid:17)

.

IV. SEGMENTATION ON USER-HOST GRAPH

In this section we investigate segmentation on user-host
graphs as a countermeasure for suppressing lateral movement.
Segmentation works by creating new user accounts to separate
user from host in order to reduce the reachability of lateral
movement, as illustrated in Fig. 2 (b). In principle, segmenta-
tion removes some edges from the access graph GC and then
merge these removed edges to create new user accounts. There-
fore, segmentation retains the same access functionality and
constrains lateral movement attacks at the price of additional
user accounts. The following analysis provides a theoretical
framework of different segmentation strategies.

Recall from (3) that the matrix B is the key factor affecting
the reachability of lateral movement on GC. Therefore, an
effective edge removal approach for segmentation is reducing
the spectral radius of B (i.e., λmax(B)) by removing some
edges from GC. Note that by deﬁnition B = AT
CAC so
that B is a positive semideﬁnite (PSD) matrix, and all entries
of B are nonnegative. Therefore, by the Perron-Frobenious
theorem [24] the entries of B’s largest eigenvector u (i.e., the
eigenvector such that Bu = λmax(B)u) are nonnegative.

Here we investigate the change in λmax(B) when an edge
is removed from GC in order to deﬁne an edge score function
that is associated with spectral radius reduction of B. If an
edge (i, j) ∈ E is removed from GC,
then the resulting
T
adjacency matrix of GC \(i, j) is (cid:101)AC ((i, j)) = AC −eU
.
The corresponding induced adjacency matrix is

i eN
j

(cid:101)B ((i, j)) = (cid:101)AC ((i, j))T
CeU
By the Courant-Fischer theorem [24] we have

(cid:101)AC ((i, j))
j eU
− eN
i

= B − AT

i eN
j

T

T

AC + eN

j eN
j

(cid:16)

(cid:17)

λmax

(cid:101)B ((i, j))

≥ uT (cid:101)B ((i, j)) u
= λmax(B) − 2uT AT

CeU

i [u]j + [u]2
j .

T

.

(9)

(10)

CeU

i [u]j −[u]2

The relation in (10) leads to a greedy removal strategy that
ﬁnds the edge (i, j) ∈ E that maximizes the edge score func-
tion 2uT AT
j , in order to minimize a lower bound
on the spectral radius of (cid:101)B ((i, j)). Moreover, Lemma 1 below
shows that the edge score function is also associated with an
upper bound on the spectral radius of (cid:101)B ((i, j)). Following
similar methodology, when a subset of edges ER ⊂ E are
removed from GC, we have

≥ λmax(B) − f (ER), (Appendix F)

(11)

(cid:16)

λmax

(cid:101)B (ER)

(cid:17)

where the function
(cid:88)

f (ER) = 2

uT AT

CeU

i [u]j

(i,j)∈ER
(cid:88)

−

(cid:88)

(cid:88)

i∈Vuser

j∈Vhost,(i,j)∈ER

s∈Vhost,(i,s)∈ER

(12)

[u]j[u]s.

In a nutshell, the function f (ER) provides a score that
evaluates the effect of edge removal set ER on the spectral
radius of (cid:101)B (ER). The lemma presented in Appendix G shows
f (ER) is nonnegative as it can be represented as a sum of
nonnegative terms. The following lemma shows that f (ER)
is associated with an upper bound on the spectral radius of
(cid:101)B (ER). Therefore, maximizing f (ER) can be an effective
strategy for spectral radius reduction of B.

Lemma 1. For any edge removal set ER with |ER| = q ≥ 1, if
there exits one edge removal set ER ⊂ E such that f (ER) > 0,
then there exists some constant c > 0 such that

λmax(B) − c · f (ER) ≥ λmax

(cid:16)

(cid:101)B (ER)

(cid:17)

.

(13)

Proof: The proof can be found in Appendix H.

Moreover, the lemma presented in Appendix I shows that
f (ER) is a monotonic increasing set function, which means
that for any two subsets ER1, ER2 ⊂ E satisfying ER1 ⊂ ER2,
f (ER2) ≥ f (ER1). In addition, the following theorem shows
that f (ER) is a monotone submodular set function [25], which
establishes performance guarantee of greedy edge removal on
reducing the spectral radius of (cid:101)B (ER). Submodularity means
f (ER) has diminishing gain: for any ER1 ⊂ ER2 ⊂ E and e ∈
E \ER2, the discrete derivative ∆f (e|ER) = f (ER∪e)−f (ER)
satisﬁes ∆f (e|ER2) ≤ ∆f (e|ER1).

Theorem 1. f (ER) is a monotone submodular set function.

Proof: The proof can be found in Appendix J.

With the established results, a greedy segmentation algo-
rithm (Algorithm 1) is proposed. Algorithm 1 computes the
edge score function f ((i, j)) = 2uT AT
j for
every edge (i, j) ∈ E and segments q edges of highest scores
to create new user accounts. For efﬁcient computation step 2
of Algorithm 1 can be represented by the matrix form F =
(cid:104)
2AT
(cid:12) AC, where [F]ij = f ((i, j)) if
(i, j) ∈ ER, and [F]ij = 0 otherwise.

CuuT − 1U (u (cid:12) u)T (cid:105)

i [u]j − [u]2

CeU

Using the monotonic submodularity of f (ER) in Theorem
1, the following theorem shows that this greedy algorithm
(Algorithm 1 without score recalculation) has performance
guarantee on spectral radius reduction relative to the optimal

Algorithm 1 Greedy score segmentation algorithm

Input: AC, number of segmented edges q
Output: modiﬁed access adjacency matrix Aq
C
if recalculating score then
Initialization: Aold
for z = 1 to q do

C = AC. Eold ← E. ER ← ∅.

1. Compute the leading eigenvector u of

B = Aold
C

Aold
C

T

2. Compute score f ((i, j)) = 2uT Aold
C
j for all (i, j) ∈ Eold

−[u]2

3. Remove the highest scored edge (i∗, j∗) ∈ Eold

T

eU
i [u]j

4. Aold

from Aold
C
i∗ eN
C = Aold
j∗
ER ← ER ∪ (i∗, j∗).

C − eU

T

. Eold ← Eold \ (i∗, j∗).

else

1. Compute the leading eigenvector u of B = AT
2. Compute score f ((i, j)) = 2uT AT

CAC
i [u]j − [u]2
j

CeU

for all (i, j) ∈ E

3. Remove the q edges of highest scores from AC
4. Store this set of q edges in ER

5. Segment the removed edges in ER to create new users.
A new user u has access to a set of hosts {s : (u, s) ∈ ER}
6. Obtain the modiﬁed access adjacency matrix Aq
C

batch edge removal strategy of combinatorial computation
complexity for selecting the best q edges.

Theorem 2. (Greedy segmentation without score recalcula-
tion) Let E opt
R be the optimal batch edge removal set with
R | = q ≥ 1 that maximizes f (ER) and let E q
|E opt
R with
|E q
R| = q be the greedy edge removal set obtained from
Algorithm 1. If f (E q
R) > 0, then there exists some constant
c(cid:48) > 0 such that

f (E opt

R ) − f (E q

R) ≤

(cid:18)

1 −

1
q

f (E opt

R ) ≥ λmax(B) − λmax

(cid:19)q

f (E opt

R ) ≤
(cid:17)
(cid:16)
(cid:101)B (E q
R)

1
e

f (E opt

R );

≥ c(cid:48)f (E opt

R ).

Proof: The proof can be found in Appendix K.

As a variant of Algorithm 1 without score recalculation, for
better traceability one may desire to successively recalculate
the largest eigenvector u and update the edge score func-
tion f (i, j) after each edge removal. The following corollary
provides a theoretical analysis of the greedy segmentation
algorithm with score recalculation (Algorithm 1 with score
recalculation), which shows that score recalculation can suc-
cessively reduce the spectral radius of B.

Corollary 1.
(Greedy segmentation with score recalcula-
tion) Let (cid:101)A(ER) denote the adjacency matrix of GC \ ER
for some ER ⊂ E, and let uER denote the largest eigen-
vector of (cid:101)B (ER). For any edge removal set ER ⊂ E,
let fER (i, j) = 2uT
j , and let
(i∗, j∗) be a maximizer of fER (i, j). Then λmax
≥
(cid:101)B(ER)
(cid:17)
. Furthermore, if fER (i∗, j∗) > 0,

i [uER ]j − [uER ]2
(cid:16)

(cid:101)B(ER ∪ (i∗, j∗))

ER (cid:101)A(ER)T eU

λmax

(cid:17)

(cid:16)

then λmax

(cid:101)B(ER)

> λmax

(cid:101)B(ER ∪ (i∗, j∗))

(cid:16)

(cid:17)

(cid:16)

(cid:17)

.

Algorithm 2 Greedy user-(host-)ﬁrst segmentation algorithm

Algorithm 3 Greedy edge hardening algorithm

Input: AC, number of segmented edges q
Output: modiﬁed access adjacency matrix Aq
C
C = AC. Eold ← E. ER ← ∅.
Initialization: Aold
for z = 1 to q do

1. Compute user (host) degree vector dU = Aold

C 1N

(dN = Aold
C

T

1U )

2. Obtain i∗ = arg maxi[dU ]i and
C ]i∗ j >0[dN ]h

j∗ = arg maxj:[Aold
(j∗ = arg maxj[dN ]j and
i∗ = arg maxi:[Aold

C ]ij∗ >0[dU ]i)

3. Remove the edge (i∗, j∗) ∈ Eold from Aold
C .
i∗ eN
C = Aold
4. Aold
j∗
ER ← ER ∪ (i∗, j∗)

. Eold ← Eold \ (i∗, j∗).

C − eU

T

5. Segment the removed edges in ER to create new users.
A new user u has access to a set of hosts {s : (u, s) ∈ ER}
6. Obtain the modiﬁed access adjacency matrix Aq
C

Proof: The proof can be found in Appendix L.

In addition to establishing the performance guarantee
of greedy score segmentation (Algorithm 1) for reducing
λmax(B), the following theorem shows that the two intuitive
greedy segmentation algorithms proposed in Algorithm 2, with
an aim of successively segmenting the edge connecting to
the most connected user or host, are also effectively reducing
an upper bound on λmax(B). The terms dU = AC1N
and dN = AT
C1U denote the degree vector of users and
hosts, respectively, and the terms duser
max denote the
maximum degree of users and hosts in GC, respectively.

max and dhost

Theorem 3. (Greedy user-(host-)ﬁrst segmentation) If an edge
(i, j) is removed from GC and (cid:101)B(i, j) is irreducible, then

(cid:16)

λmax

(cid:17)

(cid:101)B(i, j)

≤ duser

max · dhost
max
− max

s∈{1,2,...,N }

(cid:2)(cid:0)[dU ]i − 1(cid:1) eN

j − AT

CeU
i

(cid:3)
s

.

Proof: The proof and the case when (cid:101)B(i, j) is reducible

can be found in Appendix M.

CeU
i

Since the term AT

in Theorem 3 is a vector of access
connections of user i, Theorem 3 suggests a greedy user-ﬁrst
segmentation approach that segments the edge between the
user of maximum degree and the corresponding accessible host
of maximum degree in order to reduce the upper bound on
spectral radius in Theorem 3. Similar analysis apples to the
greedy host-ﬁrst segmentation approach in Algorithm 2.

V. HARDENING ON HOST-APPLICATION GRAPH

In this section we discuss two countermeasures for con-
straining lateral movements on the host-application graph.
Edge hardening refers to securing access from application k
to host j, and in effect reducing the compromise probability
[P]kj. Node hardening refers to securing a particular host and
in effect increasing its hardening level.

Recall from (8) that the reachability of lateral movement
on host-application graph is governed by the matrix J = (P ⊗
1N )T AT . Note that although J is in general not a symmetric

Input: J = (P ⊗ 1N )T AT , number of hardened edges η,
{(cid:15)kj}k∈{1,2,...,K},j∈{1,2,...,N }
Output: modiﬁed compromise probability matrix Pη
if recalculating score then

Initialization: Pη = P. Jold = J.
for z = 1 to η do

1. Compute the leading eigenvector y of Jold
2. Compute score φ ((k, j)) = yT ∆Jold
(k,j)y
3. Obtain (k∗, j∗) = arg maxk,j φ ((k, j))
4. Edge hardening: [Pη]k∗j∗ = (cid:15)k∗j∗
5. Jold = (Pη ⊗ 1N )T AT (see Appendix P)

else

Initialization: Pη = P
1. Compute the leading eigenvector y of J
2. Compute score φ ((k, j)) = yT ∆J(k,j)y
3. Find the η edges of highest scores
4. Store this set of η edges in H
5. Edge hardening: [Pη]kj = (cid:15)kj for all (k, j) ∈ H

matrix, its entries are nonnegative and hence by the Perron-
Frobenious theorem [24] λmax(J) is real and nonnegative, and
the entries of its largest eigenvector are nonnegative.

Hardening a host j for an application k means that after
hardening the compromise probability [P]kj is reduced to
some value (cid:15)kj such that [P]kj > (cid:15)kj ≥ 0. Let H denote the set
of hardened edges and let (cid:101)PH be the compromise probability
matrix after edge hardening. Then we have (cid:101)PH = P −
T
(cid:80)
. Let (cid:101)J(H) = ( (cid:101)PH⊗1N )T AT
and let y be the largest eigenvector of J. We can show that

(k,j)∈H ([P]kj − (cid:15)kj) eK

k eN
j

(cid:16)

λmax

(cid:17)

(cid:101)J(H)



∆JH =





≥ λmax (J) − yT ∆JHy;

(14)

(cid:88)

([P]kj − (cid:15)kj) eK

k eN
j

T

 ⊗ 1N



AT .




T

(k,j)∈H

The proof of (14) can be found in Appendix N.

Let φ(H) = yT ∆JHy be a score function that reﬂects the
effect of the edge hardening set H on spectral radius reduction
of J. The lemma presented in Appendix O shows that φ(H)
is a monotonic increasing set function of H. The following
analysis shows that φ(H) is associated with a pair of upper and
lower bounds on the spectral radius of J after edge hardening.

The edge hardening algorithm proposed in Algorithm 3
is a greedy algorithm that hardens the η edges of highest
scores between applications and hosts, where the per-edge
hardening score is deﬁned as φ ((k, j)) = yT ∆J(k,j)y. Step
5 in Algorithm 3 with score recalculation can be updated
efﬁciently by tracking the changes in the matrix J caused by
Step 4 (see Appendix P). The following theorem shows that
the hardened edge set obtained from Algorithm 3 without score
recalculation is a maximizer of φ(H).

Theorem 4. (Greedy edge hardening without score recalcula-
tion) For any hardening set H with |H| = η ≥ 1, let Hη with
|Hη| = η be the greedy hardening set obtained from Algorithm
3. Then Hη is a maximizer of φ(H).

Algorithm 4 Greedy node hardening algorithm

j=1

Input: edge score φ((k, j)), number of hardened nodes ζ,
{αj}N
Output: modiﬁed node hardening vector ˜a
Initialization: ˜a = a
1. Compute edge hardening score φ ((k, j)) for all

k ∈ {1, 2, . . . , K} and j ∈ {1, 2, . . . , N }
2. Compute node hardening score ρ(j) = (cid:80)K

k=1 φ((k, j))

for all j ∈ {1, 2, . . . , N }

3. Find the ﬁrst ζ nodes of highest scores and store this

set of ζ nodes in Hnode

4. Node hardening: [˜a]j = αj for all j ∈ Hnode

Proof: The proof can be found in Appendix Q.

Furthermore, the following theorem shows that Algorithm
3 without score recalculation has bounded performance guar-
antee on spectral radius reduction of J relative to that of the
optimal batch edge hardening set for which the computation
complexity is combinatorial.

(cid:16)

Theorem 5. (Performance guarantee of greedy edge hardening
without score recalculation) For any hardening set H with
. Furthermore, let
|H| = η ≥ 1, λmax(J) ≥ λmax
Hopt with |Hopt| = η be the optimal hardening set that
and let Hη with |Hη| = η be the
minimizes λmax
hardening set that maximizes φ(H). If λmax(J) > 0 and
φ(Hη) > 0, then there exists some constant c(cid:48)(cid:48) > 0 such
that

(cid:101)J(H)

(cid:101)J(H)

(cid:16)

(cid:17)

(cid:17)

λmax(J) − φ(Hη) ≤ λmax

(cid:16)

(cid:17)
(cid:101)J(Hopt)

≤ λmax(J) − c(cid:48)(cid:48)φ(Hη).

Proof: The proof can be found in Appendix R.

The corollary below shows Algorithm 3 with score recal-

culation can successively reduce the spectral radius of J.

Corollary 2. (Greedy edge hardening with score recalcula-
tion) Let yH denote the largest eigenvector of (cid:101)J(H) and
let φH ((k, j)) = yT
H(cid:101)J (H ∪ (k, j)) yH. For any edge hard-
let (k∗, j∗) be a maximizer of φH ((k, j)).
ening set H,
(cid:17)
(cid:16)
. Further-
Then λmax

(cid:101)J (H ∪ (k∗, j∗))

(cid:17)

(cid:16)

(cid:101)J(H)
(cid:16)

≥ λmax
(cid:17)

more, if λmax
(cid:17)
(cid:16)

λmax

(cid:101)J(H)

(cid:101)J(H)

> λmax

> 0 and φH ((k∗, j∗)) > 0, then
(cid:101)J (H ∪ (k∗, j∗))

(cid:17)

.

(cid:16)

Proof: The proof can be found in Appendix S.

Lastly, for node hardening we use the edge hardening score
φ((k, j)) to deﬁne the node hardening score ρ(j) for host j,
where ρ(j) = (cid:80)K
k=1 φ((k, j)). In effect, node hardening on
host j enhances its hardening level from [a]j to a value αj ∈
[[a]j, 1]. A greedy node hardening algorithm based on the node
hardening score is summarized in Algorithm 4. In Sec. VI
we also investigate the performance of two other node score
functions based on a and J for greedy node hardening, namely
ρa(j) = 1/[a]j and ρJ(j) = (cid:80)N

s=1[J]js.

(a)

(b)

Fig. 3: The effect of segmentation on the user-host access
graph. (a) Reachability with respect to different segmentation
strategies. (b) Fraction of newly created user accounts from
segmentation. Given the same number of segmented edges,
greedy host-ﬁrst segmentation strategy (green curve) is the
most effective approach to constraining reachability (Fig. 3
(a)) at the cost of most additional accounts (Fig. 3 (b)).

VI. EXPERIMENTAL RESULTS

A. Dataset Description and Experiment Setup

To demonstrate the effectiveness of the proposed segmenta-
tion and hardening strategies against lateral movement attacks,
we use the event logs and network ﬂows collected from a large
enterprise to create a tripartite user-host-application graph as in
Fig. 2 (a) for performance analysis. This graph contains 5863
users, 4474 hosts, 3 applications, 8413 user-host access records
and 6230 host-application-host network ﬂows. All experiments
assume that the defender has no knowledge of which nodes are
compromised and the defender only uses the given tripartite
network conﬁguration for segmentation and hardening.

To simulate a lateral movement attack we randomly select
5 hosts (approximates 0.1% of total host number) as the
initially compromised hosts and use the algorithms developed
in Sec. III to evaluate the reachability, which is deﬁned as
the fraction of reachable hosts by propagating on the tripartite
graph from the initially compromised hosts. The initial node
hardening level of each host is independently and uniformly
drawn from the unit interval between 0 and 1. The compromise
probability matrix P is a random matrix where the fraction
of nonzero entries is set to be 10% and each nonzero entry
is independently and uniformly drawn from the unit internal
between 0 and 1. The compromise probability after hardening,
(cid:15)kj, is set to be 10−5 for all k and j. All experimental results
are averaged over 10 trials.

B. Segmentation against Lateral Movement

Fig. 3 shows the effect of different segmentation strategies
proposed in Sec. IV on the user-host graph. In particular, Fig.
3 (a) shows that greedy host-ﬁrst segmentation strategy is
the most effective approach to constraining reachability given
the same number of segmented edges, since accesses to high-
connectivity hosts (i.e., hubs) are segmented. For example, seg-
menting 15% of user-host accesses can reduce the reachability
to nearly one third of its initial value. Greedy segmentation
with score recalculation is shown to be more effective than
that without score recalculation since it is adaptive to user-
host access modiﬁcation during segmentation. Greedy user-
ﬁrst segmentation strategy is not as effective as the other
strategies since segmentation does not enforce any user-host

(a)

(b)

(a)

(b)

Fig. 4: The effect of hardening on host-application graph. (a)
Reachability with respect to different edge hardening strate-
gies. (b) Reachability with respect to different node hardening
strategies. The greedy hardening approaches based on the
proposed hardening matrix J (red and blue curves) outperform
heuristics using the compromise probability matrix P and the
hardening level vector a (green curve).

access reduction and therefore after segmentation a user can
still access the hosts but with different accounts.

Fig. 3 (b) shows the fraction of newly created accounts with
respect to different segmentation strategies. There is clearly
a trade-off between network security and implementation
practicality since Fig. 3 suggests that segmentation strategies
with better reachability reduction capability also lead to more
additional accounts. However, in practice a user might be
reluctant to use many accounts to pursue his/her daily jobs
even though doing so can greatly mitigate the risk from lateral
movement attacks.

C. Hardening against Lateral Movement

Fig. 4 shows the effect of different hardening strategies
proposed in Sec. V on the host-application graph. As shown
in Fig. 4 (a), the proposed greedy edge hardening strategies
with and without score recalculation have similar performance
in reachability reduction, and they outperform the greedy
heuristic strategy that hardens edges of highest compromise
probability. This suggest that the proposed edge hardening
strategies indeed ﬁnds the nontrivial edges affecting lateral
movement. Fig. 4 (b) shows that the node hardening strategies
using the node score function ρ and ρJ lead to similar
performance in reachability reduction, and they outperform
the greedy heuristic strategy that hardens nodes of lowest
hardening level. These results show that the greedy edge and
node hardening approaches based on the proposed hardening
matrix J outperform heuristics using the compromise proba-
bility matrix P and the hardening level vector a, which suggest
that the intuition of hardening the host of lowest security
level might not be the best strategy for constraining lateral
movement, as it does not take into account the connectivity
structure of the host-application graph.

D. Segmentation and Hardening on Tripartite Graph

Lastly, we investigate the joint effect of segmentation and
hardening on constraining lateral movement attacks on the
user-host-application tripartite graph. Fig. 5 shows the lateral
movement reachability under a selected combination of the
proposed segmentation and hardening strategies. Since these
joint segmentation and hardening strategies lead to similar
results in reachability reduction, we display their mean and

Fig. 5: The effect of segmentation and hardening on lateral
movement attack in user-host-application tripartite graph. This
ﬁgure shows the mean and the standard deviation (std) of
reachability of four joint segmentation and hardening strate-
gies. The size and the color of a point in the plot reﬂects the
level of reachability.

standard deviation. In addition, for clarity we only plot rep-
resentative points to demonstrate the effectiveness. It can be
observed that different combinations of the proposed strategies
result in similar tendency in constraining lateral movements.
Originally, more than half of hosts can be compromised if
no preventative actions are taken. Nonetheless, the proposed
segmentation and hardening strategies can greatly reduce the
reachability of lateral movements to secure the network.

VII. BENCHMARK: PERFORMANCE EVALUATION ON
ACTUAL LATERAL MOVEMENT ATTACKS

This section demonstrates the importance of incorporat-
ing the heterogeneity of a cyber system for enhancing the
resilience to lateral movement attacks. Speciﬁcally, real lateral
movement attacks taking place in an enterprise network are
collected as a performance benchmark3. This dataset contains
the communication patterns between 2010 hosts via 2 commu-
nication protocols, and therefore the enterprise network can be
summarized as a bipartite host-application graph. It also con-
tains lateral movements originated from a single compromised
host, and in total includes 2001 propagation paths. The details
of the collected benchmark dataset are given in Appendix T.
The experiment in this section differs from the analysis in
Sec. VI, as this dataset contains actual lateral movement traces
on the host-application graph, whereas in Sec. VI we have a
complete user-host-application tripartite graph of an enterprise,
but without the actual attack traces.

We compare the performance of our proposed edge harden-
ing method (Algorithm 3) to the NetMelt algorithm [3], which
is a well-known edge removal method for containing informa-
tion diffusion on a homogeneous graph. For the proposed edge
hardening method, the edges in the host-application bipartite
graph are hardened sequentially according to the computed
scores, and the initial compromise probability matrix P is
set to be a matrix of ones. For every propagation path, the
lateral movement will be contained if the edge it attempts
to leverage is hardened. Since NetMelt can only deal with
homogeneous graphs (in this case, the host-host graph), its
recommendation on hardening a host pair is equivalent to
hardening K corresponding host-application edges (in this
case, K = 2), whereas our method has better granularity for

3Dataset available at https://sites.google.com/site/pinyuchenpage/datasets

[2] H. Goldman, R. McQuaid, and J. Picciotto, “Cyber resilience for
mission assurance,” in IEEE International Conference on Technologies
for Homeland Security (HST), 2011, pp. 236–241.

[3] H. Tong, B. A. Prakash, T. Eliassi-Rad, M. Faloutsos, and C. Faloutsos,
“Gelling, and melting, large graphs by edge manipulation,” in ACM
CIKM, 2012, pp. 245–254.

[4] N. Provos, M. Friedl, and P. Honeyman, “Preventing privilege escala-

tion,” in USENIX, vol. 3, 2003.

[5] S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, A.-R. Sadeghi, and
B. Shastry, “Towards taming privilege-escalation attacks on android.”
in NDSS, vol. 17, 2012, p. 19.

[6] L. Xing, X. Pan, R. Wang, K. Yuan, and X. Wang, “Upgrading your
android, elevating my malware: Privilege escalation through mobile os
updating,” in IEEE Symp. on Security and Privacy, 2014, pp. 393–408.
[7] P.-Y. Chen, C.-C. Lin, S.-M. Cheng, H.-C. Hsiao, and C.-Y. Huang,
“Decapitation via digital epidemics: a bio-inspired transmissive attack,”
IEEE Commun. Mag., vol. 54, no. 6, pp. 75–81, June 2016.

[8] T. Das, R. Bhagwan, and P. Naldurg, “Baaz: A system for detecting
access control misconﬁgurations,” in USENIX, 2010, pp. 161–176.
[9] Y. Chen, S. Nyemba, and B. Malin, “Detecting anomalous insiders in
collaborative information systems,” IEEE Trans. Depend. Sec. Comput.,
vol. 9, no. 3, pp. 332–344, 2012.

[10] A. Zheng, J. Dunagan, and A. Kapoor, “Active graph reachability re-
duction for network security and software engineering,” IJCAI, vol. 22,
no. 1, p. 1750, 2011.

[11] S.-M. Cheng, W. C. Ao, P.-Y. Chen, and K.-C. Chen, “On modeling
malware propagation in generalized social networks,” IEEE Commun.
Lett., vol. 15, no. 1, pp. 25–27, Jan. 2011.

[12] P.-Y. Chen, S.-M. Cheng, and K.-C. Chen, “Optimal control of epidemic
information dissemination over networks,” IEEE Trans. on Cybern.,
vol. 44, no. 12, pp. 2316–2328, Dec. 2014.
J. Gao, S. V. Buldyrev, S. Havlin, and H. E. Stanley, “Robustness of
a network of networks,” Physical Review Letters, vol. 107, no. 19, p.
195701, 2011.

[13]

[14] A. Chapman, M. Nabi-Abdolyouseﬁ, and M. Mesbahi, “Controllability
and observability of network-of-networks via cartesian products,” IEEE
Trans. Autom. Control, vol. 59, no. 10, pp. 2668–2679, 2014.
J. Ni, H. Tong, W. Fan, and X. Zhang, “Inside the atoms: ranking on a
network of networks,” in ACM KDD, 2014, pp. 1356–1365.

[15]

[16] M. Halappanavar, S. Choudhury, E. Hogan, P. Hui, J. Johnson, I. Ray,
and L. Holder, “Towards a network-of-networks framework for cyber
security,” in IEEE ISI, 2013, pp. 106–108.

[17] P. Demeester, M. Gryseels, A. Autenrieth, C. Brianza, L. Castagna,
G. Signorelli, R. Clemenfe, M. Ravera, A. Jajszczyk, D. Janukowicz,
K. V. Doorselaere, and Y. Harada, “Resilience in multilayer networks,”
IEEE Commun. Mag., vol. 37, no. 8, pp. 70–76, 1999.

[18] S. Choudhury, P.-Y. Chen, L. Rodriguez, D. Curtis, P. Nordquist, I. Ray,
and K. Oler, “Action recommendation for cyber resilience,” in ACM
CCS Workshop, 2015, pp. 3–8.

[19] H. Chan, L. Akoglu, and H. Tong, “Make it or break it: Manipulating
robustness in large networks,” in SIAM Data Mining, 2014, pp. 325–
333.

[20] P.-Y. Chen and A. O. Hero, “Assessing and safeguarding network
resilience to nodal attacks,” IEEE Commun. Mag., vol. 52, no. 11, pp.
138–143, Nov. 2014.

[21] L. A. Adamic, C. Faloutsos, T. J. Iwashyna, B. A. Prakash, and H. Tong,
“Fractional immunization in networks,” in Siam Data Mining, 2013, pp.
659–667.

[22] P. Hu and W. C. Lau, “How to leak a 100-million-node social graph
in just one week?-a reﬂection on oauth and api design in online social
networks,” in Black Hat, 2014.

[23] L. T. Le, T. Eliassi-Rad, and H. Tong, “Met: A fast algorithm for
minimizing propagation in large graphs with small eigen-gaps,” in SIAM
Data Mining, vol. 15, 2015, pp. 694–702.

[24] R. A. Horn and C. R. Johnson, Matrix Analysis. Cambridge University

Press, 1990.

[25] S. Fujishige, Submodular Functions and Optimization.

Annals of

Discrete Math., North Holland, 1990.

Fig. 6: Performance evaluation on the collected benchmark
dataset. The proposed approaches (blue and red curves) can
restrain the reachability to roughly 10% by hardening less than
1.5% of edges, whereas NetMelt (green) requires to harden
more than 5% of edges to achieve comparable reachability.

edge hardening by considering the connectivity structure of the
host-application bipartite graph. The computation complexity
of NetMelt is O(mη + N ) [3], where m is the number of
edges in the host-host graph, η is the number of hardened
edges, and N is the number of hosts. Since the operation of
leading eigenpair computation in Algorithm 3 is similar to
NetMelt, the computation complexity for Algorithm 3 without
score recalculation is O(m(cid:48)η + N ), where m(cid:48) is the number
of nonzero entries in the matrix J. For Algorithm 3 with score
recalculation, the computation complexity is O(m(cid:48)η2 + N η).

Fig. 6 shows the reachability of lateral movements with
respect to the fraction of hardened edges. Initially the reach-
ability is nearly 100%, suggesting that almost every host is
vulnerable to lateral movement attacks without edge hard-
ening. The proposed method (both with or without score
recalculation) can restrain the reachability to roughly 10% by
hardening less than 1.5% of edges, whereas NetMelt requires
to harden more than 5% of edges to achieve comparable
reachability, since it does not exploit the heterogeneity of the
cyber system. Consequently, the results demonstrate the utility
of incorporating heterogeneity for building resilient systems.

VIII. CONCLUSION AND FUTURE WORK

This paper developed a framework for joint modeling of
multiple dimensions of cyber behavior (user access control, ap-
plication trafﬁc) for enhancing cyber enterprise resiliency in an
uniﬁed, tripartite network model. Our experiments performed
on a real dataset demonstrate the value and powerful insights
from this uniﬁed model with respect to analysis performed
on a single dimensional dataset. Through the tripartite graph
model, the dominant factors affecting lateral movement are
identiﬁed and effective algorithms are proposed to constrain
the reachability with theoretical performance guarantees. We
also synthesized a benchmark dataset containing traces of
actual lateral movement attacks. The results showed that our
proposed approach can effectively contain lateral movements
by incorporating the heterogeneity of the cyber system. Our
future work includes generalization to k-partite networks to
model other dimensions of behavior (e.g., authentication mech-
anisms and social proﬁle of users).

REFERENCES

[1] M. A. Sasse, S. Brostoff, and D. Weirich, “Transforming the weakest
linka human/computer interaction approach to usable and effective
security,” BT technology journal, vol. 19, no. 3, pp. 122–131, 2001.

SUPPLEMENTARY FILE
APPENDIX A
KRONECKER PRODUCT

If X1 is an r1 × (cid:96)1 matrix and X2 is an r2 × (cid:96)2 matrix,
then the Kronecker product X1 ⊗ X2 is an r1r2 × (cid:96)1(cid:96)2 matrix
deﬁned as

X1 ⊗ X2 =







[X]11X2
[X]21X2
...
[X]r11X2

[X]12X2
[X]22X2
...
[X]r12X2

. . .
. . .
...
. . .

[X]1(cid:96)1X2
[X]2(cid:96)1X2
...
[X]r1(cid:96)1X2

Some useful properties of Kronecker product are
(X1 ⊗ X2)T = XT

1 ⊗ XT
2 ;

X1 ⊗ (X2 + X3) = X1 ⊗ X2 + X1 ⊗ X3.







.

(15)

(16)
(17)

If X1 is an r1 × (cid:96)1 matrix, X2 is an r2 × (cid:96)2 matrix, X3 is an
(cid:96)1 × (cid:96)3 matrix, and X4 is an (cid:96)2 × (cid:96)4 matrix, then

(X1 ⊗ X2) · (X3 ⊗ X4) = (X1 · X3) ⊗ (X2 · X4).

(18)

APPENDIX B
PROOF OF (3)

Following (2),

rt+1 = T

(cid:32) t+1
(cid:88)

(cid:33)

wh

APPENDIX D
PROOF OF (5)

w1 =

















Using (16) and (18) gives
0T
0T
N . . .
N
...
0T
N
...
0T
N
N eT
0T
N
(cid:1) · (cid:0)PT ⊗ In
N · In

eT
1
N eT
0T
2
...
...
0T
N . . .
= (cid:0)In ⊗ 1T
= (cid:0)In · PT (cid:1) ⊗ (cid:0)1T
= (cid:0)PT ⊗ 1T
(cid:1) AT r0
= (P ⊗ 1N )T AT r0.

N

N








col1(P)T ⊗ In
col2(P)T ⊗ In
...
coln(P)T ⊗ In

·

(cid:1) · AT r0
(cid:1) AT r0








· AT r0

(22)

APPENDIX E
PROOF OF (8)

Following (7),

(cid:32)

rt+1 = Ha

T

(cid:33)(cid:33)

(cid:32) t+1
(cid:88)

wh

h=1

(cid:32) t

(cid:88)

(cid:33)(cid:33)

wh + wt+1

(cid:32)

= Ha

T

(cid:32)

h=1

(cid:32)

(cid:32) t

(cid:88)

(cid:33)

(cid:33)(cid:33)

wh

+ wt+1

≡ Ha

T

T

h=1

(cid:32) t

(cid:88)

= T

(cid:32)

≡ T

T

h=1

(cid:33)

wh + wt+1

(cid:32) t

(cid:88)

(cid:33)

(cid:33)

wh

+ wt+1

h=1

≡ T (rt + Brt) .

APPENDIX C
PROOF OF (4)

Following the deﬁnition of w1, we have
N
(cid:88)

[w1]j =

[r0]i[W]ij

≡ Ha

(cid:16)

(cid:16)

T

h=1

rt + (P ⊗ 1N )T AT rt

(cid:17)(cid:17)

.

(23)

APPENDIX F
PROOF OF (11)

(19)

When a subset of edges ER ⊂ E are removed from GC,

the resulting adjacency matrix of GC \ ER is

(cid:101)AC (ER) = AC −

(cid:88)

i eN
eU
j

T

.

(i,j)∈ER

(24)

Therefore, the corresponding induced adjacency matrix (cid:101)B (ER)
is

i=1
N
(cid:88)

K
(cid:88)

[r0]i

[Ak]ij[P]kj

k=1

N
(cid:88)

[r0]i[Ak]ij[P]kj

i=1

0 AkeN
rT

j [P]kj

i=1
K
(cid:88)

k=1
K
(cid:88)

k=1

=

=

=

= rT
0

K
(cid:88)

k=1

([P]kjAk) eN
j .

(20)

Since (cid:80)K
we have

k=1 PkjAk = A · [colj(P) ⊗ In], applying it to (20)

[w1]j = rT
= eT
j

0 A [colj(P) ⊗ In] ej
(cid:2)colj(P)T ⊗ In

(cid:3) AT r0.

(21)

(cid:101)B (ER) = B −

(cid:88)

T

j eU
eN
i

AC −

(cid:88)

(i,j)∈ER
(cid:88)

(cid:88)

T

j eU
eN
i

(i,j)∈ER
(cid:96) eN
eU
s

T

+

AT

CeU

i eN
j

(i,j)∈ER
(cid:88)

((cid:96),s)∈ER
j eU
eN
i

= B −

T

AC −

(cid:88)

AT

CeU

i eN
j

T

T

(i,j)∈ER
(cid:88)

(cid:88)

(i,j)∈ER
(cid:88)

+

i∈Vuser

j∈Vhost,(i,j)∈ER

s∈Vhost,(i,s)∈ER

j eN
eN
s

T

.

(25)

Recall that u is the largest eigenvector of B. Left and right
multiplying (25) by uT and u and using the Courant-Fischer
theorem [24], we have

(cid:16)

λmax

(cid:17)

(cid:101)B (ER)

≥ λmax(B) − f (ER),

(26)

where f (ER) is deﬁned in (12).

APPENDIX G
AN EQUIVALENT EXPRESSION OF f (ER)

The following lemma provides an equivalent representation
of the function f (ER) in (11), which also implies that f (ER) is
nonnegative as it can be represented by a sum of nonnegative
terms.
Lemma 2. Let ∅ denote the empty set. Then f (∅) = 0 and

f (ER) =

(cid:88)

(cid:88)

(cid:88)

[u]j[u]s

i∈Vuser

j∈Vhost,(i,j)∈ER

(cid:88)

+ 2

(cid:88)

s∈Vhost,(i,s)∈ER
(cid:88)

[u]j[u]s.

i∈Vuser

j∈Vhost,(i,j)∈ER

s∈Vhost,(i,s)∈E/ER

Proof: f (∅) = 0 is a direct result from the deﬁnition of

f (ER). Moreover, f (ER) has an equivalent expression that

f (ER) = 2

(cid:88)

uT AT

CeU

i [u]j

(i,j)∈ER
(cid:88)

−

i∈Vuser
(cid:88)

= 2

(i,j)∈ER
(cid:88)

−

i∈Vuser

(cid:88)

(cid:88)

[u]j[u]s

∈Vhost,(i,j)∈ER

s∈Vhost,(i,s)∈ER

(cid:88)

[AC]is[u]s[u]j

s∈Vhost

(cid:88)

(cid:88)

[u]j[u]s

j∈Vhost,(i,j)∈ER

s∈Vhost,(i,s)∈ER


(cid:88)

= 2

(cid:88)

(cid:88)



i∈Vuser

j∈Vhost,(i,j)∈ER

s∈Vhost,(i,s)∈ER

(cid:88)



 [u]j[u]s

s∈Vhost,(i,s)∈E/ER
(cid:88)
(cid:88)

(cid:88)

i∈V

∈V,(i,j)∈ER

s∈V,(i,s)∈ER

[u]j[u]s

+

−

=

(cid:88)

i∈V

+ 2

(cid:88)

(cid:88)

[u]j[u]s

j∈V,(i,j)∈ER
(cid:88)
(cid:88)

s∈V,(i,s)∈ER
(cid:88)

i∈V

j∈V,(i,j)∈ER

s∈V,(i,s)∈E/ER

[u]j[u]s.

(27)

The nonnegativity of u suggests that f (ER) ≥ 0.

APPENDIX H
PROOF OF LEMMA 1

Therefore, there must exist one edge removal set ER with
|ER| = q such that g(ER) > 0. Otherwise g(ER) = 0 for
every edge removal set with cardinality |ER| = q ≥ 1 implies
that v is a zero vector, which contradicts the fact that v is an
eigenvector. Finally, since f (ER) > 0, there exists a constant
c > 0 such that g(ER) ≥ c · f (ER). Applying this inequality
to (28) gives λmax

≤ λmax(B) − c · f (ER).

(cid:101)B (ER)

(cid:16)

(cid:17)

APPENDIX I
MONOTONICITY OF f (ER)

Lemma 3. f (ER) is a monotonic increasing set function.

Proof: For any two subsets ER1, ER2 ⊂ E satisfying
ER1 ⊂ ER2,
let ∆ER = ER2/ER1. Using the relation
ER2 = ER1 ∪ ∆ER and ER1 ∩ ∆ER = ∅, from Lemma 2
f (ER2) can be represented as

f (ER2) =





(cid:88)

+

(cid:88)





j∈Vhost,(i,j)∈ER1

j∈Vhost,(i,j)∈∆ER

(cid:88)

+

(cid:88)



 [u]j[u]s

(cid:88)

i∈Vuser


·



s∈Vhost,(i,s)∈ER1


s∈Vhost,(i,s)∈∆ER

(cid:88)

+ 2



(cid:88)

+

(cid:88)





i∈Vuser

j∈Vhost,(i,j)∈ER1

j∈Vhost,(i,j)∈∆ER

·

(cid:88)

[u]j[u]s.

s∈Vhost,(i,s)∈E\ER

(29)

For any edge removal set ER ⊂ E with |ER| = q, let v be
the largest eigenvector of (cid:101)B (ER). Left and right multiplying
(25) by vT and v gives

Similarly, using the relation ∆ER = (E \ ER1) \ (E \ ER2),
from Lemma 2 we have

(cid:16)

λmax

(cid:17)

(cid:101)B (ER)

= vT Bv − g(ER)
≤ λmax(B) − g(ER)

(28)

f (ER1) =

(cid:88)

(cid:88)

(cid:88)

[u]j[u]s

i∈Vuser

theorem [24], where g(ER) =

by the Courant-Fischer
(cid:80)
(cid:80)
+2 (cid:80)
is obtained by following the same derivation procedure as in
Lemma 2.

s∈Vhost,(i,s)∈ER
(cid:80)

j∈Vhost,(i,j)∈ER
(cid:80)

s∈Vhost,(i,s)∈E/ER

j∈Vhost,(i,j)∈ER

[v]j[v]s

[v]j[v]s

i∈Vuser

(cid:80)

j∈Vhost,(i,j)∈ER1

s∈Vhost,(i,s)∈ER1

i∈Vuser
(cid:88)

+ 2

i∈Vuser


·



(cid:88)

j∈Vhost,(i,j)∈ER1

(cid:88)

+

(cid:88)

Next, recall from the Perron-Frobenius theorem [24] that
the entries of u and v are all nonnegative and bounded.

s∈Vhost,(i,s)∈E\ER2

s∈Vhost,(i,s)∈E\∆ER



 [u]j[u]s.

(30)

Therefore,

f (ER2) − f (ER1)

(cid:88)

=

(cid:88)

(cid:88)

[u]j[u]s

i∈Vuser
(cid:88)

+ 2

j∈Vhost,(i,j)∈∆ER

(cid:88)

s∈Vhost,(i,s)∈ER2

(cid:88)

[u]j[u]s

iuser∈V
(cid:88)

j∈Vhost,(i,j)∈∆ER

s∈Vhost,(i,s)∈E\ER2

(cid:88)

(cid:88)

[u]j[u]s

i∈Vuser
(cid:88)

j∈Vhost,(i,j)∈ER1
(cid:88)

s∈Vhost,(i,s)∈∆ER
(cid:88)

[u]j[u]s

(31)

−

≥

i∈Vuser
(cid:88)

+ 2

j∈Vhost,(i,j)∈∆ER

(cid:88)

s∈Vhost,(i,s)∈ER1

(cid:88)

APPENDIX K
PROOF OF THEOREM 2

Let E s

R with |E s

R| = s be the greedy edge removal set
obtained from Algorithm 1. By submodularity of f (ER) from
Theorem 1, for every s < q there exists an edge e ∈ E opt
R /E s
R
such that

f (E s

R ∪ e) − f (E s

R) ≥

1
q

(cid:0)f (E opt

R ) − f (E s

R)(cid:1) .

After algebraic manipulation, we have

f (E opt

R ) − f (E s+1

R ) ≤

(cid:18)

1 −

(cid:19)

1
q

(cid:0)f (E opt

R ) − f (E s

R)(cid:1)

(36)

(37)

[u]j[u]s

and therefore by telescoping (37) we have

i∈Vuser
(cid:88)

−

j∈Vhost,(i,j)∈∆ER

s∈Vhost,(i,s)∈E\ER2

(cid:88)

(cid:88)

[u]j[u]s

i∈Vuser
(cid:88)

= 2

j∈Vhost,(i,j)∈ER1

s∈Vhost,(i,s)∈∆ER

(cid:88)

(cid:88)

[u]j[u]s

i∈Vuser

j∈Vhost,(i,j)∈∆ER

s∈Vhost,(i,s)∈E\ER2

≥ 0,

(32)
(33)

where the inequality in (31) uses the Perron-Frobenious the-
orem [24] that [u]s ≥ 0 and the fact that ER1 ⊂ ER2. The
inequality in (33) is due to the nonnegativity of the largest
eigenvector u.

f (E opt

R ) − f (E q

R) ≤

(cid:18)

1 −

(cid:19)q

1
q

f (E opt

R ) ≤

1
e

f (E opt

R ).

(38)

Applying (38) and the fact that 0 < f (E q
there exists some constant c > 0 such that

R) ≤ f (E opt

R ) to (11),

λmax(B) − c (cid:0)1 − e−1(cid:1) · f (E opt
(cid:17)
(cid:101)B (E q
R)

≥ λmax(B) − f (E opt

λmax

(cid:16)

R ) ≥ λmax

R ).

(cid:16)

(cid:17)
(cid:101)B (E q
R)

;

(39)

(40)

The proof is complete by setting c(cid:48) = c (cid:0)1 − e−1(cid:1).

APPENDIX L
PROOF OF COROLLARY 1

APPENDIX J
PROOF OF THEOREM 1

This corollary is a direct result of Lemma 1 and Theorem

2 by replacing B with (cid:101)B (ER) and setting q = 1.

It has been proved in Lemma 3 that f (ER) is a mono-
tone increasing set function. Here we prove that f (ER) is
submodular. For any ER1 ⊂ ER2 ⊂ E and e ∈ E \ ER2, let
e = (u, v) ∈ E, from (31) we have

∆f (e|ER2) = f (ER2 ∪ e) − f (ER2)



(cid:88)

=

(cid:88)



(cid:88)

(cid:88)

+





j∈Vuser,(i,j)=e

s∈Vhost,(i,s)∈ER2

s∈Vhost,(i,s)=e

i∈Vuser
· [u]j[u]s
(cid:88)

+ 2

i∈Vuser
(cid:88)

j∈Vhost,(i,j)=e
(cid:88)

s∈Vhost,(i,s)∈E\(ER2∪e)

(cid:88)

[u]j[u]s

−

i∈Vuser

j∈Vhost,(i,j)∈ER2

s∈Vhost,(i,s)=e

= [u]u[u]v + 2

(cid:88)

[u]u[u]s

s∈Vhost,(u,s)∈E\(ER2∪e)
(cid:88)

[u]u[u]s

s∈Vhost,(u,s)∈E\(ER1∪e)

≤ [u]u[u]v + 2

= ∆f (e|ER1),

(34)

(35)

APPENDIX M
PROOF OF THEOREM 3

(cid:80)

We use the fact from the Perron-Frobenius theorem that
if a square matrix X is irreducible and nonnegative, then
λmax(X) ≤ maxs
t[X]st. A square nonnegative matrix X is
irreducible means that for every pair of indices s and t, there
exists a natural number z such that [Xz]st > 0. Since (cid:101)B(i, j) is
a matrix of nonnegative entries, if (cid:101)B(i, j) is irreducible, from
(9) we have
(cid:16)

(cid:17)

(cid:104)

(cid:105)

≤

=

max
s∈{1,2,...,N }
max
s∈{1,2,...,N }
max · dhost
max
− max

≤ duser

s∈{1,2,...,N }

(cid:101)B(i, j)1N
(cid:2)B1N − AT

s
CeU

i − [dU ]ieN

j + eN
j

(cid:3)
s

(cid:2)(cid:0)[dU ]i − 1(cid:1) eN

j − AT

CeU
i

,

(cid:3)
s
(41)

where (41) uses the fact that for all t ∈ {1, 2, . . . , N },

[B1N ]t = [AT

CAC1N ]t = [AT

CdU ]t ≤ duser

max · dhost
max .

(42)

(cid:88)

(cid:88)

[u]j[u]s

λmax

(cid:101)B(i, j)

where the inequality in (35) holds due to the fact that E \
(ER2 ∪ e) ⊂ E \ (ER1 ∪ e) and the entries of u are nonnegative
from the Perron-Frobenious theorem [24]. Therefore, f (ER)
is a monotone submodular set function.

Remark 1. If (cid:101)B(i, j) is reducible, one can obtain a similar
upper bound as in Theorem 3 since the largest eigenvalue
of (cid:101)B(i, j) is the maximum value of the largest eigenvalue of
block-wise irreducible nonnegative submatrices of (cid:101)B(i, j).

APPENDIX N
PROOF OF (14)

By the Courant-Fischer theorem [24], (16) and (17) we

have

λmax

(cid:16)

(cid:17)

(cid:101)J(H)

≥ yT (cid:101)J(H)y
= yT ( (cid:101)PH ⊗ 1N )T AT y
= λmax (J) − yT ∆JHy,

(43)

Hη = {H η

s }η

s=1. Then with (47) we have

φ(H) =

≤

η
(cid:88)

s=1
η
(cid:88)

φ(Hs)

φ(H η
s )

s=1
= φ(Hη),

(48)

where








T

where the maximum of φ(H) is attained when H contains
η edges of highest hardening scores. Therefore, Hη is a
maximizer of φ(H).

∆JH =





(cid:88)

([P]kj − (cid:15)kj) eK

k eN
j

T

 ⊗ 1N



AT .

(k,j)∈H

(44)

APPENDIX O
MONOTONICITY OF φ(H)

Lemma 4. φ(∅) = 0 and φ(H) is a monotonic increasing set
function.

Proof: By deﬁnition φ(∅) = 0 since ∆J∅ is a zero

matrix. For any two sets H1 ⊂ H2 ⊂ Vapp × Vmac,

φ(H2) − φ(H1) = yT (∆JH2 − ∆JH1) y

= yT (cid:0)∆JH2\H1
≥ 0

(cid:1) y

(45)

since ∆JH2\H1 is a nonnegative matrix and y is a nonnegative
vector by the Perron-Frobenious theorem [24]. Therefore,
φ(H) is a monotonic increasing set function.

APPENDIX P
EFFICIENT UPDATE OF STEP 5 IN ALGORITHM 3 WITH
SCORE RECALCULATION

Using the notations in Algorithm 3, when hardening the
edge (k∗, j∗) the entry [Pη]k∗j∗ changes to (cid:15)k∗j∗ . Let the
original value of [Pη]k∗j∗ before hardening be ψ. Then the
update in step 5 is equivalent to

Jold = Jold − HT AT ,

(46)

where H = [0, . . . , h, . . . , 0] is a matrix of zeros except that
the [(k∗ − 1) · N + 1]-th to (k∗ · N )-th entry of H’s j∗-th
column h is ψ − (cid:15)k∗j∗ .

APPENDIX Q
PROOF OF THEOREM 4

For any two hardening sets H1 and H2 satisfying H1 ⊂
H2 ⊂ Vapp × Vhost, using (44) and (45) we have the additivity
for the score function φ(H) as

φ(H2) = φ(H1) + φ(H2 \ H1).

(47)

APPENDIX R
PROOF OF THEOREM 5

We ﬁrst show the relation that λmax(J) ≥ λmax

.
For any hardening set H, let (cid:101)y be the largest eigenvector of
(cid:101)J(H). With (44) we have

(cid:101)J(H)

(cid:16)

(cid:17)

λmax

(cid:16)

(cid:17)

(cid:101)J(H)

= (cid:101)yT (cid:101)J (H) (cid:101)y
= (cid:101)yT J(cid:101)y − (cid:101)yT ∆JH(cid:101)y
≤ λmax (J) − (cid:101)yT ∆JH(cid:101)y
≤ λmax (J) .

(49)

that (cid:101)yT J(cid:101)y ≤ λmax (J) is from the Courant-
The fact
Fischer theorem [24], and the last inequality uses the fact that
(cid:101)yT ∆JH(cid:101)y ≥ 0 from the Perron-Frobenious theorem [24] due
to the fact that all entries in ∆JH and (cid:101)y are nonnegative.

If λmax(J) > 0, then by (43) and (49) we have φ(Hopt) >
0. Otherwise φ(Hopt) = 0 implies that y is a zero vector,
which contradicts the fact that y is the largest eigenvector
if λmax(J) > 0 we have λmax(J) >
of J. Therefore,
(cid:17)
. When |H| = η, since Hopt is the minimizer
λmax

(cid:16)

and Hη is the maximizer of φ(H), we have

(cid:101)J(Hopt)
(cid:16)

(cid:101)J(H)

(cid:17)

of λmax

λmax

(cid:16)

(cid:17)
(cid:101)J(Hη)

(cid:16)

(cid:17)
(cid:101)J(Hopt)

≥ λmax
≥ λmax(J) − φ(Hopt)
≥ λmax(J) − φ(Hη).

(50)

(cid:16)

(cid:17)
(cid:101)J(Hopt)

and λmax(J) ≥

, if φ(Hη) > 0, with (50) there exists some

By the facts that λmax(J) > λmax

(cid:16)

(cid:17)

(cid:101)J(Hη)

λmax
constant c(cid:48)(cid:48) > 0 such that

λmax(J) − c(cid:48)(cid:48) · φ(Hη) ≥ λmax
(cid:17)
(cid:101)J(Hopt)

λmax

(cid:16)

≥ λmax(J) − φ(Hη).

(cid:16)

(cid:101)J(Hopt)

(cid:17)

;

(51)

APPENDIX S
PROOF OF COROLLARY 2

For any hardening set H of cardinality |H| = η ≥ 1, let
H = {Hs}η
s=1, where Hs is the s-th element in H, and let

This corollary is a direct result of Theorem 5 by replacing

J with (cid:101)J(H) and setting η = 1.

APPENDIX T
DESCRIPTIONS ON THE BENCHMARK DATASET

This benchmark dataset was collected from the network
trafﬁc of a cyber testbed running inside a OpenStack-based
cloud with nearly 2000 virtual machine instances. Starting
from a known machine (host), the attack involved logging
from one machine to another using SSH. Implemented by
automated scripts, on each machine the attack replicated to
four other machines at
the beginning of every hour. This
process continued for 8 hours. We collected network trafﬁc
ﬂows from each virtual machine and combined to produce a
16 GB packet capture dataset. Each packet information was
further aggregated to produce “ﬂow” level information, which
can be interpreted as a “communication session” between two
machines. As an example, when a client connects to the server,
the client may send 5 packets and receive 10 packets of data
from the server. The “ﬂow” level data will combine these 15
data packets into a single “ﬂow” to represent one interaction
between the machines. Each ﬂow record has the following
elements: IP address and port information for both source
and destination devices, protocol, ﬂow start time, duration
and message size. We infer the application by considering
the protocol and destination address pair. As an example, a
ﬂow to destination port 22 over TCP protocol implies an SSH
connection. To apply our proposed method to the cyber system
against lateral movement attacks, we select the source and
destination IP address, and the applications to build the host-
application graph.

