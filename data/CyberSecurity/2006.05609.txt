LEARNING WITH DIFFERENTIAL PRIVACY 

Poushali Sengupta[1], Sudipta Paul[2,3], Subhankar Mishra[2,3] 

[1] University of Kalyani, Kalyani, Nadia, West Bengal â€“ 741235 

[2] National Institute of Science, Education and Research Bhubaneswar 

Odisha, India â€“ 752050 

[3] Homi Bhaba National Institute, Anushaktinagar, Mumbai â€“ 400094, India 

[1] tua.poushalisengupta@gmail.com , [2] sudiptapaulvixx@niser.ac.in , [3] smishra@niser.ac.in 

INTRODUCTION 

Humans gain â€œknowledgeâ€ by inference from raw events, incidents or structured phenomenon. That implies, 
as  long  as  it  is  not  meaningful  or  inferred  properly,  this  â€œraw  dataâ€  doesnâ€™t  become  â€œinformationâ€  to  be 
inferred that help humans to grab â€œknowledgeâ€ from. Our chapter refers to the definition of knowledge given 
by  (Davenport  et  al.,  1998).  It  states  that  from  the  perspective  of  an  expert  with  respect  to  the  particular 
experiences and principles in the right context give a proper structure to asses and integrate new raw data and 
information. This structure helps to make the transition of the data to â€œknowledgeâ€ - inside a proper intelligent 
mind. This phenomenon is equally applicable in the daily routine of any organization, processes, norms and 
practices. 
Raw data goes through processes to add contextual meaning in background to become  â€œinformationâ€. These 
processes are heavily prone to defect and danger depending on the nature of the data, its sensitivity and its 
usefulness towards the organizations. One of the biggest dangers that these â€œinformationâ€ and â€œraw dataâ€ can 
face  is  â€œleakageâ€.  Leakage  defined  as  -  when  an  adversary  knowingly  disclose  sensitive  information  for 
business  purpose  to  harm  an  individual,  a  community  or  a  particular  target  for  his/her  own  personal 
satisfaction.  The  â€œleakageâ€  can  happen  in  the  pre-processing  as  well  as  in  the  post-  processing  of 
â€œinformationâ€.  

These situations are not desired by any means. Some of the probable solutions are - 

â€¢  Make sure all endpoints have basic Cyber security systems. 
â€¢  Use a data backup and recovery solution using encryption-decryption system. 
â€¢  Clean up the data Storage on the IT Assets after a certain time - window  
â€¢  Limit user access privileges to only what is absolutely necessary 
â€¢  Provide Cyber security awareness training to the employees 
â€¢  Build security system inherited from the data itself that doesnâ€™t need any kind of third-party affiliation, but 

robust and fast enough to provide enough privacy and security promise simultaneously. 

All of the promises except the last one needs some audit from a 3rd party who or which can be a potential attacker. 
Also,  these  promises  need  extensive  monitoring  from  a  human  perspective  all  the  time  which  is  a  tough  and 
cumbersome  work.  The  last  point  in  the  above  solutions  is  formally  known  as  â€œdifferential  privacyâ€  that  is 
currently the default trend of privacy solution. 
The definition of â€œdifferential privacyâ€ (DP) will be discussed in section 4 thoroughly. But as a promise, DP might 
be  thought  of  as  a  restriction  which  filters  the  leakage  of  sensitive  statistics  at  the  time  of  the  publication  of 
aggregated information, with respect to a database, in the algorithmic level. To elaborate the above promise some 
examples are discussed below (Wikipedia â€“ Differential Privacy), 
Government departments and agencies use DP algorithms at the time of publishing demographic and other types of 
statistical aggregated analysis report with the assurance of  the confidentiality of the survey takers and responses, 

 
 
 
 
 
 
 
Companies use DP algorithms at the time of collecting user behavior, in every step to stop leakage. This measure is 
also applicable to the internal analysts. 
In whatever way the sales numbers of a business are covered in the process of hiding, those numbers might appear 
when  the  same  process  will  be done in the  total  calculation  of a  vast  region  that the  business  belongs  to with a 
combinations of addition and subtraction. DP algorithms diminish those possibilities from the root itself even if the 
attackers use robust, interactive query system. 
The research and finding timeline that results in differential privacy is following - 
1950s  -1960s:  Statistical  agencies  started  using  electronic  information  processing  system  that  resulted  in  the 
increase of number of data tables as well as potential attack. 

â€¢  1977: Statistician Tore Dalenius proposedcell suppression mathematics for statistical disclosure control. 
â€¢  2003:Computer  scientists  Kobbi  Nissim  and  Irit  Dinur  presented  the  Fundamental  Law  of  Information 

Recovery, and its key characteristics. 

â€¢  2006: Theoretical computer scientists Cynthia Dwork, McSherry, Kobi Nissim and Smith introduced the 
concept of DP, with a mathematical definition for the privacy loss and utility associated with any result 
related to a statistical database (Dwork, 2006; Dwork & Roth, 2014). They proposed (Ã, d) DP where the 
whole  processes  of  statistical  functions  running  on  the  database  are  not  overly  dependent  on  an 
individualâ€™s data.  

The  different  attack  models,  reasons  to  justify  them,  probable  solutions  in  academia  and  industry  are  the  main 
agenda of this chapter which are discussed thoroughly in the following sections. 

DIFFERENTIAL PRIVACY 

From the above discussion in the Introduction section it is evident that differential privacy comes with respect 
to  the  continuous  development  in  the  hope  of  reduction  of  information  leakage.  In  the  following  three 
subsections,  we  will  discuss  about  what  differential  privacy  does  not  promise,  different  promises  of 
differential privacy, and some useful definitions. 

Problems Regarding Privacy - Preserving Data Analysis 
There are some important problems for privacy-preserving data analysis which will be discussed here: 

â€¢  Anonymization 

Only anonymization of datasets cannot create the strong privacy. In an anonymized rich database, data 
enables  â€œnamingâ€  an  individual  by  the  combination  of  the  birth  date,  zip  code,  age  etc.  to  create  the 
uniqueness  of  the  individuals.  This  â€œnamingâ€  can  be  used  for  linkage  attack  to  match  an  anonymized 
dataset  to  a  non-anonymized  data  set.  In  the  year  1997,  a  linkage  attack  on  Massachusetts  hospital 
discharge  dataset  with  public  voter  dataset  was  done  by  Prof.  Latanya  Sweeney  and  name,  address, 
phone number of each persons were leaked. 

â€¢  Re-identification 

Re-identification is undesirable and risky because it reveals not only the membership of the database but 
also the compromising data records of the individuals of the dataset. 

â€¢  Large Query 

It cannot be predictable how large query would be. A set of queries or a large query can leak the personal 
information of individual of a particular database. For example, let M and N are two events and the a set 
of queries is â€œHow many people are involved with M?â€; â€œHow many people are involved with both M 
and  N?â€;  â€œHow  many  people  are  involved  with  M  for  last  2  weeks?â€  and    â€œHow  many  People  are 
involved  with  both M  and  N  for  last 3  weeks?â€.  By asking  these  questions,  one  can  get the  particular 
answer that he/she wants to know. This situation can compromise the privacy of the individuals. 

â€¢  Query Auditing 

In some cases, one can send two or more than two such queries whereby the difference of the answers of 
these queries, he/she can get the actual answer that he/she wants to know. Privacy can be compromises in 
this way. 
â€¢  Just a few 

In some cases, the data holds privacy in such a way that it does not compromises the private data of all 
individuals except â€œjust a fewâ€ information of individuals. Here, the data base is not fully protected. 

 
 
 
 
 
 
 
â€¢  Ordinary fact 

Revealing  ordinary  fact  like  number  of  times  a  person  goes  to  the  supermarket  in  a  week,  can 
compromises sensitive information if it is followed over time. 

In order to give a plausible solution to the above issues with the existing privacy-preserving data analysis, DP 
as  a  concept  was  plotted  by  Cynthia  Dwork  et  al.  in  their  2006  work  (Dwork,  2006).  â€œDifferential 
privacyâ€(Dwork  &  Roth,  2014)  is  a  methodology  by  which  public  sharing  of  information  regarding  any 
dataset  is  restricted  to  describe  the  groups  in  the  dataset  but  not  any  information  about  the  individuals.  DP 
addresses  a  paradox  of  learning  where  one  can  know  about  the  useful  information  of  the  given  database 
without  accessing  the  particular  sensitive  information  of  individuals.  More  fundamentally,  this  provides  a 
facility of learning overall forest data without knowing the individual trees containing the private information.  

The Promise of Differential Privacy 
The Fundamental Law of Information Recovery from introduction gives a start point to understand DP where 
they posed a restriction on the amount of query that might be asked by the analyst to not to reveal any private 
information by giving an overly accurate answer. DP possess an assurance inherently by the data curator that 
an individual is not prone to attack, adversely or otherwise, by providing their data for the purpose of use in 
any kind of research or survey, irrespective of connection to any other databases or data sources available at 
any corner of the world. 

If  a  medical  database  is  considered  for  analysis,  an  insurance  companyâ€™s  view  of  an  alcoholicâ€™s  long-term 
medical  costs  can  be  improved  as  they  can  know  from  the  database  without  accessing  individualsâ€™  data 
records  that  drinking  too  much  alcohol  causes  various  liver  disease,  most  importantly  cancer.  As  a  result, 
oneâ€™s  insurance  premium  may  rise,  if  the  insurer  knows  that  the  particular  person  drinks  alcohol.  Here  the 
medical  database  is deferentially  private as the information  of individuals  are not  â€œleakedâ€  to the insurance 
company and it makes an impact on the participants in the survey for giving answer independently whether 
he/she drinks alcohol or not. 

DP  is  not  an  algorithm,  it  is  a  theory  that  ensures,  a  stream  of  outputs  in  arbitrary  sequences  of  choice 
(responses to queries) is â€œessentiallyâ€ equally likely to occur where this term â€œessentiallyâ€ is maintained by a 
privacy parameter. The smaller the value of this parameter the better privacy occurs. This parameter is denoted 
byğœ– . 

Different Types of Differential Privacy 
There are two types of DP. They are discussed below : 

â€¢  Local Differential Privacy (LDP): 

A technique introduced in 1965 (Warner, 1965) named as - â€œRandomized Responseâ€ is the basis of this kind 
of DP. The users answer the queries using only coin toss probability set. The main plus point of this simple 
model  is  that  the  distribution  of  the  data  is  always  stable enough even  when  a user  suddenly  changes  the 
response  out  of  the  blue.  There  is  no  need  to  have  the  affiliation  of  a  third  party  authorization  too.  As  it 
always gives the answer for a forest of data instead of a single tree maintaining the above assumption, it is 
highly adopted to the industry as well as in the academia research.     

â€¢  Central Differential Privacy (CDP):  

This whole technique is depended on the trust and proficiency of the data curator (DC). The DC add random 
noise to the aggregated answer in the central part after collecting all the data from the local servers. In the 
local servers the answer to the queries are independent of each other and do not know other serversâ€™ identity. 
Therefore all the answers are individually part of the centralized dataset. As the answers are independent and 
the DC is adding external random noise, the whole phenomenon leads to CDP.  

 
 
 
Therefore, an easy comparison can be inferred from the above discussion which is given in the Table 2. 

Table 2. Comparative discussion on LDP and CDP 

LDP 

CDP 

No place for a trusted curator, or any data storage. 

Assurance of report production entirely depended on 
the trusted individual clients. They give their 
responses using the randomized response technique 
on the coin toss set.   

The data is collected from servers which are 
independent to each other and stored in a trusted 
centralized database. 
The curator releases the final report applying the 
Laplace noise randomly drawn from Laplace 
distribution for hiding the presence or absence of an 
individual. 

Example: RAPPOR in google chromium project for 
google chrome search engine. 

PROCHLO implementation of ESA, ESA revisited, 
Amplification by shuffling etc. techniques. 

A short timeline regarding the most important inventions and discoveries in DP is given in the following figure 1. 

Figure 1. Short timeline of DP 

STATE OF THE ART DP TECHNIQUES ACCORDING TO TIMELINE 

Differential privacy is a concept which possesses a huge promise towards security. Here we will discuss about 
some related works in the industry as well as in the academia using differential privacy such as â€œwhat can we 
learn privatelyâ€, RAPPOR, PROCHLO, OUTIS, ESA, ARA etc. and compare them with each other. 

 
 
 
 
 
 
 
 
 
 
 
 
 
Learning with limit 
Learning  problems  form  an  important  section  of  various  computational  tasks  that  are  applied  by  a  large 
number of computational researchers in real life. To recover these types of problems and to find the answer of 
â€œwhat can we learn privatelyâ€(Kasiviswanathan et. al, 2011), in this work they explored different approaches 
of learning concept classes as background theory, that eventually let them  propose an algorithm in terms of 
samples, computations, time and interaction that holds the following promises of improvement. 

â€¢  Occamâ€™s razorâ€™s private version. 
â€¢  Learning privately with an efficient learner. 
â€¢  Local (randomised response) and SQ learning are equivalent. 
â€¢  Local learning in two different forms i.e. interactive and non-interactive. 

In the following subsection we will go through the preliminary background theories and theoretical result they 
derived in the process. 

Preliminary Background Theories 
The  preliminary  background  theories  of  this  work  have  explored  differential  privacy,  agnostic  learning, 
Probabilistically  Approximately  Correct  (PAC)  learning,  SQ  learning  and  their  efficiency  measure.  The 
background of differential privacy will be discussed in the section 4. PAC model is the learning model that has 
the capability to access a polynomial number of labeled answers. SQ model do not access the answers directly 
whereas the learner can specify some properties on the example for which an estimate is given up to additive 
small  error,  of  the  probability  that  a  randomly  chosen  example  which  follow  the  distribution  D,  satisfy  the 
property.  The  PAC  learning  is  stringently  stronger  than  SQ  learning.  A  brief  discussion  of  PAC,  SQ  and 
Agnostic learning is given in the Table 3 below. 

Table 3: Description and mathematical formulation of different learning models. 

Learning Theories 

Description 

PAC (Probabilistically 
Approximately Correct)  

A concept class depending on 
some definite distribution will be 
PAC learnable using a 
hypothesis class if there exists 
such algorithm maintaining a 
polynomial time, whose output 
will produce a definite 
hypothesis from the aforesaid 
hypothesis class maintaining the 
bounds for probability of failure. 

Agnostic Learning 

It is identical to PAC theory with 
two more addition regarding 
distribution and bounds for 
probability of failure. 

Formulas and mathematical 
expressions 

âˆ€ğ‘‘ğœ–â„•, âˆ€ğ‘ğœ–ğ¶ğ‘‘ , âˆ€ğ’³ğœ–ğ‘‹ğ‘‘, an algorithm 
ğ’œ maintaining polynomial in 
ğ‘‘, 1 ğ›¼â„ , logâ¡(1 ğ›½â„ ), will give an output 
from the hypothesis class â„ğœ–â¡â„‹ , 
satisfying  

Pr[ğ‘’ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(â„) â‰¤ â¡ğ›¼] â¡ â‰¥ 1 âˆ’ â¡ğ›½ 

over the drawn examples ğ‘§ğ‘– =
(ğ‘¥ğ‘–, ğ‘(ğ‘¥ğ‘–)) 

âˆ€ğ‘‘ğœ–â„•, âˆ€ğ‘ğœ–ğ¶ğ‘‘ , âˆ€ğ’³ğœ–ğ‘‹ğ‘‘ Ã— {0,1}, an 
algorithm ğ’œ maintaining polynomial 
in ğ‘‘, 1 ğ›¼â„ , logâ¡(1 ğ›½â„ ), , will give an 
output from the hypothesis class â„ğœ–â¡â„‹ 
, satisfying  

Pr[ğ‘’ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(â„) â‰¤ â¡ğ‘‚ğ‘ƒğ‘‡ + ğ›¼] â¡ â‰¥ 1 âˆ’ â¡ğ›½ 

over the drawn examples ğ‘§ğ‘– =
(ğ‘¥ğ‘–, ğ‘(ğ‘¥ğ‘–)) 

 
 
 
 
Private PAC Learning 

Same as PAC learning with the 
addition of privacy parameter 
âˆ€ğœ€ > 0 on the algorithm ğ’œ and 
polynomial runtime ofâ¡ğ’œ. 

Private Agnostic Learning 

Same as Agnostic Learning with 
the addition of privacy parameter 
âˆ€ğœ€ > 0 on the algorithm ğ’œ and 
polynomial runtime ofâ¡ğ’œ. 

SQ (Statistical query)oracle  

SQ learning 

Local Learning 

Efficient private learner for 
PARITY 

It takes a statistical query as an 
input over some distribution on 
labeled data with a promise to 
maintain the output within the 
tolerance of the expectations of 
the statistical query drawn from 
the distribution.  

A class of functions over a 
definite dimension will be SQ 
learnable using SQ oracle if there 
exists such algorithm 
maintaining a polynomial time, 
whose output will be produced as 
an element of the hypothesis 
class by asking a limited number 
of queries in the limit of 
tolerance parameter with a 
definite probability. 

It is identical to PAC learning 
with the addition of the SQ 
learning. 

It maintains PAC learn ability.  
The new introduction here is a 
class of PARITY functions 
instead of a class of concepts 
with a definite failure probability 
1
of
2

+ â¡ğ›½ 

âˆ€ğ‘‘ğœ–â„•, âˆ€ğ‘ğœ–ğ¶ğ‘‘ , âˆ€ğ’³ğœ–ğ‘‹ğ‘‘, âˆ€ğœ€ > 0 ,an 
algorithm ğ’œ maintaining polynomial 
in ğ‘‘, 1 ğ›¼â„ , 1 ğœ€â„ , logâ¡(1 ğ›½â„ ), , will give 
an output from the hypothesis class 
â„ğœ–â¡â„‹ , satisfying  

Pr[ğ‘’ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(â„) â‰¤ â¡ğ›¼] â¡ â‰¥ 1 âˆ’ â¡ğ›½ 

over the drawn examples ğ‘§ğ‘– =
(ğ‘¥ğ‘–, ğ‘(ğ‘¥ğ‘–)) 

âˆ€ğ‘‘ğœ–â„•, âˆ€ğ‘ğœ–ğ¶ğ‘‘ , âˆ€ğ’³ğœ–ğ‘‹ğ‘‘ Ã— {0,1}, âˆ€ğœ€ >
0 , an algorithm ğ’œ maintaining 
polynomial in ğ‘‘, 1 ğ›¼â„ , 1 ğœ€â„ , logâ¡(1 ğ›½â„ ), 
, will give an output from the 
hypothesis class â„ğœ–â¡â„‹ , satisfying  

Pr[ğ‘’ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(â„) â‰¤ â¡ğ‘‚ğ‘ƒğ‘‡ + ğ›¼] â¡ â‰¥ 1 âˆ’ â¡ğ›½ 

over the drawn examples ğ‘§ğ‘– =
(ğ‘¥ğ‘–, ğ‘(ğ‘¥ğ‘–)) 

|â¡ğ’ªğ’Ÿ

ğœ (ğœ™) âˆ’ â¡ ğ”¼(ğ‘¥,ğ‘¦)~ğ’Ÿ[ğœ™(ğ‘¥, ğ‘¦)]| â‰¤ â¡ğœ 

With probability:1 âˆ’ â¡ğ›½,  

Output a hypothesis ğ‘“ğœ–ğ¶maintaining: 
ğ‘’ğ‘Ÿğ‘Ÿ(ğ‘“, ğ’Ÿ) â‰¤ â¡ ğ‘šğ‘–ğ‘›ğ‘“âˆ—ğœ–ğ¶ğ‘’ğ‘Ÿğ‘Ÿ(ğ‘“âˆ—, ğ’Ÿ) + â¡â¡ğ›¼ 

Tolerance parameter ğœ–â¡(0,1) 

Input function: 
ğ‘†ğ‘„ğ‘,ğ’³ 

Output v maintains the SQ learning 
promise.  

Given, ğ‘ğ‘Ÿ, ğ‘Ÿğœ–{0,1}ğ‘‘, satisfies: 

Pr[ğ’œ(ğ‘›, ğ‘§, ğœ€) = ğ‘’ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(â„) â‰¤ ğ›¼] â¡

â‰¥

1
2

+ â¡ğ›½ 

 
 
 
MASKED-PARITY 

It maintains the weak SQ learn 
ability with polynomial number 
of queries, error bounded below 

1

2

This learning concept class is 
considered when the distribution  
ğ‘‹ğ‘‘ is uniform over binary strings with 
lengthğ‘‘ + log ğ‘‘ + 1 

In the following table 4 the symbols and description for all the aforementioned learning models is given. 

Table 4. Symbols and Descriptions for the different learning models 

Symbols 

Description 

C 
ğ¶ğ‘‘ 
ğ· 
ğ’³ 
ğ‘‹ğ‘‘ 
N 
X 
H 
h 
error(h) 
c 
Î² 
Î± 
z 
c(x) 
A 

ğ‘ğ‘Ÿ 
Cr(x) 
r 
Î²0 
z0 
Aâˆ— 
SQD 
ğ‘†ğ‘„ğ‘,ğ’³ 

ğœ 

ğœ™ 

ğœ  
ğ’ªğ’Ÿ

n 

ğœ– 

Universal concept class:{ğ¶ğ‘‘}ğ‘‘ğœ–â„• 
The class of concepts from ğ‘‹ğ‘‘to {0,1} 
ğ‘‹ğ‘‘Ã— {0,1} 
{ğ‘‹}ğ‘‘ğœ–â„• 
The distribution of sampleğ‘‘ğœ–â„• 
Set of natural number 
Set of all distributions on ğ‘‹ğ‘‘ 
A class of hypothesis. 
A hypothesis that belongs to H 
ğ‘ƒğ‘¥,ğ‘¦â¡~ğ’Ÿ[â¡â„(ğ‘¥) â‰  ğ‘(ğ‘¥)] 
A specific concept that belongs toğ‘ğœ–ğ¶ğ‘‘ 
Bounds of the probability of failure 
Desired error 
Learning algorithmâ€™s input. 
A particular element of a particular concept. 
An algorithm 
privacy budget. 
A class of parity functions {0,1}ğ‘‘ â†’ {0,1} 
A set of cross products of random x 
{0,1}ğ‘‘ 
Probability failure bound for z0 
Neighboring input of z 
An algorithm is found by PAC learning. 
A statistical query over the distribution D 
The statistical query oracle that takes as a input function g:ğ’³ Ã— {+1, âˆ’1} â†’ {+1, âˆ’1} 

Tolerance Parameter and  ğœ âˆˆ (0,1) 

Statistical Query function:ğœ™ âˆ¶ â¡ğ’³ Ã— {0,1} â†’ [0,1] 

Statistical query oracle 

ÎŸ(

logâ¡(1 ğ›½)â„

ğœ–ğ›¼

(ğ‘‘ + log

1

ğ›½

Privacy Budget 

)) no. of examples 

For the purpose of better understanding the above discussion the classification of the learning approaches  is 
given in table 5 below. The  star (*) marked approaches are the authors own contribution towards different 
learning approaches.  

 
 
 
 
 
 
 
 
Table 5. Associated Works with PAC and SQ learning 

Learning Approach 

PAC learning 

SQ learning 

Related Learning Theories 

PAC learning, Agnostic learning, 
Private PAC learning, Private 
Agnostic learning, Efficient private learner for PARITY *. 

Statistical Query (SQ) oracle, 
SQ learning, Local learning, 
MASKED-PARITY* 

RAPPOR (Randomized Aggregatable Privacy-Preserving Ordinal Response) 
RAPPOR (Erlingsson et. al., 2014) allows the overall client data to be studied without giving permission for 
the  possibility  to  access  the  individual  information,  with  strong  privacy  and  great  utility  guarantee  using 
randomized response technique in bloom filter. The main contributions of this work are: 

â€¢  RAPPOR provides a local deferentially private model. 
â€¢  It generates report by creating noise by applying bloom filter. 
â€¢  It is the first industrialized implementation of differential privacy. 
â€¢  it is a fast framework that provides strong privacy with great utility. 

The RAPPOR algorithm is in the following flow-chart in figure 2: 

Figure 2. Flow chart of RAPPOR 

The  three  types  of  RAPPOR  are  explained  in  the  Table  6.  In  Table  7  all  the  symbols  and  description  of 
RAPPOR is defined. 

Table 6. Explanations of three types of RAPPOR 

One-Time RAPPOR 

As the client itself imposed the one-
time collection in this case, the 
instantaneous randomized response 
step can be skipped here where the 
direct randomization on the clientâ€™s 
true value is robust enough to give 
the protection against longitudinal 
privacy. 

Basic RAPPOR 
It is a special case of RAPPOR. 
If the report collected are small 
in size and well-defined 
enough it can be mapped to a 
single bit without using a 
Bloom Filter, reducing the 
number of hash functions in 
exchange. An easy example 
can be data on clientsâ€™ binary 
preferences where an â€œyesâ€ 
means 1 and a â€œnoâ€ means 2. 
Here the number of effective 
bloom filters is 1. 

Basic One-Time RAPPOR 
This is the combination of One-
time RAPPOR and Basic 
RAPPOR. A randomization step 
followed by a settled mapping to 
unique bits. 

 
 
 
 
 
Table 7. Symbols and Description for RAPPOR 

Description 

Symbols 
â„ 
ğµ 
ğ‘˜ 
ğµâ€² 
ğ‘† 
ğ‘“, ğ‘, ğ‘ 

Client Value 
First Applied Bloom filter 
Size of the response bit string 
Permanent Randomized Response 
Instantaneous Randomized Response 
User tunable parameters 

Experiments in RAPPOR 
By recall precision graph it is seen that using of only two  hash functions (when k and m are fixed) result in 
better utility as decrease in hash function is the cause for increase in expected recall. 

For the experiment, two simulated and two real world data were used to apply RAPPOR algorithm. The first 
one of simulated data was used for Basic One-time RAPPOR and the underlying distribution was found to be 
normal distribution with enough noise. The second simulated example was used to apply modified RAPPOR 
for collecting strings and it showed the exponential distribution of string frequencies. The third example was 
real world data on processes running on windows machines. In this case, the frequency of a particular process 
â€BADAPPLE.COMâ€ was estimated with 128 bit size bloom filter, 2 hash functions, 8 cohorts where q = 0.75, 
p  =  0.5  and  f  =  0.5.  The  estimated  frequency  of  BADAPPLE.COM  was  found  to  be  2.6%.  The  data  on 
Chrome  Homepages  were  used  for  last  example  and  it  was  observed  that  the  analysis  of  RAPPOR  can 
discover  URL  domains  of  homepage,  with  statistical  confidence,  if  their  frequencies  exceed  0.1%  of  the 
responding population. 

PROCHLO 
Itâ€™s  a  common  practice  now  a  day  to  monitor  the  userâ€™s  software  activities  thoroughly to  provide good and 
elevated  service  by  the  companies.  PROCHLO  (Bittau  et.  al.,  2017)  describes  architecture  of  a  principled 
system  -  Encode,  Shuffle,  analyze  (ESA)  to  perform  such  activities  by  maintaining  higher  utility  through 
preserving  strong  privacy  guarantee.  Here  a  pipeline  is  used  where  a  randomly  drawn  sample  from  usersâ€™ 
input  is  (Encoding  :)  encrypted  first  by  pushing  noise  randomly,  encoded  by  breaking  the  whole  encrypted 
string into data fragments, then (Shuffling:) shuffled by a secret shuffler and at last (Analyzing:) the report is 
generated from the sample. 

Architecture: PROCHLO  
It uses the Google SGX as the secret shuffler. SGX has small memory that cannot hold the millions of  data, 
and thatâ€™s why rather transferring the whole sample of usersâ€™ input directly to the shuffler, PROCHLO creates 
crowd IDs. Let, the total number of usersâ€™ input is N and the number of crowd ID is B+. Then the number of 
ğ‘
input having the same crowd ID isâ¡ğ·+ = â¡
ğµ+. After getting the bunch of inputs belonging to same crowd ID, 
they are divided into fragments for encoding. 

â€¢ Step 1: Encoding 

The  encoding  can  be  done  by tâˆ— secret  shares  where tâˆ—  secret  shares  split  a  secret  Sâˆ—  in  a  filed  F into 
arbitrary Sâˆ—1, Sâˆ—2,.... so that any tâˆ— âˆ’1 shares can hide all information about Sâˆ—. A secret share of Sâˆ— is 
tuple  [x,Ï(x)]  for  randomly  chosen  nonzero  x    F  where  Sâˆ—=  Ï(x).  Let  t  secret  sharing  encode  of  an 
arbitrary string m with parameter tâˆ— is a pair as (c,aux) where c is the cipher text which is a deterministic 
encryption under a  key ğ¾ğ‘š= H(m)  and  aux  be the  tâˆ—  secret  shares  of ğ¾ğ‘š.  But  the m is recoverable by 
using robust decryption attack with the help of aux1, aux2, ....auxt to find the ğ¾ğ‘š and by using ğ¾ğ‘š he/she 
can decrypt c and in this way one can create an attack to disclose the private data of individuals. 

 
 
 
 
 
 
 
So,  PROCHLO  use  the  data  fragmentation  for  encryption.  For  example,  consider  an  analysis  on  a 
database  based  upon  the  audiencesâ€™  ratings  on  movies.  In  this  database  each  entryis  supposed  to  be 
â€œindividualâ€ and a concern of privacy. To protect privacy, fragmentation is used here. consider a movie 
rating set is {(ğ‘š0, ğ‘Ÿ0),((ğ‘š1, ğ‘Ÿ1),(ğ‘š2, ğ‘Ÿ2)}. Where ğ‘ši (i=0:2) is the name of the ith movie and ğ‘Ÿi (i=0:2)is 
the  rating  of  the  ith  movie.  Now,  the  elements  of  this  rating  set  can  be  encoded  as  their  pairwise 
combinations likeâŒ©(ğ‘š0, ğ‘Ÿ0), (ğ‘š1, ğ‘Ÿ1)âŒª, âŒ©(ğ‘š0, ğ‘Ÿ0), (ğ‘š2, ğ‘Ÿ2)âŒªand âŒ©(ğ‘š1, ğ‘Ÿ1), (ğ‘š2, ğ‘Ÿ2)âŒª whereeach pair  will  be 
transmitted to the secret shuffler for the independent shuffling. The shuffler is trusted but always curious 
about the private data of individuals. Here, for generating the crowd IDs and encryption, it is hard for the 
shuffler to guess about the private information of any particular individual. 

â€¢ Step 2: Shuffling 

In the next part of this pipeline, this shuffler performs four tasks and those are anonymization, shuffling, 
thresholding and batching. 

o  Anonymization - Anonymization is created by striping metadata which is not enough for privacy. 

ğ‘
ğµâˆ—

o  Shuffling-  For  this,  the  SGX  do  the  oblivious  shuffling.  Based  on  Melbourne  shuffle  technique, 
PROCHLO  introduces  the  Stash  shuffle  that  actually  improves  the  all  previous  problems.  Here, 
consider  Bâˆ—  input  and  outputs  buckets  each  havingğ·â€â¡ =
 items.  At  first, ğ·â€â¡ items  of  each  input 
buckets are random shuffled with B  âˆ— âˆ’1 bucket separator. The shuffles determine which items will 
fall into which target output bucket. Then for every output bucket, as long as there is still room in the 
maximum  C  items  to  output,  the  items  from  input  bucket  are  read,  decrypted  and  deposited  to  the 
output bucket. If the bucket is full of C items, then the next items will go to the Stash and start waiting 
for the next target bucket. Finally, if some output bucket still not filled with C quota, then they are 
filled  with  dummy  variables.  After  all  input  buckets  has  been  processed,  the  Stash  may  leave  over 
with some items. These items are drained by filling extra K items per output buckets. At the end of 
this  phase,  K  is  set  to  be 
 where  Sâˆ—=  stash  space  and  Bâˆ—=  bucket  number.  Now,  all  the  items  in 
output buckets are re-encrypted, shuffled and dummy items are filtered out from every bucket. Each 
bucket drops ğ‘‘â€²â€™ item in this phase. After that, ğ·â€â¡ items are forwarded as output at a time. 

ğ‘†âˆ—
ğµâˆ—

â–ª  The  phase  proceeds  in  a  sliding  window  w  buckets  of  intermediate  items.  At  the  time  of 
ğ‘Ÿ, ğœ‡)  where  (g,hâˆ—) is 
shuffling,  there  are  two  secret  shufflers.  The  encoder  computes (ğ‘”ğ‘Ÿ, â„âˆ—
the key of shuffler 2 and r is a random value. Shuffler 1 is a blind shuffler that creates a secret 
 Î±â€²for each tuple where Î±â€²ğœ–Î–ğ‘and compute (ğ‘”ğ‘Ÿğ›¼,

ğ‘Ÿâ¡.â¡â¡ğœ‡)ğ›¼â€²

, (â„âˆ—

) 

ğ‘¢

â–ª  After that, the shufflers 1 batch the data, shuffles and forward the blinded items to shuffler 2. 
Shuffler 2 uses its private key that is the secret xâˆ— such that hâˆ—= gxâˆ— on input (u,v) to compute 
ğ‘¥âˆ—and recover ÂµÎ±0 = H(ğ‘ğ‘Ÿğ‘œğ‘¤ğ‘‘ğ¼ğ·)ğ›¼â€²
It works with crowd ID that are already hashed and has 
ğ‘£
raised  to  a  secret  powerğ›¼â€².  With  the  blind  crowd  ID,  shuffler  1  cannot  do  the  dictionary 
attack, since it does not know the secret key of the shuffler 2, whereas shuffler2 also cannot 
do  such  attack  as  it  has  not  any  idea  about  the  secret ğ›¼â€² of  shuffler  1.  So,  at  the  time  of 
shuffling, privacy is maintained. 

o  Thresholding- Even stripped and shuffled data may identify a client by uniqueness and to prevent this 

the shuffler do thresholding by generating crowdID. 

o  Batching- After that, the shuffler forwards the data to the analyser infrequently, in batches. 

â€¢ Step 3: Analyzing 

The analyzer decrypts, stores and aggregate those data comes from the shuffler. The analyzerâ€™s output is 
considered public. Analyzer uses the PINQ, FLEX or the systems such as Airavat to maintain the final 
protection of userâ€™s privacy. 

All the symbols and description of PROCHLO are given in the following table 8:  

 
 
 
 
 
Table 8: Symbols and Description of PROCHLO 

Symbols 

Description 

ğ‘†âˆ— 
ğ‘¡âˆ— 
F 
ğ¾ğ‘š 
 c 

ğ‘ğ‘¢ğ‘¥ğ‘– 

N 
B* 
ğ·" 
C 
ğ‘†âˆ— 
K 
ğ‘‘â€² 
(u, v) 
ğµ+ 
ğ·+ 

Secret string. 
Number of secret shares. 
Field contains all the secret strings. 
Key. 
Cipher text. 
ğ‘–ğ‘¡â„ Number secret sharing among all t shares. 
Total number of user inputs. 
Number of  buckets 
Number of outputs each output bucket has. 
Maximum quota of each target bucket. 
Stash. 
Number of extra elements per output bucket. 
Number of items dropped by each output bucket. 
Input from users. 
Number of crowdID. 
Number of inputs having same crowdID. 

Experiments: PROCHLO  
It performs four experiments with Crowd, Secret Crowd, No-Crowd and Blinded-Crowd to privately learn word 
frequencies on sample of size 10K,100K and 1M. It is seen that, if data with No-Crowd are transferred to the 
pipeline, it will have no privacy and highest utility whereas if we pass the data with Crowd , then the privacy will 
be improved but not so much. By creating secret Crowd, this problem can be recover, but still the result is not 
satisfactory so much. all of this problem can be removed by applying blinded Crowd to the data which provides 
strong privacy guarantee with great utility. 

PROCHLO provides much better utility than RAPPOR while maintaining strong privacy guarantee. Here, data 
have less noise than RAPPOR reports, so the utility becomes higher. PROCHLO not only offers good balance 
between utility and privacy, it introduces both new cryptographic primitives and a new algorithm of oblivious 
shuffling.  PROCHLO  is  relatively  simple,  easy  to  understand  system  and  also  has  the  straightforward 
realization of the ESA structure that minimizes trust issues. 

Amplification by Shuffling 
A  important  task  in  data  analysis is  the  monitoring  of  the  statistical  properties of  the  data in  a  manner  that 
requires repeated computation the entire data set which is involved and that type of monitoring can directly or 
indirectly  harm  the  data  by  exposing  private  information  about  sensitive  attribute  of  user.  In  case  of 
centralized  differential  model,  the  response  should  be  stable  while  the  neighboring  data  set  differs  from  n 
rows. So, the centralized differential model provides better privacy than the LDP model. 

Inspired by differential privacy under continuous observation, Amplification  by Shuffling (Erlingsson et. al., 
2019) provides an algorithm that gives high accuracy online monitoring on usersâ€™ input in LDP model whose 
privacy cost is poly-logarithmic in number of changes in usersâ€™ input and it shows how LDP guarantees about 
privacy  protection  while  doing  online  monitoring  even  when  the  users  report  repeatedly,  over  multiple 
timesteps, and whether they report on the highly correlated value, on the same value or independently drawn 
values.  This  privacy  amplification  technique  shows  that  any  permutation-invariant  algorithm  satisfying 

1
differential privacy will satisfy O(ğœ–âˆšlog (
ğ›¿

) , ğ‘› ) central differential privacy. 

 
 
 
 
 
Mathematical Model and Lower bound  
Let, we want to know the number of times a software is used by n users at the time horizon d and the input is 
taken repeated time at the time point t [d]. Consider a population of n users reporting a boolean value about 
their state at each time period tğœ–â¡[ğ‘‘] where [d]= (d1, d2,.....) and d is the power of 2. Sti = {Sti[1], Sti[2], ......., 
Sti[d]} denotes the ith userâ€™s state at the time point tğœ–â¡[ğ‘‘]and they can change their input at most k times. Let, 
ğ‘¥ğ‘– ={ ğ‘¥ğ‘–[1], ğ‘¥ğ‘–[2],  ....., ğ‘¥ğ‘–[d]}  denotes  the  changes  by  the  ith  user  at  the  time  point  tğœ–â¡[ğ‘‘].  Then,  Sti[d]  = 
âˆ‘
will  be  the  running  count  or  marginal  sum.  Now,  h  is  the  hth    level  of  the 
balanced  binary  tree  and Hi  be the  number  of  nodes  of  the  hth level  of the ith  userâ€™s  tree  and  it is  denoted 
byğ»(â„ğ‘–)ğ‘“ğ‘œğ‘Ÿâ„ğœ–[log2 d+1]. after that, k and c are initialised as k=0 and c=0 , d and kâˆ— is set up and the input xt 
is taken. Updateğ‘¥ğ‘¡â¡, ğ‘¡, ğœ–at each time step and modify k and c where the process is  differential private andğ‘¡ â‰¤
ğ‘‘, ğ‘¥ğ‘¡ âˆˆ {âˆ’1,0,1}. If ğ‘¥ğ‘¡ â‰  0, k= k+1, and when k reaches kâˆ—, c takes the value of xt. Otherwise, if c=0 and t is 
divisible by 2h-1, u take random value from {-1,1}, else b takes 

 and   ğ‘“ğ‘¡ = â¡ âˆ‘ ğ‘¥ğ‘–[ğ‘¡]

ğ‘¥ğ‘–[ğ‘™]

ğ‘›
ğ‘–=1

ğ‘™ğœ–[ğ‘¡]

value  from  2Ã— [ğµğ‘’ğ‘Ÿ (

) âˆ’ 1] and  u  takes  (b  Ã—  c).  Now  for  response,  thealgorithm  creates  ağ‘‡ğ‘ ğ‘¢ğ‘š [â„,

ğœ–
2

ğ‘’

ğœ–
2

1+ğ‘’

[h,i]

ğ‘‡ğ‘ ğ‘¢ğ‘š

[â„, ğ‘–].Here ğ‘‡[â„, ğ‘–]is  the  sum  of  independent  random 

ğ‘¡

2â„âˆ’1] = â¡ âˆ‘
variables that come from the range [-1, 1]. Now, 

) . ğ‘˜ğ‘™ğ‘œğ‘”2ğ‘‘.âˆ‘

ğ‘¡ = (

ğ‘–,â„,ğ‘¡=â„

ğ‘¢ğ‘–,ğ‘¡

ğ‘’

andğ‘“Ì…

ğ‘’

ğœ–
2+1
ğœ–
2âˆ’1

âˆ€[â„, ğ‘–]:â¡|ğ‘‡[â„â€²ğ‘–] âˆ’ ğ¸[ğ‘‡[â„, ğ‘–]]| â‰¤ â¡ ğ‘ğœ–

âˆšğ‘›

ğ‘™ğ‘œğ‘”

2ğ‘‘
ğ›½
ğ‘™ğ‘œğ‘”2ğ‘‘

, where, ğ‘ğœ– = (

ğœ–
2+1
ğœ–
2âˆ’1

ğ‘’

ğ‘’

) 

Byscaling with  ğ‘ğœ–

â€² ğ‘˜ğ‘™ğ‘œğ‘”2ğ‘‘and multiplying by log2 d we get, 

âˆ€ğ‘¡ğœ–[ğ‘‘]: |ğ‘“ğ‘¡ âˆ’ â¡ ğ‘“Ì…

3
2âˆšğ‘› log2
ğ‘¡| â¡ â‰¤ â¡ ğ‘ğœ–ğ‘˜(log2 ğ‘‘)

2ğ‘‘
ğ›½

(ğ‘–)  and ğ· = â¡ ğ‘¥ğ‘–:ğ‘›are used whereğ´ğ‘™ğ‘‘ğ‘

(ğ‘–) : ğ‘†(1)Ã— ğ‘†(2)Ã— ........ Ã— D â†’ ğ‘†(ğ‘–)be the input from ith user. 
Now, the algorithmğ´ğ‘™ğ‘‘ğ‘
After taking input ğ‘¥1, ğ‘¥2,,......, ğ‘¥ğ‘›,  a random number I is chosen from [1:n] and then the first element of the data is 
swapped with the Ith element. Now, the local randomiser is operated with the data set. Let Ï€ be any permutation of 
the  set [1:n], then  Ï€(D)  â†  {xÏ€(1),  xÏ€(2), .....,  xÏ€(n)}.  After  Local  Randomisation,  again  a shuffling  is done  where zi 
takes the value (z1:(i-1) , xi) and the generated report is {zÏ€(1), zÏ€(2), ....., zÏ€(n)}. 
Let, T is sampled from the distribution of I conditioned on ğ‘1:ğ‘› =ğ‘†1:ğ‘›. Then, 

ğ‘ƒ(ğ‘1:ğ‘›=â¡ğ‘†1:ğ‘›|ğ‘‡=ğ‘–)
ğ‘ƒ(ğ‘1:ğ‘›=â¡ğ‘†1:ğ‘›|ğ‘‡=ğ‘—)

â¡ â‰¤ â¡ ğ‘’2.ğœ– 

Now, we can write 

ğ‘ƒ(ğ‘‡ = ğ‘–|ğ‘1:ğ‘› = â¡ ğ‘†1:ğ‘›) = â¡

ğ‘ƒ(ğ‘1:ğ‘› = â¡ ğ‘†1:ğ‘›|ğ‘‡ = ğ‘–). ğ‘(ğ‘‡ = ğ‘–)
ğ‘ƒ(ğ‘1:ğ‘› = â¡ ğ‘†1:ğ‘›)|

â¡ â‰¤ â¡

1
ğ‘›

ğ‘’2.ğœ– 

Because  T  is  uniform  over  [n]  andğ‘ = â¡ ğ‘â€² = â¡
composition theorem we get 

1
ğ‘›

.  Applying  privacy  amplification  by  shuffling  and  advanced 

ğ‘›ğœ–(ğ‘’ğœ– âˆ’ 1) â‰¤

65
64

ğ‘›(ğœ–1)2 â‰¤

1
ğ›¿

2
3

ğœ–0

âˆšğ‘™ğ‘œğ‘”
ğ‘›

Where , ğœ– < ğœ–1âˆš2ğ‘›ğ‘™ğ‘œğ‘”

1
ğ›¿

+ ğ‘›ğœ–1(ğ‘’ğœ– âˆ’ 1) and ğœ–1 â‰¤

8ğœ–
ğ‘›

â¡, ğœ–0 â‰¤ â¡

1
2

 , ğ›¿ is the small distance between two datasets. 

Each set  of ğ‘›â€²users  for  which  the result is  applicable are still  be guaranteed  by  a  factor âˆšğ‘›â€²reduction in the 
centralised privacy model for the worst possible case. Here shuffling after the local randomisation technique 

satisfies(ğœ–, ğ›¿)differential  privacy  at  index  i  in  the  central  model  where ğœ– = 12ğœ–0âˆšğ‘™ğ‘œğ‘”

1
ğ›¿
|ğ‘†|

 ; ğ‘† âŠ† |ğ‘›| such  that 

ğ‘–, ğ‘—ğœ–ğ‘†, ğ´ğ‘™ğ‘‘ğ‘

(ğ‘—)  
(ğ‘–) = â¡ ğ´ğ‘™ğ‘‘ğ‘

 
 
 
 
 
 
 
 
 
 
 
 
Table 9. Symbols and Description for Amplification of Shuffling 

Symbols 

Description 

t 
d 
Sti 
ğ‘¥ğ‘– 
ğ‘“ğ‘¡ 
ğ‘“Ì…
ğ‘¡ 
ğ»(â„ğ‘–) 
ğ‘‡(â„, ğ‘–) 
D 
ğœ‹ 
ğœ– 
ğœ–1 
ğœ–0 
ğ‘†(ğ‘–) 

(ğ‘–)  
ğ´ğ‘™ğ‘‘ğ‘

Time Point 
Time Horizon 
ğ‘–ğ‘¡â„ userâ€™s state at the time point t 
Changes by ğ‘–ğ‘¡â„ user. 
Running count 
Expected running count 
Number of nodes at the â„ğ‘¡â„ level of tree T 
sum of independent random variables that come from the range [-1, 1] 
Database 
Any permutation of the set [1: n] 
Privacy budget o the data set. 
Privacy budget of neighboring data set Dâ€™  
(ğ‘–)  
Privacy budget of  ğ´ğ‘™ğ‘‘ğ‘
(ğ‘–)  
Range space of ğ´ğ‘™ğ‘‘ğ‘
ith local differentially private algorithm 

The  result  of  Amplification  by  Shuffling  is  encouraging,  and  it  secures  the  differential  privacy  in  central 
differential model and make the stable response for differing single input in two data sets. But this algorithm 
gives very poor response for longitudinal data. This formalisation assumes that the user population to be static 
which does not compared to real world. 

OUTIS 
This paper provides a framework that provides an accuracy guarantee just like CDP model (Chowdhury et. al., 
2019)  without  any  trusted  data  collector.  Here  crypt  employs  two  non-  colluding  semi-trusted  server  AS 
(Analytic  Server)  and  CSP  (Cryptographic  Service  Provider  )that  run  differential  privacy  on  the  encrypted 
data given by the data owner. 

Cryptographic Primitives: OUTIS 

In their paper they used four cryptography schemes. They are explained in the following â€“  

â€¢  Linear  Homomorphic  Encryption  (LHE)  -  This  scheme  consists  of  three  stages  i.e.  Key  generation, 
Encryption  and  Decryption  on  the  basis  of  the  group (â„³, +).  In  the  first  stage  a  user  tunable  security 
parameter K is being passed as input in the pipeline which outputs a pair of keys. Those are secret and 
public keys - (ğ‘†ğ‘˜, ğ‘ƒğ‘˜).  In the second stage, using the public key  ğ‘ƒğ‘˜ a randomized algorithm encrypts a 
message ğ‘š âˆˆ â„³ to ğ‘.  The  third  and  the  last  part  decrypt ğ‘ from  the  last  stage  using ğ‘†ğ‘˜ to  recover  the 
plaintext message ğ‘š deterministically. 

â€¢  Labelled  Homomorphic  Encryption  (LabHE)  â€“  By  the  introduction  of  pseudo-random  function  every 
LHE scheme can be changed to LabHE. The LabHE scheme also has the ability to multiply two LabHE 
ciphers.  

â€¢  They  have  used  two  more  primitives  too.  Those  are  â€œğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘œğ‘Ÿâ¡â¨ â€œand  â€œSecure  computation  using 
garbled  circuitâ€. ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘œğ‘Ÿâ¡â¨â¡is  mainly  used  for  the  repetition  purpose.  In  the  later  scheme,  for  two 
private inputs from two parties, no party can learn more than ğ‘“(ğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡1, ğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡2)  for a function ğ‘“. This is 
an inherent generator scheme using garbled input in every steps. 

Architecture: OUTIS 
The algorithm is given below- 

â€¢  Setup Phase:  

The owner initializes the privacy budget ğœ–ğ›½ for CSP and stores it in CSPâ€™s privacy engine module. Then the 
CSP key manager produces a pair of keys(ğ‘†ğ‘˜, ğ‘ƒğ‘˜).  For labHE and publishes ğ‘ƒğ‘˜ storesğ‘†ğ‘˜. 

 
 
 
 
 
â€¢  Data Collection Phase: 

 In this phase, data owner encrypts and encodes his data with the help of data encryption technique and data 
encoder  and  then  sends  the  encrypted  and  encoded  data  to  As  and  after  that,  data  owner  gets  offline 
completely. As, aggregates the data into a singleencrypted database D by aggregator module. 

â€¢  Program Execution Phase: 

 Here  AS  executes  data  analyst  provided  crypt  programs  that  accesses  sensitive  data  by  various 
transformation  operators  like  Cross  Product,  Project,  Filter,  Count,  Group  By  Count,  Group  By  Count 
Encoded,  Count  Distinct  etc  and  measurement  operators  like  Laplace,  Noisy  Max  etc  which  are  DP 
operations to create noisy answer. Measurement operators require interaction with CSP as they need to 
decrypt the data and also to check whether the privacy budget is exceeded or not. These functions can be 
done by the CSPâ€™s data decryption and privacy budget modules. 

Table 10. Symbols and Descriptions for subsection OUTIS 

Symbol 

Description 

Privacy budget for cryptographic service provider 
Secret key 
Private key 
Cipher text 
Message to be encrypted 
Aggregated data 

ğœ–ğ›½ 
ğ‘†ğ‘˜ 
ğ‘ƒğ‘˜ 
c 
m 
ğ·Ì… 

The first  two  phases  occur  exactly once  at the  beginning  and  every  subsequent  program  are  handled  by  the 
corresponding program execution phase. 

Experiments: OUTIS 
For  experiments  they  use  a  schema  database  <Age,  Gender,  Native  Country,  Race>  and  shows  7 
cryptographic  examples  over  it.  They  uses  the  crypt  program  p1  to  find  the  cumulative  distribution  of  age 
where the first step is to compute 100 ranges queries and the ith query computes the number of persons having 
the age ğœ– [0,i] in ğ·Ì…with privacy guarantee ğœ–ğ‘– then they applied a sequence of transformation operators in each 
range  of  queries  and  all  of  these  operators  have  stability  bound  1.  For  this,  the  resultant  range  query  has  a 
sensitivity upper bound 1. In this way, the subsequent measurement operator Laplace takes the privacy budget 
ğœ–ğ‘–and sensitivity âˆ† = 1. After looping over 100 ranges, p1 gives a noisy plain text ğ‘‰Ì‚= {ğ‘1Ì‚ ,ğ‘2Ì‚ ,....,ğ‘100Ì‚  } and at 
the end of the program the privacy budget is âˆ‘

. 

100
ğ‘–=1

ğœ–ğ‘–

ARA (Aggregated RAPPOR and Analysis for Central Differential Privacy) 
The main aim of ARA (Paul et. al., 2020) is trying to produce a bridge to keep best of both the worlds in terms 
of LDP and CDP, which is a software approach, comparatively less expensive, fast with less complexity in the 
analysis and overall method.  
The main contributions of ARA are following â€“ 
â€¢  The promises of DP are maintained. 
â€¢  Fast enough analysis phase (Around 1.5 hours for 1000 users times 100 loops of analysis) 
â€¢  Correct identification of the highest occurred true value every time with varying achievement. 
â€¢  Simple probabilistic analysis method in comparison to OUTIS or PROCHLO. 

Methodology and Experiments: ARA  
ARA collects data after cloning the RAPPOR code from the Google repository of GitHub by running it 100 
times  to  make  their  own  database  using  the  generated  RAPPOR  reports.  It  only  uses  ten  true  values  for 
convenience where RAPPOR has used 100 true values.  

 
 
 
 
 
 
 
 
 
In the first step the sampling is done in 100, 1000, 10000, 20000, 25000 samples taking at a time randomly 
from the created dataset without any repetition. Then the TF-IDF value is calculated with the formula given in 
the table 11. The two achievements from this step are â€“ 

â€¢  No more than âŒˆğ‘˜ 2â„ âŒ‰ + 1 positions can grab â€œon bitâ€s. Here, ğ‘˜ = 32. 
â€¢  Constant values for 17 bit positions are calculated for the â€œonâ€ bits. 

These values are now predefined for the next step and securely preserved by the trusted data curator. 

Table 11. The 17 constants value retrieved using continuous sampling on the RAPPOR reports 

Number of â€˜on bitâ€™ in the string 

Constant Value ğ“’ğ’—(v ranged from 1 - 
17) 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 

16 

17 

1.20201279 

1.0927389 

0.993399 

0.90309 

0.80618 

0.727 

0.660052 

0.60206 

0.550907 

0.50515 

0.4637573 

0.425969 

0.3912066 

0.3590219 

0.329059 

0.30103 

0.274701 

Source: Paul et. al., 2020 

In the second step, the weighted sum for the prr and irr strings is being calculated using the formulas given in 
the table. These sums are stored for a minimum time for the purpose of experiment . 
The last step is the testing phase, where the RAPPOR reports are being drawn again randomly from the testing 
portion of the created database and the weighted sum is being calculated and matched against the preserved 
results in the second step. The formulas of each steps can be consulted from the original ARA (Paul et. al., 
2020) paper and the description of the terms used in those formulas are given in the following table 12. 

Table 12. Symbols and Descriptions for ARA 

Symbol 

ğ‘‡ğ¹(ğ‘¡", ğ‘‘âˆ—) 
tâ€ 
d* 
ğ‘“ğ‘¡",ğ‘‘âˆ— 
ğ¼ğ·ğ¹(ğ‘¡", ğ‘‘âˆ—) 
1 + |ğ‘‘âˆ—Ïµğ·âˆ— âˆ¶ â¡ ğ‘¡"ğœ–ğ‘‘âˆ—| 

Description 

Term Frequency 

Term 
Document in which the term tâ€ has occurred 
Frequency of occurrence tâ€ in d* 
Inverse document frequency 
Total number of documents in the corpus 

 
 
 
 
 
 
 
N 
W 
ğ¶ğ‘ğ‘Ÿğ‘Ÿ 
ğ¶ğ‘–ğ‘Ÿğ‘Ÿ 
V 
ğ¶ğ¶ğ‘ğ‘Ÿğ‘Ÿ 
ğ¶ğ¶ğ‘–ğ‘Ÿğ‘Ÿ 

Number of documents where tâ€ has appeared 
Weighted sum 
The count of â€˜on bitâ€™ in the prr string 
The count of â€˜on bitâ€™ in the irr string 
Cohort value 
Value taken from the ğ’ğ‘£ in the Table 11 
Value taken from the ğ’ğ‘£ in the Table 11 

The main drawbacks of ARA are that the accuracy is not more than 52.28% on an average and the detection 
ability of the second major true value is poor. 

Encode, Shuffle, Analyze, Privacy Revisited: Formalization and Empirical Evaluation 
In  this  paper  (Erlingsson et.  al.,  2020)  they tried  to  bridge  all  their  previous  works starting  from  RAPPOR, 
PROCHLO â€“ an implementation of ESA (encode, shuffle, analysis) till  Amplification by shuffling, with the 
aim  to  give  a  proper  algorithm  that  works  equally  good  in  both  the  LDP  and  CDP  environment  with  an 
extensive  experimental  results  using  MNIST  and  CIFER-10  datasets.  The  key  techniques  they  talked  about 
here are the following -   

â€¢  Anonymity 
â€¢  Reporting with the preservation of privacy 
â€¢  Sketch based encryption and its limitation 
â€¢  Cons of fragmentation 
â€¢  Cons of shuffling 

Background Theorem 
In the proposed algorithm here, data are collected from the users first and then they are encoded by one of the 
techniques such as one-hot encoding, attribute fragmentation, report fragmentation and sketch-based encoding 
and  all  of  these  schemes  produce  reports  with  localized  differential  privacy  guarantee.  Each  and  every 
encoding system have their own pros and cons too. After completing encoding, the LDP reports then are being 
shuffled by k-shuffler to aggregate in the next step. After that the algorithm of amplification by shuffling is 
applied here and the final reports are generated which hold centralized and local differential privacy guarantee 
equally. The parts of this algorithm is discussed below -  

â€¢  One-Hot Encoding 

The  type  of  encoding  has  strong  impact  on  utility  of  the  differentially  private  algorithm.  Let  D  be 
dictionary of elements and id D is not too large, then a data input x can be encoded by one-hot encoding 
where each data record x will hold an element in D.But when the D is large enough, it is not a suitable 
idea to apply one-hot encoding whereas sketching algorithm can be used. 

â€¢  Sketch-Based Reports 

The main idea of this scheme is to reduce a given domain {0,1}ğ¾â€²
, ğ‘˜â€² < ğ¾â€²via hashing and then 
use  locally  private  protocols  to  operate  over  the  domain  of  size ğ‘˜â€².  To  avoid  significant  loss  due  to 
hashing, it is performed by multiple independent hash function. But it is observed that sketching is not a 
requirement for practical deployment in regimes with local differential privacy. 

to {0,1}ğ‘˜â€²

â€¢  Attributes Fragments 

In this case, each data record x is encoded as a binary vector with k or fewer bit set and each k vector 
coordinate is called attributes where x = Î£xi, xi is one-hot encoded vector. Now, either each xi splitting 
privacy budget accordingly go through the  randomizer Râˆ— or one of the xi is drawn as the sample and 
spend the entire privacy budget to send is to Râˆ— which is a randomly chosen randomizer. There are two 

 
 
 
 
 
types of local randomizer, one holds the algorithm for replacement privacy guarantee and another holds 
the algorithm for removal privacy guarantee. 

o  Replacement LDP 

An algorithm R*:D â†’ S is a replacement (ğœ–, ğ›¿) deferentially private local randomiser if for 
all S âŠ† S and for all ğ‘¥, ğ‘¥â€²ğœ–ğ·: ğ‘ƒ[ğ‘…âˆ—(ğ‘¥)ğœ–ğ‘†] â‰¤ ğ‘’ğœ–ğ‘ƒ[ğ‘…âˆ—(ğ‘¥â€²)ğœ–ğ‘†] + â¡ğ›¿ 

o  Generalized Removal (ğœ–, ğ›¿) DP 

A  randomized  algorithm  M:ğ·ğ‘› â†’  S  is  a  replacement  satisfies  removal (ğœ–, ğ›¿)-  differential 
privacy if there exist an algorithm ğ‘€â€²: ğ·ğ‘› Ã— 2[ğ‘›] âŸ¶ ğ‘†with the following properties: 

â–ª 
â–ª 
â–ª 

for all ğ·ğœ–ğ·ğ‘›, ğ‘€â€²(ğ·, [ğ‘›]) is identical to M(D) 
for all ğ·ğœ–ğ·ğ‘›and ğ¼ğœ–[ğ‘›], ğ‘€â€²(ğ·, ğ¼)â¡â¡depends only on elements D with indices I. 
for all SâŠ† S,ğ·ğœ–ğ·ğ‘›and I, Iâ€™âŠ† [n]where we have that |Iâˆ†Iâ€™|=1, 
P [ ğ‘€â€²(ğ·, ğ¼)â¡â¡ğœ–S] â‰¤ â¡ ğ‘’ğœ–ğ‘ƒ[â¡ğ‘€â€²(ğ·â€², ğ¼â€²)â¡â¡ğœ–ğ‘†]â¡+ Î´ 

o  Removal LDP 

An algorithm R*:D â†’ S is a removal (ğœ–, ğ›¿) differentially private local randomiser if exist a 
random  variable  R0  such  that  for  all  S  âŠ†  S  and  for  all ğ‘¥ğœ– D  , ğ‘’âˆ’ğœ– P[ ğ‘€â€²(ğ·, ğ¼)â¡â¡ğœ– S] â‰¤
â¡ğ‘’ğœ–ğ‘ƒ[â¡ğ‘€â€²(ğ·â€², ğ¼â€²)â¡â¡ğœ–ğ‘†]â¡+ Î´ 

After  sampling  each  z  from{ğ‘¥ğ‘– âˆ¶ ğ‘–ğœ–â¡[ğ‘˜]} ,  it  is  seen  that  sending  each  attribute  of  z  independently  to  LDP 
randomiser that produce anonymous reports, is advantageous. 

â€¢  Report Fragments 

Here,  a  sequence  of  LDP  reports  which  is  generated  by  multiple  independent  applications  of  the 
randomizer Râˆ— to x has come and each such report is called report fragment containing less information 
than the entire LDP report sequence. Thus, it improves privacy guarantee more. 

After completing the encoding parts, the fragments are sent to the shuffler. There are k secret shufflers. Each 
fragment chooses one shuffler randomly and each attribute go to the separate channel of the selected shuffler. 
Then the secret shuffling is done and shuffle data came where one cannot guess which data fragments come 
from  which  shuffler.  In  this  way,  the  data  remains  deferentially  private.  After  shuffling  the  aggregate  is 
calculated  and  at  last  amplification  by  shuffling  technique  is  applied  to  make  the  whole  process  centrally 
deferentially private. 

USEFUL BACKGROUND ON DIFFERENTIAL PRIVACY 
To understand the fundamental theory of DP one need to goes through proper steps. These steps are following: 

â€¢  Understanding the background probability theorems to define DP 

This  step  consists  of  learning  about  probability  simplex,  randomized  algorithm,  distance 
between adjacent databases, definition of differential privacy derived from the afore mentioned 
concepts  and  finally  the  intuition  of  post  processing  through  the  definitions  and  proposition 
mentioned. All of these are explained in the Appendix 1.  

â€¢  Understanding the tools to build the DP algorithm 

This  step  provides  the  definition,  remarks,  theorems  and  claims  about  probabilistic  tools  like 
additive  Chernoff  bound,  multiplicative  Chernoff  bound,  Azumaâ€™s  inequality,  Stirlingâ€™s 
approximation. It also helps to understand how to introduce noise at the time of data collection 
or  structured  surveys  by  enlightening  us  on  the  concepts  of  Randomized  response,  Laplace 
mechanism, Exponential mechanism etc. All of these are explained in the Appendix 2.  

 
 
 
 
 
 
 
 
 
 
 
â€¢  Understanding the way to use those tools to build a DP algorithm 

The final step helps us to actually build a DP algorithm for real purpose by letting us understand 
about  the  Composition  theorem,  its  technicalities,  definition,  advancement,  Sparse  vector 
technique, its algorithm, theorems, definition etc. All of these are explained in the Appendix 3. 

To understand if a proposed DP  algorithm is good or bad, we need to calculate its accuracy and utility 
(Alvim  et.  al.,  2011).  The  flow  of  utility  and  accuracy  inside  the  DP  system  is  given  in  the  following 
figure 3. The definitions are explained in Appendix 3. 

Figure 3. Leakage and utility workflow using differential privacy 

Source: Alvim et. al., 2011 

CONCLUSION AND FUTURE SCOPE 
Industries are becoming heavily dependent and invested in data. In a lot of situations, user experience can be 
improved based on the meta-data we learn from what other users are doing. Few examples are trending words, 
relevant  suggestions,  battery  hungry  websites,  popular  emojis.  However,  answering  these  questions  needs 
personal data of the users. 
Differential  privacy  technique  helps  us  comprehend  what  users  are  doing,  while  protecting  the  privacy  of 
individual users. It helps us learn about the user groups without learning about the members of the group. It 
makes sure that data cannot be reproduced even by the organization that is collecting the data. It achieves so 
with the idea that a biased statistical noise is enough to disguise a userâ€™s data and when aggregated over large 
users, can still give us insight on the community. With increase in cyber-attacks as well as data harvesting; 
differential privacy is the only ethical way of data collection. 
In this chapter, we discuss differential privacy with its history and origin as well as the current state of the art 
methods. We discuss the architecture or the model of the various algorithms adopting the differential privacy 
technique  along  with  the  required  theorems,  proofs  and  experiments  to  justify  their  privacy  and  utility.  We 
believe  this  chapter  will  communicate  the  audience  about  the  current  status  of  this  research  area  as  well  as 
engage the readers with exploring research directions in the area of differential privacy. 

ACKNOWLEDGEMENT 
This research was supported by Dept. of Science and Technology (Govt. of India). 
 Grant no:NRDMS/UG/S.Mishra/Odisha/E-01/2018  

REFERENCE 

Davenport, T. H., &Prusak, L. (1998). Working knowledge: How organizations manage what they know. Harvard Business 
Press. 
Larson,  S.  (2017,  February  2).  Facebook  loses  $500  million  Oculus  lawsuit.  Retrieved  March  11,  2020,  from 
https://money.cnn.com/2017/02/01/technology/zenimax-oculus-lawsuit-500-million/ 
Reuters. (2017, March 16). To Avoid a Trial, Uber to Push for Arbitration in Waymo Lawsuit. Retrieved March 11, 2020, 
from https://fortune.com/2017/03/16/uber-arbitration-waymo/ 

 
 
 
 
 
 
 
 
 
2018  Data  Breaches  -  The  Worst  Breaches:  IdentityForceÂ®.  (2020,  February  20).  Retrieved  March  11,  2020,  from 
https://www.identityforce.com/blog/2018-data-breaches 
Armerding, T. (2018, December 20). The 18 biggest data breaches of the 21st century. Retrieved March 11, 2020, from 
https://www.csoonline.com/article/2130877/the-biggest-data-breaches-of-the-21st-century.html 
Dell  end-user  security  survey-2017.  (2017).  Https://Www.dell.com/Learn/Us/En/84/learn_docs/Dell-End-User-Security-
Survey-2017.Pdf.  Retrieved 
from  https://i.dell.com/sites/csdocuments/Learn_Docs/en/dell-end-user-security-survey-
2017.pdf 
Differential privacy. (2020, March 8). Retrieved March 11, 2020, from https://en.wikipedia.org/wiki/Differential_privacy 
Cynthia, D. (2006). Differential privacy. Automata, languages and programming, 1-12. 
Dwork,  C.,  &  Roth,  A.  (2014).  The  algorithmic  foundations  of  differential  privacy.  Foundations  and  TrendsÂ®  in 
Theoretical Computer Science, 9(3â€“4), 211-407. 
Warner,  S.  L.  (1965).  Randomized  response:  A  survey  technique  for  eliminating  evasive  answer  bias.  Journal  of  the 
American Statistical Association, 60(309), 63-69. 
Kasiviswanathan,  S.  P.,  Lee, H.  K.,  Nissim,  K.,  Raskhodnikova,  S.,  &  Smith,  A. (2011).  What  can  we  learn privately?. 
SIAM Journal on Computing, 40(3), 793-826. 
Erlingsson, Ãš., Pihur, V., &Korolova, A. (2014, November). Rappor: Randomized aggregatable privacy-preserving ordinal 
response.  In  Proceedings  of  the  2014  ACM  SIGSAC  conference  on  computer  and  communications  security  (pp.  1054-
1067). 
Bittau, A., Erlingsson, U., Maniatis, P., Mironov, I., Raghunathan, A., Lie, D., ... &Seefeld, B. (2017, October). Prochlo: 
Strong  privacy  for  analytics  in  the  crowd.  In  Proceedings of  the  26th  Symposium  on  Operating  Systems  Principles  (pp. 
441-459). 
Erlingsson, Ãš., Feldman, V., Mironov, I., Raghunathan, A., Talwar, K., &Thakurta, A. (2019). Amplification by shuffling: 
From local to central differential privacy via anonymity. In Proceedings of the Thirtieth Annual ACM-SIAM Symposium on 
Discrete Algorithms (pp. 2468-2479). Society for Industrial and Applied Mathematics. 
Chowdhury, A. R., Wang, C., He, X., Machanavajjhala, A., & Jha, S. (2019). Outis: crypto-assisted differential privacy on 
untrusted servers. arXiv preprint arXiv:1902.07756. 
Paul,  S.,  &  Mishra,  S.  (2020).  ARA:  Aggregated  RAPPOR  and  Analysis  for  Centralized  Differential  Privacy.  SN 
Computer Science, 1(1), 22. 
Erlingsson, Ãš., Feldman, V., Mironov, I., Raghunathan, A., Song, S., Talwar, K., &Thakurta,  A. (2020). Encode, Shuffle, 
Analyze Privacy Revisited: Formalizations and Empirical Evaluation. arXiv preprint arXiv:2001.03618. 
Alvim, M. S., AndrÃ©s, M. E., Chatzikokolakis, K., Degano, P., &Palamidessi, C. (2011, September). Differential privacy: 
on  the  trade-off  between  utility  and  information  leakage.  In  International  Workshop  on Formal  Aspects  in  Security  and 
Trust (pp. 39-54). Springer, Berlin, Heidelberg. 
McMahan,  H.  B.,  Andrew,  G.,  Erlingsson,  U.,  Chien,  S.,  Mironov,  I.,  Papernot,  N.,  &  Kairouz,  P.  (2018).  A  general 
approach to adding differential privacy to iterative training procedures. arXiv preprint arXiv:1812.06210. 
Hanzely, F., KoneÄnÃ½, J., Loizou, N., Richtarik, P., & Grishchenko, D. (2019). A privacy preserving randomized gossip 
algorithm via controlled noise insertion. arXiv preprint arXiv:1901.09367. 
Wang, T., Chen, J. Q., Zhang, Z., Su, D., Cheng, Y., Li, Z., ... & Jha, S. (2020). Continuous Release of Data Streams under 
both Centralized and Local Differential Privacy. arXiv preprint arXiv:2005.11753. 
Sengupta P., Paul S. and Mishra S. (2020). BUDS: Balancing Utility and Differential Privacy by Shuffling. arXiv preprint 
arXiv:2006.04125. 
Chaudhuri,  K.,  Imola,  J.,  &  Machanavajjhala,  A.  (2019).  Capacity  bounded  differential  privacy.  In Advances  in  Neural 
Information Processing Systems (pp. 3469-3478). 
Dwork,  C.,  Naor,  M.,  Pitassi,  T.,  &  Rothblum,  G.  N.  (2010,  June).  Differential  privacy  under  continual  observation. 
In Proceedings of the forty-second ACM symposium on Theory of computing (pp. 715-724). 

ADDITIONAL READING: 

This Section contains some of the current developments on Differential Privacy.  They are following: 

â€¢  Continuous Release of Data Stream Under Both Centralized and Local Differential Privacy: 
In their work (Wang et al.,2019) propose an exponential mechanism with quality function, along with two 
algorithms ToPS (threshold optimizer, perturber and smoother) and ToPL ( ToPS applied in LDP) which 
provides the solution regarding the publishing of a stream of real valued data satisfying DP. ToPL is the 
first  LDP  algorithm  for  streaming  data  and  it  is  the  hierarchical  version  of  traditional  PAK  algorithm 
(Dwork  et al.,  2010).  ToPL  is a method designed  with the framework of  ToPS  for  outputting  streaming 
data in LDP. Here, as user perturbs their values before sending to the server, there is no need to trust the 
server. Threshold optimizer uses frequency estimation instead of applying exponential mechanism (as user 
has  local  view)  which  is  less  accurate  than  EM  (exponential  mechanism).  After  achieving  optimal 
threshold parameter, the user report is first truncated then the consistent noise is applied. As the reports are 
unbiased themselves, to answer a range of queries, this algorithm doesn't use the smoother here. But they 

 
 
 
use  the  PAK  setting  in  threshold  optimizer  assuming  that  the  distribution  stays  same  with  further 
information like data changes slowly or regularly, which is a drawback. 

â€¢  A Privacy Preserving Randomized Gossip Algorithm via Controlled Noise Insertion: 

This  work  (Hanzely  et  al.,  2019)  introduces  a  duel  algorithm  based  on  average  consensus  (AC)  that 
provides iteration  complexity  bound  and  performs  extensive  numerical  experiments  while  protecting  the 
information  regarding  initial  value stored  in  the  node.  For  a  particular  graph structure, at  first the  initial 
value is provided after adding noise to the system for propagating across the network, but in the following 
iteration , the previously added noise is removed and the new noise with smaller magnitude is applied to 
ensure the convergence to the true average that maximise the utility of the system obviously.  
â€¢  A General Approach to Adding Differential Privacy to Iterative Training Procedures: 

This  work  (McMahan  et  al.,  2018)  introduces  an  algorithm  with  the  modular  approach  to  minimize  the 
changes on training algorithm by various configuration strategies of privacy mechanism which is applied 
to heterogeneous set of vectors (like gradients of different layers of DNN, matrices, batch normalization 
parameters  with  the  different  properties).  The  algorithm  provides  an  integrated  privacy  mechanism  that 
differs in granular privacy guarantee offered and the method of privacy accounting, where, after choosing 
the  subset  from  the  training data  set  with  a  probability  parameter,  using  statistical queries  -  the  privacy 
mechanism containing noises is applied to each collected aggregates and the accounting procedure is used 
to compute a final (Îµ, Î´)- differential privacy guarantee with a good balance between privacy and utility. 
The major drawbacks are, no utility bound is given to justify the good balance between privacy and utility, 
the distribution is defined over a finite domain, the source of randomness is assumed to be guaranteed and 
computationally secured and lastly they leave open the task of developing a provable floating point 
implementation using Laplace mechanism on DP-SGD and iterating it into a ML Library. 

â€¢  Capacity Bounded Differential Privacy: 

This paper (Chaudhuri et al.,2019) introduces the capacity bounded differential privacy where the 
adversary that distinguishes the output distribution is assumed to be not bounded in computational power. 
This work models adversaries using restricted f divergence between the probability distribution and study 
various properties of the definition and algorithm that satisfy them. They also show that the Laplace and 
Gaussian mechanisms are also giving better privacy by applying this new algorithm. 

â€¢  BUDS: Balancing Utility and Differential Privacy:  

This work (Poushali Sengupta et al.,2020) introduces a mechanism along with Iterative Shuffling that 
ensures a good balance between utility and privacy guarantee of the dataset. The whole mechanism can be 
decomposed into two parts: Application of Query analysis and Iterative Shuffling (IS). The main drawback 
of this work is: one hot encoding is used for encoding which is a problem for big dimensional data set. 
Also proper architecture of Query Function is not provided here. 

Key terms and Definitions: 

This  section  is  divided  into  four  parts.  The  first  part  contains  the  key  terms  and  the  following  three  parts 
contains the necessary definitions and theorems for the learning of differential privacy. 

Key terms: 
PAC Learning, SQ Learning, Private PAC Learning, Private SQ Learning, Randomized Response, Differential 
Privacy, RAPPOR, ESA, ARA, BUDS 

Definitions and Theorems for the first step: 

In  the  second  part  we  will  discuss  some  useful  definitions  and  background  theorems  that  work  for  the  first 
learning step of DP discussed in the useful background on differential privacy section in alphabetical order as 
instructed by the publisher (Dwork et. al., 2014). 

Differential Privacy  
A randomized algorithm â„³ with domain â„•|ğ’³|ğ‘–ğ‘ â¡(ğœ–, ğ›¿) - deferentially private if for all S âŠ† Range(â„³) and for all 
ğ‘¥, ğ‘¦ğœ–â„•|ğ’³| such that ||ğ‘¥ âˆ’ ğ‘¦||1 â‰¤ 1 will follow: 

ğ‘ƒ(â„³(ğ‘¥)ğœ–ğ‘†) â‰¤ exp(ğœ–) ğ‘ƒ(â„³(ğ‘¦)ğœ–ğ‘†) + ğ›¿ 

 
 
 
 
where  the  probability  space  is  over  the  coin  flips  of  the  mechanism â„³ .  If  Î´  =  0,  we  say  thatâ¡â„³â¡ğ‘–ğ‘ ğœ– - 
deferentially private. 

Distance between two adjacent databases 
The â„“1norm of a database ğ‘¥ is denoted by ||ğ‘¥||1 and is defined to be  

|ğœ’|

||ğ‘¥||1 = â¡ âˆ‘ |ğ‘¥|ğ‘–

ğ‘–=1

The â„“1 distance  between  two  databases ğ‘¥ğ‘ğ‘›ğ‘‘ğ‘¦is ||ğ‘¥ âˆ’ ğ‘¦||1 where  the  later  term  denotes  the  measure  of  how 
many records differ between ğ‘¥ğ‘ğ‘›ğ‘‘ğ‘¦. 

Explanation of Different DP 

The values of Î´ that are less than the inverse of any polynomial in the size of the database are preferable. The 
values of Î´ which are O(1/ ||x||1) are dangerous as it allows to show all private information of individuals from a 
very small portion of the database like â€just a fewâ€ case that we are already discussed in previous subsection. If Î´ 
is negligible, there are differences between (ğœ–,0) and (ğœ–, ğ›¿)differential privacy. (ğœ–,0)-differential privacy says that, 
for  every  run  of  the mechanism â„³(ğ‘¥),  the  output  observed  is  (almost) equally  likely  to  be  observed  on  every 
neighboring  database,  simultaneously.  Whereas,  (ğœ–,Î´)-differential  privacy  provide  us  a  mechanism  where,  for 
every  pair  of  neighboring  databases  x,  y,  it  is  extremely  unlikely  that,  â€˜ex  post  factoâ€™  the  observed  value 
â„³(ğ‘¥)will be much more or much less likely to be generated when the database is x than when the database is y. 

Intuition for Post-processing 
For an output ğ’µâˆ¼â„³(ğ‘¥), a database y is may be possible to find such that ğ’µ is much more likely to be produced on 
y than it is produced when in database x. Then, privacy loss can be calculated which is given below: 

ğ’µ

â„’â„³(ğ‘¥)||â„³(ğ‘¦)

=

ğ‘ƒ(â„³(ğ‘¥)=ğ’µ)
ğ‘ƒ(â„³(ğ‘¦)=ğ’µ)

This loss can be negative or positive. 

Probability Simplex   
Given a discrete set â„¬, the probability simplex over â„¬, denoted âˆ†(â¡â„¬) is defined to be: 

âˆ†(â„¬) = {ğ‘¥ğœ–â„|â„¬| âˆ¶ â¡ ğ‘¥ğ‘– â‰¥ 0â¡âˆ€ğ‘–ğ‘ğ‘›ğ‘‘ âˆ‘ ğ‘¥ğ‘– = 1

|â„¬|
ğ‘–=1

} 

Randomized Algorithm  
A  randomized  algorithm â„³ with  domain ğ’œ and  discrete  range â„¬ is  associated  with  a  mapping â„³ : ğ’œ â†’  âˆ† 
(â¡â„¬).  On  input  ağœ–ğ’œ,  the  algorithm â„³  outputs â„³ (a)  = ğ‘with  probability   (â„³â¡(ğ‘))ğ‘  for  each  bğœ–â¡â„¬ .  The 
probability space is over the coin flips of the algorithmâ„³. 

Theorem 

Any (ğœ–,Î´)-deferentially private mechanism â„³is (kğœ– ,Î´) differentially private for groups of size k. That is, for 
all ||x âˆ’ y||1 â‰¤ k and allS âŠ†Rangeâ„³] 

where the probability space is over the coin flips of the mechanism â„³. 

ğ‘ƒ[â„³(ğ‘¥)ğœ–ğ‘†] â‰¤ expâ¡(ğ‘˜ğœ–)ğ‘ƒ[â„³(ğ‘¦)ğœ–ğ‘†] 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Definitions and Theorems for the second step: 

Here we will discuss some useful definitions and background theorems that work for the second learning step 
of DP discussed in the useful background on differential privacy section in alphabetical order as instructed by 
the publisher (Dwork et. al., 2014). 

Theorems 

Additive Chernoffâ€™s bound 
Let ğ’³1, â€¦â¡â¡, ğ’³ğ‘š be  independent  random  variables  bounded  such  that 0 â‰¤ ğ’³ğ‘– â‰¤ 1 for  all  i.  Let ğ‘† = â¡
denote their mean and let ğœ‡ = â¡ğ”¼[ğ‘†] denote their expected mean. Then: 

1
ğ‘š

ğ‘š
âˆ‘ ğ’³ğ‘–
ğ‘–=1

ğ‘ƒ[ğ‘† > ğœ‡ + ğœ€] â‰¤ â¡ â„¯âˆ’2ğ‘šğœ€2
ğ‘ƒ[ğ‘† < ğœ‡ âˆ’ ğœ€] â‰¤ â¡ â„¯âˆ’2ğ‘šğœ€2

Azumaâ€™s Inequality 
Let  f  be  a  function  of  m  random  variables ğ’³1, â€¦â¡â¡, ğ’³ğ‘š each ğ’³ğ‘– taking  values  from  a  set ğ´ğ‘–  such  that ğ”¼[ğ‘“] is 
bounded. Let ğ‘ğ‘– denote the maximum effect of ğ’³ğ‘– on f , then for all ğ‘ğ‘–, ğ‘ğ‘–Ì â¡ğœ–â¡ğ´ğ‘– :  

|ğ”¼[ğ‘“â¡|â¡ğ’³1, â€¦ , ğ’³ğ‘–âˆ’1â¡â¡, ğ’³ğ‘– = â¡ ğ‘ğ‘–] âˆ’ â¡ğ”¼[ğ‘“â¡|â¡ğ’³1, â€¦ , ğ’³ğ‘–âˆ’1â¡â¡, ğ’³ğ‘– = â¡ ğ‘ğ‘–Ì ]| â‰¤ â¡ ğ‘ğ‘– 

Then: 

ğ‘ƒ[ğ‘“(ğ’³1, â€¦â¡â¡, ğ’³ğ‘š) â‰¥ â¡ğ”¼[ğ‘“] + ğ‘¡] â‰¤ â¡ â„¯

âˆ’(

2ğ‘¡2
2ğ‘š
ğ‘ğ‘–
ğ‘–=1

âˆ‘

)

Exponential Mechanism  

The  exponential  mechanism â„³ğ¸(ğ‘¥, ğ‘¢, â„›) selects  and  outputs  an  element  rğœ–â„›â¡with  probability  proportional  to 
exp(

). Where, sensitivity of the utility score u: â„•|ğ’³| Ã— â„› â†’ â„ and   

ğœ–ğ‘¢(ğ‘¥,ğ‘Ÿ)
2âˆ†ğ‘¢

âˆ†ğ‘¢ = max
ğ‘Ÿâˆˆâ„›

max
ğ‘¥,ğ‘¦âˆˆ||ğ‘¥âˆ’ğ‘¦||â‰¤1

||ğ‘¢(ğ‘¥, ğ‘Ÿ) âˆ’ ğ‘¢(ğ‘¦, ğ‘Ÿ)|| 

Claim 

The Exponential Mechanism holds (ğœ–,0) differential privacy. 

Gaussian Mechanism  
 Just like Laplace Mechanism, it adds noise drawn from the Gaussian distribution whose variance is calibrated 
according to the sensitivity and privacy parameters. 

â„³ğºğ‘ğ‘¢ğ‘ ğ‘ (ğ‘¥, ğ‘“, ğœ–, ğ›¿) = ğ‘“(ğ‘¥) + ğ’© ğ‘‘ (ğœ‡ = 0, ğœ2 =

Claim 
â„³ğºğ‘ğ‘¢ğ‘ ğ‘  holds (ğœ–,Î´) differential privacy 

2 ln (

1.25
ğ›¿

) . (âˆ†2ğ‘“)2
ğœ–2

) 

Multiplicative Chernoffâ€™s bound 
Here the background assumption is same as the additive Chernoffâ€™s bound. The bound is following: 

ğ‘ƒ[ğ‘† > ğœ‡(1 + ğœ€)] â‰¤ â¡ â„¯âˆ’2ğ‘šğœ€2/3 
ğ‘ƒ[ğ‘† < ğœ‡(1 âˆ’ ğœ€)] â‰¤ â¡ â„¯âˆ’2ğ‘šğœ€2/2 

Noisy Max Report  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
If we consider a simple algorithm where it determines which m counting queries has highest value, and then it 
adds generated Laplace Noise from Lap(1/ğœ–) to each count and return the index of the largest noisy count. We 
can ignore the possibilities of tie. This is called Noisy Max Report. 

Claim 

The Report Noisy Max algorithm is (ğœ–,0)-differentially private. 

Report One-Sided Noisy Arg-Max 

When  run  with  parameter  ğœ–/2ğ›¿ğ‘¢  yields  the  same  distribution  on  outputs  as  the  exponential 
mechanism. 

Randomized Response 
Itâ€™s a simple survey process where binary responses are considered i.e. the answers should be in â€˜yesâ€™ and â€˜noâ€™ 
only. The steps are following: 

â€¢  Toss a coin 
â€¢ 
â€¢ 

If the coin shows â€˜tailsâ€™, then give the â€˜trueâ€™ answer 
If the coin shows â€˜headsâ€™, then again toss it and give â€˜yesâ€™ if the result is â€˜headsâ€™ or â€˜noâ€™ if the result is 
â€˜tailsâ€™. 

For (ğœ–,Î´) differentially private mechanism, to find the value of ğœ–, we obtain:        

RR = 

ğ‘ƒ[ğ‘…ğ‘’ğ‘ ğ‘ğ‘œğ‘›ğ‘ ğ‘’=YES|ğ‘‡ğ‘Ÿğ‘¢ğ‘¡â„="ğ‘Œğ¸ğ‘†"]
ğ‘ƒ[ğ‘…ğ‘’ğ‘ ğ‘ğ‘œğ‘›ğ‘ ğ‘’="ğ‘Œğ¸ğ‘†"|ğ‘‡ğ‘Ÿğ‘¢ğ‘¡â„="ğ‘ğ‘‚"]

where, ğœ– = lnâ¡(ğ‘…ğ‘…). 

Claim 

Randomized Response Technique holds (,0) differential privacy where ğœ– = lnâ¡(3). For more analysis, 
remarks and corollary please refer to (Dwork et. al., 2014). 

Stirlingâ€™s Approximation 
ğ‘›
ğ‘›! Can be approximated by âˆš2ğœ‹ğ‘›(
ğ‘’

)ğ‘›. 

The Laplace Mechanism 
Given any function f: â„•|ğ’³| â†’ â„ğ‘˜, the Laplace mechanism is defined as: 

â„³ğ¿(ğ‘¥, ğ‘“(. ), ğœ–) = ğ‘“(ğ‘¥) + (ğ‘Œ1, ğ‘Œ2, â€¦ â€¦ , ğ‘Œğ‘˜) 

Where Yi ;i = 1:k, are i.i.d random variables drawn from Lap(âˆ†ğ‘“/ğœ–). 

Definitions and Theorems for the third step: 

Here we will discuss some useful definitions and background theorems that work for the third learning step of 
DP discussed in the useful background on differential privacy section in alphabetical order as instructed by the 
publisher (Dwork et. al., 2014). 

Theorems 

Accuracy  
We will say that an algorithm which outputs a stream of answers a1 , . . . , ğœ–(âŠº, âŠ¥)âˆ— in response to a stream of k 
queries  f1  ,...,  fk  is  (Î±,Î²)-accurate  with  respect  to  a  threshold  âŠ¥  if  except  with  probability  at  most  Î²,  the 
algorithm does not halt before fk , and  
âˆ€ai = âŠº: 

and, âˆ€ai = âŠ¥: 

fi(D) â‰¥ T âˆ’ Î±. 

 
 
 
 
 
 
 
 
 
fi(D) â‰¤ T + Î± 

Advanced Composition  
If ğ’œ1, â€¦ . , ğ’œğ‘˜are randomised algorithm satisfying (,Î´) differential privacy, then their composition, defined as 
ğ’œ1(ğ·), â€¦ â€¦ , ğ’œ1(ğ·), ğ‘“ğ‘œğ‘Ÿğ·ğœ–ğ’Ÿ satisfies (ğœ–â€², ğ‘˜ğ›¿ + ğ›¿â€²) differential privacy whereğœ–â€² = â¡ğœ–âˆš2ğ‘˜ğ‘™ğ‘œğ‘”(1/ğ›¿â€²) +
ğ‘˜ğœ–(exp(ğœ–) âˆ’ 1). Moreover ğ’œi can be chosen adaptivelydepending on the outputs of ğ’œ1, â€¦ . , ğ’œğ‘˜. 
Let, two distribution are given Âµ and ğœ‡â€², then we can say that they are (ğœ–, ğ›¿)- deferentially close, denoted by 
ğœ‡ â‰…(ğœ–,ğ›¿) ğœ‡â€², if for all measurable ğ’œ, we have 

expâ¡(âˆ’ğœ–)(ğœ‡â€²(ğ’œ âˆ’ ğ›¿)) â‰¤ ğ’œ â‰¤ expâ¡(ğœ–)(ğœ‡â€²(ğ’œ + ğ›¿)) 

Composition 
Let â„³ğ‘–: â„•|X| â†’ â„›ğ‘– be an (ğœ–ğ‘–, ğ›¿ğ‘–) differentially private algorithm for i ğœ– [k]. Then ifâ¡â„³[ğ‘˜] âˆ¶ â¡ â„•|ğ’³| â†’ âˆ â„›ğ‘–
defined 
ğ‘˜
(âˆ‘ ğœ–ğ‘–
ğ‘–=1

tobe  â„³[ğ‘˜](ğ‘¥)
ğ‘˜
, âˆ‘ ğ›¿ğ‘–
ğ‘–=1

ğ‘˜
ğ‘–=1
then  â„³[ğ‘˜](ğ‘¥)

 ,â€¦â€¦â€¦â€¦..., â„³ğ‘˜(ğ‘¥)

) âˆ’differentially private. 

( â„³1(ğ‘¥), â„³2(ğ‘¥)

), 

= 

 is 
is 

Corollary 1  
Let â„³ğ‘– : â„•|X|  â†’â„›i  be  an  (ğœ–ğ‘–, 0)  differentially  private  algorithm  for  i ğœ– [k].  Then  if â¡â„³[ğ‘˜] âˆ¶ â¡ â„•|ğ’³| â†’
ğ‘˜
âˆ â„›ğ‘–
 is  defined  to  be  â„³[ğ‘˜](ğ‘¥) =  ( â„³1(ğ‘¥), â„³2(ğ‘¥)  ,â€¦â€¦â€¦â€¦â€¦,  â„³ğ‘˜(ğ‘¥) ),  then  â„³[ğ‘˜](ğ‘¥) is 
ğ‘–=1
ğ‘˜
(âˆ‘ ğœ–ğ‘–
, 0) âˆ’ differentially private. 
ğ‘–=1

Properties of Differential Privacy 
The notion of (ğœ–,Î´)differential private satisfies the following properties: 

â€¢  Monotonicity:Let. ğœ‡ â‰…(ğœ–,ğ›¿) ğœ‡â€²Then forğœ–â€² > ğœ–andğ›¿â€² > ğ›¿, ğœ‡ â‰…(ğœ–â€²,ğ›¿â€²) ğœ‡â€². 
â€¢  Triangle Inequality : Let, ğœ‡1 â‰…(ğœ–1,ğ›¿1) ğœ‡2and  ğœ‡2 â‰…(ğœ–2,ğ›¿2) ğœ‡3, thenğœ‡1 â‰…(ğœ–1+ğœ–2,ğ›¿1+ğ›¿2) ğœ‡3 
â€²  and, ğœ‡2 â‰…(ğœ–,ğ›¿) ğœ‡2
â€¢  Quasi-Convexity:Let,ğœ‡1 â‰…(ğœ–,ğ›¿) ğœ‡1

â€²  then  for  any  a ğœ–  [0,1],  it  holds  that (1 âˆ’ ğ‘)ğœ‡1 +

ğ‘ğœ‡2â¡ â‰…(ğœ–,ğ›¿) (1 âˆ’ ğ‘)ğœ‡1

â€² + ğ‘ğœ‡2

â€² â¡. 

Lemma 1  
Let  ğ‘ <
thatğœ‡ â‰…(ğœ–â€²,ğ‘ğ›¿) ğœ‡0, whereğœ–â€² = logâ¡(ğ‘(ğ‘’ğœ– âˆ’ 1) + 1) â‰¤ ğ‘(ğ‘’ğœ– âˆ’ 1). 

1
2

 and  let  ğœ‡0 , ğœ‡1  be  distributions  such  that ğœ‡1 â‰…(ğœ–,ğ›¿) ğœ‡0 .  For  ğœ‡ = (1 âˆ’ ğ‘)ğœ‡0 + ğ‘ğœ‡1 ,  it  holds 

Max Divergence   
The Max Divergence between two random variables Y and Z taking values from the same domain is defined 
to be: 

ğ·âˆ(ğ‘Œ||ğ‘) = max

[ğ‘™ğ‘›

ğ‘†âŠ†sup(ğ‘Œ)

ğ‘ƒ[ğ‘Œâˆˆğ‘†]
ğ‘ƒ{ğ‘âˆˆğ‘†}

] 

The Î´-Approximate Max Divergence between Y and Z is defined to be: 

ğ›¿(ğ‘Œ||ğ‘) = â¡

ğ·âˆ

max
ğ‘†âŠ†sup(ğ‘Œ):ğ‘ƒ(ğ‘Œâˆˆğ‘†)â‰¥ğ›¿

[lnâ¡

ğ‘ƒ[ğ‘Œâˆˆğ‘†]âˆ’ğ›¿
ğ‘ƒ[ğ‘âˆˆğ‘†]

] 

Remark 1 
For a mechanism â„³, it is to be noted: 

â€¢  It will be  differentially private necessary and sufficiently for two neighbouring database ğ‘¥ and ğ‘¦, 

ğ·âˆ(â„³(ğ‘¥)||â„³(ğ‘¦)) â‰¤ ğœ–ğ‘ğ‘›ğ‘‘ğ·âˆ(â„³(ğ‘¦)||â„³(ğ‘¥)) â‰¤ ğœ–; and 

â€¢  It  will  be  ( ğœ– ,Î´)  private  necessary  and  sufficiently  for  two  neighbouring  data  set  ğ‘¥  and ğ‘¦ , 

ğ·âˆ

ğ›¿(â„³(ğ‘¥)||â„³(ğ‘¦)) â‰¤ ğœ–andğ·âˆ

ğ›¿(â„³(ğ‘¦)||â„³(ğ‘¥)) â‰¤ ğœ–. 

ğ‘™1-Sensitivity  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
The ğ‘™1 sensitivity of a function f : â„•|ğ’³| â†’ â„ğ‘˜, then:  âˆ†ğ‘“ = â¡

max

ğ‘¥,ğ‘¦âˆˆâ„•|ğ’³|,||ğ‘¥âˆ’ğ‘¦||
1

||ğ‘“(ğ‘¥) âˆ’ ğ‘“(ğ‘¦)||1 

=1

ğ‘™2-Sensitivity  
The ğ‘™2 sensitivity of a function f : â„•|ğ’³| then: âˆ†2= max
ğ‘¥,ğ‘¦âˆˆâ„•|ğ’³|

||ğ‘“(ğ‘¥) âˆ’ ğ‘“(ğ‘¦)||2. 

Utility  
How much information about the real answer can be obtained from the reported one by a specific model[18], 
is called the utility. How the utility works can be defined by the figure 2. 

 
 
 
 
 
 
 
 
 
 
 
 
 
