ForestFirewalls: Getting Firewall Conﬁguration
Right in Critical Networks (Technical Report)
Dinesha Ranathunga∗, Matthew Roughan∗, Paul Tune∗, Phil Kernick† and Nick Falkner‡
∗ACEMS, University of Adelaide, Australia
†CQR Consulting, Australia
‡School of Computer Science, University of Adelaide, Australia
Email: {dinesha.ranathunga, matthew.roughan, paul.tune, nick.falkner}@adelaide.edu.au
phil.kernick@cqr.com

9
1
0
2

b
e
F
5
1

]

R
C
.
s
c
[

1
v
9
8
6
5
0
.
2
0
9
1
:
v
i
X
r
a

Abstract—Firewall conﬁguration is critical, yet often conducted
manually with inevitable errors, leaving networks vulnerable to
cyber attack [40]. The impact of misconﬁgured ﬁrewalls can
be catastrophic in Supervisory Control and Data Acquisition
(SCADA) networks. These networks control the distributed assets
of
industrial systems such as power generation and water
distribution systems. Automation can make designing ﬁrewall
conﬁgurations less tedious and their deployment more reliable.
In this paper, we propose ForestFirewalls, a high-level ap-
proach to conﬁguring SCADA ﬁrewalls. Our goals are three-
fold. We aim to: ﬁrst, decouple implementation details from
security policy design by abstracting the former; second, simplify
policy design; and third, provide automated checks, pre and post-
deployment, to guarantee conﬁguration accuracy. We achieve
these goals by automating the implementation of a policy to a
network and by auto-validating each stage of the conﬁguration
process. We test our approach on a real SCADA network to
demonstrate its effectiveness.

Index Terms—ﬁrewall auto-conﬁguration, SCADA network
security, security policy, policy veriﬁcation, Zone-Conduit model.

I. INTRODUCTION
“The single most important factor of your ﬁrewall’s
security is how you conﬁgure it.”

Rubin and Greer [36]

Supervisory Control and Data Acquisition (SCADA) net-
works control the distributed assets of many industrial systems.
Power generation and water distribution are just two examples
that illustrate the critical nature of these networks. Others in-
clude factory automation, sewage management, airport control
systems and chemical plant control.

SCADA networks are not like corporate IT networks [38].
IT networks can accept a degree of reliability orders of
magnitude lower than the network controlling a power station.
A fault in the latter will cost serious money, if not lives.

At

the same time, SCADA networks often incorporate
highly vulnerable devices. The Programmable Logic Con-
trollers (PLCs) that control physical devices such as gas valves
have highly constrained memory and computational power.
Today, they often include network functionality such as a
TCP/IP stack, but exclude sophisticated security functionality.
Despite their name, PLCs are not user programmable. The
plant operator does not program them – that requires a pro-
gramming board that pushes low-level code into an EPROM.

The devices come pre-installed with code (and security holes).
There are many PLCs in a power station, along with similar
devices providing telemetry, and their upgrade is likely to
occur only during a major overhaul of a plant, which might
happen once in a decade (if that often).

These devices would be vulnerable if exposed to the Inter-
net, and a plant operator cannot ﬁx the vulnerabilities. Air gaps
have been proposed as a solution to protect these devices, but
an air gap is no longer a feasible approach for many reasons.
In fact, Byres calls the idea a myth [8] to emphasise how poor
a solution it is. The only viable protection today is a ﬁrewall,
or series of ﬁrewalls [9], [38].

As Rubin and Greer note [36], it is, therefore, vital that
these ﬁrewalls are conﬁgured correctly. Misconﬁguration of
SCADA ﬁrewalls can lead to security breaches, resulting in
signiﬁcant physical and environmental damage, ﬁnancial loss
or worse, the loss of human lives. A recent example is the
hacking of a German steel mill by cyber attackers in 2014
that destroyed its blast furnace [4].

Unfortunately, ﬁrewall conﬁguration, in practice, is a com-
plicated and repetitive manual task. It involves training in
proprietary and device-speciﬁc conﬁguration languages, and
long and complex device conﬁgurations. Lack of automation
tools to assist this task has resulted in unoptimised, error-prone
conﬁgurations [35], [40], [41].

The problem is exacerbated in SCADA plants where in-
dustrial engineers generally lack specialised networking and
security knowledge. Such knowledge is often brought
in
through third party contractors. These IT security specialists
are usually unfamiliar with the speciﬁc requirements of indus-
trial engineering, and are on-site only for brief periods.

A cost-effective alternative to training plant engineers to
become IT specialists is to build network operations tools
that derive ﬁrewall conﬁgurations from high-level policy. Ap-
proaches using SDN have been proposed [25], [37], but they
remain a distant reality for SCADA networks, where TCP
is still a recent innovation. And power plants are insecure
now [35]! SCADA networks need a solution that works now,
using off-the-shelf technology. In this paper, we propose such
a solution: ForestFirewalls.

Our system provides a mechanism for speciﬁcation of
security policy at a level a non-IT specialist could understand.
What’s more, it forces good designs on its users through

1

 
 
 
 
 
 
principles derived from the study of real SCADA ﬁrewall
conﬁgurations [35] and International Society for Automation
(ISA) best practices [2], [7], [38]. Most notably:
• Single source of truth: more speciﬁcally, “Security man-
agers need a single place to look for the corporate policies
on who gets in and who doesn’t.” [20]. This general
principle in computer science [5] applies doubly here.
• Simplify: we don’t try to provide every possible security
feature. At best, advanced features create confusion, and at
worst, bad implementations can create security ﬂaws.
• Verify everything again and again: there is a clear danger
in assuming any one piece of software functions correctly,
from the ﬁrewall up to and including our own system. We
check the conﬁguration works at every level possible.
• No implicit rules: implicit rules allow unexpected inter-
actions, and undesirable consequences [35]. Desired ﬂows
must be explicitly allowed.
• Rule order should not matter: it should be possible to add,
or subtract a policy rule without considering its effect on
every other rule. Surprisingly, none of the existing ﬁrewall
conﬁguration platforms [11], [13], [14], [23] achieved this.
Operators using these tools, must provide correct rules and
maintain correct rule order to avoid adverse interactions.
• Separate structure from function [30]: decoupling
network topology (i.e., structure) from policy speciﬁcation
(i.e., function) facilitates high-level requirements based poli-
cies without network-centric minutiae like IP addresses.
• Convenience: security and convenience are usually at odds,
but wherever possible convenience should be provided. This
is not a luxury – lack of convenience is one of the main
reasons operators circumvent their own security.
Our system comprises a suite of tools to write policy,
validate, test conﬁgurations, and create real conﬁgurations, and
is designed to be user extensible.

We demonstrate it with a real example, derived from the ac-
tual (but anonymised) ﬁrewall conﬁgurations of a real SCADA
plant. The example is intentionally small for clarity, but it
shows a core set of functionality. The example includes several
zones, two ﬁrewalls, and multiple real services much as they
would run in the real network. Our testbed uses two different
ﬁrewalls: one Cisco and one Linux-based, in order to show
both the device independent nature of our policy language,
and that heterogeneous network devices can be conﬁgured in
the same network. The network offers multiple services: DNS,
HTTP, ... etc., and we use test trafﬁc on the network to show
correct function.

The proof of the pudding is that we can specify this net-
work’s policy in only 80 Lines of Code (LoC), to generate the
equivalent of 2720 device-level LoC found in a real SCADA
case study [35]. This order of magnitude reduction, along with
rigorous validation, shows the value of ForestFirewalls.

II. RELATED WORK
A useful ﬁrewall conﬁguration platform should allow poli-
cies to be speciﬁed abstractly, ﬂexibly enough and in detail.
There are many products and security management tools with

varying levels of sophistication introduced by ﬁrewall vendors
[11], [13], [14], [23], but policies still cannot be speciﬁed using
high-level requirements.

For example, Cisco introduced security levels for quick and
easy access between internal and external ﬁrewall interfaces
[13], but
these cannot specify detailed trafﬁc restrictions.
Hence, Access Control Lists (ACLs) are required to supple-
ment these levels. Security levels may also not map to clear se-
curity policies. This hinders ﬁrewall auto-conﬁguration, which
needs clear policies [5] to permit trafﬁc.

High-level security polices need to be based on security
abstractions. The choice of the abstraction determines the
level of decoupling between network topology and security
policy. For one, Firmato [3] uses a role-based abstraction in its
network grouping language that is independent of the ﬁrewalls
and routers used in the network. But, the abstraction does not
intuitively map policy to topology and requires minutiae like
IP addresses to be input through the policy speciﬁcation, to
implement policy on a network instance.

For another, Cisco has introduced security policy manage-
ment tools (e.g., VNMC for VSG policy management) to cater
for complexities introduced in network virtualisation [15]. For
scalability, the tools allow operating systems (i.e., VMs) to be
allocated to zones and policies to be deﬁned per zone. But,
each VM still needs to be deﬁned using minutiae like host-
names. ForestFirewalls decouples policy from topology using
a more intuitive Zone-Conduit abstraction. The direct zone-
to-network mapping allows policy to exclude IP addresses or
hostnames as input.

The ability to debug conﬁguration errors is also a highly
desirable feature in a ﬁrewall conﬁguration platform. But, this
debugging should support abstract queries, free of network
centric minutiae. Fang [29] and Lumeta [39] are interactive
tools that facilitate ﬁrewall rule debugging, but the queries
they support use network-centric minutiae as input.

Also desirable would be if

the conﬁguration platform
supported more general-purpose abstract queries like service
reachability and trafﬁc isolation queries. Network program-
ming languages supporting such queries have been proposed
(e.g., NetKAT [1]), but they too, rely on minutiae as input;
and are not speciﬁcally aimed at conﬁguring ﬁrewalls.

Ability to create and correctly compose distributed poli-
cies is also necessary in a ﬁrewall conﬁguration platform.
Doing so, allows users from multiple policy sub-domains
(e.g., SCADA engineers, Corporate admins) to manage their
own policies. Policy Graph Abstraction (PGA) [32] provides
such a framework for SDN networks, Cloud infrastructure and
Network Functions Virtualisation (NFV) environments. It can
automatically compose distributed policies into a coherent,
conﬂict-free policy set. But, PGA leaves out how logs, alerts
and alarms (i.e., reports) should be enabled in security-critical
middle boxes like ﬁrewalls. These reports are critical to detect
misconﬁgurations and network security setup failures. Our
solution allows reports to be encapsulated with security policy
via a framework designed by us.

Additionally, it is essential in SCADA networks to have
assurance of expected conﬁguration behaviour prior to de-
ployment, since downtime must be minimised. SANE [10]

2

proposes a central Domain Controller with trusted privileges to
reduce end-host initiated attacks in corporate networks. It sup-
ports topology-independent high-level declarative policies but
provides no pre-deployment guarantee of correct conﬁguration
behaviour. ForestFirewalls uses simple automated emulations
to achieve this goal.

Most related works do not propose a high-level descrip-
tion that intuitively decouples policy from topology. In some
cases [3], topology needs to be explicitly mapped to policy
through the speciﬁcation per host/subnet basis. There is also
no automated pre- and post-deployment veriﬁcation of poli-
cies. Moreover, none of the above works examine SCADA
networks, with unique security requirements and best practices
compared to Corporate networks.

The prior work also does not address a key practical issue-
complexity. Firewall vendors have concentrated on new and
impressive features to create systems with as much or more
complexity as the base ﬁrewall conﬁgurations.

Our research tackles this problem head-on. Our solution,
ForestFirewalls, uses security abstractions to drastically reduce
ﬁrewall policy speciﬁcation complexity. These abstractions
decouple policy from topology intuitively, so ﬁrewall policies
can be described using high-level requirements independent
of vendor and network intricacies. Automated veriﬁcation
is also built-in to our system to mitigate misconﬁgurations.
ForestFirewalls also provides a formalism to compose rule
sets into a coherent, conﬂict-free policy set. These features
collectively, make ﬁrewall conﬁguration a commodity skill
rather than a specialisation, so business managers and plant
engineers alike can manage their SCADA ﬁrewalls.

III. REQUIREMENTS

Bush and Bellovin [5] identiﬁed the following core require-

ments of an automated security conﬁguration system:
• Clear policies: an automated system cannot resolve be-
tween a plausible and a correct policy [5]. For example,
between allowing HTTP access to a publicly shared Web
server or to a sensitive internal Web server. So the policy
must be clearly understood by a Manager.
• Database driven: all device conﬁgurations and their
changes must be recorded in a single reference point [5],
which allows fast response to security incidents as well as
accurate security audits.
• Meta-conﬁgurations: speciﬁcations or instructions
about real conﬁgurations need to be obtained by abstraction
and parameterisation.

However, there are extra issues not described by [5]. For one,
there is an assumption that the auto-conﬁguration system gen-
erating the conﬁgurations is correct. But proof of correctness
must stem from validation, as we describe next.

A. Policy veriﬁcation

SCADA operators need assurance that the device conﬁgu-
rations generated produce the expected security outcome, both
pre- and post-deployment. We use multiple veriﬁcation stages
(1) to provide this assurance.

Fig. 1: Policy veriﬁcation tiers.

Upper veriﬁcation tier: it is important initially to check a
speciﬁed ﬁrewall policy against available industry best prac-
tices [9], [38]. These automated compliancy tests are critical in
SCADA networks where more restrictive practices are required
to minimise their vulnerability to threats from less secure
networks (e.g., the Internet). Best practice violations can be
accurately identiﬁed by conducting equivalence and inclusion
checks on the canonicalised policies. See VII.

Complex ﬁrewall policies also produce unintended conse-
quences through rule overlaps [27], [42]. So it is additionally
necessary to check policies from high-level through ﬁrewall-
level for inconsistencies. We do so accurately, using a mathe-
matical and logic based formal tool: Alloy [21].

Middle veriﬁcation tier: the second stage helps debug conﬁgu-
ration problems prior to deployment. Network emulation offers
a cost effective method to test conﬁgurations before actual
deployment [24]. The Netkit open source software package
[31] provides such an emulation platform with virtual devices
and interconnections via User Mode Linux (UML). Automated
pathological trafﬁc tests, together with Netkit emulations, can
verify that the generated conﬁgurations produce the expected
outcome prior to deployment.

Lower veriﬁcation tier: the ﬁnal stage guarantees that the real
ﬁrewalls operate as intended, post deployment. The automated
tests are extended from emulations to the real network, to gen-
erate live-trafﬁc and reveal unexpected conﬁguration behaviour
in the real ﬁrewalls.

Automated veriﬁcation can drastically reduce the number of
ﬁrewall misconﬁgurations. It can be used to identify best-
practice violations and adverse policy interactions, and pre-
vent those from propagating to the physical ﬁrewalls. Most
importantly, it provides users with a guarantee of the security
outcome prior to implementation.

B. Firewall reporting

A second issue not described by [5], but key to autoconﬁg-
uration, is the need to be able to constantly examine the status
of security provided by the ﬁrewalls in a network. We discuss
this brieﬂy here to keep within the scope of this paper – see
[33] for an extended discussion.

Firewall security status can be monitored using the diverse
logs, alerts and alarms available. We refer to these together
as ﬁrewall reports. These reports are critical in identifying
ﬁrewall misconﬁgurations and detecting failures in the net-
work security setup. But, the industry standards available for
reporting and analysing ﬁrewall data are scant and vague. So,

3

we developed a ﬁrewall reporting framework [33] considering
the granularity and scope requirements of the various reporting
use cases.

We learnt key lessons, in developing this reporting frame-
work. For one, a ﬁrewall is a poor source of data in some
reporting use cases (e.g., accounting) [33], although they are
often used in this way. In those cases, it is better to report
elsewhere in the network and release a ﬁrewall’s resources for
its primary function: trafﬁc ﬁltering. Where ﬁrewall reporting
must be enabled, it needs to be at the correct granularity.
Employing an inferior granularity prevents collecting sufﬁ-
cient data to satisfy use-case requirements, using an overly-ﬁne
granularity simply wastes resources.

Additionally, security policy and reporting policy need to
be encapsulated (i.e., coupled) together [33]. Decoupling the
two can lead to bad decisions, for instance, it would allow
adding security policies that are not veriﬁed.

C. Decouple policy from network

A third issue not described by [5], but key to autocon-
ﬁguration, is the need to decouple policy from the network
implementation.

In practice, network architects and business managers de-
cide what
type of services are allowed through ﬁrewalls.
Network engineers then implement these policies. Intuitively,
separation of the network intricacies from policy speciﬁcation
better suits these distinct phases. Conceptually this is analo-
gous to the separation of architects and building contractors in
construction. Contractors don’t usually decide what roof shape
a building should have.

Network topology can change often in response to new
business needs, upgrades and service demands. This may alter
the devices and administratively assigned parameters such as
IP addresses and hostnames in the network.

Comparatively, security policies are static. These policies
commonly only involve dozens of distinct services [35], so
policy complexity is relatively low to that of the network. This
relative simplicity and invariant nature leads to decoupling
policy from the network. The adage “Structure and function
should be independent” [30] truly applies here.
Decoupling structure from function, has these advantages:
• Policy is speciﬁable via high-level, vendor neutral1 re-
quirements: which assists management-level policy makers
not ﬂuent in network-centric details.
• It centralises policy management and promotes reuse:
a single topology-independent organisation policy (i.e.,
source of truth) can be maintained across sites.
• It streamlines network changes and upgrades: the policy
can be quickly re-mapped to a new topology, retaining
previous levels of protection.
• It simpliﬁes best-practice enforcement: best practice stan-
dards can be precisely speciﬁed in absence of proprietary
details of speciﬁc networks.

Security abstractions are key to decoupling policy from the
underlying network.

1Vendor platform and device independent requirements.

IV. SECURITY ABSTRACTIONS
A good high-level security abstraction captures the under-
lying network security concepts naturally and concisely. For
one, in real networks, we might group systems with a similar
set of trafﬁc services enabled. For another, trafﬁc restrictions
between two systems may be enforced by a single or a series
of ﬁrewalls. A good abstraction should decouple what
is
restricted between systems from how it is restricted.

The American National Standards Institute (ANSI)/ ISA
introduce the Zone-Conduit abstraction to segment and isolate
the Zone-
the sub-systems in a control system [2]. But,
Conduit model in its original speciﬁcation is too ﬂexible for
automation. To increase its precision, we needed to add several
extensions [35]. We describe our modiﬁed version here.

A. Our modiﬁcations to the ISA model

The Zone-Conduit model is a graph G = (Z, C) where Z

is the set of zones, and C ⊂ Z × Z is the set of conduits.

A zone is a logical or physical grouping of an organisation’s
systems with similar security requirements, based on criticality
and consequence [2]. By grouping systems in this manner,
a single zone-policy can be deﬁned for all members of a
zone. For example, 3 disjoint security zones can be deﬁned
to accommodate low, medium and high-risk systems, with
each device assigned to its respective zone, based on their
security level needed. A low-risk system can be accommodated
within a medium or high security zone without compromising
security, but not vice versa.

A conduit provides the secure communication path between
two zones, enforcing the policy between them [2]. Security
mitigation mechanisms (e.g., ﬁrewalls) are implemented within
a conduit. A conduit could consist of multiple links and
ﬁrewalls, but logically is a single connector. Conduits abstract
how a policy is enforced, so we can focus on what needs to
be enforced.

We conducted real SCADA ﬁrewall conﬁguration case stud-
ies [35] and found that the ISA Zone-Conduit model in its
original speciﬁcation is too ﬂexible for automation. For one,
the ISA model allows alternate ways of deﬁning zones and
conduits to cater for business models. It loosely permits 1:n
or n:1 mapping between conduits, ﬁrewalls and policy.

We reﬁne the model through several extensions [35]. First,
we enforce a 1:1 mapping between policies and conduits.
Second, dedicated Firewall-Zones are used to capture ﬁrewall
management policies. Third, Abstract-Zones are used to cap-
ture the distinct policy requirements of serial ﬁrewalls. Carrier-
Zones are also used to abstract any carrier based transit outside
of an administrative domain’s control.

The ISA standard also loosely allows sub-zones to be
deﬁned, enabling multiple policies within a zone. Doing so,
implies that selected subsystems in a zone (e.g., a server) could
have their own separate policies. Allowing exceptions would
impart a false sense of security: these systems are only as
secure as the zone itself, in the absence of ﬁrewalls enforcing
a real separation. We tighten the speciﬁcation further in our
approach by strictly enforcing a single zone-policy.

A single zone-policy leads to every device within a zone
having the same set of permissions to initiate, accept or block

4

one or more services. Hence, a zone is the smallest unit of
abstraction for which a policy can be applied to and we do
so simply and unambiguously using inter-zone ﬂows.

Once extended, the best practice produces a tight speciﬁcation
suitable for auto-conﬁguration. We can now begin to formally
deﬁne ﬁrewall security policies based on this reﬁned Zone-
Conduit model.

B. Policy on a single conduit

A conduit policy in the reﬁned Zone-Conduit model can
be constructed from an ordered set of rules [p1, p2, ..., pn]
that act on packet sequences to accept, deny, or in some
cases, modify them. Particularly, a policy rule p1 operates
on A = {atomic packet sequences}, where an atomic
packet sequence is a complete packet sequence that cannot be
decomposed into smaller subsequences (except themselves and
the null sequence- φ). Complete means that a decision on two
concatenated complete subsequences is the same as that on the
joint sequence, i.e., p1(s1+s2) = p1(s1)+p1(s2),∀s1, s2 ∈ A,
where + is an associative concatenation operator. A is closed
under + and φ is the identity. So, A is a monoid and policy
rules p(·) are monoid endomorphisms on A (i.e., mappings
from A to itself that preserve the semigroup structure of the
operator + and identity φ).

Typical policy rules accept/deny packets, i.e., for A ∈ A

pA(s) =

(cid:40)

s,
φ,

if s ∈ A, // accept
if s ∈ Ac, // deny.

(1)

This type of rule doesn’t allow modiﬁcation or creation of
packets. Real ﬁrewall rules can modify or create packets. For
instance a ﬁrewall might
• update certain header ﬁelds related to QoS; or
• might defragment, or fragment packets; or
• be integrated with Network Address Translation (NAT) or
Virtual Private Network (VPN) functionality.
The scope for packet modiﬁcation is huge, but within a
ﬁrewall, many modiﬁcations don’t change ﬁelds that would
affect further rules in subsequent ﬁrewalls, e.g., QoS or TTL
changes. In order to have a tractable problem, we restrict the
ﬁrewall rules to such modiﬁcations, and thus consider all rules
to be in the form given in 1.

We also cannot construct a policy rule for any possible
subset of A, due to the limitations of technology used in a
ﬁrewall. The subsets of A for which rules can be deﬁned is
actually a sigma algebra σ(A) [6].

The particular sigma algebra will be generated by the ﬁnest
possible partition of A determined by the ﬁrewall technology
used. So for a given ﬁrewall technology, A can be broken into
sets Ai ⊂ A such that Ai ∩ Aj = {} and ∪iAi = A, and we
can implement rules pAi, but cannot deﬁne any rule pB where
B is a strict subset of some Ai.

Firewall rules in practice however, are implemented by
specifying a predicate and an action. A ﬁrewall enforces
actions based on predicate matching, and ﬁrewall policies
found in practice are built using multiple policy rules [35].

C. Positive, explicit policies

A ﬁrewall policy in practice,

is made up of multiple
predicate matching rules that can be combined using several
strategies: ﬁrst match, last match or all match. If we presume
here the conservative security option: an implicit deny- all
rule in place, then an accept rule qa
m (where m is the predicate)
deﬁnes accept packet set A = {s ∈ A | s ≺ m}, where s ≺ m
denotes s matches m. A single deny rule qd
m has no affect,
i.e., A = {}.

When we combine two (ordered) rules (qt

) where
t ∈ {a, d}, we deﬁne operators based on the matching order:

, qt

m1

m2

1) ﬁrst match

qt
m1

(cid:11) qt

m2

=

2) last match

qt
m1

(cid:9) qt

m2

=











,
,

if s ≺ m1
if s ≺ m2 and s (cid:54)≺ m1

qt
m1
qt
m2
deny, otherwise,

,
,

if s ≺ m2
if s ≺ m1 and s (cid:54)≺ m2

qt
m2
qt
m1
deny, otherwise.

Clearly the operations (cid:11) and (cid:9) are associative, e.g., (q1 (cid:11)
q2) (cid:11) q3 = q1 (cid:11) (q2 (cid:11) q3), but not commutative or equivalent.
This is a problem. We need a policy to hold the same
semantics regardless of how the rules are ordered, in order
to simplify policy speciﬁcation.

So, we restrict ourselves to accept rules, conditional

on an implicit deny-all rule. This restriction
• is rich enough to represent all rules [34] and
• the operators are then commutative and equivalent [34].
Equivalent results also hold if we only allow deny rules, but
this option is less secure as it is easier to accidentally leave
something out of a deny list than to include it.

Therefore, we adopt a security whitelisting model, i.e., we
restrict inter-zone ﬂows to express positive abilities2 and deny
all ﬂows that are not explicitly allowed. Doing so, renders
the rule order irrelevant in a policy. A policy now holds the
same semantics, irrespective of how its rules are organised.
Hence, policy makers need not consider the order when adding
or removing policy rules. By being explicit, we also prevent
services being accidentally enabled implicitly.

We can use the conduit-policy deﬁnition to also check for
equivalence as well as inclusion of policies [34]. In VII we will
demonstrate how doing enables evaluation of actual ﬁrewall
policies against industry best practices for violations.

So far, we considered policy rules on a single conduit. We now
generalise these policies to a network, or rather the simpliﬁed
Zone-Conduit model of the network.

D. Network policy

For policy space Φ = {p

: A → A |
p is a monoid endomorphism}, we can deﬁne a network pol-
icy as

2Refers to the ability to initiate or accept a trafﬁc service.

5

Deﬁnition 1 (Network Policy). A network policy P = (G, P )
means a Zone-Conduit graph G(Z, C) with policy functions
pij ∈ Φ for (i, j) ∈ C.

When comparing network policies,

to
partition the policies on the networks (e.g., pij in Deﬁnition
1) into equivalence classes [34]. We refer to these partitions
as Semantic Partitions (SPs) as they have the same meaning.

is also useful

it

E. Isolation of trafﬁc

An important element in architecting a network’s security is
the proper isolation of trafﬁc between zones, i.e., it is necessary
to guarantee the privacy and integrity of a host’s data while
eliminating unwanted trafﬁc (malicious or not) between hosts,
that can hinder a network’s performance.

A common method of providing this guarantees is to con-
struct modular policies using network slices [19]. A network
slice is a piece of the network that can be programmed
independently from the rest of the network. If we restrict trafﬁc
to a network slice, the behaviour of the entire security policy
is precisely that of that slice alone. So, regardless of how
complex a network’s policy may be, we need consider only
the policy of the slice corresponding to trafﬁc ﬂow between
two zones, to ensure proper trafﬁc isolation between them.

In our revised Zone-Conduit model, a conduit provides this
network-slice behaviour. A conduit policy does not modify
packets intended for another, so to ensure trafﬁc isolation
between two zones, we simply need to consider the policy
of the conduit connecting those zones. For example, in the
policy below, trafﬁc ﬂow from Z1 to Z2 is strictly controlled
by the policy of conduit (Z1,Z2).

Policy Company_policy { Z1 -> Z2 : https, dns;

Z2 -> Z3 : http, ftp, dns;}

So, users from multiple policy subdomains (e.g., corporate
admins, SCADA engineers) can simply manage the policies
of the conduits that corresponds to their subdomain, and have
guarantee of trafﬁc isolation.

V. SYSTEM OVERVIEW

We now describe our auto-conﬁguration system design as

depicted in 2, with the details outlined below:
High-level security policy: The topology-independent policy
input ﬁle created using ForestFirewalls. See VI for details.
Compile to intermediate-level (IL) policy: Parses the high-
level policy to an intermediate format for checking.
Network topology: The input network topology described in
the XML-based graph ﬁle format GraphML [18]. The ﬁle
contains information of all devices of the underlying network
and their interconnections. The crucial aspects are the details
of the topology near the ﬁrewalls.
policy: Down-
Generate network-level,
compiles high-level policy to network-level, by coupling pol-
icy to the input network topology. See V-A.
Verify IL policy against best-practices, via Alloy: Formally
checks an IL policy for SCADA best-practice violations and
for correctness. Best-practice checks employ canonicalised

vendor-neutral

Fig. 2: Firewall auto-conﬁguration process.

policies while a mathematical and logic based tool, Alloy [21],
ﬁnds anomalies within the policy. See V-B.
Verify network-level policy via Alloy: Formally checks
network-level policy for correctness via Alloy [21]. See V-B.
Device templates: A vendor and device speciﬁc meta-
conﬁgurations repository that currently supports UML IP-
Tables, Cisco ASA5505 models, and is easily extensible.
Generate device-level
conﬁgurations: The rendering of
device-speciﬁc conﬁgurations for ﬁrewalls using the network-
level policy and the device templates.
Verify via emulations: Device conﬁgurations are pushed to an
emulated network for pre-deployment testing. Test scripts are
auto-executed in this network, to generate pathological trafﬁc
and validate conﬁgurations. See V-C.
Real network: Device-speciﬁc conﬁgurations are pushed to
hardware in a real network. At present
this is conducted
manually3, but we intend to automate it.
Verify via real trafﬁc tests: Automated tests are created for the
real-network, generating real-trafﬁc, to verify post-deployment
behaviour of ﬁrewall conﬁgurations. See V-C.

A. Network-level policy generation

A high-level policy is implemented on a network by
coupling the policy to the network topology instance. The
resultant network-level ACL rules are vendor/device neutral.
This generic format allows easy checking of rules for incon-
sistencies. The policy generation steps are outlined below.

3Automation of pushing device conﬁgurations is more development than

research.

6

1) Zone-Conduit model construction: The system ﬁrst
builds a Zone-Firewall model, containing the disjoint zones
interconnections [35] using the network
and their ﬁrewall
topology. Additional Firewall-Zones, Abstract-Zones and
Carrier-Zones are added to the model as required.

Next, the network conduits are deﬁned to create the Zone-
Conduit model. The Zone-Conduit model of the input network
may not always match that perceived by the policy creator.
So, we must cross check the real model against that provided
through the speciﬁcation. If mismatched, an error is reported
indicating incompatibility.

2) Network coupling and rule translation: An implicit
mapping between a zone and its host/subnet composition
is created when deﬁning the zones in the input network.
This mapping readily translates the high-level policy to the
underlying network. The source and destination zone of each
high-level rule can be substituted with the corresponding IP
address ranges from this mapping. The equivalent network
ACL rules can be obtained from the cross product of these
IP address ranges and the original rule operator and service
description. We can represent rule translation through a map-
ping t : Φ → Γ, where Φ is the high-level policy space and Γ
is the network-level policy space.

Multicast rules may also be required for the correct opera-
tion of certain protocols. For instance, when OSPF is speciﬁed
as a dynamic routing protocol by the user, multicast rules
are required to enable neighbour relationships to correctly
form within a single OSPF area. Similarly, stateful protocols
(e.g., TCP) require return path rules in addition to the forward
path rules for correct operation. ForestFirewalls handles these
requirements automatically, generating and incorporating any
supplementary rules as necessary.

3) Path selection and conduit conﬁguration: The system
identiﬁes possible Zone-Conduit communication paths for
each high-level policy rule. Paths that are deemed imprac-
tical are eliminated. For instance, (i) trafﬁc cannot transit a
Firewall-Zone. Firewall-Zones only enable trafﬁc ﬂow to and
from the ﬁrewall but cannot forward trafﬁc, (ii) a trafﬁc path
cannot form loops around ﬁrewalls. If a path requires a trafﬁc
packet to traverse a particular ﬁrewall interface more than
once, it is discarded, (iii) trafﬁc originating from or terminating
at a Firewall-Zone must have a valid external path through the
network.

Our system conﬁgures all conduits, using valid paths. A
conduit implements a default deny-all policy between its
interconnecting zones. This strategy promotes defence in depth
[2], [9], which prevents a single point of failure from triggering
cascading security breaches across the network.

The system evaluates each conduit’s ﬁrewall-interface lay-
out to determine how the Access Control List (ACL) rules
should be applied on these interfaces (inbound or outbound).
Our high-level policy is easily adapted to incorporate new
zone additions to a network. The updated policy is swiftly
re-implemented on the network to protect the new zones.

B. Formal policy veriﬁcation

Policy-rule overlaps can cause unintended consequences.
These overlaps can be redundancies or conﬂicts [27], [42].

Redundant rules can be removed without affecting the seman-
tics of a policy. Such rules reﬂect conﬁguration inefﬁciencies.
A conﬂict occurs when a rule overlaps with preceding rules
but speciﬁes a different action, creating ambiguity. Correct
ordering of rules is typically required to avoid rule conﬂicts.
Our system only supports positive permissions. So, we
remove conﬂicts by design, rendering rule order irrelevant.
Redundancies are still possible, so we need to check for these.
We ﬁnd redundancies using a model checker: Alloy [21].
Formal model-checking is generally complex, so Alloy aims
to ﬁnd counter-examples to illustrate problems. Essentially it’s
a refuter [21] not a prover. But, its ability to comprehensively
analyse a model, even within ﬁnite bounds, makes it very
useful [21]. For Alloy based veriﬁcation, see VII.

A policy also needs to be checked for SCADA best prac-
tice compliance. Checking policies by exhaustive comparison
would be highly inefﬁcient. A more efﬁcient approach would
be to derive a unique, canonical, representation of each policy.
Policy canonicalisation can be represented through a mapping
c : Φ → Θ, where Θ is the canonical space of policies.
Inclusion and equivalence checks on the canonical policies,
help identify any violations. For details, see VII.

C. Automated testing

We use a network emulator – Netkit – for our pre-deploy-
ment tests. The emulator is open source and enables virtual
devices and interconnections using UML [31]. AutoNetkit is a
tool designed to automate emulated network experimentation
via Netkit [24]. We have extended AutoNetkit, with basic
ﬁrewall capabilities, to generate our emulations.

When the emulated network is run, automated tests speciﬁc
to the input policy create pathological trafﬁc to verify expected
ﬁrewall conﬁguration behaviour. ForestFirewalls uses Expect
– a UNIX scripting and testing utility – to generate these test-
scripts. Expect enables automated interactions with programs
that expose a text terminal interface [26]. Netkit automatically
launches these scripts within its Virtual Machines (VMs),
once the VMs are running. The scripts run sequentially, with
independent outcomes.

Expect test scripts verify that the permits rules in a policy
works correctly (i.e., positive vetting). A permit rule fails if
its observed behaviour is different from that expected. We can
use a result function R, to track what rules fail. For a permit
rule qa
m with accept packet set A = {s ∈ A | s ≺ m} and a
test-packet sequence s1 ∈ A the result function is

R(qa

m, s1) =

(cid:40)

0,
1,

if s1 fails for permit rule qa
m
if s1 succeeds for permit rule qa
m.

(2)

A failed permit rule means its corresponding test packets

are not delivered to the intended destination.

In addition to positive vetting, we need to check that all
other services not explicitly enabled are blocked. This negative
vetting is conducted using automated, exhaustive port-scans
employing nmap and tshark.

The same test-suite can be used in the real network, post
conﬁguration deployment. The tests now generate live-trafﬁc,
verifying expected real-ﬁrewall behaviour.

7

VI. POLICY SPECIFICATION FRAMEWORK

A useful network policy speciﬁcation framework should
cater for management-level policy makers as well as com-
petent programmers. Policy makers need to deﬁne high-level
policies to meet business goals. Programmers may wish to ex-
tend the framework to add more features. A layered approach
(3) supports both cases.

A. A layered approach

Fig. 3: Policy speciﬁcation in layers.

Policy deﬁnition high-level language: designed primarily for
non-expert users to deﬁne services and security policies, it
uses a library of services and security policies in conjunction
with a simple language. The service library consists of Internet
Assigned Numbers Authority (IANA) well-known services
and the policy library contains common SCADA security poli-
cies, all easily extensible by a non-expert user. The language
syntax and semantics are also intuitively simple for non-expert
users. Informative warnings and errors are returned for fast
debugging. See VI-B.
Class library layer: dedicated to expert Programmers, this
layer features an Object Oriented Programming (OOP) based,
well-deﬁned object hierarchy that consists of rules for con-
structing protocols (e.g., TCP, UDP) and services. Detailed
checking of object speciﬁc attributes (e.g., TCP/UDP port
numbers are between 0-65535) are handled by their respective
classes. A direct mapping between the grammar rules and
the Classes makes the library easily extensible, but it is only
intended that expert protocol engineers would extend this.
Most operators would use the higher layer.
High-level
language grammar: dedicated to the language
designers, this layer consists of Backus-Naur Form (BNF)
rules that control the language semantics. The grammar in-
cludes basic checking (e.g., argument length, null checks), but
delegates detailed checking to the class library layer. The rules
are static and can only be altered by the language designers
(us). This preserves the original objectives of a high-level
abstraction that is intended to change slowly.
Our layered policy-speciﬁcation architecture leads to a vendor
and device neutral policy-speciﬁcation framework. The system
suits naive users, but the framework is easily extensible to cater
for new network applications and protocols.

B. ForestFirewalls high-level language

Simply put, the ForestFirewalls speciﬁcation language al-
lows a user to instantiate a high-level ﬁrewall policy. Below
is the deﬁnition (a complete example can be found in VIII).

ForestFirewalls’ parser is currently implemented in Python
and Ply (a lex and yacc implementation for Python). It
translates a ForestFirewalls speciﬁcation (i.e., a .policyml
ﬁle) into its Intermediate Language (IL) representation using
object deﬁnitions from the underlying class library, also im-
plemented in Python.

1) Service and Service-group description: A service is

deﬁned using the syntax

service <service-name> {

protocol=<protocol-base>;

<protocol-attributes-list>; }

For example, a custom implementation of HTTP, based on

the above service description format is given by

service custom_http {protocol=tcp;

tcp.dest_port=8080;
comment=‘‘Internal Web’’;}

All unspeciﬁed attribute values have defaults assigned (e.g.,
here tcp.source_port=0-65535). Service speciﬁc com-
ments are enabled via the comment ﬁeld. This type of code
documentation allows commentary in the lower tiers to be
auto-generated. The aim is to help document network and
device level ﬁrewall rules to avoid the common problem that
rules cannot be deleted because no one remembers why they
exist.

ForestFirewalls prohibits the description of generic services
such as all-TCP or all-IP for several reasons. For one, SCADA
case studies [35] reveal that users exploit generic rules where
possible for convenience, such as allowing all-IP trafﬁc just
to enable EIGRP trafﬁc. However, far more services than
necessary are thus admitted through ﬁrewalls.

Secondly, such inherently broad services don’t contribute
towards forming well-deﬁned security policies. They cloud the
ability to accurately see the type of cyber threats a network is
being protected from.
service
formally
can
(P r, P rA, P rV ) where P r

by
A
=
tuple
{all IP protocol numbers} and P rA ⊂ Υ, P rV ⊂ Π;
Υ = {tcp/udp/icmp etc. protocol attributes} and
Π = {protocol attribute values}.

represented
Λ; Λ

be

∈

We use a service-group to bundle services and other

service-groups (i.e., nesting is allowed)

service_group <group-name>{

<service-or-group-list>}

A service-group is

Service-groups provide a level of indirection, so application
protocols used to achieve network functionality (e.g., Web
services) can change without needing policy alterations.
set SG

=
{(P ri, P rAi, P rVi) |P ri ∈ Λ, P rAi ⊂ Υ P rVi ⊂ Π}.
set operations: union (,),
The
intersection (ˆ) and difference (\), so, new service groups
can be constructed by applying these operators on existing
service groups.

speciﬁcation supports

really

a

The following snippet deﬁnes a service-group contain-

ing various example Web services:

service_group Web { http, https, dns }

8

2) Zone-group description: A zone-group bundles a set
of zones or other zone-groups and is deﬁned using the syntax

zone_group <group-name> {<zone-or-group-list>}

A zone-group is a as a set of disjoint zones ZG ⊂ Ω
where Ω = {all zones}. Multiple zone-group declarations are
checked for duplicates to minimise code redundancy.

The snippet below describes an example zone-group, de-
picting three_zones: a set of zones in a network which is
made up of 3 disjoint zones.

zone_group three_zones {corp, scada, dmz}

promotes reuse of policy. For instance, we can imagine the ISA
creating a best practice ruleset for SCADA as a baseline for
new installations.

Non-expert programmers may, however, be unfamiliar with
the use of a complex namespace library with many features.
We developed a namespace hierarchy that
is simple, yet
provides rich features for managing and reusing namespaces.
ForestFirewalls’ namespace hierarchy consists of generic li-
brary deﬁnitions for all users with additional support for cus-
tom namespace creation. This allows to compose distributed
policies into a coherent policy set, free of inconsistencies.

We also allow similar syntax and set operators for deﬁning

VII. VERIFICATION

groups of TCP/UDP ports or ICMP types.

3) Policy-rule description: A high-level policy rule
can be deﬁned as below with an operator to di-
the inter-zone ﬂow explicitly. The end-zones deﬁned
rect
by zone-or-group-name have trafﬁc ﬂow of
type
service-or-group-name enabled.

policy_rule <rule-name> {

<first-zone-or-group-name> operator
<second-zone-or-group-name> :
<service-or-group-name> }

where operator == ‘->’ or ‘<->’

For example, the following policy rule models the capabil-
ities of a Corp_ orate_zone with regards to Web trafﬁc

policy_rule corp_web_rule {

Corp_zone -> DMZ : Web}

The above description can be represented as a policy rule qa
m
with accept packet set A = {s ∈ A | s ≺ m} where predicate
m = (s.hdr.source address in Corp zone ∧ s.hdr.dest
address in DM Z ∧ s.hdr.service == W eb).

4) Policy description: A rule_group object is used to
hold one or more security policy rules and can be deﬁned
using the following format

rule_group security_policy {

<rule1>, <rule2>, ... }

A security policy is a set of rules RS = {qa
mi

; mi −
predicate}, each rule has an accept packet set A = {s ∈
A | s ≺ mi}.

Similarly, we can specify ﬁrewall reporting policy using a

reporting _rule object [34]

reporting_rule reporting_policy {

<attributes-list>}

A global policy object then encapsulates security policy

with reporting policy [34]

policy <policy-name> { security_policy;

reporting_policy; }

5) ForestFirewalls library ﬁle imports: In large industrial
control plants, multiple policy sub-domains exist (e.g., corpo-
rate admins, SCADA engineers, network engineers, different
departments) that set
their own policies to be applied to
the network components they own or manage. Namespace
importation facilitates such distributed policy management and

Once a high-level policy is parsed by ForestFirewalls, it is
stored in IL code and needs to be checked for SCADA best-
practice violations as well as for correctness.

A. Best-practice compliance

Two policies with different rule sets, can have the same
underlying semantics (i.e., they allow the same set of services
between zones). 4(a) and 4(b) illustrate the idea based on TCP
port ﬁltering of single packets. Each rectangle indicates the
allowed packets of a single rule. Combined, the rules cover
the same set of allowed packets.

Comparing policies exhaustively is highly inefﬁcient. So,
we derive a unique, canonical, representation of each policy
to efﬁciently compare them. In our canonicalisation mapping
c : Φ → Θ, where Θ is the canonical space of policies, all
equivalent policies of Φ map to a singleton. For pX , pY ∈ Φ,
we note the following (the proof follows the deﬁnition)

Lemma 2. Policies pX ≡ pY iff c(pX ) = c(pY ).

Thus, comparison is eased by the canonicalisation of poli-
cies. We illustrate the idea using TCP policy rules (4) and
dissect the polygon formed in our example policy into hor-
izontal partitions (Figure 4(c)), using a Rectilinear-Polygon
to Rectangle conversion algorithm [17]. Each partition is
chosen to provably guarantee its uniqueness. Canonical policy
elements are derived by translating each partition back to a
rule and ordering the resulting rule-set uniquely in increasing
IP protocol number and source and destination port numbers.
We ﬁnd a unique partition quickly rather than a guaranteed
minimal partition. The result is a deterministic, ordered set of
non-overlapping rules.

So, intra-policy veriﬁcation can be performed by comparing

canonical policy components. For instance
Is c(pZ1→Z2) = c(pSCADA→Corp) ?

Another useful notation, linked to the goal of policy com-
parison, is that policy P A includes policy P B. Particularly
in SCADA networks, the notation helps evaluate whether the
policies are compliant with industry-recommended practices
in [9], [38]. These guidelines specify potentially dangerous
services (e.g., HTTP) that should be prohibited from traversing
inbound and/or outbound from the (protected) SCADA-Zone.
A violation here, means increasing the vulnerability of a
SCADA-Zone to cyber attack. Unlike corporate networks, this
increased exposure could potentially render SCADA systems

9

(a) Four rules indicated by (overlapping) rectangles.

(b) Five rules producing an equivalent policy to (a).

(c) Horizontal partitions of polygon in (a) or (b).

Fig. 4: Canonicalisation of distinct rule sets of the same policy.

unavailable, and cause signiﬁcant ﬁnancial loss or at worse
loss of human lives.

network-level policy. So, we re-check the generated policy for
overlaps and verify the fact.

We indicate that a policy complies with another if it is more

restrictive and deﬁne the following

Deﬁnition 3 (Inclusion). A policy pX is included in pY on A
iff pX (s) ∈ {pY (s), φ}, i.e., X either has the same effect as
Y on s, or denies s, for all s ∈ A. We denote inclusion by
pX ⊂ pY .

So, we can now evaluate whether an input policy adheres
to the SCADA best practice policy using an inclusion check

Is pInput ⊂ pBestP ractice ?

B. Policy correctness

A partial snippet of the Alloy language speciﬁcation (i.e.,
.als) ﬁle auto-generated by ForestFirewalls for the IL pol-
icy is shown in Figure 8 in the Appendix. It depicts a
formal model with 3 signatures: Service, PolicyRule
and SecurityPolicy. In our initial model, a Service
has the basic members: ip_protocol, source_port,
dest_port and icmp_type. Of these members, only
ip_protocol is mandatory.

A PolicyRule has 4 members: zone1 and zone2 to
capture the zone names, an operator and a single service
element. The global constraints are partially shown (lines
17–27 in Figure 8), requiring the universal set (Univ) of
PolicyRule to comprise entirely of rules in the policy. Univ
of Service must also comprise of PolicyRule services.
Predicates can determine if two given rules or services
overlap (not shown). Service overlaps are found by com-
puting their intersection and testing if the result has members.
String type members (e.g., zone1, zone2) can be directly
compared. PolicyRule overlaps are checked similarly.

A ‘no rule overlaps’ assertion (also not shown) is used
to locate distinct rules with overlapping criteria. If found,
a counter-example is returned, indicating potential inconsis-
tencies in the high-level policy. Counter-examples can be
inspected through Alloy’s GUI to ﬁnd the underlying cause(s).
Currently, Alloy is itself run manually and output counter-
examples help debug data. We do not auto-correct rules as this
requires human discretion.

When overlaps are absent in the high-level policy, there
should also be none in network-level policy, in theory. But we
cannot simply ‘trust’ our system to always correctly generate

The Alloy export generated for network policy veriﬁcation
is similar to the high-level export. The key exception is the
source and destination zone names are now replaced with IP
address ranges in an ACLRule. Additionally, the Service
signature also has members depicting protocol state. We also
deﬁne an assertion here to check for ACLRule overlaps.

VIII. A CONCRETE EXAMPLE

We show here a concrete example, illustrating our method-
ology and the prototype system. The example is based on an
actual SCADA case study [35] with the multi-ﬁrewall network
conﬁguration shown in 5. Due to security concerns and non-
disclosure agreements, a modiﬁed version of the real network
is presented for discussion. Steps have been taken to keep the
core security strategies intact, but details such as IP addresses
are anonymised.

Fig. 5: The SCADA network under study. Corp and SCADA
are the corporate and SCADA subnets while the ﬁrewalls are
R1, R2 and GW.

R1 is a Cisco ASA 5505 ﬁrewall and R2 and GW are Linux
IPtables ﬁrewalls. 5 shows these best already. The subnet
summary is below.

The Corporate network (Corp): Provides access to business
applications and the Internet.

Demilitarised Zone (DMZ): Responsible for enabling con-
nectivity between R1 and R2. The distinct vendor ﬁrewalls
provide defence in depth [9] by having different modes of
failure and ﬁrewall-software redundancy.

The SCADA network (SCADA): Responsible for providing
networked access to plant equipment.

10

Corp and SCADA could accommodate 2,046 and 65,534 hosts
respectively. Corp hosts management workstations, a HTTP
server, a HTTPS server, a FTP server, an Email server, a
syslog server and a DNS server. SCADA has Oracle database
servers, management workstations and a HTTPS server.

A. Policy goals

We consider a simple policy which nonetheless covers many
of the aspects that occur in more complex, real-life SCADA
policies [35]. Its premise is that internal corporate users are
trusted, but are restricted to use safe protocols when accessing
SCADA. External users are allowed access only to content that
is explicitly made public. The policy has these goals:
• Corp hosts can access the Oracle servers and the
HTTPS server in SCADA. They can also access all HTTP,
HTTPS, DNS resources on the Internet.
• SCADA hosts can access Web, Email and DNS servers on
Corp. Additionally, they can perform ﬁle transfer using
FTP and HTTP with respective Corp servers.
• Corp’s HTTP, FTP, Email servers are Internet accessible.
• R1, R2 can be managed from Corp using HTTPS and
SSH. R2 can be managed from SCADA using SSH. R1 can
also be managed from R2 using SSH.
• A Syslog server located in Corp stores ﬁrewall logs.
• OSPF is enabled across the entire site.
• Firewall reporting is enabled for policy veriﬁcation.

B. Implementation

A partial snippet of the ForestFirewalls high-level descrip-
tion implementing the above policy goals is depicted in Figure
10 in the Appendix. We start by importing the required library
ﬁles containing the predeﬁned lists of IANA well known
services. Next, the Zone-Conduit security model is supplied as
a GraphML ﬁle. The zones within this model can be grouped
as necessary (lines 9-15), to simplify the speciﬁcation process
and increase readability. We also deﬁne custom port-groups,
services and service-groups as needed.

A passive mode FTP data service is enabled through the
ﬁrewalls (lines 18–20) as it’s the best-practice approach [9],
[38]. Ping is also deﬁned for connectivity tests. High-level
rules are deﬁned to match the policy goals listed earlier. Finally
a policy object is used to hold all the rules (line 48).

C. Procedure and Results

Once the high-level policy is parsed,

the corresponding
Alloy export is generated by ForestFirewalls for veriﬁcation.
Checking the ‘no rule overlaps’ assertion (not shown) returns
a counter-example, indicating potential inconsistencies in the
speciﬁcation. Upon inspection of the counter-example details
in Alloy (6), we see that rules enabling HTTP services
(ip_protocol=6, dest_port=80) between zones Z3
and Z1,
initiate the overlap. The root cause is the web
and file_transfer service-groups in the high-level policy
(lines 22 and 25 in Figure 10), both containing HTTP. Once

Fig. 6: Counter-example thrown by Alloy, indicating a high-
level policy error.

this is rectiﬁed (remove HTTP from file_transfer), no
further counter-examples are found by Alloy.

Figure 9 in the Appendix shows the ACL-allocation map
for R1, indicating how ACLs are assigned to the ﬁrewall’s
interfaces.

Figure 11 in the Appendix partially shows the generated
vendor-neutral ACL rules. Note the explicit deny all rule
supplementing the explicit permit rules at the end. The step
also outputs the Zone-Firewall and Zone-Conduit models of
the input network as graphical output (7).

The network-level Alloy exports have 828 Service,
ACLRule objects. Assertion checks here yield no counter-
examples.

The device-speciﬁc conﬁgurations are rendered from the
network-level policy, using vendor and device speciﬁc Mako
templates. Mako is a template library written in Python [28],
enabling fast and easy integration into ForestFirewalls.

The device-level conﬁgurations generated were ﬁrst auto-
deployed to a Netkit-based emulated network. Once the Netkit
Virtual Machine (VM)s booted up, the test scripts were run au-
tomatically. The emulation results conﬁrmed that the ﬁrewalls
correctly admitted the services explicitly enabled through the
high-level policy. Moreover, automated exhaustive port-scans
using nmap and tshark showed that no additional services were
permitted through the ﬁrewalls.

Post emulation testing, the device conﬁgurations were de-
ployed to the real-network. Although we aim to automate this
deployment, it is currently done manually as its not seen as
an error-prone step in modern conﬁguration tools [13], [14].
Once deployed, we re-executed the emulation test scripts on
hosts in the various zones of the network. The tests conﬁrmed
that the services enabled by the input policy were passing
across ﬁrewalls as expected, and port scans conﬁrmed no
additional services were allowed through.

11

(a) Zone-Firewall model.

(b) Zone-Conduit model of (a).

Fig. 7: System generated security models of the network.

TABLE I: High-level comparison of Original vs Generated conﬁgurations (LoC - Lines of Code).

Type

Original case study
ForestFirewalls generated

Device-level
LoC
2720
714

Obsolete-ACL
count
2
0

Generic permit-
rule count
324
0

Intra-ACL
interaction count
167
0

D. Cyber attack mitigation

We have studied ﬁrewall conﬁgurations from 7 real SCADA
networks to date [35] (including the network discussed), and
found the following serious cyber-security vulnerabilities:
• Insecure protocols enabled through explicit generic rules:
all-TCP, all-UDP and all-IP trafﬁc ﬂow were explicitly
enabled inbound to SCADA, permitting far more services
than necessary. Inherently unsafe protocols such as FTP and
HTTP were thus allowed into SCADA. HTTP for instance,
is known to transport worms and attacks. These generic
rules signiﬁcantly increased the vulnerability of a SCADA-
Zone to cyber attack.
• Insecure protocols enabled through implicit rules: incor-
rect use of implicit rules such as Cisco security levels
[13] enabled all-IP trafﬁc to ﬂow between Corporate and
SCADA zones, making the latter more prone to cyber attack.
• Direct communication enabled between the SCADA-Zone
and the Internet: allowing so, clearly violated industry best-
practices and signiﬁcantly elevated the risk of a cyber attack
on the SCADA-Zone.
• Insecure protocols enabled through explicit and implicit-
rule interactions: in some cases, insecure protocols (e.g.,
HTTP) were explicitly disallowed inbound to the SCADA-
Zone, but were then implicitly enabled into the same zone,
exposing the latter to cyber attack.
ForestFirewalls addresses each of the above cyber security
vulnerabilities comprehensively. A comparison of the ﬁrewall
conﬁgurations observed in the case study discussed and those
those generated by ForestFirewalls are shown in I. It shows
that there are no explicit generic permit rules generated by our
system (i.e., all-TCP, all-UDP or all-IP based rules). Eliminat-
ing these rules prohibits unwanted services from being enabled
implicitly between zones. Additionally, ForestFirewalls only
utilises explicit rules to enable both ﬁrewall management and
non-management trafﬁc. So, the use of implicit rules such as
Cisco security levels are removed altogether. Doing so, also

prevents interactions between explicit and implicit rules, so,
one cannot override the other to accidentally enable services.
Also shown in I, there are no redundant ACLs generated by
ForestFirewalls. Each ACL serves a purpose and is assigned to
an active ﬁrewall interface. There are also no intra-ACL rule
interactions in the ACLs generated, making these conﬁgura-
tions comparatively more efﬁcient.

Our system also formally checks a security policy against
industry best practices for compliance. Any violations are
ﬂagged for the user to resolve and policy compilation stops
until the issues are rectiﬁed. The step prevents direct commu-
nication between SCADA and the Internet being enabled.

These are almost obvious consequences of our design
approach but the real ﬁrewalls [35] had all of these defects.
Our system only requires 80 high-level LoC (only 41 LoC are
policy speciﬁc) to generate 714 device-level LoC to conﬁgure
all 3 ﬁrewalls in the case study discussed. This high-level
policy with only 80 LoC has replaced 2720 attack and error
prone, inefﬁcient, device-level LoC of the original case study!
In fact for all 7 real SCADA networks we studied, it was
possible to replace their total 7694 ﬁrewall-level LoC with
only 271 high-level ForestFirewalls LoC.

IX. CONCLUSIONS AND FUTURE WORK

The current manual approach to ﬁrewall conﬁguration is
complex and error prone. Various ﬁrewall vendor tools attempt
to facilitate high-level conﬁguration, but these lack ﬂexibility
in specifying detailed trafﬁc restrictions and do not reduce the
conﬁguration burden.

ForestFirewalls greatly reduces the conﬁguration burden,
and by use of high-level abstraction, templates and graphs,
offers a simple and manageable approach to SCADA ﬁre-
wall conﬁguration. Our system guarantees conﬁguration accu-
racy through stage-wise validations employing SCADA best-
practices, a formal veriﬁcation tool (Alloy), and emulation
based pre-deployment tests. The system gives users assurance
of the generated device-level conﬁgurations delivering the

12

expected ﬁrewall behaviour prior to deployment. The ability to
conﬁgure a group of ﬁrewalls at once makes ForestFirewalls
scale at lower cost.

REFERENCES

[1] C. J. Anderson, N. Foster, A. Guha, J.-B. Jeannin, D. Kozen,
C. Schlesinger, and D. Walker. Netkat: Semantic foundations for
In Symposium on Principles of Programming Languages,
networks.
pages 113–126. ACM, 2014.

[2] ANSI/ISA-62443-1-1. Security for industrial automation and control

systems part 1-1: Terminology, concepts, and models, 2007.

[3] Y. Bartal, A. Mayer, K. Nissim, and A. Wool. Firmato: A novel ﬁrewall
management toolkit. In IEEE Symposium on Security and Privacy, pages
17–31, 1999.

[4] BBC. Hack attack causes ‘massive damage’ at steel works, http://www.

bbc.com/news/technology-30575104.

[5] S. Bellovin and R. Bush. Conﬁguration management and security. IEEE
Journal on Selected Areas in Communications, 27(3):268–274, 2009.
[6] P. Billingsley. Probability and measure. John Wiley and Sons, New York,

1995.

[7] E. Byres. Using ANSI/ISA-99 standards to improve control system

security. White paper, Toﬁno Security, May 2012.

[8] E. Byres. The air gap: SCADA’s enduring security myth. Communica-

tions of the ACM, 56(8):29–31, 2013.

[31] M. Pizzonia and M. Rimondini. Netkit: Easy emulation of complex
In TRIDENTCOM, pages 1–10.

networks on inexpensive hardware.
ICST, 2008.

[32] C. Prakash, J. Lee, Y. Turner, J.-M. Kang, A. Akella, S. Banerjee,
C. Clark, Y. Ma, P. Sharma, and Y. Zhang. PGA: Using graphs to express
and automatically reconcile network policies. In ACM SIGCOMM, pages
29–42. ACM, 2015.

[33] D. Ranathunga, M. Roughan, P. Kernick, and N. Falkner. Towards
In Security of Industrial Control
standardising ﬁrewall reporting.
Systems and Cyber Physical Systems, pages 127–143. Springer, 2015.
[34] D. Ranathunga, M. Roughan, P. Kernick, and N. Falkner. Malachite:
Firewall policy comparison. In Computers and Communication (ISCC),
2016 IEEE Symposium on, pages 310–317. IEEE, 2016.

[35] D. Ranathunga, M. Roughan, H. Nguyen, P. Kernick, and N. Falkner.
Case studies of scada ﬁrewall conﬁgurations and the implications for
best practices. IEEE Transactions on Network and Service Management,
13(4):871–884, 2016.

[36] A. D. Rubin and D. E. Geer. A survey of Web security. IEEE Computer,

31(9):34–41, 1998.

[37] R. Soul´e, S. Basu, P. J. Marandi, F. Pedone, R. Kleinberg, E. G. Sirer,
and N. Foster. Merlin: A language for provisioning network resources.
In ACM CoNEXT, pages 213–226. ACM, 2014.

[38] K. Stouffer, J. Falco, and K. Scarfone. Guide to Industrial Control
Systems (ICS) security. NIST Special Publication, 800(82):16–16, 2008.
[39] A. Wool. Architecting the Lumeta ﬁrewall analyzer. In USENIX Security

[9] E. Byres, J. Karsch, and J. Carter. NISCC good practice guide on ﬁrewall

Symposium, pages 85–97, 2001.

deployment for SCADA and process control networks. NISCC, 2005.

[40] A. Wool. A quantitative study of ﬁrewall conﬁguration errors.

IEEE

[10] M. Casado, T. Garﬁnkel, A. Akella, M. J. Freedman, D. Boneh,
N. McKeown, and S. Shenker. SANE: A protection architecture for
enterprise networks. In Usenix Security, 2006.

[11] Check Point. NGX R65 CC Evaluated Conﬁguration User Guide. Check

Point software technologies Ltd., USA, 2008.

[12] W. R. Cheswick, S. M. Bellovin, and A. D. Rubin. Firewalls and Internet

security: Repelling the wily hacker. Addison-Wesley, 2003.

[13] Cisco Systems. Cisco ASA 5500 Series Conﬁguration Guide using the
CLI. Cisco Systems Inc., 170 West Tasman Drive, San Jose, CA 95134-
1706, USA, 2010.

[14] Cisco Systems. Cisco ASA 5585-X adaptive security appliance archi-

tecture. White paper, Cisco Systems, May 2014.

[15] Cisco Systems. Cisco Virtual Security Gateway for Nexus 1000V Series
Switch Conﬁguration Guide. Cisco Systems Inc., 170 West Tasman
Drive, San Jose, CA 95134-1706, USA, 2014.

[16] N. Foster, R. Harrison, M. J. Freedman, C. Monsanto, J. Rexford,
A. Story, and D. Walker. Frenetic: A network programming language.
In ACM ICFP, pages 279–291. ACM, 2011.

[17] K. D. Gourley and D. M. Green. Polygon-to-rectangle conversion
IEEE Computer Graphics and Applications., 3(1):31–32,

algorithm.
1983.

[18] Graph Steering Committee. GraphML, 2003.
[19] S. Gutz, A. Story, C. Schlesinger, and N. Foster. Splendid isolation:
In HotSDN, pages

A slice abstraction for software-deﬁned networks.
79–84. ACM, 2012.

[20] C. D. Howe. What’s Beyond Firewalls? Forrester Research, Incorpo-

rated, 1996.

[21] D. Jackson. Software Abstractions: Logic, Language, and Analysis. The

MIT Press, 2011.

[22] R. Jamieson, L. Land, S. Smith, G. Stephens, and D. Winchester.
infrastructure information security: Impacts of identity and

Critical
related crimes. In PACIS, 2009.

[23] Juniper Networks. Firewall Filter and Policer Conﬁguration Guide.
Juniper Networks, Inc., 1194 North Mathilda Avenue, Sunnyvale, Cali-
fornia 94089, USA, 2011.

[24] S. Knight, H. Nguyen, O. Maennel, I. Phillips, N. Falkner, R. Bush, and
M. Roughan. An automated system for emulated network experimenta-
tion. In ACM CoNEXT, pages 235–246. ACM, 2013.

[25] D. Levin, M. Canini, S. Schmid, and A. Feldmann. Panopticon: Reaping
the beneﬁts of partial SDN deployment in enterprise networks. TU
Berlin/T-Labs, Technical Report, 2013.

[26] D. Libes.

Exploring Expect: A Tcl-based toolkit

for automating

interactive programs. O’Reilly, 1995.

[27] A. X. Liu. Formal veriﬁcation of ﬁrewall policies. In IEEE International

Conference on Communications, pages 1494–1498, 2008.

[28] Mako. Mako templates for Python, http://www.makotemplates.org/.
[29] A. Mayer, A. Wool, and E. Ziskind. Fang: A ﬁrewall analysis engine.

In IEEE Symposium on Security and Privacy, pages 177–187, 2000.

[30] J. Pearce. Programming and Meta-Programming in Scheme. Springer,

1998.

13

Computer, 37(6):62–67, 2004.

[41] A. Wool. Trends in ﬁrewall conﬁguration errors: Measuring the holes
in Swiss cheese. IEEE Internet Computing, 14(4):58–65, 2010.
[42] L. Yuan, H. Chen, J. Mai, C.-N. Chuah, Z. Su, and P. Mohapatra.
In IEEE

FIREMAN: A toolkit for ﬁrewall modeling and analysis.
Symposium on Security and Privacy, pages 15–213, 2006.

APPENDIX

Fig. 8: High-level policy veriﬁcation framework using Alloy
(partially shown)

abstract sig Service {

ip_protocol: some Int,
source_port: set String,
dest_port: set String,
icmp_type: set Int }

abstract sig PolicyRule {
zone1: one String,
zone2: one String,
operator: some Int,
service: one Service }

// Policy definition
one sig SecurityPolicy { rules: some PolicyRule }

// List of global constraints
fact {

// All defined rules are in the policy to check
all r: PolicyRule | r in SecurityPolicy.rules

// Policy rules make up universe of PolicyRule
SecurityPolicy.rules = PolicyRule

// A service belongs to at least one PolicyRule
all s: Service | some r: PolicyRule | s in r.service}

Fig. 9: ForestFirewalls policy description (partially shown).

// library files
import system.services.iana_services;
import system.services.iana_icmp;

// zone−conduit security topology
load_zone_conduit_model ‘‘zone_conduit.graphml’’

// define zone groups
zone_group all_zones {z1,z2,z3,az1,fwz1,fwz2,fwz3}
zone_group scada_zone { z3 }
zone_group corp_zone { z1 }
zone_group internet_zone { z2 }
zone_group all_firewall_zones { fwz1, fwz2, fwz3 }
zone_group all_internal_zones { all_zones \ internet_zone }

// passive mode FTP using custom port numbers
port_group ftp_data_ports { 24500−24600 }
service ftp_data { protocol=tcp; tcp.dest_port=ftp_data_ports; }

// service groups using standard port numbers
service_group ftp { iana_services.ftp_control, ftp_data }
service_group web { iana_services.http, iana_services.https }
service_group ping { iana_icmp.icmp_echo, iana_icmp.icmp_echo_reply }
service_group dns { iana_services.dns_tcp, iana_services.dns_udp }
service_group file_transfer { iana_services.http, ftp }

// define security policy
policy_rule file_transfer_rule { scada_zone −> corp_zone : file_transfer }

policy_rule ping_rule { corp_zone <−> scada_zone : ping }

policy_rule dns_rule { scada_zone −> corp_zone : dns }

policy_rule web_rule { scada_zone −> corp_zone : web }

rule_group security_policy { file_transfer_rule, ping_rule, dns_rule, web_rule }

// enable policy verification reporting in firewalls
reporting_rule verify_rules{ use_case=verification;
granularity.network={zone_or_group={all_zones}};
granularity.policy={rule_or_group={security_policy}};
granularity.traffic={measurement={counter};
counter_type={connection};};
granularity.temporal={per_hour};
granularity.performance={process};}

// define global policy
policy company_policy { security_policy; verify_rules}

Fig. 10: System generated network-level policy (partially shown, comments are denoted by remark).

INFO Vendor neutral network-level ruleset for ACL: acl_2

remark˜enable corp_zone to scada_zone HTTPS traffic (return path)
permit˜tcp˜from˜10.0.0.16/29˜to˜10.0.0.0/29˜sport˜[443]˜dport˜[‘0-65535’]˜state˜ESTABLISHED˜log
permit˜tcp˜from˜10.0.0.16/29˜to˜10.0.128.4/30˜sport˜[443]˜dport˜[‘0-65535’]˜state˜ESTABLISHED˜log
remark˜enable scada_zone to corp_zone WEB traffic (forward path)
permit˜tcp˜from˜10.0.0.16/29˜to˜10.0.0.0/29˜sport˜[‘0-65535’]˜dport˜[443]˜state˜NEW,ESTABLISHED˜log
permit˜tcp˜from˜10.0.0.16/29˜to˜10.0.128.4/30˜sport˜[‘0-65535’]˜dport˜[80]˜state˜NEW,ESTABLISHED˜log
deny˜ip˜from˜any˜to˜any˜sport˜˜dport˜˜state˜

14

