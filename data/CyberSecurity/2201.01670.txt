2
2
0
2

n
a
J

5

]
L
F
.
s
c
[

1
v
0
7
6
1
0
.
1
0
2
2
:
v
i
X
r
a

Finite-Word Hyperlanguages

Borzoo Bonakdarpoura, Sarai Sheinvaldb

aDepartment of Computer Science and Engineering, Michigan State University, USA
bDepartment of Software Engineering, ORT Braude College, Israel

Abstract

Formal languages are in the core of models of computation and their behavior. A
rich family of models for many classes of languages have been widely studied. Hyper-
properties lift conventional trace-based languages from a set of execution traces to a
set of sets of executions. Hyperproperties have been shown to be a powerful formalism
for expressing and reasoning about information-ï¬‚ow security policies and important
properties of cyber-physical systems. Although there is an extensive body of work on
formal-language representation of trace properties, we currently lack such a general
characterization for hyperproperties.

We introduce hyperlanguages over ï¬nite words and models for expressing them.
Essentially, these models express multiple words by using assignments to quantiï¬ed
word variables. Relying on the standard models for regular languages, we propose
hyperregular expressions and ï¬nite-word hyperautomata (NFH), for modeling the class
of regular hyperlanguages. We demonstrate the ability of regular hyperlanguages to
express hyperproperties for ï¬nite traces. We explore the closure properties and the
complexity of the fundamental decision problems such as nonemptiness, universality,
membership, and containment for various fragments of NFH.

1. Introduction

Formal languages, along with the models that express them, are in the core of
modeling, speciï¬cation, and veriï¬cation of computing systems. Execution traces are
formally described as words, and various families of automata are used for modeling
systems of different types. Regular languages are a classic formalism for ï¬nite traces
and when the traces are inï¬nite, Ï‰-regular languages are used.

There are well-known connections between speciï¬cation logics and formal lan-
guages. For example, LTL [33] formulas can be translated to Ï‰-regular expressions,
and CTLâˆ— [17] formulas can be expressed using tree automata. Accordingly, many ver-
iï¬cation techniques that exploit these relations have been developed. For instance, in
the automata-theoretic approach to veriï¬cation [36, 37], the model-checking problem

Email addresses: borzoo@msu.edu (Borzoo Bonakdarpour), sarai@braude.ac.il (Sarai

Sheinvald)

Preprint submitted to Elsevier

 
 
 
 
 
 
is reduced to checking the nonemptiness of the product automaton of the model and
the complement of the speciï¬cation.

Hyperproperties [14] generalize the traditional trace properties [4] to system prop-
erties, i.e., a set of sets of traces. A hyperproperty prescribes how the system should
behave in its entirety and not just based on its individual executions. Hyperproperties
have been shown to be a powerful tool for expressing and reasoning about information-
ï¬‚ow security policies [14] and important properties of cyber-physical systems [38] such
as sensitivity and robustness, as well as consistency conditions in distributed comput-
ing such as linearizability [9]. While different types of logics have been suggested
for expressing hyperproperties, their formal-language counterparts and the models that
express them are currently missing.

In this paper, we establish a formal-language theoretical framework for hyperlan-
guages, that are sets of sets of words, which we term hyperwords. Our framework is
based on an underlying standard automata model for formal languages, augmented with
quantiï¬ed word variables that are assigned words from a set of words in the hyperlan-
guage. This formalism is in line with logics for hyperproperties (e.g., HyperLTL [13]
and HyperPCTL [2, 1]). These logics express the behavior of inï¬nite trace systems.
However, a basic formal model for expressing general hyperproperties for ï¬nite words
has not been deï¬ned yet.

To begin with the basics, we focus this paper on a regular type of hyperlanguages
of sets consisting of ï¬nite words, which we call regular hyperlanguages. The models
we introduce and study are based on the standard models for regular languages, namely
regular expressions and ï¬nite-word automata.

1.1. Motivation and Applications

Hyperlanguages based on ï¬nite words have many practical applications. Let us ï¬rst

explain the idea of hyperlanguages with two examples.

Example 1. Consider the following hyperregular expression (HRE) over the alphabet
{a}.

r1 = âˆ€x.âˆƒy.

(cid:16)

(cid:124)

{ax, ay}âˆ—{#x, ay}âˆ—(cid:17)
(cid:123)(cid:122)
(cid:125)
Ë†r1

The HRE r1 uses two word variables x and y, which are assigned words from a hy-
perword. The HRE r1 contains an underlying regular expression Ë†r1, whose alphabet
is ({a} âˆª {#}){x,y}, and whose (regular) language describes different word assign-
ments to x and y, where # is used for padding at the end if the words assigned to
x and y are of different lengths. In a word in the language of Ë†r1, the iâ€™th letter de-
scribes both iâ€™th letters in the words assigned to x and y. For example, the word
{ax, ay}{ax, ay}{#x, ay} describes the assignment x (cid:55)â†’ aa, y (cid:55)â†’ aaa. The regular
expression Ë†r1 requires that the word assigned to y be longer than the word assigned
to x. The quantiï¬cation condition âˆ€x.âˆƒy of r1 requires that for every word in a hy-
perword S in the hyperlanguage of r1, there exists a longer word in S. This holds iff
S contains inï¬nitely many words. Therefore, the hyperlanguage of r1 is the set of all
inï¬nite hyperwords over {a}.

2

Example 2. Path planning objectives for robotic systems often stipulate the existence
of one or more ï¬nite paths that stand out from all other paths. For example, robotics
applications are often concerned with ï¬nding the shortest path that reaches a goal g,
starting from an initial location i. The shortest path requirement can be expressed by
the following HRE over an alphabet Î£:

r2 = âˆƒx.âˆ€y.{ix, iy}{Â¯gx, Â¯gy}âˆ—(cid:16)

{gx, Â¯gy} | {gx, gy}

(cid:17)

{#x, $y}âˆ—

where Â¯g âˆˆ Î£ âˆ’ {g} and $ âˆˆ Î£. That is, there exists a path x that is shorter than any
other path y in reaching g.

Another interesting application in robotics is in adversarial settings, where some
robots may interfere (e.g., act as moving obstacles) with a set of controllable robots.
In this scenario, given any behavior of the adversarial robots, the controllable robots
should be able to achieve their operation objectives. This speciï¬cation is in general of
the following form:

r3 = âˆ€x1.âˆ€x2 . . . âˆ€xn
(cid:125)

(cid:124)

(cid:123)(cid:122)
advarsaries

. âˆƒy1.âˆƒy2 . . . âˆƒym
(cid:123)(cid:122)
(cid:125)
(cid:124)
controllable

.Ë†r

where words x1 Â· Â· Â· xn express the behavior of the adversaries, words y1 Â· Â· Â· ym de-
scribe the behavior of the controllable robots and regular expression Ë†r speciï¬es the
control objectives.

1.2. Contributions

Although there is an ongoing line of research on model-checking hyperproper-
ties [27, 5, 15], the work on ï¬nite-trace hyperproperties is limited to [18], where the
authors construct a ï¬nite-word representation for the class of regular k-safety hyper-
properties. We make the following contributions:

â€¢ Introduce regular hyperlanguages and HREs, and demonstrate the ability of HREs
to express important information-ï¬‚ow security policies such as different varia-
tions of noninterference [29] and observational determinism [39].

â€¢ Present nondeterministic ï¬nite-word hyperautomata (NFH), an automata-based

model for expressing regular hyperlanguages.

â€¢ Conduct a comprehensive study of the properties of regular hyperlanguages (see

Table 1):

â€“ We show that regular hyperlanguages are closed under union, intersection,

and complementation.

â€“ We consider the nonemptiness problem for NFH:

* We prove that the nonemptiness problem is in general undecidable for

NFH.

* However, for the alternation-free fragments (which only allow one
type of quantiï¬er), as well as for the âˆƒâˆ€ fragment (in which the quan-
tiï¬cation condition is limited to a sequence of âˆƒ quantiï¬ers followed
by a sequence of âˆ€ quantiï¬ers), nonemptiness is decidable.

3

Property
Closure

Result
Complementation, Union, Intersection (Theorems 1, 2, 3)

Nonemptiness

Bounded Nonemptiness

Universality

Finite membership

Regular membership

Containment

âˆ€âˆƒâˆƒ
âˆƒâˆ— / âˆ€âˆ— / âˆƒâˆ—(cid:63) / âˆ€âˆ—(cid:63)
âˆƒâˆ—âˆ€âˆ—
âˆƒâˆ—âˆ€âˆ—(cid:63)
NFH
âˆƒâˆ€âˆ€
âˆƒâˆ— / âˆ€âˆ—
âˆ€âˆ—âˆƒâˆ—
NFH
O(log(k)) âˆ€

Undecidable (Theorem 4)
NL-complete (Theorems 5, 10)
PSPACE-complete (Theorem 6)
EXPSPACE-complete (Theorem 11)
PSPACE-complete (Theorem 9)
Undecidable (Theorem 12)
PSPACE-complete (Theorem 12)
EXPSPACE (Theorem 12)
PSPACE (Theorem 13)
NP-complete (Theorem 13)

Decidable (Theorem 14)

NFH
âˆƒâˆ— âŠ† âˆ€âˆ— / âˆ€âˆ— âŠ† âˆƒâˆ—
âˆƒâˆ—âˆ€âˆ— âŠ† âˆ€âˆ—âˆƒâˆ—

Undecidable (Theorem 15)
PSPACE-complete (Theorem 16)
EXPSPACE (Theorem 16)

Table 1: Summary of results on properties of hyperregular languages.
* As another positive result in the area of nonemptiness, we show that
the bounded nonemptiness problem, in which we decide whether an
NFH accepts a hyperword of bounded size, is PSPACE-complete.
* We consider the construction of HRE and NFH with wild card let-
ters, which allow expressing the assignment to only a subset of the
variables, by assigning a wild card letter to the rest of the variables.
We show that adding wild cards does not alter the complexity of the
nonemptiness for the alternation-free fragments, while it does increase
the complexity of this problem for the âˆƒâˆ€ fragment.

* We describe a semi-algorithm for deciding the nonemptiness of NFH
with a âˆ€âˆƒ quantiï¬cation condition. The procedure begins with the
largest potential hyperword, and iteratively prunes it in a consistent
way in case it is not accepted. Since the problem is undecidable, there
are inputs for which our semi-algorithm does not halt. However, in
case it does halt, it is guaranteed to return a correct answer. Since âˆ€âˆƒ
is a useful fragment, our procedure can be a useful tool.

â€“ We study the universality, membership and containment problems. These
results are aligned with the complexity of HyperLTL model checking for
tree-shaped and general Kripke structures [5]. This shows that the com-
plexity results in [5] mainly stem from the nature of quantiï¬cation over
ï¬nite words and depend on neither the full power of the temporal operators
nor the inï¬nite nature of HyperLTL semantics.

Comparison to the conference version. This article substantially extends the results of
our original conference submission [10] by the following new contributions.

â€¢ An upper and lower bound of the bounded nonempitness problem.

4

â€¢ Upper and lower bounds for the nonemptiness problem for the various fragments

of NFH in the presence of wild-card letters.

â€¢ A semi-algorithm for deciding the nonemptiness for the âˆ€âˆƒ fragment.

â€¢ A detailed discussion on related work.

In summary, the material in Sections 6.2, 6.4 6.3, and 8 is all new. Finally, all proof
sketches are now extended to revised and detailed full proofs.

1.3. Organization

The rest of the paper is organized as follows. Preliminary concepts are presented in
Section 2. We introduce the notion of HRE and NFH in Sections 3 and 4, while their
properties and our complexity results are studied in Sections 5, 6, and 7. Related work
is discussed in Section 8. Finally, we make concluding remarks and discuss future
work in Section 9.

2. Preliminaries

An alphabet is a nonempty ï¬nite set Î£ of letters. A word over Î£ is a ï¬nite sequence
of letters from Î£. The empty word is denoted by (cid:15), and the set of all words is denoted by
Î£âˆ—. A language is a subset of Î£âˆ—. We assume that the reader is familiar with the syntax
and semantics of regular expressions (RE). We use the standard notations {Â·, |, âˆ—} for
concatenation, union, and Kleene star, respectively, and denote the language of an RE
r by L(r). A language L is regular if there exists an RE r such that L(r) = L.

ï¬nite-word
Deï¬nition 1. A nondeterministic
tuple
A = (cid:104)Î£, Q, Q0, Î´, F (cid:105), where Î£ is an alphabet, Q is a nonempty ï¬nite set of states,
Q0 âŠ† Q is a set of initial states, F âŠ† Q is a set of accepting states, and Î´ âŠ† Q Ã— Î£ Ã— Q
is a transition relation.

automaton

(NFA)

is

a

Given a word w = Ïƒ1Ïƒ2 Â· Â· Â· Ïƒn over Î£, a run of A on w is a sequence of states
(q0, q1, . . . qn), such that q0 âˆˆ Q0, and for every 0 < i â‰¤ n, it holds that (qiâˆ’1, Ïƒi, qi) âˆˆ
Î´. The run is accepting if qn âˆˆ F . We say that A accepts w if there exists an accepting
run of A on w. The language of A, denoted L(A), is the set of all words that A ac-
cepts. It is well-known that a language L is regular iff there exists an NFA A such that
L(A) = L.

3. Hyperregular Expressions

Deï¬nition 2. A hyperword over Î£ is a set of words over Î£ and a hyperlanguage over
Î£ is a set of hyperwords over Î£.

Before formally deï¬ning hyperregular expressions, we explain the idea behind
them. A hyperregular expression (HRE) over Î£ uses a set of word variables X =
{x1, x2, . . . , xk}. When expressing a hyperword S, these variables are assigned words

5

from S. An HRE r is composed of a quantiï¬cation condition Î± over X, and an un-
derlying RE Ë†r, which represents word assignments to X. An HRE r deï¬nes a hyper-
language L(r). The condition Î± deï¬nes the assignments that should be in L(Ë†r). For
example, Î± = âˆƒx1.âˆ€x2 requires that there exists a word w1 âˆˆ S (assigned to x1),
such that for every word w2 âˆˆ S (assigned to x2), the word that represents the assign-
ment x1 (cid:55)â†’ w1, x2 (cid:55)â†’ w2, is in L(Ë†r). The hyperword S is in L(r) iff S meets these
conditions.

We represent an assignment v : X â†’ S as a word assignment wv, which is a word
over the alphabet (Î£âˆª{#})X (that is, assignments from X to Î£âˆª{#}), where the iâ€™th
letter of wv represents the k iâ€™th letters of the words v(x1), . . . , v(xk) (in case that the
words are not of equal length, we â€œpadâ€ the end of the shorter words with # symbols).
We represent these k iâ€™th letters as an assignment denoted {Ïƒ1x1 , Ïƒ2x2 , . . . , Ïƒkxk },
where xj is assigned Ïƒj. For example, the assignment v(x1) = aa and v(x2) = abb is
represented by the word assignment wv = {ax1 , ax2}{ax1, bx2 }{#x1 , bx2}.

Deï¬nition 3. A hyperregular expression is a tuple r = (cid:104)X, Î£, Î±, Ë†r(cid:105), where Î± =
Q1x1 Â· Â· Â· Qkxk, where Qi âˆˆ {âˆƒ, âˆ€} for every i âˆˆ [1, k], and where Ë†r is an RE over
Ë†Î£ = (Î£ âˆª {#})X .

Let S be a hyperword and let v : X â†’ S be an assignment of the word variables of
r to words in S. We denote by v[x (cid:55)â†’ w] the assignment obtained from v by assigning
the word w âˆˆ S to x âˆˆ X. We represent v by wv. We now deï¬ne the membership
condition of a hyperword S in the hyperlanguage of r. We ï¬rst deï¬ne a relation (cid:96) for
S, Ë†r, a quantiï¬cation condition Î±, and an assignment v : X â†’ S, as follows.

â€¢ For Î± = (cid:15), deï¬ne S (cid:96)v (Î±, Ë†r) if wv âˆˆ L(Ë†r).

â€¢ For Î± = âˆƒx.Î±(cid:48), deï¬ne S (cid:96)v (Î±, Ë†r) if there exists w âˆˆ S s.t. S (cid:96)v[x(cid:55)â†’w] (Î±(cid:48), Ë†r).

â€¢ For Î± = âˆ€x.Î±(cid:48), deï¬ne S (cid:96)v (Î±, Ë†r) if S (cid:96)v[x(cid:55)â†’w] (Î±(cid:48), Ë†r) for every w âˆˆ S .1

Since all variables are under the scope of Î±, membership is independent of v, and so if
S (cid:96) (Î±, Ë†r), we denote S âˆˆ L(r). The hyperlanguage of r is L(r) = {S | S âˆˆ L(r)}.

Deï¬nition 4. We call a hyperlanguage L a regular hyperlanguage if there exists an
HRE r such that L(r) = L.

Application of HRE in Information-ï¬‚ow Security

Noninterference [29] requires high-secret commands to be removable without af-

fecting observations of users holding low clearances:

Ï•ni = âˆ€x.âˆƒy{lx, lÎ»y}âˆ—,

where l denotes a low state and lÎ» denotes a low state such that all high commands are
replaced by a dummy value Î».

1In case that Î± begins with âˆ€, membership holds vacuously with an empty hyperword. We restrict the

discussion to nonempty hyperwords.

6

Observational determinism [39] requires that if two executions of a system start

with low-security-equivalent events, they should remain low equivalent:

Ï•od = âˆ€x.âˆ€y.

(cid:16)

{lx, ly}+ | {Â¯lx, Â¯ly}{$x, $y}âˆ— | {lx, Â¯ly}{$x, $y}âˆ— | {Â¯lx, ly}{$x, $y}âˆ—(cid:17)

where l denotes a low event, Â¯l âˆˆ Î£ \ {l}, and $ âˆˆ Î£. We note that similar policies
such as Boudol and Castellaniâ€™s noninterference [28] can be formulated in the same
fashion. 2

Generalized noninterference (GNI) [32] allows nondeterminism in the low-observable

behavior, but requires that low-security outputs may not be altered by the injection of
high-security inputs:

Ï•gni = âˆ€x.âˆ€y.âˆƒz.

(cid:18)

{hx, ly, hlz} | {Â¯hx, ly, Â¯hlz} | {hx, Â¯ly, hÂ¯lz} | {Â¯hx, Â¯ly, Â¯hÂ¯lz}

(cid:19)âˆ—

where h denotes the high-security input, l denotes the low-security output, Â¯l âˆˆ Î£ \ {l},
and Â¯h âˆˆ Î£ \ {h}.

Declassiï¬cation [34] relaxes noninterference by allowing leaking information when
necessary. Some programs must reveal secret information to fulï¬ll functional require-
ments. For example, a password checker must reveal whether the entered password is
correct or not:

Ï•dc = âˆ€x.âˆ€y.{lix, liy}{pwx, pwy}{lox, loy}+
where li denotes low-input state, pw denotes that the password is correct, and lo de-
notes low-output states. We note that for brevity, Ï•dc does not include behaviors where
the ï¬rst two events are not low or, in the second event, the password is not valid.

Termination-sensitive noninterference requires that for two executions that start
from low-observable states, information leaks are not permitted by the termination
behavior of the program (here, l denotes a low state and $ âˆˆ Î£):

Ï•tsni = âˆ€x.âˆ€y.

(cid:16)

{lx, ly}{$x, $y}âˆ—{lx, ly} | {Â¯lx, Â¯ly}{$x, $y}âˆ— |
{lx, Â¯ly}{$x, $y}âˆ— | {Â¯lx, ly}{$x, $y}âˆ—(cid:17)

4. Nondeterminsitic Finite-Word Hyperautomata

We now present a model for regular hyperlanguages, namely ï¬nite-word hyper-
automata. A hyperautomaton is composed of a set X of word variables, a quantiï¬ca-
tion condition, and an underlying ï¬nite-word automaton that accepts representations of
assignments to X.

Deï¬nition 5. A nondeterministic ï¬nite-word hyperautomaton (NFH) is a tuple
A = (cid:104)Î£, X, Q, Q0, F, Î´, Î±(cid:105), where Î£, X and Î± are as in Deï¬nition 3, and where
(cid:104) Ë†Î£, Q, Q0, F, Î´(cid:105) forms an underlying NFA over Ë†Î£ = (Î£ âˆª {#})X .

2This policy states that every two executions that start from bisimilar states (in terms of memory low-

observability), should remain bisimilarly low-observable.

7

Figure 1: The NFH A1 (left) and A2 (right).

The acceptance condition for NFH, as for HRE, is deï¬ned with respect to a hyperword
S, the NFH A, the quantiï¬cation condition Î±, and an assignment v : X â†’ S. For the
base case of Î± = (cid:15), we deï¬ne S (cid:96)v (Î±, A) if Ë†A accepts wv. The cases where Î± is of
the type âˆƒx.Î±(cid:48) and âˆ€x.Î±(cid:48) are deï¬ned similarly as for HRE, and if S (cid:96) (Î±, A), we say
that A accepts S.

Deï¬nition 6. Let A be an NFH. The hyperlanguage of A, denoted L(A), is the set of
all hyperwords that A accepts.

Example 3. Consider the NFH A1 in Figure 1 (left), whose alphabet is Î£ = {a, b},
over two word variables x and y. The NFH A1 contains an underlying standard NFA
Ë†A1. For two words w1, w2 that are assigned to x and y, respectively, Ë†A1 requires that
(1) w1, w2 agree on their a (and, consequently, on their b) positions, and (2) once one
of the words has ended (denoted by #), the other must only contain b letters. Since
the quantiï¬cation condition of A1 is âˆ€x1.âˆ€x2, in a hyperword S that is accepted by
A1, every two words agree on their a positions. As a result, all the words in S must
agree on their a positions. The hyperlanguage of A1 is then all hyperwords in which
all words agree on their a positions.

Example 4. The NFH A2 of Figure 1 (right) depicts the translation of the HRE of
Example 1 to an NFH.

Since regular expressions are equivalent to NFA, we can translate the underlying
regular expression Ë†r of an HRE r to an equivalent NFA, and vice versa â€“ translate the
underlying NFA Ë†A of an NFH A to a regular expression. It is then easy to see that every
HRE has an equivalent NFH over the same set of variables with the same quantiï¬cation
condition.

We consider several fragments of NFH, which limit the structure of the quantiï¬-
cation condition Î±. HREâˆ€ is the fragment in which Î± contains only âˆ€ quantiï¬ers, and
similarly, in HREâˆƒ, Î± contains only âˆƒ quantiï¬ers. In the fragment HREâˆƒâˆ€, Î± is of the
form âˆƒx1 Â· Â· Â· âˆƒxiâˆ€xi+1 Â· Â· Â· âˆ€xk.

4.1. Additional Terms and Notations

We present several terms and notations which we use throughout the paper. Recall
that we represent an assignment v : X â†’ S as a word assignment wv. Conversely, a
word w over (Î£ âˆª {#})X represents an assignment vw : X â†’ Î£âˆ—, where vw(xi) is
formed by concatenating the letters of Î£ that are assigned to xi in the letters of w. We
denote the set of all such words {vw(x1), . . . , vw(xk)} by S(w). Since we only allow

8

{ğ‘ğ‘¥,ğ‘ğ‘¦}{#ğ‘¥,ğ‘ğ‘¦}âˆ€ğ‘¥âˆƒğ‘¦ğ‘ğ‘¥,ğ‘ğ‘¦,{ğ‘ğ‘¥,ğ‘ğ‘¦}âˆ€ğ‘¥âˆ€ğ‘¦{#ğ‘¥,ğ‘ğ‘¦}{ğ‘ğ‘¥,#ğ‘¦}{ğ‘ğ‘¥,#ğ‘¦}{#ğ‘¥,ğ‘ğ‘¦}{#ğ‘¥,ğ‘ğ‘¦}padding at the end of a word, if a padding occurs in the middle of w, then w does not
represent a legal assignment. Notice that this occurs iff w contains two consecutive
letters wiwi+1 such that wi(x) = # and wi+1(x) (cid:54)= # for some x âˆˆ X. We call w
legal if vw represents a legal assignment from X to Î£âˆ—.

Consider a function g : A â†’ B where A, B are some sets. The range of g, denoted

range(g) is the set {g(a)|a âˆˆ A}.

A sequence of g is a function g(cid:48) : A â†’ B such that range(g(cid:48)) âŠ† range(g). A
permutation of g is a function g(cid:48) : A â†’ B such that range(g(cid:48)) = range(g). We extend
the notions of sequences and permutations to word assignments. Let w be a word over
Ë†Î£. A sequence of w is a word w(cid:48) such that S(w(cid:48)) âŠ† S(w), and a permutation of w is a
word w(cid:48) such that S(w(cid:48)) = S(w).

Throughout the paper, when we use a general NFH A, we assume that its ingredi-

ents are as in Deï¬nition 5.

5. Closure Properties of Regular Hyperlanguages

We now consider closure properties of regular hyperlanguages. We show, via con-
structions on NFH, that regular hyperlanguages are closed under all the Boolean oper-
ations.

Theorem 1. Regular hyperlanguages are closed under complementation.
Proof. Let A be an NFH. The NFA Ë†A can be complemented with respect to its lan-
guage over Ë†Î£ to an NFA Ë†A. Then, for every assignment v : X â†’ S, it holds that Ë†A
accepts wv iff Ë†A does not accept wv. Let Î± be the quantiï¬cation condition obtained
from Î± by replacing every âˆƒ with âˆ€ and vice versa. We can prove by induction on
Î± that A, the NFH whose underlying NFA is Ë†A, and whose quantiï¬cation condition
is Î±, accepts L(A). The size of A is exponential in | Ë†A|, due to the complementation
construction for Ë†A and complementing the set of transitions in Î´.

Theorem 2. Regular hyperlanguages are closed under union.

Proof. let A1 = (cid:104)Î£, X, Q, Q0, Î´1, F1, Î±1(cid:105) and A2 = (cid:104)Î£, Y, P, P0, Î´2, F2, Î±2(cid:105) be two
NFH with |X| = k and |Y | = k(cid:48) variables, respectively.

We construct an NFH Aâˆª = (cid:104)Î£, X âˆª Y, Q âˆª P âˆª {p1, p2}, Q0 âˆª P0, Î´, F1 âˆª F2 âˆª
{p1, p2}, Î±(cid:105), where Î± = Î±1Î±2 (that is, we concatenate the two quantiï¬cation condi-
tions), and where Î´ is deï¬ned as follows.

â€¢ For every (q1

f
âˆ’â†’ q2) âˆˆ Î´1 we set (q1

f âˆªg
âˆ’âˆ’â†’ q2) âˆˆ Î´ for every g âˆˆ (Î£ âˆª {#})Y .

â€¢ For every (q1

f
âˆ’â†’ q2) âˆˆ Î´2 we set (q1

f âˆªg
âˆ’âˆ’â†’ q2) âˆˆ Î´ for every g âˆˆ (Î£ âˆª {#})X .

â€¢ For every q âˆˆ F1, we set (q

g âˆˆ (Î£ âˆª {#})Y .

â€¢ For every q âˆˆ F2, we set (q

g âˆˆ (Î£ âˆª {#})X .

{#}X âˆªg
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p1), (p1

{#}X âˆªg
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p1) âˆˆ Î´ for every

gâˆª{#}Y
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p2), (p2

gâˆª{#}Y
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p2) âˆˆ Î´ for every

9

Let S be a hyperword. For every v : (X âˆª Y ) â†’ S, it holds that if wv|X âˆˆ L( Ë†A1),
then wv âˆˆ L( Ë†Aâˆª). Indeed, according to our construction, every word assigned to the
Y variables is accepted in the A1 component of the construction, and so it satisï¬es both
types of quantiï¬ers. A similar argument holds for v|Y and A2.

Also, according to our construction, for every v : (X âˆª Y ) â†’ S, if wv âˆˆ L( Ë†Aâˆª),
then either wv|X âˆˆ L( Ë†A1), or wv|Y âˆˆ L( Ë†A2). As a conclusion, we have that L(Aâˆª) =
L(A1) âˆª L(A2).

The state space of Aâˆª is linear in the state spaces of A1, A2. However, the size
of the alphabet of Aâˆª may be exponentially larger than that of A1 and A2, since we
augment each letter with all functions from Y to Î£ âˆª {#} (in A1) and from X to
Î£ âˆª {#} (in A2).

Theorem 3. Regular hyperlanguages are closed under intersection.

Proof. The proof follows from the closure of regular hyperlanguages under union and
complementation. However, we also offer a direct translation, which avoids the need
to complement.

let A1 = (cid:104)Î£, X, Q, Q0, Î´1, F1, Î±1(cid:105) and A2 = (cid:104)Î£, Y, P, P0, Î´2, F2, Î±2(cid:105) be two NFH

with |X| = k and |Y | = k(cid:48) variables, respectively.

We construct an NFH Aâˆ© = (cid:104)Î£, X âˆª Y, (Q âˆª {q}) Ã— (P âˆª {p}), (Q0 Ã— P0), Î´, (F1 âˆª

{q}) Ã— (F2 âˆª {p}), Î±1Î±2(cid:105), where Î´ is deï¬ned as follows.

â€¢ For every (q1

f
âˆ’â†’ q2) âˆˆ Î´1 and every (p1

g
âˆ’â†’ p2) âˆˆ Î´2, we have

(cid:16)

(q1, p1)

f âˆªg
âˆ’âˆ’â†’ (q2, p2)

(cid:17)

âˆˆ Î´

â€¢ For every q1 âˆˆ F1, (p1

g
âˆ’â†’ p2) âˆˆ Î´2 we have

(cid:16)

(q1, p1)

{#}X âˆªg
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q, p2)

(cid:17)

(cid:16)

,

(q, p1)

{#}kâˆªg
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q, p2)

(cid:17)

âˆˆ Î´

â€¢ For every (q1

f
âˆ’â†’ q2) âˆˆ Î´1 and p1 âˆˆ F2, we have

(cid:16)

(q1, p1)

f âˆª{#}Y
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q2, p)

(cid:17)

(cid:16)

,

(q1, p)

f âˆª{#}Y
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q2, p)

(cid:17)

âˆˆ Î´

Intuitively, the role of q, p is to keep reading {#}X and {#}Y after the word read by
Ë†A1 or Ë†A2, respectively, has ended.

The NFH Ë†Aâˆ© simultaneously reads two word assignments that are read along Ë†A1
and Ë†A2, and accepts iff both word assignments are accepted. The correctness follows
from the fact that for v : (X âˆª Y ) â†’ S, we have that wv is accepted by Ë†A iff wv|X and
wv|Y are accepted by Ë†A1 and Ë†A2, respectively. This construction is polynomial in the
sizes of A1 and A2.

10

6. Nonemptiness of NFH.

The nonemptiness problem is to decide, given an NFH A, whether L(A) = âˆ…. The
complexity of the nonemptiness problem affects the complexity of various other deci-
sion problems, such as universality and containment. In this section, we extensively
study various versions of this problem for various fragments of NFH. First, we show
that the problem for general NFH is undecidable. Then, we show that nonemptiness is
decidable for various fragments of NFH, with varying complexities.

We then study the bounded nonemptiness problem, in which we ask whether an

NFH accepts a hyperword of bounded size.

Finally, we study the nonemptiness problem in the presence of wild-card letters,
which represent free assignments to a variable. Wild-card letters can exponentially
decrease the number of transitions of an NFH. We show that for the alternation-free
fragments of NFH, wild-card letters do not increase the complexity of the nonemptiness
problem, while for the fragment of NFHâˆƒâˆ€, the smaller representation comes with an
exponential blow-up in complexity.

6.1. General Nonemptiness Results

We begin with the nonemptiness problem for general NFH.

Theorem 4. The nonemptiness problem for NFH is undecidable.

Proof. In [19], a reduction from the Post correspondence problem is used for proving
the undecidability of HyperLTL satisï¬ability. We mimic the proof ideas of [19] to show
that the nonemptiness problem for NFH is, in general, undecidable. A PCP instance is
a collection C of dominoes of the form:

(cid:40)

(cid:104) u1
v1

(cid:105)

,

(cid:104) u2
v2

(cid:105)
, . . . ,

(cid:104) uk
vk

(cid:41)

(cid:105)

where for all i âˆˆ [1, k], we have vi, ui âˆˆ {a, b}âˆ—. The problem is to decide whether
there exists a ï¬nite sequence of the dominoes of the form

(cid:105)

(cid:104) ui1
vi1

(cid:105)(cid:104) ui2
vi2

Â· Â· Â·

(cid:105)

(cid:104) uim
vim

where each index ij is in [1, k], such that the upper and lower ï¬nite strings of the
dominoes are equal, i.e.,

ui1 ui2 Â· Â· Â· uim = vi1vi2 Â· Â· Â· vim

For example, if the set of dominoes is

Cexmp =

(cid:40)

(cid:104) ab
b

(cid:105)

,

(cid:105)

,

(cid:104) ba
a

(cid:104) a
aba

(cid:41)

(cid:105)

Then, a possible solution is the following sequence of dominoes from Cexmp:

sol =

(cid:104) a
aba

(cid:105)(cid:104) ba
a

(cid:105)(cid:104) ab
b

(cid:105)

.

11

Given an instance C of PCP, we encode a solution as a word wsol over the following

alphabet:

(cid:111)
(cid:110) Ïƒ
Ïƒ(cid:48) | Ïƒ, Ïƒ(cid:48) âˆˆ {a, b, Ë™a, Ë™b, $}
.
Intuitively, Ë™Ïƒ marks the beginning of a new domino, and $ marks the end of a sequence
of the upper or lower parts of the dominoes sequence.

Î£ =

We note that wsol encodes a legal solution iff the following conditions are met:

1. For every Ïƒ

Ïƒ(cid:48) that occurs in wsol, it holds that Ïƒ, Ïƒ(cid:48) represent the same domino

letter (both a or both b, either dotted or undotted).

2. The number of dotted letters in the upper part of wsol is equal to the number of

dotted letters in the lower part of wsol.

3. wsol starts with two dotted letters, and the word ui between the iâ€™th and i + 1â€™th
dotted letters in the upper part of wsol, and the word vi between the correspond-
ing dotted letters in the lower part of wsol are such that [ ui
] âˆˆ C, for every
vi
i.

We call a word that represents the removal of the ï¬rst k dominoes from wsol a
partial solution, denoted by wsol,k. Note that the upper and lower parts of wsol,k are
not necessarily of equal lengths (in terms of a and b sequences), since the upper and
lower parts of a domino may be of different lengths, and so we use letter $ to pad the
end of the encoding in the shorter of the two parts.

We construct an NFH A, which, intuitively, expresses the following ideas: (1)
There exists an encoding wsol of a solution to C, and (2) For every wsol,k (cid:54)= (cid:15) in a
hyperword S accepted by A, the word wsol,k+1 is also in S.

L(A) is then the set of all hyperwords that contain an encoded solution wsol, as
well as all its sufï¬xes obtained by removing a preï¬x of dominoes from wsol. This
ensures that wsol indeed encodes a legal solution. For example, a matching hyperword
S (for the solution sol discussed earlier) that is accepted by A is:

S = {wsol =

Ë™b
b

Ë™a
Ë™a

a
a

Ë™a
Ë™a

b
Ë™b

, wsol,1 =

Ë™b
Ë™a

a
Ë™b

Ë™a
$

b
$

, wsol,2 =

Ë™a
Ë™b

b
$

, wsol,3 = (cid:15)}

Thus, the quantiï¬cation condition of A is Î± = âˆ€x1âˆƒx2âˆƒx3, where x1 is to be
assigned a potential partial solution wsol,k, and x2 is to be assigned wsol,k+1, and x3
is to be assigned wsol.

During a run on a hyperword S and an assignment v : {x1, x2, x3} â†’ S, the NFH
A checks that the upper and lower letters of wsol all match. In addition, A checks
that the ï¬rst domino of v(x1) is indeed in C, and that v(x2) is obtained from v(x1)
by removing the ï¬rst tile. A performs the latter task by checking that the upper and
lower parts of v(x2) are the upper and lower parts of v(x1) that have been â€œshiftedâ€
back appropriately. That is, if the ï¬rst tile in v(x2) is the encoding of [ wi
], then A uses
vi
states to remember, at each point, the last |wi| letters of the upper part of v(x2) and the
last |vi| letters of the lower part of v(x2), and veriï¬es, at each point, that the next letter
in v(x1) matches the matching letter remembered by the state.

12

Next, we show that for the alternation-free fragments, a simple reachability test

sufï¬ces to decide nonemptiness.

Theorem 5. The nonemptiness problem for NFHâˆƒ and NFHâˆ€ is NL-complete.

Proof. The lower bound for both fragments follows from the NL-hardness of the
nonemptiness problem for NFA.

We turn to the upper bound, and begin with NFHâˆƒ. Let Aâˆƒ be an NFHâˆƒ. We claim
that Aâˆƒ is nonempty iff Ë†Aâˆƒ accepts some legal word w. The ï¬rst direction is trivial. For
the second direction, let w âˆˆ L( Ë†Aâˆƒ). By assigning v(xi) = vw(xi) for every xi âˆˆ X,
we get wv = w, and according to the semantics of âˆƒ, we have that Aâˆƒ accepts S(w).
To check whether Ë†Aâˆƒ accepts a legal word, we can run a reachability check on-the-ï¬‚y,
while advancing from a letter Ïƒ to the next letter Ïƒ(cid:48) only if Ïƒ(cid:48) assigns # to all variables
f
âˆ’â†’ p in Ë†A is of size k, we can
for which Ïƒ assigns #. While each transition T = q
(xi,Ïƒi)
encode T as a set of size k of encodings of transitions of type q
âˆ’âˆ’âˆ’âˆ’â†’ p with a binary
encoding of p, q, Ïƒi, as well as i, t, where t marks the index of T within the set of
transitions of Ë†A. Therefore, the reachability test can be performed within space that is
logarithmic in the size of Aâˆƒ.

Now, let Aâˆ€ be an NFHâˆ€ over X. We claim that Aâˆ€ is nonempty iff Aâˆ€ accepts a
hyperword of size 1. For the ï¬rst direction, let S âˆˆ L(Aâˆ€). Then, by the semantics of
âˆ€, we have that for every assignment v : X â†’ S, it holds that wv âˆˆ L( Ë†Aâˆ€). Let u âˆˆ S,
and let vu(xi) = u for every xi âˆˆ X. Then, in particular, wvu âˆˆ L( Ë†Aâˆ€). Then for
every assignment v : X â†’ {u} (which consists of the single assignment vu), it holds
that Ë†Aâˆ€ accepts wv, and therefore Aâˆ€ accepts {u}. The second direction is trivial.

To check whether Aâˆ€ accepts a hyperword of size 1, we restrict the reachability

test on Ë†Aâˆ€ to letters over Ë†Î£ that represent ï¬xed functions.

For NFHâˆƒâˆ€, we show that the problem is decidable, by checking the nonemptiness

of an exponentially larger equi-empty NFA.

Theorem 6. The nonemptiness problem for NFHâˆƒâˆ€ is PSPACE-complete.

Proof. Let A be an NFHâˆƒâˆ€ with k quantiï¬ers and m âˆƒ-quatiï¬ers. We begin with a
PSPACE upper bound.

Let S âˆˆ L(A). Then, according to the semantics of the quantiï¬ers, there exist
w1, . . . wm âˆˆ S, such that for every assignment v : X â†’ S in which v(xi) = wi for
every 1 â‰¤ i â‰¤ m, it holds that Ë†A accepts wv. Let v : X â†’ S be such an assignment.
Then, Ë†A accepts wv(cid:48) for every sequence v(cid:48) of v that agrees with v on its assignments
to x1, . . . , xm, and in particular, for such sequences whose range is {w1, . . . , wm}.
Therefore, by the semantics of the quantiï¬ers, we have that {w1, . . . , wm} is in L(A).
The second direction is trivial.

We call wv(cid:48) as described above a witness to the nonemptiness of A. We construct
an NFA A based on Ë†A that is nonempty iff Ë†A accepts a witness to the nonemptiness of
A.

Let Î“ be the set of all functions of the type Î¶ : [1, k] â†’ [1, m] such that Î¶(i) = i
for every i âˆˆ [1, m], and such that range(Î¶) = [1, m]. For a letter assignment f =
{Ïƒ1x1

}, we denote by fÎ¶ the letter assignment {ÏƒÎ¶(1)x1

, . . . , ÏƒÎ¶(k)xk

, . . . Ïƒkxk

}.

13

g
âˆ’â†’ q(cid:48) in Î´, we have q

For every function Î¶ âˆˆ Î“, we construct an NFA AÎ¶ = (cid:104) Ë†Î£, Q, Q0, Î´Î¶, F (cid:105), where
f
âˆ’â†’ q(cid:48) in Î´Î¶, for every f that occurs in Ë†A for which
for every q
fÎ¶ = g. Intuitively, for every run of AÎ¶ on a word w there exists a similar of Ë†A on the
sequence of w that matches Î¶. Therefore, Ë†A accepts a witness w to the nonemptiness
of A iff w âˆˆ L(AÎ¶) for every Î¶ âˆˆ Î“.

We deï¬ne A = (cid:84)

Î¶âˆˆÎ“ AÎ¶. Then Ë†A accepts a witness to the nonemptiness of A iff

A is nonempty.

Since |Î“| = mkâˆ’m, the state space of A is of size O(nmkâˆ’m

), where n = |Q|,
and its alphabet is of size | Ë†Î£|. Notice that for A to be nonempty, Î´ must be of size at
least |(Î£ âˆª #)|(kâˆ’m), to account for all the sequences of letters in the words assigned
to the variables under âˆ€ quantiï¬ers (otherwise, we can immediately return â€œemptyâ€).
Therefore, | Ë†A| is O(nÂ·|Î£|k). We then have that the size of A is O(| Ë†A|k). If the number
k âˆ’ m of âˆ€ quantiï¬ers is ï¬xed, then mkâˆ’m is polynomial in k. However, now | Ë†A| may
be polynomial in n, k, and |Î£|, and so in this case as well, the size of A is O(| Ë†A|k).

Since the nonemptiness problem for NFA is NL-complete, the problem for NFHâˆƒâˆ€

can be decided in space of size that is polynomial in | Ë†A|.

For the lower bound, we show a reduction from a polynomial version of the corri-
dor tiling problem, deï¬ned as follows. We are given a ï¬nite set T of tiles, two relations
V âŠ† T Ã— T and H âŠ† T Ã— T , an initial tile t0, a ï¬nal tile tf , and a bound n > 0. We
have to decide whether there is some m > 0 and a tiling of a n Ã— m-grid such that (1)
The tile t0 is in the bottom left corner and the tile tf is in the top right corner, (2) A
horizontal condition: every pair of horizontal neighbors is in H, and (3) A vertical con-
dition: every pair of vertical neighbors is in V . When n is given in unary notation, the
problem is known to be PSPACE-complete. Given an instance C of the tiling problem,
we construct an NFHâˆƒâˆ€ A that is nonempty iff C has a solution. We encode a solution
to C as a word wsol = w1 Â· w2 Â· wm$ over Î£ = T âˆª {1, 2, . . . n, $}, where the word
wi, of the form 1 Â· t1,i Â· 2 Â· t2,i, . . . n Â· tn,i, describes the contents of row i.

To check that wsol indeed encodes a solution, we need to make sure that:

1. w1 begins with t0 and wm ends with tf $.

2. wi is of the correct form.

3. Within every wi, it holds that (tj,i, tj+1,i) âˆˆ H.

4. For wi, wi+1, it holds that (tj,i, tj,i+1) âˆˆ V for every j âˆˆ [1, n].

Verifying items 1 âˆ’ 3 is easy via an NFA of size O(n|H|). The main obstacle is

item 4.

We describe an NFHâˆƒâˆ€ A = (cid:104)T âˆª {0, 1, 2, . . . n, $}, {y1, y2, y3, x1, . . . xlog(n)},
Q, {q0}, Î´, F, Î±(cid:105) that is nonempty iff there exists a word that satisï¬es items 1 âˆ’ 4.
The quantiï¬cation condition Î± is âˆƒy1âˆƒy2âˆƒy3âˆ€x1 . . . âˆ€xlog(n). The NFH A only pro-
ceeds on letters whose assignments to y1, y1, y3 is r, 0, 1, respectively, where r âˆˆ
T âˆª {1, . . . n, $}. Notice that this means that A requires the existence of the words
0|wsol| and 1|wsol| (the 0-word and 1-word, henceforth). A makes sure that the word
assigned to y1 matches a correct solution w.r.t. items 1 âˆ’ 3 described above. We pro-
ceed to describe how to handle the requirement for V . We need to make sure that for

14

every position j in a row, the tile in position j in the next row matches the current one
w.r.t. V . We can use a state qj to remember the tile in position j, and compare it to the
tile in the next occurrence of j. The problem is avoiding having to check all positions
simultaneously, which would require exponentially many states. To this end, we use
log(n) copies of the 0- and 1-words to form a binary encoding of the position j that is
to be remembered. The log(n) âˆ€ conditions make sure that every position within 1 âˆ’ n
is checked.

We limit the checks to words in which x1, . . . xlog(n) are the 0- or 1-words, by
having Ë†A accept every word in which there is a letter that is not over 0, 1 that is assigned
to the x variables. This takes care of accepting all cases in which the word assigned to
y1 is also assigned to one of the x variables.

To check that x1, . . . xlog(n) are the 0- or 1-words, Ë†A checks that the letter as-
signments to these variables remain constant throughout the run. In these cases, upon
reading the ï¬rst letter, Ë†A remembers the value j that is encoded by the constant as-
signments to x1, . . . xlog(n) in a state, and makes sure that throughout the run, the tile
that occurs in the assignment to y1 in position j in the current row matches the tile in
position j in the next row.

We construct a similar reduction for the case that the number of âˆ€ quantiï¬ers is
ï¬xed: instead of encoding the position by log(n) bits, we can directly specify the po-
sition by a word of the form jâˆ—, for every j âˆˆ [1, n]. Accordingly, we construct an
NFHâˆƒâˆ€ over {x, y1, . . . yn, z}, with a quantiï¬cation condition Î± = âˆƒxâˆƒy1 . . . âˆƒynâˆ€z.
The NFA Ë†A advances only on letters whose assignments to y1, . . . yn are always
1, 2, . . . n, respectively, and checks only words assigned to z that are some constant
1 â‰¤ j â‰¤ n. Notice that the ï¬xed assignments to the y variables leads to Î´ of polyno-
mial size. In a hyperword accepted by A, the word assigned to x is wsol, and the word
assigned to z speciï¬es which index should be checked for conforming to V .

6.2. Bounded nonemptiness

The bounded nonemptiness problem is to decide, given an NFH A and m âˆˆ N,
whether A accepts a hyperword of size at most m. Notice that some nonempty NFH
only accept inï¬nite hyperwords (for example, A2 of Figure 1), and so they do not
accept a hyperword of size m, for every m âˆˆ N.

We show that the bounded nonemptiness problem is decidable for all of NFH.

Theorem 7. The bounded nonemptiness problem for NFH is in PSPACE.

Proof. Let A be an NFH with a quantiï¬cation condition Î± with k quantiï¬ers, and let
m âˆˆ N.
Intuitively, we construct an NFA A in which a single run simultaneously
follows all runs of Ë†A on the possible assignments of a potential hyperword S of size m
to the variables of A. Then, A accepts a set of such legal assignments (represented as
a single word) iff A accepts a hyperword of size at most m.

The assignment tree for Î± and m is deï¬ned as follows. The tree T has k + 1 levels,
where the root is at level 0. For 0 < i â‰¤ k, if Qi = âˆ€, then every node in level i âˆ’ 1 has
m children. If Qi = âˆƒ, then every node in level i âˆ’ 1 has a single child. Every node
v in T is associated with an encoding in [1, m]âˆ— that matches the path from the root to
v. For example, if v is in level 2, and Î± begins with âˆƒâˆ€, and v is the second child, then

15

Figure 2: The labeled assignment tree c(T ) (left), transitions in A (middle), and their depiction in A (right).

the position of v is encoded by 1 Â· 2. The leaves of T are then all encoded by elements
of [1, m]k.

A labeling c of T labels every node (except for the root) by some value in [1, m].
For 0 < i â‰¤ k, if Qi = âˆ€, then the m children of every node in level i âˆ’ 1 are labeled
1 to m. If Qi = âˆƒ, then the child of every node in level i âˆ’ 1 is labeled by some value
in [1, m].

Consider a hyperword S = {w1, w2, . . . wm}. Every path p along c(T ) matches
an assignment of the words in S to the variables in X: the variable xi is assigned wj,
where j is the labeling of the node in level i in p. Then, c(T ) matches a possible set of
assignments of the words of S to the variables in X. Given p, we denote this assignment
by fp. According to the semantics of NFH, we have that A accepts a hyperword of size
m iff there a labeling c(T ) such that for every path p of c(T ), the underlying NFA Ë†A
accepts the word assignment for fp.

We construct A such that a single run of A simultaneously follows every assignment

fp in a labeling c(T ), letter by letter.

Let C be the set of all labelings of T , and let L be the set of all indices of leaves
of T . We deï¬ne the NFA A as follows. The alphabet of A is (Î£ âˆª {#})m. The set
of states of A is QL Ã— C. The set of initial states is QL
0 Ã— C, and the set of accepting
states is F L Ã— C.

ixi

from (((q1, l1), . . . (q|L|, l|L|)), c) to (((q(cid:48)
ery 1 â‰¤ r â‰¤ |L|, there is a transition in Î´ labeled by {Ïƒ(cid:48)
r, where Ïƒ(cid:48)
q(cid:48)

The transition relation of A is as follows. We add a transition labeled (Ïƒ1, Ïƒ2, . . . Ïƒm)
|L|, l|L|)), c(cid:48)) if c = c(cid:48), and for ev-
1, l1), . . . (q(cid:48)
, . . . Ïƒ(cid:48)
} from qr to
= Ïƒj, where j is the labeling of the node in level i in the path to lr in c.
For example, consider the labeled assignment tree c(T ) of Figure 2 for the quan-
tiï¬cation condition âˆ€x1âˆƒx2, and m = 3. Then T has three leaves, labeled 1 Â· 1, 2 Â· 1,
and 3 Â· 1. The labeling c(T ) assigns the nodes of T values in [1, 3] as described in
Figure 2. The three transitions in A from q1, q2, q3 are then translated to the transition
from s = (((q1, 1 Â· 1), (q2, 2 Â· 1), (q3, 3 Â· 1)), c(T )) labeled (a, b, c), which means that
the transition associates label 1 with a, label 2 with b, and label 3 with c, matching the
transitions from q1,q2, and q3, when they are associated with the leaves as in s.

, Ïƒ(cid:48)

kxk

2x2

1x1

The size of T (and hence, the size of L) is O(mk(cid:48)
quantiï¬ers in Î±. Accordingly, the size of C is O(mmk(cid:48)
A is of size O(nmk(cid:48)

Â· mmk(cid:48)

), where n is the number of states in A.

), where k(cid:48) is the number of âˆ€
). Therefore, the state space of

16

3123231â‹…12â‹…13â‹…1ğ‘1ğ‘2ğ‘3ğ‘â€²1ğ‘â€²2ğ‘â€²3ğ‘(ğ‘‡){ğ‘ğ‘¥1,ğ‘ğ‘¥2}{ğ‘ğ‘¥1,ğ‘ğ‘¥2}{ğ‘ğ‘¥1,ğ‘ğ‘¥2}ğ‘11.1ğ‘22.1ğ‘33.1âŒ©ğ‘,ğ‘,ğ‘âŒªğ‘â€²11.1ğ‘â€²22.1ğ‘â€²33.1According to our construction, we have that A accepts a hyperword of size m
iff A is nonempty, when considering only paths that are legal assignments, that is,
once a value i is assigned the letter #, it continues to be assigned #. Checking A
for such nonemptiness can be done on-the-ï¬‚y in space that is logarithmic in the size
of A. Notice, as mentioned in the proof of theorem 6, that for m > 1, the size of
the transition relation of A must be exponential in the size of k(cid:48), to account for the
different assignments to the âˆ€-quantiï¬ers (otherwise, A is empty and we can return
â€œfalseâ€). Therefore, the size of each state of A is polynomial in the size of A, and a
PSPACE upper bound follows.

A PSPACE lower bound for the bounded nonemptiness problem for NFH directly
follows from the nonemptiness problem for NFHâˆƒâˆ€, since, as we prove in Theorem 6,
an NFHâˆƒâˆ€ A with k(cid:48) âˆƒ-quantiï¬ers is nonempty iff it accepts a hyperword of size k(cid:48).
However, we prove PSPACE-hardness for a âˆ€xâˆƒy quantiï¬cation condition, showing
that this problem is PSPACE-hard even for a ï¬xed number of âˆ€ and âˆƒ quantiï¬ers.

Theorem 8. The bounded nonemptiness problem for NFH with Î± = âˆ€xâˆƒy is PSPACE-
hard.

Proof. We reduce from the problem of deciding the nonemptiness of the intersection
of k given NFA, which is known to be PSPACE-hard.

Let A1, A2, . . . Ak be NFA, where Ai = (cid:104)Î£, Qi, Qi

0, Î´i, Fi(cid:105). We construct an NFH
A = (cid:104)Î£(cid:48), {x, y}, Q, Q0, F, Î´, âˆ€xâˆƒy(cid:105) that accepts a hyperword whose size is at most k
iff there exists a word w such that w âˆˆ L(Ai) for every i âˆˆ [1, k].

The set of states Q of A is (cid:83)
i Qi Ã— Q(i+1)modk, and Î£(cid:48) = (cid:83)
i Qi Ã— Î£ Ã— Qi.
The set of accepting states is (cid:83)
i Fi Ã— F(i+1)modk, and the set of initial states Q0
is (cid:83)
0 Ã— Q(i+1)modk
. The transitions are as follows. For every i âˆˆ [1, k], ev-
ery Ïƒ âˆˆ Î£, and every two transitions (q, Ïƒ, q(cid:48)) âˆˆ Î´i, (p, Ïƒ, p(cid:48)) âˆˆ Î´(i+1)modk, we set
((q, p), {(q, Ïƒ, q(cid:48))x, (p, Ïƒ, p(cid:48))y}, (q(cid:48), p(cid:48))) âˆˆ Î´. Notice that the size of A is polynomial
in the sizes of A1, . . . Ak. Every word assignment w that is read along Ë†A describes
the parallel run of Ai and A(i+1)modk on the same word w. The word assignment w is
accepted by Ë†A iff w is accepted by both Ai and A(i+1)modk.

i Qi

0

If there exists a word w that is accepted by all NFA, then the hyperword S that
describes all the matching accepting runs on w by the different NFA is accepted by A.
Indeed, for the accepting run on w by Ai there is a matching accepting run on w by
A(i+1)modk.

Conversely, if there exists a hyperword of size (at most) k that is accepted by A,
then it contains descriptions of runs of A1, . . . Ak on words. By the way we have
deï¬ned A, if there exists r âˆˆ S that describes the accepting run of Ai on a word w,
then there must exist r(cid:48) âˆˆ S that describes the accepting run of A(i+1)modk on w. As a
result, and combined with the size of S, we have that S must contain an accepting run
of every NFA in the set, and these runs must all be on the same word w. Therefore, the
intersection of A1, . . . Ak is nonempty.

As a conclusion from Theorems 7 and 8, we have the following.

Theorem 9. The bounded nonemptiness problem for NFH is PSPACE-complete.

17

6.3. NFH with Wild Card Letters

When constructing an HRE or an NFH, every letter must include an assignment to
all variables. However, an HRE may only need to describe the assignment to a subset
of the variables at each step. For example, the HRE

âˆƒxâˆƒy{ax}{by}

describes hyperwords in which there exist two words, where the ï¬rst word starts with
a, and the second word has b in its second position. Since the ï¬rst letter and the second
letter of the second and ï¬rst words, respectively, do not matter, there is no need to
express them. Therefore, we can deï¬ne a more general and useful notion of HRE in
which the letters are partial functions from X to Î£.

To translate the notion of partial functions to NFH, we simply add a wild-card letter
(cid:63) which can stand for every letter assignment to the variables. For example, the letter
{ax, (cid:63)y} stands for all the assignments to x, y in which x is assigned a.

The size of the alphabet Ë†Î£ of an underlying NFA must be exponential in the size
of the number of âˆ€-quantiï¬ers, to account for all the assignments of letters to all the
variables under âˆ€-quantiï¬ers. Otherwise, the language of the NFH is empty. Using
wild-card letters, such transitions can be replaced by a single transition in which every
variable under âˆ€ is assigned (cid:63). Thus, using wild-card letters can lead to exponentially
smaller NFH.

We deï¬ne NFH with wild cards accordingly. An NFH with wild card letters (NFH(cid:63))
is a tuple A = (cid:104)Î£, X, Q, Q0, F, Î´, Î±(cid:105) whose underlying NFA Ë†A is over the alphabet
Ë†Î£ = (Î£ âˆª {#, (cid:63)})X . The semantics of NFH(cid:63) is similar to that of NFH. The only
difference is that now, wv contains all possible word assignments in which the letters
in Î£ may also be replaced with (cid:63) in the assignments to the variables.

Obviously, every NFH(cid:63) can be translated to an NFH with an exponential blow-up
in the number of transitions. The constructions for intersection, union, and comple-
mentation can all be adjusted to handle the wild cards. Due to the exponential decrease
in size, the complexity of the various decision procedures for NFH(cid:63) may, in the worst
case, increase exponentially. Since the nonemptiness problem is at the core of most
decision procedures, we study its complexity for the various fragments of NFH(cid:63).

We begin with NFH(cid:63)

âˆƒ and NFH(cid:63)

âˆ€, and show that for these fragments, adding wild-

card letters does not change complexity of the nonemptiness problem.

According to the proof of Theorem 5, a simple reachability test on the underlying
NFA sufï¬ces to determine nonemptiness for these fragments. We notice that this holds
also in the presence of wild-card letters. Indeed, an NFH(cid:63)
âˆ€ is nonempty iff it accepts
a hyperword of size 1. The proof of Theorem 5 locates such a word by following an
accepting path in the underlying NFH in which all variables are equally assigned at
every step. It is easy to see that such a path sufï¬ces also when some of the variables
are assigned wild-card letters. Similarly, an accepting path in an NFHâˆƒ induces a ï¬nite
accepted hyperword, and the same holds also when traversing transitions with wild-
card letters. Therefore, we have the following.

Theorem 10. The nonemptiness problem for NFH(cid:63)

âˆƒ and NFH(cid:63)

âˆ€ is NL-complete.

18

We turn to study the fragment of NFH(cid:63)

âˆƒâˆ€. Recall that in the proof for the lower
bound of Theorem 6, we argue that the size of the transition relation of a nonempty
NFHâˆƒâˆ€ must be exponential in its number of âˆ€-quantiï¬ers, which affects the space
complexity analysis of the size of the NFA that we construct. For an NFH(cid:63)
âˆƒâˆ€ A, this ar-
gument no longer holds. While we can construct a similar NFA and check its nonempti-
ness, its size may now be exponential in that of A, conforming to an EXPSPACE up-
per bound. We prove a matching lower bound, and conclude that in contrast to the
alternation-free fragments, adding wild-card letters hardens the nonemptiness problem
for NFHâˆƒâˆ€.
Theorem 11. The nonemptiness problem for NFH(cid:63)

âˆƒâˆ€ is EXPSPACE-complete.

Proof. Let A be an NFHâˆƒâˆ€. Consider the NFA A constructed in the proof of Theo-
rem 6. A similar NFA can be constructed to decide the nonemptiness of A. The only
difference is the need to consider the intersection of letters which carry wild-card let-
, Ïƒ2x2
ters. These can be easily computed: the intersection letter of {Ïƒ1x1
, . . . Ïƒkxk
} and
{Ïƒ(cid:48)
i = (cid:63), and Î³i = Ïƒ(cid:48)
, Î³2x2
i
if Ïƒi = (cid:63), and otherwise it must hold that Î³i = Ïƒi = Ïƒ(cid:48)
i.

}, where Î³i = Ïƒi if Ïƒ(cid:48)

} is {Î³1x1

, . . . Î³kxk

The size of A is, as in the proof of Theorem 6, O(nmkâˆ’m

), where n is the number
of states in A, and m is the number of âˆƒ-quantiï¬ers in Î±. Since the nonemptiness
problem for NFA is NL-complete, an EXPSPACE upper bound follows.

, . . . Ïƒ(cid:48)

, Ïƒ(cid:48)

kxk

2x2

1x1

We turn to the lower bound. As in the proof of Theorem 6, we reduce from the
corridor tiling problem: we are given an input C which consists of a ï¬nite set T of
tiles, two relations V âŠ† T Ã— T and H âŠ† T Ã— T , an initial tile t0, a ï¬nal tile tf , and
a bound n > 0. In the exponential version of this problem, we need to decide whether
there exists a legal tiling of a 2n Ã— m for some m > 0 (in contrast to the polynomial
version which we use for NFHâˆƒâˆ€). This problem is known to be EXPSPACE-complete.
We use a similar idea as for NFHâˆƒâˆ€, and encode the legal solution as a word, while
using the 0âˆ’ and 1âˆ’words under âˆ€ as memory. However, the exponential length of
each row in the tiling poses two main obstacles. First, we can no longer use a state to
remember the index in the row that we need to check in order to verify the vertical con-
dition. Second, we can no longer use numbered letters to mark the index in every row,
and using binary encoding requires verifying that the encoding is correctly ordered.
We describe how we overcome these two obstacles by using wild-card letters.

We encode a solution wsol = $w1 Â· w2 Â· wm$ over Î£ = T âˆª {0, 1, $, &}, where the
word wi, of the form b0 Â· t0,i Â· b1 Â· t2,i, . . . b2nâˆ’1 Â· t2nâˆ’1,i, describes the contents of row
i, where bj is the n-bit binary encoding of index j. Additionally, we use the 0-word
which only consists of 0 letters, and similarly we use the 1-word. Here, we precede the
sequence of bits with &.

NFH(cid:63)

a

an

We

construct

quantiï¬cation

âˆƒâˆ€ A with
condition
Î± = âˆƒsâˆƒx0âˆƒx1âˆ€uâˆ€y1 . . . âˆ€ynâˆ€z1 . . . âˆ€zn that is nonempty iff C has a solution. In-
tuitively, as in the proof of Theorem 6, the assignment to s must be wsol, and the
assignment to x0 and x1 must be the 0- and the 1-words, respectively. The assignment
to u must be equal to the assignment of either s, x0, or x1. Notice that since u is under
âˆ€, then if A is nonempty then the only hyperword it can accept is {wsol, 0, 1}. There-
fore, the rest of the variables must always be assigned one of these three words in order
for A to accept.

19

When the assignments to y1 . . . yn are the 0- and 1- words, their binary values
are used for encoding a single index j that veriï¬es that every two consecutive tiles in
position j satisfy V , as we describe below. Ë†A accepts all runs in which one of the y
variables is assigned wsol. To this end, the transition relation Î´ of Ë†A uses transitions
from the initial state labeled by letters in which one of y1, . . . yn is assigned $ and the
rest are assigned (cid:63), leading to accepting runs for these cases.

To match the encoding of the y variables with the correct index j in wsol, the
transition relation Î´ of A describes the n bits of j in cycles of length n + 1, where in
each cycle, the iâ€™th bit of j is speciï¬ed in the iâ€™th step, and the rest of the values are
represented as (cid:63). In each cycle, the iâ€™th bit is compared with the iâ€™th bit in wsol. In
cycles in which all n index bits in wsol match those of y1 . . . yn, the tile in the letter
that follows the encoding (the n + 1â€™th letter in the cycle) is matched with the previous
tile, remembered by a state, to verify that they satisfy V .

For example, for n = 3, the encoding 101 would be as follows.

ï£«

ï£­

y1 = & 1
y2 = & (cid:63)
y3 = & (cid:63)

(cid:63)
0
(cid:63)

(cid:63)
(cid:63)
1

(cid:63)
(cid:63)
(cid:63)

1
(cid:63)
(cid:63)

(cid:63)
0
(cid:63)

ï£¶

ï£¸

(cid:63) Â· Â· Â·
(cid:63) Â· Â· Â·
1 Â· Â· Â·

Notice that (considering only y variables), only 2n + 2 letters are needed to describe
this encoding: two for every value of the iâ€™th bit, one of all wild-cards, and one for all
&. Specifying all bits in a single letter would require exponentially many letters.

We now describe how to verify that the index encoding along wsol is correct. We
use the z variables in a similar way to the y variables, to encode the successor position
of the one encoded in the y variables. To check that they are indeed successors, it
sufï¬ces to check, within the ï¬rst cycle, that all bits up to some 1 â‰¤ i < n are equal,
that zi = 1 and yi = 0, and that yi+1 . . . yn = 1 and zi+1 . . . zn = 0 (the only
exception is for 2n + 1 and 0, in which we only need to check that all y bits are 1 and
all z bits are 0). Runs of Ë†A in which the encoding in the z variables is not the successor
of the encoding of the y variables, or in which one of the z variables is assigned wsol,
are accepting. Otherwise, whenever the encoding of the position in wsol is equal to that
of the y variables (we check this bit by bit), we check that the encoding of the position
in the next cycle is equal to that of the z variables.

For example, for checking the successor of 101, the assignments to the y and z

variables would be as follows.

ï£«

ï£¬
ï£¬
ï£¬
ï£¬
ï£¬
ï£¬
ï£­

y1 = & 1
y2 = & (cid:63)
y3 = & (cid:63)
z1 = & 1
z2 = & (cid:63)
z3 = & (cid:63)

(cid:63)
0
(cid:63)
(cid:63)
1
(cid:63)

(cid:63)
(cid:63)
1
(cid:63)
(cid:63)
0

(cid:63)
(cid:63)
(cid:63)
(cid:63)
(cid:63)
(cid:63)

1
(cid:63)
(cid:63)
1
(cid:63)
(cid:63)

(cid:63)
0
(cid:63)
(cid:63)
1
(cid:63)

ï£¶

ï£·
ï£·
ï£·
ï£·
ï£·
ï£·
ï£¸

(cid:63) Â· Â· Â·
(cid:63) Â· Â· Â·
1 Â· Â· Â·
(cid:63) Â· Â· Â·
(cid:63) Â· Â· Â·
0 Â· Â· Â·

Since the y and z variables are under âˆ€, all positions along wsol are checked over
all runs of Ë†A on the different assignments to the y and z variables. It is left to check
that the ï¬rst position in wsol is 0n, and the last position is 1n, which can be done via
states.

20

Checking the horizontal condition itself can be done by comparing every two con-
secutive tiles in the same row. These tiles are n letters apart, and so this can be done via
the states and does not require using the variables as memory. The rest of the checks,
i.e, the identity of the ï¬rst and last tiles, and the correct form of wsol, can also be easily
checked by the states.

In every letter of Ë†A (other than the ï¬rst in the run, in which all y and z variables are
assigned &), there are at most six non-wild card letters: the assignments to s, x0, x1
and u, and yi and zi for some 1 â‰¤ i â‰¤ n, and additionally the letters in which one of
the y or z variables is assigned with a word that starts with $. Therefore, the alphabet
of A is polynomial in the input. The number of states needed for the various checks is
also polynomial, and therefore the size of A is polynomial in |C|.

6.4. A semi-algorithm for deciding the nonemptiness for âˆ€âˆƒ

The nonemptiness problem for NFH is undecidable already for the fragment of âˆ€âˆƒ,
as shown in Theorem 4. However, this fragment is of practical use in expressing ï¬nite-
word properties, as shown in Section 3. We now describe a semi-algorithm for testing
the nonemptiness of an NFH with a quantiï¬cation condition of the type âˆ€âˆƒ. Intuitively,
this procedure aims at ï¬nding the largest hyperword that is accepted by the NFH.

The procedure ï¬rst considers the set L0 of all the words that can be assigned to x1,
and checks whether this set subsumes the matching assignments for the âˆƒ quantiï¬er. If
so, then L0 is a suitable hyperword. Otherwise, L0 is pruned to the largest potential
hyperword by omitting from L0 all words that are not assigned to the variable under âˆƒ,
and the procedure continues to the next round. In case that the procedure does not ï¬nd
an accepted hyperword, or conversely if the procedure does not reach an empty set, it
does not halt.

L0
exists a word in L0
We deï¬ne L1

âˆ€ = {u|âˆƒv : wx(cid:55)â†’u,y(cid:55)â†’v âˆˆ L( Ë†A)}, and let L0

We describe our procedure with more detail. Let A = (cid:104)Î£, {x, y}, Q, Q0, F, Î´, âˆ€xâˆƒy(cid:105)
be an NFH. Let L0
âˆƒ = {v|âˆƒu : wx(cid:55)â†’u,y(cid:55)â†’v âˆˆ
L( Ë†A)}. We denote the NFA obtained from Ë†A by restricting the transitions to assign-
âˆ€ = Ë†Ax is an NFA
ments to x by Ë†Ax, and similarly deï¬ne Ë†Ay. It is easy to see that A0
for L0

âˆ€, and A0
âˆƒ âŠ† L0
If L0
âˆ€ is accepted by A. If
âˆƒ âˆ© L0
âˆ€ = âˆ…, then by the semantics of NFH, we have that A is empty. Otherwise, there

âˆƒ = Ë†Ay is an NFA for L0
âˆƒ.
âˆ€, then by the semantics of NFH, we have that L0

âˆ€, and vice versa.

âˆ€. Notice that L1

âˆƒ is regular, and an NFA A1
âˆƒ. Now L1
âˆ€ and A0

âˆƒ that is not in L0
âˆƒ âˆ© L0
âˆƒ = L0
âˆƒ for L1
âˆƒ
can be calculated by the intersection construction for A0
âˆƒ âŠ† L0
âˆ€.
However, it may be the case that there exists a word u âˆˆ L0
âˆ€ for which there ex-
ists no matching v âˆˆ L1
âˆ€ = {u|âˆƒv âˆˆ L1
âˆƒ :
wx(cid:55)â†’u,y(cid:55)â†’v âˆˆ L( Ë†A)}. We calculate an NFA A1
âˆ€ for L1, as follows. Let A0
âˆƒ =
(cid:104)P, Î£, p0, Î´0, F0(cid:105). We deï¬ne Ë†A1 = (cid:104)Q Ã— P, (Î£ âˆª {#}){x,y}, (q0, p0), Î´1, F1 Ã— F2(cid:105),
y}, q(cid:48)) âˆˆ Î´, (p, Ïƒ(cid:48), p(cid:48)) âˆˆ
where Î´1 = {((q, p), {Ïƒ(cid:48)
x, Ïƒy}, (q(cid:48), p(cid:48))|Ïƒ, Ïƒ(cid:48) âˆˆ Î£, (q, {Ïƒx, Ïƒ(cid:48)
Î´0}. That is, Ë†A1 is roughly the intersection construction of Ë†A and A0
âˆƒ, when consider-
ing only the letter assignments to y. We denote this construction by âˆ©y. Finally, we set
A1

âˆƒ. Therefore, we restrict L0

âˆ€ to a set L1

âˆƒ)âˆ©L(A1
then L(A) = âˆ…. Otherwise, we repeat the process above with respect to Ë†A1, A1

âˆ€) is accepted by A, and if L(A1

âˆ€), then L(A1

âˆƒ) âŠ† L(A1

âˆ€) = âˆ…,
âˆ€, A1
âˆƒ.

âˆ€ = Ë†A1
x.
Now, if L(A1

21

Algorithm 1 describes the procedure.

Algorithm 1: Nonemptiness test for âˆ€âˆƒ

Input: A.
Output: L(A) (cid:54)= âˆ…?
1 Aâˆ€ = Ë†Ax, Aâˆƒ = Ë†Ay
2 while true do
3

if L(Aâˆƒ) âŠ† L(Aâˆ€) then

return tt

else if L(Aâˆƒ) âˆ© L(Aâˆ€) = âˆ… then

4

5

6

7

8

return ff
Aâˆƒ = Aâˆƒ âˆ© Aâˆ€
Ë†A = Ë†A âˆ©y Aâˆƒ
Aâˆ€ = Ë†Ax

9
10 endwhile

7. Additional decision procedures

The universality problem is to decide whether a given NFH A accepts every hy-
perword over Î£. Notice that A is universal iff A is empty. Since complementing an
NFH involves an exponential blow-up, we conclude the following from the results in
Section 6, combined with the PSPACE lower bound for the universality of NFA.

Theorem 12. The universality problem for

1. NFH is undecidable,

2. NFHâˆƒ and NFHâˆ€ is PSPACE-complete, and

3. NFHâˆ€âˆƒ is in EXPSPACE.

We turn to study the membership problem for NFH: given an NFH A and a hyper-
word S, is S âˆˆ L(A)? When S is ï¬nite, so is the set of assignments from X to S, and
so the problem is decidable. We call this case the ï¬nite membership problem.

Theorem 13.

â€¢ The ï¬nite membership problem for NFH is in PSPACE.

â€¢ The ï¬nite membership problem for a hyperword of size k and an NFH with

O(log(k)) âˆ€ quantiï¬ers is NP-complete.

Proof. Let S be a ï¬nite hyperword, and let A be an NFH with k variables. We can
decide the membership of S in L(A) by iterating over all relevant assignments from X
to S, and for every such assignment v, checking on-the-ï¬‚y whether wv is accepted by
Ë†A. This algorithm uses space of size that is polynomial in k and logarithmic in |A|.

In the case that the number of âˆ€ quantiï¬ers is O(log k), an NP upper bound is met
by iterating over all assignments to the variables under âˆ€, while guessing assignments

22

to the variables under âˆƒ. For every such assignment v, checking whether wv âˆˆ L( Ë†A)
can be done on-the-ï¬‚y.

We show NP-hardness for this case by a reduction from the Hamiltonian cycle
problem. Given a graph G = (cid:104)V, E(cid:105) where V = {v1, v2, . . . , vn} and |E| = m,
we construct an NFHâˆƒ A over {0, 1} with n states, n variables, Î´ of size m, and
a hyperword S of size n, as follows. S = {w1, . . . , wn}, where wi is the word over
{0, 1} in which all letters are 0 except for the iâ€™th. The structure of Ë†A is identical to that
of G, and we set Q0 = F = {v1}. For the transition relation, for every (vi, vj) âˆˆ E,
we have (vi, Ï•i, vj) âˆˆ Î´, where Ï•i assigns 0 to all variables except for xi. Intuitively,
the iâ€™th letter in an accepting run of Ë†A marks traversing vi. Assigning wj to xi means
that the jâ€™th step of the run traverses vi. Since the words in w make sure that every
v âˆˆ V is traversed exactly once, and that the run on them is of length n, we have that A
accepts S iff there exists some ordering of the words in S that matches a Hamiltonian
cycle in G.
remark To account for all the assignments to the âˆ€ variables, Î´ â€“ and therefore, Ë†A
â€“ must be of size at least 2k(cid:48)
(otherwise, we can return â€œnoâ€). We then have that if
k = O(k(cid:48)), then space of size k is logarithmic in | Ë†A|, and so the problem in this case
can be solved within logarithmic space. A matching NL lower bound follows from the
membership problem for NFA.

When S is inï¬nite, it may still be ï¬nitely represented, allowing for algorithmic
membership testing. We now address the problem of deciding whether a regular lan-
guage L (given as an NFA) is accepted by an NFH. We call this the regular membership
problem for NFH. We show that this problem is decidable for the entire class of NFH.

Theorem 14. The regular membership problem for NFH is decidable.

Proof. Let A = (cid:104)Î£, P, P0, Ï, F (cid:105) be an NFA, and let A = (cid:104)Î£, {x1, . . . , xk}, Q, Q0,
Î´, F, Î±(cid:105) be an NFH.

First, we construct an NFA A(cid:48) = (cid:104)Î£ âˆª {#}, P (cid:48), P (cid:48)

0, Ï(cid:48), F (cid:48)(cid:105) by extending the alpha-
bet of A to Î£ âˆª {#}, adding a new and accepting state pf to P with a self-loop labeled
by #, and transitions labeled by # from every q âˆˆ F to pf . The language of A(cid:48) is then
L(A) Â· #âˆ—. We describe a recursive procedure (iterating over Î±) for deciding whether
L(A) âˆˆ L(A).

For the case that k = 1, if Î± = âˆƒx1, then L(A) âˆˆ L(A) iff L(A) âˆ© L( Ë†A) (cid:54)= âˆ….
Otherwise, if Î± = âˆ€x1, then L(A) âˆˆ L(A) iff L(A) /âˆˆ L(A), where A is the NFH for
L(A). The quantiï¬cation condition for A is âˆƒx1, conforming to the base case.

For k > 1, we construct a sequence of NFA Ak, Akâˆ’1 . . . , A1 as follows. Initially,
i , Î´i, Fi(cid:105). If Qi = âˆƒ , then we construct Aiâˆ’1 as follows.
i Ã— P0. The set
f (xi)
âˆ’âˆ’âˆ’â†’ p(cid:48)) âˆˆ Ï,

Ak = Ë†A. Let Ai = (cid:104)Î£i, Qi, Q0
The set of states of Aiâˆ’1 is Qi Ã— P , and the set of initial states is Q0
f
âˆ’â†’ q(cid:48)) âˆˆ Î´i and every (p
of accepting states is Fi Ã— F . For every (q

}

f \{Ïƒixi
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q(cid:48), p(cid:48))) âˆˆ Î´iâˆ’1. We denote this construction by A âˆ©xi Ai.
we have ((q, p)
Then, Aiâˆ’1 accepts a word assignment wv iff there exists a word u âˆˆ L(A), such that
Ai accepts wvâˆª{xi(cid:55)â†’u}.

If Qi = âˆ€, then we set Aiâˆ’1 = A âˆ©xi Ai Notice that Aiâˆ’1 accepts a word assign-

ment wv iff for every u âˆˆ L(A), it holds that Ai accepts wvâˆª{xi(cid:55)â†’u}.

23

For

i âˆˆ [1, k],

let Ai be the NFH whose quantiï¬cation condition is
Î±i = Q1x1 Â· Â· Â· Qixi, and whose underlying NFA is Ai. Then, according to the con-
struction of Aiâˆ’1, we have that L(A) âˆˆ L(Ai) iff L(A) âˆˆ L(Aiâˆ’1).

The NFH A1 has a single variable, and we can now apply the base case.
Every âˆ€ quantiï¬er requires complementation, which is exponential in |Q|. There-

fore, in the worst case, the complexity of this algorithm is O(22...|Q||A|
), where the
tower is of height k. If the number of âˆ€ quantiï¬ers is ï¬xed, then the complexity is
O(|Q||A|k).

The containment problem is to decide, given NFH A1 and A2, whether L(A1) âŠ†
L(A2). Since we can reduce the nonemptiness problem to the containment problem,
we have the following as a result of Theorem 4.

Theorem 15. The containment problem for NFH is undecidable.

However, the containment problem is decidable for various fragments of NFH.

Theorem 16. The containment problem of NFHâˆƒ âŠ† NFHâˆ€ and NFHâˆ€ âŠ† NFHâˆƒ is
PSPACE-complete. The containment problem of NFHâˆƒâˆ€ âŠ† NFHâˆ€âˆƒ is in EXPSPACE

Proof. A lower bound for all cases follows from the PSPACE-hardness of the contain-
ment problem for NFA. For the upper bound, for two NFH A1 and A2, we have that
L(A1) âŠ† L(A2) iff L(A1) âˆ© L(A2) = âˆ…. We can compute an NFH A = A1 âˆ© A2
(Theorems 1, 3), and check its nonemptiness. Complementing A2 is exponential in its
number of states, and the intersection construction is polynomial.

If A1 âˆˆ NFHâˆƒ and A2 âˆˆ NFHâˆ€ or vice versa, then A is an NFHâˆƒ or NFHâˆ€,

respectively, whose nonemptiness can be decided in space that is logarithmic in |A|.

The quantiï¬cation condition of an NFH for the intersection may be any interleaving
of the quantiï¬cation conditions of the two intersected NFH. (Theorem 3). Therefore,
for the rest of the fragments, we can construct the intersection such that A is an NFHâˆƒâˆ€.
The exponential blow-up in complementing A2, along with The PSPACE upper bound
of Theorem 6 gives an EXPSPACE upper bound for the rest of the cases.

8. Related Work

It is well-known that classic speciï¬cation languages like regular expressions and
LTL cannot express hyperproperties. The study of speciï¬c hyperproperties, such as
noninterference, dates back to the seminal work by Goguen and Meseguer [29] in the
1980s. The ï¬rst systematic study of hyperproperties is due to Clarkson and Schnei-
der [14]. Subsequently, temporal logics HyperLTL and HyperCTL* were introduced [13]
to give formal syntax and semantics to hyperproperties. HyperLTL was recently ex-
tended to A-HLTL [6] to capture asynchronous hyperproperties, where some execution
traces can stutter while others advance.

There has been much recent progress in automatically verifying [27, 26, 25, 15, 31]
and monitoring [3, 24, 11, 9, 23, 35, 30] HyperLTL speciï¬cations. HyperLTL is also
supported by a growing set of tools, including the model checkers HyperQube [31],

24

MCHyper [27, 15], the satisï¬ability checkers EAHyper [22] and MGHyper [20], and
the runtime monitoring tool RVHyper [23].

Related to the nonemptiness problem in this paper is the satisï¬ability problem for
HyperLTL, which was shown to be decidable for the âˆƒâˆ—âˆ€âˆ— fragment, and undecidable
for any fragment that includes a âˆ€âˆƒ quantiï¬er alternation [19]. The hierarchy of hyper-
logics beyond HyperLTL has been studied in [16]. Furthermore, our other results are
aligned with the complexity of HyperLTL model checking for tree-shaped and general
Kripke structures [5], which encode ï¬nite traces. In particular, our membership results
are in line with the results on the complexity of veriï¬cation in [5]. This shows that
the complexity results in [5] mainly stem from the nature of quantiï¬cation over ï¬nite
words and depend on neither the full power of the temporal operators nor the inï¬nite
nature of HyperLTL semantics.

The synthesis problem has shown to be undecidable in general, and decidable for
the âˆƒâˆ— and âˆƒâˆ—âˆ€ fragments. While the synthesis problem becomes, in general, unde-
cidable as soon as there are two universal quantiï¬ers, there is a special class of uni-
versal speciï¬cations, called the linear âˆ€âˆ—-fragment, which is still decidable [21]. The
linear âˆ€âˆ—-fragment corresponds to the decidable distributed synthesis problems. The
bounded synthesis problem considers only systems up to a given bound on the number
of states. Bounded synthesis from hyperproperties is studied in [21], and has been suc-
cessfully applied to small examples such as the dining cryptographers [12]. Program
repair and controller synthesis for HyperLTL have been studied in [7, 8]. Our results on
bounded nonemptiness complement the known results, as it resembles the complexity
of bounded synthesis.

9. Discussion and Future Work

We have introduced and studied hyperlanguages and a framework for their model-
ing, focusing on the basic class of regular hyperlanguages, modeled by HRE and NFH.
We have shown that regular hyperlanguages are closed under set operations and are
capable of expressing important hyperproperties for information-ï¬‚ow security policies
over ï¬nite traces. We have also investigated fundamental decision procedures for var-
ious fragments of NFH, conscentrating mostly on the important decision problem of
nonemptiness. Some gaps, such as the precise lower bound for the universality and
containment problems for NFHâˆƒâˆ€, are left open.

Since our framework does not limit the type of underlying model, it can be lifted
to handle hyperwords consisting of inï¬nite words, with an underlying model designed
for such languages, such as nondeterministic BÂ¨uchi automata, which model Ï‰-regular
languages. Just as BÂ¨uchi automata can express LTL, such a model can express the
entire logic of HyperLTL [13].

As future work, we plan on studying non-regular hyperlanguages (e.g., context-
free), and object hyperlanguages (e.g., trees). Another direction is designing learning
algorithms for hyperlanguages, by exploiting known canonical forms for the underly-
ing models, and basing on existing learning algorithms for them. The main challenge
would be handling learning sets and a mechanism for learning word variables and quan-
tiï¬ers.

25

References

[1]

Â´AbrahÂ´am, E., Bartocci, E., Bonakdarpour, B., Dobe, O.: Probabilistic hyperprop-
erties with nondeterminism. In: Proceedings of the 18th Symposium on Auto-
mated Technology for Veriï¬cation and Analysis (ATVA). pp. 518â€“534 (2020)

[2]

Â´AbrahÂ´am, E., Bonakdarpour, B.: HyperPCTL: A temporal logic for probabilistic
hyperproperties. In: QEST. pp. 20â€“35 (2018)

[3] Agrawal, S., Bonakdarpour, B.: Runtime veriï¬cation of k-safety hyperproperties
in HyperLTL. In: Proceedings of the IEEE 29th Computer Security Foundations
(CSF). pp. 239â€“252 (2016)

[4] Alpern, B., Schneider, F.: Deï¬ning liveness. Information Processing Letters pp.

181â€“185 (1985)

[5] B. Bonakdarpour, B., Finkbeiner, B.: The complexity of monitoring hyperprop-

erties. In: CSF. pp. 162â€“174 (2018)

[6] Baumeister, J., Coenen, N., Bonakdarpour, B., SÂ´anchez, B.F.C.: A temporal logic
for asynchronous hyperproperties. In: Proceedings of the 33rd International Con-
ference on Computer-Aided Veriï¬cation (CAV) (2021), to appear

[7] Bonakdarpour, B., Finkbeiner, B.: Program repair for hyperproperties. In: Pro-
ceedings of the 17th Symposium on Automated Technology for Veriï¬cation and
Analysis (ATVA). pp. 423â€“441 (2019)

[8] Bonakdarpour, B., Finkbeiner, B.: Controller synthesis for hyperproperties. In:
Proceedings of the IEEE 32th Computer Security Foundations (CSF). pp. 366â€“
379 (2020)

[9] Bonakdarpour, B., SÂ´anchez, C., Schneider, G.: Monitoring hyperproperties by
combining static analysis and runtime veriï¬cation. In: ISoLA. pp. 8â€“27 (2018)

[10] Bonakdarpour, B., Sheinvald, S.: Finite-word hyperlanguages. In: Language and
Automata Theory and Applications - 15th International Conference, LATA 2021,
Milan, Italy, March 1-5, 2021, Proceedings. Lecture Notes in Computer Science,
vol. 12638, pp. 173â€“186. Springer (2021)

[11] Brett, N., Siddique, U., Bonakdarpour, B.: Rewriting-based runtime veriï¬cation
for alternation-free HyperLTL. In: Proceedings of the 23rd International Con-
ference on Tools and Algorithms for the Construction and Analysis of Systems
(TACAS). pp. 77â€“93 (2017)

[12] Chaum, D.: Security without identiï¬cation: Transaction systems to make big
brother obsolete. Communications of the ACM 28(10), 1030â€“1044 (1985)

[13] Clarkson, M., Finkbeiner, B., Koleini, M., Micinski, K., Rabe, M., SÂ´anchez, C.:

Temporal logics for hyperproperties. In: POST. pp. 265â€“284 (2014)

26

[14] Clarkson, M., Schneider, F.: Hyperproperties. Journal of Computer Security pp.

1157â€“1210 (2010)

[15] Coenen, N., Finkbeiner, B., C. SÂ´anchez, C., Tentrup, L.: Verifying hyperliveness.

In: CAV. pp. 121â€“139 (2019)

[16] Coenen, N., Finkbeiner, B., Hahn, C., Hofmann, J.: The hierarchy of hyperlog-
ics. In: Proceedings 34th Annual ACM/IEEE Symposium on Logic in Computer
Science (LICS). pp. 1â€“13 (2019)

[17] Emerson, E.A., Halpern, J.: â€œsometimesâ€ and â€œnot neverâ€ revisited: on branching
versus linear time temporal logic. Journal of the ACM pp. 151â€“178 (1986)

[18] Finkbeiner, B., Haas, L., Torfah, H.: Canonical representations of k-safety hyper-

properties. In: CSF 2019. pp. 17â€“31 (2019)

[19] Finkbeiner, B., Hahn, C.: Deciding hyperproperties. In: CONCUR. pp. 13:1â€“

13:14 (2016)

[20] Finkbeiner, B., Hahn, C., Hans, T.: MGHyper: Checking satisï¬ability of Hyper-
LTL formulas beyond the \exists Ë†*\forall Ë†* âˆƒ âˆ— âˆ€ âˆ— fragment. In: Proceedings
of the 16th International Symposium on Automated Technology for Veriï¬cation
and Analysis (ATVA). pp. 521â€“527 (2018)

[21] Finkbeiner, B., Hahn, C., Lukert, P., Stenger, M., Tentrup, L.: Synthesizing re-
active systems from hyperproperties. In: Proceedings of the 30th International
Confer ence on Computer Aided Veriï¬cation (CAV). pp. 289â€“306 (2018)

[22] Finkbeiner, B., Hahn, C., Stenger, M.: Eahyper: Satisï¬ability, implication, and
equivalence checking of hyperproperties. In: Proceedings of the 29th Interna-
tional Conference on Computer Aided Veriï¬cation (CAV). pp. 564â€“570 (2017)

[23] Finkbeiner, B., Hahn, C., Stenger, M., Tentrup, L.: RVHyper: A runtime veriï¬ca-
tion tool for temporal hyperproperties. In: Proceedings of the 24th International
Conference on Tools and Algorithms for the Construction and Analysis of Sys-
tems (TACAS). pp. 194â€“200 (2018)

[24] Finkbeiner, B., Hahn, C., Stenger, M., Tentrup, L.: Monitoring hyperproperties.

Formal Methods in System Design (FMSD) 54(3), 336â€“363 (2019)

[25] Finkbeiner, B., Hahn, C., Torfah, H.: Model checking quantitative hyperproper-
ties. In: Proceedings of the 30th International Conference on Computer Aided
Veriï¬cation. pp. 144â€“163 (2018)

[26] Finkbeiner, B., MÂ¨uller, C., Seidl, H., Zalinescu, E.: Verifying Security Policies in
Multi-agent Workï¬‚ows with Loops. In: Proceedings of the 15th ACM Conference
on Computer and Communications Security (CCS) (2017)

[27] Finkbeiner, B., Rabe, M.N., SÂ´anchez, C.: Algorithms for model checking Hyper-
LTL and HyperCTL*. In: Proceedings of the 27th International Conference on
Computer Aided Veriï¬cation (CAV). pp. 30â€“48 (2015)

27

[28] G. Boudol, G., Castellani, I.: Noninterference for concurrent programs and

thread. In: TCS 2002. pp. 109â€“130 (2002)

[29] Goguen, J., Meseguer, J.: Security policies and security models. In: IEEE Symp.

on Security and Privacy. pp. 11â€“20 (1982)

[30] Hahn, C., Stenger, M., Tentrup, L.: Constraint-based monitoring of hyperprop-
erties. In: Proceedings of the 25th International Conference on Tools and Al-
gorithms for the Construction and Analysis of Systems (TACAS). pp. 115â€“131
(2019)

[31] Hsu, T.H., SÂ´anchez, C., Bonakdarpour, B.: Bounded model checking for hyper-
properties. In: Proceedings of the 27th International Conference on Tools and Al-
gorithms for Construction and Analysis of Systems (TACAS). pp. 94â€“112 (2021)

[32] McCullough, D.: Noninterference and the composability of security properties.
In: Proceedings of the 1988 IEEE Symposium on Security and Privacy. pp. 177â€“
186 (1988)

[33] Pnueli, A.: The temporal logic of programs. In: FOCS. pp. 46â€“57 (1977)

[34] Sabelfeld, A., Sands, D.: Probabilistic noninterference for multi-threaded pro-

grams. In: CSFW. pp. 200â€“214 (2000)

[35] Stucki, S., SÂ´anchez, C., Schneider, G., Bonakdarpour, B.: Graybox monitoring of
hyperproperties. In: Proceedings of the 23rd International Symposium on Formal
Methods (FM). pp. 406â€“424 (2019)

[36] Vardi, M., Wolper, P.: Automata theoretic techniques for modal logic of pro-

grams. Journal of Computer and System Sciences pp. 183â€“221 (1986)

[37] Vardi, M., Wolper, P.: Reasoning about inï¬nite computations. Information and

Computation pp. 1â€“37 (1994)

[38] Wang, Y., Zarei, M., Bonakdarpour, B., Pajic, M.: Statistical veriï¬cation of hy-
perproperties for cyber-physical systems. ACM Transactions on Embedded Com-
puting systems (TECS) pp. 92:1â€“92:23 (2019)

[39] Zdancewic, S., Myers, A.: Observational determinism for concurrent program

security. In: CSFW. p. 29 (2003)

28

