2
2
0
2

n
a
J

5

]
L
F
.
s
c
[

1
v
0
7
6
1
0
.
1
0
2
2
:
v
i
X
r
a

Finite-Word Hyperlanguages

Borzoo Bonakdarpoura, Sarai Sheinvaldb

aDepartment of Computer Science and Engineering, Michigan State University, USA
bDepartment of Software Engineering, ORT Braude College, Israel

Abstract

Formal languages are in the core of models of computation and their behavior. A
rich family of models for many classes of languages have been widely studied. Hyper-
properties lift conventional trace-based languages from a set of execution traces to a
set of sets of executions. Hyperproperties have been shown to be a powerful formalism
for expressing and reasoning about information-ﬂow security policies and important
properties of cyber-physical systems. Although there is an extensive body of work on
formal-language representation of trace properties, we currently lack such a general
characterization for hyperproperties.

We introduce hyperlanguages over ﬁnite words and models for expressing them.
Essentially, these models express multiple words by using assignments to quantiﬁed
word variables. Relying on the standard models for regular languages, we propose
hyperregular expressions and ﬁnite-word hyperautomata (NFH), for modeling the class
of regular hyperlanguages. We demonstrate the ability of regular hyperlanguages to
express hyperproperties for ﬁnite traces. We explore the closure properties and the
complexity of the fundamental decision problems such as nonemptiness, universality,
membership, and containment for various fragments of NFH.

1. Introduction

Formal languages, along with the models that express them, are in the core of
modeling, speciﬁcation, and veriﬁcation of computing systems. Execution traces are
formally described as words, and various families of automata are used for modeling
systems of different types. Regular languages are a classic formalism for ﬁnite traces
and when the traces are inﬁnite, ω-regular languages are used.

There are well-known connections between speciﬁcation logics and formal lan-
guages. For example, LTL [33] formulas can be translated to ω-regular expressions,
and CTL∗ [17] formulas can be expressed using tree automata. Accordingly, many ver-
iﬁcation techniques that exploit these relations have been developed. For instance, in
the automata-theoretic approach to veriﬁcation [36, 37], the model-checking problem

Email addresses: borzoo@msu.edu (Borzoo Bonakdarpour), sarai@braude.ac.il (Sarai

Sheinvald)

Preprint submitted to Elsevier

 
 
 
 
 
 
is reduced to checking the nonemptiness of the product automaton of the model and
the complement of the speciﬁcation.

Hyperproperties [14] generalize the traditional trace properties [4] to system prop-
erties, i.e., a set of sets of traces. A hyperproperty prescribes how the system should
behave in its entirety and not just based on its individual executions. Hyperproperties
have been shown to be a powerful tool for expressing and reasoning about information-
ﬂow security policies [14] and important properties of cyber-physical systems [38] such
as sensitivity and robustness, as well as consistency conditions in distributed comput-
ing such as linearizability [9]. While different types of logics have been suggested
for expressing hyperproperties, their formal-language counterparts and the models that
express them are currently missing.

In this paper, we establish a formal-language theoretical framework for hyperlan-
guages, that are sets of sets of words, which we term hyperwords. Our framework is
based on an underlying standard automata model for formal languages, augmented with
quantiﬁed word variables that are assigned words from a set of words in the hyperlan-
guage. This formalism is in line with logics for hyperproperties (e.g., HyperLTL [13]
and HyperPCTL [2, 1]). These logics express the behavior of inﬁnite trace systems.
However, a basic formal model for expressing general hyperproperties for ﬁnite words
has not been deﬁned yet.

To begin with the basics, we focus this paper on a regular type of hyperlanguages
of sets consisting of ﬁnite words, which we call regular hyperlanguages. The models
we introduce and study are based on the standard models for regular languages, namely
regular expressions and ﬁnite-word automata.

1.1. Motivation and Applications

Hyperlanguages based on ﬁnite words have many practical applications. Let us ﬁrst

explain the idea of hyperlanguages with two examples.

Example 1. Consider the following hyperregular expression (HRE) over the alphabet
{a}.

r1 = ∀x.∃y.

(cid:16)

(cid:124)

{ax, ay}∗{#x, ay}∗(cid:17)
(cid:123)(cid:122)
(cid:125)
ˆr1

The HRE r1 uses two word variables x and y, which are assigned words from a hy-
perword. The HRE r1 contains an underlying regular expression ˆr1, whose alphabet
is ({a} ∪ {#}){x,y}, and whose (regular) language describes different word assign-
ments to x and y, where # is used for padding at the end if the words assigned to
x and y are of different lengths. In a word in the language of ˆr1, the i’th letter de-
scribes both i’th letters in the words assigned to x and y. For example, the word
{ax, ay}{ax, ay}{#x, ay} describes the assignment x (cid:55)→ aa, y (cid:55)→ aaa. The regular
expression ˆr1 requires that the word assigned to y be longer than the word assigned
to x. The quantiﬁcation condition ∀x.∃y of r1 requires that for every word in a hy-
perword S in the hyperlanguage of r1, there exists a longer word in S. This holds iff
S contains inﬁnitely many words. Therefore, the hyperlanguage of r1 is the set of all
inﬁnite hyperwords over {a}.

2

Example 2. Path planning objectives for robotic systems often stipulate the existence
of one or more ﬁnite paths that stand out from all other paths. For example, robotics
applications are often concerned with ﬁnding the shortest path that reaches a goal g,
starting from an initial location i. The shortest path requirement can be expressed by
the following HRE over an alphabet Σ:

r2 = ∃x.∀y.{ix, iy}{¯gx, ¯gy}∗(cid:16)

{gx, ¯gy} | {gx, gy}

(cid:17)

{#x, $y}∗

where ¯g ∈ Σ − {g} and $ ∈ Σ. That is, there exists a path x that is shorter than any
other path y in reaching g.

Another interesting application in robotics is in adversarial settings, where some
robots may interfere (e.g., act as moving obstacles) with a set of controllable robots.
In this scenario, given any behavior of the adversarial robots, the controllable robots
should be able to achieve their operation objectives. This speciﬁcation is in general of
the following form:

r3 = ∀x1.∀x2 . . . ∀xn
(cid:125)

(cid:124)

(cid:123)(cid:122)
advarsaries

. ∃y1.∃y2 . . . ∃ym
(cid:123)(cid:122)
(cid:125)
(cid:124)
controllable

.ˆr

where words x1 · · · xn express the behavior of the adversaries, words y1 · · · ym de-
scribe the behavior of the controllable robots and regular expression ˆr speciﬁes the
control objectives.

1.2. Contributions

Although there is an ongoing line of research on model-checking hyperproper-
ties [27, 5, 15], the work on ﬁnite-trace hyperproperties is limited to [18], where the
authors construct a ﬁnite-word representation for the class of regular k-safety hyper-
properties. We make the following contributions:

• Introduce regular hyperlanguages and HREs, and demonstrate the ability of HREs
to express important information-ﬂow security policies such as different varia-
tions of noninterference [29] and observational determinism [39].

• Present nondeterministic ﬁnite-word hyperautomata (NFH), an automata-based

model for expressing regular hyperlanguages.

• Conduct a comprehensive study of the properties of regular hyperlanguages (see

Table 1):

– We show that regular hyperlanguages are closed under union, intersection,

and complementation.

– We consider the nonemptiness problem for NFH:

* We prove that the nonemptiness problem is in general undecidable for

NFH.

* However, for the alternation-free fragments (which only allow one
type of quantiﬁer), as well as for the ∃∀ fragment (in which the quan-
tiﬁcation condition is limited to a sequence of ∃ quantiﬁers followed
by a sequence of ∀ quantiﬁers), nonemptiness is decidable.

3

Property
Closure

Result
Complementation, Union, Intersection (Theorems 1, 2, 3)

Nonemptiness

Bounded Nonemptiness

Universality

Finite membership

Regular membership

Containment

∀∃∃
∃∗ / ∀∗ / ∃∗(cid:63) / ∀∗(cid:63)
∃∗∀∗
∃∗∀∗(cid:63)
NFH
∃∀∀
∃∗ / ∀∗
∀∗∃∗
NFH
O(log(k)) ∀

Undecidable (Theorem 4)
NL-complete (Theorems 5, 10)
PSPACE-complete (Theorem 6)
EXPSPACE-complete (Theorem 11)
PSPACE-complete (Theorem 9)
Undecidable (Theorem 12)
PSPACE-complete (Theorem 12)
EXPSPACE (Theorem 12)
PSPACE (Theorem 13)
NP-complete (Theorem 13)

Decidable (Theorem 14)

NFH
∃∗ ⊆ ∀∗ / ∀∗ ⊆ ∃∗
∃∗∀∗ ⊆ ∀∗∃∗

Undecidable (Theorem 15)
PSPACE-complete (Theorem 16)
EXPSPACE (Theorem 16)

Table 1: Summary of results on properties of hyperregular languages.
* As another positive result in the area of nonemptiness, we show that
the bounded nonemptiness problem, in which we decide whether an
NFH accepts a hyperword of bounded size, is PSPACE-complete.
* We consider the construction of HRE and NFH with wild card let-
ters, which allow expressing the assignment to only a subset of the
variables, by assigning a wild card letter to the rest of the variables.
We show that adding wild cards does not alter the complexity of the
nonemptiness for the alternation-free fragments, while it does increase
the complexity of this problem for the ∃∀ fragment.

* We describe a semi-algorithm for deciding the nonemptiness of NFH
with a ∀∃ quantiﬁcation condition. The procedure begins with the
largest potential hyperword, and iteratively prunes it in a consistent
way in case it is not accepted. Since the problem is undecidable, there
are inputs for which our semi-algorithm does not halt. However, in
case it does halt, it is guaranteed to return a correct answer. Since ∀∃
is a useful fragment, our procedure can be a useful tool.

– We study the universality, membership and containment problems. These
results are aligned with the complexity of HyperLTL model checking for
tree-shaped and general Kripke structures [5]. This shows that the com-
plexity results in [5] mainly stem from the nature of quantiﬁcation over
ﬁnite words and depend on neither the full power of the temporal operators
nor the inﬁnite nature of HyperLTL semantics.

Comparison to the conference version. This article substantially extends the results of
our original conference submission [10] by the following new contributions.

• An upper and lower bound of the bounded nonempitness problem.

4

• Upper and lower bounds for the nonemptiness problem for the various fragments

of NFH in the presence of wild-card letters.

• A semi-algorithm for deciding the nonemptiness for the ∀∃ fragment.

• A detailed discussion on related work.

In summary, the material in Sections 6.2, 6.4 6.3, and 8 is all new. Finally, all proof
sketches are now extended to revised and detailed full proofs.

1.3. Organization

The rest of the paper is organized as follows. Preliminary concepts are presented in
Section 2. We introduce the notion of HRE and NFH in Sections 3 and 4, while their
properties and our complexity results are studied in Sections 5, 6, and 7. Related work
is discussed in Section 8. Finally, we make concluding remarks and discuss future
work in Section 9.

2. Preliminaries

An alphabet is a nonempty ﬁnite set Σ of letters. A word over Σ is a ﬁnite sequence
of letters from Σ. The empty word is denoted by (cid:15), and the set of all words is denoted by
Σ∗. A language is a subset of Σ∗. We assume that the reader is familiar with the syntax
and semantics of regular expressions (RE). We use the standard notations {·, |, ∗} for
concatenation, union, and Kleene star, respectively, and denote the language of an RE
r by L(r). A language L is regular if there exists an RE r such that L(r) = L.

ﬁnite-word
Deﬁnition 1. A nondeterministic
tuple
A = (cid:104)Σ, Q, Q0, δ, F (cid:105), where Σ is an alphabet, Q is a nonempty ﬁnite set of states,
Q0 ⊆ Q is a set of initial states, F ⊆ Q is a set of accepting states, and δ ⊆ Q × Σ × Q
is a transition relation.

automaton

(NFA)

is

a

Given a word w = σ1σ2 · · · σn over Σ, a run of A on w is a sequence of states
(q0, q1, . . . qn), such that q0 ∈ Q0, and for every 0 < i ≤ n, it holds that (qi−1, σi, qi) ∈
δ. The run is accepting if qn ∈ F . We say that A accepts w if there exists an accepting
run of A on w. The language of A, denoted L(A), is the set of all words that A ac-
cepts. It is well-known that a language L is regular iff there exists an NFA A such that
L(A) = L.

3. Hyperregular Expressions

Deﬁnition 2. A hyperword over Σ is a set of words over Σ and a hyperlanguage over
Σ is a set of hyperwords over Σ.

Before formally deﬁning hyperregular expressions, we explain the idea behind
them. A hyperregular expression (HRE) over Σ uses a set of word variables X =
{x1, x2, . . . , xk}. When expressing a hyperword S, these variables are assigned words

5

from S. An HRE r is composed of a quantiﬁcation condition α over X, and an un-
derlying RE ˆr, which represents word assignments to X. An HRE r deﬁnes a hyper-
language L(r). The condition α deﬁnes the assignments that should be in L(ˆr). For
example, α = ∃x1.∀x2 requires that there exists a word w1 ∈ S (assigned to x1),
such that for every word w2 ∈ S (assigned to x2), the word that represents the assign-
ment x1 (cid:55)→ w1, x2 (cid:55)→ w2, is in L(ˆr). The hyperword S is in L(r) iff S meets these
conditions.

We represent an assignment v : X → S as a word assignment wv, which is a word
over the alphabet (Σ∪{#})X (that is, assignments from X to Σ∪{#}), where the i’th
letter of wv represents the k i’th letters of the words v(x1), . . . , v(xk) (in case that the
words are not of equal length, we “pad” the end of the shorter words with # symbols).
We represent these k i’th letters as an assignment denoted {σ1x1 , σ2x2 , . . . , σkxk },
where xj is assigned σj. For example, the assignment v(x1) = aa and v(x2) = abb is
represented by the word assignment wv = {ax1 , ax2}{ax1, bx2 }{#x1 , bx2}.

Deﬁnition 3. A hyperregular expression is a tuple r = (cid:104)X, Σ, α, ˆr(cid:105), where α =
Q1x1 · · · Qkxk, where Qi ∈ {∃, ∀} for every i ∈ [1, k], and where ˆr is an RE over
ˆΣ = (Σ ∪ {#})X .

Let S be a hyperword and let v : X → S be an assignment of the word variables of
r to words in S. We denote by v[x (cid:55)→ w] the assignment obtained from v by assigning
the word w ∈ S to x ∈ X. We represent v by wv. We now deﬁne the membership
condition of a hyperword S in the hyperlanguage of r. We ﬁrst deﬁne a relation (cid:96) for
S, ˆr, a quantiﬁcation condition α, and an assignment v : X → S, as follows.

• For α = (cid:15), deﬁne S (cid:96)v (α, ˆr) if wv ∈ L(ˆr).

• For α = ∃x.α(cid:48), deﬁne S (cid:96)v (α, ˆr) if there exists w ∈ S s.t. S (cid:96)v[x(cid:55)→w] (α(cid:48), ˆr).

• For α = ∀x.α(cid:48), deﬁne S (cid:96)v (α, ˆr) if S (cid:96)v[x(cid:55)→w] (α(cid:48), ˆr) for every w ∈ S .1

Since all variables are under the scope of α, membership is independent of v, and so if
S (cid:96) (α, ˆr), we denote S ∈ L(r). The hyperlanguage of r is L(r) = {S | S ∈ L(r)}.

Deﬁnition 4. We call a hyperlanguage L a regular hyperlanguage if there exists an
HRE r such that L(r) = L.

Application of HRE in Information-ﬂow Security

Noninterference [29] requires high-secret commands to be removable without af-

fecting observations of users holding low clearances:

ϕni = ∀x.∃y{lx, lλy}∗,

where l denotes a low state and lλ denotes a low state such that all high commands are
replaced by a dummy value λ.

1In case that α begins with ∀, membership holds vacuously with an empty hyperword. We restrict the

discussion to nonempty hyperwords.

6

Observational determinism [39] requires that if two executions of a system start

with low-security-equivalent events, they should remain low equivalent:

ϕod = ∀x.∀y.

(cid:16)

{lx, ly}+ | {¯lx, ¯ly}{$x, $y}∗ | {lx, ¯ly}{$x, $y}∗ | {¯lx, ly}{$x, $y}∗(cid:17)

where l denotes a low event, ¯l ∈ Σ \ {l}, and $ ∈ Σ. We note that similar policies
such as Boudol and Castellani’s noninterference [28] can be formulated in the same
fashion. 2

Generalized noninterference (GNI) [32] allows nondeterminism in the low-observable

behavior, but requires that low-security outputs may not be altered by the injection of
high-security inputs:

ϕgni = ∀x.∀y.∃z.

(cid:18)

{hx, ly, hlz} | {¯hx, ly, ¯hlz} | {hx, ¯ly, h¯lz} | {¯hx, ¯ly, ¯h¯lz}

(cid:19)∗

where h denotes the high-security input, l denotes the low-security output, ¯l ∈ Σ \ {l},
and ¯h ∈ Σ \ {h}.

Declassiﬁcation [34] relaxes noninterference by allowing leaking information when
necessary. Some programs must reveal secret information to fulﬁll functional require-
ments. For example, a password checker must reveal whether the entered password is
correct or not:

ϕdc = ∀x.∀y.{lix, liy}{pwx, pwy}{lox, loy}+
where li denotes low-input state, pw denotes that the password is correct, and lo de-
notes low-output states. We note that for brevity, ϕdc does not include behaviors where
the ﬁrst two events are not low or, in the second event, the password is not valid.

Termination-sensitive noninterference requires that for two executions that start
from low-observable states, information leaks are not permitted by the termination
behavior of the program (here, l denotes a low state and $ ∈ Σ):

ϕtsni = ∀x.∀y.

(cid:16)

{lx, ly}{$x, $y}∗{lx, ly} | {¯lx, ¯ly}{$x, $y}∗ |
{lx, ¯ly}{$x, $y}∗ | {¯lx, ly}{$x, $y}∗(cid:17)

4. Nondeterminsitic Finite-Word Hyperautomata

We now present a model for regular hyperlanguages, namely ﬁnite-word hyper-
automata. A hyperautomaton is composed of a set X of word variables, a quantiﬁca-
tion condition, and an underlying ﬁnite-word automaton that accepts representations of
assignments to X.

Deﬁnition 5. A nondeterministic ﬁnite-word hyperautomaton (NFH) is a tuple
A = (cid:104)Σ, X, Q, Q0, F, δ, α(cid:105), where Σ, X and α are as in Deﬁnition 3, and where
(cid:104) ˆΣ, Q, Q0, F, δ(cid:105) forms an underlying NFA over ˆΣ = (Σ ∪ {#})X .

2This policy states that every two executions that start from bisimilar states (in terms of memory low-

observability), should remain bisimilarly low-observable.

7

Figure 1: The NFH A1 (left) and A2 (right).

The acceptance condition for NFH, as for HRE, is deﬁned with respect to a hyperword
S, the NFH A, the quantiﬁcation condition α, and an assignment v : X → S. For the
base case of α = (cid:15), we deﬁne S (cid:96)v (α, A) if ˆA accepts wv. The cases where α is of
the type ∃x.α(cid:48) and ∀x.α(cid:48) are deﬁned similarly as for HRE, and if S (cid:96) (α, A), we say
that A accepts S.

Deﬁnition 6. Let A be an NFH. The hyperlanguage of A, denoted L(A), is the set of
all hyperwords that A accepts.

Example 3. Consider the NFH A1 in Figure 1 (left), whose alphabet is Σ = {a, b},
over two word variables x and y. The NFH A1 contains an underlying standard NFA
ˆA1. For two words w1, w2 that are assigned to x and y, respectively, ˆA1 requires that
(1) w1, w2 agree on their a (and, consequently, on their b) positions, and (2) once one
of the words has ended (denoted by #), the other must only contain b letters. Since
the quantiﬁcation condition of A1 is ∀x1.∀x2, in a hyperword S that is accepted by
A1, every two words agree on their a positions. As a result, all the words in S must
agree on their a positions. The hyperlanguage of A1 is then all hyperwords in which
all words agree on their a positions.

Example 4. The NFH A2 of Figure 1 (right) depicts the translation of the HRE of
Example 1 to an NFH.

Since regular expressions are equivalent to NFA, we can translate the underlying
regular expression ˆr of an HRE r to an equivalent NFA, and vice versa – translate the
underlying NFA ˆA of an NFH A to a regular expression. It is then easy to see that every
HRE has an equivalent NFH over the same set of variables with the same quantiﬁcation
condition.

We consider several fragments of NFH, which limit the structure of the quantiﬁ-
cation condition α. HRE∀ is the fragment in which α contains only ∀ quantiﬁers, and
similarly, in HRE∃, α contains only ∃ quantiﬁers. In the fragment HRE∃∀, α is of the
form ∃x1 · · · ∃xi∀xi+1 · · · ∀xk.

4.1. Additional Terms and Notations

We present several terms and notations which we use throughout the paper. Recall
that we represent an assignment v : X → S as a word assignment wv. Conversely, a
word w over (Σ ∪ {#})X represents an assignment vw : X → Σ∗, where vw(xi) is
formed by concatenating the letters of Σ that are assigned to xi in the letters of w. We
denote the set of all such words {vw(x1), . . . , vw(xk)} by S(w). Since we only allow

8

{𝑎𝑥,𝑎𝑦}{#𝑥,𝑎𝑦}∀𝑥∃𝑦𝑎𝑥,𝑎𝑦,{𝑏𝑥,𝑏𝑦}∀𝑥∀𝑦{#𝑥,𝑎𝑦}{𝑏𝑥,#𝑦}{𝑏𝑥,#𝑦}{#𝑥,𝑏𝑦}{#𝑥,𝑏𝑦}padding at the end of a word, if a padding occurs in the middle of w, then w does not
represent a legal assignment. Notice that this occurs iff w contains two consecutive
letters wiwi+1 such that wi(x) = # and wi+1(x) (cid:54)= # for some x ∈ X. We call w
legal if vw represents a legal assignment from X to Σ∗.

Consider a function g : A → B where A, B are some sets. The range of g, denoted

range(g) is the set {g(a)|a ∈ A}.

A sequence of g is a function g(cid:48) : A → B such that range(g(cid:48)) ⊆ range(g). A
permutation of g is a function g(cid:48) : A → B such that range(g(cid:48)) = range(g). We extend
the notions of sequences and permutations to word assignments. Let w be a word over
ˆΣ. A sequence of w is a word w(cid:48) such that S(w(cid:48)) ⊆ S(w), and a permutation of w is a
word w(cid:48) such that S(w(cid:48)) = S(w).

Throughout the paper, when we use a general NFH A, we assume that its ingredi-

ents are as in Deﬁnition 5.

5. Closure Properties of Regular Hyperlanguages

We now consider closure properties of regular hyperlanguages. We show, via con-
structions on NFH, that regular hyperlanguages are closed under all the Boolean oper-
ations.

Theorem 1. Regular hyperlanguages are closed under complementation.
Proof. Let A be an NFH. The NFA ˆA can be complemented with respect to its lan-
guage over ˆΣ to an NFA ˆA. Then, for every assignment v : X → S, it holds that ˆA
accepts wv iff ˆA does not accept wv. Let α be the quantiﬁcation condition obtained
from α by replacing every ∃ with ∀ and vice versa. We can prove by induction on
α that A, the NFH whose underlying NFA is ˆA, and whose quantiﬁcation condition
is α, accepts L(A). The size of A is exponential in | ˆA|, due to the complementation
construction for ˆA and complementing the set of transitions in δ.

Theorem 2. Regular hyperlanguages are closed under union.

Proof. let A1 = (cid:104)Σ, X, Q, Q0, δ1, F1, α1(cid:105) and A2 = (cid:104)Σ, Y, P, P0, δ2, F2, α2(cid:105) be two
NFH with |X| = k and |Y | = k(cid:48) variables, respectively.

We construct an NFH A∪ = (cid:104)Σ, X ∪ Y, Q ∪ P ∪ {p1, p2}, Q0 ∪ P0, δ, F1 ∪ F2 ∪
{p1, p2}, α(cid:105), where α = α1α2 (that is, we concatenate the two quantiﬁcation condi-
tions), and where δ is deﬁned as follows.

• For every (q1

f
−→ q2) ∈ δ1 we set (q1

f ∪g
−−→ q2) ∈ δ for every g ∈ (Σ ∪ {#})Y .

• For every (q1

f
−→ q2) ∈ δ2 we set (q1

f ∪g
−−→ q2) ∈ δ for every g ∈ (Σ ∪ {#})X .

• For every q ∈ F1, we set (q

g ∈ (Σ ∪ {#})Y .

• For every q ∈ F2, we set (q

g ∈ (Σ ∪ {#})X .

{#}X ∪g
−−−−−→ p1), (p1

{#}X ∪g
−−−−−→ p1) ∈ δ for every

g∪{#}Y
−−−−−→ p2), (p2

g∪{#}Y
−−−−−→ p2) ∈ δ for every

9

Let S be a hyperword. For every v : (X ∪ Y ) → S, it holds that if wv|X ∈ L( ˆA1),
then wv ∈ L( ˆA∪). Indeed, according to our construction, every word assigned to the
Y variables is accepted in the A1 component of the construction, and so it satisﬁes both
types of quantiﬁers. A similar argument holds for v|Y and A2.

Also, according to our construction, for every v : (X ∪ Y ) → S, if wv ∈ L( ˆA∪),
then either wv|X ∈ L( ˆA1), or wv|Y ∈ L( ˆA2). As a conclusion, we have that L(A∪) =
L(A1) ∪ L(A2).

The state space of A∪ is linear in the state spaces of A1, A2. However, the size
of the alphabet of A∪ may be exponentially larger than that of A1 and A2, since we
augment each letter with all functions from Y to Σ ∪ {#} (in A1) and from X to
Σ ∪ {#} (in A2).

Theorem 3. Regular hyperlanguages are closed under intersection.

Proof. The proof follows from the closure of regular hyperlanguages under union and
complementation. However, we also offer a direct translation, which avoids the need
to complement.

let A1 = (cid:104)Σ, X, Q, Q0, δ1, F1, α1(cid:105) and A2 = (cid:104)Σ, Y, P, P0, δ2, F2, α2(cid:105) be two NFH

with |X| = k and |Y | = k(cid:48) variables, respectively.

We construct an NFH A∩ = (cid:104)Σ, X ∪ Y, (Q ∪ {q}) × (P ∪ {p}), (Q0 × P0), δ, (F1 ∪

{q}) × (F2 ∪ {p}), α1α2(cid:105), where δ is deﬁned as follows.

• For every (q1

f
−→ q2) ∈ δ1 and every (p1

g
−→ p2) ∈ δ2, we have

(cid:16)

(q1, p1)

f ∪g
−−→ (q2, p2)

(cid:17)

∈ δ

• For every q1 ∈ F1, (p1

g
−→ p2) ∈ δ2 we have

(cid:16)

(q1, p1)

{#}X ∪g
−−−−−→ (q, p2)

(cid:17)

(cid:16)

,

(q, p1)

{#}k∪g
−−−−−→ (q, p2)

(cid:17)

∈ δ

• For every (q1

f
−→ q2) ∈ δ1 and p1 ∈ F2, we have

(cid:16)

(q1, p1)

f ∪{#}Y
−−−−−→ (q2, p)

(cid:17)

(cid:16)

,

(q1, p)

f ∪{#}Y
−−−−−→ (q2, p)

(cid:17)

∈ δ

Intuitively, the role of q, p is to keep reading {#}X and {#}Y after the word read by
ˆA1 or ˆA2, respectively, has ended.

The NFH ˆA∩ simultaneously reads two word assignments that are read along ˆA1
and ˆA2, and accepts iff both word assignments are accepted. The correctness follows
from the fact that for v : (X ∪ Y ) → S, we have that wv is accepted by ˆA iff wv|X and
wv|Y are accepted by ˆA1 and ˆA2, respectively. This construction is polynomial in the
sizes of A1 and A2.

10

6. Nonemptiness of NFH.

The nonemptiness problem is to decide, given an NFH A, whether L(A) = ∅. The
complexity of the nonemptiness problem affects the complexity of various other deci-
sion problems, such as universality and containment. In this section, we extensively
study various versions of this problem for various fragments of NFH. First, we show
that the problem for general NFH is undecidable. Then, we show that nonemptiness is
decidable for various fragments of NFH, with varying complexities.

We then study the bounded nonemptiness problem, in which we ask whether an

NFH accepts a hyperword of bounded size.

Finally, we study the nonemptiness problem in the presence of wild-card letters,
which represent free assignments to a variable. Wild-card letters can exponentially
decrease the number of transitions of an NFH. We show that for the alternation-free
fragments of NFH, wild-card letters do not increase the complexity of the nonemptiness
problem, while for the fragment of NFH∃∀, the smaller representation comes with an
exponential blow-up in complexity.

6.1. General Nonemptiness Results

We begin with the nonemptiness problem for general NFH.

Theorem 4. The nonemptiness problem for NFH is undecidable.

Proof. In [19], a reduction from the Post correspondence problem is used for proving
the undecidability of HyperLTL satisﬁability. We mimic the proof ideas of [19] to show
that the nonemptiness problem for NFH is, in general, undecidable. A PCP instance is
a collection C of dominoes of the form:

(cid:40)

(cid:104) u1
v1

(cid:105)

,

(cid:104) u2
v2

(cid:105)
, . . . ,

(cid:104) uk
vk

(cid:41)

(cid:105)

where for all i ∈ [1, k], we have vi, ui ∈ {a, b}∗. The problem is to decide whether
there exists a ﬁnite sequence of the dominoes of the form

(cid:105)

(cid:104) ui1
vi1

(cid:105)(cid:104) ui2
vi2

· · ·

(cid:105)

(cid:104) uim
vim

where each index ij is in [1, k], such that the upper and lower ﬁnite strings of the
dominoes are equal, i.e.,

ui1 ui2 · · · uim = vi1vi2 · · · vim

For example, if the set of dominoes is

Cexmp =

(cid:40)

(cid:104) ab
b

(cid:105)

,

(cid:105)

,

(cid:104) ba
a

(cid:104) a
aba

(cid:41)

(cid:105)

Then, a possible solution is the following sequence of dominoes from Cexmp:

sol =

(cid:104) a
aba

(cid:105)(cid:104) ba
a

(cid:105)(cid:104) ab
b

(cid:105)

.

11

Given an instance C of PCP, we encode a solution as a word wsol over the following

alphabet:

(cid:111)
(cid:110) σ
σ(cid:48) | σ, σ(cid:48) ∈ {a, b, ˙a, ˙b, $}
.
Intuitively, ˙σ marks the beginning of a new domino, and $ marks the end of a sequence
of the upper or lower parts of the dominoes sequence.

Σ =

We note that wsol encodes a legal solution iff the following conditions are met:

1. For every σ

σ(cid:48) that occurs in wsol, it holds that σ, σ(cid:48) represent the same domino

letter (both a or both b, either dotted or undotted).

2. The number of dotted letters in the upper part of wsol is equal to the number of

dotted letters in the lower part of wsol.

3. wsol starts with two dotted letters, and the word ui between the i’th and i + 1’th
dotted letters in the upper part of wsol, and the word vi between the correspond-
ing dotted letters in the lower part of wsol are such that [ ui
] ∈ C, for every
vi
i.

We call a word that represents the removal of the ﬁrst k dominoes from wsol a
partial solution, denoted by wsol,k. Note that the upper and lower parts of wsol,k are
not necessarily of equal lengths (in terms of a and b sequences), since the upper and
lower parts of a domino may be of different lengths, and so we use letter $ to pad the
end of the encoding in the shorter of the two parts.

We construct an NFH A, which, intuitively, expresses the following ideas: (1)
There exists an encoding wsol of a solution to C, and (2) For every wsol,k (cid:54)= (cid:15) in a
hyperword S accepted by A, the word wsol,k+1 is also in S.

L(A) is then the set of all hyperwords that contain an encoded solution wsol, as
well as all its sufﬁxes obtained by removing a preﬁx of dominoes from wsol. This
ensures that wsol indeed encodes a legal solution. For example, a matching hyperword
S (for the solution sol discussed earlier) that is accepted by A is:

S = {wsol =

˙b
b

˙a
˙a

a
a

˙a
˙a

b
˙b

, wsol,1 =

˙b
˙a

a
˙b

˙a
$

b
$

, wsol,2 =

˙a
˙b

b
$

, wsol,3 = (cid:15)}

Thus, the quantiﬁcation condition of A is α = ∀x1∃x2∃x3, where x1 is to be
assigned a potential partial solution wsol,k, and x2 is to be assigned wsol,k+1, and x3
is to be assigned wsol.

During a run on a hyperword S and an assignment v : {x1, x2, x3} → S, the NFH
A checks that the upper and lower letters of wsol all match. In addition, A checks
that the ﬁrst domino of v(x1) is indeed in C, and that v(x2) is obtained from v(x1)
by removing the ﬁrst tile. A performs the latter task by checking that the upper and
lower parts of v(x2) are the upper and lower parts of v(x1) that have been “shifted”
back appropriately. That is, if the ﬁrst tile in v(x2) is the encoding of [ wi
], then A uses
vi
states to remember, at each point, the last |wi| letters of the upper part of v(x2) and the
last |vi| letters of the lower part of v(x2), and veriﬁes, at each point, that the next letter
in v(x1) matches the matching letter remembered by the state.

12

Next, we show that for the alternation-free fragments, a simple reachability test

sufﬁces to decide nonemptiness.

Theorem 5. The nonemptiness problem for NFH∃ and NFH∀ is NL-complete.

Proof. The lower bound for both fragments follows from the NL-hardness of the
nonemptiness problem for NFA.

We turn to the upper bound, and begin with NFH∃. Let A∃ be an NFH∃. We claim
that A∃ is nonempty iff ˆA∃ accepts some legal word w. The ﬁrst direction is trivial. For
the second direction, let w ∈ L( ˆA∃). By assigning v(xi) = vw(xi) for every xi ∈ X,
we get wv = w, and according to the semantics of ∃, we have that A∃ accepts S(w).
To check whether ˆA∃ accepts a legal word, we can run a reachability check on-the-ﬂy,
while advancing from a letter σ to the next letter σ(cid:48) only if σ(cid:48) assigns # to all variables
f
−→ p in ˆA is of size k, we can
for which σ assigns #. While each transition T = q
(xi,σi)
encode T as a set of size k of encodings of transitions of type q
−−−−→ p with a binary
encoding of p, q, σi, as well as i, t, where t marks the index of T within the set of
transitions of ˆA. Therefore, the reachability test can be performed within space that is
logarithmic in the size of A∃.

Now, let A∀ be an NFH∀ over X. We claim that A∀ is nonempty iff A∀ accepts a
hyperword of size 1. For the ﬁrst direction, let S ∈ L(A∀). Then, by the semantics of
∀, we have that for every assignment v : X → S, it holds that wv ∈ L( ˆA∀). Let u ∈ S,
and let vu(xi) = u for every xi ∈ X. Then, in particular, wvu ∈ L( ˆA∀). Then for
every assignment v : X → {u} (which consists of the single assignment vu), it holds
that ˆA∀ accepts wv, and therefore A∀ accepts {u}. The second direction is trivial.

To check whether A∀ accepts a hyperword of size 1, we restrict the reachability

test on ˆA∀ to letters over ˆΣ that represent ﬁxed functions.

For NFH∃∀, we show that the problem is decidable, by checking the nonemptiness

of an exponentially larger equi-empty NFA.

Theorem 6. The nonemptiness problem for NFH∃∀ is PSPACE-complete.

Proof. Let A be an NFH∃∀ with k quantiﬁers and m ∃-quatiﬁers. We begin with a
PSPACE upper bound.

Let S ∈ L(A). Then, according to the semantics of the quantiﬁers, there exist
w1, . . . wm ∈ S, such that for every assignment v : X → S in which v(xi) = wi for
every 1 ≤ i ≤ m, it holds that ˆA accepts wv. Let v : X → S be such an assignment.
Then, ˆA accepts wv(cid:48) for every sequence v(cid:48) of v that agrees with v on its assignments
to x1, . . . , xm, and in particular, for such sequences whose range is {w1, . . . , wm}.
Therefore, by the semantics of the quantiﬁers, we have that {w1, . . . , wm} is in L(A).
The second direction is trivial.

We call wv(cid:48) as described above a witness to the nonemptiness of A. We construct
an NFA A based on ˆA that is nonempty iff ˆA accepts a witness to the nonemptiness of
A.

Let Γ be the set of all functions of the type ζ : [1, k] → [1, m] such that ζ(i) = i
for every i ∈ [1, m], and such that range(ζ) = [1, m]. For a letter assignment f =
{σ1x1

}, we denote by fζ the letter assignment {σζ(1)x1

, . . . , σζ(k)xk

, . . . σkxk

}.

13

g
−→ q(cid:48) in δ, we have q

For every function ζ ∈ Γ, we construct an NFA Aζ = (cid:104) ˆΣ, Q, Q0, δζ, F (cid:105), where
f
−→ q(cid:48) in δζ, for every f that occurs in ˆA for which
for every q
fζ = g. Intuitively, for every run of Aζ on a word w there exists a similar of ˆA on the
sequence of w that matches ζ. Therefore, ˆA accepts a witness w to the nonemptiness
of A iff w ∈ L(Aζ) for every ζ ∈ Γ.

We deﬁne A = (cid:84)

ζ∈Γ Aζ. Then ˆA accepts a witness to the nonemptiness of A iff

A is nonempty.

Since |Γ| = mk−m, the state space of A is of size O(nmk−m

), where n = |Q|,
and its alphabet is of size | ˆΣ|. Notice that for A to be nonempty, δ must be of size at
least |(Σ ∪ #)|(k−m), to account for all the sequences of letters in the words assigned
to the variables under ∀ quantiﬁers (otherwise, we can immediately return “empty”).
Therefore, | ˆA| is O(n·|Σ|k). We then have that the size of A is O(| ˆA|k). If the number
k − m of ∀ quantiﬁers is ﬁxed, then mk−m is polynomial in k. However, now | ˆA| may
be polynomial in n, k, and |Σ|, and so in this case as well, the size of A is O(| ˆA|k).

Since the nonemptiness problem for NFA is NL-complete, the problem for NFH∃∀

can be decided in space of size that is polynomial in | ˆA|.

For the lower bound, we show a reduction from a polynomial version of the corri-
dor tiling problem, deﬁned as follows. We are given a ﬁnite set T of tiles, two relations
V ⊆ T × T and H ⊆ T × T , an initial tile t0, a ﬁnal tile tf , and a bound n > 0. We
have to decide whether there is some m > 0 and a tiling of a n × m-grid such that (1)
The tile t0 is in the bottom left corner and the tile tf is in the top right corner, (2) A
horizontal condition: every pair of horizontal neighbors is in H, and (3) A vertical con-
dition: every pair of vertical neighbors is in V . When n is given in unary notation, the
problem is known to be PSPACE-complete. Given an instance C of the tiling problem,
we construct an NFH∃∀ A that is nonempty iff C has a solution. We encode a solution
to C as a word wsol = w1 · w2 · wm$ over Σ = T ∪ {1, 2, . . . n, $}, where the word
wi, of the form 1 · t1,i · 2 · t2,i, . . . n · tn,i, describes the contents of row i.

To check that wsol indeed encodes a solution, we need to make sure that:

1. w1 begins with t0 and wm ends with tf $.

2. wi is of the correct form.

3. Within every wi, it holds that (tj,i, tj+1,i) ∈ H.

4. For wi, wi+1, it holds that (tj,i, tj,i+1) ∈ V for every j ∈ [1, n].

Verifying items 1 − 3 is easy via an NFA of size O(n|H|). The main obstacle is

item 4.

We describe an NFH∃∀ A = (cid:104)T ∪ {0, 1, 2, . . . n, $}, {y1, y2, y3, x1, . . . xlog(n)},
Q, {q0}, δ, F, α(cid:105) that is nonempty iff there exists a word that satisﬁes items 1 − 4.
The quantiﬁcation condition α is ∃y1∃y2∃y3∀x1 . . . ∀xlog(n). The NFH A only pro-
ceeds on letters whose assignments to y1, y1, y3 is r, 0, 1, respectively, where r ∈
T ∪ {1, . . . n, $}. Notice that this means that A requires the existence of the words
0|wsol| and 1|wsol| (the 0-word and 1-word, henceforth). A makes sure that the word
assigned to y1 matches a correct solution w.r.t. items 1 − 3 described above. We pro-
ceed to describe how to handle the requirement for V . We need to make sure that for

14

every position j in a row, the tile in position j in the next row matches the current one
w.r.t. V . We can use a state qj to remember the tile in position j, and compare it to the
tile in the next occurrence of j. The problem is avoiding having to check all positions
simultaneously, which would require exponentially many states. To this end, we use
log(n) copies of the 0- and 1-words to form a binary encoding of the position j that is
to be remembered. The log(n) ∀ conditions make sure that every position within 1 − n
is checked.

We limit the checks to words in which x1, . . . xlog(n) are the 0- or 1-words, by
having ˆA accept every word in which there is a letter that is not over 0, 1 that is assigned
to the x variables. This takes care of accepting all cases in which the word assigned to
y1 is also assigned to one of the x variables.

To check that x1, . . . xlog(n) are the 0- or 1-words, ˆA checks that the letter as-
signments to these variables remain constant throughout the run. In these cases, upon
reading the ﬁrst letter, ˆA remembers the value j that is encoded by the constant as-
signments to x1, . . . xlog(n) in a state, and makes sure that throughout the run, the tile
that occurs in the assignment to y1 in position j in the current row matches the tile in
position j in the next row.

We construct a similar reduction for the case that the number of ∀ quantiﬁers is
ﬁxed: instead of encoding the position by log(n) bits, we can directly specify the po-
sition by a word of the form j∗, for every j ∈ [1, n]. Accordingly, we construct an
NFH∃∀ over {x, y1, . . . yn, z}, with a quantiﬁcation condition α = ∃x∃y1 . . . ∃yn∀z.
The NFA ˆA advances only on letters whose assignments to y1, . . . yn are always
1, 2, . . . n, respectively, and checks only words assigned to z that are some constant
1 ≤ j ≤ n. Notice that the ﬁxed assignments to the y variables leads to δ of polyno-
mial size. In a hyperword accepted by A, the word assigned to x is wsol, and the word
assigned to z speciﬁes which index should be checked for conforming to V .

6.2. Bounded nonemptiness

The bounded nonemptiness problem is to decide, given an NFH A and m ∈ N,
whether A accepts a hyperword of size at most m. Notice that some nonempty NFH
only accept inﬁnite hyperwords (for example, A2 of Figure 1), and so they do not
accept a hyperword of size m, for every m ∈ N.

We show that the bounded nonemptiness problem is decidable for all of NFH.

Theorem 7. The bounded nonemptiness problem for NFH is in PSPACE.

Proof. Let A be an NFH with a quantiﬁcation condition α with k quantiﬁers, and let
m ∈ N.
Intuitively, we construct an NFA A in which a single run simultaneously
follows all runs of ˆA on the possible assignments of a potential hyperword S of size m
to the variables of A. Then, A accepts a set of such legal assignments (represented as
a single word) iff A accepts a hyperword of size at most m.

The assignment tree for α and m is deﬁned as follows. The tree T has k + 1 levels,
where the root is at level 0. For 0 < i ≤ k, if Qi = ∀, then every node in level i − 1 has
m children. If Qi = ∃, then every node in level i − 1 has a single child. Every node
v in T is associated with an encoding in [1, m]∗ that matches the path from the root to
v. For example, if v is in level 2, and α begins with ∃∀, and v is the second child, then

15

Figure 2: The labeled assignment tree c(T ) (left), transitions in A (middle), and their depiction in A (right).

the position of v is encoded by 1 · 2. The leaves of T are then all encoded by elements
of [1, m]k.

A labeling c of T labels every node (except for the root) by some value in [1, m].
For 0 < i ≤ k, if Qi = ∀, then the m children of every node in level i − 1 are labeled
1 to m. If Qi = ∃, then the child of every node in level i − 1 is labeled by some value
in [1, m].

Consider a hyperword S = {w1, w2, . . . wm}. Every path p along c(T ) matches
an assignment of the words in S to the variables in X: the variable xi is assigned wj,
where j is the labeling of the node in level i in p. Then, c(T ) matches a possible set of
assignments of the words of S to the variables in X. Given p, we denote this assignment
by fp. According to the semantics of NFH, we have that A accepts a hyperword of size
m iff there a labeling c(T ) such that for every path p of c(T ), the underlying NFA ˆA
accepts the word assignment for fp.

We construct A such that a single run of A simultaneously follows every assignment

fp in a labeling c(T ), letter by letter.

Let C be the set of all labelings of T , and let L be the set of all indices of leaves
of T . We deﬁne the NFA A as follows. The alphabet of A is (Σ ∪ {#})m. The set
of states of A is QL × C. The set of initial states is QL
0 × C, and the set of accepting
states is F L × C.

ixi

from (((q1, l1), . . . (q|L|, l|L|)), c) to (((q(cid:48)
ery 1 ≤ r ≤ |L|, there is a transition in δ labeled by {σ(cid:48)
r, where σ(cid:48)
q(cid:48)

The transition relation of A is as follows. We add a transition labeled (σ1, σ2, . . . σm)
|L|, l|L|)), c(cid:48)) if c = c(cid:48), and for ev-
1, l1), . . . (q(cid:48)
, . . . σ(cid:48)
} from qr to
= σj, where j is the labeling of the node in level i in the path to lr in c.
For example, consider the labeled assignment tree c(T ) of Figure 2 for the quan-
tiﬁcation condition ∀x1∃x2, and m = 3. Then T has three leaves, labeled 1 · 1, 2 · 1,
and 3 · 1. The labeling c(T ) assigns the nodes of T values in [1, 3] as described in
Figure 2. The three transitions in A from q1, q2, q3 are then translated to the transition
from s = (((q1, 1 · 1), (q2, 2 · 1), (q3, 3 · 1)), c(T )) labeled (a, b, c), which means that
the transition associates label 1 with a, label 2 with b, and label 3 with c, matching the
transitions from q1,q2, and q3, when they are associated with the leaves as in s.

, σ(cid:48)

kxk

2x2

1x1

The size of T (and hence, the size of L) is O(mk(cid:48)
quantiﬁers in α. Accordingly, the size of C is O(mmk(cid:48)
A is of size O(nmk(cid:48)

· mmk(cid:48)

), where n is the number of states in A.

), where k(cid:48) is the number of ∀
). Therefore, the state space of

16

3123231⋅12⋅13⋅1𝑞1𝑞2𝑞3𝑞′1𝑞′2𝑞′3𝑐(𝑇){𝑎𝑥1,𝑏𝑥2}{𝑐𝑥1,𝑐𝑥2}{𝑏𝑥1,𝑐𝑥2}𝑞11.1𝑞22.1𝑞33.1〈𝑎,𝑏,𝑐〉𝑞′11.1𝑞′22.1𝑞′33.1According to our construction, we have that A accepts a hyperword of size m
iff A is nonempty, when considering only paths that are legal assignments, that is,
once a value i is assigned the letter #, it continues to be assigned #. Checking A
for such nonemptiness can be done on-the-ﬂy in space that is logarithmic in the size
of A. Notice, as mentioned in the proof of theorem 6, that for m > 1, the size of
the transition relation of A must be exponential in the size of k(cid:48), to account for the
different assignments to the ∀-quantiﬁers (otherwise, A is empty and we can return
“false”). Therefore, the size of each state of A is polynomial in the size of A, and a
PSPACE upper bound follows.

A PSPACE lower bound for the bounded nonemptiness problem for NFH directly
follows from the nonemptiness problem for NFH∃∀, since, as we prove in Theorem 6,
an NFH∃∀ A with k(cid:48) ∃-quantiﬁers is nonempty iff it accepts a hyperword of size k(cid:48).
However, we prove PSPACE-hardness for a ∀x∃y quantiﬁcation condition, showing
that this problem is PSPACE-hard even for a ﬁxed number of ∀ and ∃ quantiﬁers.

Theorem 8. The bounded nonemptiness problem for NFH with α = ∀x∃y is PSPACE-
hard.

Proof. We reduce from the problem of deciding the nonemptiness of the intersection
of k given NFA, which is known to be PSPACE-hard.

Let A1, A2, . . . Ak be NFA, where Ai = (cid:104)Σ, Qi, Qi

0, δi, Fi(cid:105). We construct an NFH
A = (cid:104)Σ(cid:48), {x, y}, Q, Q0, F, δ, ∀x∃y(cid:105) that accepts a hyperword whose size is at most k
iff there exists a word w such that w ∈ L(Ai) for every i ∈ [1, k].

The set of states Q of A is (cid:83)
i Qi × Q(i+1)modk, and Σ(cid:48) = (cid:83)
i Qi × Σ × Qi.
The set of accepting states is (cid:83)
i Fi × F(i+1)modk, and the set of initial states Q0
is (cid:83)
0 × Q(i+1)modk
. The transitions are as follows. For every i ∈ [1, k], ev-
ery σ ∈ Σ, and every two transitions (q, σ, q(cid:48)) ∈ δi, (p, σ, p(cid:48)) ∈ δ(i+1)modk, we set
((q, p), {(q, σ, q(cid:48))x, (p, σ, p(cid:48))y}, (q(cid:48), p(cid:48))) ∈ δ. Notice that the size of A is polynomial
in the sizes of A1, . . . Ak. Every word assignment w that is read along ˆA describes
the parallel run of Ai and A(i+1)modk on the same word w. The word assignment w is
accepted by ˆA iff w is accepted by both Ai and A(i+1)modk.

i Qi

0

If there exists a word w that is accepted by all NFA, then the hyperword S that
describes all the matching accepting runs on w by the different NFA is accepted by A.
Indeed, for the accepting run on w by Ai there is a matching accepting run on w by
A(i+1)modk.

Conversely, if there exists a hyperword of size (at most) k that is accepted by A,
then it contains descriptions of runs of A1, . . . Ak on words. By the way we have
deﬁned A, if there exists r ∈ S that describes the accepting run of Ai on a word w,
then there must exist r(cid:48) ∈ S that describes the accepting run of A(i+1)modk on w. As a
result, and combined with the size of S, we have that S must contain an accepting run
of every NFA in the set, and these runs must all be on the same word w. Therefore, the
intersection of A1, . . . Ak is nonempty.

As a conclusion from Theorems 7 and 8, we have the following.

Theorem 9. The bounded nonemptiness problem for NFH is PSPACE-complete.

17

6.3. NFH with Wild Card Letters

When constructing an HRE or an NFH, every letter must include an assignment to
all variables. However, an HRE may only need to describe the assignment to a subset
of the variables at each step. For example, the HRE

∃x∃y{ax}{by}

describes hyperwords in which there exist two words, where the ﬁrst word starts with
a, and the second word has b in its second position. Since the ﬁrst letter and the second
letter of the second and ﬁrst words, respectively, do not matter, there is no need to
express them. Therefore, we can deﬁne a more general and useful notion of HRE in
which the letters are partial functions from X to Σ.

To translate the notion of partial functions to NFH, we simply add a wild-card letter
(cid:63) which can stand for every letter assignment to the variables. For example, the letter
{ax, (cid:63)y} stands for all the assignments to x, y in which x is assigned a.

The size of the alphabet ˆΣ of an underlying NFA must be exponential in the size
of the number of ∀-quantiﬁers, to account for all the assignments of letters to all the
variables under ∀-quantiﬁers. Otherwise, the language of the NFH is empty. Using
wild-card letters, such transitions can be replaced by a single transition in which every
variable under ∀ is assigned (cid:63). Thus, using wild-card letters can lead to exponentially
smaller NFH.

We deﬁne NFH with wild cards accordingly. An NFH with wild card letters (NFH(cid:63))
is a tuple A = (cid:104)Σ, X, Q, Q0, F, δ, α(cid:105) whose underlying NFA ˆA is over the alphabet
ˆΣ = (Σ ∪ {#, (cid:63)})X . The semantics of NFH(cid:63) is similar to that of NFH. The only
difference is that now, wv contains all possible word assignments in which the letters
in Σ may also be replaced with (cid:63) in the assignments to the variables.

Obviously, every NFH(cid:63) can be translated to an NFH with an exponential blow-up
in the number of transitions. The constructions for intersection, union, and comple-
mentation can all be adjusted to handle the wild cards. Due to the exponential decrease
in size, the complexity of the various decision procedures for NFH(cid:63) may, in the worst
case, increase exponentially. Since the nonemptiness problem is at the core of most
decision procedures, we study its complexity for the various fragments of NFH(cid:63).

We begin with NFH(cid:63)

∃ and NFH(cid:63)

∀, and show that for these fragments, adding wild-

card letters does not change complexity of the nonemptiness problem.

According to the proof of Theorem 5, a simple reachability test on the underlying
NFA sufﬁces to determine nonemptiness for these fragments. We notice that this holds
also in the presence of wild-card letters. Indeed, an NFH(cid:63)
∀ is nonempty iff it accepts
a hyperword of size 1. The proof of Theorem 5 locates such a word by following an
accepting path in the underlying NFH in which all variables are equally assigned at
every step. It is easy to see that such a path sufﬁces also when some of the variables
are assigned wild-card letters. Similarly, an accepting path in an NFH∃ induces a ﬁnite
accepted hyperword, and the same holds also when traversing transitions with wild-
card letters. Therefore, we have the following.

Theorem 10. The nonemptiness problem for NFH(cid:63)

∃ and NFH(cid:63)

∀ is NL-complete.

18

We turn to study the fragment of NFH(cid:63)

∃∀. Recall that in the proof for the lower
bound of Theorem 6, we argue that the size of the transition relation of a nonempty
NFH∃∀ must be exponential in its number of ∀-quantiﬁers, which affects the space
complexity analysis of the size of the NFA that we construct. For an NFH(cid:63)
∃∀ A, this ar-
gument no longer holds. While we can construct a similar NFA and check its nonempti-
ness, its size may now be exponential in that of A, conforming to an EXPSPACE up-
per bound. We prove a matching lower bound, and conclude that in contrast to the
alternation-free fragments, adding wild-card letters hardens the nonemptiness problem
for NFH∃∀.
Theorem 11. The nonemptiness problem for NFH(cid:63)

∃∀ is EXPSPACE-complete.

Proof. Let A be an NFH∃∀. Consider the NFA A constructed in the proof of Theo-
rem 6. A similar NFA can be constructed to decide the nonemptiness of A. The only
difference is the need to consider the intersection of letters which carry wild-card let-
, σ2x2
ters. These can be easily computed: the intersection letter of {σ1x1
, . . . σkxk
} and
{σ(cid:48)
i = (cid:63), and γi = σ(cid:48)
, γ2x2
i
if σi = (cid:63), and otherwise it must hold that γi = σi = σ(cid:48)
i.

}, where γi = σi if σ(cid:48)

} is {γ1x1

, . . . γkxk

The size of A is, as in the proof of Theorem 6, O(nmk−m

), where n is the number
of states in A, and m is the number of ∃-quantiﬁers in α. Since the nonemptiness
problem for NFA is NL-complete, an EXPSPACE upper bound follows.

, . . . σ(cid:48)

, σ(cid:48)

kxk

2x2

1x1

We turn to the lower bound. As in the proof of Theorem 6, we reduce from the
corridor tiling problem: we are given an input C which consists of a ﬁnite set T of
tiles, two relations V ⊆ T × T and H ⊆ T × T , an initial tile t0, a ﬁnal tile tf , and
a bound n > 0. In the exponential version of this problem, we need to decide whether
there exists a legal tiling of a 2n × m for some m > 0 (in contrast to the polynomial
version which we use for NFH∃∀). This problem is known to be EXPSPACE-complete.
We use a similar idea as for NFH∃∀, and encode the legal solution as a word, while
using the 0− and 1−words under ∀ as memory. However, the exponential length of
each row in the tiling poses two main obstacles. First, we can no longer use a state to
remember the index in the row that we need to check in order to verify the vertical con-
dition. Second, we can no longer use numbered letters to mark the index in every row,
and using binary encoding requires verifying that the encoding is correctly ordered.
We describe how we overcome these two obstacles by using wild-card letters.

We encode a solution wsol = $w1 · w2 · wm$ over Σ = T ∪ {0, 1, $, &}, where the
word wi, of the form b0 · t0,i · b1 · t2,i, . . . b2n−1 · t2n−1,i, describes the contents of row
i, where bj is the n-bit binary encoding of index j. Additionally, we use the 0-word
which only consists of 0 letters, and similarly we use the 1-word. Here, we precede the
sequence of bits with &.

NFH(cid:63)

a

an

We

construct

quantiﬁcation

∃∀ A with
condition
α = ∃s∃x0∃x1∀u∀y1 . . . ∀yn∀z1 . . . ∀zn that is nonempty iff C has a solution. In-
tuitively, as in the proof of Theorem 6, the assignment to s must be wsol, and the
assignment to x0 and x1 must be the 0- and the 1-words, respectively. The assignment
to u must be equal to the assignment of either s, x0, or x1. Notice that since u is under
∀, then if A is nonempty then the only hyperword it can accept is {wsol, 0, 1}. There-
fore, the rest of the variables must always be assigned one of these three words in order
for A to accept.

19

When the assignments to y1 . . . yn are the 0- and 1- words, their binary values
are used for encoding a single index j that veriﬁes that every two consecutive tiles in
position j satisfy V , as we describe below. ˆA accepts all runs in which one of the y
variables is assigned wsol. To this end, the transition relation δ of ˆA uses transitions
from the initial state labeled by letters in which one of y1, . . . yn is assigned $ and the
rest are assigned (cid:63), leading to accepting runs for these cases.

To match the encoding of the y variables with the correct index j in wsol, the
transition relation δ of A describes the n bits of j in cycles of length n + 1, where in
each cycle, the i’th bit of j is speciﬁed in the i’th step, and the rest of the values are
represented as (cid:63). In each cycle, the i’th bit is compared with the i’th bit in wsol. In
cycles in which all n index bits in wsol match those of y1 . . . yn, the tile in the letter
that follows the encoding (the n + 1’th letter in the cycle) is matched with the previous
tile, remembered by a state, to verify that they satisfy V .

For example, for n = 3, the encoding 101 would be as follows.





y1 = & 1
y2 = & (cid:63)
y3 = & (cid:63)

(cid:63)
0
(cid:63)

(cid:63)
(cid:63)
1

(cid:63)
(cid:63)
(cid:63)

1
(cid:63)
(cid:63)

(cid:63)
0
(cid:63)





(cid:63) · · ·
(cid:63) · · ·
1 · · ·

Notice that (considering only y variables), only 2n + 2 letters are needed to describe
this encoding: two for every value of the i’th bit, one of all wild-cards, and one for all
&. Specifying all bits in a single letter would require exponentially many letters.

We now describe how to verify that the index encoding along wsol is correct. We
use the z variables in a similar way to the y variables, to encode the successor position
of the one encoded in the y variables. To check that they are indeed successors, it
sufﬁces to check, within the ﬁrst cycle, that all bits up to some 1 ≤ i < n are equal,
that zi = 1 and yi = 0, and that yi+1 . . . yn = 1 and zi+1 . . . zn = 0 (the only
exception is for 2n + 1 and 0, in which we only need to check that all y bits are 1 and
all z bits are 0). Runs of ˆA in which the encoding in the z variables is not the successor
of the encoding of the y variables, or in which one of the z variables is assigned wsol,
are accepting. Otherwise, whenever the encoding of the position in wsol is equal to that
of the y variables (we check this bit by bit), we check that the encoding of the position
in the next cycle is equal to that of the z variables.

For example, for checking the successor of 101, the assignments to the y and z

variables would be as follows.











y1 = & 1
y2 = & (cid:63)
y3 = & (cid:63)
z1 = & 1
z2 = & (cid:63)
z3 = & (cid:63)

(cid:63)
0
(cid:63)
(cid:63)
1
(cid:63)

(cid:63)
(cid:63)
1
(cid:63)
(cid:63)
0

(cid:63)
(cid:63)
(cid:63)
(cid:63)
(cid:63)
(cid:63)

1
(cid:63)
(cid:63)
1
(cid:63)
(cid:63)

(cid:63)
0
(cid:63)
(cid:63)
1
(cid:63)











(cid:63) · · ·
(cid:63) · · ·
1 · · ·
(cid:63) · · ·
(cid:63) · · ·
0 · · ·

Since the y and z variables are under ∀, all positions along wsol are checked over
all runs of ˆA on the different assignments to the y and z variables. It is left to check
that the ﬁrst position in wsol is 0n, and the last position is 1n, which can be done via
states.

20

Checking the horizontal condition itself can be done by comparing every two con-
secutive tiles in the same row. These tiles are n letters apart, and so this can be done via
the states and does not require using the variables as memory. The rest of the checks,
i.e, the identity of the ﬁrst and last tiles, and the correct form of wsol, can also be easily
checked by the states.

In every letter of ˆA (other than the ﬁrst in the run, in which all y and z variables are
assigned &), there are at most six non-wild card letters: the assignments to s, x0, x1
and u, and yi and zi for some 1 ≤ i ≤ n, and additionally the letters in which one of
the y or z variables is assigned with a word that starts with $. Therefore, the alphabet
of A is polynomial in the input. The number of states needed for the various checks is
also polynomial, and therefore the size of A is polynomial in |C|.

6.4. A semi-algorithm for deciding the nonemptiness for ∀∃

The nonemptiness problem for NFH is undecidable already for the fragment of ∀∃,
as shown in Theorem 4. However, this fragment is of practical use in expressing ﬁnite-
word properties, as shown in Section 3. We now describe a semi-algorithm for testing
the nonemptiness of an NFH with a quantiﬁcation condition of the type ∀∃. Intuitively,
this procedure aims at ﬁnding the largest hyperword that is accepted by the NFH.

The procedure ﬁrst considers the set L0 of all the words that can be assigned to x1,
and checks whether this set subsumes the matching assignments for the ∃ quantiﬁer. If
so, then L0 is a suitable hyperword. Otherwise, L0 is pruned to the largest potential
hyperword by omitting from L0 all words that are not assigned to the variable under ∃,
and the procedure continues to the next round. In case that the procedure does not ﬁnd
an accepted hyperword, or conversely if the procedure does not reach an empty set, it
does not halt.

L0
exists a word in L0
We deﬁne L1

∀ = {u|∃v : wx(cid:55)→u,y(cid:55)→v ∈ L( ˆA)}, and let L0

We describe our procedure with more detail. Let A = (cid:104)Σ, {x, y}, Q, Q0, F, δ, ∀x∃y(cid:105)
be an NFH. Let L0
∃ = {v|∃u : wx(cid:55)→u,y(cid:55)→v ∈
L( ˆA)}. We denote the NFA obtained from ˆA by restricting the transitions to assign-
∀ = ˆAx is an NFA
ments to x by ˆAx, and similarly deﬁne ˆAy. It is easy to see that A0
for L0

∀, and A0
∃ ⊆ L0
If L0
∀ is accepted by A. If
∃ ∩ L0
∀ = ∅, then by the semantics of NFH, we have that A is empty. Otherwise, there

∃ = ˆAy is an NFA for L0
∃.
∀, then by the semantics of NFH, we have that L0

∀, and vice versa.

∀. Notice that L1

∃ is regular, and an NFA A1
∃. Now L1
∀ and A0

∃ that is not in L0
∃ ∩ L0
∃ = L0
∃ for L1
∃
can be calculated by the intersection construction for A0
∃ ⊆ L0
∀.
However, it may be the case that there exists a word u ∈ L0
∀ for which there ex-
ists no matching v ∈ L1
∀ = {u|∃v ∈ L1
∃ :
wx(cid:55)→u,y(cid:55)→v ∈ L( ˆA)}. We calculate an NFA A1
∀ for L1, as follows. Let A0
∃ =
(cid:104)P, Σ, p0, δ0, F0(cid:105). We deﬁne ˆA1 = (cid:104)Q × P, (Σ ∪ {#}){x,y}, (q0, p0), δ1, F1 × F2(cid:105),
y}, q(cid:48)) ∈ δ, (p, σ(cid:48), p(cid:48)) ∈
where δ1 = {((q, p), {σ(cid:48)
x, σy}, (q(cid:48), p(cid:48))|σ, σ(cid:48) ∈ Σ, (q, {σx, σ(cid:48)
δ0}. That is, ˆA1 is roughly the intersection construction of ˆA and A0
∃, when consider-
ing only the letter assignments to y. We denote this construction by ∩y. Finally, we set
A1

∃. Therefore, we restrict L0

∀ to a set L1

∃)∩L(A1
then L(A) = ∅. Otherwise, we repeat the process above with respect to ˆA1, A1

∀) is accepted by A, and if L(A1

∀), then L(A1

∃) ⊆ L(A1

∀) = ∅,
∀, A1
∃.

∀ = ˆA1
x.
Now, if L(A1

21

Algorithm 1 describes the procedure.

Algorithm 1: Nonemptiness test for ∀∃

Input: A.
Output: L(A) (cid:54)= ∅?
1 A∀ = ˆAx, A∃ = ˆAy
2 while true do
3

if L(A∃) ⊆ L(A∀) then

return tt

else if L(A∃) ∩ L(A∀) = ∅ then

4

5

6

7

8

return ff
A∃ = A∃ ∩ A∀
ˆA = ˆA ∩y A∃
A∀ = ˆAx

9
10 endwhile

7. Additional decision procedures

The universality problem is to decide whether a given NFH A accepts every hy-
perword over Σ. Notice that A is universal iff A is empty. Since complementing an
NFH involves an exponential blow-up, we conclude the following from the results in
Section 6, combined with the PSPACE lower bound for the universality of NFA.

Theorem 12. The universality problem for

1. NFH is undecidable,

2. NFH∃ and NFH∀ is PSPACE-complete, and

3. NFH∀∃ is in EXPSPACE.

We turn to study the membership problem for NFH: given an NFH A and a hyper-
word S, is S ∈ L(A)? When S is ﬁnite, so is the set of assignments from X to S, and
so the problem is decidable. We call this case the ﬁnite membership problem.

Theorem 13.

• The ﬁnite membership problem for NFH is in PSPACE.

• The ﬁnite membership problem for a hyperword of size k and an NFH with

O(log(k)) ∀ quantiﬁers is NP-complete.

Proof. Let S be a ﬁnite hyperword, and let A be an NFH with k variables. We can
decide the membership of S in L(A) by iterating over all relevant assignments from X
to S, and for every such assignment v, checking on-the-ﬂy whether wv is accepted by
ˆA. This algorithm uses space of size that is polynomial in k and logarithmic in |A|.

In the case that the number of ∀ quantiﬁers is O(log k), an NP upper bound is met
by iterating over all assignments to the variables under ∀, while guessing assignments

22

to the variables under ∃. For every such assignment v, checking whether wv ∈ L( ˆA)
can be done on-the-ﬂy.

We show NP-hardness for this case by a reduction from the Hamiltonian cycle
problem. Given a graph G = (cid:104)V, E(cid:105) where V = {v1, v2, . . . , vn} and |E| = m,
we construct an NFH∃ A over {0, 1} with n states, n variables, δ of size m, and
a hyperword S of size n, as follows. S = {w1, . . . , wn}, where wi is the word over
{0, 1} in which all letters are 0 except for the i’th. The structure of ˆA is identical to that
of G, and we set Q0 = F = {v1}. For the transition relation, for every (vi, vj) ∈ E,
we have (vi, ϕi, vj) ∈ δ, where ϕi assigns 0 to all variables except for xi. Intuitively,
the i’th letter in an accepting run of ˆA marks traversing vi. Assigning wj to xi means
that the j’th step of the run traverses vi. Since the words in w make sure that every
v ∈ V is traversed exactly once, and that the run on them is of length n, we have that A
accepts S iff there exists some ordering of the words in S that matches a Hamiltonian
cycle in G.
remark To account for all the assignments to the ∀ variables, δ – and therefore, ˆA
– must be of size at least 2k(cid:48)
(otherwise, we can return “no”). We then have that if
k = O(k(cid:48)), then space of size k is logarithmic in | ˆA|, and so the problem in this case
can be solved within logarithmic space. A matching NL lower bound follows from the
membership problem for NFA.

When S is inﬁnite, it may still be ﬁnitely represented, allowing for algorithmic
membership testing. We now address the problem of deciding whether a regular lan-
guage L (given as an NFA) is accepted by an NFH. We call this the regular membership
problem for NFH. We show that this problem is decidable for the entire class of NFH.

Theorem 14. The regular membership problem for NFH is decidable.

Proof. Let A = (cid:104)Σ, P, P0, ρ, F (cid:105) be an NFA, and let A = (cid:104)Σ, {x1, . . . , xk}, Q, Q0,
δ, F, α(cid:105) be an NFH.

First, we construct an NFA A(cid:48) = (cid:104)Σ ∪ {#}, P (cid:48), P (cid:48)

0, ρ(cid:48), F (cid:48)(cid:105) by extending the alpha-
bet of A to Σ ∪ {#}, adding a new and accepting state pf to P with a self-loop labeled
by #, and transitions labeled by # from every q ∈ F to pf . The language of A(cid:48) is then
L(A) · #∗. We describe a recursive procedure (iterating over α) for deciding whether
L(A) ∈ L(A).

For the case that k = 1, if α = ∃x1, then L(A) ∈ L(A) iff L(A) ∩ L( ˆA) (cid:54)= ∅.
Otherwise, if α = ∀x1, then L(A) ∈ L(A) iff L(A) /∈ L(A), where A is the NFH for
L(A). The quantiﬁcation condition for A is ∃x1, conforming to the base case.

For k > 1, we construct a sequence of NFA Ak, Ak−1 . . . , A1 as follows. Initially,
i , δi, Fi(cid:105). If Qi = ∃ , then we construct Ai−1 as follows.
i × P0. The set
f (xi)
−−−→ p(cid:48)) ∈ ρ,

Ak = ˆA. Let Ai = (cid:104)Σi, Qi, Q0
The set of states of Ai−1 is Qi × P , and the set of initial states is Q0
f
−→ q(cid:48)) ∈ δi and every (p
of accepting states is Fi × F . For every (q

}

f \{σixi
−−−−−−→ (q(cid:48), p(cid:48))) ∈ δi−1. We denote this construction by A ∩xi Ai.
we have ((q, p)
Then, Ai−1 accepts a word assignment wv iff there exists a word u ∈ L(A), such that
Ai accepts wv∪{xi(cid:55)→u}.

If Qi = ∀, then we set Ai−1 = A ∩xi Ai Notice that Ai−1 accepts a word assign-

ment wv iff for every u ∈ L(A), it holds that Ai accepts wv∪{xi(cid:55)→u}.

23

For

i ∈ [1, k],

let Ai be the NFH whose quantiﬁcation condition is
αi = Q1x1 · · · Qixi, and whose underlying NFA is Ai. Then, according to the con-
struction of Ai−1, we have that L(A) ∈ L(Ai) iff L(A) ∈ L(Ai−1).

The NFH A1 has a single variable, and we can now apply the base case.
Every ∀ quantiﬁer requires complementation, which is exponential in |Q|. There-

fore, in the worst case, the complexity of this algorithm is O(22...|Q||A|
), where the
tower is of height k. If the number of ∀ quantiﬁers is ﬁxed, then the complexity is
O(|Q||A|k).

The containment problem is to decide, given NFH A1 and A2, whether L(A1) ⊆
L(A2). Since we can reduce the nonemptiness problem to the containment problem,
we have the following as a result of Theorem 4.

Theorem 15. The containment problem for NFH is undecidable.

However, the containment problem is decidable for various fragments of NFH.

Theorem 16. The containment problem of NFH∃ ⊆ NFH∀ and NFH∀ ⊆ NFH∃ is
PSPACE-complete. The containment problem of NFH∃∀ ⊆ NFH∀∃ is in EXPSPACE

Proof. A lower bound for all cases follows from the PSPACE-hardness of the contain-
ment problem for NFA. For the upper bound, for two NFH A1 and A2, we have that
L(A1) ⊆ L(A2) iff L(A1) ∩ L(A2) = ∅. We can compute an NFH A = A1 ∩ A2
(Theorems 1, 3), and check its nonemptiness. Complementing A2 is exponential in its
number of states, and the intersection construction is polynomial.

If A1 ∈ NFH∃ and A2 ∈ NFH∀ or vice versa, then A is an NFH∃ or NFH∀,

respectively, whose nonemptiness can be decided in space that is logarithmic in |A|.

The quantiﬁcation condition of an NFH for the intersection may be any interleaving
of the quantiﬁcation conditions of the two intersected NFH. (Theorem 3). Therefore,
for the rest of the fragments, we can construct the intersection such that A is an NFH∃∀.
The exponential blow-up in complementing A2, along with The PSPACE upper bound
of Theorem 6 gives an EXPSPACE upper bound for the rest of the cases.

8. Related Work

It is well-known that classic speciﬁcation languages like regular expressions and
LTL cannot express hyperproperties. The study of speciﬁc hyperproperties, such as
noninterference, dates back to the seminal work by Goguen and Meseguer [29] in the
1980s. The ﬁrst systematic study of hyperproperties is due to Clarkson and Schnei-
der [14]. Subsequently, temporal logics HyperLTL and HyperCTL* were introduced [13]
to give formal syntax and semantics to hyperproperties. HyperLTL was recently ex-
tended to A-HLTL [6] to capture asynchronous hyperproperties, where some execution
traces can stutter while others advance.

There has been much recent progress in automatically verifying [27, 26, 25, 15, 31]
and monitoring [3, 24, 11, 9, 23, 35, 30] HyperLTL speciﬁcations. HyperLTL is also
supported by a growing set of tools, including the model checkers HyperQube [31],

24

MCHyper [27, 15], the satisﬁability checkers EAHyper [22] and MGHyper [20], and
the runtime monitoring tool RVHyper [23].

Related to the nonemptiness problem in this paper is the satisﬁability problem for
HyperLTL, which was shown to be decidable for the ∃∗∀∗ fragment, and undecidable
for any fragment that includes a ∀∃ quantiﬁer alternation [19]. The hierarchy of hyper-
logics beyond HyperLTL has been studied in [16]. Furthermore, our other results are
aligned with the complexity of HyperLTL model checking for tree-shaped and general
Kripke structures [5], which encode ﬁnite traces. In particular, our membership results
are in line with the results on the complexity of veriﬁcation in [5]. This shows that
the complexity results in [5] mainly stem from the nature of quantiﬁcation over ﬁnite
words and depend on neither the full power of the temporal operators nor the inﬁnite
nature of HyperLTL semantics.

The synthesis problem has shown to be undecidable in general, and decidable for
the ∃∗ and ∃∗∀ fragments. While the synthesis problem becomes, in general, unde-
cidable as soon as there are two universal quantiﬁers, there is a special class of uni-
versal speciﬁcations, called the linear ∀∗-fragment, which is still decidable [21]. The
linear ∀∗-fragment corresponds to the decidable distributed synthesis problems. The
bounded synthesis problem considers only systems up to a given bound on the number
of states. Bounded synthesis from hyperproperties is studied in [21], and has been suc-
cessfully applied to small examples such as the dining cryptographers [12]. Program
repair and controller synthesis for HyperLTL have been studied in [7, 8]. Our results on
bounded nonemptiness complement the known results, as it resembles the complexity
of bounded synthesis.

9. Discussion and Future Work

We have introduced and studied hyperlanguages and a framework for their model-
ing, focusing on the basic class of regular hyperlanguages, modeled by HRE and NFH.
We have shown that regular hyperlanguages are closed under set operations and are
capable of expressing important hyperproperties for information-ﬂow security policies
over ﬁnite traces. We have also investigated fundamental decision procedures for var-
ious fragments of NFH, conscentrating mostly on the important decision problem of
nonemptiness. Some gaps, such as the precise lower bound for the universality and
containment problems for NFH∃∀, are left open.

Since our framework does not limit the type of underlying model, it can be lifted
to handle hyperwords consisting of inﬁnite words, with an underlying model designed
for such languages, such as nondeterministic B¨uchi automata, which model ω-regular
languages. Just as B¨uchi automata can express LTL, such a model can express the
entire logic of HyperLTL [13].

As future work, we plan on studying non-regular hyperlanguages (e.g., context-
free), and object hyperlanguages (e.g., trees). Another direction is designing learning
algorithms for hyperlanguages, by exploiting known canonical forms for the underly-
ing models, and basing on existing learning algorithms for them. The main challenge
would be handling learning sets and a mechanism for learning word variables and quan-
tiﬁers.

25

References

[1]

´Abrah´am, E., Bartocci, E., Bonakdarpour, B., Dobe, O.: Probabilistic hyperprop-
erties with nondeterminism. In: Proceedings of the 18th Symposium on Auto-
mated Technology for Veriﬁcation and Analysis (ATVA). pp. 518–534 (2020)

[2]

´Abrah´am, E., Bonakdarpour, B.: HyperPCTL: A temporal logic for probabilistic
hyperproperties. In: QEST. pp. 20–35 (2018)

[3] Agrawal, S., Bonakdarpour, B.: Runtime veriﬁcation of k-safety hyperproperties
in HyperLTL. In: Proceedings of the IEEE 29th Computer Security Foundations
(CSF). pp. 239–252 (2016)

[4] Alpern, B., Schneider, F.: Deﬁning liveness. Information Processing Letters pp.

181–185 (1985)

[5] B. Bonakdarpour, B., Finkbeiner, B.: The complexity of monitoring hyperprop-

erties. In: CSF. pp. 162–174 (2018)

[6] Baumeister, J., Coenen, N., Bonakdarpour, B., S´anchez, B.F.C.: A temporal logic
for asynchronous hyperproperties. In: Proceedings of the 33rd International Con-
ference on Computer-Aided Veriﬁcation (CAV) (2021), to appear

[7] Bonakdarpour, B., Finkbeiner, B.: Program repair for hyperproperties. In: Pro-
ceedings of the 17th Symposium on Automated Technology for Veriﬁcation and
Analysis (ATVA). pp. 423–441 (2019)

[8] Bonakdarpour, B., Finkbeiner, B.: Controller synthesis for hyperproperties. In:
Proceedings of the IEEE 32th Computer Security Foundations (CSF). pp. 366–
379 (2020)

[9] Bonakdarpour, B., S´anchez, C., Schneider, G.: Monitoring hyperproperties by
combining static analysis and runtime veriﬁcation. In: ISoLA. pp. 8–27 (2018)

[10] Bonakdarpour, B., Sheinvald, S.: Finite-word hyperlanguages. In: Language and
Automata Theory and Applications - 15th International Conference, LATA 2021,
Milan, Italy, March 1-5, 2021, Proceedings. Lecture Notes in Computer Science,
vol. 12638, pp. 173–186. Springer (2021)

[11] Brett, N., Siddique, U., Bonakdarpour, B.: Rewriting-based runtime veriﬁcation
for alternation-free HyperLTL. In: Proceedings of the 23rd International Con-
ference on Tools and Algorithms for the Construction and Analysis of Systems
(TACAS). pp. 77–93 (2017)

[12] Chaum, D.: Security without identiﬁcation: Transaction systems to make big
brother obsolete. Communications of the ACM 28(10), 1030–1044 (1985)

[13] Clarkson, M., Finkbeiner, B., Koleini, M., Micinski, K., Rabe, M., S´anchez, C.:

Temporal logics for hyperproperties. In: POST. pp. 265–284 (2014)

26

[14] Clarkson, M., Schneider, F.: Hyperproperties. Journal of Computer Security pp.

1157–1210 (2010)

[15] Coenen, N., Finkbeiner, B., C. S´anchez, C., Tentrup, L.: Verifying hyperliveness.

In: CAV. pp. 121–139 (2019)

[16] Coenen, N., Finkbeiner, B., Hahn, C., Hofmann, J.: The hierarchy of hyperlog-
ics. In: Proceedings 34th Annual ACM/IEEE Symposium on Logic in Computer
Science (LICS). pp. 1–13 (2019)

[17] Emerson, E.A., Halpern, J.: “sometimes” and “not never” revisited: on branching
versus linear time temporal logic. Journal of the ACM pp. 151–178 (1986)

[18] Finkbeiner, B., Haas, L., Torfah, H.: Canonical representations of k-safety hyper-

properties. In: CSF 2019. pp. 17–31 (2019)

[19] Finkbeiner, B., Hahn, C.: Deciding hyperproperties. In: CONCUR. pp. 13:1–

13:14 (2016)

[20] Finkbeiner, B., Hahn, C., Hans, T.: MGHyper: Checking satisﬁability of Hyper-
LTL formulas beyond the \exists ˆ*\forall ˆ* ∃ ∗ ∀ ∗ fragment. In: Proceedings
of the 16th International Symposium on Automated Technology for Veriﬁcation
and Analysis (ATVA). pp. 521–527 (2018)

[21] Finkbeiner, B., Hahn, C., Lukert, P., Stenger, M., Tentrup, L.: Synthesizing re-
active systems from hyperproperties. In: Proceedings of the 30th International
Confer ence on Computer Aided Veriﬁcation (CAV). pp. 289–306 (2018)

[22] Finkbeiner, B., Hahn, C., Stenger, M.: Eahyper: Satisﬁability, implication, and
equivalence checking of hyperproperties. In: Proceedings of the 29th Interna-
tional Conference on Computer Aided Veriﬁcation (CAV). pp. 564–570 (2017)

[23] Finkbeiner, B., Hahn, C., Stenger, M., Tentrup, L.: RVHyper: A runtime veriﬁca-
tion tool for temporal hyperproperties. In: Proceedings of the 24th International
Conference on Tools and Algorithms for the Construction and Analysis of Sys-
tems (TACAS). pp. 194–200 (2018)

[24] Finkbeiner, B., Hahn, C., Stenger, M., Tentrup, L.: Monitoring hyperproperties.

Formal Methods in System Design (FMSD) 54(3), 336–363 (2019)

[25] Finkbeiner, B., Hahn, C., Torfah, H.: Model checking quantitative hyperproper-
ties. In: Proceedings of the 30th International Conference on Computer Aided
Veriﬁcation. pp. 144–163 (2018)

[26] Finkbeiner, B., M¨uller, C., Seidl, H., Zalinescu, E.: Verifying Security Policies in
Multi-agent Workﬂows with Loops. In: Proceedings of the 15th ACM Conference
on Computer and Communications Security (CCS) (2017)

[27] Finkbeiner, B., Rabe, M.N., S´anchez, C.: Algorithms for model checking Hyper-
LTL and HyperCTL*. In: Proceedings of the 27th International Conference on
Computer Aided Veriﬁcation (CAV). pp. 30–48 (2015)

27

[28] G. Boudol, G., Castellani, I.: Noninterference for concurrent programs and

thread. In: TCS 2002. pp. 109–130 (2002)

[29] Goguen, J., Meseguer, J.: Security policies and security models. In: IEEE Symp.

on Security and Privacy. pp. 11–20 (1982)

[30] Hahn, C., Stenger, M., Tentrup, L.: Constraint-based monitoring of hyperprop-
erties. In: Proceedings of the 25th International Conference on Tools and Al-
gorithms for the Construction and Analysis of Systems (TACAS). pp. 115–131
(2019)

[31] Hsu, T.H., S´anchez, C., Bonakdarpour, B.: Bounded model checking for hyper-
properties. In: Proceedings of the 27th International Conference on Tools and Al-
gorithms for Construction and Analysis of Systems (TACAS). pp. 94–112 (2021)

[32] McCullough, D.: Noninterference and the composability of security properties.
In: Proceedings of the 1988 IEEE Symposium on Security and Privacy. pp. 177–
186 (1988)

[33] Pnueli, A.: The temporal logic of programs. In: FOCS. pp. 46–57 (1977)

[34] Sabelfeld, A., Sands, D.: Probabilistic noninterference for multi-threaded pro-

grams. In: CSFW. pp. 200–214 (2000)

[35] Stucki, S., S´anchez, C., Schneider, G., Bonakdarpour, B.: Graybox monitoring of
hyperproperties. In: Proceedings of the 23rd International Symposium on Formal
Methods (FM). pp. 406–424 (2019)

[36] Vardi, M., Wolper, P.: Automata theoretic techniques for modal logic of pro-

grams. Journal of Computer and System Sciences pp. 183–221 (1986)

[37] Vardi, M., Wolper, P.: Reasoning about inﬁnite computations. Information and

Computation pp. 1–37 (1994)

[38] Wang, Y., Zarei, M., Bonakdarpour, B., Pajic, M.: Statistical veriﬁcation of hy-
perproperties for cyber-physical systems. ACM Transactions on Embedded Com-
puting systems (TECS) pp. 92:1–92:23 (2019)

[39] Zdancewic, S., Myers, A.: Observational determinism for concurrent program

security. In: CSFW. p. 29 (2003)

28

