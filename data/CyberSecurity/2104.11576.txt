Automating Cyber Threat Hunting Using NLP, Automated Query
Generation, and Genetic Perturbation

Prakruthi Karuna1
pkaruna@perspectalabs.com

Erik Hemberg2
hembergerik@csail.mit.edu
1Perspecta Labs, Inc. 2 MIT CSAIL

Una-May O’Reilly2
unamay@csail.mit.edu

Nick Rutar1
nrutar@perspectalabs.com

1
2
0
2

r
p
A
3
2

]

R
C
.
s
c
[

1
v
6
7
5
1
1
.
4
0
1
2
:
v
i
X
r
a

1

Introduction

Scaling the cyber hunt problem poses several key tech-
nical challenges. Detecting and characterizing cyber
threats at scale in large enterprise networks is hard be-
cause of the vast quantity and complexity of the data
that must be analyzed as adversaries deploy varied and
evolving tactics to accomplish their goals. There is a
great need to automate all aspects, and, indeed, the
workﬂow of cyber hunting. AI oﬀers many ways to sup-
port this. We have developed the WILEE system that
automates cyber threat hunting by translating high-
level threat descriptions into many possible concrete im-
plementations. Both the (high-level) abstract and (low-
level) concrete implementations are represented using a
custom domain speciﬁc language (DSL). WILEE uses
the implementations along with other logic, also writ-
ten in the DSL, to automatically generate queries to
conﬁrm (or refute) any hypotheses tied to the potential
adversarial workﬂows represented at various layers of
abstraction. We summarize WILEE in Section 2.

In this contribution we focus on presenting two AI
components of WILEE that coordinate to support its
automated query generation for hunting, see Figure 1.
First, in Section 3, we introduce a hunt component,
named Malmo, that uses Natural Language Processing
(NLP) to automate extraction and translation of known
threat descriptions. Known threats can be identiﬁed
with pattern recognition and signature-based meth-
ods. Their descriptions are embedded within human-
readable, semi-structured documents. Malmo extracts
and translates, to machine digestible format, key ﬁelds
of the documents including indicators of compromise,
to make them operational for the hunt.

Known threats evolve into unknown threats. Evolu-
tionary adaptations occur at the level of TTPs, i.e. at
the behavioral level, or, at the lower level of simple, but
eﬀective modiﬁcations of their signatures. This implies
that, to detect unknown threats, explorative variations
should also be hunted. The hunt needs to be widened,
while not becoming so wide as to overwhelm data col-
lection and its subsequent ﬁltering. To address these
challenges, WILEE introduces a genetic programming
hunt component [1]. Called Genetic Perturbation En-

Figure 1: AI Components for automated DSL Genera-
tion for use within the WILEE threat detection system.

gine, (GPE), the component is integrated both within
WILEE’s workﬂow, as a generator of perturbed threat
implementation, see Figure 7, and with Malmo, see Fig-
ure 8 as a way to replace a ﬁeld describing an indicator
of compromise (IOC ) of a known threat, with an al-
ternative of the same type, drawn from a database of
possibilities. We summarize GPE in Section 4.

Conclusions, and primarily future work directions

are presented in Section 5.

2 WILEE Framework and DSL

The primary input to the WILEE threat detector is
a Threat Description, which is expressed in the
input is a high level, mostly ab-
DSL. This initial
stract, workﬂow that the detector is hunting. Each
‘call’ from this description is an abstract TTP (tactic,
technique, or procedure) mapping primarily to MITRE
ATT&CK®[2] entries. An example of this input is
shown in Figure 3. This input is technically optional,
and if an abstract workﬂow is not deﬁned, WILEE will
attempt to detect the full ‘kill-chain’[3].

The Threat Interpreter takes in the Python DSL

This material is based upon work supported by the DARPA
Advanced Research Project Agency (DARPA) and Space and
Naval Warfare Systems Center, Paciﬁc (SSC Paciﬁc) under Con-
tract No. N66001-18-C-4036. The views, opinions, and/or ﬁnd-
ings expressed are those of the author(s) and should not be inter-
preted as representing the oﬃcial views or policies of the Depart-
ment of Defense or the U.S. Government. Approved for Public
Release, Distribution Unlimited.

1

 
 
 
 
 
 
(if explicitly deﬁned) and pulls all appropriate tac-
tics, techniques, and procedures from the TTP Store
to concretize all possible combinations of the abstract
workﬂow. An example of one TTP representation is
shown in Figure 4. While the DSL is Pythonic in syn-
tax, that code is never executed. Rather the Python
AST is parsed to generate all the possible queries needed
to query/inquire whether the events in the workﬂow are
occurring on the protected enclave. This generation of
the queries occurs in the Query Scheduler, which is
data store agnostic. The actual queries for the sup-
ported data stores takes place in the Data Proxy and
the query results allow WILEE to ingest the conﬁrmed
(or refuted) hypotheses as a graph with TTP-based in-
ferences between entities, into an internal data store. A
match algorithm is applied to the edges within that data
store in the Threat Matcher module. Finally, the
results are output to various formats (including Mark-
down, JavaScript, and ticketing systems like Redmine)
in the Threat Output module.

The WILEE framework has been successfully de-
ployed to categorize threats using data sets including
the Operationally Transparent Cyber (OpTC) evalua-
tion set[4] and in categorizing MITRE CALDERA [5]
based simulated attacks. In both of these deployments,
the DSLs representing the individual TTPs that were
used for categorization, and maintained/stored in the
WILEE TTP Store, were manually generated by a sub-
ject matter expert (SME). While the WILEE system is
fully automated, the dependence on these manually gen-
erated entries limits the breadth of TTPs WILEE can
detect, and lessens the speed at which it can model new
TTPs as they are incorporated within ATT&CK and
other threat models. The rest of this paper will discuss
how we are automating the process of DSL generation
utilizing NLP within Malmo and novel IOC generation
within GPE.

3 Malmo: Natural Language Pro-

cessing (NLP) Engine

MITRE ATT&CK provides a knowledge base of adver-
sarial tactics, techniques and procedures (TTPs) writ-
ten in a human readable format. However, it’s challeng-
ing for a computer to understand or hunt based on this
knowledge base as it’s not easily digestible for a cyber
hunt system. MITRE ATT&CK TTPs refer to several
network and host level entities such as ”system”, ”win-
dow registry keys”, ”process”. It is necessary to model
these entities to be able to capture the knowledge in the
TTPs, therefore, we use MITRE CybOX (Cyber Ob-
servable Expression) as our base data model. However,
CybOX does not contain all the entities referred to in

Figure 2: WILEE Threat Detector Framework

Figure 3: (Abstract) Threat Description DSL Example

Figure 4: (Concrete) TTP DSL Example

2

Figure 5: (Concrete) Malmo DSL Example

TTPs, therefore we extend this data model to include
objects referred to in the TTPs (e.g, active directory
in windows OS) but are not modeled in CybOX. Once
we have a detailed data model, we use this to write our
pythonic DSL that represents TTPs in a computer di-
gestible format.
In our DSL we represent each TTP
technique as a function as shown in Figure 4. Within
each function, we instantiate objects from our data
model and relate them using relations of type: “has”
and “observed”. By doing so we can represent all the
essential objects referred to in the technique and also re-
late them to form meaningful triplets of form: “system –
has – process”, process – observed – win registry key”.
We populate the variables associated with our objects
to values that are relevant to the technique. For ex-
ample Figure 4 shows the DSL for ATT&CK technique
T1552.002: Unsecured Credentials: Credentials in Reg-
istry where we populate variables winregistrykey1.Hive
to ”Software\*\Putty\Sessions” that is derived from
the technique description and variable process1.name
to ”TrojanSpy.Win32.TRICKBOT.AZ ”. By doing this
we are tying indicators of compromise (IOC) to diﬀer-
ent variables in our TTP description represented using
the DSL. Indicators of compromise are forensic artifacts
that are used as signs that a system has been attacked
or worse compromised by an attack or that it has been
infected with a particular malicious software.
In this
work, we use IOCs to identify attacker activity. Finding
data points using IOCs informs us with high conﬁdence
that there was attacker activity. However, each variable
could be associated with multiple IOC values. There-
fore, we store these IOCs in a database and query it on
the ﬂy. To do this we populate object variables with sql
queries written using SQLAlchemy notations as shown
in Figure 5.

We can also model red team tool-based indicators
using our DSL. We worked with the red team tool
CALDERA’s stockpile plugin that provides a set of
commands to replicate adversary behaviors as if a real
intrusion is occurring. An example command is: ”Get-
Process -Name ”powershell” — Stop-Process” where

Figure 6: Pipeline for DSL generation

an attacker abuses command and script interpreter as
described in technique T1059.001. We use such com-
mands to identify attacker activity.

3.1 Automated DSL Generation

Threats are ever evolving, and new techniques and pro-
cedures get added to the MITRE ATT&CK reposi-
tory often. However, generating such a detailed DSL
is a labor-intensive task. Therefore we use NLP tech-
niques to automate the generation of pythonic DSL
from MITRE ATT&CK TTPs. Our NLP pipeline is
as shown in Figure 6.

We take as input TTP technique descriptions, our
data model, and indicators of attacker activity. We
parse relevant phrases from technique description by
extracting noun phrases that follow the regular expres-
sion pattern of Adjective*Noun+. We then pre-process
our data model to retain classes and variables. We then
match the classes and variables to the phrases from text
to identify relevant classes and variables. To identify
relevant classes we compute the relevancy of a class to
a TTP technique based on the formulas below and in-
clude top n number of classes with the highest class in-
clusion value. We then instantiate classes and populate
variables with indicators of attacker activity using tem-
plate ﬁlling techniques. We ﬁnally relate these classes
based on previously seen relations.

∃ Word match if wordnoun phrase ∈ class name
and wordnoun phrase ∈ class.variable name

Relative importance of Word match =
1
(Frequency of wordnoun phrase in data model)

Percentage words matched in Word match =

Number of matched wordnoun phrase
Number of wordsvariable name

∗ 100

Word match value = (Relative imp of Word match)∗
(Percentage words matched in Word match)

(cid:80)

Class inclusion value =
variable∈class Word match value

3

4 Genetic Perturbations of IOCs

WILEE uses genetic programming (GP) as the algo-
rithm of GPE. Genetic Programming is an evolution-
ary algorithm where candidate solutions are executable
code that are manipulated in their parse tree represen-
tation. GP’s genetic operators can exchange the sub-
trees of code trees and maintain their ability to execute
without syntactic errors. A code tree is executed and
its compliance with output requirements determines its
ﬁtness. We use grammar-guided GP to allow the search
space of GP to be deﬁned independently of its variation
operators. For more information see [1, 6–8]. We chose
GP for WILEE because abstract syntax trees (ASTs)
can be extracted from WILEE’s threat implementa-
tions, as they are represented as Pythonic DSL. With
parse tree representations, they can be manipulated by
GP within the GPE to vary the hunt queries and IOC s.
This allows search at the abstract threat level.

Figure 7: GPE intercepts Threat Implementations
and perturbs them.

Threat Implementation Perturbation: Per Fig-
ure 7, GPE and its Threat Implementation pertur-
bation role are best described in the context of the
standard WILEE workﬂow. GPE is an optional in-
jection into this ﬂow.
It is fed a diverted Threat
Implementation from the Threat Interpreter and
then perturbs it to enlarge the space of variants around
the Threat Implementation, using adaptations that
are GP mutations or type-matched options from the
IOC database that is the cornerstone of Malmo. We
encounter several critical challenges. The ﬁrst is that
the GP system starts without ﬁtness values for one
or more candidate Threat Implementations because
their match quality is unknown. We solve this challenge
by using novelty search; a GP technique where genetic
selection prefers candidates that are diﬀerent from each
other, [9, 10]. We have improved novelty search to pro-
vide it with a knob-like feature that automatically bal-
ances each population between novel membership and
ﬁtness-based membership.[11] The second (open) chal-
lenge is that the ﬁtness of a Threat Implementation
at one point in time may be inaccurate at another. For
example, a Threat Implementation could be explored

4

Figure 8: MALMO and GP creating new IOCs.

before a C2C domain is established and thus be un-
ﬁt. But, in a system where, some time later, a C2C
is established, it would be ﬁt. The ﬁtness of a Threat
Implementation can also change if the ﬁltering of a
data stream changes and, with the change its match
changes.
IOC Perturbation: Figure 8 shows a second use of
GPE. We have implemented the ability for GPE to look
for <bind> values in the Threat Implementation,
and, on the basis of the type required, access match-
ing options in Malmo’s IOC database. This allows
the substitution of known threat information into con-
cretized Threat Implementations. We exploit GPE’s
aforementioned grammar, some constraint logic, and
(currently) blind mutation to do so. The ultimate
use case we have in mind would perturb bound values
with novel values that are informed by domain infor-
mation. For example, the Hive locator in ATT&CK
technique t1552.002 which is Software/SimonTatham/
Putty/Sessions could be intelligently cycled through
reasonable options that replace the putty program au-
thor’s name. While we have not assigned ﬁtness to var-
ious perturbations, this future work may need to be
handled with our novelty search.

5 Conclusion and Future Work

We have presented AI-based techniques for the automa-
tion of DSL entries in support of threat detection. The
primary focus for future work will be the evaluation
of these techniques. We currently have ’ground truth’
for which TTPs are deployed in adversarial simulations
in systems like CALDERA. Our immediate next step
is evaluating how WILEE performs when using SME
generated DSLs in comparison to automatically gener-
ated DSLs. For next steps for IOCs, when using IOC
based search data, we can learn attacker behaviors and
later use these learnt behavior to identify new IOCs. In
the future, we plan to identify variations of CALDERA
commands to further identify threats. Finally, we are
considering the value of the GPE adding perturbations
that are like regular expressions [12], directing the hunt
to a family of variants to which a threat may evolve.

THREATINTERPRETERGENETICPERTURBATIONENGINEQuerySCHEDULERSENSORDATA QUERYTHREATMATCHERHuntInterfaceTHREAT IMPLEMENTATIONTHREAT IMPLEMENTATIONPERTURBED THREAT IMPLEMENTATIONSENSOR REQUESTSENSOR RESPONSETHREAT IMPLEMENTATION MATCH (FITNESS)INDICATORS OF COMPROMISETHREAT IMPLEMENTATION MATCHIOC DBMALMOGRAMMARGENETIC PERTURBATION ENGINEJSONCONSTRAINTSJSONINFO ON WHERE DOMAIN NAMES OCCURIOC DBDOMAIN NAMEPERTURBED DOMAIN NAMEReferences

[1] James McDermott and Una-May O’Reilly. Genetic
programming. In Springer Handbook of Computa-
tional Intelligence, pages 845–869. Springer, 2015.

[2] Mitre att&ck. https://attack.mitre.org/.

[3] Cloppert Lockheed-Martin Corporation-Hutchins
and Amin.
Intelligence-driven computer network
defense informed by analysis of adversary cam-
paigns and intrusion kill chains, 2011.

[4] Optc-data.

https://github.com/

FiveDirections/OpTC-data.

[5] Caldera. https://caldera.readthedocs.io/en/

latest/.

[6] Riccardo Poli, William B Langdon, Nicholas F
McPhee, and John R Koza. A ﬁeld guide to ge-
netic programming. Lulu. com, 2008.

[7] Una-May O’Reilly and Erik Hemberg.

Introduc-
In Proceedings of
tion to genetic programming.
the Genetic and Evolutionary Computation Con-
ference Companion, pages 710–725, 2019.

[8] Robert

I McKay, Nguyen Xuan Hoai, Pe-
ter Alexander Whigham, Yin Shan, and Michael
O’neill. Grammar-based genetic programming: a
survey. Genetic Programming and Evolvable Ma-
chines, 11(3):365–396, 2010.

[9] Erik Hemberg, Jonathan Kelly, and Una-May
O’Reilly. On domain knowledge and novelty to im-
prove program synthesis performance with gram-
In Proceedings of the Genetic
matical evolution.
and Evolutionary Computation Conference, pages
1039–1046, 2019.

[10] Joel Lehman and Kenneth O Stanley. Eﬃciently
evolving programs through the search for novelty.
In Proceedings of the 12th annual conference on
Genetic and evolutionary computation, pages 837–
844, 2010.

[11] Jonathan Kelly, Erik Hemberg, and Una-May
O’Reilly.
Improving genetic programming with
novel exploration-exploitation control. In European
Conference on Genetic Programming, pages 64–80.
Springer, 2019.

[12] L. G. Michael, J. Donohue, J. C. Davis, D. Lee,
and F. Servant. Regexes are hard: Decision-
making, diﬃculties, and risks in programming reg-
ular expressions. In 2019 34th IEEE/ACM Inter-
national Conference on Automated Software Engi-
neering (ASE), pages 415–426, 2019.

5

