Secure State Estimation For Cyber Physical Systems Under
Sensor Attacks: A Satisﬁability Modulo Theory Approach

Yasser Shoukry, Pierluigi Nuzzo, Alberto Puggelli,
Alberto L. Sangiovanni-Vincentelli, Sanjit A. Seshia, and Paulo Tabuada

1

5
1
0
2

r
a

M
4
1

]

C
O
.
h
t
a
m

[

2
v
4
2
3
4
.
2
1
4
1
:
v
i
X
r
a

Abstract

Secure state estimation is the problem of estimating the state of a dynamical system from a set of noisy and adversarially
corrupted measurements. The secure state estimation is a combinatorial problem, which has been addressed either by brute force
search, suffering from scalability issues, or via convex relaxations using algorithms that can terminate in polynomial time but are
not necessarily sound. In this paper, we present a novel algorithm that uses a Satisﬁability-Modulo-Theory approach to lessen
the intrinsic combinatorial complexity of the problem. By leveraging results from formal methods over real numbers, we provide
guarantees on the soundness and completeness of our algorithm. Moreover, we provide upper bounds on the runtime performance
of the proposed algorithm in order to proclaim the scalability of the proposed algorithm. The scalability argument is then supported
by numerical simulations showing an order of magnitude decrease in the runtime performance with alternative techniques. Finally,
we demonstrate its application to the problem of controlling an unmanned ground vehicle.

I. INTRODUCTION

The detection and mitigation of attacks on Cyber-Physical Systems (CPS) is a problem of increasing importance. The tight
coupling between “cyber” components and “physical” processes often leads to systems where the increased sophistication
comes at the expense of increased vulnerability and security weaknesses. An important scenario is posed by a malicious
adversary that can arbitrarily corrupt the measurements of a subset of sensors in the system. These sensor-related attacks can
be deployed in any of the following components of a real-life CPS:

1) Software. Malicious software running on the processor executing the sensor processing routine can access the sensor
information before it is processed by the controller itself. The Stuxnet malware is an infamous example of this category
of attacks. It exploits vulnerabilities in the operating system running over SCADA devices [1] and once it obtains enough
operating system privileges, it can corrupt the sensor measurements collected via the attacked SCADA device.

2) Network. Modern control systems rely on a networked infrastructure to exchange sensor information. Therefore, an
adversarial attacker can corrupt sensor measurements by manipulating the data packets exchanged between various
components, as has been investigated, for instance, in smart grids [2].

3) Sensors Spooﬁng. By tampering with the sensor hardware and/or environment, an adversary can mislead the sensor about
the value of the physical signal it is attempting to measure. As previously shown by some of the authors, it is possible
to make drivers lose control of their cars by directly spooﬁng the velocity sensors of anti-lock braking systems in a
non-invasive manner [3].

This paper addresses the problem of detecting and mitigating the effects of an adversarial corruption of sensory data in a
linear dynamical system. While detection is concerned with determining which sensors are under attack, mitigation is concerned
with the ability to estimate the state of the underlying physical system from corrupted measurements, so that it can be used by
the controller. We call the latter problem secure state estimation. We focus on linear dynamical systems and model the attack
as a sparse vector added to the measurement vector. The entries corresponding to unattacked sensors are null while sensors
under attack are corrupted by non-zero signals. We make no assumptions regarding the magnitude, statistical description, or
temporal evolution of the attack vector.

While some prior work focused on the special cases of scalar system [4] and/or special structure on the attack signal (e.g.
replay attacks in [5]), the work reported in this work focuses on the case when the underlying system is multi-dimensional,
equipped with multiple sensors and without assumptions on the knolwedge of the time evolution of the attack signal. In such
case, the secure state estimation problem becomes a combinatorial problem [6], [7], [8]. We can broadly categorize the prior
work in this area based on the technique used to tackle the combinatorial aspect of the problem into two wide categories (i)
brute force search and (ii) convex relaxation.

The work reported in [7], [8] are representative of the ﬁrst class; brute force search. Pasqualetti et al. [7] provide a suite of
sound and complete algorithms to generate fault-monitor ﬁlters, which can be used to detect the existence of an attack. However,

Y. Shoukry and P. Tabuada with Electrical Engineering Department, UCLA, {yshoukry, tabuada}@ucla.edu
P. Nuzzo, A. Puggelli, A. L. Sangiovanni-Vincentelli, and S. A. Seshia are with Electrical Engineering and Computer Science Department, UC Berkeley,

{puggelli,nuzzo,alberto,sseshia}@eecs.berkeley.edu

This work was partially sponsored by the NSF award 1136174, by DARPA under agreement number FA8750-12-2-0247, by TerraSwarm, one of six
centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by the NSF project ExCAPE: Expeditions
in Computer Augmented Program Engineering (award 1138996). The U.S. Government is authorized to reproduce and distribute reprints for Governmental
purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted
as necessarily representing the ofﬁcial policies or endorsements, either expressed or implied, of NSF, DARPA or the U.S. Government.

 
 
 
 
 
 
2

if only an upper bound on the cardinality of the attacked sensors is available, the number of needed monitors is combinatorial
in the size of the attacked sensors, which might hinder the scalability of the approach. To avoid running a combinatorial
set of parallel monitors, Chong et al. [8] shows how all the monitors can be combined into a single multi-observer with a
combinatorial number of outputs. The algorithm reported in their work searches over all the outputs in order to discover which
sensors are under attack.

For the convex relaxation approach, prior work reported in [6] (for the case where sensors are ideal and not affected by
noise) and [9] (for the noisy case) shows how to formulate the secure state estimation problem as a non-convex l0 minimization
problem and then relax it into a convex a convex lr/l1 problem, which can be solved in polynomial time. The major drawback
of this relaxation step is the loss of correctness guarantees. In particular, we show experimental results, at the end of this paper,
for which the relaxed lr/l1 leads to incorrect results. To avoid the relaxation step while obtaining an algorithm that runs in
polynomial time, an alternative formulation was proposed in [10], [11]. However, correctness of the results obtained by the
proposed algorithms are guaranteed only when restrictive conditions are satisﬁed by the system structure.

Another suite of algorithms are also proposed for the secure state estimation without any formal guarantees on their
correctness. For example, a technique that relies on an on-line learning mechanism based on approximate envelopes of
collected data has also been recently reported [12]. The envelopes are used to detect any abnormal behavior without assuming
any knowledge of the dynamical system model. Another techniques are proposed in [13] and [14] in which robustiﬁcation
approaches for state estimation (using either Kalman Filters or Principal Component Analysis) against sparse sensor attacks
are proposed, again with no guarantees on their correctness.

In this work, we resort to techniques from formal methods to develop a sound and complete algorithm that can efﬁciently
handle the combinatorial complexity of the state estimation problem. We show that the state estimation problem can be cast
as a satisﬁability problem for a formula including logic and pseudo-Boolean constraints on Boolean variables as well as
convex constraints on real variables. The Boolean variables model the presence (or absence) of an attack, while the convex
constraints capture properties of the system state. We then show how this satisﬁability problem can be efﬁciently solved using
the Satisﬁability-Modulo-Theories (SMT) paradigm [15], speciﬁcally adapted to convex constraint solving [16], to provide
both the index of attacked sensors and the state estimate. To improve the execution time of our decision procedure, we equip
the convex constraint solver of our SMT-based algorithm with heuristics that can exploit the speciﬁc geometry of the state
estimation problem. Finally, we compare the performance of our approach against other algorithms via numerical experiments,
and demonstrate its effectiveness on the problem of controlling an Unmanned Ground Vehicle (UGV).

Technically, we make the following contributions:
• We formalize the secure state estimation problem as a satisﬁability problem which includes both boolean constraints and

convex constraints over real variables.

• We provide IMHOTEP1-SMT; a novel SMT-solver that is shown, formally, to provide a sound and complete solution to

the secure state estimation problem.

• We propose heuristics to improve the execution time of the IMHOTEP-SMT solver along with the real-time guarantees

given as the upper bounds on the number of iterations required by the proposed algorithm.

The rest of this paper is organized as follows. Section II introduces the formal setup for the problem under consideration.
The main contributions of this paper – the introduction of the SMT-based detector and the characterization of its soundness
and completeness – are presented in Section III and Section IV. Numerical comparisons and results are then shown in Section
V. Finally, Section VI concludes the paper and discusses new research directions.

We provide a mathematical formulation of the state estimation problem considered in this paper and discuss the conditions

for the existence and uniqueness of the solution.

II. THE SECURE STATE ESTIMATION PROBLEM

A. Notation

} \

supp(x). If S is a set,

The symbols N, R and B denote the sets of natural, real, and Boolean numbers, respectively. The symbols

denote
Rn, denoted by supp(x), is the set
the logical AND and logical NOT operators, respectively. The support of a vector x
of indices of the non-zero elements of x. Similarly, the complement of the support of a vector x is denoted by supp(x) =
Rn s-sparse, if x has at most s nonzero
1, . . . , n
(cid:107)2 the induced 2-norm
, we denote by
R(m−|Γ|)×n is

{
elements, i.e., if
of a matrix M
MΓ ∈
1Imhotep: (pronounced as “emmo-tepp”) was an ancient Egyptian polymath who is considered to be the earliest known architect, engineer and physician
in the early history. He is famous of the design of the oldest pyramid in Egypt; Pyramid of Djoser (the Step Pyramid) at Saqqara, Egypt, 2630 – 2611 BC.

∈
M
(cid:107)2 the 2-norm of x and by
x
(cid:107)
1, . . . , m
⊆ {
}
R|Γ|×n the matrix obtained from M by removing all the rows except those indexed by Γ. Then, MΓ ∈

S
|
|
s. For a vector x
Rm×n. We also denote by Mi

R1×n the ith row of M . For the set Γ

is the cardinality of S. We call a vector x

Rn, we denote by

supp(x)

|
∈

and

| ≤

∈

∧

∈

¬

∈

(cid:107)

the matrix obtained from M by removing the rows indexed by the set Γ, Γ representing the complement of Γ. For example,
if m = 4, and Γ =

1, 2
, we have
}

{

MΓ =

, MΓ =

(cid:21)

(cid:20)M1
M2

(cid:21)

(cid:20)M3
M4

.

3

B. System and Attack Model

We consider a system under sensor attack of the form:

Σa

(cid:40)

x(t+1) = Ax(t) + Bu(t),
y(t)

= Cx(t) + a(t) + ψ(t)

(II.1)

∈

∈

N, u(t)

Rn is the system state at time t

Rm is the system input, and y(t)

Rp is the observed output.
where x(t)
Rp is an
The matrices A, B, and C represent the system dynamics and have appropriate dimensions. The attack vector a(t)
s-sparse vector modeling how an attacker changed the sensor measurements at time t. If sensor i
is attacked then
the ith element in a(t) is non-zero; otherwise the ith sensor is not attacked. Hence, s describes the number of attacked sensors.
Note that we make no assumptions on the vector a(t) apart from being s-sparse. In particular, we do not assume bounds,
statistical properties, nor restrictions on the time evolution of the elements in a(t). The value of s is also not assumed to be
known, although we assume the knowledge of an upper bound s on the maximum number of sensors that can be attacked.
Rp represents the measurement noise, which is assumed to be bounded.
Finally, the vector ψ(t)

1, . . . , p

∈ {

∈

∈

∈

}

∈

C. Problem Formulation

To formulate the state estimation problem, we assume the state is recountsucted from a set of τ

N measurements, where
n is selected to guarantee that the system observability matrix, as deﬁned below, has full rank. Therefore, we can arrange

∈

≤

τ
the outputs from the ith sensor at different time instants as follows:
ix(t−τ +1) + E(t)

(cid:101)Y (t)
i =

i + FiU (t) + Ψ(t)

i

,









, E(t)

i =

where:

(cid:101)Y (t)
i =

Fi =


y(t−τ +1)
i
y(t−τ )


i

...


y(t)
i
0
CiB
...








O


a(t−τ +1)
i
a(t−τ )


i

...


a(t)
i
. . .
. . .
. . .

0
0

0
0
...
CiAτ −2B CiAτ −3B . . . CiB 0

0
0
















, Ψ(t)

i =








u(t−τ +1)
u(t−τ +2)
...
u(t)








,

i =

O

, U (t) =


ψ(t−τ +1)
i
ψ(t−τ )


i

...


ψ(t)
i









.








Ci
CiA
...
CiAτ −1








,

Since all the inputs in U (t) are known, we can further simplify the output equation as:

where Y (t)

i = (cid:101)Y (t)

i −

FiU (t). We also deﬁne:

Y (t) =

Y (t)
i =








Y (t)
1

...


Y (t)
p

ix(t−τ +1) + E(t)

i + Ψ(t)

i

O

,

, E(t) =








E(t)
1

...


E(t)
p

,

=

O






O1
...
p
O






(II.2)

(II.3)

to denote, respectively, the vector of outputs, attacks and observability matrices related to all sensors over the same time
window of length τ . Here, with some abuse of notation, Yi, Ei and
. Then,
by the same abuse of notation, we also denote by YΓ, EΓ, and

i are used to denote the ith block of Y, E and
OΓ the blocks indexed by the elements in the set Γ.

O

O

D. Problem Statement

4

For each individual sensor, we deﬁne a binary indicator variable bi

B such that bi = 0 when the ith sensor is attack-free

and bi = 1 otherwise. Based on the formulation in Sec. II-C, our goal is to ﬁnd x(t−τ +1) in (II.2), knowing that:
1) if a sensor is attack-free (i.e., bi = 0), then (II.2) reduces to Y (t)
2) Ψi is the upper bound on the norm of the noise at sensor i, i.e.,

ix(t−τ +1) = Ψ(t)
i

i − O

;

∈

3) the maximum number of attacked sensors is s.

Therefore, using the binary variables bi, we can pose the problem of secure state estimation as follows.

(cid:13)
(cid:13)Ψ(t)
(cid:13)

i

(cid:13)
(cid:13)
(cid:13)2 ≤

(cid:13)
(cid:13)
(cid:13)Ψi

(cid:13)
(cid:13)
(cid:13)2

,

N

t
∀

∈

Problem II.1. (Secure State Estimation) For the linear control system under attack Σa (deﬁned by (II.1)), construct an
estimate η = (x, b)

Rn

= φ, i.e., η satisﬁes the formula φ, where φ is deﬁned as:
|
(cid:33)

(cid:32) p

∈

×

Bp such that η
(cid:32)

φ ::=

p
(cid:94)

i=1

bi

¬

Yi

⇒ (cid:107)

− O

ix

Ψi

(cid:107)2 ≤ (cid:107)

(cid:107)2

(cid:94)

(cid:88)

bi

≤

i=1

(cid:33)
s

.

O

Ψi
(cid:107)

In Problem (II.1), Yi,
i are the vectors of outputs, measurement noise bound and the observability matrix related
(cid:107)2 and
ix) to be bounded only by the noise
to sensor i, as deﬁned in Sec. II-C. The ﬁrst conjunction of constraints requires (Yi
bound if sensor i is attack-free. We resort to the 2-norm of (Yi
ix) since the only information we have available about the
noise is a bound on its 2-norm. The second inequality enforces the cardinality constraint on the number of attacked sensors.
We drop the time t argument in Problem (II.1) since the satisﬁability problem is to be solved at every time instance. Note
that although we reconstruct a delayed version of the state x(t−τ +1), we can always reconstruct the current state x(t) from
x(t−τ +1) by recursively rolling the dynamics forward in time.

− O

− O

The secure state estimation problem II.1 does not ask for the minimal number of attacked sensors for which the estimated
state matches the measured output. That is, if b∗ is the vector of indicator variables characterizing the actual attack, any
assignment η = (x, b)
supp(b) is a valid solution for Problem II.1. Therefore, it is useful to modify
Problem II.1 to ask for the minimal number of attacked sensors that explains the collected measurements as follows.

= φ with supp(b∗)
|

⊆

Problem II.2. (Minimal Attack Support) For the linear control system under attack Σa construct the estimate η = (x, b)
obtained as the solution of the optimization problem:

∈

Rn

Bp

×

min
(x,b)∈Rn×Bp

p
(cid:88)

i=1

bi

s.t.

p
(cid:94)

i=1

(cid:32)

bi

¬

Yi

⇒ (cid:107)

− O

ix

Ψi

(cid:107)2 ≤ (cid:107)

(cid:107)2

(cid:19)

.

It is straightforward to show that the solution to Problem II.2 can be obtained by performing a binary search over s and
invoking a solver for Problem II.1 at each step, starting with s = s and then decreasing s until Problem II.1 becomes unfeasible
or s = 0. Since any solution of (II.2) must necessarily satisfy the constraints of Problem II.1, such a procedure will terminate
by returning the solution with the minimal attack support. We denote this solution as minimal support solution. In the reminder
of the paper, we will focus on the analysis of the feasibility problem II.1, since a solution to the optimization problem II.2
can be obtained by solving a sequence of instances of Problem II.1.

In Sec. II-E, we discuss the conditions for the uniqueness of the minimal support solution of Problem II.2. However, we ﬁrst
recall that the satisﬁability problem over real numbers, and speciﬁcally over Rn, is inherently intractable, i.e., decision algorithms
for formulas with non-linear polynomials already suffer from high complexity [17], [18]. Moreover, linear programming and
convex programming solvers usually perform ﬂoating point (hence inexact) calculations, which may be inadequate for some
applications. Therefore, to provide formal guarantees about correctness of Problem II.1, we resort to the notion of δ-completeness
which was previously used in [19].
Deﬁnition II.3 (Soundness and Completeness of Decision Algorithms for Problem II.1). Let a minimal solution η∗ = (x∗, b∗)
(the true state and indicator variables) exist for Problem II.1. Then, a solution η = (x, b)
= φ is said to δ-satisfy φ (or δ-SAT
|
2
R. Moreover, an algorithm that solves Problem II.1 is said
for short) if supp(b∗)
x
2 ≤
(cid:107)
⊆
to be δ-complete if it returns a δ-SAT solution.

δ for some δ

supp(b) and

x∗

−

∈

(cid:107)

Deﬁnition II.3 asks for an algorithm which terminates and returns a solution η = (x, b) that is correct (up to the tolerance
δ). Hence, a δ-complete decision algorithm in the sense of Deﬁnition II.3 is also (δ-)sound since, if it returns a solution η, η
is actually a δ-SAT solution.

E. Uniqueness of Minimal Support Solutions

To characterize the existence and uniqueness of solutions to Problem II.2, we recall the notion of s-sparse observability [11].

5

Deﬁnition II.4. (s-Sparse Observable System) The linear control system Σa, deﬁned by (II.1), is said to be s-sparse observable
if for every set Γ

= s, the system ΣΓ is observable, where ΣΓ is deﬁned as:

1, . . . , p

with

⊆ {

}

Γ
|

|

ΣΓ

(cid:40)

x(t+1) = Ax(t) + Bu(t),
= CΓx(t)
y(t)

t

∈

N

.

(II.4)

In other words, a system is s-sparse observable if it is observable from any choice of p
systems, the following result holds.

−

s sensors. For 2s-sparse observable

Theorem II.5. (Existence and Uniqueness of the Solution)[Theorem III.2 in [11]] In the noiseless case (Ψi = 0 for all
), Problem II.2 admits a unique solution η∗ = (x∗, b∗) if and only if the dynamical system Σa deﬁned by (II.1)
i
}
is 2s-sparse observable.

1, . . . , p

∈ {

The following result was established as part of the proof of Theorem II.5 in [11] and will be used in the SectionIII.

Proposition II.6. Let the dynamical system Σa deﬁned by (II.1) be 2s-sparse observable. The observability matrix
2s.
trivial kernel for any set

1, . . . , p

with

p

I has a

O

I ⊆ {

}

|I| ≥

−

Remark II.7. As stated in Theorem II.5, the state of Σa can be uniquely determined when the system is 2s-sparse observable.
This condition seems expensive to check because of its combinatorial nature: we have to check observability of all possible
systems ΣΓ. Yet, the 2s-sparse observability condition clearly illustrates a fundamental limitation for secure state estimation:
it is impossible to correctly reconstruct the state whenever a number of sensors larger than or equal to
is attacked, since
multiple states can be mapped to the same measurements.

p/2

(cid:100)

(cid:101)

Indeed, suppose that we have an even number of sensors p and s = p/2 sensors are attacked. Then, Theorem II.5 requires
the system to still be observable after removing 2s = p rows from the map C. However, this is impossible since CΓ becomes
the transformation mapping every state to zero. This fundamental limitation is consistent with previous results reported in the
literature [6], [20], [21].

Problem II.2 can be solved by transforming it into a Mixed Integer-Quadratic Program (MIQP) as follows:

min
(x,b)∈Rn×Bp

p
(cid:88)

i=1

bi

s.t.

Yi
(cid:107)

ix

(cid:107)2 ≤

− O

M bi +

Ψi
(cid:107)

(cid:107)21

≤

i

≤

p,

(II.5)

∈

R is a constant that should be “big” enough to make each constraint not active when bi = 1. The relaxation in (II.5)
where M
is typically used to express constraints including logical implications [22]; however, in this case, the choice of M affects the
completeness of the approach, which will depend on M . For example, since
(cid:107)2 is ultimately bounded by the power
(cid:107)2, in the absence of noise, can produce an incorrect result. While
of the attack
a physical sensor has a bounded dynamic range in practice, such a bound is not known a priori in our formulation, which
(cid:107)2. Therefore, completeness of the MIQP formulation (II.5) cannot be guaranteed in general.
makes no assumptions on
In the sequel, we detail an algorithm which exploits the geometry of the state estimation problem and the convexity of the
quadratic constraints to generate a provably correct solution using the SMT paradigm. We compare the SMT-based solution
with the MIQP formulation in (II.5) using a commercial MIQP solver.

(cid:107)2, a value of M <
Ei
(cid:107)

(cid:107)2 =

Ei
(cid:107)

Ei
(cid:107)

Yi
(cid:107)

Yi
(cid:107)

− O

− O

ix

ix

III. SMT-BASED DETECTOR

To decide whether a combination of Boolean and convex constraints is satisﬁable, we construct the detection algorithm
IMHOTEP-SMT using the lazy SMT paradigm [15]. As in the CalCS solver [16], our decision procedure combines a SAT
solver (SAT-SOLVE) and a theory solver (
-SOLVE) for convex constraints on real numbers. The SAT solver efﬁciently
reasons about combinations of Boolean and pseudo-Boolean constraints, using the David-Putnam-Logemann-Loveland (DPLL)
algorithm [23], to suggest possible assignments for the convex constraints. The theory solver checks the consistency of the
given assignments, and provides the reason for the conﬂict, a certiﬁcate, or a counterexample, whenever inconsistencies are
found. Each certiﬁcate results in learning new constraints which will be used by the SAT solver to prune the search space.
The complex detection and mitigation decision task is thus broken into two simpler tasks, respectively, over the Boolean and
convex domains. We denote the approach as lazy, because it checks and learns about consistency of convex constraints only
when necessary, as detailed below.

T

Algorithm 1 IMHOTEP-SMT

6

(cid:17)

ci

∧

(cid:16)(cid:80)

i∈{1,...,p} bi

(cid:17)
s

;

≤

bi

i∈{1,...,p} ¬

1: status := UNSAT;
(cid:16)(cid:86)
2: φB :=
⇒
3: while status == UNSAT do
4:
5:
6:
7:
8:
∧
9: return η = (x, b);

(b, c) := SAT-SOLVE(φB);
(status, x) :=
if status == UNSAT then

φcert :=
T
φB := φB

φcert;

T

-SOLVE.CHECK(supp(b));

-SOLVE.CERTIFICATE(b, x);

A. Overall Architecture

As illustrated in Algorithm 1, we start by mapping each convex constraint to an auxiliary Boolean variable ci to obtain the

following (pseudo-)Boolean satisﬁability problem:

φB ::=





(cid:94)

i∈{1,...,p}



bi

¬

⇒

ci



∧





(cid:88)

i∈{1,...,p}



s


bi

≤

(cid:107)

Yi

ix

Ψi

− O

(cid:107)2 ≤ (cid:107)

where ci = 1 if
(cid:107)2 is satisﬁed, and zero otherwise. By only relying on the Boolean structure of the
problem, SAT-SOLVE returns an assignment for the variables bi and ci (for i = 1, . . . , p), thus hypothesizing which sensors
are attack-free, hence which convex constraints should be jointly satisﬁed.

This Boolean assignment is then used by

Rn which satisﬁes all the
supp(b). If x is found, IMHOTEP-SMT
convex constraints related to the unattacked sensors, i.e.
− O
terminates with SAT and provides the solution (x, b). Otherwise, the UNSAT certiﬁcate φcert is generated in terms of new
Boolean constraints, explaining which sensor measurements are conﬂicting and may be under attack. The most naive certiﬁcate
can take the form of:

-SOLVE to determine whether there exists a state x

(cid:107)2 for i

(cid:107)2 ≤ (cid:107)

Yi
(cid:107)

Ψi

ix

∈

∈

T

φUNSAT-cert =

(cid:88)

i∈supp(b)

bi

1,

≥

T

which encodes the fact that at least one of the sensors in the set supp(b) (i.e. for which bi = 0) is actually under attack. This
augmented Boolean problem is then fed back to SAT-SOLVE to produce a new assignment. The sequence of new SAT queries
is then repeated until

-SOLVE terminates with SAT.

By the 2s-sparse observability condition (Theorem II.5), there always exists a unique solution to Problem II.2, hence
Algorithm 1 will always terminate. However, to help the SAT solver quickly converge towards the correct assignment, a central
problem in lazy SMT solving is to generate succinct explanations whenever conjunctions of convex constraints are unfeasible,
possibly highlighting the minimum set of conﬂicting assignments. The rest of this section will then focus on the implementation
of the two main tasks of
-SOLVE.CHECK), and (ii)
-SOLVE, namely, (i) checking the satisﬁability of a given assignment (
-SOLVE.CERTIFICATE). For clarity’s sake, we focus on the noiseless case (Ψ = 0)
generating succinct UNSAT certiﬁcates (
in this section; we will extend our results to the noisy case in Section IV.

T

T

T

B. Satisﬁability Checking

Given an assignment of the Boolean variables b, with

supp(b)

s, the following condition holds:

|

| ≤

min
x∈Rn

(cid:13)

(cid:13)Ysupp(b) − Osupp(b)x(cid:13)

2
(cid:13)
2 ≤

0

(III.1)

if and only if (x, b) is the solution of Problem II.2. This is a direct consequence of the 2s-sparse observability property
discussed in Section II. The preceding unconstrained least-squares optimization problem can be solved very efﬁciently, thus
leading to Algorithm 2. In practical implementations, (III.1) should actually be replaced with:

min
x∈Rn

(cid:13)

(cid:13)Ysupp(b) − Osupp(b)x(cid:13)

2
(cid:13)
2 ≤

(cid:15),

where (cid:15) > 0 is the solver tolerance, accounting for numerical errors. As for noise, for the sake of clarity, we focus here on
the case when (cid:15) is zero and defer the discussion for non-zero tolerance to the next section.

Since Algorithm 2 is the basic block of our SMT-based detector, it is important to characterize its soundness and completeness,

as is done in the following result.

)

7

I
YI

2
2

Ix
(cid:107)

− O

Algorithm 2

-SOLVE.CHECK(

(cid:107)
2
2 = 0 then
YI
Ix
(cid:107)
(cid:107)
− O
status = SAT;

T
1: Solve: x := arg minx∈Rn
2: if
3:
4: else
status = UNSAT;
5:
6: return (status, x);

Lemma III.1. Let the linear dynamical system Σa deﬁned in (II.1) be 2s-sparse observable. Let
Ψi
(cid:107)
and let also (cid:15) = 0 be the numerical solver tolerance for Algorithm 2. Then for any index set
I
Algorithm 2 returns SAT if and only if the following holds:

(cid:107)2 = 0 for all i
with cardinality

1, . . . , p
}
s,
p

∈ {
|I| ≥

−

1)
2)

supp(b∗),
2
2 = 0,

x
(cid:107)

−

I ⊆
x∗
(cid:107)

where (x∗, b∗) is the solution to Problem II.2 and x is computed on line 1 of Algorithm 2.

Proof: Since the “if” condition is trivial to show, we focus on the “only if” condition as follows. Deﬁne

(cid:48) as the set of
(cid:48). We can write the result from lines 1 and 2

I

indices of the sensors that are attack free. Deﬁne also
of Algorithm 2 as:

I

(cid:48)(cid:48) as the set

(cid:48)(cid:48) =

I

I \ I

min
x∈Rn (cid:107)

YI

2
2 = 0
Ix
(cid:107)
(cid:88)

− O
min
x∈Rn

⇒

min
x∈Rn

⇒

i∈I
(cid:88)
i∈I(cid:48) (cid:107)

Yi
(cid:107)

− O

2
2 = 0

ix

(cid:107)

Yi

ix

− O

2
2 +
(cid:107)

Yi

ix

2
2 = 0
(cid:107)

− O

min
x∈Rn (cid:107)O

⇒

I(cid:48)(x∗

2
2 +
x)
(cid:107)

−

i(x∗

2
x) + E∗
2 = 0
i (cid:107)

−

(cid:88)
i∈I(cid:48)(cid:48) (cid:107)
(cid:88)
i∈I(cid:48)(cid:48) (cid:107)O

Hence, in order for Algorithm 2 to return SAT, both terms
the optimal point.

I(cid:48)(x∗

x)
(cid:107)

−

(cid:107)O

2

2 and (cid:80)

i∈I(cid:48)(cid:48)

i(x∗

2
x) + E∗
2 must vanish at
i (cid:107)

−

(cid:107)O

Since at most s sensors are under attack, we conclude that

2s. Hence, it follows from
2
x)
Proposition II.6 that the observability matrix
2 evaluates
(cid:107)
to zero if and only if x = x∗. This, in turn, implies that the solution of the optimization problem in line 1 of Algorithm 2 is
x∗ and hence

−
I(cid:48) has a trivial kernel. Therefore, we conclude that

is at most s and

I(cid:48)(x∗

| ≥

(cid:107)O

|I

|I

O

−

x

p

|

(cid:48)(cid:48)

(cid:48)

supp(b∗). However, this follows from the requirement that (cid:80)

i∈I(cid:48)(cid:48)

i(x∗

(cid:107)O

x) + E∗
i (cid:107)

−

2
2

−
To conclude, we need to show that

x∗
(cid:107)

2
2 = 0.
(cid:107)

vanishes at the optimal point, i.e., for x = x∗. Hence:

I ⊆

(cid:88)
i∈I(cid:48)(cid:48) (cid:107)O

i(x∗

x) + E∗
i (cid:107)

−

2
2 = 0

⇒

(cid:88)
i∈I(cid:48)(cid:48) (cid:107)

2
E∗
2 = 0
i (cid:107)

which, in turn, implies that all the sensors indexed by

(cid:48)(cid:48) are attack free. Combining this result with the deﬁnition of the set

I

(cid:48) we conclude that all the sensors indexed by
When noise and/or non-zero numerical tolerance is present, we modify Algorithm 2 by checking instead whether the optimal
x drives the objective function below the noise level and the numerical tolerance. Clearly, satisfying such a constraint on the
2-norms is not sufﬁcient to retrieve the actual state in the sense of Deﬁnition II.3: attacks having a relatively small power may
not be detected. Therefore, in Section IV, we will determine which conditions to require on the noise level and the numerical
tolerance to achieve δ-completeness as in Deﬁnition II.3.

are actually attack free, and the inclusion

supp(b∗) holds.

I ⊆

I

I

C. Generating UNSAT certiﬁcates

Whenever

T

-SOLVE.CHECK provides UNSAT, a certiﬁcate could be easily generated as follows:

φtriv-cert =

(cid:88)

i∈supp(b)

bi

1,

≥

(III.2)

indicating that at least one of the sensors, which was initially assumed as attack-free (i.e. for which bi = 0), is actually under
attack; one of the bi variables should then be set to one in the next assignment of the SAT solver. However, such trivial
certiﬁcate φtriv-cert does not provide much information, since it only excludes the current assignment from the search space,
and can lead to exponential execution time, as reﬂected by the following proposition.

10

8

6

4

2
x

10

8

6

4

2
x

10

8

6

4

2
x

0

1

2

3

4

5

0

1

2

3

4

5

0

1

2

3

4

5

8

x1

(a) Four hyperplanes corresponding to measure-
ments from 4 different sensors. The red hyper-
plane corresponds to the sensor under attack.
All other hyperplanes intersect at
the unique
solution. The optimal point is marked as a black
box.

x1

x1

(b) An example of a run of Algorithm 3. In the ﬁrst iteration (left), the set I min r contains
the p−2s = 4−2×1 = 2 indexes of the sensors that correspond to the minimal residuals. This
set is a non-conﬂicting set and hence the corresponding hyperplanes have a unique intersection
point. In the second iteration (right), the index of the sensor corresponding to the maximum
residual is added to the set Itemp resulting into a conﬂict. Algorithm 3 terminates and returns
the conﬂicting set Itemp (In both cases, the optimal point is marked as a black box).

Fig. 1. Pictorial examples illustrating the geometrical intuitions behind Algorithm 3.

1, . . . , p

Proposition III.2. Let the linear dynamical system Σa deﬁned in (II.1) be 2s-sparse observable. Let
(cid:107)2 = 0 for all
and let also (cid:15) = 0 be the numerical solver tolerance for Algorithm 2. Then, Algorithm 1 which uses the trivial
i
∈ {
UNSAT certiﬁcate φtriv-cert in (III.2) is δ-complete (in the sense of Deﬁnition II.3) with δ = 0. Moreover, the upper bound on
the number of iterations of Algorithm 1 is (cid:80)s

Ψi
(cid:107)

}

(cid:0)p
s

(cid:1).

s=0

Proof: δ-Completeness of Algorithm 1 follows directly from Lemma III.1. To derive the bound on the number of iterations,
we ﬁrst recall that the 2s-sparse observability condition ensures uniqueness of a minimal solution (Theorem II.5). The worst
case scenario would happen when the solver exhaustively explores all possible combinations of attacked sensors with cardinality
less than or equal to s in order to ﬁnd the correct assignment. This is equal to (cid:80)s

(cid:1) iterations.

(cid:0)p
s

s=0

D. Enhancing the Execution Time

The generated UNSAT certiﬁcates heavily affects the overall execution time of Algorithm 1: the smaller the certiﬁcate,
the more information is learnt and the faster is the convergence of the SAT solver to the correct assignment. For example, a
certiﬁcate with bi = 1 would identify exactly one attacked sensor at each step, a substantial improvement with respect to the
exponential worst-case complexity of the plain SAT problem, which is NP-complete. Hence, and inspired by the theoretical
underpinnings of CALCS [16], we focus on designing heuristics that can lead to more compact certiﬁcates to enhance the
execution time of IMHOTEP-SMT. To do so, we exploit the speciﬁc structure of the secure state estimation problem and
generate customized, yet stronger, UNSAT certiﬁcates. In this subsection, we focus on generating two types of certiﬁcates
called (i) conﬂicting certiﬁcates and (ii) agreeable certiﬁcates.

First, we observe that the measurements of each sensor Yi =

ix deﬁne a hyperplane Hi

Rn as:

Hi =

x
{

∈

Rn

|

.
ix = 0
}

− O

O
Yi

⊆

The dimension of Hi is given by the dimension of the null space of the matrix
i). Then,
satisﬁability checking in Algorithm 2 can be reformulated as follows. Let ri be the residual of the state x with respect to the
2
hyperplane Hi, deﬁned as ri(x) =
ix
2. The optimization problem in Algorithm 2 is equivalent to searching for a
point x that minimizes the individual residuals with respect to all the hyperplanes Hi for i

i, i.e., dim(Hi) = dim(ker

Yi
(cid:107)

, i.e.:

− O

O

O

(cid:107)

min
x∈Rn (cid:107)

YI

Ix

2
2 = min
x∈Rn
(cid:107)

− O

(cid:88)

i∈I

Yi
(cid:107)

− O

ix

2
2 = min
x∈Rn
(cid:107)

(cid:88)

i∈I

∈ I
ri(x).

Based on the formulation above, it is straightforward to state and show the following result.

Proposition III.3. Let the linear dynamical system Σa deﬁned in (II.1) be 2s-sparse observable. Let
i
the following statements are equivalent:

Ψi
(cid:107)
and let also (cid:15) = 0 be the numerical solver tolerance for Algorithm 2. Then for any set of indices

1, . . . , p

∈ {

}

(cid:107)2 = 0 for all
,
1, . . . , p
}
I ⊆ {

) returns UNSAT,

•

-SOLVE.CHECK(

T
• minx∈Rn (cid:80)
• (cid:84)
Hi =

i∈I

I
i∈I ri(x) > 0,
.

∅

1) Smaller Conﬂicting Sensor Set: To generate a compact Boolean constraint that explains a conﬂict, we aim to ﬁnd a
small set of sensors that cannot all be attack-free. Their existence is guaranteed by the following proposition whose proof
exploits the geometric interpretation provided by the hyperplanes Hi.

9

Proposition III.4. Let the linear dynamical system Σa deﬁned in (II.1) be 2s-sparse observable. Let
1, . . . , p
i
}
, with
set
|I|
is also UNSAT.

and let also (cid:15) = 0 be the numerical solver tolerance for Algorithm 2. If
> p

(cid:107)2 = 0 for all
Ψi
(cid:107)
) is UNSAT for a
-SOLVE.CHECK(
I
temp)

2s, then there exists a subset

-SOLVE.CHECK(

2s + 1 such that

∈ {
I

with

⊂ I

| ≤

temp

temp

|I

−

−

T

T

I

I

p

Proof: Consider any set of sensors

⊂ I
exist, then the result follows trivially. If the set
and hence the intersection (cid:84)
Proposition III.3 that:

I

(cid:48)

I

i∈I(cid:48) Hi is a single point, named x(cid:48). Now, since

2s and (cid:84)
such that
(cid:48) exists, then it follows from Proposition II.6 that

i∈I(cid:48) Hi is not empty. If such set

= p

|I

−

|

(cid:48)

(cid:48) does not
I
I(cid:48) has a trivial kernel
) is UNSAT, it follows from

O

-SOLVE.CHECK(

I

T

Hi =

(cid:92)

i∈I

(cid:92)

Hi

i∈I(cid:48)

∩

∅ ⇒

(cid:92)

Hi =

i∈I\I(cid:48)

x(cid:48)

∅ ⇒ {

(cid:92)

} ∩

i∈I\I(cid:48)

Hi =

,
∅

which in turn implies that there exists at least one sensor i
point x(cid:48). Now, we deﬁne
temp as

temp =

i and note that

(cid:48)

I

I

I

∪

∈ I \ I
|I

temp

| ≤

−

(cid:48) such that its hyperplane Hi does not pass through the
2s + 1, which concludes the proof.

p

Using Proposition III.4, our objective is to ﬁnd a small set of hyperplanes that fails to intersect. Hence, if an assignment
for the convex constraints is UNSAT, our conjecture is that the p
2s hyperplanes with the lowest (normalized) residuals are
most likely to have a common intersection point, which can then be used as a candidate intersection point for the hyperplanes
with the higher (normalized) residuals, one-by-one, until a conﬂict is detected. A pictorial illustration of this intuition is given
in Figure 1(a). Based on this intuition, we propose the following procedure, summarized in Algorithm 3.

−

I

T

Algorithm 3

-SOLVE.CERTIFICATE-CONFLICT(

, x)

,

;

}

ix

I
I

∈ I

− O

i
(cid:107)O

ri :=

2
2 /
(cid:107)

r := (cid:83)

2
2 , i
(cid:107)

r sorted := sortAscendingly(r);

1: Compute normalized residuals
Yi
ri
2:
i∈I {
(cid:107)
3: Sort the residual variables
4:
5: Pick the index corresponding to the maximum residual
max r := Index(r sorted{|I|,|I|−1,...,p−2s+1});
6:
min r := Index(r sorted{1,...,p−2s});
7:
8: Search linearly for the UNSAT certiﬁcate
status = SAT;
9:
min r
temp :=
10:
11: while status == SAT do
(status, x) :=
12:
if status == UNSAT then
13:
14:
15:

T
φconf-cert := (cid:80)

-SOLVE.CHECK(

max rcounter;

counter = 1;

i∈I temp bi

temp);

else

∪ I

1;

≥

I

I

I

temp :=

counter := counter + 1;

16:
min r
17:
18: [Optional] Sort the rest according to dim(ker
temp2 = sortAscendingly(dim(ker
19:
20:

max rcounter;

{O
temp2

counter2 =

∪ I

I temp
1;

I

I

)
{O}
));
}

temp2{1,...,counter2};

|I

| −

I
status = UNSAT;
temp2 :=

I

I

21:
22: while status == UNSAT do
23:
24:
25:

(status, x) :=
T
if status == SAT then
φconf-cert := (cid:80)

else

26:
27:

counter2 := counter2 - 1;

-SOLVE.CHECK(

temp);

I

i∈I temp2{1,...,counter2+1}

bi

1;

≥

28:
I
29: return φconf-cert

temp2 :=

I

temp2{1,...,counter2};

We ﬁrst compute the (normalized) residuals ri for all i

minimum (normalized) residuals indexed by
hyperplanes indexed by

2s
min r, and search for one more hyperplane that leads to a conﬂict with the
min r. To do this, we start by solving the same optimization problem as in Algorithm 2, but on

, and sort them in ascending order. We then pick the p

∈ I

−

I

I

10

max r is the index associated with the
the reduced set of hyperplanes indexed by
hyperplane having the maximal (normalized) residual. If this set of hyperplanes intersect in one point, they are labelled as
max r with the hyperplane
“non-conﬂicting”, and we repeat the same process by replacing the hyperplane indexed by
associated with the second maximal (normalized) residual from the sorted list, till we reach a conﬂicting set of hyperplanes.
Once the set is discovered, we stop by generating the following, more compact, certiﬁcate:

max r, where

temp =

min r

∪ I

I

I

I

I

A sample execution of Algorithm 3 is illustrated in Figure 1(b).

φconf-cert :=

(cid:88)

i∈Itemp

bi

1.

≥

Finally, as a post-processing step, we can further reduce the cardinality of

temp by exploiting the dimension of the
hyperplanes corresponding to the index list. Intuitively, the lower the dimension, the more information is provided by the
corresponding sensor. For example, a sensor i with dim(Hi) = dim(ker
−1
i Yi. This
restricts the search space to the unique point and makes it easier to generate a conﬂict formula. Therefore, to converge faster
towards a conﬂict, we iterate through the indexes in
temp and remove at each step the one which corresponds to the hyperplane
with the highest dimension until we are left with a reduced index set that is still conﬂicting.

i) = 0 corresponds to only one point

O

O

I

I

The following result provides an upper bound for the performance of the proposed heuristic.

1, . . . , p

Proposition III.5. Let the linear dynamical system Σa deﬁned in (II.1) be 2s-sparse observable. Let
(cid:107)2 = 0 for all
and let also (cid:15) = 0 be the numerical solver tolerance for Algorithm 2. Then, Algorithm 1 using the conﬂicting
i
∈ {
UNSAT certiﬁcate φconf-cert in Algorithm 3 is δ-complete (in the sense of Deﬁnition II.3) with δ = 0. Moreover, the upper bound
on the number of iterations of Algorithm 1 is (cid:0)

Ψi
(cid:107)

(cid:1).

}

p
p−2s+1

Proof: δ-Completeness follows from Lemma III.1 along with the 2s observability condition. The upper bound on the
number of iterations of Algorithm 1 can be derived as follows. First, it follows from Proposition III.4 that each certiﬁcate
2s + 1 sensors. Since we know that the algorithm always terminates, the worst case would then happen
φconf-cert has at most p
when the solver exhaustively generates all conﬂicting sets of cardinality p
2s + 1. This leads to a number of iterations equal
to (cid:0)

(cid:1).

−

−

p
p−2s+1

2) Agreeable Sensor Set: This heuristic aims to ﬁnd a set of p

2s sensors that all agree on the same x. We recall that
2s sensors. Accordingly, for
the 2s-sparse observability condition ensures that the state is fully observable from any set of p
a given set of sensors, we select the p
2s sensors, hence hyperplanes, that correspond to minimal residuals. We then check
whether they all intersect in one point x. In such case, we inform the SAT solver that all of these sensors are unattacked, by
generating the following certiﬁcate:

−

−

−

φagree-cert :=

(cid:88)

bi = 0,

i∈I min r

2s hyperplanes with the lowest residuals.

where

min r is the set of indexes of the p

I

−

The procedure described above is summarized in Algorithm 4. As evident from line 9 of Algorithm 4, φagree-cert is not always
generated; therefore, we use this heuristic, when it is successful, only as a complement of the previously discussed UNSAT
certiﬁcate. Moreover, the heuristic itself is not always applicable. In fact, it is still possible to design an attack such that up
to s attacked sensors agree on a single value of x. Hence, an additional condition is required as reﬂected in the following
proposition.

1, . . . , p

Proposition III.6. Let the linear dynamical system Σa deﬁned in (II.1) be 3s-sparse observable. Let
(cid:107)2 = 0 for all
and let also (cid:15) = 0 be the numerical solver tolerance for Algorithm 2. Then, Algorithm 1 using the agreeable
i
∈ {
UNSAT certiﬁcate φagree-cert in Algorithm 4 is δ-complete (in the sense of Deﬁnition II.3) with δ = 0. Moreover, whenever
(cid:0)2s
φagree-cert is generated, Algorithm 1 terminates within (cid:80)s
s

(cid:1) iterations.

Ψi
(cid:107)

s=0

}

satisﬁes

Proof: δ-Completeness of Algorithm 4 is equivalent to showing the soundness and completeness of Algorithm 2. It follows
from Proposition III.1 that Algorithm 2 is sound and complete whenever the system is 2s-sparse observable and when the
s. Hence, to show the result, it is enough to replicate the proof of Proposition III.1 under
cardinality of
the assumption that the system is 3s-sparse observable and the cardinality of

2s.
The bound on the number of iterations can be derived as follows. First, we note that φagree-cert assigns p

2s as being
unattacked sensors. This in turn forces the solver to search for the attacked sensors in the remaining set of sensors with
2s) = 2s. The bound then follows using the same argument of Proposition III.2.
caridinality p

satisﬁes instead

|I| ≥

|I| ≥

(p

−

−

−

I

I

p

p

−

−

E. Soundness and Completeness of Algorithm 1, Noiseless Case

The procedure

-SOLVE.CERTIFICATE(

, x) in line 7 of Algorithm 1 can be implemented as shown in Algorithm 5. We

are now ready to state the main result of this section, which is a direct consequence of our previous results.

T

I

, x)

11

ix

2
2 /
(cid:107)

2
2 , i
(cid:107)

i
(cid:107)O

;

∈ I

− O

Algorithm 4

-SOLVE.CERTIFICATE-AGREE(

I

T

r sorted := sortAscendingly(r);

,

}

ri :=

r := (cid:83)

1: Compute individual residuals
Yi
ri
2:
i∈I {
(cid:107)
3: Sort the residual variables
4:
5: Pick the p
6:
I
(status, x) :=
7:
T
8: φagree-cert :=TRUE;
9: if status == SAT then
φagree-cert := (cid:80)
10:
11: return φagree-cert

−

i∈I min r bi = 0;

min r := Index(r sorted{1,...,p−2s}));

-SOLVE.CHECK(

min r);

I

2s indexes corresponding to the minimum residuals

Theorem III.7. Let the linear dynamical system Σa deﬁned in (II.1) be 2s-sparse observable.
1, . . . , p
}
and let also (cid:15) = 0 be the numerical solver tolerance for Algorithm 2. Algorithm 1 is δ-complete (in the sense of Deﬁnition
II.3) with δ = 0.

(cid:107)2 = 0 for all i

Ψi
(cid:107)

∈ {

T

Algorithm 5
1: φcert :=
2: if p > 3s then
φagree-cert :=
3:
T
φcert := φcert ∧
4:
5: return φcert

-SOLVE.CERTIFICATE(

T
-SOLVE.CERTIFICATE-CONFLICT(

I

, x)

, x);

I

-SOLVE.CERTIFICATE-AGREE(
φagree-cert;

, x);

I

IV. COMPLETENESS IN THE PRESENCE OF NOISE

As discussed in the previous section, IMHOTEP-SMT can always detect any compromised sensors in the absence of
) and when the numerical tolerance is zero ((cid:15) = 0). In this section,
Ψi
measurement noise (
}
(cid:107)
we characterize completeness in the presence of noise and/or numerical tolerance in the solver, by determining to what extent
an attack signal can be hidden by noise and/or numerical tolerance, thereby making it unfeasible to reconstruct the true state.
Since Algorithm 1 consists of multiple invocations of the least-squares problem, the completeness of the detector entirely
depends on the correctness of Algorithm 2 in checking the satisﬁability of a Boolean assignment over b.

(cid:107)2 = 0 for all i

1, . . . , p

∈ {

The completeness of Algorithm 2 will in turn depend on two major components: (i) the tolerance of the numerical solvers,
which is typically a small value used as a stopping criterion, and can be controlled by the user; (ii) the noise margin intrinsic
to the dynamical system model. To account for these two components, we replace the satisﬁability condition in line 2 of
Algorithm 2 with the following condition:

(cid:107)2 ≤ (cid:107)
where (cid:15) > 0 is the user-deﬁned tolerance. To characterize soundness and completeness of Algorithm 2, we ﬁrst recall that the
solution of the unconstrained least squares problem in Algorithm 2 is given by:

− O

(cid:107)

YI

Ix

ΨI

(cid:107)2 + (cid:15)

(IV.1)

where
O
Algorithm 2 depends on the properties of the matrix

T
I is the Moore-Penrose pseudo inverse of

T
I O

O

I

+

I = (cid:0)
O

(cid:1)−1

O

O
I. It is apparent that soundness and completeness of

+
I . Accordingly, we deﬁne the following two, technical, quantities.

O

x = (cid:0)

T
I O

I

O

(cid:1)−1

T
I YI =

O

+
I YI

Deﬁnition IV.1. Deﬁne o

R+ as:

∈

where

O

+
I Moore-Penrose pseudo inverse of

I.

O

o = max

I⊆{1,...,p}

(cid:13)
(cid:13)

+
I
O

(cid:13)
2
(cid:13)
2

Deﬁnition (Proposition) IV.2. Let the linear system deﬁned in (II.1) be 2s-sparse observable and deﬁne ∆s

∆s =

max
Γ⊂I⊆{1,...,p}
|Γ|≤s,|I|≥p−s

λmax






(cid:32)

(cid:88)

i∈Γ

T
i
i O

O

(cid:33) (cid:32)

(cid:88)

i∈I

(cid:33)−1




T
i
i O

O

R+ as:

∈

Then, for any s-sparse attack vector E, the following holds:

(cid:13)
(cid:13)(I

+
I )EI

O

(cid:13)
2
(cid:13)
2 ≥

(1

−

∆s)

EI

(cid:107)

2
2
(cid:107)

I

− O

with ∆s strictly less than 1.

Proof: First deﬁne the set Γ

Hence:

⊂ I

as the set of indices on which the attack vector E is supported and note that EΓ = 0.

12

(cid:13)
(cid:13)(I

+
I )EI

− O

I

O

(cid:13)
2
2 = ET
(cid:13)
= ET

I

I EI

(cid:0)I

− O

I

O

(cid:1)2

+
I

EI

(a)
= ET
I

(cid:0)I

ET

I O

I(

I)−1

T
I O

I

(cid:1) EI

+
I
O
− O
(b)
= ET
Γ EΓ −

O
where, equality (a) follows from the fact that the matrix I
of the set Γ. The second term can be bounded as:
I)−1

ET
λmax{OΓ(
Γ OΓ(
O
O
Hence, to show that the result holds, we need to show that the inequality:

Γ EΓ ≤
O

I

− O

T
I O

O

−

T

T
I O

I)−1

T
Γ }

O

ET

Γ EΓ

T
I EI

T
ET
Γ OΓ(
I O
O
O
+
I is idempotent and equality (b) follows from the deﬁnition

T
Γ EΓ

I)−1

O

holds for any set
I
dimensions, λmax{

and Γ
AB

⊂ I
= λmax{

}

with

Γ
|
BA

s and

p
| ≤
. Hence, we can rewrite (IV.2) as:
}
I)−1

T

λmax{O

Γ OΓ(

T
I O

O

}

< 1.

I)−1

T
λmax{OΓ(
I O
O
s. First, recall that for any two matrices A and B with appropriate
−
|I| ≥

(IV.2)

T
Γ }

< 1

O

Now notice that:

and rewrite (IV.2) as:

T
I O

O

I =

(cid:88)

i∈I

T
i O

O

i =

(cid:88)

i∈Γ

T
i O

i +

O

(cid:88)

i∈I\Γ

T
i
i O

O

=

T

Γ OΓ +
O

T
I\ΓOI\Γ

O

λmax

(cid:26)

(cid:16)

T
Γ OΓ

O

T

Γ OΓ +

T
I\ΓOI\Γ

O

O

(cid:17)−1(cid:27)

< 1

where the set
matrix
holds.

Γ has a cardinality of at least p

2s. Hence, it follows from the 2s-sparse observability condition that the
I\ΓOI\Γ is positive deﬁnite and therefore we can apply Proposition A.1 in the appendix to show that the statement
O

I \

−

T

Using these two quantities, we can state our main result, which is the noisy version of Theorem III.7.

Theorem IV.3. Let the linear system deﬁned in (II.1) be 2s-sparse observable, and let (cid:15) > 0 be the numerical solver tolerance.
Then, for any attack Ei satisfying:

2
2 >

Ei
(cid:107)

(cid:107)

(cid:18) 2
1

−

(cid:19)

Ψ

2
2 +
(cid:107)

(cid:107)

1

∆s

(cid:15)

−

,

∆s

(IV.3)

Algorithm 1, modiﬁed as in (IV.1), is δ-complete with δ = o

2
2.
(cid:107)
Proof: To prove the result, we need to show that the check (IV.1), resulting in δ-satisﬁability, is satisﬁed if and only if

Ψ
(cid:107)

no sensor in

is under attack.

I

If no sensor is under attack, condition (IV.1) is trivially satisﬁed. Therefore, we focus on proving the reverse implication,
is under attack, then (IV.1) does not hold as long as the attack Eia satisﬁes (IV.3). To
which contains the attacked sensor ia. Recall that the solution of the unconstrained least squares

∈ I

showing that if at least one sensor ia
do so, we consider the set
problem in Algorithm 2 is given by:

I

+

I = (cid:0)

where
optimal point can be bounded from below as:

O

O

O

I

T
I O

(cid:1)−1

T
I is the Moore-Penrose pseudo inverse of

O

x = (cid:0)

T
I O

O

I

(cid:1)−1

T
I YI =

O

+
I YI

O
I. Hence, the value of the objective function at the

YI
(cid:107)

Ix

2
2
(cid:107)

− O

(cid:13)YI

(a)

= (cid:13)
= (cid:13)

(c)

(cid:13)(I

I

− O

I

− O

O

(b)

= (cid:13)

(cid:13)
2
+
I YI
(cid:13)(I
(cid:13)
2
− O
O
(d)
I )(ΨI + EI)(cid:13)
2
+
(cid:13)
2

I
(cid:12)
(cid:12)
(cid:12)

O
(cid:13)
(cid:13)(I

+
I )(

O

≥

− O

Ix∗ + ΨI + EI)(cid:13)
2
(cid:13)
2
(cid:13)
(cid:13)
2
(cid:13)(I
(cid:13)
2 −

+
I )EI

O

I

I

− O

+
I )ΨI

O

(cid:13)
2
(cid:13)
2

(cid:12)
(cid:12)
(cid:12)

where (a) follows from (II.2); (b) follows from the deﬁnition of YI; (c) follows from the fact that
inequality (d) follows from the inverse triangular inequality.

I
O

+
I O

O

I =

(IV.4)

I; and the

O

13

(IV.5)

On the other hand, the condition on the attack signal (IV.3) implies that:
(cid:18) 2
1

(cid:18) 2
1

Eia(cid:107)
(cid:107)

2
2 +
(cid:107)

2
2 >

Ψ
(cid:107)

∆s ≥

∆s

(cid:19)

1

(cid:15)

(cid:19)

ΨI
(cid:107)

2
2 +
(cid:107)

1

(cid:15)

∆s

−

∆s

−

Hence, by noticing that

EI
(cid:107)

(cid:107)

−
−
2
2, we conclude that:

2
Eia (cid:107)
2 ≥ (cid:107)
2
2 >

EI
(cid:107)

(cid:107)

(cid:18) 2
1

−

(cid:19)

∆s
∆s)

∆s)

(cid:107)
EI
(cid:107)

EI
(cid:107)

∆s)

(cid:107)

EI

I

− O
I

− O

O

O

I

− O

O

(cid:15)

1

ΨI

ΨI
(cid:107)

ΨI
(cid:107)

2
2 +
(cid:107)
2
2 >
(cid:107)
2
2 >
(cid:107)
2
2 >
ΨI
(cid:107)
(cid:107)
(cid:13)
2
+
I )EI
2 >
(cid:13)
(cid:13)
2
+
I )EI
(cid:13)
2 −
(cid:13)
2
(cid:13)
2 −

+
I )EI

2

I

−

O

+
I

− O

2
2 + (cid:15)
(cid:107)

(cid:13)
2
(cid:13)
2 (cid:107)
+
I )ΨI

∆s
2
2 +
ΨI
(cid:107)
(cid:107)
2 + (cid:13)
2
(cid:13)I
(cid:107)
2 + (cid:13)
(cid:13)(I
− O
(cid:107)
2 + (cid:13)
2
(cid:13)(I
ΨI
I
− O
(cid:107)
(cid:107)
O
(cid:13)
(cid:13)
2
+
(cid:13)(I
2 >
I )ΨI
(cid:13)
(cid:107)
(cid:12)
(cid:13)
(cid:13)
2
(cid:12)
(cid:12) >
(cid:13)(I
(cid:13)
2

+
I )ΨI

− O

O

O

I

I

I

− O

(1

(1

−

−

−

(1
(cid:13)
(cid:13)(I
(cid:13)
(cid:13)(I
(cid:12)
(cid:13)
(cid:12)
(cid:13)(I
(cid:12)

⇒
(e)
⇒
(f )
⇒
(g)
⇒

⇒
(h)
⇒

2
ΨI
2 + (cid:15)
(cid:107)
(cid:13)
2
2 + (cid:15)
(cid:13)
(cid:13)
2
2 + (cid:15)
(cid:13)
2
2 + (cid:15)
(cid:107)
2
2 + (cid:15)
ΨI
(cid:107)

+
I )ΨI
ΨI

(cid:13)
2
where, the implication (e) follows from the fact that the matrix I
1; (f )
(cid:13)
2 ≤
O
(cid:107)2; (g) follows
follows from the properties of the induced norm which implies that
from Proposition IV.2; ﬁnally, (h) follows from the right hand side of the inequality being positive and hence the left hand
side is also positive along with the fact that

O
− O
O
R is positive.
Combining the bounds (IV.4) and (IV.5) we conclude that the following holds:

(cid:13)
(cid:13)I
− O
(cid:13)
+
(cid:13)2 (cid:107)
I
O

= a whenever a

I
− O
(cid:13)
(cid:13)(I

I
ΨI

a
|
|

− O

+
I

∈

(cid:107)

O
+
I is idempotent and hence
(cid:13)
(cid:13)2 ≤
I

+
I )ΨI

(cid:13)
(cid:13)I

I

which implies that the result of Algorithm 2 is UNSAT whenever (IV.3) is satisﬁed.

The error bound δ can be then computed directly as:

YI
(cid:107)

Ix

2
2 >
(cid:107)

ΨI
(cid:107)

2
2 + (cid:15)
(cid:107)

− O

x∗
(cid:107)

x

2

2 = (cid:13)

(cid:13)x∗

+
I YI

(cid:13)
2
(cid:13)
2

(i)

= (cid:13)
(cid:13)

+
I ΨI

(cid:13)
2
(cid:13)
2 ≤

(cid:13)
(cid:13)

+
I

(cid:13)
2
(cid:13)
2 (cid:107)

ΨI

2
2
(cid:107)

(j)

o

Ψ
(cid:107)

2
2 ,
(cid:107)

O
where, the equality (i) follows from the fact that all attacks satisfy (IV.3) and hence can be detected. Accordingly, the set
contains only sensors which is attack free and therefore (II.2) can be simpliﬁed into:

− O

O

−

≤

(cid:107)

I

Finally, the inequality (j) the follows from the deﬁnition of o in IV.1.

Remark IV.4. In the previous proof, we rely on the assumption that:

YI =

Ix∗ + ΨI.

O

However, since we do not know the set
assumption:

I

that will be used in Theorem IV.5.

2
2 >

EI

(cid:107)

(cid:107)

(cid:18) 2
1

−

(cid:19)

ΨI
(cid:107)

(cid:107)

2
2 +

1

∆s

(cid:15)

∆s

−

, which is selected by the underlying SAT solver, we resort to the more conservative

Ei

(cid:107)

2
2 >
(cid:107)

(cid:18) 2
1

−

∆s

(cid:19)

2
2 +

Ψ
(cid:107)

(cid:107)

1

(cid:15)

∆s

−

The previous result characterizes the class of attack signals that will lead to detection. However, a smart attacker may be
tempted to inject attack signals which are not detected by the proposed algorithm, but yet increase the estimation error. The
following result, characterizes the estimation error in the presence of un-detectable attacks.

Theorem IV.5. Let the linear system deﬁned in (II.1) be 2s-sparse observable, and let (cid:15) > 0 be the numerical solver tolerance.
Algorithm 1, modiﬁed as in (IV.1), returns an estimate x which satisﬁes:

x∗
(cid:107)

x
(cid:107)

2
2 ≤

−

(cid:18)

2o

1 +

(cid:19)

2
∆s

−

1

2
2 +

Ψ
(cid:107)

(cid:107)

1

2o(cid:15)

∆s

−

.

14

+
I ΨI

+
I EI

2 = (cid:13)
(cid:13)
2
(cid:13)
(cid:13)
O

+
I ΨI

− O

− O

+
I EI

(cid:13)
2
(cid:13)
2

Proof: The error

x∗
(cid:107)

−

2

x∗
x
(cid:107)
(cid:107)
−
2 = (cid:13)
(cid:13)x∗
x
2 (cid:13)
(cid:13)

(a)

2
2 can be bounded as follows:
2 = (cid:13)
(cid:13)
2
(cid:13)x∗
(cid:13)
2 + 2 (cid:13)
2
(cid:13)
O
(cid:107)

+
I O
− O
(cid:13)
2
+
(cid:13)
I
2 (cid:107)

+
I YI

ΨI

O

(cid:107)

Ix∗

EI

(cid:107)

− O
2
2

− O
(cid:13)
2
+
(cid:13)
I
2 (cid:107)
2
2 + 2o
(cid:107)
Ψ

2
2 + 2o
(cid:107)

2o

Ψ
(cid:107)

2o

(cid:107)
(cid:18)

≤
(b)

≤
(c)

≤

= 2o

1 +

2
2
(cid:107)

EI
(cid:107)
2
∆s (cid:107)

1

−
(cid:19)

2
∆s

Ψ
(cid:107)

2
2 +
(cid:107)

Ψ

2
2 + 2o
(cid:107)

1

2o(cid:15)

(cid:15)

∆s

−

∆s
where the inequality (a) follows from Cauchy-Schwarz inequality; (b) from the deﬁnition of o in (IV.1) along with the fact
2
2; ﬁnally (c) follows from Theorem IV.3 (along with Remark IV.4) which shows that only attacks with
ΨI
that
(cid:107)
(cid:107)
norm:

2
2 ≤ (cid:107)
(cid:107)

−

Ψ

−

1

1

are not detected by Algorithm 1 and hence can affect the estimation error.

EI
(cid:107)

2
2 ≤

(cid:107)

(cid:19)

(cid:18) 2
1

−

∆s

Ψ
(cid:107)

2
2 +
(cid:107)

1

(cid:15)

∆s

−

V. EXPERIMENTAL RESULTS
We developed our theory solver in MATLAB, and interfaced it with the pseudo-Boolean SAT solver SAT4J [24]. All the
experiments were executed on an Intel Core i7 3.4-GHz processor with 8 GB of memory. To validate our approach, we
ﬁrst compare the effect of the two proposed heuristics on the required number of iterations. We then compare the runtime
performance against previously proposed algorithms. Then, we demonstrate the effect of attack detection on the problem of
controlling a robotic vehicle under sensor attacks.

A. Runtime Performance

φagree-cert, is used.

To assess the effectiveness of the heuristics introduced in Sec. III-D, Figure 2(a) shows the number of iterations of IMHOTEP-
SMT when only one of the three certiﬁcates, the trivial certiﬁcate φtriv-cert, the conﬂicting certiﬁcate φconf-cert, and the joint
certiﬁcate φconf-cert ∧
In the ﬁrst experiment (top), we increase the number s of actual sensors under attack for a ﬁxed s = 20 (n = 25, p = 60).
In the second experiment (bottom), we increase both n and p simultaneously, with p = 3n, while p/3 sensors are under attack,
and s = p/3. In both cases, the system is constructed to be 3s-sparse observable, with the dimensions of the kernels of
i
O
2, meaning that the state is “poorly” observable from individual sensors. We also show the
ranging between n
number of iterations against the theoretical limit in Proposition III.5. We observed an average of 50
reduction in iterations
when φconf-cert was used compared to φtriv-cert, while using both φconf-cert and φagree-cert decreased the number of iterations by a
factor of 75.

1 and n

×

−

−

We also compared the performance of IMHOTEP-SMT against the MIQP formulation (II.5), the ETPG algorithm [11], and

the lr/l1 decoder [6], with respect to both execution time and estimation error.

The MIQP is solved using the commercial solver GUROBI [25], the ETPG algorithm is implemented in MATLAB, while
the lr/l1 decoder is implemented using the convex solver CVX [26]. Figure 2 reports the numerical results in two test cases.
In Figure 2(b), we ﬁx the number of sensors p = 20 and increase the number of system states from n = 10 to n = 150. In
Figure 2(c), we ﬁx the number of states n = 50 and increase the number of sensors from p = 3 to p = 150. In both cases, half
of the sensors are attacked. Our algorithm always outperforms both the ETPG and the lr/l1 approaches and scales nicely with
respect to both n and p. In particular, as evident from Figure 2(b), increasing n has a small effect on the overall execution
time, which reﬂects the fact that the number of constraints to be satisﬁed does not depend on n. Conversely, as shown in
Figure 2(c), as the number of sensors increases, the number of constraints, hence the execution time of our algorithm, also
increases. The runtime of the MIQP formulation in (II.5) scales worse than our algorithm with n, but better with p, because
GUROBI can efﬁciently process many conic constraints (whose number scales with p) but is more sensitive to the size of each
conic constraint (which scales with n). Finally, Figure 2(b) (bottom) shows that the lr/l1 decoder reports incorrect results in
multiple test cases, because of its lack of soundness, as discussed in Section I.

B. Attacking an Unmanned Ground Vehicle

We apply our algorithms to the model of a UGV, as detailed in [11], [9], under different types of sensor attacks. We assume
that the UGV moves along straight lines and completely stops before rotating. Under these assumptions, we can describe the
dynamics of the UGV as:

(cid:21)

(cid:20) ˙x
˙v

=

(cid:20)0
1
0 −B
M

(cid:21)

(cid:21) (cid:20)x
v

+

(cid:20) 0

(cid:21)

1
M

F,

15

30

60

90

120

150

Number of sensors p

)
c
e
s
(

e
m

i
t

n
o
i
t
u
c
e
x
E

30

20

10

0

3

10−2

·

2
(cid:107)

∗
x

(cid:107)

/
2
(cid:107)

x

−

∗
x

(cid:107)

8

6

4

2

0

Theoretical limit

)
c
e
s
(

e
m

i
t

n
o
i
t
u
c
e
x
E

200

150

100

50

0

5

10

15

20

Number of attacked sensors s

10

25

50

75

100

150

Number of states n

s
n
o
i
t
a
r
e
t
i

f
o

r
e
b
m
u
N

s
n
o
i
t
a
r
e
t
i

f
o

r
e
b
m
u
N

500

400

300

200

100

0

1

500

400

300

200

100

0

1

104
·

1.5

1

0.5

2
(cid:107)

∗
x

(cid:107)

/
2
(cid:107)

x

−

∗
x

(cid:107)

0

10

Theoretical limit

5

10

15

20

Number of states n

φtriv-cert

φconf-cert

φconf-cert ∧

φagree-cert

(a) Number of iterations in Algorithm 1 versus
number of attacked sensors (top) and number of
states and sensors (down) for different heuris-
tics.

25

50

75

100

150

Number of states n

SMT

MIQP

ETPG

lr/l1

3

30

60

90

120

150

Number of sensors p

SMT

MIQP

ETPG

lr/l1

(b) Execution time (top) and estimation error
(bottom) versus number of states n for different
algorithms (p = 20, s = 5).

(c) Execution time (top) and estimation error
(bottom) versus number of sensors p for differ-
ent algorithms (n = 50, s = p/2 − 1).

Fig. 2. Simulation results showing number of iterations, execution time, and estimation error with respect to number of states and number of sensors.

where x and v are the states, corresponding to the UGV position and linear velocity, respectively. The parameters M and
B denote the mechanical mass and the translational friction coefﬁcient. The inputs to the UGV is the force F . The UGV is
equipped with a GPS sensor which measures its position and two motor encoders which measure the translational velocity.
The resulting output equation is:

y =


1
0

0


0
1

1

(cid:21)

(cid:20)x
v

+



 ,





ψ1
ψ2
ψ3

ψ1|

|

where ψi is the measurement noise on the ith sensor which is assumed to be bounded. In our experiments, we used M = 0.8 kg,
B = 1,

2 = 0.2 (m/s)2.

2 = 0.2 m2,

2 =

The model is discretized with a time step equal to 0.1 s. The SMT-based detector uses the discretized model along with
sensor measurements to provide an estimate for the state vector, which is then used by a feedback controller to regulate the
robot and follow a squared-shape path of length equal to 5 m.

ψ2|
|

ψ3|

|

Figure 3 shows the performance of the SMT-based detector. The attacker alternates between corrupting the left and the right
encoder measurements as shown in Figure 3(b). Three different types of attacks are considered. First, the attacker corrupts the
sensor signal with random noise. The next attack consists of a step function followed by a ramp. Finally, a replay-attack is
mounted by replaying the previously measured UGV velocity. The estimated position and velocity are shown in Figure 3(a).
We recall that the SMT-based detector is also able to return the indicator variable vector b, denoting which sensors are under
attack. Figure 3(b) shows both the attack and the corresponding indicator variables as returned by the SMT-based detector.
The proposed algorithm is able to estimate the state and the support of the attack also in the presence of noise.

VI. CONCLUSIONS

We proposed a sound and complete algorithm which adopts the Satisﬁability-Modulo-Theories paradigm to tackle the intrinsic
combinatorial complexity of the secure state estimation problem for linear dynamical systems under sensor attacks. At the heart
of our detector lie a set of routines that exploit the geometric structure of the problem to efﬁciently reason about inconsistency
of sensor measurements and enhance the runtime performance. Our approach was validated via numerical simulations, and
demonstrated on an unmanned ground vehicle control problem. Future directions include the extension and the characterization
of the proposed algorithm for nonlinear and hybrid dynamical systems.

[1] R. Langner, “Stuxnet: Dissecting a cyberwarfare weapon,” IEEE Security and Privacy Magazine, vol. 9, no. 3, pp. 49–51, 2011.

REFERENCES

16

(a) Estimated position and velocity versus ground truth.

(b) Attack signal on the left and right encoders.

(c) Indicator variables b computed by the proposed SMT-based detector.

Fig. 3. Performance of the UGV controller in the case when no attack takes place versus the case when the attack signal is applied to the UGV encoders.
The objective is to move 5 m, stop and perform a 90o rotation, and repeat this pattern to follow a square path. The controller uses the proposed SMT-based
approach to estimate the UGV states. In both cases we show the linear position and linear velocity (top), and the attack signal and its estimate (bottom).

[2] Y. Liu, P. Ning, and M. K. Reiter, “False data injection attacks against state estimation in electric power grids,” in Proceedings of the 16th ACM

conference on Computer and communications security, ser. CCS ’09. New York, NY, USA: ACM, 2009, pp. 21–32.

[3] Y. Shoukry, P. D. Martin, P. Tabuada, and M. B. Srivastava, “Non-invasive spooﬁng attacks for anti-lock braking systems,” in Workshop on Cryptographic
International Association for Cryptologic Research,

Hardware and Embedded Systems, ser. G. Bertoni and J.-S. Coron (Eds.): CHES 2013, LNCS 8086.
2013, pp. 55–72.

[4] C.-Z. Bai and V. Gupta, “On kalman ﬁltering in the presence of a compromised sensor: Fundamental performance bounds,” in American Control

Conference (ACC), 2014, June 2014, pp. 3029–3034.

[5] Y. Mo and B. Sinopoli, “Secure control against replay attacks,” in 47th Annual Allerton Conference on Communication, Control, and Computing

(Allerton), Sept 2009, pp. 911–918.

[6] H. Fawzi, P. Tabuada, and S. Diggavi, “Secure estimation and control for cyber-physical systems under adversarial attacks,” IEEE Transactions on

Automatic Control, vol. 59, no. 6, pp. 1454–1467, June 2014.

[7] F. Pasqualetti, F. Dorﬂer, and F. Bullo, “Attack detection and identiﬁcation in cyber-physical systems,” IEEE Transactions on Automatic Control, vol. 58,

no. 11, pp. 2715–2729, Nov 2013.

[8] M. S. Chong, M. Wakaiki, and J. P. Hespanha, “Observability of linear systems under adversarial attacks,” in The 2015 IEEE American Control conference

(ACC), 2015, accepted.

[9] M. Pajic, J. Weimer, N. Bezzo, P. Tabuada, O. Sokolsky, I. Lee, and G. Pappas, “Robustness of attack-resilient state estimators,” in ACM/IEEE International

Conference on Cyber-Physical Systems (ICCPS), April 2014, pp. 163–174.

[10] Y. Shoukry and P. Tabuada, “Event-triggered projected luenberger observer for linear systems under sensor attacks,” in IEEE 53rd Annual Conference

on Decision and Control (CDC), Dec. 2014.

[11] Y. Shoukry and P. Tabuada, “Event-Triggered State Observers for Sparse Sensor Noise/Attacks,” ArXiv e-prints, Sept. 2013. [Online]. Available:

http://arxiv.org/abs/1309.3511

[12] A. Tiwari, B. Dutertre, D. Jovanovi´c, T. de Candia, P. D. Lincoln, J. Rushby, D. Sadigh, and S. Seshia, “Safety envelope for security,” in Proceedings
of the 3rd International Conference on High Conﬁdence Networked Systems, ser. HiCoNS ’14. New York, NY, USA: ACM, 2014, pp. 85–94.
[13] J. Mattingley and S. Boyd, “Real-time convex optimization in signal processing,” IEEE Signal Processing Magazine, vol. 27, no. 3, pp. 50–61, May

2010.

[14] S. Farahmand, G. B. Giannakis, and D. Angelosante, “Doubly robust smoothing of dynamical processes via outlier sparsity constraints,” Trans. Sig.

Proc., vol. 59, no. 10, pp. 4529–4543, Oct. 2011.

[15] C. Barrett, R. Sebastiani, S. A. Seshia, and C. Tinelli, Satisﬁability Modulo Theories, Chapter in Handbook of Satisﬁability.
[16] P. Nuzzo, A. Puggelli, S. A. Seshia, and A. Sangiovanni-Vincentelli, “CalCS: SMT solving for non-linear convex constraints,” in Formal Methods in

IOS Press, 2009.

Computer-Aided Design (FMCAD), 2010, Oct 2010, pp. 71–79.

[17] C. W. Brown and J. H. Davenport, “The complexity of quantiﬁer elimination and cylindrical algebraic decomposition,” in Proceedings of the 2007

International Symposium on Symbolic and Algebraic Computation, ser. ISSAC ’07. New York, NY, USA: ACM, 2007, pp. 54–60.

[18] G. E. Collins, “Quantiﬁer elimination for real closed ﬁelds by cylindrical algebraic decomposition: A synopsis,” SIGSAM Bull., vol. 10, no. 1, pp. 10–12,

Feb. 1976.

[19] S. Gao, J. Avigad, and E. M. Clarke, “δ-complete decision procedures for satisﬁability over the reals,” in Proceedings of the 6th International Joint

Conference on Automated Reasoning, ser. IJCAR’12. Berlin, Heidelberg: Springer-Verlag, 2012, pp. 286–300.

[20] H. Fawzi, P. Tabuada, and S. Diggavi, “Secure state-estimation for dynamical systems under active adversaries,” in 49th Annual Allerton Conference on

Communication, Control, and Computing (Allerton), sept. 2011, pp. 337–344.

[21] S. Sundaram and C. Hadjicostis, “Distributed function calculation via linear iterative strategies in the presence of malicious agents,” IEEE Transactions

on Automatic Control, vol. 56, no. 7, pp. 1495–1508, 2011.

[22] W. L. Winston, Operations Research: Applications & Algorithms. Thomson Business Press, 2008.
[23] R. Nieuwenhuis, A. Oliveras, and C. Tinelli, “Solving SAT and SAT Modulo Theories: From an abstract Davis–Putnam–Logemann–Loveland procedure

to DPLL(T),” J. ACM, vol. 53, no. 6, pp. 937–977, Nov. 2006.

[24] D. L. Berre and A. Parrain, “The Sat4j library, release 2.2,” Journal on Satisﬁability, Boolean Modeling and Computation, vol. 7, pp. 59–64, 2010.
[25] “Gurobi Optimizer.” [Online]: http://www.gurobi.com/.

05101520253034051015Time[s]Position[m]SMTEngineGroundtruth05101520253034−0.500.511.52Time[s]Velocity[m/s]SMTEngineGroundtruth051015202530340246Time[s]Attacksignal[m/s]AttackonleftencoderAttackonrightencoder0510152025303400.20.40.60.81Time[s]AttackindicatorAttackindicatorb2Attackindicatorb3[26] M. Grant and S. Boyd, “CVX: Matlab software for disciplined convex programming, version 1.21,” http://cvxr.com/cvx, May 2010.

17

APPENDIX

18

Fact 1: For any two square matrices A and B, both AB and BA have the same eigenvalues.
Fact 2: If I

A is a positive deﬁnite matrix, then all eigenvalues of A are strictly less than 1.

−

Proposition A.1. Given a positive semideﬁnite matrix A and a positive deﬁnite matrix B of the same dimension, the following
holds:

λ

A(A + B)−1
{

}

< 1

Proof: It follows from the positive (semi)deﬁniteness assumptions of A and B that (A + B)−1 is positive deﬁnite matrix

and hence can be written using its square root matrix as:

(A + B)−1 = (A + B)− 1

2 (A + B)− 1
2 .

Now, it follows from Fact 1 that A(A + B)−1 have the same eigenvalues of (A + B)− 1

2 A(A + B)− 1

2 . Now we have,

I

−

(A + B)− 1

2 A(A + B)− 1

2 = (A + B)− 1
(A + B)− 1
−
= (A + B)− 1

2 (A + B)(A + B)− 1
2 A(A + B)− 1
2 B(A + B)− 1

2

2

2

which is still positive deﬁnite. Hence, it follows from Fact 2 that all eigenvalues of (A + B)− 1
than 1 and so are the eigenvalues of A(A + B)−1.

2 A(A + B)− 1

2 are strictly less

