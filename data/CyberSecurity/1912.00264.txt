Towards Efﬁcient Integration of Blockchain for IoT
Security: The Case Study of IoT Remote Access

Chenglong Fu
Temple University
Email: chenglong.fu@temple.edu

Qiang Zeng
University of South Carolina
Email: zeng1@cse.sc.edu

Xiaojiang Du
Temple University
Email: xjdu@temple.edu

9
1
0
2

v
o
N
0
3

]

R
C
.
s
c
[

1
v
4
6
2
0
0
.
2
1
9
1
:
v
i
X
r
a

Abstract—The booming Internet of Things (IoT) market has
drawn tremendous interest from cyber attackers. The centralized
cloud-based IoT service architecture has serious limitations in
terms of security, availability, and scalability, and is subject to
single points of failure (SPOF). Recently, accommodating IoT
services on blockchains has become a trend for better security,
privacy, and reliability. However, blockchain’s shortcomings of
high cost, low throughput and long latency make it unsuitable
for IoT applications. In this paper, we take a retrospection of
existing blockchain-based IoT solutions and propose a frame-
work for efﬁcient blockchain and IoT integration. Following the
framework, we design a novel blockchain-assisted decentralized
IoT remote accessing system, RS-IOT, which has the advantage of
defending IoT devices against zero-day attacks without relying on
any trusted third-party. By introducing incentives and penalties
enforced by smart contracts, our work enables “an economic
approach to cybersecurity,” thwarting the majority of attackers
who aim to achieve monetary gains. Our work presents an
example of how blockchain can be used to ensure the fairness
of service trading in a decentralized environment and punish
misbehaviors objectively. We show the security of RS-IoT via
detailed security analyses. Finally, we demonstrate its scalability,
efﬁciency, and usability through a proof-of-concept implementa-
tion on the Ethereum testnet blockchain.1

I.

INTRODUCTION

The IoT market

is ﬂourishing. According to Gartner’s
report in 2018 [26], there is predicted to have 14.2 billion
connected things in use in 2019 and 25 billion by 2021.
However, security concerns are raised along with the growth
of the IoT market. A series of horrible IoT-related attacks
have been seen during the past years such as the Mirai
botnet attack [9], BrickerBot attack [32], Deutsch Telekom
TR-069 attack [9]. Newly developed fancy pwns and hacks
targeting IoT devices like [30], [56] are emerging every day.
Considering the scale of IoT devices, securing them becomes
a non-trivial
the Mirai botnet attacker
launches the record-breaking DDoS attack by recruiting more
than 600K compromised IoT devices as his bot army, causing
inaccessibility of many high-proﬁle websites such as Twitter,
Reddit, and Netﬂix.

task. For example,

Securing these vulnerable IoT devices is challenging. Not
only because those low-cost IoT devices are lacking of com-
puting resources and I/O peripherals, but also due to the
IoT vendors’ lax on implementing secure softwares. Many

1An earlier version of this paper was submitted to ACM CCS18 on May
9th, 2018. This version contains some minor modiﬁcations based on that
submission.

manufacturers are busy rolling out products with novel fea-
tures while leaving security ﬂaws unpatched for years [23],
[56], [51], [46]. Given IoT devices’ actuality of insecurity,
it is reasonable to have the assumption of access-to-attack,
with which any attacker that has direct access to the IoT
device’s open port is supposed being able to take down the
device. Modern IoT vendors try to address this problem by
anchoring the access entries of their products on endpoint
instances hosted by cloud servers [6]. They migrate critical
services such as authentication, remote administration, and
data collection from vulnerable IoT devices to the more secure
cloud server. Unfortunately, the insecurity of cloud servers
is never a piece of news with prominent examples of high-
proﬁle compromises including Equifax [12], Dropbox, and the
US voter database [52]. Since the Cloud endpoint serves as
the entry and is trusted by a large number of IoT devices, it
may, on the contrary, give adversaries an additional arsenal for
launching large scale attacks [57], [47].

Recent advancements on the blockchain and smart con-
tracts inspire researchers to seek blockchain-based solutions
for its intrinsic advantages on decentralization, faulty tolerance,
and data integrity. However, incorporating blockchain and IoT
is non-trivial due to the blockchain’s characteristics and the
IoT’s requirements. On the one hand, billions of IoT devices
are running 24/7 and produce enormous amounts of data to be
timely stored and processed. On the other hand, blockchain
usually has limited throughput and is costly. Although the
smart contract
the
Proof-of-Work (PoW) consensus mechanism makes it not only
expensive but also slow.

theoretically achieves Turing-complete,

Currently, most research on blockchain-based IoT solutions
are still using the blockchain as a substitution of the cloud
server. Their approaches to solving the aforementioned chal-
lenges can be roughly categorized into three types: 1) They
choose to study speciﬁc services that are latency insensitive
and bring low overhead, for example, IoT authentication and
identity management. 2) They use private or permissioned
blockchains instead of public blockchains to avoid cost and
throughput issues. 3) They turn to edge computing where edge
servers are introduced to mitigate the IoT’s resource constrains
for interacting with the blockchain. These workarounds are
either making a trade-off between the usability and security or
are limited on speciﬁc tasks. A general framework to efﬁciently
integrate blockchain into IoT systems is still an open question.

a) This Work: In this paper, we try to ﬁll this gap by
rethinking the blockchain’s role in the IoT service architecture.
Instead of being the host to accommodate services directly,

 
 
 
 
 
 
blockchain is more suitable to be a service trading platform
where service users and third-party providers can discover each
other, establish commission relationships, and settle service
fees. The service itself is undertaken by independent third-
party providers. The participation of third-party providers
decouples the relationship between IoT devices and vendor
operated cloud servers, which allows IoT devices switch to
any provider for better service security and quality. To realize
it, the following questions need to be answered:

Q1:

Q2:

Q3:

How to motivate the participation of third-party ser-
vice providers?

How to establish a mutual trust between service users
and providers?

How to prevent malicious behaviors like cheating,
attacking, and denial of service?

We propose RS-IOT, a novel blockchain assisted IoT relay
sharing system as a case study of the IoT remote access
service. In the system, we introduce third-party relay servers
to substitute the centralized message broker [28] for enabling
two-way relayed communications between a user’s controller
client device and an IoT device. IoT device owners on this plat-
form can freely commission any relay servers for their devices
instead of using those designated by device vendors. First,
the decentralized nature of the proposed technique resolves
the SPOF and scalability issues. Leveraging the power of the
smart contract [15], we design a transparent, self-governing
relay service trading protocol where monetary incentives are
used to motivate third-party relay providers’ participation and
deter potential malicious behaviors. Furthermore, fair and ob-
jective disputation arbitration and attack handling are achieved
without any trusted authorities by using our proof-of-delivery
scheme which involves off-chain proof generation and on-
chain veriﬁcation. As a result, third-party relay servers get the
incentive to shield their customer IoT devices, which gives
vulnerable IoT devices additional protection against zero-day
attacks.

rethink

b) Contribution: We

of
blockchain for IoT systems after a comprehensive literature
investigation. Based on what, we propose a novel blockchain-
assisted decentralized relay sharing system as a solution to
the IoT remote accessing problem. Our contributions are
summarized as follows:

integration

the

• We propose a practical framework for Blockchain
enabled IoT services and provide the guideline to
resolve its inherent shortcomings of cost, throughput,
and latency.

• We propose the proposed RS-IOT, which to the best
is the ﬁrst decentralized relay

of our knowledge,
architecture designed for IoT remote access.

• We design a smart contract based relay service trading
system where disputes are resolved by using smart
contracts.

• We achieve precautionary defense against future un-
known malware by presenting the misbehavior report-
ing scheme which is inspired by the concept of N-
version programming [18]. Malicious attacking be-
haviors are deterred because once the malware attack

2

fails on any IoT device, the attacker’s deposit will be
conﬁscated to cause direct ﬁnancial loss.

The rest of the paper is organized as follows. We present
the related background knowledge in Section II. In Section III,
we review existing researches in terms of blockchain and IoT
integration and propose our framework for converting cloud-
based IoT services to blockchain-assisted distributed services.
In Section IV, we study the use case of IoT remote access
and give the threat model. The design overview of RS-IoT is
illustrated in V. After that, Section VI and Section VII describe
the details of proof-of-delivery and malicious behavior report-
ing. Security analysis and experiments are presented in Section
VIII and Section IX, respectively. We survey related works in
Section X and have discussions of some implementation issues
in Section XI. Finally, we conclude the paper in Section XII.

II. BACKGROUND

A. N-version Programming

N-version programming (NVP) [18] is a method used in
software engineering in which multiple versions of software
are created from the same copy of initial speciﬁcations. These
equivalent copies of softwares are developed independently in
different approaches. It is proved that NVP can greatly reduce
the inﬂuence from identical software faults. The concept has
already been used as an effective defense method against
software ﬂaws [21]. For our proposed relay sharing system, the
variety of IoT devices’ software implementation makes it im-
possible for attackers to launch universally applicable attacks
and imposes risks when they make unsuccessful attempts.

B. Non-Repudiable TLS

TLS-N [44] is an extension of the current TLS protocol. It
adds non-repudiation features. Traditional TLS/SSL protocol
only veriﬁes the identity of the other end at the beginning
of the session and assumes the consistency of identity after
the encrypted session is established. Although it is effective
to defeat
the man-in-the-middle attack and impersonation
attack, it does not support communication forensics with non-
deniable proofs of packets sending. Unlike the normal TLS
protocol which only uses HMAC in application data packets
for message integrity checking, TLS-N enables signatures on
each packet transmitted between the communicating peers.
By adding a veriﬁable signature created with the private key,
the sender cannot deny sending certain content. The TLS-
N protocol
timely ﬁlls the gap between the imperfection
of traditional TLS and the requirements of objective and
veriﬁable message publication for smart contracts’ execution.
It is built on the base of normal TLS protocol and proved to
be able to generate proofs that are not only non-repudiable but
also privacy-preserving. As tested by the author, TLS-N only
incurs less than 1.5 milliseconds increase of time overhead
for each HTTP request compared to the original version of
TLS protocol and costs no more than 3 USD for verifying
proofs on the public Ethereum blockchain. In our work, TLS-
N signatures of malicious packets are used by our reporting
system as the evidence of relay servers’ misbehaviors.

C. Smart Contract

Smart contract [15] consists of pieces of script code on
blockchain to deal with digital assets. It is executed by all
miner nodes in the isolated virtual environment. The ac-
cepted execution results are recorded on the decentralized
ledger through consensus mechanisms which ensures it to be
trustworthy and tampering-resistant. Smart contracts provide
two types of accounts:
is owned by
the participating node and protected by the private key; the
contract account points to the instance of smart contract code
without private keys. Both types of accounts have the account
addresses and are able to hold digital assets.

the personal account

III. BLOCKCHAIN AND IOT INTEGRATION

Cloud platforms have been proved to help enhance resource
constraint IoT devices against security threats [45], [40], [49].
However, the risk of single point of failure and the problem of
scalability bottleneck entice IoT vendors to shift their services
from the centralized architecture to the decentralized form.
The blockchain’s intrinsic natures of decentralization, tamper-
resistance, and autonomy make it a promising candidate to be
used in the IoT paradigm. Furthermore, the emergence of smart
contracts provides a practical way for Turning-complete trusted
global computer, which inspires the proposal of autonomous
IoT system [14].

However,

these wonderful

security beneﬁts of

the
blockchain are not to be taken for granted. The ‘world com-
puter’ is achieved by using numerous blockchain nodes as
redundant backups. This brings high cost and latency for oper-
ations on public blockchains. Moreover, despite blockchain’s
good scalability of accommodating unlimited participating
nodes, the whole network throughput of transaction processing
is limited. For instance, Bitcoin has a constant throughput of
10 minutes per block, which is equivalent to 7 transactions
per second and Ethereum allows 15 seconds per block. Another
issue is cost. All operations that modify the public blockchain’s
state are subject to transaction fees. Even simple operations
like storing or changing a byte in the blockchain can be
expensive, let alone complicated tasks such as data processing.
Considering the IoT’s requirement of large scale and low cost,
the use of blockchain becomes unpractical.

To ﬁnd a general and viable solution, we ﬁrst review
the existing research works of blockchain-based IoT security
mechanisms and analyze their strengths and weaknesses on
addressing the two mentioned constraints. Based on the retro-
spection, we propose our efﬁcient integration framework.

A. Retrospection of Existing Works

Since the proposal of smart contracts in 2014, there have
been many research works regarding the paradigm of IoT and
blockchain integration. We choose three well-presented survey
papers [39], [19], [20] as indices to collect notable works
related to this topic for further analyses and discussions. In
contrast to these survey papers, we focus on categorizing and
evaluating the technical methods used by these papers to solve
the aforementioned problems. Speciﬁcally, we evaluate them
in terms of 6 criteria:

•

Use Case: The target application or service the work
aims to provide for IoT.

3

•

•

•

•

•

Service Architecture: Participating entities and their
roles in service.

Service Requirements: The requirements on through-
put, latency and cost.

Scalability: The scale of deployment.

Blockchain Specs: The type of blockchain and con-
sensus algorithm they use.

Attack Resilience: Whether their system can exclude
the malicious nodes and recover from a system failure.

Based on these criteria, we categorize the collected papers

into the following two types:

a) Blockchain as a Ledger: In this type, the blockchain
is used as an immutable ledger or a distributed database to
store critical information. This is the most straightforward way
for the integration of IoT and blockchain and is adopted by
many early works. [55] proposes to use the blockchain to
store and deliver out-of-band authentication credentials. Since
authentication only occurs when devices request sensitive
information from the cloud server, it has low requirements
for throughput and latency. The authors indicate that they
use the Eris blockchain, but they do not specify any details
about the implementation, nor a solution to reduce the involved
transaction fees. [22] designs a multi-layer architecture for
blockchain powered smart home access control. It employs a
centralized device to process all transactions and generate new
blocks to get rid of the overhead brought by the Proof-of-Work.
However, this design contradicts the core concept of decentral-
ization of blockchain and undermines the security. Some other
works straightforwardly leverage the blockchain’s immutable
feature to facilitate distributed data storage and sharing as
discussed in [58] and [54]. They use public blockchain to
store either raw data or the hash of data. These works avoid
the cost and throughput constraints by either choosing speciﬁc
services that have low requirements for transaction frequency
and latency or using a single centralized miner.

b) Blockchain as a Service: Inspired by the concept
of decentralized applications [43], some works regard the
smart contract as a trusted computing platform and build more
applications on it. The ﬁrst category is decentralized PKIs
based on the smart contract. [17] introduces an additional party
named ‘bookkeeper’ to form the backbone of a permissioned
blockchain and store the certiﬁcate revocation list. But it does
not specify the origin and the incentive of ‘bookkeepers’,
which implies a limited number of available bookkeepers.
Certcoin [25] chooses to build a decentralized trust system
based on Namecoin, a public blockchain for DNS services.
Although the author ﬁnds a solution to mitigate end users’
storage burdens, all certiﬁcates and public keys are still held on
the blockchain. Access control and authorization is another hot
topic for blockchain and IoT integration. ‘WAVE’ [7] proposes
a city-wide blockchain to store the metadata of permissions for
supporting a variety of access control patterns. The authors
craft a set of smart contracts to automatically handle compli-
cated out-of-order access permission delegations. A bunch of
other IoT authorization solutions [37], [5], [50] basically use
the similar architecture that employs smart contracts to auto-
matically enforce access control policies. They try to address
the cost and throughput issues either by using permissioned

multi-party computing and does not offer more details of how
to realize it in the IoT domain.

We follow this insight and dive into more details of
blockchain-assisted distributed IoT services to ﬁnd the answer
to the three questions as proposed in the Section I. Many
blockchains provide the functionality of cryptocurrencies. So,
the blockchain can be used as a service trading platform
where service users (usually IoT devices) use services provided
by third-party service providers who join for service fees
paid by cryptocurrencies. To avoid possible disputations, the
blockchain can also serve as the intermediary between two
parties that collects pre-paid service fee payments from service
users and compensates providers when objective proofs are
provided. The blockchain can also punish malicious service
providers by forfeiting their deposits of cryptocurrency to deter
possible attacking attempts.

IV. CASE STUDY OF EFFICIENT BLOCKCHAIN AND IOT
INTEGRATION: IOT REMOTE ACCESS

Smart home IoT systems enable homeowners to manage
their IoT sensors and appliances from both inside and outside
their homes. However, accessing IoT outside the home’s pri-
vate network is challenging due to the isolation of Network
Address Translation (NAT) and the ﬁrewall. As a result, IoT
remote access requires a relay server with a public accessible
IP address for bridged communication. In this section, we
study the use case of IoT remote accessing to demonstrate
the proposed framework.

A. State-of-art Solutions

a) Port forwarding: Direct access through the IP ad-
dresses may be obstructed by the NAT and ﬁrewalls. They
either shield IoT devices in private networks or ﬁlter out
inbound connections. The intuitive workaround is exposing the
device’s port on the public address by setting the port forward
on the gateway device. However, as pointed out in [48], the
NAT has side-effects of isolating IoT devices and protecting
them from attacking trafﬁcs on the Internet. Some consumer
IoT devices such as Belkin’s WeMo smart plug and Philips
Hue smart light accept unauthenticated commands from the
local network and require no credentials to simplify users’
conﬁguration. However, exposing IoT devices them could be
dangerous because any host on the Internet gets the possibility
to compromise them. For example, a surprising higher number
of IoT devices are infected by the Mirai botnet malware
because they are exposed to the public Internet with the UPnP
IGD protocol [33].

b) Cloud-based Endpoint: Even shielded by the gate-
way, vulnerable IoT devices behind the home private network
are still threatened by other compromised devices through the
LAN connection as described in [48]. Modern IoT vendors
try to address this problem with a more radical isolation that
anchors the access entry of their products on the endpoint
instances hosted by cloud servers as shown in Figure 2.
With the embedded public key, IoT devices can initiate a
secure session towards the endpoint right after it boots up
and maintain the session with heartbeat packets. This method
enables indirect access through the relay server [4]. Since
the session is proactively launched by the IoT device located

Fig. 1. Abstract architectures of IoT services. Solid lines represent direct
Internet communications and dash-dotted lines represent interactions with the
blockchain.

blockchains [17], [50], [5], or delicately designing the contract
code to minimize the frequency of modifying the global state
of blockchain [37], [7].

In summary, the aforementioned works basically follow
two approaches. First, they choose speciﬁc services that require
a low frequency of issuing transactions to avoid intensive on-
chain operations which are subject to fees and latencies. Read-
ing the blockchain data would not cause a state change and has
no cost or minimal overhead. Therefore, the blockchain can
host data sharing, PKI services, and access controls, which
have asymmetric requirements of reading and writing. This
also explains why a considerable portion of blockchain-IoT
papers in the survey [39] focus on these topics.

or

using

private

Another

permission
is
approach
blockchains instead of
the public blockchain, where the
burden of computing-intensive proof-of-work is relieved or
avoided. However, it also undermines the security with a much
smaller network scale. Some new blockchain techniques such
as hyperledger [8] and IoTa [42] achieve better performance
by making trade-offs either on decentralization or on security.

B. Rethinking Blockchain and IoT Integration

To explore a feasible way to integrate IoT and blockchain,
we ﬁrst make an abstract model of IoT services as depicted
in Figure 1. In a conventional IoT services scenario, with
client devices (e.g., smartphone), users can either access their
IoT devices directly (case (a)) or through the cloud server
for advanced functionalities like cloud storage and automation
(case (b)). The blockchain, as mentioned earlier enables IoT
services to replace the cloud server with the blockchain (case
(c)). One promising architecture is proposed in [59] as shown
in (case (d)) that combines the ordinary distributed system
with blockchain by moving heavy-load services from the
blockchain to third-party servers. The blockchain serves as
the coordinator to enforce correctness and fairness. However,
this paper mainly focuses on the theoretical model of secure

4

UserIoTUserIoTUserIoTUserIoTBlockchainThird-party ServersBlockchainCloud(a)(b)(c)(d)These capabilities are reasonable considering the endless
discoveries of new vulnerabilities on vendor customized ap-
plications. Also, we make some reasonable assumptions about
the restriction of attackers’ capabilities:

1)

2)

Attackers cannot take down an unknown device with-
out making multiple attempts.
Attackers cannot crack standard cryptographic prim-
itives such as the digital signature.

These assumptions are practical because of the principle
of multi-version programming. IoT applications made by dif-
ferent vendors may have different vulnerabilities, but there is
no universally applicable vulnerability considering the variety
of IoT software. Besides, since the hardware, the operating
system, and public middleware libraries such as TLS-N are
widely shared by different device vendors and are well tested in
contrast to individually developed application layer programs,
it is much more difﬁcult to ﬁnd vulnerabilities to exploit among
them. So, we think those extremely strong attacking vectors
targeting IoT hardware and fundamental software components
are out of our scope.

V. DESIGN OF RS-IOT

In this section, we present our design of the blockchain
based relay-sharing IoT remote access system (RS-IoT), which
utilizes the framework we propose in Section III. Since a relay
server is necessary for accessing IoT devices behind the NAT,
a feasible solution is to decouple the ﬁxed relationship between
relay server and the IoT devices by replacing the centralized
cloud server with a large number of third-party relay servers.
Accordingly, a smart contract based service trading platform is
designed for transaction management and dispute arbitration,
with which IoT devices are able to freely choose their relay
service providers.

Our design brings four prominent beneﬁts: 1) The manage-
ment platform is completely self-governing to guarantee the
fairness of the service trading without the help of any trusted
authority. 2) Compromised or misbehaving relay servers will
be reported and excluded from the relay platform to avoid
further damage. 3) Malicious relay servers that launches at-
tacks against its connected IoT devices have the risk to be
reported and punished 4) No assumption of robust and secure
IoT applications are required.

A. Relay Sharing Model

Taking the smart contract into account, there are four roles
involved in RS-IoT as shown in Figure 3: the IoT device
(D), the controller (C), the relay server (R), and the smart
contract (SC). Among them, the controller and the IoT device
are grouped as the party of the service user and share secret
keys since they are usually owned by the same owner and have
the common interest. The relay server constitutes the party of
service provider. The smart contract is script code stored on
the public blockchain as a fair third-party.

All roles except the smart contract join the blockchain
by generating their own public and private keys, and the
smart contact is published on the blockchain with only the
account address. We denote their addresses on as addr(D),
addr(C), and addr(R) respectively. After that, the IoT device,

Fig. 2. Relay-assisted IoT accessing model. For the scenario of both two
parties are behind the NAT, a relay server with a publicly accessible IP address
is necessary for bidirectional communications.

behind the NAT, access requests encapsulated in the response
packets can freely pass through the NAT and ﬁrewall, which
is dubbed as ”piggybacking.” A typical real-world example
is the message broker service [2] provided by Amazon Web
Service’s IoT core module. It maintains a long-term session
with the subscribed IoT devices where messaging protocols
such as MQTT are carried with it for real-time device control.

Counterintuitively, the centralized cloud could provide at-
tackers, especially botnet attackers, better approaches to deliver
IoT attacks. As the cloud server usually groups entries for
similar devices from the same vendor, once it gets compro-
mised [13], the attacker suddenly acquires free access to a large
amount of IoT devices which share similar vulnerabilities. This
saves attackers the effort for randomly scanning on the Internet,
which is time-consuming. Even the cloud server is not taken
down, security ﬂaws of application program interfaces (APIs)
as summarized in [6] can also facilitate attacks like username
enumeration, password brute-forcing, and unauthorized privi-
lege escalation. These insecure cloud APIs prompt the cloud-
based IoT botnet attacks [30], [31]. Aside from security issues,
the scalability problem is another concern. Maintaining en-
crypted sessions involves the device identity management, the
credential update and constant communication, which induce
heavy pressure on the centralized cloud server. Considering the
scale of IoT devices, centralized cloud servers can potentially
become the performance bottleneck whose malfunction may
result in a large-scale blackout of IoT devices.

B. Threat Model

According to the background knowledge and the afore-
mentioned challenges, we present our threat model here.
Following the access-to-attack assumption, we assume very
strong attackers who have capabilities to:

1)

2)

3)

Take down any IoT devices as long as they can
get access to them by exploiting application layer
software vulnerabilities.
Take down arbitrary relay servers with non-negligible
time.
Install malwares on compromised IoT devices for
botnet attacks.

5

IoTDevicesCentralized Cloud ServerNATNATNATControllerDevicesAttackerrespond with their IP addresses and quotes of service via
direct transactions towards the requesting IoT’s blockchain
address. After waiting for some time, the IoT device evaluates
the received quotes by the deposit and price, and ﬁnally
makes a decision by calling the service select function with
the chosen relay server’s blockchain address and price as
arguments. Similar to the user registration, this function call
would generate an item into the table serviceList consisting the
following values as shown in Table I and set the conﬁrmation
ﬂag to pending.

TABLE I.

KEYS OF CONTENT IN THE SERVICELIST.

T xn
Serial
Address
P rice
Balance

index number for each pair of IoT device and relay server
counter to index the number of successfully relayed packets
blockchain address of all involved parties
cost of forwarding one packet
amount of pre-paid service fee payment

Finally, the chosen relay server conﬁrms the service rela-
tionship by calling the service conﬁrm function to change
the conﬁrmation ﬂag in table serviceList
to conﬁrmed. At
the same time, an event broadcast would be triggered as a
log of relationship binding. Then, the commission is ﬁnished.
The IoT device launches a TLS-N connection towards the
commissioned relay server.

The function prototype for commission is listed below

function service_request(address D, address C)

public {...}

function service_select(address D, address C,

address R, uint price) public payable{...}

function service_confirm(uint Txn){...}

3) Relay: As all history transactions on blockchain are
the controller client can easily recover
publicly readable,
the current serving relay server’s IP address and initiate a
TLS-N connection towards it. With the shared secret key
between the IoT device and the controller client, a long-term
symmetric encryption key K(C, D) can be derived to encrypt
the messages exchanged between them. The controller client
ﬁrst generates a proof of signed transaction on the original
packet which is sent to the relay server along with the packet
itself. On receiving the packet, the relay server uses a random
stream derived from a one-time key P N to cover the packet
before forwarding it to the IoT device. Afterwards, the receiver
(IoT device) generates another proof transaction using the
same algorithm but on the covered packet and sends it back
to the relay server. Finally, the relay server creates a new
transaction containing the cover key and broadcasts it along
with two received proof transactions. With the cover key, a
successful proof veriﬁcation on the smart contract will trigger
a transfer of cryptocurrency from the contract account to the
relay server’s personal account. We will illustrate details of the
proof generation algorithm and show its effect on preventing
cheating in Section VI and Section VIII, respectively.

4) Decommission: As we stated, both the relay server
and the IoT device can freely determine when to end the
service relationship. The decommission process is provided to
terminate a service relationship by either party by calling the
function decommission. T xn is the only argument required to
specify the service record to be cleared. After a decommission
is initiated, an event would be emitted as the notiﬁcation and

Fig. 3. Overview of relay-sharing IoT remote accessing. Nodes connected by
the same type of line are within the same session of a relay service. A relay
server can host multiple control sessions and a controller device can control
multiple IoT devices through different relay servers.

the controller and the relay server top up their account with
cryptocurrency as deposit or service fee. The basic unit of
relay service is the end-to-end link between an IoT device
and its controller client with one commissioned relay server in
between. Both the IoT device and the controller are connected
to the relay server via TLS-N sessions and all packets passed
through them are signed with the sender’s blockchain private
key.

B. Relay Workﬂow

This subsection describes the workﬂow of relay sharing by
going over the procedure of forwarding a packet. As described
in Figure 4, the workﬂow consists of the registration phase, the
commission phase, and the relay phase.

1) Registration: With blockchain accounts established, all
three parties register their account addresses on the smart
contract to indicate their participation by calling a registration
function of the smart contract SC and creating new items
in two tables in blockchain: userInfo and serverInfo. Since a
service user is uniquely identiﬁed by its pair of IoT device ID
and controller ID, both of them need to register by providing
the other party’s address as arguments. After either one of
them calls the registration function, a new item in userInfo
is created with the conﬁrmation ﬂag set to false. Then, the
function call by the other party would ﬂip the conﬁrmation ﬂag
to indicate a successful user registration. For the relay server,
the deposit of cryptocurrency is required to be paid to the smart
contract along with the registration function call transaction.
The amount of deposit is stored in serverInfo together with
the relay server’s blockchain address.

The function prototype for registration is listed below

function reg_user(address oppo_end) public {...}
function reg_server() public payable{...}

2) Commission: The commission phase is used for mutual
discovery between service users and providers, as well as
setting up service relationships. The commission phase begins
with an IoT device calling the service request function which
broadcasts a global event containing the user’s registration
information. Upon receiving the event, interested relay servers

6

NATSmart ContractIoTDevicesRelay ServersControllerDevicesNATNATFig. 4. Workﬂow of RS-IoT. Solid lines are function call transactions toward the smart contract and blockchain direct transactions. Dash lines are direct
communications through the TLS-N session.

the service record item in serviceList is deleted after a pre-
deﬁned block time for the relay server to ﬁnish billing. The
remaining pre-paid service fee will be paid back to the IoT
device’s personal account.

C. Relay Service Client

Fig. 5.
Packets handling procedures of IoT devices. The operating system
can ﬁler out trafﬁc that does not originate from the commissioned relay server
and the TLS-N library blocks packets without valid signatrues.

Relay Service Client

is a middleware installed in IoT
devices to deal with all relay sharing related logics. Besides
interacting with the smart contract for the aforementioned
workﬂow, this middleware is also responsible for setting the

7

packet ﬁlter policy for the operating system kernel and con-
ﬁguring the TLS-N module with a private key. As shown in
Figure 5, for any incoming packets, the netﬁlter of the operat-
ing system ﬁrst ﬁlters out those connection requests initiated
by external hosts. Then, the netﬁlter dispatches packets that
originate from the commissioned relay server to the TLS-N
library which checks their signature. Only packets with valid
signatures can be accepted and passed to the relay service
client. Here, the client inspects received packets and report
those suspicious ones to the smart contract. Different device
vendors have different implementations of the relay service
client and inspection method.

D. Billing of Relay Service

During the commission precedure, the pre-paid service fee
is transferred to the smart contract’s account along with the
function call of service conﬁrm. As described in Section V-B3,
a relay server gets remuneration by presenting the proof of
each successfully relayed packet. However, considering the
amount of relayed packets and blockchain’s aforementioned
cost and throughput constraints, verifying each of them on the
smart contract is unrealistic. We innovatively use the smart
contract’s local veriﬁability to make it unnecessary to verify
each packet on the blockchain. That is, on receiving proof
transactions, the relay server ﬁrst runs the veriﬁcation function
locally instead of posting them on the blockchain. If the
veriﬁcation is successful, the relay server caches the proofs and
for the current packet, and send the cover key to the IoT device.
If both two parties are honest, the IoT device would be able to
successfully recover the message with the received cover key.
As long as no dispute occurs, this ofﬂine veriﬁcation can be
used for all following packets. When the relay server wants
to cash the remuneration, it only needs to verify the proof
of the last packet on the blockchain. The difference between
the recorded serial number serial in the table serviceList and

RegistrationIoT Device (D)Contract (SC)Relay Server (R)Controller (C)CommissionRelayInitial?YesNoPacketsAbandonOrigin?OtherRelay ServerInvalidAbandonRelay ServiceClientReportSmart ContractMQTTSOAPCGIRTSP... ...OS KernelTLS-NRelay Service ClientSuspiciousOtherApplicationsSignatureVerificationValidserial in the proof is accounted as the number of successfully
relayed packets. The total amount of remunerations is then
calculated as the product of the number of successfully relayed
packets and the unit service price. After the transfer, the serial
in serviceList is updated. Because the serial as a function call
argument is signed by the IoT device, it can be regarded as
the IoT’s acknowledgment of successful relay for all packets
before it.

VI. PROOF-OF-DELIVERY

In a real-world service trading system, both the service
user and the service provider have the incentive to cheat: the
relay server may deliver broken, modiﬁed, or forged packets
for making extra proﬁt; While, the relay user (including the
controller and the IoT device) may deny the receipt of packets
to avoid the payment.

To solve this problem, we propose an autonomous proof-
of-delivery solution to resolve possible disputes fairly by uti-
lizing the smart contract as a decentralized trusted computing
platform. Firstly, We design a SHA-3 [24] based key stream
generator for the relay server to hide the content of the
original packet. Then, leveraging the smart contract’s locally
veriﬁable feature, we propose an innovative off-line blind proof
generation algorithm to derive proofs of packet delivery on
both the original and the covered packet. During the operation,
the relay server holds the cover key while it asks the IoT device
for the proof of the covered packet. On one hand, without
receiving the correct proof, the relay server would not reveal
the cover key for the receiver to extract the message. On the
other hand, the relay server is not able to get the correct proof
for cashing reward if the packet is not delivered conﬁdentially.
This solution provides a mutual restriction between the user
and the server so that neither of them have the opportunity to
cheat. Thanks to the smart contract’s off-chain veriﬁability, the
proof only needs to be posted on the blockchain when disputes
occur rather than every time a packet is relayed, which greatly
reduces the cost of operation. For clarity, we list all symbols
to be used in the following notation table:

TABLE II.

NOTATIONS

K(C,D)
S(C,D)
Ra & Ra(cid:48)
P N
B
B(cid:48)
T x(B)
N
i

pre-shared encryption key between C and D
pre-shared secret for bits selector
byte select index list
secret key for cover stream generator
selected bytes for uncovered packet
selected bytes for covered packet
contract function call with B as argument
commitment length
self-incrementing counter

A. Components

Considering the high cost of storing and processing data on
the blockchain, it is not practical to verify the entire packet on
smart contract because of the unbearable latency and cost. Al-
though existing cryptography primitives have already provided
satisfying digest-based security features, hardly any of them
are available as built-in functions on popular public blockchain
platforms such as the Ethereum [53]. If we implement them
in the form of script code, the cost will become unbearable.
To overcome these difﬁculties, we design the Bytes Selector
and the Cover Stream Generator as new primitives based

8

The workﬂow of proof-of-delivery. Dotted lines mean signed
Fig. 6.
transactions are sent to the relay server. After the veriﬁcation, the relay server
publishes them on the smart contract to get its service fee.

on Ethereum’s built-in functions. The Bytes Selector is used
to extract ﬁxed-length bytes streams from arbitrary packets,
while the Cover Stream Generator is used to generate cover
streams to hide the content of a packet. These new components
provide comparable security while remains low cost.

1) Cover Stream Generator: To prevent the lost of service
fee when service users maliciously deny the receiving of
relayed packets, the relay server covers the content of packets
to be delivered to the receiver with a stream cipher. The relay
server will only reveal the cover key when it gets valid com-
mitments from the receiver as the proof of successful delivery.
The cover stream generator is an alternative implementation
of the stream ciphers on the smart contract. Since there is no
pre-compiled script function in the current version of Ethereum
blockchain, implementing a standard stream cipher would be
extremely expensive. Under this case, we build the cover
stream generator based on the SHA-3 hash function, which
is the cheapest built-in operation on Ethereum [53].

The cover stream is generated by concatenating hashes of
the sums of a secret key P N and a self-increasing counter
i. To keep high entropy of randomness, we only retain the
highest indexed byte of each 256-bit SHA-3 hash result. The
cover stream is generated as shown in the equation below. The
‘|’ means the concatenation of hash values.

cover(P N ) = SHA3(P N )|SHA3(P N + 1)| · · ·

(1)

Aside from using the low-cost building block, this hash
chain based stream cipher also reduces cost by enabling
selective encryption stream generation at arbitrary position. For
example, to encrypt/decrypt the content at the Kth byte with a

EncryptionBytes SelectorSIGNBytes SelectorSHA-3RNGSIGNSIGNSmart ContractControllerRelay ServerIoT DeviceCoverStreamRNGSHA-3CoverStreamgiven key P N , we can simply calculate SHA3(P N + K − 1)
and take the ﬁrst bytes as the key stream instead of producing
the key stream from the beginning. Thus, the overhead from
generating and storing the whole stream for large packets is
avoided.

2) Bytes Selector: As an analogy, the bytes selector serves
the similar purpose as the Hash Message Authentication Code
(HMAC) function. The difference is that our bytes selector
retains the commutativity along with our cover scheme (i.e.,
the digest of the covered packet equals to the covered digest
giving same secure keys).

The bytes selector is driven by the secret S(C, D) shared
between the controller client C and the IoT device D. Both
C and D use this secret as the seed of a pseudo random
number generator. For each packet, C and D synchronously
generate N random numbers of 16-bits, denoted as Ra =
{ra1, ra2, ra3, · · · , raN }. Assuming the length of the packet
is L, the bytes selection list Ra(cid:48) = {ra(cid:48)
N }
is derived from Ra with ra(cid:48)
i = rai mod L. Thereafter, a
list of N bytes B = {b1, b2, b3, · · · , bN } are extracted from
targeting packet where bi is the ra(cid:48)
ith byte in the packet. The
generated bytes list is totally random and there is no way to
recover their locations in the packet without the knowledge of
the random seed S(C, D).

3, · · · , ra(cid:48)

1, ra(cid:48)

2, ra(cid:48)

B. Proof-of-Delivery Workﬂow

The proof-of-delivery comprises four steps: 1) The sender
(assuming it is the controller because control session is usually
initiated by it) generate the ﬁrst commitment with our bytes
selector on the original packet to be sent to the relay server.
2) The relay server covers the packet and forwards it to the
receiver (IoT device). 3) The receiver generate the second
commitment on the covered packet using the same methond
and sends it back to the relay server. 4) The relay server
verify two received commitments with the cover stream key
and reveal the key to the receiver if commitments are valid.

1) Bytes Commitment by the Controller Client: We assume
the controller C wants to send a packet msg to the device D
through the relay server R. C ﬁrstly encrypts the message
with the pre-shared symmetric key K(C,D) and generates the
encrypted packet EnK(C,D)[msg]. Then, it rolls the random
number generator with the pre-shared secret S(C, D) to get the
Ra(cid:48) as indices of bytes to be selected. After that, it extracts
the bytes from EnK(C,D)[msg] as indexed by Ra(cid:48) to form the
commitment B and use it as the argument of the transaction
towards the function of commitment. Finally, the transaction
T x(B)C is signed by the controller client’s private key and
sent to the relay server R.

2) Bits Covering by the Relay Server: On receiving the
encrypted packet EnK(C,D)[msg] and the commitment B
from the controller client C, the relay server R generates a
random number P N as the seed of the cover stream generator
to produce an pseudo random stream. It uses the cover stream
to cover the packet with the exclusive-OR operation. which
is illustrated as in the equation below. After that, the covered
packet is forwarded to the IoT device.

Co(EnK(C,D)[msg]) = EnK(C,D)[msg] ⊕ cover(P N )

9

3) Bits Commitment by the IoT Device: The received
packet from the relay server is covered by the cover stream.
By using the bytes selector, bytes at the same location are
selected on the covered packet which is denoted as B(cid:48). Then,
the IoT device packages B(cid:48) together with the bytes selection
list Ra(cid:48) into a function call transaction T x(B(cid:48), Ra(cid:48))D. The
signed transaction is sent back to the relay server R.

4) Asynchronous Delivery Veriﬁcation: Upon receiving
both commitment transactions T x(B)C and T x(B(cid:48), Ra(cid:48))D,
the relay server now has all the of materials to verify the
correctness of the commitments locally. Then, the relay server
checks whether B ⊕ B(cid:48) equals to cover(P N ) at
the
designated location as speciﬁed by Ra(cid:48). If the veriﬁcation
is successful, the relay server prepares another transaction
T x(P N )R signed by itself with the P N as the argument.
These three commitment transactions are the proof of delivery
which are cached by the relay server. When commitments are
presented to the smart contract SC, the same veriﬁcation is
performed as the relay server. Payment for the relay service
is transferred to the relay server upon successful commitment
veriﬁcations.

To avoid the latency and the transaction fee caused by
executing the smart contract, the relay server caches all com-
mitments instead of verifying them immediately. It delivers the
cover key P N through the relay connection to the IoT device
after the successful veriﬁcation. When it wants to withdraw
the payment, it veriﬁes the commitment of the newest packet.
As described in Section V-D, the veriﬁcation of all previous
commitments is unnecessary.

VII. PENALTY & DISPUTATION SOLVING

Since the relay server serves as the only access entry for
all its customer IoT devices, all trafﬁc delivered to the IoT
device should originate from its legitimate controller clients.
However, relay service providers are anonymous according to
the registration phase, which induces the risk of malicious
relay servers delivering IoT malware. Based on the non-
repudiable features of TLS-N, we develop a smart contract
function for relay service users reporting unauthorized trafﬁc
from their commissioned relay server. After issuing a log event
as notiﬁcation, the reported relay server needs to present the
TLS-N signature of the sender for the reported packet to claim
its innocence. Otherwise, the relay server’s registration will be
revoked, and all its deposit will be conﬁscated.

A. Reporting

[ht] Upon receiving a packet, the IoT device ﬁrstly veriﬁes
the TLS-N signature with the TLS-N library to make sure it
really originates from the relay server. Then, the TLS-N library
passes the packet to the application layer of the IoT devices.
If the packet contains malicious content that is not initiated by
the controller, IoT devices have some chance to recognize it.
According to the theory of multi-version programming (MVP),
a perfect attack that can compromise arbitrary IoT devices does
not exist considering the variety of IoT software types and
architectures. Once a malicious packet fails to take down a
device, the device can use the relay server’s TLS-N signature
to report this misbehavior to the smart contract.

Fig. 7. The workﬂow of reporting suspicious packets. Once the public key
derived from the signature matches the address of the accused relay server, an
record is inserted into the pending list. At the same time, it triggers an event
to notify the relay server.

The reporting process starts from the function call trans-
action towards the reporting function in the smart contract.
As shown in the ﬁgure 7, the function call contains argu-
ments of the transaction number, the suspected packet’s serial
number, the content of the packet and the relay server’s TLS-
N signature. Since the TLS-N signature is signed with the
relay server’s private key, when giving the content of the
original packet, any arbitrary party including the smart contract
can retrieve the relay server’s public key and then derive the
blockchain address ADDR(R). The smart contract will verify
the validation of the signature by generating the address from
it and compare it with the address stored inside the serviceList
which is indexed by the argument of the transaction number.
If the recovered address matches that in the list, it means the
reported packet really comes from the relay server and the
smart contract will take it as a valid report. Then the smart
contract will create a new record in the report pending list
which contains the transaction number, the serial number, the
reported packet, and the current latest block number. At the
same time, a notiﬁcation is emitted and broadcasted on the
blockchain to inform the relay server to process this accusation.

The function prototype for reporting is listed below:
function reporting(uint Txn, uint serial, bytes

packet, bytes32 signature){...}

Fig. 8. The workﬂow of rebuting a pending report record. The relay server
prove itself’s innocence by presenting the sender’s TLS-N signature of the
suspected packet and the cover key so that the smart contract can uncovered
the packet and verify the TLS-N signature.

rebutting function in the smart contract. Among parameters
provided, the transaction and serial number are used to locate
the pending record of rebutting. Since the packet in the pending
list is covered by the relay server with the cover key, the relay
server needs to provide the cover key to recover the original
packet it receives from the controller. Afterward, with the
original packet and the controller’s signature, the controller’s
address ADDR(C) can be derived using the same way as
in the reporting process. If the derived address matches that
stored in the serviceList table, it indicates the reported packet
is really initiated by the controller, and the relay server does
not do anything malicious. If so, the smart contract will delete
the record in the report pending list. Otherwise the rebutting
fails and the record remains inside the pending list.

The function prototype for rebutting is listed below:

function rebutting(uint Txn, uint serial, bytes32

packetHash, uint PN){...}

C. Executing

B. Rebutting

[ht] Even if the pending report record is successfully
generated, it only represents the reported packet is sent by
the relay server and is not enough to determine whether it is
malicious. As a result, we design the rebutting function for the
accused relay server to defend its innocence by proving that
the reported packet is originating from the controller device.

As shown in the Figure 8, it involves a similar process that
starts from sending the function call transaction towards the

Since the reporting notiﬁcation takes some time to broad-
cast on the blockchain, a grace period is provided for the
relay server to respond to the accusation. The grace period
can be measured with the number of newly generated blocks
in the blockchain because the generation of new blocks usually
means the consensus among all participating nodes in the
network and the completion of states update.

If the reporting record remains in the pending list after
the end of the grace period,
the IoT device who initiate
the reporting is eligible to execute the penalty by sending

10

Service ListADDR(D)ADDR(C)ADDR(R)...............TxnSerialPacketSignatureSignature VerificationADDR(R)Equal?YReport Pending ListTxnSerialPacket.........NotificationRelay Server Report MessageIoT DevicesFunction CallSmart ContractTxnSerialCover KeySHA3 HashSignatureADDR(C)Equal?Report Pending ListTxnSerialPacket.........SHA-3Equal?YService List...ADDR(D)ADDR(R)ADDR(C)............RebuttingUncoverRelay ServerSignature VerificationYFunction CallDelete ItemSmart Contractcan efﬁciently access millions of its connected IoT devices.
Differently, in our relay sharing system, attacking relay servers
is much less efﬁcient because each relay server only connects
to a small number of IoT devices. In consequence, attackers
need to spend signiﬁcantly more efforts to take down many
relay servers with different software implementations, while
obtaining much less retribution. Even if some relay servers
get compromised, they will be detected and excluded from the
relay system when they are utilized for launching attacks.

3) Malicious Relay Server Attack: In this kind of attack,
the malicious relay server attacks its connected IoT devices
by delivering packets containing attacking vectors. According
to our threat model, the malicious relay server must sign the
packets with its blockchain private key to get
it accepted
by the target IoT device. As shown in Figure 9, the signed
packet is then passed to our relay sharing client middleware.
The middleware may be vulnerable which means a malicious
relay server does have the chance to successfully bypass the
middleware’s inspection and takes down the device without
getting reported. However, as one of the core beneﬁts of
our work, we propose to deter this kind of attacks by im-
posing “economic risk” instead of relying on the unrealistic
perfect software implementation. Launching attacks inevitably
requires the target’s platform information which is acquired by
sending some probing packets. If the target is not vulnerable to
the probing attack, the unauthorized packets will be reported,
which results in the malicious relay server losing all its deposit.
Because the packet does not originate from the controller,
the malicious relay server is not able to prove its innocence
through the rebutting process. Although the attacker can rejoin
RS-IoT with a new account, the risk of losing deposit still
exists. Also, compared with the random scanning attack, it’s
very slow to traverse IoT devices on the RS-IoT platform by
passively waiting to be commissioned. Finally, attackers get
discouraged because this type of attack is not only risky but
also inefﬁcient.

B. Fairness Analysis

Considering there is no trust between relay users and
servers, fairness of the service trading platform is required to
prevent cheating behaviors of either parties. We enumerate all
possible cheating scenarios and show how to deal with them
by using our proof-of-delivery scheme.

1) Cheating: First, the relay user has the incentive to cheat
by denying that they have already received the relayed packet
from the relay server. According to the commitment procedure
described in Section VI, this can be achieved by sending an
incorrect commitment back to the relay server. For this kind of
cheating, the relay server cannot verify the commitment B and
B(cid:48) and thus won’t reveal the cover stream key P N . Without
P N , the cheating IoT device is not able to extract the desired
content, which is equivalent to receiving nothing. Hence, the
free ride is impossible due to the packet covering conducted
by the relay server.

Second, the relay server has the motivation to reap without
sowing. That is, it may deliver incomplete packets to IoT
devices to reduce the cost. Since the delivered packet
is
covered by the cover stream, IoT cannot verify its integrity
before the relay server reveals the cover stream key P N .

Fig. 9. Demonstration of possible attacks.

function call transactions towards the executing function in
the smart contract. This time only the transaction number
and the serial number is needed to locate the record in the
pending list. The smart contract ﬁrstly traverses the report
pending list to check the existence of the referred reporting
record. Then, it calculates the number of blocks that are newly
generated after the reporting. If the difference is larger than
the pre-deﬁned grace period, the smart contract will execute
the penalty that means the relay server’s deposit stored inside
the smart contract account will be transferred to the reporting
IoT device’s account. Moreover, the misbehaving relay server’s
registration information in the serverInfo list will be deleted to
revoke its qualiﬁcation as a relay server. As a result, it won’t be
able to be commissioned by any other IoT device in the future.
Since the public blockchain is anonymous, the malicious relay
server may rejoin the relay system with a different address
to continue its attacks. However, registering as a new relay
server requires the attacker to pay the deposit again, which
causes economic loss to the attacker.

The function prototype for executing is listed below:

function execute(uint Txn, uint serial){...}

VIII. SECURITY ANALYSIS

A. Possible Attacks

1) Random Scanning Attack: In a random scanning attack,
the attacker scans for open ports as other botnet malwares do
without joining the relay sharing system. Since IoT devices are
shielded by NAT gateways, scanning trafﬁc from the Internet
will not be able to reach the IoT devices. Even if the attacker
successfully compromises devices located in the same subnet,
the non TLS-N trafﬁc will be discarded by the packet ﬁlter
that resides in the IoT devices’ operating system kernel. As
depicted in Figure 9, this type of attack will never get a chance
to exploit any vulnerabilities in the application layer.

2) Attacks against the Relay Server:

In the centralized
relay model,
the relay server becomes an attractive target
for attackers because once it gets compromised, attackers

11

However, the byte selecting list Ra(cid:48) is not known to the relay
server, and it has no idea about which bytes will be selected for
composing the commitment. As a result, when an IoT device
generates the commitment B(cid:48) on the imcompletely delivered
packet, the relay server has no method to ﬁgure out a P N that
can satisfy the relation of CoverP N (B) = B(cid:48). Then, there
will be no way to pass the checking of proof-of-delivery by
the smart contact to obtain the service fee.

2) Malicious Reporting: Since joining the system as an IoT
devices requires no deposit, attackers who want to destroy the
system may register a large amount of IoT device accounts and
use them to maliciously report benign relay servers. Although
we design the rebutting scheme, this method may still be
able to overload relay servers and undermine the system’s
performance.

We prevent this kind of abuse by utilizing the high cost
nature of on-blockchain function calls, which is usually re-
garded as a problem as we discussed before. According to
our description of the reporting process, IoT devices need to
pass the whole packet as one of the arguments to the function
call which will be very expensive considering the data storage
and processing price on Ethereum [53]. For normal reporting
of real malicious packets, this cost will be made up by the
conﬁscated deposit of the relay server. However, if an IoT
device reports benign packet, there will be no make up. So,
malicious reporting leads to high cost and is quite uneconomic.

IX. EXPERIMENT

To validate the efﬁciency and usability of RS-IoT, we
deploy the proposed RS-IoT on Ethereum rinkeby testnet with
solidity script language of version 0.4.21. After that, we use
three Raspberry PIs with Geth (Golang Ethereum Client) and
the web3.py package installed as an emulation of the relay
server, IoT, and controller respectively. Each of the raspberry
PIs has one account setup in its geth client, and is topped
up with test ethers from the rinkeby Faucet. To minimize
the execution cost, we avoid using local variables and store
all
the
intermediate results in a memory location. We set
commitment length N to 32 bytes to avoid exceeding block
gas limit. Based on the cost of gas deﬁned in the Ethereum
yellow paper [53], we can accurately evaluate the execution
cost of every function that we use. Also, with the gas price set
to 2 Gwei (1 Ether equals to 1 ∗ E9 Gwei) and an Ether price
of $135, we can convert the execution cost to USD as listed
in Table III.

TABLE III.

CONTRACTS EXECUTION COST.

Entity:Function

Cost in Gas

Cost in USD

D:register
C:register
R:register
D:service request
D:service select
D:service conﬁrm
D:commitment
C:commitment
R:commitment verify
C, D, R:decommission
D:execute

Registration Total
Commission Total
Commit Total

47k
22k
40k
1.8k
14.3k
22.8k
175k
151k
40k
12k
8k

109k
32.6k
366k

0.012
0.005
0.01
0.0003
0.003
0.005
0.046
0.039
0.01
0.003
0.002

0.03
0.009
0.10

Fig. 10. Reporting & Rebutting Gas Cost.

As we can see, since all the operations of the RS-IoT
are asynchronous and none of them exceed the Ethereum gas
limit (average 3,000,000 gas per block), there is no limitation
on the number of concurrent online relay sessions. From
the usage perspective, registration costs 109k Gas in total,
which is a one-time cost. Commission/decommission cost
32.6k gas, but it only happens when the IoT device switches
to a new relay server. Though the price for commitment is
high, asynchronous veriﬁcation as mentioned in Section VI-B4
makes it unnecessary to be called for each delivered packet.
Instead, by caching the commitment transactions, veriﬁcation
can be conducted in arbitrary long packet intervals as long
as no disputation emerges. Thus, the cost is amortized as
affordable.

The costs of reporting and rebutting scales along with the
size of the reported packet are shown in Figure 10. Though
the gas limit of one block is about 7 million gas, operations
that consume more than 3.5 million gas become difﬁcult to
processed. The largest packet size for successful reporting and
rebutting in our experiment is 3.5k bytes.

X. RELATED WORK

A. IoT Malware Defense

After the breakout of Mirai botnet, various defense schemes
are proposed. They can be categorized into three types: The
ﬁrst type is the honeypot as in [38], [36], [9] which is usually
for research purpose only. The honeypot is a computer with
publicly accessible IP addresses and powerful trafﬁc moni-
toring and logging systems that imitates normal IoT devices.
It functions as a trap to detect botnet scanning trafﬁc and
after that entices the loading of executable malware ﬁles by
pretending to be compromised. In this way,
the honeypot
operators can acquire samples of malwares at the ﬁrst time.
Analysis of the sample malware gives security experts clues
about the address of the attacking master’s command and
control server and helps them make security patches. However,
because of the lack of reliable ﬁrmware update methods, it’s
hard to push the security patch to vulnerable devices, which
undermines the effect of this kind of defense.

The second type is the secure software implementation
guideline, and modules like IDS (Intrusion Detection System)
designed for IoT devices and IoT connected cloud servers.

12

[10], [41] fall into this type. [10] proposes to enforce security
policies on IoT devices to ﬁlter out abnormal or unnecessary
packets and [41] offers some guidelines from perspectives of
network conﬁguration and device deployment. Both of these
works require assumptions about the robustness of deployed
softwares, which does not always hold.

The last type of defense as in [16], [34], [27] is actually
inspired by Mirai botnet malware, which involves discovering
vulnerable IoT devices by random scanning. Upon discovering
new targets, they either dig into the system to expel the hidden
malware or report the vulnerable device to authorities and the
owner. However, this type of defense is limited on its usability
that there is normally no reliable way to notify the owner for
discovered vulnerabilities. Purifying the IoT device without
getting the owner’s approval causes legal concern.

B. Blockchain based IoT Service

Though blockchain has been proved as a successful tech-
nology for years, the high cost of transaction fee and limited
network throughput have long become the impediment of
adopting it for IoT. However, there are quite some works trying
to ﬁnd workaround ways to integrate the power of blockchain
into IoT systems. In [7] smart contract is used as an IoT
authorization platform where the smart contract only serves
as an online distributed ledger to record permission changes.
In [29], blockchain is used for secure device commissioning
and data privacy protecting with the help of secure hardware.
In [22], self-mined private blockchain is deployed in home
network as a ledger of accessing privilege and access control
policies. However, none of these works solve the problem of
IoT malware propagation.

Although the idea of imposing economic incentives and
penalties has already been proposed in Enigma [59], it only
provides a theoretical model for secure multi-party compu-
tation rather than a usable guideline for IoT and blockchain
integration. Enigma conduct most of its operation on the
blockchain which is inevitably expensive. In comparison, our
proof-of-delivery scheme can run off-chain completely as long
as no dispute happens. Other related works that utilizing
economic incentives such as NameCoin [35] and FileCoin [11]
also use the economic incentives, but they are applied on
speciﬁc tasks that involves low frequency of on-chain operation
and do not propose the framework of off-chain verﬁﬁcation.

XI. DISCUSSION

a) Device endpoints: Blockchain data is increasing
inﬁnitely, it is unrealistic to let each IoT devices to access
the public blockchain with their own client. In real-world
deployment, the blockchain client can be hosted on a local
edge server (e.g., a home router, an IoT device hub) which
has higher computing power and sufﬁcient storage space to
host an Ethereum Geth client [3]. The edge server opens the
Remote Procedure Call (RPC) interface and serves as a proxy
for IoT devices to query the blockchain’s content and broadcast
transactions. As a result, resource limited IoT devices do not
need to store any blockchain data except their own private
keys for signing transactions. As the edge server is owned
and operated by the same owner,
is trusted by the all
other IoT devices with in the same household’s network. This

it

architecture has already been widely adopted by many other
research works and is proved to be more efﬁcient than the light
Geth client [1].

b) Account compromising attacks: Since each IoT de-
vices need to setup its own cryptocurrency wallet for paying
the service fee, malicious relay servers have the motivation to
steal their customer IoT devices’ account. Malicious servers
may launch attacks in the wish of retrieving victim devices’
blockchain private key. However, in reality, this type of attack
can be easily defeated by allowing deposing service fees with
any other blockchain account (e.g., users’ personal accounts
that are securely protected). There is no need to check the
eligibility of making deposits because malicious depositing
makes no sense. As a result, there will only be very few
amount of cryptocurrency in IoT devices’ accounts for paying
transaction fees. As a result, earnings of this kind of attacks
are very limited compared to the high risk of being reported
and losing a large amount of the deposit.

c) Service Quality: Different relay servers may provide
services with different qualities. For example, a relay server
with more powerful hardware and higher Internet bandwidth
could forward packets with smaller latency. To help relay
service users to choose better service providers, the service
rating function can be added to the current smart contract.
For a speciﬁc relay server, its service users that have use it
to forward a higher number of packets than a pre-deﬁned
threshold have the eligibility to rate its service quality. The
smart contract will record its total number of ratings and the
average rating score along with its record in the serverInfo
table. Hence, on receiving quotes from relay servers, IoT
devices have additional information to ﬁnd a most attactive
one with balanced price and service quality.

d) Amount of Service Fee and Deposit: This paper
concentrates on demonstrating the framework of IoT and
blockchain integration. Finding the optimal amount of service
fee and deposit requires economic theories that is out of the
scope of this paper. Intuitively, the required deposit for a
speciﬁc relay server can be dynamically tuned according to
the number of its users. When the number of users reaches a
higher lever, the relay server should invest additional deposit
accordingly.

XII. CONCLUSION

In this paper, we presented a general framework for ef-
ﬁcient blockchian and IoT service integration. To solve high
cost and overhead of on-blockchain operations, we proposed
the distributed architecture to host IoT services on third-
part servers and use the blockchain and the smart contract
as a naturally trusted authority to enforce the fairness and
punish attackers. We applied this architecture on the task of
IoT remote accessing and designed RS-IoT, a blockchain-
assisted distributed relay sharing system. RS-IoT provided
secure and robust relay services for IoT users to access their
IoT devices which are behind the network address translation
(NAT). We utilized “an economic approach to cyber security”
to deter malicious relay servers and achived it with our novel
proof-of-delivery mechanism. By verifying proofs off-chain,
the costs and throughput issues of blockchain are overcome.
We demonstrated the cost efﬁciency of our design with our
prototype implementation on the Ethereum testnet.

13

REFERENCES

[1]

[2]

[3]

“Light client protocol,” 2018. [Online]. Available: https://github.com/
ethereum/wiki/wiki/Light-client-protocol
“Aws iot developer guide,” 2019. [Online]. Available: https://docs.aws.
amazon.com/iot/latest/developerguide
“Ofﬁcial go implementation of the ethereum protocol,” 2019. [Online].
Available: https://github.com/ethereum/go-ethereum

[4] D. Ajitomi, H. Kawazoe, K. Minami, and N. Esaka, “A cost-effective
method to keep availability of many cloud-connected devices,” in 2015
IEEE 8th International Conference on Cloud Computing.
IEEE, 2015,
pp. 1–8.

[5] N. Alexopoulos, S. M. Habib, and M. M¨uhlh¨auser, “Towards secure
distributed trust management on a global scale: An analytical approach
for applying distributed ledgers for authorization in the iot,” in Pro-
ceedings of the 2018 Workshop on IoT Security and Privacy. ACM,
2018, pp. 49–54.

[6] O. Alrawi, C. Lever, M. Antonakakis, and F. Monrose, “Sok: Security
evaluation of home-based iot deployments,” in SoK: Security Evaluation
of Home-Based IoT Deployments.

IEEE, 2019, p. 0.

[7] M. P. Andersen, J. Kolb, K. Chen, G. Fierro, D. E. Culler, and
R. A. Popa, “Wave: A decentralised authorization system for iot via
blockchain smart contracts,” 2017.

[8] E. Androulaki, A. Barger, V. Bortnikov, C. Cachin, K. Christidis,
A. De Caro, D. Enyeart, C. Ferris, G. Laventman, Y. Manevich et al.,
“Hyperledger fabric: a distributed operating system for permissioned
blockchains,” in Proceedings of the Thirteenth EuroSys Conference.
ACM, 2018, p. 30.

[9] M. Antonakakis, T. April, M. Bailey, M. Bernhard, E. Bursztein,
J. Cochran, Z. Durumeric, J. A. Halderman, L. Invernizzi, M. Kallitsis
et al., “Understanding the mirai botnet,” in USENIX Security Sympo-
sium, 2017, pp. 1092–1110.

[10] D. Barrera, I. Molloy, and H. Huang, “Idiot: Securing the internet of
things like it’s 1994,” arXiv preprint arXiv:1712.03623, 2017.
J. Benet and N. Greco, “Filecoin: A decentralized storage network,”
Protoc. Labs, 2018.

[11]

[12] T. S. Bernard, T. Hsu, N. Perlroth, and R. Lieber, “Equifax says
cyberattack may have affected 143 million in the us,” The New York
Times, p. A1, 2017.

[13] C.

Bradford,

“7

Security
[Online]. Available: https://blog.storagecraft.com/

Infamous

Cloud

Most

Breaches,” 2018.
7-infamous-cloud-security-breaches/

[14] P. Brody and V. Pureswaran, “Device democracy: Saving the future of

the internet of things,” IBM, September, 2014.

[15] V. Buterin et al., “A next-generation smart contract and decentralized

application platform,” white paper, 2014.

[16] C. Cao, L. Guan, P. Liu, N. Gao, J. Lin, and J. Xiang, “Hey, you, keep
away from my device: remotely implanting a virus expeller to defeat
mirai on iot devices,” arXiv preprint arXiv:1706.05779, 2017.
J. Chen, S. Yao, Q. Yuan, K. He, S. Ji, and R. Du, “Certchain: Public
and efﬁcient certiﬁcate audit based on blockchain for tls connections,”
in IEEE INFOCOM 2018-IEEE Conference on Computer Communica-
tions.

IEEE, 2018, pp. 2060–2068.

[17]

[18] L. Chen, A. Avizienis et al., “N-version programminc: A fault-tolerance
approach to rellablllty of software operatlon,” in Twenty-Fifth Interna-
tional Symposium on Fault-Tolerant Computing, 1995,.
IEEE, 1995,
p. 113.

[19] K. Christidis and M. Devetsikiotis, “Blockchains and smart contracts

for the internet of things,” Ieee Access, vol. 4, pp. 2292–2303, 2016.

[20] M. Conoscenti, A. Vetro, and J. C. De Martin, “Blockchain for the
internet of things: A systematic literature review,” in 2016 IEEE/ACS
13th International Conference of Computer Systems and Applications
(AICCSA).

IEEE, 2016, pp. 1–6.

[21] B. Cox, D. Evans, A. Filipi, J. Rowanhill, W. Hu, J. Davidson, J. Knight,
A. Nguyen-Tuong, and J. Hiser, “N-variant systems: A secretless frame-
work for security through diversity.” in USENIX Security Symposium,
2006, pp. 105–120.

[22] A. Dorri, S. S. Kanhere, R. Jurdak, and P. Gauravaram, “Blockchain
for iot security and privacy: The case study of a smart home,” in Perva-

14

[23]

sive Computing and Communications Workshops (PerCom Workshops).
IEEE, 2017, pp. 618–623.
J.
holes
[Online].
researcher-reveals-d-link-router-holes-that-might-never-be-patched/

router
2017.
patched,”
https://nakedsecurity.sophos.com/2017/09/12/

“Researcher
never

might
Available:

d-link
Sep

reveals

Dunn,

that

be

E.

[24] M.

J. Dworkin, “Sha-3 standard: Permutation-based hash and

extendable-output functions,” Tech. Rep., 2015.

[25] C. Fromknecht, D. Velicanu, and S. Yakoubov, “Certcoin: A namecoin
based decentralized authentication system,” Massachusetts Inst. Tech-
nol., Cambridge, MA, USA, Tech. Rep, vol. 6, 2014.

“Gartner

[26] Gargner,
iot
Available:
2018-11-07-gartner-identiﬁes-top-10-strategic-iot-technologies-and-trends

strategic
[Online].
https://www.gartner.com/en/newsroom/press-releases/

10
2018.

technologies

identiﬁes

trends,”

and

top

[27] D. Goodin, “Brickerbot, the permanent denial-of-service botnet, is back

with a vengeance,” Ars Technica, 2017.

[28] D. Happ, N. Karowski, T. Menzel, V. Handziski, and A. Wolisz,
“Meeting iot platform requirements with open pub/sub solutions,”
Annals of Telecommunications, vol. 72, no. 1-2, pp. 41–52, 2017.
[29] T. Hardjono and N. Smith, “Cloud-based commissioning of constrained
devices using permissioned blockchains,” in Proceedings of the 2nd
ACM International Workshop on IoT Privacy, Trust, and Security.
ACM, 2016, pp. 29–36.

[30] P. Kim, “Pwning the dlink 850l routers and abusing the mydlink cloud
protocol,” 2017. [Online]. Available: https://pierrekim.github.io/blog/
2017-09-08-dlink-850l-mydlink-cloud-0days-vulnerabilities/

[31] ——,

“Security

research
in
nerabilities
2017.
Available:
2017-09-08-dlink-850l-mydlink-cloud-0days-vulnerabilities/

vul-
cameras,”
https://pierrekim.github.io/blog/

[Online].

multiple

wireless

found

pierre

by

ip

[32] C. Kolias, G. Kambourakis, A. Stavrou, and J. Voas, “Ddos in the iot:

Mirai and other botnets,” Computer, vol. 50, no. 7, pp. 80–84, 2017.

[33] B. Krebs, “Who makes the iot things under attack,” Krebs on Security,

2016.

[34] F. Lauria, “How to footprint, report and remotely secure compromised

iot devices,” Network Security, vol. 2017, no. 12, pp. 10–16, 2017.

[35] A. Loibl and J. Naab, “Namecoin,” namecoin. info, 2014.
[36] T. Luo, Z. Xu, X. Jin, Y. Jia, and X. Ouyang, “Iotcandyjar: Towards an
intelligent-interaction honeypot for iot devices,” Black Hat, 2017.
[37] A. Z. Ourad, B. Belgacem, and K. Salah, “Using blockchain for
iot access control and authentication management,” in International
Conference on Internet of Things. Springer, 2018, pp. 150–164.
[38] Y. M. P. Pa, S. Suzuki, K. Yoshioka, T. Matsumoto, T. Kasama, and
C. Rossow, “Iotpot: analysing the rise of iot compromises,” EMU, vol. 9,
p. 1, 2015.

[39] A. Panarello, N. Tapas, G. Merlino, F. Longo, and A. Puliaﬁto,
“Blockchain and iot integration: A systematic survey,” Sensors, vol. 18,
no. 8, p. 2575, 2018.

[40] P. Parwekar, “From internet of things towards cloud of things,” in 2nd
International Conference on Computer and Communication Technology.
IEEE, 2011, pp. 329–333.

[41] B. R. Payne and T. T. Abegaz, “Securing the internet of things: Best

practices for deploying iot devices,” pp. 493–506, 2018.

[42] S. Popov, “The tangle,” cit. on, p. 131, 2016.
[43] S. Raval, Decentralized applications: harnessing Bitcoin’s blockchain

technology.

” O’Reilly Media, Inc.”, 2016.

[44] H. Ritzdorf, K. W¨ust, A. Gervais, G. Felley, and S. Capkun, “Tls-n:
Non-repudiation over tls enablign ubiquitous content signing.” in NDSS,
2018.

[45] A. Sajid, H. Abbas, and K. Saleem, “Cloud-assisted iot-based scada
systems security: A review of the state of the art and future challenges,”
IEEE Access, vol. 4, pp. 1375–1384, 2016.

[46] B. Schneier, “The internet of things is wildly insecure–and often

[47]

unpatchable,” Schneier on Security, vol. 6, 2014.
J. Singh, T. Pasquier, J. Bacon, H. Ko, and D. Eyers, “Twenty security
considerations for cloud-supported internet of things,” IEEE Internet of
things Journal, vol. 3, no. 3, pp. 269–284, 2016.

[48] V. Sivaraman, D. Chan, D. Earl, and R. Boreli, “Smart-phones attacking
smart-homes,” in Proceedings of the 9th ACM Conference on Security &
Privacy in Wireless and Mobile Networks. ACM, 2016, pp. 195–200.
[49] P. Srivastava and N. Garg, “Secure and optimized data storage for iot
through cloud framework,” in International Conference on Computing,
Communication & Automation.

IEEE, 2015, pp. 720–723.

[50] A. Stanciu, “Blockchain based distributed control system for edge
computing,” in 2017 21st International Conference on Control Systems
and Computer Science.

IEEE, 2017, pp. 667–671.

[51] H. Tschofenig and S. Farrell, “Report from the internet of things

software update (iotsu) workshop 2016,” Tech. Rep., 2017.

[52] R. Walters, “Cyber attacks on us companies in 2014,” The Heritage

Foundation, vol. 4289, pp. 1–5, 2014.

[53] G. Wood, “Ethereum: A secure decentralised generalised transaction
ledger,” Ethereum Project Yellow Paper, vol. 151, pp. 1–32, 2014.
[54] D. W¨orner and T. von Bomhard, “When your sensor earns money:
exchanging data for cash with bitcoin,” in Proceedings of the 2014
ACM International Joint Conference on Pervasive and Ubiquitous
Computing: Adjunct Publication. ACM, 2014, pp. 295–298.
[55] L. Wu, X. Du, W. Wang, and B. Lin, “An out-of-band authentication
scheme for internet of things using blockchain technology,” in 2018
International Conference on Computing, Networking and Communica-
tions (ICNC).

IEEE, 2018, pp. 769–773.

[56] B. Zhang, “Awesome iot hacks,” 2019. [Online]. Available: https:

//github.com/nebgnahz/awesome-iot-hacks

[57] B. Zhang, N. Mor, J. Kolb, D. S. Chan, K. Lutz, E. Allman,
J. Wawrzynek, E. Lee, and J. Kubiatowicz, “The cloud is not enough:
Saving iot from the cloud,” in 7th {USENIX} Workshop on Hot Topics
in Cloud Computing, 2015.

[58] G. Zyskind, O. Nathan et al., “Decentralizing privacy: Using blockchain
to protect personal data,” in 2015 IEEE Security and Privacy Work-
shops.

IEEE, 2015, pp. 180–184.

[59] G. Zyskind, O. Nathan, and A. Pentland, “Enigma: Decentral-
ized computation platform with guaranteed privacy,” arXiv preprint
arXiv:1506.03471, 2015.

15

