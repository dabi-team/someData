DICE: Automatic Emulation of DMA Input
Channels for Dynamic Firmware Analysis

Alejandro Mera, Bo Feng, Long Lu, Engin Kirda, William Robertson
Khoury College of Computer Sciences
Northeastern University
Boston, USA
{mera.a, feng.bo, l.lu, e.kirda}@northeastern.edu

Abstract—Microcontroller-based embedded devices are at the
core of Internet-of-Things (IoT) and Cyber-Physical Systems
(CPS). The security of these devices is of paramount importance.
Among the approaches to securing embedded devices, dynamic
ﬁrmware analysis (e.g., vulnerability detection) gained great
attention lately,
thanks to its ofﬂine nature and low false-
positive rates. However, regardless of the analysis and emulation
techniques used, existing dynamic ﬁrmware analyzers share a
major limitation, namely the inability to handle ﬁrmware using
DMA (Direct Memory Access). It severely limits the types of
devices supported and ﬁrmware code coverage.

We present DICE, a drop-in solution for ﬁrmware analyzers
to emulate DMA input channels and generate or manipulate
DMA inputs (from peripherals to ﬁrmware). DICE is designed
to be hardware-independent (i.e., no actual peripherals or DMA
controllers needed) and compatible with common MCU ﬁrmware
(i.e., no ﬁrmware-speciﬁc DMA usages assumed) and embedded
architectures. The high-level idea behind DICE is the identi-
ﬁcation and emulation of the abstract DMA input channels,
rather than the highly diverse peripherals and controllers. DICE
identiﬁes DMA input channels as the ﬁrmware writes the source
and destination DMA transfer pointers into the DMA controller.
Then DICE manipulates the input transferred through DMA on
behalf of the ﬁrmware analyzer. DICE does not require ﬁrmware
source code or additional features from ﬁrmware analyzers.

We integrated DICE to the recently proposed ﬁrmware an-
alyzer P2IM (for ARM Cortex-M architecture) and a PIC32
emulator (for MIPS M4K/M-Class architecture). We evaluated it
on 83 benchmarks and sample ﬁrmware, representing 9 different
DMA controllers from 5 different vendors. DICE detected 33
out of 37 DMA input channels, with 0 false positives. It correctly
supplied DMA inputs to 21 out of 22 DMA buffers that ﬁrmware
actually use, which previous ﬁrmware analyzers cannot achieve
due to the lack of DMA emulation. DICE’s overhead is fairly
low, it adds 3.4% on average to P2IM execution time. We also
fuzz-tested 7 real-world ﬁrmware using DICE and compared the
results with the original P2IM. DICE uncovered tremendously
more execution paths (as much as 79X) and found 5 unique
previously-unknown bugs that are unreachable without DMA
emulation. All our source code and dataset are publicly available.

I. INTRODUCTION

Modern embedded devices, equipped with increasingly
powerful MCUs (microcontrollers) and rich network con-
nectivity, are used as the building blocks in Internet-of-
Things (IoT) and Cyber-Physical Systems (CPS). It is expected
that 5.8 billion Enterprise and Automotive connected devices
(IoT and CPS) will be in use in 2020 [12]. Therefore, the
(in)security of embedded devices has profound implications on

millions of devices, in terms of both data privacy and physical
safety. Security vulnerabilities in ﬁrmware may allow attackers
to control affected devices deployed in smart homes, connected
vehicles, intelligent factories, power grids, etc., and in turn,
steal critical data or manipulate device behavior. Such attacks
have been on a rise and launched on cars [5], [28], Wi-Fi SoC
[31], [33], manufacturing controllers [43], and more.

To improve embedded device security, researchers explored
various approaches, including runtime attack mitigation [16],
remote attestation [41], [37], and ﬁrmware analysis [10], [44],
[6], [7]. Compared with other approaches, dynamic ﬁrmware
analysis has low false positives, requires no hardware or
software modiﬁcation, and incurs zero overhead on production
devices. Therefore, it is generally considered more practical.
A major challenge facing dynamic ﬁrmware analysis is
the inability to fully run and test ﬁrmware at scale, due to
hardware dependence on diverse peripherals. Many previous
works either rely on real hardware components during analysis
or port ﬁrmware to a conventional computer platform (e.g.,
x86), for which full emulators exist. P2IM [10] is a recent
work that for the ﬁrst time enables dynamic ﬁrmware analysis
without requiring actual hardware, source code, or porting
ﬁrmware to a non-native platform. P2IM removes hardware
dependence by identifying processor-peripheral interfaces and
supplying viable input data through such interfaces on behalf
of peripherals. As a result, ﬁrmware can boot, run, and be
tested in a generic emulator without using peripheral hardware
or emulation.

Despite the tremendous progress made by previous works,
one fundamental problem remains open: existing dynamic an-
alyzers cannot support ﬁrmware taking input from peripherals
via DMA (Direct Memory Access). When ﬁrmware reads from
a DMA buffer in memory, which is supposed to contain input
written directly by a peripheral, existing analyzers or emulators
would fail to recognize it as a DMA read, and instead, treat it
as a regular memory read (i.e., returning zero or invalid value
to ﬁrmware). As a result, ﬁrmware cannot obtain any DMA
inputs, which causes the execution to idle, a large portion
of the ﬁrmware code to be unreachable/untested, or even the
analysis session to crash.

The root cause of the problem lies in the very nature of
DMA, which allows peripherals to access memory directly
(with the help of a DMA controller, which is also a peripheral).

1

programs the sources and destinations of DMA transfers into
the DMA controller. The sources and destinations are ad-
dresses within speciﬁc ranges (such as RAM), and are written
to a ﬁxed region in memory, namely the memory-mapped
registers of the DMA controller. By identifying the creations
and removals of such channels, DICE maps the sources and
destinations of possible DMA data transfers. When ﬁrmware
reads from a memory buffer that belongs to a DMA data
transfer destination, DICE detects it as a DMA input event
and signals the analyzer for further actions (e.g., supplying
the read with fuzzer-generated input).

There are three main technical challenges that we tackled
while pursuing this approach. First, DMA input channels are
created and removed on demand by ﬁrmware during execution.
DICE needs to dynamically identify these channels and mon-
itor input events through them. Second, the high diversity in
embedded hardware and software makes it difﬁcult to develop
a generic design for DICE that works on different
types
of architectures, peripherals, DMA controllers, and ﬁrmware.
Third, a large number of ﬁrmware analyzed in practice are
in binary form without source code or debug symbols. DICE
should not need source code for identifying and emulating
DMA input channels. Our design and implementation ad-
dressed all these challenges.

To evaluate the performance of DICE and demonstrate the
beneﬁts that it brings to existing ﬁrmware analyzers, we built
two prototypes of DICE, based on P2IM (for ARM Cortex-M)
and a PIC32 emulator (for MIPS M4K/M) [36], respectively.
We performed unit tests or micro-benchmarking on 83 sample
ﬁrmware, representing 11 different MCU SoCs and covering
ARM and MIPS architectures. DICE detected 33 out of 37
DMA input channels correctly, with 0 false positives. For
the 22 channels that ﬁrmware actually used during the tests,
DICE supplied inputs to 21 of them without errors. We also
conducted fuzzing tests on 7 real ﬁrmware and measured the
code and path coverages with and without DICE enabled on
P2IM. Thanks to DICE’s automatically emulated DMA input
channels, the basic block coverage increased by 30.4% and
the path coverage jumped remarkably by 79X. Even with
a fairly primitive memory sanitizer and a 48-hour fuzzing
session, DICE detected 5 unique previously unknown bugs
in the ﬁrmware.

The source code of DICE, the integrations with ﬁrmware
analyzers and emulators, and all
the ﬁrmware tested are
publicly available at https://github.com/RiS3-Lab/DICE-D
MA-Emulation.

In sum, our work makes the following contributions:

• We study and advocate the importance of supporting
DMA-based peripherals and input in dynamic ﬁrmware
analysis; we identify the lack of DMA support as a
common limitation for all existing ﬁrmware analyzers.
• We present DICE, which enables dynamic ﬁrmware ana-
lyzers to support DMA-based peripherals, and recognize
and manipulate DMA inputs for testing otherwise skipped
or unreachable code/states in ﬁrmware.

Fig. 1: DICE design overview as a drop-in component of ﬁrmware analyzer

A ﬁrmware analyzer, if not fully emulating all peripherals or
entirely aware of their DMA activities, is unable to determine
when and where in memory DMA-based I/O may occur.
Therefore, the analyzer cannot tell, when ﬁrmware reads from
a buffer in memory, whether the read operation is a DMA-
based input event or just a regular load of data from memory.
Due to this open problem, existing analyzers either treat
DMA to be out of scope (i.e., not supporting ﬁrmware that
uses DMA), or use very simple heuristics to statically infer
locations of DMA buffers in memory, which can be highly
inaccurate and incomplete due to the dynamic nature of DMA.
Supporting DMA input is critical and necessary for dynamic
analysis of embedded ﬁrmware, for the following reasons.
First, to perform comprehensive dynamic tests of ﬁrmware,
all
input channels used by ﬁrmware need to be covered.
Embedded devices take inputs from a wide range of periph-
erals through several channels, including MMIO (memory-
mapped I/O) and DMA. Analysis of DMA-enabled ﬁrmware
cannot reach or exercise the code that depends on DMA
inputs. Second, many embedded devices use DMA (roughly
25% among the surveyed ﬁrmware, see §IV). In fact, DMA
offers additional beneﬁts to embedded devices. For example,
besides improving data transfer rates, DMA allows processors
to enter or stay in sleep or power-saving mode during data
transfers, which is desirable for power-constrained embedded
devices. Third, DMA is the only input channel used by certain
peripherals and buses on embedded devices. For instance,
input from CAN (Controller Area Network) and USB is
accessible to ﬁrmware only via DMA.

In this paper, we present DICE (DMA Input Channel
Emulation), a drop-in component (Fig. 1) for existing and fu-
ture dynamic ﬁrmware analyzers to recognize and manipulate
DMA-based peripheral input, and in turn, expand their analysis
to cover ﬁrmware code, states, and vulnerabilities dependent
on DMA input.

DICE adopts a non-conventional approach to supporting
ﬁrmware input during analysis. Instead of aiming to emulate
DMA controllers or DMA-enabled peripherals, which is prac-
tically impossible due to the complexity and diversity of these
hardware components, we design DICE to emulate the DMA
input channels, an implicit
interface through which DMA
input data ﬂow to (or is consumed by) ﬁrmware execution.
These channels manifest as memory buffers which peripherals
directly write data to and ﬁrmware subsequently reads input
from. DICE identiﬁes DMA input channels when the ﬁrmware

2

MCU memorymapProcessorEmulatorDICECrashReportTesting inputPeripheralProcessor InterfaceDMATraces• When designing DICE, we overcome the challenges
posed by the dynamic nature of DMA,
the diverse
hardware and software of embedded devices, and the
unavailability of ﬁrmware source code.

• We implemented two prototypes of DICE based on P2IM
and a MIPS PIC32 emulator, respectively. Our evaluation
shows that DICE: (1) achieved highly accurate DMA
input channel identiﬁcation and emulation, (2) helped
P2IM signiﬁcantly improve its analysis coverage and
discover 5 new bugs in tested ﬁrmware.

• We analyzed all the bugs discovered by DICE and found
all of them are remotely exploitable. They have security
consequences such as information leakage, data corrup-
tion, and denial-of-service. These bugs cannot be found
by exiting ﬁrmware analyzers due to the lack of DMA
support or emulation.

II. MOTIVATION

MCU-based embedded devices (or MCUs in short) integrate
on a single chip a main processor, RAM, Flash, and diverse
peripherals. Their energy-efﬁciency and sufﬁcient computing
power make them the ideal building blocks of IoT devices and
cyber-physical systems. The entire software stack on MCUs,
referred to as ﬁrmware, contains OS/system libraries, drivers,
and application-level logic in a monolithic form.

Firmware, similar to other software, may contain program-
ming errors or bugs that can be exploited by attackers [32],
[33], [31]. These security bugs in ﬁrmware, although often
similar in nature, can cause severe and unique consequences
because MCUs are widely used in mission-critical settings
(e.g., industrial systems) and have direct physical outreach
(e.g., controlling vehicle movements).

Unfortunately, bugs in MCU ﬁrmware are more difﬁcult
to detect than bugs in conventional computer software, due
to existing analysis tools’ limited support for highly diverse
and heterogeneous MCU hardware. Specially, various kinds
of peripherals are used as the main communication channels
through which ﬁrmware communicates with other devices and
interacts with the physical environment. However, existing
ﬁrmware analysis methods cannot fully model or emulate
peripherals, and thus, fail to trigger or reach a large portion of
ﬁrmware code during analysis, missing opportunities to detect
bugs.

Take a MCU-based GPS device as an example (Figure 2).
It uses UART (universal asynchronous receiver-transmitter) to
receive NMEA [13] serialized messages from a GPS antenna.
These messages are copied to RAM via DMA. The ﬁrmware
then parses the messages and computes the location informa-
tion, which is later copied via DMA to an LCD (Liquid Crystal
Display) attached to the SPI (Serial Peripheral Interface).
This device also has other peripherals for receiving inputs or
delivering outputs.

Without peripheral awareness or support, dynamic analysis
of this GPS ﬁrmware cannot reach most of the code because
the ﬁrmware execution cannot receive any input or even boot
up the device. Some recent work [44], [6], [10] addressed

Fig. 2: A MCU-based GPS and its I/O ﬂows: 1(cid:13) DMA-based interfaces, 2(cid:13)
MMIO/interrupt-based interfaces.

the peripheral dependence issue using different approaches.
However, they mostly focused on the simple peripherals that
only use memory-mapped I/O (e.g., those inside the box 2(cid:13)
in Figure 2). [7] relies on manually identiﬁed DMA buffers to
partially support simple DMA-based I/O, and [2] completely
removes DMA through replacing HAL (hardware abstraction
layer) functions with manually-written hooks.

So far no existing work supports complex peripherals that
use DMA to communicate with ﬁrmware (e.g., those inside
box 1(cid:13) in Figure 2). Therefore, ﬁrmware using DMA still
cannot be fully analyzed and all
their bugs/vulnerabilities
detected. According to our survey (§IV), most nontrivial
ﬁrmware use DMA for both performance and energy-saving
reasons. In these ﬁrmware, the majority of code cannot run or
be tested without DMA support.

III. BACKGROUND

A. DMA on MCU Devices

Direct Memory Access (DMA) is a widely used architec-
tural feature that allows peripherals to access the main system
memory (RAM) without involving main processors. The goal
of DMA is to improve performance when transferring data
between RAM and peripherals. The introduction of DMA
dates back to the 1960s on the DEC PDP-8 minicomputer [3].
DMA is ubiquitously adopted by today’s computers.

DMA is also widely used in modern embedded devices
powered by microcontrollers (MCU). Similar to DMA on
conventional computers, DMA on MCU devices beneﬁt from
the performance improvement in data transfer between RAM
and peripherals. Unlike conventional computers, MCU devices
use DMA not just for performance reasons but also for saving
power or energy. DMA allows large or slow data transfers
to take place while the main processor (i.e., a major power
consumer on embedded devices) is asleep or stays in the low-
power mode.

From the programmers’ perspective, DMA provides a stan-
dard interface that abstracts away peripheral internals. Pro-
grammers can use the same interface exposed by DMA
controllers to exchange data with different peripherals. An
example of this abstraction is the HAL library of ChibiOS [9],

3

SPIDMA CTRLRAMMainProcessorUARTBufferBufferGPIODACFLASHI2CLCDMCU-based GPS12GPSEEPROMA single MCU may have more than one DMA controllers,
each covering a set of connected peripherals. A DMA stream
in a DMA controller can only be used for supporting one DMA
transfer at any given time. High-speed on-chip peripherals,
such as Ethernet, USB, and CAN, may integrate a DMA
controller for higher throughput. Note that it is the DMA
controller, not the source peripheral, that directly writes the
data to memory. DMA controllers are the only peripherals
that can directly access RAM thanks to the special permission
they have to access the system bus as master devices.

C. Challenges of Supporting DMA in Firmware Analysis

Dynamic nature of DMA: The dynamic nature of DMA (e.g.,
conﬁgurations, streams, and transfers) makes it challenging
to detect DMA input channels or infer transfer pointers.
Some previous work relies on manual and static identiﬁcation
of DMA buffers [7]. This strategy requires source code or
reverse engineering of ﬁrmware. Despite the poor scalability,
it can neither be complete nor accurate because it may miss
dynamically created DMA buffers or mistakenly treat regular
memory regions as DMA buffers. A reliable and practical
approach should consider that DMA transfers are created
and performed dynamically on demand. It should not require
human efforts or rely purely on static inference.

MCU hardware and software diversity: The diversity of
MCU ﬁrmware prevents the application of DMA models
designed for desktop OS, where a generic hardware abstraction
layer (HAL) exists (e.g. for Linux [39]). For MCU ﬁrmware,
there is no standard DMA interface or a prevalent OS that
provides a generic abstraction for various hardware periph-
erals. Moreover, it is practically impossible to develop an
emulator for each DMA controller and peripheral due to the
high diversity of the hardware, as observed by [10], [44], [29],
[6]. Therefore, it is necessary yet challenging to design a single
DMA emulation method that can work with a wide range of
ﬁrmware, architectures and peripherals.

IV. SURVEY ON DMA AVAILABILITY AND USAGE ON
MCUS

We surveyed 1) the availability of DMA controllers for
MCUs on the complete product portfolio of a top MCU
vendor, and 2) DMA usage by ﬁrmware on a large collection
of open-source repositories from GitHub.

A. DMA Availability on MCUs

We analyzed on March 2019 the MCU product portfolio
(which documents all MCU models a vendor produced) of
Microchip Semiconductors [24], a top MCU vendor in terms
of market share [19]. Our analysis included 1,356 MCUs
from 32-bit (ARM Cortex-M, MIPS), 16-bit (PIC16), and 8-
bit (PIC8 and AVR) architectures. We excluded the legacy
architecture 8051. We grouped MCUs into families using
Microchip’s quick reference guides [27], [25], [26]. MCUs
within the same family, although different in memory size and
packaging, use the same architecture and have mostly the same

Fig. 3: DMA controller and detail of DMA transfer descriptors, each using 20
bytes of memory span in the MMIO region (some ﬁelds of transfer descriptors
are omitted for simplicity).

where the low-level drivers use DMA transparently through a
uniform interface to receive input from different peripheral.

We surveyed the availability of DMA on MCUs and the uses
of DMA in ﬁrmware. We analyzed 1,356 MCUs from a major
vendor and 1,000 repositories from Github targeting MCUs
exclusively. Our analysis showed that 94.1% of the modern
MCUs (32-bit architecture) are DMA capable, which demon-
strates the ubiquitous support for DMA on modern embedded
devices. As for the ﬁrmware, 25.1% of the compilable or pre-
compiled MCU repositories contain DMA related debugging
symbols, a strong indicator of ﬁrmware using DMA. The
results underline the importance and urgency of supporting
DMA-capable peripherals and DMA-based input in ﬁrmware
analysis. We present the details of our survey in §IV.

B. DMA Workﬂow on ARM Cortex-M

We choose ARM Cortex-M as the reference architecture for
designing DICE because it is the most common architecture
used in modern MCU devices and IoT. DMA works on this
architecture in a similar way as it does on others, such
as MIPS, which DICE also supports. Below we describe a
simpliﬁed DMA workﬂow and introduce the basic concepts,
which are necessary to understand the design of DICE.

A DMA controller plays the central role in the DMA
workﬂow. It is an on-chip peripheral that transfers data into
memory on behalf of peripherals. A DMA transfer is a
single movement of data to memory. It starts with ﬁrmware
creating a transfer descriptor, specifying the transfer’s source,
destination, size, etc., and writing this transfer descriptor to the
DMA controller, a step called DMA conﬁguration. In addition,
ﬁrmware also speciﬁes which DMA stream (a physical data
channel inside the DMA controller) should be used for the
transfer. Figure 3 shows a DMA controller with three DMA
streams conﬁgured for three different DMA transfers. After
the conﬁguration ﬁnishes and the data becomes ready at
the source, the DMA controller performs the transfer asyn-
chronously without involving the ﬁrmware or the processor.
The source and destination of a transfer are also referred to
as transfer pointers.

4

Transfer Descriptor 3:SourceDestinationSizeTransfer Descriptor 2:SourceDestinationSizeTransfer Descriptor 1:SourceDestinationSizeStream 3Stream 2Stream 1Peripheral BusSystem BusBase: 0x4002 0000Base+0x08Base+0x1CBase+0x30DMA ControllerBase+0x00CommonConﬁg& StatusMCU architecture
32-bit (ARM Cortex-M, MIPS)
16-bit (PIC16)
8-bit (PIC8, AVR)

DMA support
32 (94.1%)
2 (11.1%)
7 (11.3%)

No DMA support
2 (5.9%)
16 (89.9%)
55 (88.7%)

TABLE I: DMA availability on Microhip MCUs families (March 2019)

on-chip peripherals and DMA availability (as DMA controller
is also an on-chip peripheral). Therefore, grouping MCUs into
families allow us to better analyze and describe DMA avail-
ability on those MCU families. Our analysis demonstrated that
94.1% of modern 32-bit MCU families include one or multiple
DMA controllers, or include DMA capable peripherals (e.g.,
USB, CAN, Ethernet). On the other hand, only 11% of 16-bit
and 8-bit MCU families support DMA (Table I).

B. DMA Usage by Firmware

We collected 1,000 unique repositories from GitHub by
searching keywords and topics related to microcontrollers,
IoT, and DMA. Our dataset only included repositories for
ARM Cortex-M architecture, the most popular architecture
for IoT devices and cyber-physical systems. We found most
repositories cannot be compiled because of missing build-
ing scripts (e.g., makeﬁles) or libraries, or unavailability of
proprietary IDE (Integrated Development Environments) and
toolchains. We were able to compile or directly download 350
ELF binaries from our dataset. We performed a basic static
analysis on both source code and EFL ﬁles.

Our analysis shows that 920 out of 1,000 (92%) repositories
include DMA related header ﬁles or DMA driver source code.
However, only 88 out of 350 (25.1%) ELF ﬁles contain DMA
related debug symbols. This is because DMA header ﬁles and
driver code are always distributed as part of SDKs, regardless
of ﬁrmware usage. Therefore, we cannot use the inclusion
of DMA header ﬁles or driver code as an indicator of DMA
usage. Instead, we use the appearance of DMA debug symbols
in ELF ﬁles as the indicator for DMA usage by ﬁrmware, and
estimate 25.1% (88 out of 350) ﬁrmware use DMA.

We also observed that most ﬁrmware that use DMA are
for battery-powered devices (e.g., drones, handhelds, smart
watches), or require high data communication throughput
(e.g., DSPs and LCDs). We admit that usage of DMA is
an architectural and/or design decision made by ﬁrmware
developers for the speciﬁc application.

V. SYSTEM DESIGN

DICE provides dynamic ﬁrmware analyzers the ability to
recognize and handle DMA-based input from peripherals, thus
allowing ﬁrmware using DMA to be analyzed and ﬁrmware
code dependent on DMA input to be executed and tested,
which is previously impossible. DICE meets the following
design goals that we set:

• Hardware independence: DICE should not rely on ac-
tual hardware peripherals. It should be generic to support
a wide range of architectures, peripherals, and DMA
controllers used in embedded devices.

• Firmware compatibility: DICE should be compatible
with all possible ways that ﬁrmware may use DMA as
input channels, regardless of how DMA is conﬁgured or
data is consumed.

• Dynamic DMA: DICE should fully consider the dynamic
nature of DMA and be able to capture DMA input events
through dynamically allocated memory regions.

• No source code: DICE should not require source code

or debug symbols of ﬁrmware.

• Integration with analyzers: DICE should not need
hardware or software capabilities that common ﬁrmware
analyzers do not have. Integrating DICE should not
require major changes to existing analyzers.

DICE achieves the design goals thanks to a novel approach
to the ﬁrmware. The approach
to supplying DMA input
is inspired by our observation on the generic patterns that
ﬁrmware follows when performing DMA conﬁgurations and
data transfers. These patterns are observed across different
ﬁrmware on various embedded devices using distinct DMA
controllers and peripherals. In fact, these patterns reﬂect the
de facto protocol used by embedded ﬁrmware and peripherals
when exchanging data via DMA. By detecting these patterns
and intercepting the DMA conﬁguration and data transfer
events, DICE monitors DMA input channels as they are
created, used, and disposed. As a result, DICE can capture
(and respond to) all DMA input events, which inevitably go
through the monitored interfaces.

Next, we explain the abstract notion of DMA input channels
and discuss the DMA conﬁguration and data transfer patterns
that DICE uses to identify DMA input channels.

A. DMA Input Channels

DMA input channel is an abstract notion we formulated, on
which the core idea of DICE is derived. Such channels can
be viewed as the conceptual bridges through which ﬁrmware
and peripherals exchange data via DMA. They manifest as
dynamically allocated memory buffers that ﬁrmware and pe-
ripherals agree upon for transferring data. A DMA controller
serves as the proxy for a peripheral to write data in the DMA
memory buffers without involving the main processor. The
data is then read from the memory buffer by the ﬁrmware
as input from the peripheral. Therefore, if all DMA input
channels (or their manifestations, i.e., memory buffers used as
DMA data exchanges) can be recognized upon their creation,
access, and disposal, all DMA data transfers can be monitored
and interposed, which allows DICE to supply DMA input
to the ﬁrmware execution without using actual peripheral
hardware or understanding the inner workings of peripherals
or DMA controllers. DMA output channel follows the same
deﬁnition with DMA input channel, but with the opposite
transfer direction (i.e., data is transferred to peripherals via
DMA).

Table II shows all possible combinations of sources and
destinations for DMA input and output channels. Those with
Flash as the destinations are invalid because DMA is only
meant for transferring data to memory, including RAM and

5

Source
Peripheral
Peripheral
Peripheral
RAM
RAM
RAM
Flash
Flash
Flash

Destination
RAM
Peripheral
Flash
Peripheral
RAM
Flash
RAM
Peripheral
Flash

Valid
Yes
Yes
No
Yes
Yes
No
Yes
Yes
No

Type
DMA input channel
DMA output channel
N/A
DMA output channel
DMA input channel
N/A
DMA input channel
DMA output channel
N/A

TABLE II: Possible combinations of sources and destinations for DMA input
and output channels

Fig. 4: Life-cycle of a DMA transfer

memory-mapped peripheral regions. Among the valid com-
binations, we focus on those with RAM as the destination
because they are DMA input channels that can directly inﬂu-
ence the execution and analysis of ﬁrmware. DICE does not
handle DMA output channels which do not directly inﬂuence
ﬁrmware execution. Unless otherwise noted, we refer to DMA
transfers that go through DMA input channels simply as DMA
transfers.

Each DMA transfer takes three steps. First, ﬁrmware estab-
lishes the DMA input channel by sending a transfer descriptor
to the DMA controller as part of the transfer conﬁguration
( 1(cid:13) in Fig. 4). The transfer descriptor speciﬁes, among other
things, which physical DMA stream inside the DMA controller
should be used for transferring the data, along with the source
and destination addresses as well as the transfer size. The
source address points to the to-be-transferred data stored in
peripheral registers, Flash, or RAM. The destination points to
the memory buffer where the ﬁrmware expects the input data
to be transferred. We refer to a source or destination address
as a transfer pointer. Second, when the input data becomes
available at the source, as indicated by an interrupt, the DMA
controller copies the data from the source to the destination.
Note that the actual data transfer and direct memory access

6

are performed by the DMA controller on behalf of peripherals
( 2(cid:13) in Fig. 4). Third, after ﬁnishing the data transfer, the DMA
controller signals the ﬁrmware and closes the DMA stream.
It tears down the current DMA input channel and leaves the
input data in the memory buffer for the ﬁrmware to use ( 3(cid:13)
in Fig. 4).

A transfer descriptor is valid only for one DMA transfer,
which goes through the DMA input channel identiﬁed by
the transfer descriptor. Firmware may sometimes use the
auto-reload feature of DMA controllers, whereby a transfer
descriptor is valid for multiple consecutive DMA transfers
until reconﬁgured.

The lifespan of a DMA input channel starts when DMA
controller receives the transfer descriptor and the DMA stream
is conﬁgured. It terminates when the data transfer ﬁnishes.
A channel’s exit end is attached to a dynamically allocated
memory buffer (i.e., the destination). This per-transfer and
highly dynamic nature of DMA input channels makes it
challenging to detect and monitor them. For the same reason,
previously proposed techniques for detecting DMA input using
static heuristics are inaccurate and incomplete.

B. Capturing Stream Conﬁgurations

DICE dynamically captures DMA stream conﬁguration
events to extract the information needed for identifying DMA
input channels, such as destinations and sizes. However,
stream conﬁgurations are not directly visible by ﬁrmware
emulators or analyzers due to the semantic gap—such a
conﬁguration (i.e., ﬁrmware writing a transfer descriptor to
memory-mapped registers), in the eyes of an emulator, looks
the same as a regular memory write by ﬁrmware.

We observed a fairly distinct pattern followed by DMA
stream conﬁgurations: writing some values within a spe-
ciﬁc range to a ﬁxed region in memory. This pattern
echos the essential operation performed in each stream
conﬁguration—writing the source and destination transfer
pointers to the DMA controller
registers. These periph-
eral
registers are always mapped in the MMIO region
(0x40000000–0x5fffffff). DMA transfers through DMA input
channels move data from peripheral/Flash/RAM to RAM.
Therefore, the value of source transfer pointers must be in
the range of 0x40000000–0x5fffffff (for peripheral MMIO),
0x20000000-0x20004fff (for RAM), or 0x8000000-0x801ffff
(for Flash) 1. Similarly, destination pointers must point to the
RAM region. These regions are not very big in size (2kB
to 512kB), which means the value range of transfer pointers
is not very wide. DICE uses this pattern (i.e., two writes of
pointer values to consecutive locations in the MMIO region)
to detect DMA stream conﬁgurations.

We also observed that a DMA controller can support
multiple DMA streams (Figure 3). The source and destination

1The RAM and Flash address ranges are taken from the STM32F103 MCU
as an example. Different MCU may use slightly different ranges for RAM
and Flash, which are speciﬁed in their data-sheets. When data-sheets are not
available, DICE uses the largest ranges allowed by the architecture (a 512MB
region) as the RAM/Flash region.

CPU domainOptionalMandatoryTransferConﬁgHardware TriggerSoftware TriggerDataTransferInterrupt/EventAutoStartReloadConﬁgYesFinishInvalidateConﬁgNoBufferaccessDMA CTRL domain132transfer pointers of a particular stream are recorded in two
consecutive MMIO registers in the DMA controller. The write
operations to these registers are 32-bit in width and 4-byte
aligned in address. This pattern allows DICE to identify
multiple stream conﬁgurations on the same DMA controller,
and more importantly, ﬁlter out pointer-like values that are
written to the MMIO region yet not transfer pointers (i.e., the
write operations are sparse, unaligned or in a different data
width).

Based on our tests on real ﬁrmware and devices of various
kinds (§VII-A), this pattern reliably indicates stream conﬁg-
urations and is never seen in other types of memory write
operations. It means that, empirically, ﬁrmware writes two
pointer/address values to two consecutive MMIO registers only
for the purpose of DMA stream conﬁguration.

DICE looks for the stream conﬁguration pattern while it
monitors memory writes by ﬁrmware during execution. When
one is observed, DICE captures the DMA stream conﬁguration
and extracts from it the transfer pointers. Then DICE needs
to identify the direction of the DMA transfer, because when
DICE identiﬁes two transfer pointers that point to, for exam-
ple, peripheral and RAM regions, it does not know whether
the DMA transfer is from peripheral to RAM, or the opposite.
DICE determines the transfer direction by monitoring mem-
ory accesses made by the ﬁrmware through the transfer point-
ers. If the ﬁrmware reads from the RAM address referenced
by the transfer pointer, the DMA transfer is from peripheral
to RAM (a DMA input channel that we are interested in).
If the ﬁrmware writes to the RAM address referenced by the
transfer pointer, the DMA transfer is from RAM to peripheral.
This is determination of transfer direction is intuitive. For
incoming DMA data, ﬁrmware needs to read the data after it
is transferred into RAM from a peripheral. For outgoing data,
ﬁrmware needs to write it into RAM before DMA transfers it
to a peripheral.

DICE captures a DMA stream conﬁguration transferring
the
data to RAM, and ﬁnds its destination address (i.e.,
beginning of the memory buffer for receiving the current
DMA transfer). A newly captured DMA stream conﬁguration
marks the establishment of a DMA input channel for an
upcoming DMA transfer. Its destination address locates the
memory buffer that the ﬁrmware will read the DMA input
from. DICE keeps track of all active DMA input channels
and their destination addresses.

Pattern variations: We encountered one variant of the stream
conﬁguration pattern described above, namely, multiple desti-
nation addresses are speciﬁed in one conﬁguration. This occurs
when a DMA transfer operates in the circular mode [40].
Although slightly different from normal stream conﬁgurations,
this variation still obeys the pattern that DICE uses to capture
stream conﬁgurations. It simply uses one (or more) extra
destination transfer pointer (e.g., three pointers written to three
consecutive MMIO peripheral registers).

Pattern limitation: We identiﬁed two limitations of the
pattern for capturing DMA stream conﬁguration. First, the

pattern assumes that ﬁrmware always writes transfer descrip-
tors, including the transfer pointers, to the memory-mapped
peripheral region that corresponds to DMA controller registers.
Although this is true for most ﬁrmware and MCU devices, we
are aware of some rare cases where ﬁrmware writes transfer
descriptors to RAM, rather than DMA controller registers.
This type of stream conﬁguration is used only in some high-
end SoCs, which resembles the desktop architectures. In this
case, DMA controllers fetch transfer descriptors from RAM
in ways unique to the individual DMA controllers. We did not
encounter such cases in our experiments. DICE cannot capture
the stream conﬁgurations performed this way.

Second, some DMA controller models (e.g., NRF52832
easyDMA [1]) require only the destination address, not the
source-destination pair, when ﬁrmware conﬁgures a DMA
stream (using an implicit source address). As DICE needs
to observe both the source and destination transfer pointers
in order to identify a DMA stream conﬁguration, DICE can-
not identify destination-only stream conﬁgurations. However,
based on our evaluation, only 2 DMA controller models
support this type of conﬁguration. DICE missed only 7 out
of 52 DMA stream conﬁgurations due to this limitation. We
discuss the details in §VII.

C. Responding to DMA Data Read

After DICE captures a DMA stream conﬁguration and
ﬁnds the destination address, it places an access hook on
the destination address, which allows DICE to identify and
respond to ﬁrmware’s read from the corresponding DMA
memory buffer. However, this DMA read identiﬁcation and
response process is not as straightforward as it may sound,
due to two technical challenges: the unknown buffer size, and
the dynamic termination of DMA input channels.

Unknown buffer size: Although DICE can reliably capture
every DMA stream conﬁguration and extract the destination
address, it cannot accurately ﬁnd the transfer size or the buffer
size from a captured conﬁguration event. This is because
transfer sizes may take a wide range of values, unlike destina-
tion addresses, whose values are bounded by the valid DMA
memory regions and therefore fairly distinguishable.

DICE needs to know where each DMA buffer ends in
order to determine if a memory read falls in such a buffer.
An intuitive solution is to extract buffer size from the debug
symbols generated by compiler. At DMA stream conﬁguration,
debug symbols are looked up to ﬁgure out which buffer is
allocated at the destination address and what the buffer size
is. However, debug symbols are absent in MCU ﬁrmware,
which are stripped binary blobs containing only code and
data. Moreover,
identify the size of
dynamically allocated buffers that are widely used in DMA
transfers.

this approach cannot

Instead, DICE adopts an approach supporting dynamically
created DMA buffers without using debug symbols. It dy-
namically infers the bounds of DMA buffers by observ-
ing ﬁrmware’s access. The inference leverages the fact that

7

ﬁrmware typically reads a DMA buffer consecutively in space
(from the beginning to the end, but not necessarily consecutive
in time). Although in theory ﬁrmware may not start reading
DMA buffers from the beginning, we did not observe such
a case in our experiments on real ﬁrmware. When input data
comes from a peripheral that uses a different endianness than
the MCU’s, ﬁrmware may start reading the buffer several bytes
after the beginning. DICE considers and handles such cases.
For each ﬁrmware access to a detected DMA buffer, DICE
calculates a span (i.e., the possible extent to which this DMA
buffer may extend beyond the currently known boundary).
The span size is set
to twice of the data width of the
memory read operation (LOAD). For instance, the span for
a buffer accessed via a 32-bit LOAD will have the size of 64
bits (8 bytes). Having a span for each buffer access allows
DICE to incrementally infer the buffer size and recognize
the endianness conversion that the ﬁrmware may perform. For
example, after multiple two-byte inputs are transferred from
big-endian peripherals by DMA, ﬁrmware running on a little-
endian CPU will read the DMA buffer in 1-byte data width
to convert the endianness. As byte 1 is read before byte 0,
having a span twice of the data width allows DICE to catch
this behavior. DICE monitors memory read operations while
the DMA input channel is in use. When a memory read falls in
the span, DICE expands the detected DMA buffer to include
the read address. This process is described in Algorithm 1. The
dynamic and incremental expansion of detected DMA buffers
allows DICE to identify and handle ﬁrmware’s DMA read
while continuously inferring the true buffer size, especially
for dynamically allocated DMA buffers.

Algorithm 1 DMA buffer size inference

P erceivedSize ← 0
while DMA input channel is valid do

if memory is read then

Span.Size ← 2 ∗ Read.DataW idth
Span.Base ← (Buf f er.Base + P erceivedSize)
if Read falls in Span then

P erceivedSize ← (Read.addr − Buf f er.Base) +
Read.DataW idth

end if

end if
end while

Dynamic channel terminations: DMA input channels are per
DMA transfers and not permanent. A channel is created when
the underlying DMA stream is conﬁgured and terminated
when the stream is invalidated or used for a different transfer.
DICE tracks the life cycles of DMA input channels and detects
dynamic channel terminations. This is necessary because stale
channels, if not recognized, can cause DICE and the ﬁrmware
analysis to mistakenly treat regular memory access as DMA
input events and thus corrupt ﬁrmware execution. It is worth
noting that the static technique used by the previous works for
identifying DMA buffers suffer from this issue.

DICE watches for two types of signals that indicate channel
terminations. First, if a newly captured DMA stream con-
ﬁguration references the same DMA stream as a previously
captured one did, the stream is now reconﬁgured to support

a different DMA transfer, and therefore, the previous DMA
input channel is now terminated. Second, if ﬁrmware writes
to a memory buffer that corresponds to a DMA input channel,
the channel is implicitly terminated and the buffer is no longer
used for receiving DMA input. When a channel termination is
detected, DICE removes the access hook on the buffer. As a
result, DICE no longer treats it as a DMA buffer or supplies
input to it. The previously generated input data still remains
in the buffer, which ﬁrmware may continue using.

VI. IMPLEMENTATION

We implemented two prototypes of DICE as drop-in com-
ponents on top of the P2IM framework (for ARM Cortex-M
architecture) and a PIC32 emulator (for MIPS M4K/M-Class
architecture) [36].

DICE leverages the tracing and hooking capabilities of
QEMU, which is the processor emulator used in P2IM and the
PIC32 emulator. It is worth noting that these emulators/ana-
lyzers do not provide any DMA capabilities as part of their
original design. Also, DICE does not rely on any internals
of these systems, making DICE portable to other ﬁrmware
analyzers.

Although the implementation of DICE in the two prototypes
are virtually the same, they could not be integrated under
a single implementation because these systems are based
on different and heavily modiﬁed QEMU forks. Also, each
emulator has a different set of capabilities. P2IM can run a
broader range of ﬁrmware and perform fuzz testing thanks
to its automatic modeling of processor-peripheral interfaces
and integration with AFL [45]. The PIC32 emulator can only
run a small set of ﬁrmware because it emulates a limited
number of peripherals. We consider extending P2IM to support
MIPS M4K/M-Class architecture, or port P2IM to the PIC32
emulator out of the scope of this paper.

On the PIC32 emulator, any access to non-emulated pe-
ripherals will halt
the emulator, which signiﬁcantly limits
ﬁrmware execution. To avoid halting the ﬁrmware, we created
default memory-mapped register handlers in the emulator.
These handlers do not implement any meaningful peripheral
functionalities. They treat registers as memory, i.e, they record
the value that is written to a register, and return it when
the register is read. Besides, we implemented a round-robin
strategy (inspired by P2IM design) for triggering DMA-related
interrupts and invoking the associated ISR (interrupt service
routine). This allows the ﬁrmware to read DMA buffers.

The DICE implementation on P2IM includes 1,237 lines
of C code added to QEMU. The implementation on PIC32
emulator has 1,620 lines of C code. Despite the different
target architectures (ARM and MIPS), both implementations
are fairly similar and the description below applies to both.
The heuristic to capture DMA stream conﬁgurations is im-
plemented in QEMU’s unassigned_mem_write function,
which manages MMIO operations related to the peripheral
memory area ( 1(cid:13) in Fig. 5). This function has access to traces
of the MMIO operations. These traces include information
about the operation type (read/write), value, address and data

8

Fig. 5: DICE implementation (P2IM version). 1(cid:13) Identiﬁcation of DMA transfer pointers. 2(cid:13) transfer descriptor management. 3(cid:13) Transfer size and DMA
hooks.

width (8, 16 or 32 bits) of the MMIO. The transfer descriptor
manager ( 2(cid:13) in Fig. 5) is a software component that tracks
and orchestrates the life cycles of DMA input channels.
We implemented this component and data structures in the
helper_le_ld_name function. This function is deﬁned in
the softmmu template.h ﬁle and has access to traces of any
memory read in all memory areas of MCU. We modiﬁed
QEMU to invoke this function on every LOAD instruction.
This method is described as the “slow path” for memory
access, according to QEMU’s documentation [4].

The helper_le_ld_name function allows DICE to
place memory hooks on-the-ﬂy ( 3(cid:13) in Fig. 5), according to the
captured DMA input channels and accesses of ﬁrmware to the
destination address. Also, helper_le_ld_name provides
the effective data width (8, 16 and 32-bit) of the LOAD
instruction emulated by QEMU. This information is used to
adjust the span that is used to identify the buffer size.

The DICE implementation on P2IM supports fuzzing. It
reuses the underlying AFL engine and the TriForce [18]
QEMU extensions of P2IM. DICE supports ﬁles, network
sockets, and other input methods that a ﬁrmware analyzer
requires to provide input to ﬁrmware. This architecture allows
DICE to be added as a drop-in component to other ﬁrmware
analyzers and enhance it with the automatic emulation and
manipulation of DMA input channels.

VII. EVALUATION

We evaluated DICE from three different angles: 1) whether
it can accurately identify DMA input channels on ﬁrmware
that run on different architectures, MCUs and OSes; 2) how
much its runtime overhead is; 3) whether it can support fuzz-
testing on real ﬁrmware that uses DMA, and more importantly,
ﬁnd bugs that cannot be found by existing dynamic ﬁrmware
analyzers.

To verify 1) and 2), we performed unit tests and micro-
benchmarks on sample ﬁrmware in §VII-A. As for 3), we
fuzz-tested 7 real-world ﬁrmware with DICE (integrated with
P2IM) and found 5 previously unknown bugs in §VII-B. We
also discussed our insights into DMA emulation.

All experiments were conducted on a dual-core Intel Core
i5-7260U CPU @ 2.20GHz, 8 GB of RAM, and a fresh
installation of Ubuntu 18.04 LTS. We will release all the
ﬁrmware images after the paper is published.

MCU

Architecture

ARM Cortex-M4
ARM Cortex-M0
ARM Cortex-M0
ARM Cortex-M3
ARM Cortex-M4
ARM Cortex-M3
MIPS M4K

NRF52832
NRF51822
NUC123
LPC1837
MK64F
SAM3X
PIC32MX795
PIC32MZ2048 MIPS M-class
STM32F103
STM32L152
STM32F429

ARM Cortex-M3
ARM Cortex-M3
ARM Cortex-M4

DMA cntlr.
model
a
a
b
c
d
e,f
g
g
h
h
i

Vendor

Nordic
Semiconductors
Nuvoton

NXP

Microchip/
Atmel

ST
Microelectronics

TABLE III: Architectures, MCUs, DMA controller models and vendors
covered by the 83 sample ﬁrmware. Some MCUs share the same DMA
controller model. SAM3X has two different DMA controller models. For
brevity, we use the letters (a-i) to differentiate the controller models.

A. Unit Tests on Sample Firmware

We conducted this experiment to show that DICE can accu-
rately identify DMA input channels on different architectures,
MCUs and OSes (i.e., DICE is accurate, hardware-independent
and OS-agnostic). We collected a set of 83 sample ﬁrmware
from the ofﬁcial MCU SDKs and open-source repositories.
These sample ﬁrmware are developed by MCU vendors or
open-source contributors and serve as templates for ﬁrmware
developers. The sample ﬁrmware are suitable for our micro-
benchmarking because each implements a self-contained logic
and they collectively cover: 1) different architectures, ven-
dors, MCUs, and DMA controllers, 2) different OSes/system
libraries, 3) different combinations of DMA sources and
destinations.

Experiment Setup: As shown in Table III, the 83 sample
ﬁrmware cover 2 architectures, 11 different MCUs from 5
major vendors, and 9 unique DMA controller models.

The sample ﬁrmware are based on the real-time OSes
(RTOS) or system libraries chosen by the vendors (SDKs), in-
cluding BSD, Arduino, Mynewt, NuttX, Riot OS and ChibiOS
(Table IV). This set of ﬁrmware include not only those that
use all types of DMA input channels, but also those that do
not use DMA (non-DMA-enabled ﬁrmware). The non-DMA-
enabled ﬁrmware include the whole unit test suite used in [10]
and 2 ports of BSD for MCUs. Including both DMA-enabled
and non-DMA-enabled ﬁrmware allows us to comprehensively
evaluate DICE, in terms of its accuracy and compatibility.

9

Tranfer descriptormanagerMMIO tracesRAM access tracesTransferPointersDMA inputchannelsQEMUMCU memory mapMCURAMAFL fuzzer,ﬁles, socketsP2IM /EmulatedperipheralsCrashReportRAMHooking123Firmware
ADC PDC *

MCU
SAM3x

OS/SDK
Arduino

ARM Cortex-M0/M3/M4 DMA-Enabled Firmware

SPI DMAC Slave *
USART DMAC
ADC slider
I2C accelerometer
SPI
UART
ADC slider
SPI
UART
ADC SW DMA *
ADC Timer DMA *
I2C DMA IT
I2C DMA Adv IT
I2C TxRx DMA *
SPI Half DMA *
SPI Half DMA Init
SPI Full DMA *
USART TxRx DMA *
USART Full DMA *
UART H.Term. DMA
UART 2Boards DMA
SPI Full EX. DMA *
I2C 2Boards DMA
PDMA M-M

Serial console

SPI slave
SPI master
SPI slave
Serial DMA
PDMA USART
PDMA M-M

Source Code
http://nicecircuits.com/playing-with-analog-to-digital-converte
r-on-arduino-due/
https://asf.microchip.com/docs/latest/sam.drivers.spi.
spi dmac slave example.sam3x ek/html/index.html

SAM3x

Atmel ASF

STM32F103
STM32F103
STM32F103
STM32F103
STM32F429
STM32L152
STM32L152

ChibiOS

https://osdn.net/projects/chibios/downloads/70739/
ChibiOS 19.1.0.7z/

STM32F103

STM32CubeF1

https://www.st.com/en/embedded-software/stm32c
ubef1.html

LPC1837

LPC Open

https://www.nxp.com/downloads/en/software/lpcopen 3 02 l
pcxpresso mcb1857.zip

NRF52832
NRF51822
NRF51822
NRF52832
NRF52832
NRF52832

NUC123

Mynewt

https://mynewt.apache.org/download/

Nordic SDK

https://www.nordicsemi.com/Software-and-tools/So
ftware/nRF5-SDK/Download

OpenNuvoton

https://github.com/OpenNuvoton/NUC123BSP.git

ARM Cortex-M3/M4 Non-DMA-Enabled Firmware

Firmware
P2IM unit test suite
(44 ﬁrmware images)
[10]

MCU
STM32F103
SAM3x
MK64F

OS/SDK

Source Code

Arduino, Riot
OS, NuttX

https://github.com/RiS3-Lab/p2im-unit tests

MIPS M4K/M-class DMA-Enabled Firmware

Firmware
PIC32MX UART
PIC32MX test
PIC32MZ UART
PIC32MZ ef curiosity

MCU
PIC32MX795
PIC32MX795
PIC32MZ2048
PIC32MZ2048

OS/SDK

Microchip
Harmony v3

Source Code
https://microchipdeveloper.com/harmony3:
pic32mx470-getting-started-training-module
https://microchipdeveloper.com/harmony3:
pic32mzef-getting-started-training-module

Firmware
PIC32MX RetroBSD
PIC32MZ-BSD-Lite

MCU
PIC32MX795
PIC32MZ2048

OS/SDK
RetroBSD
LiteBSD

Source Code
http://retrobsd.org/wiki/doku.php/start
https://github.com/sergev/LiteBSD/wiki

MIPS M4K/M-class Non-DMA-Enabled Firmware

TABLE IV: Sample ﬁrmware tested in unit tests. Firmware marked with * were also used in performance tests.

All

the sample ﬁrmware include the essential routines
for running on real devices, such as OS initialization and
peripheral (including DMA controller) conﬁguration and oper-
ation. As shown in Figure 6, each ﬁrmware accesses multiple
peripherals (ranging from 4 to 18) and registers (ranging from
9 to 132). Each ﬁrmware conﬁgures up to 4 DMA streams
simultaneously.

We run each unmodiﬁed ﬁrmware binary with the DICE
prototypes supporting ARM and MIPS architectures and col-
lected debug output from QEMU for evaluating DICE’s true
positive rates and false positive rates when detecting DMA
input channels. In this experiment, we ﬁll the detected DMA
buffers (as determined by the transfer pointers and transfer

sizes) with zeros, instead of meaningful or fuzzer-generated
data. This is to make our experiment precise and reproducible.
The result shows that DICE can accurately identify DMA
input channels on different architectures, MCU models and
OSes. In other words, DICE is accurate, hardware-independent
and OS-agnostic.

True positive and false negative analysis: To establish the
ground truth, we looked up the DMA conﬁguration infor-
mation in the MCU data-sheets and veriﬁed it using the
instrumented emulators. There were 52 ﬁrmware-executed
(emulator-observed) DMA stream conﬁgurations in all
the
ﬁrmware. We use these as the ground truth for evaluating

10

Firmware
ADC PDC
ADC SW DMA
ADC Timer DMA
I2C TxRx DMA
SPI DMAC Slave
SPI Full DMA
SPI Full EX. DMA
SPI Half DMA
USART TxRx DMA
USART Full DMA

P2IM [s]
89.0
5.3
5.3
2.8
17.3
28.2
13.6
18.1
5.4
20.7

DICE [s]
94.1
5.3
5.4
2.8
17.7
28.9
15.1
18.7
5.5
21.6

Diff[%]
5.7
0.0
1.9
0.0
2.3
2.5
11.0
3.3
1.9
4.3

TABLE VI: Time needed for ﬁrmware execution to reach a ﬁxed point when
running on original P2IM (Col. 2) and DICE integrated on top of P2IM (Col.
3). This shows the overhead that DICE adds to P2IM.

Table V, among all the ﬁrmware tested, the emulators observed
35 pointer-like values written to the MMIO region that do
not conﬁgure DMA. DICE did not consider any of them as
transfer pointers, thus achieving a 0% false positive rate. This
is because, for the heuristics to consider a value written to
the value not only needs to be
MMIO as a transfer pointer,
in the narrow RAM range (i.e., pointer-like) but also needs
to be accompanied by another transfer pointer written to the
adjacent MMIO location. As an example, the TIMER1 counter
register of the PIC32MZ2048EF MCU is initialized with the
value 255 via an MMIO write operation. This value on the
MIPS M-class architecture is a valid RAM address (a pointer),
which is allocated to a global variable. DICE observed this
value, recognized it as a pointer to RAM. However, since
no other pointer was observed to be written to the adjacent
MMIO, DICE never considered this MMIO write as part of a
DMA conﬁguration. Among the 35 pointer-like values written
to MMIO, 6 were dereferenced/accessed by ﬁrmware. Since
they were not transfer pointers, DICE did not intercept the
memory accesses or infer the buffer sizes.

Hypothetically, if ﬁrmware reads from a memory address
that was falsely identiﬁed as a DMA channel, DICE may pro-
vide the ﬁrmware with analyzer-provided input (e.g., fuzzer-
generated data). This may in turn corrupt ﬁrmware execution.
However, in our experiments, no false positive occurred thanks
to the simple yet accurate heuristics.

Runtime overhead: The runtime overhead of DICE is fairly
low. It adds only 3.4% on average to the execution time
of the sample ﬁrmware. The main source of overhead is
the instrumentation required to identify the DMA transfer
size. This instrumentation affects every LOAD instruction. A
secondary source of overhead is the instrumentation capturing
the stream conﬁgurations. It only affects write operations on
the peripheral MMIO area in memory. Therefore, the overhead
of DICE is determined by the number of LOAD instructions
executed,
the number of streams conﬁgured, and the size
(number of bytes) of the buffers. Table VI illustrates the
overhead on 10 ﬁrmware selected from the entire set. These
ﬁrmware were selected because they run smoothly on P2IM
and execute all the code paths related to DMA.

Fig. 6: Distributions of numbers of peripherals, MMIO registers and DMA
stream conﬁgurations used in sample ﬁrmware (outliers marked by ◦).
All ﬁrmware access multiple and different peripherals, which shows their
complexity and diversity.

True DMA stream conﬁgurations

- DMA input channels
- DMA output channels

Buffer accessed (size inferred)

Observed by emulator
(ground truth)

52
37
15
22
Observed by emulator
(ground truth)

False DMA stream conﬁgurations
Buffer accessed (size inferred)

35
6

TP
DICE
45 (87%)
33 (89%)
12 (80%)
21 (95%)
FP
DICE
0 (0%)
0 (0%)

TABLE V: Accuracy of DMA stream conﬁguration detection: true positives
(upper table) and false positives (lower table). False DMA stream conﬁgura-
tions are pointer-like values written to MMIO that do not conﬁgure DMA.

true positives and false negatives. As shown in the upper
half of Table V, DICE correctly detected 45 out of 52 DMA
stream conﬁgurations. Among those detected, 33 are DMA
input channels and 12 are DMA output channels (the latter is
irrelevant to ﬁrmware analysis and thus their buffer access/size
is omitted). DICE missed 7 DMA stream conﬁgurations (false
negatives, 4 input and 3 output DMA channels) due to the pat-
tern limitation discussed in §V-B. There were 22 DMA buffers
accessed by the ﬁrmware during our tests. DICE detected
21 of them and correctly inferred their sizes. The undetected
buffer corresponds to one of the seven conﬁgurations missed
by DICE.

It is worth noting that ﬁrmware execution on the emulators
never accessed the DMA buffers created by 12 DMA stream
conﬁgurations correctly identiﬁed by DICE. This is due to the
limitation of P2IM and the PIC32 emulator. These emulators
neither prioritize nor recognize DMA-related code paths in
ﬁrmware. Without DMA buffers being accessed, DICE cannot
identify DMA transfer sizes. We further veriﬁed that, in all
the cases where the emulators executed the corresponding
DMA access code path, DICE successfully identiﬁed the DMA
transfer size.

False positive analysis: We instrumented the emulators to ﬁnd
pointer-like values written to MMIO during ﬁrmware execu-
tion. We then used the MCU data-sheets to select those that are
unrelated to DMA conﬁgurations. We refer to them as “false
DMA stream conﬁgurations” and use them as the ground truth
for evaluating false positives. As shown in the lower half of

11

4681012141618Peripherals20406080100120MMIO Registers01234DMA StreamsB. Fuzz-testing Real Firmware

In this experiment, we demonstrate that DICE can ef-
fectively support dynamic analysis on real-world ﬁrmware
that uses DMA. To this end, we fuzz-tested 7 real-world
ﬁrmware using DICE integrated with P2IM. DICE accurately
identiﬁed DMA input channels on all 7 ﬁrmware and found 5
previously unknown bugs (none of them were found by P2IM
alone). DICE supported fuzzing sessions for all ﬁrmware,
whereas P2IM alone failed to bootstrap a fuzzing session for
1 ﬁrmware. DICE also achieved a much higher code coverage
than P2IM, echoing the importance of DMA emulation and
support during dynamic analysis.

Experiment Setup: We selected 7 real-world ﬁrmware from
different sectors, ranging from industrial IoT to consumer
devices. These ﬁrmware represent diverse use cases of DMA,
such as data signal acquisition without CPU intervention and
high throughput data exchange. All these ﬁrmware contain
OS/system libraries (including scheduler, driver, interrupt ser-
vice routine) and application logic. As shown in Table VII,
they are based on various MCU models and multiple OSes
(i.e., FreeRTOS, Mbed OS, bare-metal). We brieﬂy describe
below the ﬁrmware functionality and security consequences of
its bugs:

Modbus: Modbus is a master-slave communication proto-
col that is widely used in commercial PLC (Programmable
Logic Controller) devices. This ﬁrmware is a highly-optimized
implementation of Modbus slave that uses DMA to receive
commands from Modbus master. As PLC devices normally
control critical industrial processes, bugs in this type of system
can lead to Stuxnet-like [43] attacks and cause physical
damage.

Guitar Pedal: This ﬁrmware includes the digital signal
processing (DSP) routines for creating musical effects in an
electric guitar. It also includes a graphical user interface (GUI)
for conﬁguring the effects. This ﬁrmware is a typical example
of mixed-signal (digital and analog) application, which uses
DMA to continuously sample analog channels at a ﬁxed rate.
Vulnerabilities in this ﬁrmware can crash the ﬁrmware or
produce unexpected sound effects that are harmful to human
hearing.

Soldering Station: This is a customized ﬁrmware for the
KSGER mini soldering station. It includes a PID (Propor-
tional–Integral–Derivative) temperature control routine and a
graphical user interface for conﬁguring and operating the de-
vice. The ﬁrmware uses DMA to read multiple ADC channels
continuously in circular mode. Vulnerabilities in this ﬁrmware
can destroy the heating element and cause injuries to operators.
Stepper Motor: This is the ﬁrmware for the stepper motor
controller in a CNC (Computer Numerical Control) machine.
CNC machines are widely used in 3D printers, drills, lathes,
etc. The ﬁrmware implements a stepper motor control routine,
a command parser, and a proprietary communication protocol.
It uses DMA to achieve high communication throughput and
control speed. Vulnerabilities in these devices can be exploited

to modify the motor speed or bypass the safety checks in the
CNC machine.

GPS Receiver: This ﬁrmware implements the GPS re-
ceiver communication protocol deﬁned by the National Marine
Electronics Association (NMEA) [13]. This ﬁrmware uses
DMA for serial communication. We discuss this ﬁrmware
as an example in §II. Vulnerabilities in this ﬁrmware can
be exploited to manipulate navigation, and in turn, control
autonomous or human-operated vehicles.

MIDI Synthesizer: This ﬁrmware implements the MIDI
protocol and controls the synthesizer operation. It processes
stereo audio inputs through the WM8778 audio codec and
digital signal processing routines, and outputs audio to external
ampliﬁers. It uses DMA to receive and parse MIDI messages
with low latency and overhead. Vulnerabilities in this ﬁrmware
can crash the ﬁrmware and produce output signals that can
overcharge the ampliﬁers and damage the electronic circuit of
the instrument.

Oscilloscope: This is a minimal oscilloscope that includes
a touchscreen as the user interface and supports PC commu-
nication for data acquisition. This ﬁrmware uses DMA for
continuous and fast sampling of electrical signals through
ADC. Vulnerabilities in this ﬁrmware can crash the system,
corrupt the data acquired and present false information to the
user.

We use unmodiﬁed AFL [45] as our fuzzer (i.e., generating
DMA and other ﬁrmware input) and fuzz-tested all ﬁrmware
using DICE on P2IM. We launched the fuzzer with random
seed input and fuzz-tested each ﬁrmware for 48 hours. As
pointed out by [30], memory corruption errors are less likely
to crash the MCU ﬁrmware than computer programs, which
causes fuzzer to miss some bugs after triggering them. To
mitigate this problem, we used the same simple memory error
detector (or sanitizer) described in [10]. It grants read+execute
permission to Flash, read+write permission to RAM and the
peripheral MMIO region, and no permission to the rest of
memory space. This simple detector allows for detection
of access violations that cross region boundaries, but not
those within a memory region. Besides, we implemented a
more ﬁne-grained error detector for buffer over/under-ﬂow
detection. We inserted red-zones before and after buffers at
compile time. Accesses to red-zones will crash the ﬁrmware
execution. Although red-zones make bugs more visible, they
are not required to launch fuzzing. In other words, ﬁrmware
binary can be fuzz-tested “as is” without re-compilation. We
note that an advanced memory sanitizer may help detect more
bugs in our experiment, but designing such a sanitizer is out
of the scope of this paper.

Fuzzing Statistics: For all tested ﬁrmware, DICE was able
to automatically and completely identify DMA input channels
(transfer pointer + transfer size), and feed fuzzer-generated
to DMA buffers through RAM hooks. We did not
input
observe any falsely identiﬁed DMA input channels (i.e., no
false positives). On the other hand, P2IM alone was able to
fuzz test only 6 out of 7 ﬁrmware. It failed to fuzz test MIDI

12

Firmware
Modbus
Guitar Pedal
Soldering Station
Stepper Motor

OS
MCU
STM32F303
FreeRTOS
STM32F303 Mbed OS
Baremetal
STM32F103
Baremetal
STM32F466

Size
1.3MB
2.4MB
1.4MB
1.4MB

GPS Receiver

STM32F103

Baremetal

798KB

MIDI Synthesizer
Oscilloscope

STM32F429
STM32F103

Baremetal
Arduino

0.7MB
0.7MB

Source
https://github.com/DoHelloWorld/stm32f3 Modbus Slave UART-DMA-FreeRTOS
https://github.com/Guitarman9119/Nucleo Guitar Effects Pedal
https://github.com/PTDreamer/stm32 soldering iron controller
https://github.com/omuzychko/StepperHub
https://github.com/MaJerle/GPS NMEA parser,
https://github.com/MaJerle/STM32 USART DMA
https://github.com/mondaugen/stm32-codec-midi-mmdsp-test
https://github.com/pingumacpenguin/STM32-O-Scope

TABLE VII: Real-world Firmware fuzz-tested with P2IM and DICE

Synthesizer ﬁrmware because the ﬁrmware only consumes
inputs through DMA input channels that are not supported
by P2IM.

As shown in Table VIII, DICE outperforms P2IM on 5 out
of 7 ﬁrmware in terms of fuzzing coverage. DICE improves
the basic block coverage by up to 30.4%, and increase the
number of paths triggering new execution patterns by up to
79 times.

The improvement in path coverage is much more signiﬁcant
than basic block coverage, for two reasons. First, a larger
number of basic blocks in ﬁrmware are executed during the
booting process, when MCU hardware and OS are initialized.
As no DMA operation is involved during booting, these basic
blocks are reachable even without DMA support, which allows
P2IM to achieve a fairly high basic block coverage. Second,
ﬁrmware code is highly reused on MCUs due to constrained
device storage. For example, the USART peripheral on the
Modbus ﬁrmware is used by the console to print messages
and by the Modbus protocol to reply to Modbus masters. The
USART driver functions are invoked by the console, which
operates without using DMA, and the Modbus protocol, which
operates through DMA. Supporting DMA does not signiﬁ-
cantly increase basic block coverage for these driver functions
as most of them are also used by non-DMA operations
(i.e., console printing). However, without DMA emulation or
support, code paths that depend on DMA input (i.e., Modbus
protocol stack) can never be reached or tested, despite that
these paths may share many basic blocks with other paths
unrelated to DMA operations or input.

As evidenced by the result, many ﬁrmware contain a great
number of DMA-related paths (hence the drastic increase in
path coverage under DICE). Such paths cannot be explored
by analyzers without using DICE.

Also signiﬁcantly, DICE improves the Max Depth by up to
500% (on Stepper Motor). This improvement indicates that,
with DICE (or generic DMA emulation), dynamic analyzers
can now dig much deeper into ﬁrmware code, unveiling states
and bugs residing at far ends of executions. This result also
indicates that, with the ability to directly feed input to DMA
buffers, even off-the-shelf fuzzers like AFL (without DMA
awareness) can be used for fuzzing ﬁrmware relying on DMA
input channels.

In terms of fuzzing speed, DICE is slower on 3 out of 7
ﬁrmware than P2IM, with 18% as the worst-case slowdown
(observed on Stepper Motor). The slower fuzzing speed is not
only caused by the overhead of DMA support (discussed in

§VII-A), but also the fact that more basic blocks and paths
are executed on each fuzzer run thanks to the added DMA
support.

As 2 rare cases, fuzzing Soldering Station and Oscilloscope
ﬁrmware with DMA support turned out to be faster, 5.6%
and 92.1% respectively, with slightly lower code coverage.
We found that in these cases DMA input channels through
ADC allows rapid consumption of input data, which caused
the ﬁrmware execution to ﬁnish much earlier than without
DMA support.

Detected New Bugs and Case Study: DICE found 5 unique,
previously unknown bugs that P2IM alone (i.e. without DMA
emulation) cannot detect (Table IX). We manually examined
these bugs (3 in Modbus and 2 in MIDI Synthesizer) and
conﬁrmed that it is the DMA support that makes DICE out-
performs existing dynamic analysis frameworks, such as P2IM.
More speciﬁcally, Modbus and the MIDI Synthesizer ﬁrmware
receive commands from the USART peripheral through DMA.
Without DMA support, no command can be received by
the ﬁrmware. As a result, the command parsing logic and
application logic, where all 5 bugs were found, can never be
executed.

We veriﬁed that all the bugs are real and reproducible on
real devices with the same fuzzer-generated input. All the
bugs detailed in Table IX are remotely exploitable. They are
triggered by the commands that the ﬁrmware receives through
the USART peripheral via a DMA input channel.

The bugs found in the MIDI Synthesizer ﬁrmware (ID 4
and 5) are caused by freeing memory not on the heap. The
ﬁrmware stores the MIDI messages received through DMA
input channels in the buffers that are either statically allocated
(as global variables) or dynamically allocated on the heap.
When the buffers are allocated on the heap, the ﬁrmware
invokes free() function to deallocate them after the MIDI
messages is processed. In these bugs, the ﬁrmware uses global
buffers, but still invokes the free() function which is supposed
to free only buffers allocated on heap. This causes that memory
not on the heap is freed, which may lead to ﬁrmware crash and
denial-of-service. These bugs cannot be found by P2IM alone
because the free() function is only invoked when the MIDI
messages received from DMA input channels are processed.
For the Modbus ﬁrmware, DICE identiﬁed 2 buffer over-
write and 1 buffer overread bugs. The root cause is improper
validations of array indexes. Speciﬁcally, the ﬁrmware uses un-
trusted input for calculating array indexes, but fails to validate

13

Framework
BBL Cov. [%]
Total Paths
Max Depth
Speed [run/s]

Modbus
P2IM DICE ∆%
52.6 58.7 11.6
1276 7875
16
300
8
2
41.6 41.0 -1.4

Guitar Pedal
P2IM DICE ∆%
16.9 17.0 0.6
3267 3773 15.5
4
3.8

5
3.8

25
0

Soldering St.
P2IM DICE ∆%
31
31
166
172
3
3
17.9 18.9 5.6

0
-3.5
0

Stepper Motor
P2IM DICE ∆%
22.3 25.6 14.8
4595 5276 14.8
500
12
2
22.2 18.2 -18.0

GPS Receiver
P2IM DICE ∆%
11.5 15.0 30.4
1988 6527
30
6
5
49.4 48.9 -1.0

20

MIDI Synth.
P2IM DICE ∆%
40.8 N/A
0.0
588 N/A
0
N/A
3
0
59.9 N/A
0

Oscilloscope
P2IM DICE ∆%
27.3 27.3 0.0
-4.5
590
618
-20
4
5
0.76 1.46 92.1

TABLE VIII: Statistics of fuzz-testing real ﬁrmware using DICE on P2IM. P2IM was unable to fuzz test MIDI Synthesizer ﬁrmware which solely consumes
input through DMA input channels.

Firmware Bug ID

Bug type

Modbus

MIDI
Synthesizer

1, 2

3

4, 5

Buffer overwrite

Buffer overread
Free of memory
not on the Heap

Security consequences
Corrupt data structure with
attacker controlled values.
Information leakage.
Firmware crash,
denial-of-service.

TABLE IX: New bugs found by DICE in Modbus and MIDI Synthesizer
ﬁrmware. None of them can be found by P2IM alone.

the computed indexes or ensure the indexes are referencing
valid positions within the arrays. Modbus receives commands
from a shared ﬁeldbus in a typical PLC device setup. There-
fore, any malicious/compromised device connected to the
ﬁeldbus can exploit these bugs by sending crafted commands.
These bugs allow an attacker to corrupt data structures or
retrieve secrets stored in the ﬁrmware memory, e.g. critical
parameters of the PLC control routine.

Listing 1 shows the code snippet of Bug #1. startAddr is
calculated from modbusRxTxBuffer[], which is the DMA
buffer that holds untrusted input (Line 265). The ﬁrmware
checks if startAddr is within the valid range of array
modbusMemory[] (Line 266), and then uses it as an index
for array access (Line 270). The input validation at Line
266 is wrong (the correct check should be startAddr >=
MODBUS_SLAVE_REGISTERS_NUM), which causes buffer
overwrite at Line 270.
265 uint16_t startAddr = modbusRxTxBuffer[2] << 8 |

modbusRxTxBuffer[3];

266 if(startAddr > MODBUS_SLAVE_REGISTERS_NUM) //

improper input validation

answerLen = modbusSlaveErrorSet(0x02);

267
268 else
269 {
270

modbusMemory[startAddr] = modbusRxTxBuffer[4] << 8

| modbusRxTxBuffer[5]; // buffer overwrite

answerLen = modbusRxCount;

271
272 }

Listing 1: Code snippet of Bug #1

We also investigated the potential reasons for our experi-
ment not ﬁnding bugs in the other ﬁve ﬁrmware. In general,
fuzz-testing ﬁrmware with DICE on P2IM faces the open
challenges as with other existing tools, such as the lack of error
detectors/sanitizers for MCU, limited ability to solve complex
state machines and path constraints, etc., which are out of the
scope for this paper. We also identiﬁed the following reasons
speciﬁc to DMA.

First, some ﬁrmware using DMA can quickly drain fuzzer
input, without going deep into the code. Such ﬁrmware tends
to allocate large DMA buffers for high-throughput data trans-
fers. For example, Stepper Motor uses 2 buffers of 4 KB

14

for receiving and transmitting data. However, AFL prefers
to generate short input sequences to achieve better fuzzing
performance.

Second, some DMA input channels do not directly inﬂuence
ﬁrmware control ﬂow, but DICE still treats them as “risky”
channels and lets the fuzzer generate and mutate inputs
for them. For example, Soldering Station, Guitar Pedal and
Oscilloscope continuously sample analog input using DMA
and performs mathematical calculations on the sampled inputs.
These DMA inputs can rarely change ﬁrmware execution paths
or trigger bugs. However, due to the design requirement of
being peripheral-agnostic, DICE cannot detect or exclude such
fuzzing-unworthy DMA input channels, and thus, ends up
spending too much time on them, instead of focusing on other
fuzzing-worthy DMA input channels.

VIII. DISCUSSION

A. Location of transfer descriptor

DICE identiﬁes the DMA input channels based on the
transfer descriptors are always written to
assumption that
DMA controller through MMIO operations. However, in some
rare cases, transfer descriptors are stored in RAM, which are
not supported by DICE. We admit it a limitation of DICE.
To measure how prevalent the transfer descriptors are stored
in RAM, we surveyed the complete STM32 MCU portfolio
of ST Microelectronics, a top-ﬁve MCU vendor according to
[19] and the most popular MCU vendor in terms of the number
of Github repositories (19,870 unique entries by Nov. 2019).
The product lines we analyzed include ultra-low-power, main-
stream, and high-performance families. Our analysis showed
that all MCUs (983 in total) store transfer descriptors in the
peripheral memory area, while the STM32H7 product line
(59 MCUs) also allows storing transfer descriptors in RAM.
To conclude, only 6% of STM32 MCUs can optionally store
transfer descriptors in RAM, and therefore, it is acceptable for
DICE not to handle this rare case.

B. DMA Buffer Size Identiﬁcation

Unlike source and destination, buffer size cannot be reliably
identiﬁed from a DMA stream conﬁguration event. To solve
this, DICE adopts a conservative heuristic for buffer size
identiﬁcation. The heuristic, which gradually expands the
perceived DMA buffers at memory read that falls right after
the buffer boundary, may produce a smaller-than-actual size
upon memory reads that are not consecutive in space. This
inaccuracy, although possible in theory, is not observed in our
evaluation. Moreover, when the ﬁrmware executes for long
enough, DICE may progressively identify the correct buffer

size. Therefore, it is reasonable to use such a conservative
heuristic which trades identiﬁcation accuracy for the ﬁrmware
stability (when a wrongly identiﬁed DMA buffer byte is read,
the ﬁrmware can crash).

C. Architecture beyond ARM and MIPS

DICE can be applied to other architectures that meet three
requirements: (R1) the architecture uses designated memory
regions for peripherals (MMIO), Flash and RAM; (R2) DMA
streams conﬁgurations are written to the peripheral region via
MMIO; (R3) DMA transfers follow the life cycle depicted in
Figure 4.

We analyzed RISC-V, the increasingly popular architec-
ture used in MCUs. We conﬁrmed that RISC-V meets
these requirements, and therefore, is compatible with DICE.
Speciﬁcally, we studied the data-sheets of
the RISC-V
GD32VF103 MCU [35]. The MCU uses separate mem-
ory regions for peripherals, RAM and Flash (0x40000000-
0x5003FFFF, 0x20000000-0x20017FFF, and 0x08000000-
0x0801FFFF respectively), thus meeting R1. It also writes
DMA streams conﬁgurations via MMIO to peripherals and
meet R2. The MCU obeys the DMA life cycle illustrated in
Figure 4 and meet R3. This result demonstrates that DICE is
generically applicable to at least three different architectures,
namely ARM, MIPS, and RISC-V.

D. Devices beyond MCUs

DICE is designed to support DMA in ﬁrmware analysis for
MCU devices. It solves multiple challenges, especially, the
hardware and software diversity of MCUs. Other platforms
such as desktop and mobile devices use similar DMA transfer
descriptors and follow the same DMA life cycle as MCUs.
However,
those more powerful platforms frequently store
transfer descriptors in RAM, rather than in DMA controller
registers (MMIO), for ﬂexibility reasons (e.g.,
to support
complex concatenated DMA transfers). As we discussed in
§V, RAM-stored transfer descriptors are not supported by
DICE. Therefore, DICE cannot be directly used for emulating
DMA on platforms other than MCUs.

Existing work such as PeriScope [39] can handle DMA
on Linux-based platforms during dynamic analysis. PeriScope
instruments Linux kernel DMA APIs to monitor the creation
and destroy of DMA input channels and to manipulate DMA
input. PeriScope is OS-speciﬁc. Unlike DICE, PeriScope is
not applicable to MCUs, which have highly diverse OS and
ﬁrmware, and therefore, pose unique challenges for DMA
emulation.

E. Integration with Other Firmware Analyzers

The design of DICE allows for easy integration with various
ﬁrmware analyzers, providing them with the capability of
analyzing ﬁrmware that use DMA. As a demonstration, we in-
tegrated DICE with Avatar2 [29], a ﬂexible dynamic ﬁrmware
analysis framework. The implementation is only 240 lines of
Python code. This integration allows Avatar2 to recognize and

manipulate DMA data when it was read by the ﬁrmware, and
in turn, to analyze ﬁrmware that uses DMA for input.

Furthermore, we integrate DICE with Symbion [14] (an
extension to the Angr [38] framework). This integration allows
DMA-aware concolic execution on MCU ﬁrmware. Speciﬁ-
cally, we used DICE and Avatar2 to identify the DMA buffers
used by a ﬁrmware as the ﬁrmware runs on a real development
board. Upon reaching an interesting point of analysis, Symbion
moves the concrete state of this execution to Angr. Thanks
to DICE, Angr can now recognize and symbolize the DMA
buffers in the concrete state, achieving a more precise and
comprehensive concolic execution.

F. Peripherals beyond DMA controller

Many merits of DICE, such as hardware-independent and
ﬁrmware compatibility, are attributed to our abstraction of the
DMA input channel. We believe that for other peripherals (e.g.,
counters and comparators), which have well-deﬁned function-
alities and identiﬁable conﬁgurations like DMA controllers do,
can be abstracted in a similar way. We admit that identifying
if and how a peripheral can be abstracted for dynamic analysis
purposes, in a hardware-independent and ﬁrmware-compatible
way, is an interesting research topic that we would like to
pursue in the future.

IX. RELATED WORK

A. Dynamic Firmware Analysis

Multiple existing works tackled the challenging problem of
dynamic ﬁrmware analysis. They are divided into hardware-in-
the-loop emulation approaches and full emulation approaches
by whether real devices are required in the process of dynamic
analysis. Avatar [44] proposed a novel hardware-in-the-loop
emulation mechanism, which forwards peripheral operations
to a real device while executing the ﬁrmware in the emulator.
It conducted concolic execution for MCU ﬁrmware. Surro-
gates [22] improved the performance of peripheral operation
forwarding by customized hardware. [30] fuzz-tested simple
programs with artiﬁcially-implanted bugs using Avatar, which
demonstrated that memory corruption vulnerabilities are much
less likely to crash on MCU than on desktop. Avatar2 [29]
extended Avatar with the record and replay capability for
the forwarded peripheral operations. Charm [42] fuzz-tested
Android device drivers by a hardware-in-the-loop emulator
that uses a similar forwarding technique with Avatar. Prospect
[21] forwarded peripheral operations made through syscalls,
the abstraction of which is not available for MCU devices.
[20] combined runtime program state approximation with
peripheral access caching to facilitate dynamic analysis.
Hardware-in-the-loop emulation approaches suffer

from
poor performance and scalability due to the slow forwarding
speed and one-to-one binding between emulator instances and
real devices. Several recent works addressed this by removing
the need for real devices through full emulation. Pretender [15]
generated approximated peripheral models from the peripheral
operations that are forwarded to the real device by Avatar

15

[44]. With the model, it successfully executed and fuzzed-
tested several simple ﬁrmware with manually-injected vulner-
abilities without using any real device. P2IM [10] completely
removed the usage of real devices by automatically model-
ing the processor-peripheral interfaces while emulating the
ﬁrmware. It fuzz-tested several real-world ﬁrmware of typical
embedded applications and found real bugs. HALucinator [2]
adopts a high-level emulation-based approach which replaces
Hardware Abstraction Layer (HAL) functions with manually-
crafted handlers by library matching on binary. It fuzz-tested
network stack, ﬁle system, serial port and PLC, and found
real bugs. PartEmu [17] fuzz-tested ARM TrustZone software
stack by a hybrid approach of replacing software components
with stubs and modeling peripheral hardware with manually
crafted register value patterns. Various works dynamically
analyzed Linux-based ﬁrmware by full emulation [6], [8],
[34]. Those ﬁrmware are more similar to general-purpose
desktop software than truly embedded ﬁrmware. Emulators
have much better support for Linux-based ﬁrmware, which
uses less diverse peripherals than MCU ﬁrmware. However,
none of these works, either hardware-in-the-loop emulation
or full emulation, were able to dynamically analyze MCU
ﬁrmware using DMA without requiring any source code. The
major obstacle is the un-emulated DMA controllers, which
are vendor-speciﬁc and possibly proprietary. Our work can
extend both hardware-in-the-loop (Avatar) and full emulation
(P2IM [10]) mechanism with DMA support and conduct dy-
namic analysis. Although HALucinator [2] can analyze DMA-
enabled ﬁrmware (because its high-level emulation totally
removes DMA operations), their approach (speciﬁcally, the
library matching component) requires source code of HAL.
Neither can HALucinator ﬁnd bugs in ﬁrmware components
that are replaced by the high-level emulation, such as drivers
for DMA controller and other peripherals. DICE adopts a
completely different approach which identiﬁes DMA input
channels from unmodiﬁed ﬁrmware. Therefore, DICE is able
to ﬁnd bugs in the whole ﬁrmware stack, without requiring
any source code or manually created handlers.

B. DMA Attacks & Analyses

Various works revealed attacks enabled by DMA. To name
a few, PCILeech [11] revealed that malicious peripherals with
DMA capability (e.g., PCIe peripherals) can access/modify
arbitrary physical memory addresses and gain full control
over the victim computer if IOMMU is not enabled (IOMMU
enables virtual memory for I/O devices). Thunderclap [23]
further demonstrated that DMA attacks are still feasible even
with IOMMU enforced. These attacks, however, are not feasi-
ble on MCUs because MCU peripherals normally do not have
DMA capability, and DMA is conducted through a dedicated
DMA controller which is part of the System-on-Chip (SoC)
and considered trusted. PeriScope [39] identiﬁed a compro-
mised peripheral device (e.g., Wi-Fi chip) can attack kernel
device drivers by sending malicious input through DMA, and
therefore, fuzz-tested the DMA channels. It identiﬁes DMA

channels by instrumenting Linux kernel APIs, which however
is not applicable to bare-metal MCU ﬁrmware.

X. CONCLUSION

We presented a survey showing the prevalence and di-
verse usages of DMA on MCU-based embedded devices.
We highlighted the importance of supporting DMA-enabled
peripherals during dynamic ﬁrmware analysis. To address
existing ﬁrmware analyzers’ inability to test DMA-enabled
ﬁrmware, we designed and built DICE, a drop-in solution
that enables analyzer-generic and hardware-independent em-
ulation of DMA input channels. By identifying and observing
DMA conﬁgurations and accesses by ﬁrmware during emu-
lated execution, DICE detects DMA input channels that are
dynamically created by ﬁrmware. It also dynamically infers
the locations and sizes of memory buffers used as DMA
transfer destinations. Without requiring any human assistance
or ﬁrmware source code, DICE allows ﬁrmware analyzers to
run and test DMA-related code, and in turn, ﬁnd bugs or
vulnerabilities in ﬁrmware that otherwise cannot be reached
or triggered.

We integrated DICE into P2IM (for ARM Cortex-M) and a
MIPS PIC32 emulator. We evaluated DICE using 83 sample
ﬁrmware and 7 real-world ﬁrmware. Its runtime overhead is
low (3.4%) and its emulation accuracy is very high (89% true
positive rate and 0% false positive rate). When used for fuzzing
the real-world ﬁrmware, DICE increased code path coverage
it helps detect 5 unique,
by as much as 79X. Moreover,
previously unreported bugs, which would not have been found
without the generic and automatic DMA emulation.

ACKNOWLEDGMENT

The authors would like to thank the anonymous reviewers
for their insightful comments. This project was supported
by the National Science Foundation (Grant#: CNS-1748334),
the Ofﬁce of Naval Research (Grant#: N00014-18-1-2043),
and the Army Research Ofﬁce (Grant#: W911NF-18-1-0093).
Any opinions, ﬁndings, and conclusions or recommendations
expressed in this paper are those of the authors and do not
necessarily reﬂect the views of the funding agencies.

REFERENCES

[1] Nrf52832 datasheet. https://infocenter.nordicsemi.com/pdf/nRF52832

PS v1.4.pdf. Accessed: Sep 2019.

[2] Halucinator: Firmware re-hosting through abstraction layer emulation.

In 29th USENIX Security Symposium, 2020.

[3] C. Gordon Bell, Allen Newell, and Daniel P. Siewiorek. Structural levels
of the pdp-8. http://digitalcollections.library.cmu.edu/awweb/awarchi
ve?type=ﬁle&item=356992, 1978. Accessed: Apr 2020.

[4] Fabrice Bellar. Qemu features/softmmu. https://wiki.qemu.org/Features

/SoftMMU. Accessed: Apr 2020.

[5] Stephen Checkoway, Damon McCoy, Brian Kantor, Danny Anderson,
Hovav Shacham, Stefan Savage, Karl Koscher, Alexei Czeskis, Franziska
Roesner, and Tadayoshi Kohno. Comprehensive experimental analyses
In 20th USENIX Security Symposium,
of automotive attack surfaces.
San Francisco, CA, USA, August 8-12, 2011, Proceedings. USENIX
Association, 2011.

[6] Daming D Chen, Maverick Woo, David Brumley, and Manuel Egele. To-
wards automated dynamic analysis for linux-based embedded ﬁrmware.
In Network and Distributed System Security Symposium (NDSS), 2016.

16

[28] Valasek Chris Miller Charlie. Remote exploitation of an unaltered
http://illmatics.com/RemoteCarHacking.pdf.

passenger vehicle.
Accessed: Nov 2019.

[29] Marius Muench, Dario Nisi, Aur´elien Francillon, and Davide Balzarotti.

Avatar 2: A multi-target orchestration platform. In BAR, 2018.

[30] Marius Muench, Jan Stijohann, Frank Kargl, Aur´elien Francillon, and
Davide Balzarotti. What you corrupt is not what you crash: Challenges in
fuzzing embedded devices. In Network and Distributed System Security
Symposium (NDSS), 2018.

[31] NIST. CVE-2019-6496. https://nvd.nist.gov/vuln/detail/CVE-2019-64

96, 2019. Accessed: April 2020.

[32] Koopman Phil. A case study of toyota unintended acceleration and
software safety. https://users.ece.cmu.edu/∼koopman/pubs/koopman14
toyota ua slides.pdf, 2014. Accessed: November 2019.

[33] Google Project Zero. Over the air: Exploiting broadcom’s wi-ﬁ stack.
https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-bro
adcoms-wi-ﬁ 4.html, 2017. Accessed: November 2019.

[34] Matthew J Renzelmann, Asim Kadav, and Michael M Swift. Symdrive:

Testing drivers without devices. In OSDI, 2012.

[35] GigaDevice Semiconductor. Gd32vf103 user manual. http://gd32mcu.
21ic.com/data/documents/shujushouce/GD32VF103 User Manual E
N V1.2.pdf, 2019. Accessed: Nov 2019.

[36] Vakulenko Serge. Qemu for mips pic32. https://github.com/sergev/qe

mu/wiki. Accessed: April 2020.

[37] A. Seshadri, A. Perrig, L. van Doorn, and P. Khosla. Swatt: software-
based attestation for embedded devices. In IEEE Symposium on Security
and Privacy, 2004. Proceedings. 2004, pages 272–282, May 2004.
[38] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens,
Mario Polino, Audrey Dutcher, John Grosen, Siji Feng, Christophe
Hauser, Christopher Kruegel, and Giovanni Vigna. SoK: (State of)
In IEEE
The Art of War: Offensive Techniques in Binary Analysis.
Symposium on Security and Privacy, 2016.

[39] Dokyung Song, Felicitas Hetzelt, Dipanjan Das, Chad Spensky, Yeoul
Na, Stijn Volckaert, Giovanni Vigna, Christopher Kruegel, Jean-Pierre
Seifert, and Michael Franz. Periscope: An effective probing and fuzzing
framework for the hardware-os boundary. In Network and Distributed
System Security Symposium (NDSS), 2019.

[40] STmicroelectronics. Stm32f4 reference manual. https://www.st.com/r
esource/en/reference manual/dm00031020.pdf, 2019. Accessed: Nov
2019.

[41] Zhichuang Sun, Bo Feng, Long Lu, and Somesh Jha. Oat: Attesting
operation integrity of embedded devices. In 2020 IEEE Symposium on
Security and Privacy (SP). IEEE, 2020.

[42] Seyed Mohammadjavad Seyed Talebi, Hamid Tavakoli, Hang Zhang,
Zheng Zhang, Ardalan Amiri Sani, and Zhiyun Qian. Charm: Facilitating
dynamic analysis of device drivers of mobile systems. In 27th USENIX
Security Symposium, 2018.

[43] Wikipedia. Stuxnet. https://en.wikipedia.org/wiki/Stuxnet, 2010.

Accessed: Sep 2019.

[44] Jonas Zaddach, Luca Bruno, Aurelien Francillon, and Davide Balzarotti.
Avatar: A framework to support dynamic security analysis of embedded
In Network and Distributed System Security
systems’ ﬁrmwares.
Symposium (NDSS), 2014.

[45] Michal Zalewski. american fuzzy lop. http://lcamtuf.coredump.cx/afl/.

Accessed: Sep 2019.

[7] Nassim Corteggiani, Giovanni Camurati, and Aur´elien Francillon. In-
ception: system-wide security testing of real-world embedded systems
software. In 27th USENIX Security Symposium, 2018.

[8] Andrei Costin, Apostolis Zarras, and Aur´elien Francillon. Automated
dynamic ﬁrmware analysis at scale: a case study on embedded web
interfaces. In ACM Asia Conference on Computer and Communications
Security, 2016.

[9] Geovanny Di Sirio. ChibiOS. http://chibios.org, 2017. Accessed: Sep

2019.

[10] Bo Feng, Alejandro Mera, and Long Lu. P2im: Scalable and hardware-
independent ﬁrmware testing via automatic peripheral interface model-
ing. In 29th USENIX Security Symposium, 2020.
[11] U. Frisk. Direct memory attack the kernel.

In Proceedings of

DEFCON’24, 2016.

[12] Gartner. Gartner says 5.8 billion enterprise and automotive iot endpoints
will be in use in 2020. https://www.gartner.com/en/newsroom/press-re
leases/2019-08-29-gartner-says-5-8-billion-enterprise-and-automotive
-io. Accessed: Nov 2019.

[13] GPSinformation.org. NMEA data. https://www.gpsinformation.org/dal

e/nmea.htm. Accessed: Sep 2019.

[14] Fabio Gritti, Lorenzo Fontana, Eric Gustafson, Fabio Pagani, Andrea
Continella, Christopher Kruegel, and Giovanni Vigna. Symbion: Inter-
leaving symbolic with concrete execution. In Proceedings of the IEEE
Conference on Communications and Network Security (CNS), June 2020.
[15] Eric Gustafson, Marius Muench, Chad Spensky, Nilo Redini, Aravind
Machiry, Yanick Fratantonio, Davide Balzarotti, Aurelien Francillon,
Yung Ryn Choe, Christophe Kruegel, et al. Toward the analysis of
In International
embedded ﬁrmware through automated re-hosting.
Symposium on Research in Attacks, Intrusions and Defenses (RAID)
2019), 2019.

[16] Taylor Hardin, Ryan Scott, Patrick Proctor, Josiah D. Hester, Jacob
Sorber, and David Kotz. Application memory isolation on ultra-low-
power mcus. In 2018 USENIX Annual Technical Conference, USENIX
ATC 2018, Boston, MA, USA, July 11-13, 2018, pages 127–132, 2018.
[17] Lee Harrison, Hayawardh Vijayakumar, Rohan Padhye, Koushik Sen,
and Michael Grace. PARTEMU: Enabling dynamic analysis of real-
In 29th USENIX Security
world trustzone software using emulation.
Symposium, 2020.

[18] Jesse Hertz and Tim Newsham. Triforceaﬂ. https://www.nccgroup.trust
/us/about-us/newsroom-and-events/blog/2016/june/project-triforce-run
-aﬂ-on-everything/. Accessed: Sep 2019.

[19] IC Insights. The mcclean report 2017 - april update. https://www.eene
wsanalog.com/news/ma-moves-alter-mcu-vendor-ranking-0. Accessed:
Sep 2019.

[20] Markus Kammerstetter, Daniel Burian, and Wolfgang Kastner. Embed-
ded security testing with peripheral device caching and runtime program
In 10th International Conference on Emerging
state approximation.
Security Information, Systems and Technologies (SECUWARE), 2016.

[21] Markus Kammerstetter, Christian Platzer, and Wolfgang Kastner.
Prospect: peripheral proxying supported embedded code testing. In ACM
Symposium on Information, Computer and Communications Security,
2014.

[22] Karl Koscher, Tadayoshi Kohno, and David Molnar. Surrogates: En-
abling near-real-time dynamic analyses of embedded systems. In WOOT,
2015.

[23] A Theodore Markettos, Colin Rothwell, Brett F Gutstein, Allison Pearce,
Peter G Neumann, Simon W Moore, and Robert NM Watson. Thun-
derclap: Exploring vulnerabilities in operating system iommu protection
In Network and Distributed
via dma from untrustworthy peripherals.
System Security Symposium (NDSS), 2019.

[24] Microchip. Microchip product portfolio march 2019. https://www.mi
crochip.com/ParamChartSearch/chart.aspx?branchID=30063, 2019.
Accessed: March 2019.

[25] Microchip. Quick reference guide 16bit microcontrollers. http://ww1.mi
crochip.com/downloads/en/DeviceDoc/30010109F.pdf, 2019. Accessed:
March 2019.

[26] Microchip. Quick reference guide 32bit microcontrollers. http://ww
1.microchip.com/downloads/en/DeviceDoc/60001455D.pdf, 2019.
Accessed: March 2019.

[27] Microchip. Quick reference guide 8bit microcontrollers. http://ww1.micr
ochip.com/downloads/en/DeviceDoc/30009630M.pdf, 2019. Accessed:
March 2019.

17

