8
1
0
2

n
u
J

8
1

]

R
C
.
s
c
[

3
v
5
6
4
3
0
.
3
0
8
1
:
v
i
X
r
a

Malytics: A Malware Detection Scheme

Mahmood Youseﬁ-Azar∗†, Len Hamey∗, Vijay Varadharajan‡, Shiping Chen†

∗Department of Computing, Faculty of Science and Engineering, Macquarie University, Sydney, NSW, Australia.
Email: mahmood.youseﬁazar@hdr.mq.edu.au, len.hamey@mq.edu.au

‡Faculty of Engineering and Built Environment, University of Newcastle.
Email: vijay.varadharajan@newcastle.edu.au
† Commonwealth Scientiﬁc and Industrial Research Organisation, CSIRO, Data61.
Email: Shiping.Chen@data61.csiro.au

Abstract

An important problem of cyber-security is malware
analysis. Besides good precision and recognition rate,
a malware detection scheme needs to be able to gen-
eralize well for novel malware families (a.k.a zero-day
attacks). It is important that the system does not require
excessive computation particularly for deployment on
the mobile devices.

In this paper, we propose a novel scheme to detect
malware which we call Malytics. It is not dependent
on any particular tool or operating system. It extracts
static features of any given binary ﬁle to distinguish
malware from benign. Malytics consists of three stages:
feature extraction, similarity measurement and classiﬁ-
cation. The three phases are implemented by a neural
network with two hidden layers and an output layer.
We show feature extraction, which is performed by
tf -simhashing,
layer of a
particular neural network. We evaluate Malytics per-
formance on both Android and Windows platforms.
Malytics outperforms a wide range of learning-based
techniques and also individual state-of-the-art models
on both platforms. We also show Malytics is resilient
and robust in addressing zero-day malware samples.
The F1-score of Malytics is 97.21% and 99.45% on
Android dex ﬁle and Windows PE ﬁles respectively,
in the applied datasets. The speed and efﬁciency of
Malytics are also evaluated.

is equivalent

to the ﬁrst

I. INTRODUCTION

Malware detection is of paramount importance to our
digital era and thus the daily life. Over 600 millions
malware for Windows and 19 million for Android devices
were developed in 2016/2017 [1]. In addition to the volume
of malware generated, novel families make the detection
task overwhelming.

Malware detection is mostly based on static or/and dy-
namic analysis of samples [2, 3, 4]. Static analysis uses a
binary ﬁle and/or disassembled code without running it. It is
quite efﬁcient, in most cases, but has problems with heavy
obfuscation. Dynamic analysis is a better solution for obfus-
cated samples because it relies on the run-time behaviour,
but it is computationally expensive, and the analysis might
not see malicious behaviour during testing. Given features
extracted, a classic method to detect malicious codes is
to generate a signature for every malware sample. The

signature-based methods are only good for detecting known
malware.

it

In particular,

is not difﬁcult

to create many poly-
morphic/metamorphic variants of a given malware sample.
The new variants easily evade signature-based defence sys-
tems. However, the different variants of the same malware
typically exhibit similar malicious patterns. Learning the
patterns is the given task of most modern malware detection
schemes [5, 6].

Deep Convolutional Neural Network (CNN) and other
deep learning models have been developed to address a
wide range of our daily life phenomenons such as vision,
speech and NLP [7, 8]. The motivations behind them are
quite intuitive for the given task and make them state-of-
the-art for most cases; however, the proposed scheme of
this paper outperforms a wide range of such models. This
might be because the scheme is particularly developed for
our given task.

This paper presents a novel learning-based scheme that
shows robust ability to detect malware compared with
existing state-of-the-art learning-based models and other
baselines. The proposed scheme which we call Malytics
is resilient to zero-day samples.

We named our model Malytics because the intuition
behind the scheme is an analytic solution to detect malware.
That is, the learning algorithm comes from a top-down
theory with a direct solution rather than learning through
samples in an iteration fashion. A wide range of learning
algorithms have been developed to learn from input samples
[9]. We do not argue the capability of learning models that
initiate a hypothesis space (i.e. a model) and adapt this
hypothesis space into the training samples. However, we
propose to use a learning algorithm that is theoretically
related to our proposed feature representation.

The model is an integrated system in which static features
are extracted from a binary ﬁle and classiﬁed by a neural
network. Although deep learning models can be this neural
network, it is computationally very expensive to use back-
propagation to learn a very large feature space. A common
solution for this situation is to use random projection
techniques [10]. The projected feature space is then fed

 
 
 
 
 
 
to the deep neural network. Random projection with our
training algorithm shows quite strong results, supported by
a theoretical justiﬁcation.

Figure ?? present a high level concept of the Malytics.
Inspired from Natural Language Processing (NLP) (see
section II), the term-frequency (tf ) of the given binary ﬁle
is multiplied by the random projection matrix including 1
and -1. The result is called tf -simhashing. This process is
linear.

The representation is fed to the next stage/layer where the
similarity indices are obtained as the input for classiﬁcation.
To improve classiﬁcation, generic non-linear features (e.g.
the Gaussian kernel) can be used [11]. This can cause
poor generalization [12]. A motivation that this paper uses
Extreme Learning Machine (ELM) (see section III) as the
supervised classiﬁer is to address the generalization.

We collected different datasets for our experiments. Be-
cause the samples were collected in the wild, they could
be a malware ﬁle or malicious code that was imaged into
another ﬁle. This setting helps test the model for real world
application. We cannot directly compare our model with
the other work because we do not have access to speciﬁc
state-of-the-art work datasets, except one Android dataset;
however, we think that in many cases similar datasets have
been used [13, 14, 15, 16]. Our ground-truth for malware
samples is a collection of 19 well-known AV vendors.

To evaluate Malytics a wide range of experiments on
Android and Windows samples is conducted. For Android,
We propose to use the Dex (Dalvik Executable) ﬁle rather
than the raw APK. Our experiments show tf -simhashing
of a dex ﬁle of an APK carries more efﬁcient information
rather than the APK itself. Dex ﬁles are also smaller than
APKs. The results on Windows Portable Executable (PE)
ﬁles show that the model is not dependent on a particular
operating system.

Authors [17] showed for n-grams with n > 2 (e.g 4-
gram and 6-gram), the byte-level representation is highly
informative while it demands a high computation and
feature selection phase. They observed that the information
contained in n-grams stem from string features. However,
we think 2-gram can carry more information related to
instructions and also preserve the string pattern in the
frequency.

Problem: Malware must be distinguished from benign
samples. The system needs to be fast and efﬁcient. Novel
Malware families must be detected.

Solution: Malytics is a resilient solution for the problem.
information
The byte representation contains important
such as APIs, op-codes. The model learns the pattern of
bytes. The tf -simhashing static feature representation is a
fast solution to embed the byte patterns into a short size
vector. Malytics generalizes the patterns well even for novel
samples.

Contribution:
- We propose a single and integrated model for malware
detection. The model has no dependency on particular
tools. Malytics places no restriction on the operating sys-

tem. Evaluation shows it outperforms other single (non-
ensemble) state-of-the-art models for both Android and
Windows static analysis.

- We bridge the gap between simhashing and a type
of neural network. In particular, we show that simhashing
has a close relation to the ﬁrst layer of ELM. This paper
theoretically and empirically show this neural network
where the ﬁrst layer is not trained, has a strong capability
for malware detection.

- We show least squares regression in the form of the
ELM with a non-linear kernel can provide a template
to fully enhance the feature space rather than implicit
feature selection of the regressor used in [17]. The Malytics
generalization performance for unseen data also shows the
effectiveness of the applied regularization technique.

- A further empirical evaluation of Malytics shows that it
can successfully detect new malware families and zero-day
samples in the wild. This paper also shows Malytics can be
tailored for large scale data application while still remains
competitive.

The feature extraction method is presented in section 2,
and providing the detail of the proposed scheme in section
3. In section 4, we present a comprehensive evaluation on
the performance of Malytics for both Android and Windows
platforms, and also discuss the results. In section 5, we
provide the limitations of Malytics and future direction of
research. Section 5 and 6 present related work to our work
and conclusion respectively.

II. THE FEATURE EXTRACTION

Hashing is a computation which maps arbitrary size data
into data of a ﬁxed size. Hashing algorithms have been
widely used in the security application domain [18, 19, 20].
Locality Sensitive Hashing (LSH) is one of the main
categories of hashing methods. It hashes input data so
that similar data maps to the same “buckets” with high
probability, maximizing the probability of a “collision” for
similar inputs. Simhashing is one of the most widely used
LSH algorithms, adopted to ﬁnd similar strings [21, 22].
Simhashing is an LSH that is designed to approximate
the cosine similarity between inputs. The main concept of
simhashing comes from Sign Random Projections (SRP)
[21, 23, 24]. Given an input vector V , SRP utilizes a
random Gaussian unit vector (a random hyper-plane) I
with each component generated from a Gaussian unit (i.e.,
Ii ∼ N (0, 1) where i is the number of component) and
only stores the sign of the projected data as:

hash(V ) = sign(V · I)

(1)

where · is the dot product. Depending on which side of
the hyper-plane V lies, hashing(V ) = ±1 . A family of the
hash function with the mentioned characteristics provides
a setting where for two inputs vectors V and U :

Fig. 1: Detailed schematic of the proposed solution for malware detection. We used 2-gram (see section II) in this particular
example.

P r[hash(V ) = hash(U )] = 1 −

θ(V, U )
π
|V ∩ U |
(cid:112)|V | · |U |

)

(2)

θ = arccos (

Where θ(V, U ) is closely related to cosine(V, U ) for the

two vectors.

If V · I ≥ 0 then hash(V ) = 1 and otherwise hash(V ) =
0, the hamming distance is related to the similarity and
it provides a good space to solve the nearest neighbour
problem; however, this is not the problem we look to solve.
The hash function family generates a real value vector
if hash(V ) = V · I and equation 2 is still guaranteed. We
use simhashing that produce real values.

Simhashing has wide-ranging applications from detecting
duplicates in texts (e.g. websites) to different security
and to malware analysis, speciﬁcally with the Hamming
distance similarity measure [25, 26, 27]. Inspired from NLP
application domain, a n-gram is a contiguous sequence of n
items (here, a byte pair) from a given sequence of the binary
ﬁle. The n-gram feature representation is a speciﬁc type of
bag-of-words representation in which only the number of
occurrences of the items is decisive and the location of
the items in the binary ﬁle is neglected. The theory behind
simhashing allows us to weight the byte n-gram [21] with
the number of occurrences rather than only representing
presence (i.e. zero and one) of the byte n-gram in the ﬁle.
The proposed feature representation generates a ﬁx size
vector from an arbitrary size binary ﬁle. Given a binary
ﬁle, each n-gram is ﬁrst hashed to a single ﬁx size vector.
To speed up this process, ﬁrst a dictionary of n-grams is
provided and then, this vocabulary hashed to binary values.
Having tf of the vocabulary stored, each hash bit with value
1 or -1 is weighted with tf of the n-gram. Thus, tf is inserted
into the representation [28]. In the next step, all the vectors
sum up bit-wise, thereby providing a ﬁnal ﬁx size vector.
With this process, we embed the distribution of the n-grams
of bytes into the vector. This representation provides the

two vectors that are close to each other when two ﬁles
have many common n-grams and different when the ﬁles
have many different n-grams.

Bit-wise summing up all the real-value hash vectors of
a ﬁle (i.e. hash(Vi) = Vi · Ii where i is the number of
components of hash vector, for example 1024) results in
a vector with high variance that needs to be reduced for
feeding to an learning algorithm.

Because we want to map the representation into the
space where dot product of vectors directly depends on
the angle between vectors, each vector needs to be linearly
transformed to have zero mean and unit variance. This
transformation is different than normalizing each feature
independently to speed up the convergence, because it nor-
malizes each input vector. The other option is to normalize
each vector to its Euclidean length (a.k.a L2 norm). In
this case, the dot product of two vectors is directly Cosine
similarity. But, since the representation will further map
to an inﬁnite-dimension space using a Euclidean-distance-
based similarity measure, we do not use L2 normalization
but
to have zero mean
and unit variance). We observed that this transformation
provides better results. The pseudo-code of the proposed
greedy-wise algorithm is:

linearly transform (Z = X−µ

σ

Algorithm 1: tf -simhashing

dictionarySize ← 28∗ngram
componentsSize ← i
IdictionarySize×componentsSize ← Ii ∼ N (0, 1)
Where ii ≥ 0 set to 1 and ii < 0 set to -1

1: procedure tfSimhash(Dataset, ngram, i)
2:
3:
4:
5:
6: repeat
7:
8:
9:
10:

for each binary ﬁle:
HexStr ← Hex(BinaryFile)
TF1×dictionarySize ← dic(HexStr, dictionarySize)
tf-simhash1×componentsSize ← normalization(TF × I)

The aforementioned algorithm is how tf -simhashing can
be implemented; however, in the context of neural network,

algorithm 1 is equivalent to the whole process of feeding
tf representation of byte n-grams to a layer with weights
randomly set to 1 or -1; thus, no training is required for
this layer (see section III for more theoretical elaboration).
The output of the hidden layer is exactly our tf -simhashing.
Indeed, the proposed algorithm bridges the gap between
simashing and a neural network in which the ﬁrst hidden
layer has random weights.

We already know that the similarity of the output of the
hidden nodes in algorithm 1 closely depends on the Cosine
angle between two samples (i.e. V and U ). In algorithm
1, the vector size i corresponds to the number of hidden
nodes in the neural network.

In the next section, we call the tf -hashing phase as the

ﬁrst layer of our neural network.

III. THE PROPOSED SCHEME

Because the latent representation generated in the output
of the ﬁrst hidden layer is based on the similarity of the
original space, the second hidden layer of the proposed
model can provide a similarity measure. Indeed, we need a
task-speciﬁc similarity over pairs of data points to facilitate
training samples in the ﬁrst
the prior knowledge (i.e.
hidden layer). This similarity measure followed by a linear
predictor also yields a convex optimization problem [29].
Kernel methods can play this role. The relation between
kernel machines and the neural network has been widely
investigated [29, 30, 31]. Because kernel layer is data-
dependent but unlabeled, the kernel layer training could be
seen as unsupervised.

Figure 2 presents the proposed scheme. The output layer
weights are analytically obtained using the linear least
squares technique. The output layer is the ELM. The whole
scheme has more than one hidden layer; thus, it is a deep
neural network. However, because the training does not
use the back-propagation algorithm for training, the scheme
differs from the deep learning that is a well-known term in
the machine learning community.

The kernel layer is a non-parametric and nonlinear model
to match the input to the templates that are obtained from
the training samples. The Radial Basis Function (RBF)
kernel is well known for providing an inﬁnite-dimensional
kernel space and is commonly used with the kernel trick
[31, 32]. As we show later, our model supports the kernel
trick, so the RBF kernel is a logical choice.

K(x, xi) = exp

(cid:18)

−d(x−xi)2
2γ2

(cid:19)

(3)

where d is the Euclidean distance and γ is the spread
parameter. The function is symmetric K : X × X → R,
a positive-deﬁnite matrix and always a real-valued square
matrix. This function projects tf -simhashing vectors into an
inﬁnite dimensional space. The output layer weight can be
trained to predict both classes (i.e. 1 and -1).

In detail, although approximations to RBF can also
provide good results [32], our malware detection task
alongside with the ﬁrst hidden layer topology give a

good reason not to use any approximation but to use the
kernel trick. The kernel trick implicitly maps the feature
space to an inﬁnite-dimension feature space. The trick
makes the mapping limited by the number of data. We
empirically evaluate the effect of the kernel dimension
(see the subsection IV-F2).

To obtain the output layer parameters, we use the ELM.
Let {(xi, ti)|xi ∈ Rd, ti ∈ {−1, 1}}N
i=1, where N is the
number of training samples, d is the dictionary size and m
is the number of output nodes. The ELM model is f as
follows:

f (x) =

L
(cid:88)

i=1

βih(x, ai, bi) = h(x)β

(4)

Where L is the number of hidden nodes, β =
[βi, ..., βL]T is the output weights and a and b, in our
model, are the kernel parameters (i.e exp(−b||x−a||2). b are
constant when ELM is being trained. h(·) is the RBF kernel.
The ELM objective function is to minimize:

||β||2 + C

Minimizeβ :

1
2
Subject to : h(xi)β = tT

N
(cid:88)

1
2
i=1
i − ξT

||ξ||2

(5)

i , i = 1, ..., N

Where C is the trade-off parameter, ξ = [ξi,1, ..., ξi,m]T
is the error between the desired target (e.g. [-1,1] for benign
and [1,-1] for malware) and the labels predicted by the
models. There are different techniques to obtain the output
layer weights β including orthogonal projection method,
iterative methods, and singular value decomposition (SVD)
[33, 34, 35]. To minimize the least squares norm,
the
methods are based on the calculation of the Moore–Penrose
pseudo-inverse matrix [35, 36] as follows:

β = H†T

(6)

Where H† is the matrix. For the sake of feasibility,
Kozik [37] used the SVD matrix factorization technique for
malware activity detection; however, the proposed malware
detection scheme of this paper allows us to use the closed
form solution [38]. With Karush-Kuhn-Tucker conditions,
the Lagrangian dual problem is deﬁned:

LDualELM :

1
2

||β||2 + C

1
2

N
(cid:88)

i=1

||ξ||2

N
(cid:88)

m
(cid:88)

−

i=1

j=1

αi,j(h(xi)βj − ti,j + ξi,j)

(7)

Where βj is the out put layer weight/vectors and in our
case m = 2. The dual problem can be optimized (see
Appendix A) and provides the direct solution as follows:

β = HT (cid:0) I
C

+ HHT)−1T

(8)

Fig. 2: The proposed scheme. tf -simhashing algorithm has been considered as the ﬁrst hidden layer.

The ELM function is:

f (x) = h(x)β = h(x)HT (cid:0) I
C

+ HHT)−1T

(9)

Where h(·) can be unknown and an implicit function
satisﬁes the task. A kernel matrix Ω using a kernel function
K can be used as follows:

Ω = HHT : Ωi,j = h(xi) · h(xj)

= K(xi, xj), i, j = 1, ..., N

(10)

The output function as follows:

Testing

:

f (x) =











K(x, x1)
...
K(x, xN )

(cid:0) I
C

+ Ω)−1T

(11)

The applied kernel is RBF. The method is similar to
RBF kernel in SVM. Indeed, SVMs are the particular case
of ELM. That is, in ELM all the inputs construct support
vectors [38]. Based on the ELM universal approximation
capability that is:

lim
L→∞

||

L
(cid:88)

i=1

βihi(x) − f (x)|| = 0

(12)

As long as h(·) is a strict positive deﬁnite kernel [39, 40],
a sufﬁcient number of hidden nodes still satisﬁes 12. In
our model, the ﬁrst hidden layer (tf -simashing algorithm)
is equivalent to the random nodes; additionally, we also
show that we can choose a random subset of the support
vectors, from kernel matrix, to reduce the computational
over-head and required memory for big data in the cost of
the model’s performance, that is, ||Kl×lβ − T || < (cid:15) where
l < L.

The proposed scheme is summarized in Algorithm 2

Algorithm 2: the proposed scheme algorithm
: given N training samples as
Input

{(xi, ti)|xi ∈ Rd, ti ∈ {−1, 1}}N
testing samples as {(xi, ti)|xi ∈ Rd, }V
n-gram, i, l

i=1, given V

i=1,

Output
Training :

: predicted labels (Benign or Malware)

tf-simhashN ×i ← tfSimhash(Dataset,ngram,i)
KernelM atrixN,N ← RBF(tf-simhashN ×i)
if l (cid:54)= N then

RandK ← Random(1 : l)
return KernelMatrixl,l(RandK, RandK);

end
β ← (cid:0) I

C + KernelM atrix(cid:1)−1T

tf-simhashV ×i ← tfSimhash(binary ﬁle,ngram,i)
Predictions ← β × RBF (tf-simhashV ×i)

IV. EVALUATION

To evaluate our scheme, we conducted a wide range of
experiments on real datasets collected from the wild for
both Android and Windows platforms. During all experi-
ments, we kept the training data balanced (i.e. malware to
benign ratio (MBR) is 0.5) except especially to evaluate
the capability of the scheme to deal with imbalanced data.
Our benign samples were collected from Androzoo, a freely
available APks repository [41]. Androzoo crawled several
markets including the ofﬁcial Google Play. We randomly
selected apps collected from Google Play. Our collected
malware samples (from Virussahre.com1) includes a wide
range of malware families for both Android and Microsoft
Windows platforms. We double checked the status of all
malware samples using VirusTotal.com API2. VirusTotal
provides the results of analysis by about 55 anti-virus
vendors. To avoid having a considerable inconsistency,
we selected 19 of the most well-known vendors’ results.
The selected companies are Kaspersky, Symantec, ESET-

1https://virusshare.com/
2https://www.virustotal.com/#/home/search

NOD32, Avast, McAfee, AVG, Avira, Microsoft, BitDe-
fender, Panda, F-Secure, Malwarebytes, TrendMicro, Co-
modo, VIPRE, AVware, Ad-Aware, Sophos and Qihoo-
360. A malware that is detected by at least one of the
vendors was picked to be included in our datasets. This
procedure was used to establish the ground-truth in all our
experiments.

The ﬁrst malware dataset is Drebin [42]. It consists of

5560 malware of which 5555 have a .dex ﬁle.

downloaded

We also collected our own malware dataset from the
and
packages VirusShare Android 20130506.zip
two
VirusShare Android 20140324.zip,
from
VirusShare.com. Together these consist of 35397 malware
that were collected before April 2014. Since some samples
of the packages have been reversed engineered and were
re-compressed, we focus on intact samples. Also, each
malware must meet our ground-truth threshold. 20255
malware samples met our criterion. Figure 3 shows
the number of samples detected by the 19 anti-virus
vendors. We again randomly select 20255 benign from
our repository. The statistics of the dataset (DexShare) is
presented in the table I.

For Microsoft Windows, 8912 PE (WinPE) benign has
been collected from a fresh installed Windows 10 with
2016 updates. The other benign set, consisting of 11983
PE (WinAppPE), was collected by combining the Windows
benign with 77 applications (e.g. ﬁrefox, Adobe Reader,
etc), automatically install by Ninite 3. For the malware
set, we downloaded VirusShare 00271.zip a package con-
taining 65,536 malware of which 11483 are PEs that also
meet the threshold of the selected anti-virus vendors. The
package was captured from 2016-11-01 to 2016-11-20 from
the wild. To provide balance, we collected further 500
malware from the previous package in VirusShare and
added this malware set to yield MalPE2016. Because one
of our evaluation goals is zero-day detection, we also
collected PEs of VirusShare 00298.zip (MalPE2017) that is
a package collected about one year after PE2016. The table
I shows the statistics of the Windows dataset (PEShare).
Figure 3 also shows the number of samples detected by
1 to 19 anti-virus vendors for both malware sets. When
it comes to testing Malytics for WinPE set, we randomly
select 8912 malware from MalPE2016.

We used different evaluation metrics to analyze the
performance of the proposed scheme. The metric for our
two class classiﬁcation task is based on the confusion
matrix:

Actual

Benign
Malware

Benign
True Negative (TN)
False Negative (FN)

Malware
False Positive (FP)
True Positive (TP)

Predicted

The common performance metrics are:
Recall (a.k.a hit/detection rate or sensitivity) = T P

And, False Negative Rate (FNR) = F N

T P +F N .
T P +F N . where FNR

3https://ninite.com/

Fig. 3: The number of samples detected by the 19 selected
anti-virus vendors.

Dataset

Drebin

DexShare

PEShare

Type

Qty

Max. Min.

Ave.

Malware
Benign

Malware
Benign

MalPE2016
MalPE2017
WinPE
WinAppPE

5555
5555

20255
20255

11983
12127
8912
11983

06.0
13.5

09.2
10.5

53.0
54.1
33.6
80.3

2.3
1.4

1.0
1.9

0.8
1.5
1.7
1.5

0.36
3.00

0.65
1.56

0.97
1.26
0.35
0.50

TABLE I: The statistics of the datasets. Max, Min and Ave
stand for maximum size (MB), minimum size (KB) and
average size (MB) of the ﬁles respectively

is 1 - recall.

T P +F P

T N +T P
T N +F P +F N +T P

Precision = T P
f1-score = 2 ∗ precision∗recall
precision+recall
Accuracy =
False positive rate (FPR) = F P
The mentioned metrics are enough to evaluate a model.
We also used AUC (the area under receiver operating
characteristic (ROC) curve) where we found other work
with this index. AUC is the probability that a classiﬁer
will rank a randomly chosen positive sample higher than a
randomly chosen negative sample.

T N +F P

A. Experimental Setup

To practically show the scheme’s efﬁciency and meeting
the mentioned classiﬁer characteristics, we used Support
Vector Machines (SVMs), Gradient Boost (XGBoost), Deep
Neural Network (DNN), Random Forest (RF) and K-
Nearest Neighbors (K-NN) as our baselines. The scikit-
learn Python library was used to implement the baselines
for SVM, XGBoost, RF, K-NN. We use Keras API , that
runs on top of TensorFlow, to implement Deep Neural net-
work. We used grid search to optimize the hype-parameters
of the baselines. The results of this the grid search (range
from 10−4 to 104 for both C and gamma) for SVM C = 0.1
and γ = 100 with RBF kernel. The grid search for K-NN
ranged from 1 to 20 for n neighbors and is either ’uniform’
or ’distance’ for weights. The Deep learning model has 3
hidden layer with 1024, 128 and 64 nodes and 1 node

in the output
layer. The activation functions are linear
rectiﬁer, linear rectiﬁer, sigmoid. The ﬁrst hidden layer is
the proposed representation. The optimizer, batch size and
the number of epochs are adam, 5, 100. The ﬁrst two hidden
layer adapt dropout regularization with 0.2 probability.

The two hyper-parameters of Malytics are trade-off pa-
rameter C and kernel parameter γ. The result of the grid
search for hyper-parameters C (ranging from 10 to 500) is
200 and for γ (ranging from 0.5 to 1.5.) is 1.

Our machine speciﬁcation is Intel(R) Core(TM) i7-4790
CPU @ 3.60GHz, 32.0 GB RAM and hard disk drive
(HDD).

The hashing algorithm was designed to generate the vec-
tor of size 1024, showing strong performance. We observe
that larger vectors provide the slightly better results and
smaller vectors reduce the performance. The vector of size
1204 is an optimum size while it still is computationally
cheap. Over our experiments, we choose 2-gram and used
5-fold cross-validation. Malytics even with 2-gram outper-
forms the state-of-the-art models. We do not ﬁx a threshold
to ensure the highest precision and recall but rather the
range of the capability of the model is also a goal of this
paper.

B. Results and Discussion

This part of the paper presents the results of the proposed
model. To compare the scheme with other models, we feed
tf -simhashing to different classiﬁers. Thus, the proposed
feature extraction technique is also examined using different
classiﬁers. Because the presented results on both Android
and Windows are based on the 5-fold cross-validation, we
present mean and standard deviation (Std) of all 5-folds in
the tables. It is usual to present FPR as a ﬁx value rather
than mean (±Std). We also calculated FPR in this way.

C. Android Malware Detection

This section presents the performance of Malytics on
Android malware detection. First, we show the model’s
capability compared with different baselines on Drebin and
DexShare datasets. Then, the model is evaluated in different
settings. Further analysis of Android malware detection is
presented in the section IV-F.

Table II shows the performance of Malytics compared
with the state-of-the-art models [3, 43], 5 baselines and
ELM (without kernel layer) on the Drebin dataset. Grosse
[43] with MBR=0.5 can be compared with our experiments.
Mariconti [3] also provides a similar setting to ours. Ma-
lytics outperforms all other techniques when it comes to
detecting malware, that is, FNR = 1.44%. This superior
performance is seen for f-score and accuracy as well.
Interestingly, DNN is the most precise model compared
with all others with only 1% FPR while its FNR is the
worst.

The Drebin dataset is a publicly available dataset but not
very sophisticated. We also tested the models on a more so-
phisticated dataset, DexShare, with more samples, collected
in wider time windows. We used AVCLASS tool to label

malware samples of both Drebin and DexShare [44]. The
tool labels the malware sets based on VirusTotal reports.
Because we use VirusTotal to double-check the collected
malware set, reports were available to use AVCLASS for
labeling. With the tool, Drebin has 180 malware families
while DexShare has 309 families.

The performance of the models on DexShare is presented
in table III. It is to be expected that all models perform
weaker on the dataset compared to Drebin, since the
detaset is more complicated to deal with. Malytics again
outperforms all models on DexShare. The results show that
Malytics has the highest hit rate (a.k.a recall = 1-FNR) to
detect malware and the highest precision that corresponds
to low FPR.

In addition to Malytics, most baselines also provide good
performance compared with Zhu [15]. This trend shows
the tf -simhashing feature representation is rich and many
classiﬁers can leverage it and provide good performance. It
is true that Hui-Juan [15] did not exactly use the DexShare
dataset, but they collected their dataset from Virusshare.com
as we did. Virusshare.com has two packages for Android
malware, and DexShare is a combination of both. So, the re-
sults can be compared. Additionally, Hui-Juan’s [15] feature
extraction is on the basis of static analysis. For example,
tf -simhashing feeding to SVM yields 93.35% (±0.16%),
08.00% (±0.48%), 94.77% (±0.25%), 93.44% (±0.16%)
for AUC, FNR, precision, and accuracy respectively while
Hui-Juan [15] reported 86.00% (±2.0%), 13.82% (±2.3%),
84.13% (±3.5%) and 84.93% (±1.8%) for AUC, FNR,
precision, and accuracy respectively when they used SVM
as the classiﬁer.

Model

SVM

XGBoost

DNN

RF

K-NN

ELM

Malytics

[43]
[3]

FNR

Precision

f1-score

Accuracy

FPR

04.81%
(±1.15%)
02.97%
(±0.20%)
13.50%
(±0.64%)
04.18%
(±0.55%)
02.80%
(±0.48%)
03.00%
(±0.30%)
01.44%
(±0.33%)
06.37%
3.00%

96.62%
(±0.40%)
93.59%
(±0.31%)
98.77%
(±0.62%)
92.52%
(±0.98%)
93.36%
(±0.70%)
94.51%
(±0.47%)
96.45%
(±0.45%)
−
95.00%

95.90%
(±0.80%)
95.28%
(±0.23%)
92.22%
(±0.46%)
94.14%
(±0.34%)
95.25%
(±0.55%)
95.76%
(±0.31%)
97.36%
(±0.29%)
−
96.00%

95.93%
(±0.77%)
95.19%
(±0.25%)
92.70%
(±0.42%)
94.03%
(±0.38%)
95.15%
(±0.57%)
95.70%
(±0.30%)
97.33%
(±0.30%)
95.93%
−

3.33%

6.64%

1.00%

7.76%

6.91%

5.60%

3.90%

3.96%
−

TABLE II: The Mean and Std of Malytics and the baselines
for Drebin Dataset.

Table IV provides more inside into Malytics. The tf -
simhashing feature extraction algorithm can be imple-
mented on APK as well as only Dex ﬁle of respective APK.
Youseﬁ-Azar [28] is based on tf -simhashing of the APK.
Table IV shows hashing the dex ﬁle yields much better
performance compared with hashing the whole APKs.

A common test is to evaluate a model in an imbalanced
setting to mimic the real world settings. For the test, MBR
is typically 10%, 20%, 30%. To have enough malware to
test the scheme and also to provide the imbalanced settings,
we chose MBR= 0.2. That is, we randomly selected 5060

Model

SVM

XGBoost

DNN

RF

K-NN

ELM

Malytics

[15]

FNR

Precision

f1-score

Accuracy

FPR

08.00%
(±0.48%)
10.12%
(±0.55%)
24.40%
(±3.53%)
13.07%
(±0.35%)
7.45%
(±0.48%)
16.50%
(±0.29%)
05.53%
(±0.46%)

11.60%
(±2.76%)

94.77%
(±0.25%)
90.74%
(±0.39%)
90.40%
(±1.73%)
92.73%
(±0.32%)
93.36%
(±0.70%)
92.25%
(±0.67%)
95.88%
(±0.40%)

88.16%
(±1.8%)

93.34%
(±0.18%)
90.30%
(±0.36%)
82.23%
(±1.45%)
89.73%
(±0.22%)
91.38%
(±0.55%)
87.66%
(±0.30%)
95.17%
(±0.20%)

−
−

93.44%
(±0.16%)
90.35%
(±0.35%)
83.72%
(±0.89%)
90.05%
(±0.21%)
91.28%
(±0.57%)
88.24%
(±0.36%)
95.20%
(±0.20%)

88.26%
(±1.73%)

05.07%

09.17%

08.13%

06.82%

10.00%

07.00%

04.06%

−

setting based on detecting future malware. Our test
is
different with their test. But if we assume that our family
exclusion test is at least as difﬁcult as predicting future
malware (e.g. test on one year in future), we can see that
Malytics is quite competitive with the state-of-the-art in
novelty detection. For further explanation see section IV-F1.

Model

Malytics (APK)

Malytics (Dex, MBR=0.5)

Malytics (Dex, MBR=0.2)

FNR

Precision

f1-score

Accuracy

FPR

09.43%
(±0.61%)
05.33%
(±0.46%)
05.27%
(±0.63%)

91.76%
(±0.73%)
95.88%
(±0.40%)
98.45%
(±0.69%)

91.16%
(±0.54%)
95.17%
(±0.20%)
96.55%
(±0.55%)

91.22%
(±0.48%)
95.20%
(±0.20%)
98.65%
(±0.21%)

8.1%

4.1%

3.7%

3.4%
−

TABLE III: The Mean and Std of Malytics and the baselines
for DexShare Dataset.

Malytics (Zero-day)
[3]

10.59%
12.00%

96.31%
86.00%

92.68%
87.00%

92.99%
−

malware from the DexShare malware set while the total
benign set was used. Table IV shows that Malytics performs
more precisely with imbalanced data. We expect this results
because the model saw more benign sample in the training.
FNR does not show a statistically signiﬁcant change. It
demonstrates that Malytics is robust
to the imbalanced
situations.

One of the most important tests of a malware detection
system is to evaluate the system against zero-day malware.
There are different evaluation methods to do a zero-day
experiment. Mariconti [3] use a time frame test. That is,
they trained the model with samples of a given date, the
model was tested on samples of one year and also two years
later than the given date. In short, training on past sample
and testing on new samples in time.

Although we could use the timestamp of the samples of
DexShare, because the timestamp of a ﬁle is easily forged,
both by malware and benign writers, we think timestamp
is not a good index to partition our dataset into past and
future samples. We also think that AVCLASS is not a very
accurate technique to partition our dataset.

However, because we do not have any other concrete op-
tion, we again rely on AVCLASS. As mentioned earlier in
this section, AVCLASS labels DexShare with 309 different
families. From 309 families, about 20 families have more
than about 150 samples in each family. We chose these
20 families for our novelty detection test. To do this test,
we selected training and test sets and we do not use cross-
validation. From malware set, out of 20 families, 4 families
were chosen to be the test set and the rest of malware set
were chosen to be training set. We did this test 5 time to
test on all 20 families. To be clear, when 4 families were
chosen to be the test set, the other 16 families plus the rest
of the malware set are the training set. The benign set was
randomly chosen from DexShare to keep the training and
test sets balanced.

Table IV shows the average FNR, precision, f1-score,
accuracy and FPR of Malytics with our proposed feature
representation. The main important index of the test is FNR
as a measure that shows how well Malytics detected new
families. Mariconti [3] also provided a novelty detection

TABLE IV: The Mean and Std of Malytics for DexShare
dataset on the APK, Dex. Also, the results when the dataset
is imbalanced and for zero-day (novel families) detection.

the hash size is 3000. Then,

For real word application, we can increase the size of
hash vector to improve the performance while Malytics
still requires a light computation. Motivated from [45],
we replaced the tf -simashing weights (i.e -1 and 1 val-
ues) with a sparse matrix including -1, 1 and 0 [46].
We set the sparsity to 1% and the size of tf -simashing
vector is 3000. Thus, only 30 elements of the hashing
matrix are non-zero but after summing over the entire
vocabulary,
this vector is
used as the input to the kernel layer and then the output
layer. This sparse setting helps reduce the complexity of
the tf -simashing computation while increasing the hidden
feature representation size. Table V presents the results of
the experiment on both datasets. Malytics False positive
improves slightly while hit-rate is very close to dense
setting (see table II). The size of hashing provides richer
hidden representation for DexShare samples. In addition to
being more precise, Malytics has better hit-rate (see table
III). The imbalanced setting shows Malytics performance
for real word application. We set hash size 3000 which has
slight impact on the LEM computation.

We conducted the last experiment to show Malytics can
perform in different settings and its improvement capability.
To have a comparable settings, other experiments of the
paper are all based on dense matrix setting with the hash
size 1024.

Dataset

Drebin

DexShare

DexShare (MBR=0.2)

FNR

Precision

f1-score

Accuracy

FPR

01.53%
(±0.50%)
04.72%
(±0.50%)
04.42%
(±0.27%)

96.68%
(±0.45%)
96.69%
(±0.35%)
98.91%
(±0.82%)

97.56%
(±0.40%)
95.96%
(±0.38%)
97.21%
(±0.53%)

97.54%
(±0.30%)
96.00%
(±0.35%)
98.90%
(±0.18%)

3.38%

3.30%

2.60%

TABLE V: The Mean and Std of Malytics with sparse tf -
simashing for both Drebin and DexShare Datasets.

D. Windows Malware Detection

This section presents the capability of Malytics to detect
Microsoft Windows malware. We show that the scheme

is not restricted by any speciﬁc feature of the operating
system.

Table VI shows that Malytics and Wuechner [14] outper-
form other models when it comes to distinguishing original
Windows PE clean ﬁles from PE malware. Malytics is the
most capable method in detecting malware with lowest the
FPR compared with all methods, in particular, with our
machine learning baselines. It has better FNR compared
with Wuechner [14] and both schemes have the same
precision while Wuechner [14] used an imbalanced dataset.
In an imbalanced setting, trade-off indices are more reliable
for concluding an analysis. F-score of the proposed model
in Wuechner [14] is more than Malytics but the difference is
not statistically signiﬁcant. AUC indices show that Malytics
outperforms other models. The FPR as an important factor
for Windows platform malware analyzer is well less than
1% that is critical for Windows.

Table VII shows that the proposed solution outperforms
other models over all evaluation indices. It is to be expected
that all models performance is reduced compared with table
VI, mainly because the benign set of this experiment is a
mix of Windows PEs and third-party PEs while the malware
set is from the same source and only has more samples.

An interesting result of trying to distinguish Mal2016
malware set from WinAppPE benign set is in the compari-
son of DNN with Raff [16]. Raff [16] used deep CNN for
detection. The results show deep learning models also can
be competitive for malware application domain. Although
the input of CNN is an image representation of the PE
ﬁles and DNN’s input is tf -simhashing, we think deep
learning models can also be competitive if the feature
representation has more theoretical justiﬁcation in the deep
learning models’ training algorithm.

Figure 4 shows the detection rate of Malytics on
Mal2017. The training sets are Mal2016 and WinAppPE
while Mal2017 is the test set. To have a similar setting
to the real world, the training benign set was WinAppPE
rather than WinPE. This experiment is to evaluate how well
the scheme can detect zero-day attacks. We assume that a
one year interval between the malware set in training and
the malware set for testing is an acceptable chronological
gap.

Malytics could successfully detect 95.5% of the Mal2017
as zero-day samples. It is only one percent less than ESET-
NOD32 detection rate. AVG with 91.5% is the third in
the ranking. Our ground truth for the detection rate of AV
vendors is VirusTotal real-time update report. VirusTotal
always uses the latest update of AVs; thus, the detection
rates it reports are considerably better than they would
be if the virus detector data was one year old. After one
year, Malytics performs competitively with the best AV
vendor software fully up to date. In another experiment,
we trained Malytics using Mal2016 and WinPE sets and
tested on Mal2017. As it is to be expected, the detection
rate increases to 98.1%.

Model

SVM

XGBoost

DNN

RF

K-NN

ELM

Malytics

[14]

[13]

FNR

Precision

f1-score

Accuracy

AUC

1.30%
(±0.30%)
1.30%
(±0.27%)
2.51%
(±0.59%)
2.18%
(±0.35%)
1.56%
(±0.38%)
1.00%
(±0.17%)
0.55%
(±0.23%)

1.00%
(±0.00%)
0.80%

99.13%
(±0.25%)
98.43%
(±0.26%)
96.77%
(±2.04%)
98.44%
(±0.32%)
98.50%
(±0.04%)
95.82%
(±0.35%)
99.20%
(±0.27%)

99.20%
(±0.00%)
−

98.91%
(±0.26%)
98.56%
(±0.19%)
97.11%
(±0.78%)
98.13%
(±0.22%)
98.47%
(±0.20%)
97.38%
(±0.18%)
99.32%
(±0.12%)

99.70%
(±0.5%)
99.10%

98.92%
(±0.26%)
98.56%
(±0.19%)
97.09%
(±0.83%)
98.14%
(±0.21%)
98.47%
(±0.20%)
97.34%
(±0.19%)
99.32%
(±0.11%)

−
−
99.05%

98.92%
(±0.25%)
98.57%
(±0.19%)
97.09%
(±0.83%)
98.14%
(±0.25%)
98.47%
(±0.20%)
97.79%
(±0.18%)
99.96%
(±0.19%)

99.30%
(±0.1%)

FPR

0.86%

1.57%

3.31%

1.55%

1.50%

4.30%

0.80%

−

1.10%

TABLE VI: The Mean and Std of Malytics and the base-
lines for WinPE and Mal2016 of the PEShare Dataset.

Model

SVM

XGBoost

DNN

RF

K-NN

ELM

Malytics

[16]

FNR

Precision

f1-score

Accuracy

AUC

2.78%
(±0.13%)
2.24%
(±0.36%)
4.43%
(±0.60%)
4.46%
(±0.58%)
2.30%
(±0.15%)
2.18%
(±0.17%)
1.32%
(±0.06%)
−

98.32%
(±0.16%)
97.61%
(±0.19%)
94.71%
(±3.90%)
97.85%
(±0.26%)
96.90%
(±0.31%)
93.95%
(±0.42%)
98.65%
(±0.04%)
−

97.76%
(±0.14%)
97.68%
(±0.20%)
95.09%
(±1.90%)
96.68%
(±0.29%)
97.30%
(±0.19%)
95.84%
(±0.19%)
98.66%
(±0.20%)
−

97.78%
(±0.14%)
97.68%
(±0.20%)
95.02%
(±2.00%)
96.72%
(±0.27%)
97.29%
(±0.19%)
95.76%
(±0.14%)
98.67%
(±0.19%)
94.00%

97.78%
(±0.14%)
97.69%
(±0.20%)
95.02%
(±2.05%)
96.72%
(±0.28%)
97.29%
(±0.19%)
97.42%
(±0.19%)
99.81%
(±0.22%)
98.10%

FPR

1.7%

2.4%

5.5%

2.1%

3.1%

6.3%

1.3%

−

TABLE VII: The Mean and Std of Malytics and the
baselines for WinAppPE and Mal2016 of the PEShare
Dataset.

E. tf-simhashing visualization

To have more insight into the proposed latent representa-
tion, that is, tf -simhashing layer and RBF kernel, a visual-
ization experiment was conducted on the feature space. We
implemented the experiment on Windows malware dataset,
WinPE and Mal2017 and used t-SNE [47] to visualize the
space.

To this end, tf -simhashing values have been clustered
using k-means clustering technique and then the centroids
of the clusters fed to t-SNE. We think because in the k-
means optimization algorithm the Euclidean distance is
used as a metric, it can provide a similar ground with RBF
kernel that is also based on Euclidean distance. But RBF
kernel provides an inﬁnite feature space that we cannot
visualize easily. Also, the intention of the experiment is to
show that similar vectors of tf -simhashing are quantiﬁed
similarly and tf -simhashing is meaningful.

More precisely, tf -simhashing of the dataset (here 17824
= 2×8912) benign and malware samples) are clustered into
2400 clusters (1200 centroids per class). So, the input of
the k-means function is a matrix of size 17824×1024 and
the output is a matrix of size 2400×1024. Effectively, we
use k-means as a vector quantisation algorithm, yielding
on average, one codebook per about 7.4 vectors ( 17824
2400 =
7.43). Our experiment shows the 2400-vector representation
provides a good visual picture to understand the dataset.
The matrix of 2400×1200 is fed to t-SNE to be mapped

testing and the remaining 16 families plus all the other
malware and benign sets for training. This routine was
repeated 5 times.

Figure 7 presents the number of total samples in each
family and false negative detection. We tested Malytics in
the balanced and imbalanced group of families. Also, one of
the groups consists of malware families (Fakeinst4, Adwo5,
SMSreg6, Lotoor7) with 4 different functions/intention. The
detection rate is similar for most families and the diversity
of malware function did not prevent detection.

The Adwo family is the least challenging for detection
by Malytics. This is to be expected since although Adwo
is not in the training set, other adware variants are used
in training. Fakeinst and Opfake were reported as similar
families and Fakeinst had been continued to be detected
while Opfake not 8. Malytics could detect Opfake better
than Fakeinst. It might because of the complexity of the
Fakeint that our model could not detect it well, as it was
also continued to disseminate over the net in the real world.
But, it might because of the number of sample in training
when another family is presented only in testing set.

The worst detection rate belongs to Plankton9 ( 80
344 =
23.3%). This family sits silently, collecting information and
sending it to a remote location. Its variants have a wide
range of actions10. Calleja [48] has particular analysed on
Plankton. They showed that this family is very similar to the
Nyleak and BaseBridge families. These two similar families
to Plankton have only 28 and 2 samples in DexShare. We
think that because, in training, there are few similar mal-
ware samples to the Plankton family, Malytics’ detection
rate is reduced for this family; however, the 76.7% hit rate
is still very good for this family in this setting.

Figure 6 presents ROC and respective AUC of the novelty
detection. With 2-3% FPR, the hit rate is more than 75%
for all four families that seems promising.

2) Random kernel: Malytics is based on the batch
learning algorithm. That is, the entire training set is fed
to Malytics for training in one batch. This process might
become computationally very expensive and demand a large
amount of memory for big data.

As mentioned in III, Malytics has the capability of
being trained on a random subset of training data while
still keeping the generalization performance. This random
selection has a negative impact on the performance of
Malytics. Figure 8 presents the f-score for both platforms
when the kernel matrix size varies from 10% to 100% of the
original kernel matrix. Similar to all previous evaluations,

4https://www.f-secure.com/v-descs/trojan android fakeinst.shtml
5https://www.sophos.com/en-us/threat-center/threat-analyses/adware-

and-puas/Android%20Adwo/detailed-analysis.aspx

6https://home.mcafee.com/virusinfo/virusproﬁle.aspx?key=8503749
7https://www.symantec.com/security response/writeup.jsp?docid=2012-

091922-4449-99

8https://threatpost.com/opfake-fakeinst-android-malware-variants-

continue-resist-detection-080712/76887/

9https://www.f-secure.com/v-descs/trojan android plankton.shtml
10https://www.avira.com/en/support-threats-

summary/tid/8996/threat/ANDROID.Plankton.C.Gen

Fig. 4: The detection rate of Malytics and the 19 malware
vendor for Mal2017, trained on Mal2016 and WinAppPE.

into two-dimensional space (2400×2) for visualization.

We obtain codebooks from malware and benign sets
separately. That is, 1200 centroid per class. Figure 5 shows
clustering the representation provides a meaningful result
and the codebooks are basically distributed similarly. This
means the vectors of tf -simhashing is meaningful and
can settle in closed distance when we optimize k-mean
with its Euclidean distance measure. We do not show
representation of feeding tf -simhashing to t-SNE directly
because it generates a meaningless distribution.

Fig. 5: t-SNE of WinPE versus Mal2016. WE clustered
each class with 1200 centroids for each class.

F. Case study and Further analysis of the scheme

1) Android family detection case: The scope of this
paper is not a particular malware family but covers the
range of malware disseminating all over the network. Our
datasets were collected with this purpose. However, looking
into some speciﬁc cases may provide better inside into the
model. We used the DexShare dataset for detail study.

As described in section IV, we tested the model on 20
new families. In brief, we chose groups of 4 families for

Fig. 6: The ROC curve for novelty detection on DexShare.
Each curve shows the ROC curve and AUC when groups 4
families have been fetched out from DexShare. First family
is the ﬁrst left 4 family in the ﬁgure 7 and so on.

Fig. 7: Total number of samples and False negative detec-
tion based on 4 families fetching out on DexShare. The
black bar separates each group of 4 families.

Android platform is more impacted than Windows. It is to
be expected because Windows PEs are all from Microsoft
while Android apps are developed by many different de-
velopers and therefore exhibits a greater variety.

Table VIII shows the run-time performance of Malytics
with random kernel sampling from 10% to 100% of the
kernel matrix. The training and testing time increases but
not sharply. In contrast, the f-score value increases sharply
initially (see ﬁgure 8). This shows that choosing more than
a threshold number of samples may provide the desired
performance with optimum memory and computation re-
quirements. This demonstrates Malytics’s scalability.

3) Run-time performance: Because Malytics is based
on static analysis, we compare it with MAMADROID [3].
The run-time performance of Malytics is not dependent on
the operating system while MAMADROID is proposed to
detect Android malware.

Fig. 8: The f1-score of Malytics trained on a random subsets
of the datasets. For Android, Drebin dataset was used and
for Windows, WinPE versus Mal2016.

The average execution time of MAMADROID for benign
samples in family and package modes are 27.3s and 33.83s
per sample respectively. MAMADROID says for 10000
apps that are being submitted to Google Play per day, the
model requires less than one and a half hours to complete
execution with 64 cores.

In our prototype of Malytics, on average, tf -simhashing
algorithm speed is 560KB per second. This includes extract-
ing a dex ﬁle out of the APK. Also, for the Drebin dataset
with 11110 samples (on average 3+0.36
2 = 1.68M B), the
training and testing time are 3.6s and 0.6s respectively, for
11110×0.8 = 0.4ms
each fold (from table VIII). That is,
0.6s
11110×0.2 = 0.27ms per
per sample to train the model and
sample to test an App.

3.6s

1.68M B

Based on the statistics of Drebin malware set and random
benign set collected from Google Play, Malytics requires,
0.560M B/Sec = 3 second for each sample to
approximately,
hash and 0.27ms to detect. For 10000 apps, 30003 seconds
to complete execution with one core and 470 seconds with
64 cores. In short, Malytics needs less than 8 minutes to
complete execution for all the Google Play new samples
in a day. The speed of Malytics provides the possibility of
frequently training with new samples.

V. LIMITATIONS AND FUTURE WORK

The main limitation of Malytics is the amount of the
required memory. More precisely, the advantage of Malytics
batch learning technique is speed and mostly convexity;
nevertheless, the model needs to store all input samples as
a batch in memory. The learning process also requires a
considerable amount of memory to obtain the output layer
weights, of course, but only for big data. Also, for the
test phase, the kernel layer needs to keep all the training
samples. This intensiﬁes the memory issue and also makes
the test process directly dependent on the training set.

Malytics hashes the whole binary ﬁle into one vector.
This may not be effective for binary ﬁles that are partly
infected with malicious codes. To address this issue, hash-
ing windows of a binary ﬁle may help and is a potential
direction of future study.

Dataset

Drebin

WinPE vs Mal2016

Phase

Train
Test

Train
Test

L = N
10

L = N
20

L = N
30

L = N
40

L = N
50

L = N
60

L = N
70

L = N
80

L = N
90

L = N

0.12s
0.10s

0.09s
0.19s

0.15s
0.16s

0.35s
0.34s

0.29s
0.22s

0.78s
0.52s

0.58s
0.27s

1.50s
0.70s

0.80s
0.35s

2.40s
0.80s

1.20s
0.40s

3.70s
1.14s

1.75s
0.45s

5.30s
1.20s

2.35s
0.54s

7.20s
1.30s

3.20s
0.58s

9.60s
1.50s

3.60s
0.6s

11.6s
1.55s

TABLE VIII: The run-time performance of Malytics with randomly selected kernel matrix L ranging from 10% to 100%
of the kernel matrix N . The time is for each fold (i.e. 8888 training and 2222 test samples) of the 5-fold cross-validation.

Malytics relies on the static analysis of binary ﬁles and it
does not have any knowledge of the behavior of the binary.
Despite the computational expenses of dynamic analysis, it
can cover deﬁciencies of the static features of malware in
particular for obfuscated malware and more importantly for
advanced persistent attacks.

tf -simhashing visualization experiment suggests that k-
means might be used for feature learning the hashing dic-
tionary rather than random generation from a distribution.
Also, deep learning models have no theoretic underlying
with a random initialization layer. This may contribute to
deep learning models as well.

The dex ﬁle is the not the only source of information
in Android apps. The manifest ﬁle also contains critical
information. For Windows, PEs structure can be informative
if we could embed this information into the hashing algo-
rithm. Also, developing a feasible algorithm for larger n-
grams may improve the performance. Finally, an ensemble
of fast learning models is a potential direction of study for
future work.

VI. RELATED WORK

In addition to malware as a general concept, there are
novel systems to deal with particular types of malware
[49, 50]. In both cases, learning-based systems show very
promising results [51, 52, 53, 54].

For Android malware detection, Mariconti [3] proposed
a static-feature extraction model that could provide a very
good performance. A novelty of the work was the proposed
random variable based on Markov chain. The output was
fed to a feature extraction phase in which Principal Compo-
nent Analysis (PCA) [55] was used. At the end, each sample
ﬁle yeilds a vector of size 100,000 to be classiﬁed as either
benign or malware. Applying PCA to such feature space
requires a huge amount of memory to obtain the co-variance
matrix. Zhu [15] recently showed that rotational forest, as a
classiﬁer, has the capability of being applying for Android
malware detection. They also used static features.

Wuechner [14] used a compression-based graph min-
ing technique to detect Windows malware. They widely
evaluated the effect of classiﬁers on their scheme and
reported that all
the applied classiﬁers provide similar
results. Carlin [13] used the run-time opcodes of every
sample with signiﬁcantly different approach compared with
Wuechner [14] and still presented competitive results. Both
papers used dynamic analysis of Windows PEs. Dynamic
analysis of malware is more computationally expensive than

static analysis. Having said that, it is well-known to be
used in many anti-malware production due to its reliable
performance and capability to cope with obfuscated ﬁles.
Dynamic analysis of a malware does not inﬂuence the
vulnerability of machine learning because the feature space
can be still reverse engineered to craft an adversary. Very re-
cently, Stokes et al. [10] proposed a detection system using
dynamic analysis and they showed it is still vulnerability
to crafted adversarial attacks.

The tf -simhashing representation is a promising feature
representation [28]. Simhashing has also been used for mal-
ware detection and detecting similarity between data/ﬁles
[56, 57]. In both [28, 56], simhashing was used to represent
each ﬁle as an image which was then fed to a naive classiﬁer
or a CNN. Malware detection on the basis of visualization
is not restricted only to simhashing. Raff [16] proposed a
new feature representation to map any binary ﬁle into an
image and used CNN as the classiﬁer.

ELM shows very promising results for malware activity
detection and identiﬁcation of malicious packed executa-
bles. Kozi [37] presented a distributed ELM using NetFlow
data structure alongside the Apache Spark 11 framework
that provided good performance. Different types of ELM
have been applied for malicious packed executable identi-
ﬁcation [58].

VII. CONCLUSION

In this paper, we proposed a learning-based malware
detection model called ”Malytics”. This integrated model
comprises two layers of latent feature representation and a
layer for prediction. The ﬁrst layer is a hashing algorithm
(tf -simhashing) and we showed that it has a close relation
to the ﬁrst layer of the Extreme Learning Machine (ELM).
ELM is the output
layer of the proposed scheme. We
showed that having a layer to measure the similarity of
tf -simhashing before output layer strongly improves the
performance of the scheme. We used the RBF kernel for
the similarity measure.

We conducted comprehensive evaluations on Drebin,
DexShare, PEShare datasets and Malytics outperforms
different baselines including non-ensemble state-of-the-art
models. Drebin and DexShare are Android apps and PE-
Share is Windnows PEs. The dex ﬁle of Android apps
is informative enough to compete with related work. We
tested how well Malytics could perform on imbalanced
datasets, for novel family detection. Novelty detection was

11https://spark.apache.org/

organized in two different ways: particular family detection
and chronological novelty detection. We also evaluated the
speed and scalability of Malytics. It shows promising results
for large-scale data.

APPENDIX A
OPTIMIZATION

The dual problem can be optimized as follows:

∂LDualELM
∂βj

= 0 → βj =

N
(cid:88)

i=1

αi,jh(xi)T → β = HTα

∂LDualELM
∂ξj

= 0 → αi = Cξi, i = 1, ..., N

(13)

(14)

∂LDualELM
∂αj

= 0 → h(xi)β − tT

i + ξT

i = 0, i = 1, ..., N

(15)
Where αi = [αi,1, ..., αi,m]T and αi = [α1, ..., αN ]T .

With a bit of calculus, for β:

β = HT (cid:0) I
C

+ HHT)−1T

(16)

REFERENCES

[1] Av

test: Facts

and ﬁgures

-

security

report

2016/2017.

[Online]. Available: https://www.av-test.org/ﬁleadmin/pdf/security
report/AV-TEST Security Report 2016-2017.pdf

[2] M. Y. Wong and D. Lie, “Intellidroid: A targeted input generator for
the dynamic analysis of android malware.” in NDSS, vol. 16, 2016,
pp. 21–24.

[3] E. Mariconti, L. Onwuzurike, P. Andriotis, E. De Cristofaro, G. Ross,
and G. Stringhini, “MaMaDroid: Detecting Android Malware by
Building Markov Chains of Behavioral Models,” in ISOC Network
and Distributed Systems Security Symposiym (NDSS), San Diego,
CA, 2017.

[4] Z. Yang, M. Yang, Y. Zhang, G. Gu, P. Ning, and X. S. Wang,
“Appintent: Analyzing sensitive data transmission in android for
privacy leakage detection,” in Proceedings of the 2013 ACM SIGSAC
conference on Computer & communications security. ACM, 2013,
pp. 1043–1054.

[5] K. Rieck, T. Holz, C. Willems, P. D¨ussel, and P. Laskov, “Learning
and classiﬁcation of malware behavior,” in International Conference
on Detection of Intrusions and Malware, and Vulnerability Assess-
ment. Springer, 2008, pp. 108–125.

[6] U. Bayer, P. M. Comparetti, C. Hlauschek, C. Kruegel, and E. Kirda,
“Scalable, behavior-based malware clustering.” in NDSS, vol. 9.
Citeseer, 2009, pp. 8–11.

[7] S. Sabour, N. Frosst, and G. E. Hinton, “Dynamic routing between
capsules,” in Advances in Neural Information Processing Systems,
2017, pp. 3859–3869.

[8] Y. LeCun, Y. Bengio, and G. Hinton, “Deep learning,” nature, vol.

521, no. 7553, p. 436, 2015.

[9] S. J. Russell, P. Norvig, J. F. Canny, J. M. Malik, and D. D. Edwards,
Prentice hall Upper

Artiﬁcial intelligence: a modern approach.
Saddle River, 2003, vol. 2, no. 9.

[10] J. W. Stokes, D. Wang, M. Marinescu, M. Marino, and B. Bussone,
“Attack and defense of dynamic analysis-based, adversarial neural
malware classiﬁcation models,” arXiv preprint arXiv:1712.05919,
2017.

[11] B. Sch¨olkopf and A. J. Smola, Learning with kernels: support vector
machines, regularization, optimization, and beyond. MIT press,
2002.

[12] Y. Bengio, O. Delalleau, and N. L. Roux, “The curse of highly
variable functions for local kernel machines,” in Advances in neural
information processing systems, 2006, pp. 107–114.

[13] D. Carlin, P. O’Kane, and S. Sezer, “Dynamic analysis of malware
using run-time opcodes,” in Data Analytics and Decision Support
for Cybersecurity. Springer, 2017, pp. 99–125.

[14] T. Wuechner, A. Cislak, M. Ochoa, and A. Pretschner, “Leveraging
compression-based graph mining for behavior-based malware detec-
tion,” IEEE Transactions on Dependable and Secure Computing,
2017.

[15] H.-J. Zhu, Z.-H. You, Z.-X. Zhu, W.-L. Shi, X. Chen, and L. Cheng,
“Droiddet: Effective and robust detection of android malware using
static analysis along with rotation forest model,” Neurocomputing,
vol. 272, pp. 638–646, 2018.

[16] E. Raff, J. Barker, J. Sylvester, R. Brandon, B. Catanzaro, and
C. Nicholas, “Malware detection by eating a whole exe,” arXiv
preprint arXiv:1710.09435, 2017.

[17] E. Raff, R. Zak, R. Cox, J. Sylvester, P. Yacci, R. Ward, A. Tracy,
M. McLean, and C. Nicholas, “An investigation of byte n-gram
features for malware classiﬁcation,” Journal of Computer Virology
and Hacking Techniques, vol. 14, no. 1, pp. 1–20, 2018.

[18] J. Jang, D. Brumley, and S. Venkataraman, “Bitshred: feature hashing
malware for scalable triage and semantic analysis,” in Proceedings
of
the 18th ACM conference on Computer and communications
security. ACM, 2011, pp. 309–320.

[19] S. Dharmapurikar and J. W. Lockwood, “Fast and scalable pattern
matching for network intrusion detection systems,” IEEE Journal on
Selected Areas in communications, vol. 24, no. 10, pp. 1781–1792,
2006.

[20] E. A. Manzoor, S. Momeni, V. N. Venkatakrishnan, and L. Akoglu,
“Fast memory-efﬁcient anomaly detection in streaming heteroge-
neous graphs,” arXiv preprint arXiv:1602.04844, 2016.

[21] M. S. Charikar, “Similarity estimation techniques from rounding al-
gorithms,” in Proceedings of the thiry-fourth annual ACM symposium
on Theory of computing. ACM, 2002, pp. 380–388.

[22] G. S. Manku, A. Jain, and A. Das Sarma, “Detecting near-duplicates
for web crawling,” in Proceedings of the 16th international confer-
ence on World Wide Web. ACM, 2007, pp. 141–150.

[23] A. Gionis, P. Indyk, R. Motwani et al., “Similarity search in high
dimensions via hashing,” in VLDB, vol. 99, no. 6, 1999, pp. 518–529.
[24] A. Andoni and P. Indyk, “Near-optimal hashing algorithms for
approximate nearest neighbor in high dimensions,” in Foundations of
Computer Science, 2006. FOCS’06. 47th Annual IEEE Symposium
on.

IEEE, 2006, pp. 459–468.

[25] M. S. Uddin, C. K. Roy, K. A. Schneider, and A. Hindle, “On
the effectiveness of simhash for detecting near-miss clones in large
scale software systems,” in Reverse Engineering (WCRE), 2011 18th
Working Conference on.

IEEE, 2011, pp. 13–22.

[26] P.-T. Ho, H.-S. Kim, and S.-R. Kim, “Application of sim-hash
algorithm and big data analysis in spam email detection system,”
in Proceedings of the 2014 Conference on Research in Adaptive and
Convergent Systems. ACM, 2014, pp. 242–246.

[27] K. Han, B. Kang, and E. G. Im, “Malware analysis using visualized
image matrices,” The Scientiﬁc World Journal, vol. 2014, 2014.
[28] M. Youseﬁ-Azar, L. Hamey, V. Varadharajan, and M. D. McDonnell,
“Fast, automatic and scalable learning to detect android malware,”
in International Conference on Neural Information Processing.
Springer, 2017, pp. 848–857.

[29] Y. Bengio, Y. LeCun et al., “Scaling learning algorithms towards ai,”
Large-scale kernel machines, vol. 34, no. 5, pp. 1–41, 2007.
[30] Y. Cho and L. K. Saul, “Kernel methods for deep learning,” in
Advances in neural information processing systems, 2009, pp. 342–
350.

[31] A. G. Wilson, Z. Hu, R. Salakhutdinov, and E. P. Xing, “Deep kernel
learning,” in Artiﬁcial Intelligence and Statistics, 2016, pp. 370–378.
[32] A. Vedaldi and A. Zisserman, “Efﬁcient additive kernels via explicit
feature maps,” IEEE transactions on pattern analysis and machine
intelligence, vol. 34, no. 3, pp. 480–492, 2012.

[33] G. Huang, G.-B. Huang, S. Song, and K. You, “Trends in extreme
learning machines: A review,” Neural Networks, vol. 61, pp. 32–48,
2015.

[34] G. H. Golub and C. F. Van Loan, Matrix computations.

JHU Press,

2012, vol. 3.

[35] C. R. Rao and S. K. Mitra, “Generalized inverse of matrices and its

applications,” 1971.

[36] R. Penrose, “A generalized inverse for matrices,” in Mathematical
proceedings of the Cambridge philosophical society, vol. 51, no. 3.
Cambridge University Press, 1955, pp. 406–413.

Neural Computing and Applications, vol. 27, no. 1, pp. 93–100,
2016.

[37] R. Kozik, “Distributing extreme learning machines with apache spark
for netﬂow-based malware activity detection,” Pattern Recognition
Letters, vol. 101, pp. 14–20, 2018.

[38] G.-B. Huang, “An insight into extreme learning machines: random
neurons, random features and kernels,” Cognitive Computation,
vol. 6, no. 3, pp. 376–390, 2014.

[39] W.-Y. Deng, Y.-S. Ong, and Q.-H. Zheng, “A fast reduced kernel
extreme learning machine,” Neural Networks, vol. 76, pp. 29–38,
2016.

[40] G.-B. Huang, L. Chen, C. K. Siew et al., “Universal approximation
using incremental constructive feedforward networks with random
hidden nodes,” IEEE Trans. Neural Networks, vol. 17, no. 4, pp.
879–892, 2006.

[41] K. Allix, T. F. Bissyand´e, J. Klein, and Y. Le Traon, “Androzoo:
Collecting millions of android apps for the research community,” in
Mining Software Repositories (MSR), 2016 IEEE/ACM 13th Working
Conference on.

IEEE, 2016, pp. 468–471.
[42] D. Arp, M. Spreitzenbarth, M. Hubner, H. Gascon, K. Rieck, and
C. Siemens, “Drebin: Effective and explainable detection of android
malware in your pocket.” in NDSS, 2014.

[43] K. Grosse, N. Papernot, P. Manoharan, M. Backes, and P. McDaniel,
“Adversarial perturbations against deep neural networks for malware
classiﬁcation,” Proceedings of the 2017 European Symposium on
Research in Computer Security, Oslo, Norway, 2017.

[44] M. Sebasti´an, R. Rivera, P. Kotzias, and J. Caballero, “Avclass: A
tool for massive malware labeling,” in International Symposium on
Research in Attacks, Intrusions, and Defenses. Springer, 2016, pp.
230–253.

[45] C. Chen, C.-M. Vong, C.-M. Wong, W. Wang, and P.-K. Wong, “Ef-
ﬁcient extreme learning machine via very sparse random projection,”
Soft Computing, vol. 22, no. 11, pp. 3563–3574, 2018.

[46] P. Li, T. J. Hastie, and K. W. Church, “Very sparse random pro-
jections,” in Proceedings of the 12th ACM SIGKDD international
conference on Knowledge discovery and data mining. ACM, 2006,
pp. 287–296.

[47] L. v. d. Maaten and G. Hinton, “Visualizing data using t-sne,”
Journal of Machine Learning Research, vol. 9, no. Nov, pp. 2579–
2605, 2008.

[48] A. Calleja, A. Mart´ın, H. D. Men´endez, J. Tapiador, and D. Clark,
“Picking on the family: Disrupting android malware triage by forcing
misclassiﬁcation,” Expert Systems with Applications, vol. 95, pp.
113–126, 2018.

[49] A. Kharraz, S. Arshad, C. Mulliner, W. K. Robertson, and E. Kirda,
“Unveil: A large-scale, automated approach to detecting ran-
somware.” in USENIX Security Symposium, 2016, pp. 757–772.
[50] I. Gasparis, Z. Qian, C. Song, and S. V. Krishnamurthy,
“Detecting
android
from root
in 26th USENIX Security Symposium (USENIX
providers,”
Security 17). Vancouver, BC: USENIX Association, 2017, pp.
1129–1144. [Online]. Available: https://www.usenix.org/conference/
usenixsecurity17/technical-sessions/presentation/gasparis

learning

exploits

root

by

[51] A. Saracino, D. Sgandurra, G. Dini, and F. Martinelli, “Madam:
Effective and efﬁcient behavior-based android malware detection
and prevention,” IEEE Transactions on Dependable and Secure
Computing, 2016.

[52] D. Ucci, L. Aniello, and R. Baldoni, “Survey on the usage of
machine learning techniques for malware analysis,” arXiv preprint
arXiv:1710.08189, 2017.

[53] M. Egele, T. Scholte, E. Kirda, and C. Kruegel, “A survey on
automated dynamic malware-analysis techniques and tools,” ACM
computing surveys (CSUR), vol. 44, no. 2, p. 6, 2012.

[54] S. Wang, Q. Yan, Z. Chen, B. Yang, C. Zhao, and M. Conti,
“Detecting android malware leveraging text semantics of network
ﬂows,” IEEE Transactions on Information Forensics and Security,
vol. PP, no. 99, pp. 1–1, 2017.

[55] S. Wold, K. Esbensen, and P. Geladi, “Principal component analysis,”
Chemometrics and intelligent laboratory systems, vol. 2, no. 1-3, pp.
37–52, 1987.

[56] K. Han, J. H. Lim, and E. G. Im, “Malware analysis method using
visualization of binary ﬁles,” in Proceedings of the 2013 Research
in Adaptive and Convergent Systems. ACM, 2013, pp. 317–321.

[57] C. Sadowski and G. Levin, “Simhash: Hash-based similarity detec-

tion,” 2007.

[58] P. Xie, X. Liu, J. Yin, and Y. Wang, “Absent extreme learning ma-
chine algorithm with application to packed executable identiﬁcation,”

