Parametric analyses of attack-fault trees

´Etienne Andr´e
Universit´e Paris 13, LIPN, CNRS, F-93430, Villetaneuse, France
JFLI, CNRS, Tokyo, Japan / National Institute of Informatics, Tokyo, Japan

Didier Lime
´Ecole Centrale de Nantes, LS2N, CNRS,
UMR 6004, Nantes, France

Mathias Ramparison
Universit´e Paris 13, LIPN, CNRS,
UMR 7030, F-93430 Villetaneuse, France

Mari¨elle Stoelinga
Formal Methods and Tools, University of Twente,
The Netherlands

9
1
0
2

y
a
M
8

]

R
C
.
s
c
[

3
v
6
3
3
4
0
.
2
0
9
1
:
v
i
X
r
a

Abstract—Risk assessment of cyber-physical systems, such
as power plants, connected devices and IT-infrastructures has
always been challenging: safety (i. e., absence of unintentional
failures) and security (i. e., no disruptions due to attackers) are
conditions that must be guaranteed. One of the traditional tools
used to help considering these problems is attack trees, a tree-
based formalism inspired by fault trees, a well-known formalism
used in safety engineering. In this paper we deﬁne and implement
the translation of attack-fault trees (AFTs) to a new extension
of timed automata, called parametric weighted timed automata.
This allows us to parametrize constants such as time and discrete
costs in an AFT and then, using the model-checker IMITATOR, to
compute the set of parameter values such that a successful attack
is possible. Using the different sets of parameter values computed,
different attack and fault scenarios can be deduced depending on
the budget, time or computation power of the attacker, providing
helpful data to select the most efﬁcient counter-measure.

Index Terms—security, attack-fault trees, parametric timed

automata, IMITATOR

I. INTRODUCTION

In the past few years, the range of security breaches in
the security of organizations has become larger and larger.
The process of unifying them by determining relations and
consequences between separated events has become more
difﬁcult: how to relate the presence of solid oxygen in a
helium tank in SpaceX rocket Falcon 9 to its the explosion
during ﬁring tests? What is the cost for the attacker and
the damages caused to SpaceX manufacturing plants? One
of the tools available to help structure risk assessments and
security analyses is attack trees, recommended, e. g., by NATO
Research and Technology Organisation (RTO) [NAT08] and
OWASP (Open Web Application Security Project) [OWA13].
Attack trees [Sla+98] were formalized in [Kor+10] as a popular
and convenient formalism for security analysis (see [KPS14]
for a survey) and are inspired by fault trees [FMC09; RS15]

This manuscript is the extended version of the manuscript of the same
name published in the proceedings of the 19th International Conference
on Application of Concurrency to System Design (ACSD 2019). The ﬁnal
version is available at https://ieeexplore.ieee.org/. This work is partially
supported by the ANR national research program PACS (ANR-14-CE28-
0002), the PHC Van Gogh project PAMPAS, by STW under the project
15474 SEQUOIA, KIA KIEM project 628.010.006 StepUp, the EU under
the project 102112 SUCCESS and ERATO HASUO Metamathematics for
Systems Design Project (No. JPMJER1603), JST.

a well-known formalism used in safety engineering. Bottom-
up computation for a single parameter (e. g., cost, probability
or time of an attack), can be performed directly on attack
trees [Bag+12]. Attack trees and fault trees are quite similar
but differ on their gates and/or goals [Bag+12; Kor+14]. Both
are constructed with leaves that model component and attack
step failures or successes that propagate through the system
via gates. While fault trees focus on safety properties, attack
trees considerate skills, resources and risk appetite possessed
by an attacker performing actions. Attack-fault trees (AFTs)
[KS17] combine safety properties from fault trees and security
conditions from attack trees; therefore gates of both fault trees
and attack trees are used in this formalism.

Quantitative analysis of AFTs with multiple quantitative
annotations on AFTs like cost, time, failure probabilities—
which can functionally be dependent on each other—evaluates
risks and helps to determine the most risky scenarios and
therefore to select the most effective counter-measures.

a) Contribution: In this work, we study a more abstract
version of the security problem, and we propose an approach
to synthesize times and costs necessary to individual actions
in order to perform a successful attack or individual failures
causing the failure of the entire system. The global attack
time and cost can then be expressed as a combination of the
parametric unit costs. To this end, we propose a formalization
of attack-fault trees using an ad-hoc extension of parametric
timed automata called parametric weighted timed automata
(PWTAs). PWTAs can be seen as a generalization of para-
metric timed automata (PTAs) [AHV93] and weighted/priced
automata [Beh+01; ALP04] with only costs on transitions.

We implement our framework within the tool ATTop pre-
sented in [Kum+18], allowing to deﬁne AFTs in the Galileo
format, and provide an automated translation into the IMITA-
TOR input format [And+12].

As a proof of concept, we apply our framework to an attack
tree of [KS17] and an original attack-fault tree. With the help
of the parametric timed model checker IMITATOR, we are
able to synthesize constraints in several dimensions; further
we discuss induced possible attack and fault scenarios.

This enlarges the scope of quantitative analysis for AFTs by
parameterizing multiple annotations on the AFT at once such
as time, cost and damages and then compute for instance the

1

 
 
 
 
 
 
optimal combination of parameter values for the attack to fail
quickly while keeping damages to the system low.

b) Related work: Attack tree analysis has been studied
timed automata [KRS15;
through lattice theory [Kor+10],
KS17; Kum+18],
I/O-IMCs [KGS15; Arn+15], Bayesian
networks [GIM15], Petri nets [Dal+06], stochastic games
[ANP16; Her+16], etc. Uppaal has been used for model
transformations in [Sch+17] and in [HV06] UML sequence
diagrams are manually transformed into timed automata mod-
els. [KS17] especially tackles the problem of multiple complex
risk metrics and attacker proﬁles, in a probabilistic and timed
formalism that can be computed and analyzed using stochas-
tical model-checking [RS14] and Uppaal SMC [Dav+15].
AFTs are modeled in the Galileo format and translated with
the tool ATTop [Kum+18] into stochastic timed automata
[Dav+11].

However, synthesis of multidimensional parameters (time,
cost for the attacker, damages for the organization...) at once
for fully timed systems is not treated in the previously cited
works, and these works require testing one by one a set of
possible attribute values for an AFT.

Besides, attack-defense trees are one of the most well-
studied extensions of attack trees and new analysis methods
are still developed [Kor+14; KW18].

In a completely different area, asynchronous hardware cir-
cuits’ gates were translated into (parametric) timed automata
in [Che+09]; our translation of AFTs gates into PWTAs syn-
chronized using parallel composition shares some similarities
with that approach.

c) Outline: We recall attack-fault trees in Section II. We
then introduce the formalism of parametric weighted timed
automata in Section III. Our translation from AFTs to PWTAs
is given in Section IV. Then, we describe our implementation
in Section V and report on experiments in Section VI. We
conclude by discussing future works.

II. ATTACK-FAULT TREES

Attack-fault trees (AFTs) model how a safety or security
goal can be reﬁned into smaller sub-goals, represented as
gates, until no further reﬁnement is possible, represented as
leaves. The leaves of the tree model are either basic component
failures (BCF) or basic attack steps (BAS). Since subtrees
can be shared in the literature (see e. g., [KS17]), AFTs are
actually directed acyclic graphs, rather than trees. In this
paper, we consider only trees without shared gates or leaves.
Safety is compromised with the failure of a BCF, i. e., without
any outside spark action. Security is compromised when an
outside attacker causes the activation of a BAS. Following the
terminology of [KS17], in this paper write that a gate or a
leaf is disrupted if the output is true i. e., it succeeds, and
fails otherwise. A success event (disruption) models the fact
that a component (gate or leaf) is compromised i. e., the attack
is successful or the component fails. In contrast, a fail event
models the robustness of the component against an attacker
through a BAS, or a BCF.

Figure 1: From left to right: AND, SAND, PAND, OR, SOR,
XOR, FDEP, SPARE, VOT(k/n) gates

k/n

A. AFT leaves

AFT leaves are equipped with an execution time and a rich
cost structure that includes the cost incurred by an attacker and
the damage inﬂicted on the organization. In contrast to [RS15;
KS17] where BCF and BAS are equipped with probability
distributions, we consider both BCF and BAS as parametric
time-dependent events. This allows us to compute a range
of cost values, damages values and time intervals at once in
order to perform operations such as optimum time values for
a counter-measure while keeping damage to the organization
low, and cost for the attacker high.

B. AFT gates

In order to model complex scenarios with multiple leaves,
BCF and BAS have to be composed. For this purpose, log-
ical gates are used that output either the propagation of a
disruption, or not. Gates take as an input either leaves or
outputs from gates in their subtrees. Logical gates used in
AFTs are taken from both dynamic fault trees and attack trees:
AND, PAND, SAND, OR, SOR, FDEP, SPARE, VOT(k/n),
depicted in Fig. 1. These gates are the translatable ones in
ATTop [Kum+18] from the Galileo format. We also added
the XOR gate to improve our modeling capabilities.

AND gate propagates a disruption (i. e.,, it synchronizes
a success event [KS17]) if all of its children are disrupted,
regardless of the order of disruption. Children are activated
initially by the AND. Children of a SAND gate are activated
sequentially from left to right. After the success (disruption) of
the leftmost child, the second left most child is activated, and
so on until the disruption of rightmost child. If all children are
disrupted, the SAND gate is disrupted. However, if any child
fails (to be disrupted), the SAND gate directly fails. SAND
gate is a speciﬁc gate of attack trees. Compared with SAND
gate, all children of a PAND gate are activated initially when
the PAND gate is activated. The rest of the execution is similar
to a SAND gate, and propagates a disruption if all children are
disrupted from left to right (which in contrast is not mandatory
for an AND gate), otherwise the PAND gate fails.

OR gate propagates a disruption if at

least one of its
children is disrupted. Children are activated initially by the
OR gate. Similarly to a SAND gate, children of a SOR gate
are activated sequentially after the termination of the previous
one and from left to right. It propagates a disruption when one
of its children is disrupted, otherwise if all children fail the
SOR gate fails. XOR gate propagates a disruption if one of
its children is disrupted and the other one fails.

FDEP (functional dependency) gate consists of a trigger
event and several dependent events, and is a speciﬁc gate of

2

fault trees. When the trigger event occurs, all its dependent
BCF events are disrupted (i. e., the failure of the power sup-
ply automatically deactivate the alarm and security cameras,
therefore the BCFs are successful).

SPARE gate is similar to SAND, but is a speciﬁc gate
for fault events while SAND gate is used for attack events.
SPARE gate consists of one primary BCF and several sec-
ondary BCF which are activated sequentially. If the primary
BCF is disrupted (i. e.,
the component fails), a secondary
becomes primary. If no BCFs are left (they all are disrupted),
SPARE gate propagates a disruption.

VOT(k/n) gate is similar to OR gate and consists of n ∈ N
children initially activated. VOT(k/n) gate is disrupted when k
of its n children are disrupted.

III. PARAMETRIC WEIGHTED TIMED AUTOMATA
Let N, Q, Q+, and R+ denote the set of non-negative
integers, rationals, non-negative rationals and non-negative
reals, respectively.

We assume a set C = {x1, . . . , xH } of clocks, i. e., real-
valued variables that evolve at the same rate. A clock valuation
is a function ν : C → R+. We write (cid:126)0C for the clock valuation
assigning 0 to all clocks. Given d ∈ R+, ν + d denotes the
valuation s.t. (ν + d)(x) = ν(x) + d, for all x ∈ C. Given
R ⊆ C, we deﬁne the reset of a valuation ν, denoted by
[ν]R, as follows: [ν]R(x) = 0 if x ∈ R, and [ν]R(x) = ν(x)
otherwise.

We assume a set TP = {p1, . . . , pJ } of timing parameters,
i. e., unknown timing constants. A timing parameter valuation
tv is a function tv : TP → Q+. We assume (cid:46)(cid:47) ∈ {<, ≤, =
, ≥, >}. A guard g is a constraint over C ∪ TP deﬁned by a
conjunction of inequalities of the form x (cid:46)(cid:47) d, or x (cid:46)(cid:47) p with
x ∈ C, d ∈ N and p ∈ TP. Given g, we write ν |= tv(g)
if the expression obtained by replacing each x with ν(x) and
each p with tv(p) in g evaluates to true.

i aiwi + (cid:80)

We assume a set W = {w1, . . . , wM } of weights. A weight
valuation µ is a function µ : W → Q. We write (cid:126)0W for
the weight valuation assigning 0 to all weights. We assume a
set WP = {q1, . . . , qN } of weight parameters, i. e., unknown
weight constants. A weight parameter valuation wv is a
function wv : WP → Q.1 A linear arithmetic expression
over W ∪ WP is (cid:80)
j bjqj + c, where wi ∈ W,
qj ∈ WP and ai, bj, c ∈ Q. Let LA(W ∪ WP) denote the
set of arithmetic expressions over W and WP. A parametric
weight update is a partial function α : W (cid:57) LA(W ∪ WP).
That is, we can assign a weight to an arithmetic expression
of parametric weights and other weight values, and rational
constants. Given a weight valuation µ, a parametric weight
update α and a weight parameter valuation wv, we need an
evaluation function eval wv(α, µ) returning a weight valuation,
and deﬁned as follows:
(cid:40)

eval wv(α, µ)(w) =

µ(w)
µ(wv(α(w)))

if α(w) is undeﬁned
otherwise

1Observe that, in contrast to timing parameters that should be non-negative
(which is usual for parametric timed automata), our weight parameters may
be negative.

3

where µ(wv(α(w))) denotes the replacement within the linear
arithmetic expression α(w) of all occurrences of a weight
parameter qi by wv(qi), and of a weight variable wj with
its current value µ(wj). Observe that this replacement gives
a rational constant, therefore eval wv(α, µ) is indeed a weight
valuation W → Q. That is, eval wv(α, µ) computes the new
(non-parametric) weight valuation obtained after applying to µ
the partial function α valuated with wv.

Parametric timed automata (PTA) extend timed au-
tomata [AD94] with timing parameters within guards and
invariants in place of integer constants [AHV93]. We extend
further PTA with (discrete) rational-valued weight parameters,
giving birth to parametric weighted timed automata (PWTA).

Deﬁnition 1. A parametric weighted timed automaton
(PWTA) A is a tuple A = (Σ, L, l0, F, C, TP, W, WP, I, E),
where:

1) Σ is a ﬁnite set of synchronization actions,
2) L is a ﬁnite set of locations,
3) l0 ∈ L is the initial location,
4) F ⊆ L is the set of accepting locations,
5) C is a ﬁnite set of clocks,
6) TP is a ﬁnite set of timing parameters,
7) W is a ﬁnite set of weights,
8) WP is a ﬁnite set of weight parameters,
9) I is the invariant, assigning to every l ∈ L a guard I(l),
10) E is a ﬁnite set of edges e = (l, g, a, R, α, l(cid:48)) where l, l(cid:48) ∈
L are the source and target locations, g is a guard, a ∈ Σ,
R ⊆ C is a set of clocks to be reset, and α : W (cid:57)
LA(W ∪ WP) is a parametric weight update.

Given a timing parameter valuation tv and a weight param-
eter valuation wv, we denote by tv|wv(A) the non-parametric
structure where all occurrences of a timing parameter pi have
been replaced by tv(pi), and all occurrences of a weight
parameter qj have been replaced by wv(qj). The result-
ing structure can be seen as an extension of a parametric
weighted/priced timed automaton [Beh+01; ALP04] with only
rational weights on edges.2 However, our structure goes be-
yond a simple parametric extensions of weighted/priced timed
automata, for two reasons:

1) we allow multiple weights;
2) we allow to not only increment weight values over a path,
but also perform more complex operations on that weight,
notably incrementing it with another weight value, which
is clearly not possible in [Beh+01; ALP04].

Note that, if we restrict our parametric weight update function
to expressions of the form α(wi) = wi + z, where z is either
a weight parameter or a rational constant, then our formalism
is exactly the parametric extension of (the discrete “switch”
weight part of) [Beh+01; ALP04].3

2In [ALP04] cost is deﬁned as the sum of each discrete cost on transitions
(switch cost) plus the time spent in a location multiplied by an integer rate
(duration cost), resulting in a rational value. Here, we omit the duration costs.
3Technically, as weighted/priced timed automata use integer constants,
a rescaling of the constants is necessary: by multiplying all constants in
tv|wv(A) by the least common multiple of their denominators, we obtain
an equivalent (integer-valued) weighted/priced timed automata.

compromise_IoT_device

access_home_network

exploit_software_vulnerability_in_IoT_device
10–11

cost = 60 US$, duration = 1 hour

0–10
get_credentials

cost = 40 US$,
duration = 10 hours

gain_access_to_private_networks

access_LAN

access_WLAN

11–11.5
run_malicious_script

cost = 50 US$
duration = 0.5 hour

find_LAN_access_port

spoof_MAC_address

find_WLAN

0–5

0–2
break_WPA_keys

cost = 20 US$,
duration = 1 hour

cost = 30 US$,
duration = 0.5 hour

cost = 2 US$,
duration = 5 hours

cost = 80 US$,
duration = 2 hours

Figure 2: Attack Tree modeling the compromise of an IoT device from [Sch+17]. Leaves are equipped with the cost and time
required to execute the corresponding step. The parts of the tree attacked in a successful attack are indicated by a darker color,
with start and end times for the steps in this attack denoted in red.

In addition, our formalism shares some similarities with the
statically parametric timed automata of [Wan00], where timed
automata are extended with parameters that can only be used
in guards, but not compared to clocks. In contrast, our weight
parameters can only be used in updates, and not in guards; in
addition, we also feature the timing parameters of [AHV93]
that can be compared to clocks.

l1

press
x := 0
y := 0
w := 2e

serve
y = p2

l2

prepare
y = p1

l3

press
y ≤ 5 ∧ x > 1
x := 0
w := w + q

Figure 3: A PWTA modeling a coffee machine

Example 1. In the PWTA in Fig. 3, we have the following
elements: L = {l1, l2, l3}, l0 = l1 (also the unique element
of F ), C = {x, y}, and Σ = {press, prepare, serve}, with the
set TP = {p1, p2} and weights W = {w}, WP = {q}. There
are four edges:

• e1 = (cid:104)l1, g, a, R, l2(cid:105) where R sets both x, y to 0, α is

w = 2e,

• e2 = (cid:104)l2, g, a, R, l2(cid:105) where g is y ≤ 5 ∧ x > 1 and R

sets x to 0, α is w := w + q,

• e3 = (cid:104)l2, g, a, R, l3(cid:105) where g is y = p1 and
• e4 = (cid:104)l3, g, a, R, l1(cid:105) where g is y = p2.

Let us now deﬁne the concrete semantics of PWTA as
the union over all timing parameter and weight parameter
valuations.

Deﬁnition 2 (Semantics of a valuated PWTA). Given a PWTA
A = (Σ, L, l0, F, C, TP, W, WP, I, E), a timing parameter
valuation tv, and a weight parameter valuation wv, the se-
mantics of tv|wv(A) is given by the timed transition system
(TTS) (S, s0, →), with

• S = {(l, ν, µ) ∈ L × RH
• s0 = (l0,(cid:126)0C,(cid:126)0W),
• → consists of the discrete and (continuous) delay transi-

+ × QM | ν |= tv(I(l))},

tion relations:

1) discrete

transitions:

(l, ν, µ)
if
(l, ν, µ), (l(cid:48), ν(cid:48), µ(cid:48)) ∈ S, and there exists e =
(l, g, a, R, α, l(cid:48)) ∈ E, such that ν |= tv(g), ν(cid:48) = [ν]R,
and µ(cid:48) = eval wv(α, µ)(w);

e(cid:55)→ (l(cid:48), ν(cid:48), µ(cid:48)),

2) delay transitions: (l, ν, µ) d(cid:55)→ (l, ν + d, µ), with d ∈

R+, if ∀d(cid:48) ∈ [0, d], (l, ν + d(cid:48), µ) ∈ S.

That is, a state is a triple made of the current location, the
current (non-parametric) clock valuation, and the current (non-
parametric) weight valuation. The clock valuations evolve
naturally as in timed automata, while the current weight
evolves according to the weight update function.

Moreover we write (l, ν, µ)

(e,d)
−→ (l(cid:48), ν(cid:48), µ(cid:48)) for a combi-
nation of a delay and discrete transition if ∃ν(cid:48)(cid:48) : (l, ν, µ) d(cid:55)→
(l, ν(cid:48)(cid:48), µ) e(cid:55)→ (l(cid:48), ν(cid:48), µ(cid:48)). Given tv|wv(A) with concrete seman-
tics (S, s0, →), we refer to the states of S as the concrete states
of tv|wv(A). A run of tv|wv(A) is an alternating sequence
of concrete states of tv|wv(A) and pairs of edges and delays

4

starting from the initial state s0 of the form s0, (e0, d0), s1, · · ·
with i = 0, 1, . . . , ei ∈ E, di ∈ R+ and (si, ei, si+1) ∈ →.

Example 2. A concrete execution of the PWTA tv|wv(A) of
Example 1 with w = 2e, wv(q) = 0.5e, tv(p1) = 5 and
tv(p2) = 8 is

(l1, (0, 0), (0))
(l2, (0, 1.5), (2.5))
(l3, (2.5, 5), (3))

(serve,3)

(press,2)
(l2, (0, 0), (2))
−→
(press,1)
−→ (l2, (0, 2.5), (3))

(press,1.5)
−→
(prepare,2.5)
−→

−→ (l1, (5.5, 8), (2.5)).
Note that no coffee can be served if tv(p1) = 8 and

tv(p2) = 5.

Remark 1. Despite the name of weights (justiﬁed by our
context of measuring costs and damages), our parametric
weights are in fact sufﬁciently expressive to encode parametric
(rational-valued) data.

IV. TRANSLATION OF AFTS TO PTAS

A. Overview of the translation

We will model an attack-fault

tree using a network of
PWTAs that will synchronize along actions (using the usual
composition semantics). Each gate and each leaf (i. e., BAS
or BCF) will be modeled as a PWTA. Leaves PWTA have
a duration and a weight, while gates PWTA store the weight
value of their children to forward it to their parents. Therefore,
each gate PWTA maintains its own weight, and its value will
be added to that of their parents in case of success (thanks to
the parametric weight update).

All gates and leaves PWTAs initially synchronize their start
action—referred as activation in this paper—, and end with
either a success or fail synchronization action. After gates
synchronize their start action, they synchronize the start action
of their children.

Intuitively, the process is top-bottom-top: the top level gate
PWTA activates its children, which themselves activate their
children (if any), and so on until the leaves PWTAs at the
bottom of the attack-falt tree. Once a leaf PWTA terminates,
it synchronizes either its success or fail action. In case of
the leaf PWTA forwards its weight value to its
success,
parent, where this value is stored. When its parent gate PWTA
terminates, the gate PWTA synchronizes either a success or
a fail action. In case of success, the gate PWTA forwards its
weight value to its parent, and so on until the top-level gate
PWTA terminates.

If the top-level PWTA terminates in its success location,
the attack is successful. We apply the reachability synthesis
algorithm of PTAs on the success location in the top-level
PWTA, that is, we synthesize all valuations for which this
location is reachable: this gives us the success conditions of an
attack. The set of constraints on time and weight (such as cost
for the attacker, damages for the organization) that allowed this
attack to be successful are output by this analysis.

As a running example, we consider the attack tree in Fig. 2

taken from [Sch+17].

5

l1

start
x := 0

x ≤ 5
l2

l3

success
x ≥ 5
wparent := wparent + wleaf

fail
x ≥ 5

l4

Figure 4: PWTA translation of leaf that can reach the success
location in exactly 5 units of time, and of weight wleaf

B. Translation of leaves

A BAS/BCF is modeled as a PWTA with clocks and weights
(see Fig. 4). Note that in real life while a BAS needs to success
so the attack is possibly successful, a BCF needs to fail in
order to propagate a disruption (as in basic component failure).
However we consider in our models that both BAS and BCF
need to reach the success location. There is two paths in a
BAS/BCF PWTA, one that reaches the success location and
one that reaches the fail location. In case of success, its weight
is forwarded to and stored in its parent gate.

Example 3. The translation of leaf find_WLAN of Fig. 2 is
given in Fig. 9 in Appendix A.

C. Translation of gates

Concrete translations of SAND, AND, OR gates are given
time cannot
in Table I (yellow locations denote urgency:
elapse). We describe them and give examples in the following.
Other gates are similar.

a) AND: recall that an AND gate is disrupted if all of its
children are disrupted. It activates all of its children then waits
for their disruptions regardless of the order of the successes.
At any moment if one fails, the AND gate fails. If the success
action is synchronized, its parent weight wparent is updated:
the weight wAND carried by the AND gate is added to wparent.
Example 4. We give in Fig. 5b the PWTA corresponding to
the AND gate access_home_network of Fig. 2. When all
children are activated in the PWTA of Fig. 5b, there are four
paths leading to the fail state, while only two (success of the
two children in any order) leading to the success state. star-
tAND3 launches the AND gate access_home_network.
the BAS get_credential and the OR
Both children,
gate gain_access_to_private_networks are acti-
vated with the synchronization of the actions launchGetCred
and startOR. Unlike the SAND gate, AND gate waits for any
of its child to synchronize a success action. If successGetCred
is synchronized, it then will wait for successOR to go to the
location success. If failGetCred is synchronized, the automa-
ton will go to the location failing. When waiting for the action
successOR, if failOR is synchronized the automaton will also
go to the location failing. The other possibility (successOR
then successGetCred) is similar. When in location failing
it synchronizes the action failAND3, while if going to the
location success it will synchronize the action successAND3.

AND gate

A

B

SAND gate

A

B

C

OR gate

A

B

l5

successA

failB

successB

l1

startAND

l2

startA

l3

startB

l4

failA
failB

successB

failAND

lf

failA

successA

l6

ls

successAND
wparent += wAND

l7

l8

l1

startSAND

l2

startA

l3

successA

l4

l5

successB

l6

startB

startC

l7

successC

l8

ls

successSAND
wparent += wSAND

l9

failSAND

lf

l6

failOR

lf

failA

failB

failC

l5

failA

successB

failB

l4

successA
successB

l7

successOR

ls

wparent += wOR
successA

failA

failB

l8

l1

startOR

l2

startA

l3

startB

Table I: Translation rules of AND, SAND and OR gates to PWTA

If the success state is reached, the weight of its parent gate is
increased by its own weight.

b) SAND: recall that a SAND gate is disrupted if all its
children from left to right are disrupted sequentially from left
to right. It activates its leftmost child then waits for its success
or failure, then activates its second leftmost child and so on.
If the rightmost child succeeds, the SAND gate is disrupted.
If one child fails, the SAND gate fails. For a SAND gate
modeled as a PWTA with n children, there is only one path
leading to the success state, while there are n paths leading
to the fail state (one from each child). If the success action
is synchronized, its parent weight wparent
is updated: the
weight wSAND carried by the SAND gate is added to wparent.

Example 5. The top event of the attack tree in Fig. 2 is a
SAND gate. We give the PWTA corresponding to this SAND
in Fig. 5a. It synchronizes the action startSAND. Then it
activates its leftmost child access_home_network with
the action startAND3, which is an AND gate. If the action
successAND3 is synchronized, its second leftmost child is
activated with the action launchExploit. If the action success-
Exploit is synchronized, its third and last child is activated with
the action launchRunMScript. If the action successRunMScript

is synchronized, the action successSAND is synchronized. At
any moment, if one of its children fail and an action failAND3,
failExploit or failRunMscript is synchronized the automaton
goes to the location failing where the action failSAND is
synchronized. If the success state is reached, the weight of
its parent gate is increased by its own weight.

c) OR: OR gate initially activates all of its children. OR
gate is disrupted if at least one of its children is disrupted,
and fails if all of its children fail. Therefore in the case of two
children, one child can fail and the OR gate still propagates
a disruption if the other one succeeds right after. However, if
one child succeeds no need to wait for the second one and the
success action of the OR gate is synchronized. If the success
action is synchronized, its parent weight wparent is updated:
the weight wOR carried by the OR gate is added to wparent.
Example 6. The PWTA translating the only OR of Fig. 2 is
given in Fig. 10 in Appendix B.

D. Top-level automaton

Finally, we need to create an automaton that will activate
the ﬁrst top-event gate of the AFT. We call it rootTA. This
PWTA is the one that starts the chain reaction by activating

6

(b) Translation of the AND gate access_home_network

(a) Translation of the top-level SAND gate

Figure 5: SAND and AND gate

the top-event PWTA gate, which at its turn will activate its own
children and so on. It waits for the success or fail action of this
PWTA gate. In case of success, its weight has been updated
with the total weight value of the execution forwarded by the
top-event gate PWTA. This bottom-to-top addition stores in the
weight current cost root the total weight of the attack. The
rootTA also stores the total time spent since the ﬁrst activation
of the top-event PWTA (using an extra clock and parameter).

Example 7. We give in Fig. 6 the top-level PWTA for the AFT
in Fig. 2. It is very similar to a leaf PWTA. It activates the top-
level gate PWTA, then waits for its success or fail action. If the

7

l3

l4

successRoot
total cost = current cost root
abs time = total time

successSAND

l1

startSAND

l2

failSAND

l5

failROOT

l6

Figure 6: The rootTA

success action is synchronized, its weight has been updated to
the total weight value of the execution and is checked against
an additional parameter total cost so IMITATOR outputs this
current cost root value. Likewise, the clock abs time which
is never reset since the activation of rootTA is checked against
a timing parameter total time. Therefore IMITATOR outputs
the total time of execution.

V. IMPLEMENTATION OF THE TRANSLATION

A. IMITATOR

IMITATOR [And+12] is a parametric model checker taking
as input an extension of networks parametric timed automata
extended with synchronization, stopwatches and discrete vari-
ables. IMITATOR supports global (shared) discrete rational-
valued variables, that can be either concrete (in which case
they are syntactic sugar for an unbounded number of loca-
tions), or symbolic, in which case they can be updated to or
compared with parameters. While IMITATOR technically con-
siders a single type of parameters (where symbolic variables
can be compared or even updated to timing parameters), our
weight parameters are never compared to timing parameters,
and this setting can be considered as a subclass of the
IMITATOR expressiveness.

IMITATOR implements several synthesis algorithms, no-
tably reachability synthesis (EFsynth), that attempts to syn-
thesize all parameter valuations for which a given location
is reachable—which is the algorithm we use here. IMITATOR
relies on the symbolic semantics of parametric timed automata
(see e. g., [And+09; JLR15]), where symbolic states are made
of a discrete location, and a constraint over the clocks and
parameters. The weight parameters are added to this symbolic
semantics in a straightforward manner, with symbolic states
enriched with linear constraints over weight parameters.

Note that, while parametric timed automata are highly un-
decidable (see [And19] for a survey), and while our parametric
extension adds a new layer of complexity, all analyses termi-
nate with an exact result (sound and complete) because our
models are acyclic: our AFTs are trees, and their translation
yields structurally acyclic PWTAs. As a consequence,
the
symbolic semantics of these PWTAs can be represented as
a ﬁnite structure, and the analysis is guaranteed to terminate.

B. Translation from AFTs to PWTAs

The translation from AFTs to PWTAs was implemented
within the framework of ATTop [Sch+17]. The existing soft-
ware ATTop can take as input a Galileo formatted ﬁle. This
format is pretty easy to use and to understand. The code in
Fig. 7 expresses an attack-fault tree of one OR gate named A,
with two children B and C. The BAS B takes between 50
and 100 units of time to terminate, and costs $50 to the
attacker. The BAS C takes between 30 and 70 units of time
to terminate, and costs $30 to the attacker.

ATTop takes as an input a Galileo ﬁle and parses it to
represent it as an attack-fault tree meta-model (ATMM) (see
[Sch+17, Section 3], and Fig. 12 in Appendix C for a screen-
shot of the tool). Then, different translations are available:

t o p l e v e l ”A” ;
1
2 ”A” or ”B” ”C ” ;
3 ”B” mintime =50 maxtime =100 c o s t = 5 0 ;
4 ”C” mintime =30 maxtime =70 c o s t = 3 0 ;

Figure 7: Example of Galileo attack-tree

one quite interesting is the translation into an Uppaal ﬁle,
for instance a network of stochastic timed automata [KS17].
ATTop takes the ATMM and translates it in its Uppaal meta-
model, then serializes it into an Uppaal formatted ﬁle.
In
our approach we directly translate the representation of the
ATMM into an IMITATOR formatted ﬁle, using the Epsilon
Generation Language (EGL) [Ros+08]. This translation is a
very efﬁcient way to obtain AFTs modeled using PWTAs:
designing manually a PWTA model from an AFT is very
tedious to achieve, while deﬁning an AFT within the Galileo
syntax is simple.

Once the PWTA obtained, we synthesize using IMITATOR
all parameter valuations for which the success location of
the rootTA can be reached (using EFsynth). These sets of
parameter values will help us to determine attack and fault
scenarios in the following section.

VI. CASE STUDIES

As a proof of concept, we apply our approach to an
attack tree from the literature and an original attack-fault tree.
Experiments were conducted with IMITATOR 2.10.4 “Butter
Jellyﬁsh”,4 on a 2.4 GHz Intel Core i5 processor with 2 GiB
of RAM in a VirtualBox environment. Computation times
of parameter values ranges from 1 to 9 seconds with four
parameters.

A. Compromising an IoT device

We apply our approach to the AFT depicted in Fig. 2
taken from [Sch+17]. We choose to parametrize the cost of
ﬁnding a LAN access point (CostFindLAN AP) and the
maximum amount of time to break WPA keys (tMax Break)
of the AFT. This conﬁguration will describe which attack
(WLAN or LAN) is smarter for the attacker, depending on
their resources: ﬁnding a LAN access point can be difﬁcult
depending on the infrastructure security and perhaps social
if the attacker does not
engineering is needed. However,
have enough resources but a large amount of time (s)he can
spend time trying to break WPA keys. IMITATOR computes
several constraints on these parameters such that the attack is
successful.

Different constraints are possible representing possible time
and weight values s.t. an attack is possible. This is represented
as a disjunction of conjunctions of constraints on parameters.
For instance it can be a quick but very costly attack, or a long

4Sources, binaries, models and results are available at https://www.imitator.

fr/static/ACSD19PAT/

8

but cheap one; therefore different attack and fault scenarios
appear. The conjunction of constraints

2 ∗ tMax Break ≥ 23 ∧ CostFindLAN AP ≥ 0

∧CostFindLAN AP + 180 = total cost ∧ 2 ∗ total time = 23

Falcon 9 in september 20165. The AFT in Fig. 8 depicts
the different conﬁgurations that can eventually end up with
the explosion. The objective of this case-study is to show
that the explosion is more likely to be accidental, due to the
expensiveness of the BAS for the attacker who could attempt
a sabotage.

represents an attack that is very expensive for the attacker:
indeed, the total cost of the attack is at least $180 and fully
depends on the cost of ﬁnding a LAN access point. However,
the time spent on the attack is negligible and ﬁxed (11.5h).

In opposition, the constraint

2 ∗ tMax Break + 3 ≥ 2 ∗ total time

∧CostFindLAN AP ≥ 0

∧2 ∗ total time ≥ 23 ∧ total cost = 232

shows a an attack that will last at least 11.5h—that is, the
attacker does not exactly knows when (s)he will break the
WPA keys depending for instance of her/his computation
power—but with a ﬁxed cost of $232..

Contrarily to our initial intuition, the cost of this second
attack can be high above the ﬁrst one, as breaking the WPA
keys is quite costly ($80) in opposition with ﬁnding a LAN
access point. A smart attacker could choose, regardless of their
time and resources the ﬁrst attack through LAN access point.

The rocket carries a helium tank with three composite
overwrapped pressure vessels (COPVs) inside. One COPV
possibly had a manufacturing defect and buckles in its liner
and the carbon overwrap (AND gate). Afterwards (PAND gate)
liquid oxygen (LOx) can pool in these buckles and become
trapped when pressurized under the carbon overwrap, resulting
in a ﬂawed COPV. An other possibility is the presence of solid
oxygen (SOx) either due to the loading temperature of helium
or placed here intentionally by an attacker (OR gate).

These two conﬁgurations result in a compromised COPV.
When the COPV is compromised, a friction due to take-off
tests can start the rocket ignition (SAND gate).

BCFs have a duration representing the time taken until the
component failure. Damage is the cost for the organization
for having built a defective component, or the cost induced
when the component has failed. BASs have a cost for the
attacker to perform the attack, and a duration for the attack to
be successful.

We choose to parametrize the damages

induced to
the manufacturing facility by damage BuckleInInnerLiner,
and the cost of pooling solid oxygen near
the COPV,
cost SOXmaliciouslyIntroduced.

The constraint

13 ≥ total time ≥ 8

∧cost SOXmaliciouslyIntroduced ≥ 0
∧total damages ≥ 100

∧damage BuckleInInnerLiner + 100 = total damages

∧total cost = 1700

represents the attack using the malicious introduction of LOx
between the inner liner and the carbon overwrap of the COPV.
Clearly this attack is very costly ($1700) and assumes the
presence of these buckles. It is highly prejudicial to SpaceX
as the company may want to investigate the manufacturing
facility that produces COPV components.

The other attack, represented by the constraint

total time = 6

∧cost SOXmaliciouslyIntroduced ≥ 0

∧total damages = 0

∧damage BuckleInInnerLiner ≥ 0

Figure 8: AFT of SpaceX rocket explosion

∧total cost = cost SOXmaliciouslyIntroduced

B. SpaceX rocket Falcon 9 explosion

the cost of the attack is equal

shows that
to the cost of
introducing SOx near the COPV. The higher is the parameter
cost SOXmaliciouslyIntroduced, the higher is the cost of the

Our second case study is an adaptation of the anomaly
investigation that followed the explosion of SpaceX rocket

5SpaceX anomaly

anomaly-updates

update,

https://www.spacex.com/news/2016/09/01/

9

attack. We may assume this cost is high enough as SpaceX
surely secured its launch complex. Otherwise, an efﬁcient
counter-measure would be to ﬁnd means to increase this cost
for the attacker.
The constraint

cost SOXmaliciouslyIntroduced ≥ 0

∧total damage ≥ 150

∧damage BuckleInInnerLiner + 150 ≥ total damage

∧total time = 3 ∧ total cost = 0

represents the fact that buckles in the inner liner and in the
carbon overwrap of the COPV, and then LOx pooled under
the overwrap, lead to a complete failure of the system, i. e.,
the rocket explodes. In this scenario, there is in all likelihood
the damages for the manufacturing
no attacker. However,
facility can be huge if it is ﬂawed: SpaceX should probably
investigate in their manufacturing facilities in order to prevent
the production of other ﬂawed components.

Finally, the constraint

cost SOXmaliciouslyIntroduced ≥ 0

∧total damage = 100

∧damage BuckleInInnerLiner ≥ 0

∧3 ≥ total time ≥ 1 ∧ total cost = 0

shows that the explosion can be provoked by the presence
of SOx due to cold helium. This case is possible without any
attacker or component failure and is therefore fully accidental.
No damages are caused to SpaceX (excepted the cost of the
unusable rocket) or its suppliers.

These scenarios indicate that the rocket explosion is more
likely to be accidental, as the cost in both scenarios where
there is an attacker is very high. However, the worst case
indicates that SpaceX should investigate their production lines
to prevent other ﬂawed components, as well as the presence
of an attacker.

VII. CONCLUSION

We addressed the problem of formalizing attack-fault trees
in a more abstract framework allowing to cope with parametric
timings, costs and damages. We deﬁned and implemented a
translation from attack-fault trees to PWTAs (a new extension
of PTAs) that can be analyzed using the IMITATOR model-
checker. This translation allows us to deﬁne easily an AFT
using the Galileo syntax, and obtain as an output this AFT
modeled with PWTAs. Using IMITATOR, we synthesize all
parameter values such that there is a successful attack and/or a
system failure. Finally, obtaining a disjunction of convex sets
of parameter values allows us to deﬁne different attack and
fault scenarios. Therefore it helps selecting the most plausible
scenario and the most efﬁcient counter-measures.

Future works: In this paper, we only considered three
parameters: timing, cost and damage parameters. However,
it is trivial to split these parameters into more precise ones,
such as human damages (health and insurance) and material

damages caused by the attacker or the failure of the system:
an attack can be cheap for the attacker but
inﬂict many
kind of damages to the organization, as in our SpaceX case
study. Thanks to the vector of weights deﬁned in our PWTAs,
this would be immediate to consider in our framework and
implementation.

Moreover, extending our

framework to attack-defense

trees [Kor+14; Gad+16] is also on our agenda.

Finally, adding probabilities in order to create probabilis-
tic parametric attack-fault trees will be an interesting and
challenging future work. Indeed, in our SpaceX rocket case
study adding probabilities to the manufacturing defects of the
COPV on top of the damages inﬂicted to the company would
strengthen considerably our formalism.

ACKNOWLEDGEMENTS
We are thankful to Stefano Schivo and Enno J.J. Ruijters
from Twente University for their helpful advices concerning
meta-models and ATTop.

REFERENCES

Rajeev Alur and David L. Dill. “A theory of timed
automata”. In: Theoretical Computer Science 126.2
(Apr. 1994), pp. 183–235. ISSN: 0304-3975. DOI: 10.
1016/0304-3975(94)90010-8 (cit. on p. 3).
Rajeev Alur, Thomas A. Henzinger, and Moshe Y.
Vardi. “Parametric real-time reasoning”. In: STOC.
Ed. by S. Rao Kosaraju, David S. Johnson, and Alok
Aggarwal. San Diego, California, United States: ACM,
1993, pp. 592–601. ISBN: 0-89791-591-7. DOI: 10.1145/
167088.167242 (cit. on pp. 1, 3, 4).
Rajeev Alur, Salvatore La Torre, and George J. Pappas.
“Optimal paths in weighted timed automata”. In: The-
oretical Computer Science 318.3 (2004), pp. 297–322.
DOI: 10.1016/j.tcs.2003.10.038 (cit. on pp. 1, 3).
´Etienne Andr´e, Thomas Chatain, Emmanuelle Encre-
naz, and Laurent Fribourg. “An Inverse Method for
Parametric Timed Automata”. In: International Journal
of Foundations of Computer Science 20.5 (Oct. 2009),
pp. 819–836. DOI: 10 . 1142 / S0129054109006905 (cit. on
p. 8).
´Etienne Andr´e, Laurent Fribourg, Ulrich K¨uhne, and
Romain Soulat. “IMITATOR 2.5: A Tool for Ana-
lyzing Robustness in Scheduling Problems”. In: FM.
Ed. by Dimitra Giannakopoulou and Dominique M´ery.
Vol. 7436. Lecture Notes in Computer Science. Paris,
France: Springer, Aug. 2012, pp. 33–36. DOI: 10.1007/
978-3-642-32759-9 6 (cit. on pp. 1, 8).
´Etienne Andr´e. “What’s decidable about parametric
timed automata?” In: International Journal on Soft-
ware Tools for Technology Transfer 21.2 (Apr. 2019),
pp. 203–2019. DOI: 10.1007/s10009- 017- 0467- 0 (cit. on
p. 8).
Zaruhi Aslanyan, Flemming Nielson, and David
Parker. “Quantitative Veriﬁcation and Synthesis of
Attack-Defence Scenarios”. In: CSF. IEEE Computer
Society, 2016, pp. 105–119. DOI: 10.1109/CSF.2016.15
(cit. on p. 2).
Florian Arnold, Dennis Guck, Rajesh Kumar, and
Mari¨elle Stoelinga. “Sequential and Parallel At-
tack Tree Modelling”. In: SAFECOMP Workshops.
Vol. 9338. Lecture Notes
in Computer Science.
Springer, 2015, pp. 291–299. DOI: 10.1007/978- 3- 319-
24249-1 25 (cit. on p. 2).

[AD94]

[AHV93]

[ALP04]

[And+09]

[And+12]

[And19]

[ANP16]

[Arn+15]

10

[Bag+12]

[Beh+01]

[Che+09]

[Dal+06]

[Dav+11]

[Dav+15]

[FMC09]

[Gad+16]

[GIM15]

[Her+16]

[HV06]

[JLR15]

Alessandra Bagnato, Barbara Kordy, Per H˚akon Me-
land, and Patrick Schweitzer. “Attribute Decoration of
Attack-Defense Trees”. In: International Journal of
Secure Software Engineering 3.2 (2012), pp. 1–35. DOI:
10.4018/jsse.2012040101 (cit. on p. 1).
Gerd Behrmann, Ansgar Fehnker, Thomas Hune, Kim
Guldstrand Larsen, Paul Pettersson, Judi Romijn, and
Frits W. Vaandrager. “Minimum-Cost Reachability for
Priced Timed Automata”. In: HSCC. Ed. by Maria
Domenica Di Benedetto and Alberto L. Sangiovanni-
Vincentelli. Vol. 2034. Lecture Notes in Computer
Science. Rome, Italy: Springer, 2001, pp. 147–161.
ISBN: 3-540-41866-0. DOI: 10.1007/3- 540- 45351- 2 15
(cit. on pp. 1, 3).
R´emy Chevallier, Emmanuelle Encrenaz-Tiph`ene, Lau-
rent Fribourg, and Weiwen Xu. “Timed Veriﬁcation of
the Generic Architecture of a Memory Circuit Using
Parametric Timed Automata”. In: Formal Methods in
System Design 34.1 (Feb. 2009), pp. 59–81. DOI: 10 .
1007/s10703-008-0061-x (cit. on p. 2).
G.C. Dalton, Robert Mills, John Colombi, and R.A.
Raines. “Analyzing Attack Trees using Generalized
Stochastic Petri Nets”. In: July 2006, pp. 116–123. DOI:
10.1109/IAW.2006.1652085 (cit. on p. 2).
Alexandre David, Kim G. Larsen, Axel Legay, Mar-
ius Mikucionis, Danny Bøgsted Poulsen, Jonas van
Vliet, and Zheng Wang. “Statistical Model Checking
for Networks of Priced Timed Automata”. In: FOR-
MATS. Vol. 6919. Lecture Notes in Computer Science.
Springer, 2011, pp. 80–96. DOI: 10 . 1007 / 978 - 3 - 642 -
24310-3 7 (cit. on p. 2).
Alexandre David, Kim G. Larsen, Axel Legay, Mar-
ius Mikucionis, and Danny Bøgsted Poulsen. “Uppaal
SMC tutorial”. In: International Journal on Software
Tools for Technology Transfer 17.4 (2015), pp. 397–
415. DOI: 10.1007/s10009-014-0361-y (cit. on p. 2).
Igor Nai Fovino, Marcelo Masera, and Alessio De
Cian. “Integrating cyber attacks within fault trees”. In:
Reliability Engineering & System Safety 94.9 (2009),
pp. 1394–1402. DOI: 10.1016/j.ress.2009.02.020 (cit. on
p. 1).
Olga Gadyatskaya, Ren´e Rydhof Hansen, Kim Guld-
strand Larsen, Axel Legay, Mads Chr. Olesen, and
Danny Bøgsted Poulsen. “Modelling Attack-defense
Trees Using Timed Automata”. In: FORMATS. Ed. by
Martin Fr¨anzle and Nicolas Markey. Vol. 9884. Lecture
Notes in Computer Science. Quebec, QC, Canada:
Springer, 2016, pp. 35–50. DOI: 10 . 1007 / 978 - 3 - 319 -
44878-7 3 (cit. on p. 10).
Marco Gribaudo, Mauro Iacono, and Stefano Marrone.
“Exploiting Bayesian Networks for the Analysis of
Combined Attack Trees”. In: Electronic Notes in Theo-
retical Computer Science 310 (2015), pp. 91–111. DOI:
10.1016/j.entcs.2014.12.014 (cit. on p. 2).
Holger Hermanns, Julia Kr¨amer, Jan Krc´al, and
Mari¨elle Stoelinga. “The Value of Attack-Defence
Diagrams”. In: POST. Vol. 9635. Lecture Notes in
Computer Science. Springer, 2016, pp. 163–185. DOI:
10.1007/978-3-662-49635-0 9 (cit. on p. 2).
Martijn Hendriks and Marcel Verhoef. “Timed au-
tomata based analysis of embedded system architec-
tures”. In: IPDPS. IEEE, 2006. DOI: 10 . 1109 / IPDPS .
2006.1639422 (cit. on p. 2).
Aleksandra Jovanovi´c, Didier Lime, and Olivier H.
Roux. “Integer Parameter Synthesis for Real-Time Sys-
tems”. In: IEEE Transactions on Software Engineering

[KGS15]

[Kor+10]

[Kor+14]

[KPS14]

[KRS15]

[KS17]

[Kum+18]

[KW18]

[NAT08]

[OWA13]

[Ros+08]

[RS14]

[RS15]

41.5 (2015), pp. 445–461. DOI: 10 . 1109 / TSE . 2014 .
2357445 (cit. on p. 8).
Rajesh Kumar, Dennis Guck, and Mari¨elle Stoelinga.
Time Dependent Analysis with Dynamic Counter Mea-
sure Trees. Tech. rep. abs/1510.00050. CoRR, 2015
(cit. on p. 2).
Barbara Kordy, Sjouke Mauw, Sasa Radomirovic, and
Patrick Schweitzer. “Foundations of Attack-Defense
Trees”. In: FAST. Ed. by Pierpaolo Degano, Sandro
Etalle, and Joshua D. Guttman. Vol. 6561. Lecture
Notes in Computer Science. Pisa, Italy: Springer, 2010,
pp. 80–95. DOI: 10 . 1007 / 978 - 3 - 642 - 19751 - 2 6 (cit. on
pp. 1, 2).
Barbara Kordy, Sjouke Mauw, Sasa Radomirovic, and
Patrick Schweitzer. “Attack-defense trees”. In: Journal
of Logic and Computation 24.1 (2014), pp. 55–87. DOI:
10.1093/logcom/exs029 (cit. on pp. 1, 2, 10).
Barbara Kordy, Ludovic Pi`etre-Cambac´ed`es,
and
Patrick Schweitzer. “DAG-based attack and defense
modeling: Don’t miss the forest for the attack trees”.
In: Computer Science Review 13-14 (2014), pp. 1–38.
DOI: 10.1016/j.cosrev.2014.07.001 (cit. on p. 1).
Rajesh Kumar, Enno Ruijters, and Mari¨elle Stoelinga.
“Quantitative Attack Tree Analysis via Priced Timed
Automata”. In: FORMATS. Vol. 9268. Lecture Notes in
Computer Science. Springer, 2015, pp. 156–171. DOI:
10.1007/978-3-319-22975-1 11 (cit. on p. 2).
Rajesh Kumar and Mari¨elle Stoelinga. “Quantitative
Security and Safety Analysis with Attack-Fault Trees”.
In: HASE. IEEE, 2017, pp. 25–32. DOI: 10.1109/HASE.
2017.12 (cit. on pp. 1, 2, 8).
Rajesh Kumar, Stefano Schivo, Enno Ruijters, Bugra
Mehmet Yildiz, David Huistra, Jacco Brandt, Arend
Rensink, and Mari¨elle Stoelinga. “Effective Analy-
sis of Attack Trees: A Model-Driven Approach”. In:
FASE. Vol. 10802. Lecture Notes in Computer Science.
Springer, 2018, pp. 56–73. DOI: 10 . 1007 / 978 - 3 - 319 -
89363-1 4 (cit. on pp. 1, 2).
Barbara Kordy and Wojciech Widel. “On Quantitative
Analysis of Attack-Defense Trees with Repeated La-
bels”. In: POST. Ed. by Lujo Bauer and Ralf K¨usters.
Vol. 10804. Lecture Notes in Computer Science. April
14-20, 2018: Springer, 2018, pp. 325–346. DOI: 10.1007/
978-3-319-89722-6 14 (cit. on p. 2).
NATO Research and Technology Organisation (RTO).
Improving Common Security Risk Analysis. Tech. rep.
AC/323(ISP-049)TP/193. 2008 (cit. on p. 1).
OWASP. CISO AppSec Guide: Criteria for managing
application security risks. Tech. rep. 2013 (cit. on p. 1).
Louis M. Rose, Richard F. Paige, Dimitrios S. Kolovos,
and Fiona Polack. “The Epsilon Generation Lan-
guage”. In: ECMDA-FA. Ed. by Ina Schieferdecker and
Alan Hartman. Vol. 5095. Lecture Notes in Computer
Science. Berlin, Germany: Springer, 2008, pp. 1–16.
DOI: 10.1007/978-3-540-69100-6 1 (cit. on p. 8).
Anne Remke and Mari¨elle Stoelinga, eds. Proceed-
ings of the International Autumn School on Stochastic
Model Checking. Rigorous Dependability Analysis Us-
ing Model Checking Techniques for Stochastic Systems
(ROCKS 2012). Vol. 8453. Lecture Notes in Computer
Science. Vahrn, Italy: Springer, 2014. DOI: 10.1007/978-
3-662-45489-3 (cit. on p. 2).
Enno Ruijters and Mari¨elle Stoelinga. “Fault tree anal-
in modeling,
ysis: A survey of the state-of-the-art
analysis and tools”. In: Computer Science Review 15
(2015), pp. 29–62. DOI: 10 . 1016 / j . cosrev. 2015 . 03 . 001
(cit. on pp. 1, 2).

11

APPENDIX
A. Translation of leaf find_WLAN

[Sch+17]

[Sla+98]

[Wan00]

Stefano Schivo, Bugra M. Yildiz, Enno Ruijters,
Christopher Gerking, Rajesh Kumar, Stefan Dziwok,
Arend Rensink, and Mari¨elle Stoelinga. “How to Efﬁ-
ciently Build a Front-End Tool for UPPAAL: A Model-
Driven Approach”. In: SETTA. Vol. 10606. Lecture
Notes in Computer Science. Springer, 2017, pp. 319–
336. DOI: 10.1007/978-3-319-69483-2 19 (cit. on pp. 2, 4,
5, 8).
Chris Slater, O. Sami Saydjari, Bruce Schneier, and
Jim Wallner. “Toward a Secure System Engineering
Methodolgy”. In: WNSP. Ed. by Bob Blakley, Darrell
M. Kienzle, Mary Ellen Zurko, and Steven J. Green-
wald. Charlottsville, VA, USA: ACM, 1998, pp. 2–10.
DOI: 10.1145/310889.310900 (cit. on p. 1).
Farn Wang. “Parametric Analysis of Computer Sys-
tems”. In: Formal Methods in System Design 17.1
(2000), pp. 39–60. DOI: 10.1023/A:1008782501688 (cit. on
p. 4).

Figure 9: BAS translation of find_WLAN

The translation of leaf find_WLAN of Fig. 2 is given in
Fig. 9 in Appendix A. To express the leaf find_WLAN we use
four locations, one clock x4. The ﬁrst step is to activate the
basic attack step using the synchronization action launchFind-
WLAN. Once activated, and at most ﬁve units of time after
(modeled by the invariant 5 ≥ x4 and the guard x4 ≥ 5) it
can either success with the action successFindWLAN or fail
with the action failFindWLAN. If the success state is reached,
the weight of its parent gate is increased by its own weight 10.

B. Example of OR translation

its children,

The PWTA translating the only OR of Fig. 2 (given
then waits for
in Fig. 10) activates all of
one to succeed, regardless of the order. Afterwards, what-
ever happens leads to the success state. If one child fails,
then the other has to succeed, otherwise the OR fails.
Therefore there is six possible paths to the success state,
while there is two paths to the fail state (failure of both
children in any order). startOR launches the OR gate
gain_access_to_private_networks which activates
its two children using the actions startAND1 and star-
tAND2 which activates the AND access_LAN and AND
access_WLAN. Only one action successAND1 or succes-
sAN2 is needed to be synchronized so the automaton goes to

12

the location success regardless of which action is synchronized
afterwards. Then it synchronizes the action successOR. If at
ﬁrst the action failAND1 (resp. failAND2) is synchronized,
then successAND2 (resp. successAND1) has to be synchro-
nized afterwards in order to reach the location success. Oth-
erwise,
the
automaton will go to the location failing and then synchronize
the action failOR. If the success state is reached, the weight
of its parent gate is increased by its own weight.

failAND1) is synchronized,

if failAND2 (resp.

Figure
the
gain_access_to_private_networks

Translation

10:

of

Figure 11: OR

C. Screenshot of the tool ATTop

OR

gate

13

Figure 12: Screenshot of the tool ATTop after the translation of the SpaceX AFT

14

