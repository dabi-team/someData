2
2
0
2

p
e
S
5
2

]

R
C
.
s
c
[

5
v
2
5
0
1
0
.
5
0
2
2
:
v
i
X
r
a

HTTPA/2: a Trusted End-to-End Protocol for Web Services

Gordon King∗
gordon.king@intel.com
Intel Corporation

Hans Wang∗
hans.wang@intel.com
Intel Corporation

Abstract

With the advent of cloud computing and the Internet, the commercialized website becomes
capable of providing more web services, such as software as a service (SaaS) or function as a
service (FaaS), for great user experiences. Undoubtedly, web services have been thriving in
popularity that will continue growing to serve modern human life. As expected, there came
the ineluctable need for preserving privacy, enhancing security, and building trust. However,
HTTPS alone cannot provide a remote attestation for building trust with web services, which
remains lacking in trust. At the same time, cloud computing is actively adopting the use of
TEEs and will demand a web-based protocol for remote attestation with ease of use. Here,
we propose HTTPA/2 as an upgraded version of HTTP-Attestable (HTTPA) by augmenting
existing HTTP to enable end-to-end trusted communication between endpoints at layer 7 (L7).
HTTPA/2 allows for L7 message protection without relying on TLS. In practice, HTTPA/2 is
designed to be compatible with the in-network processing of the modern cloud infrastructure,
including L7 gateway, L7 load balancer, caching, etc. We envision that HTTPA/2 will further
enable trustworthy web services and trustworthy AI applications in the future, accelerating the
transformation of the web-based digital world to be more trustworthy.

Keywords— HTTP, HTTPA, TLS, Protocol, Attestation, TCB, TEE, Secret, Key Exchange,
Conﬁdential Computing

1 Introduction

We received positive feedback and inquiries on
the previous version of HTTPA [12] (HTTPA/1).
As a result, we present a major revision of the
HTTPA protocol (HTTPA/2) to protect sensi-
tive data in HTTPA transactions from cyber at-
tacks. Comparatively, the previous work [12]
is mainly focused on how to include remote at-
testation (RA) and secret provisioning to the
HTTP protocol with Transport Layer Security
(TLS) protection across the Internet, which is
In contrast,
great, but it comes at a price.
HTTPA/2 is not necessary to rely on the TLS

protocol, such as TLS 1.3 [21], for secure com-
munication over the Internet. The design of
HTTPA/2 follows the SIGMA model [14] to es-
tablish a trusted (attested) and secure communi-
cation context between endpoints at layer 7 (L7)
of the OSI model. Diﬀerent from connection-
based protocols, HTTPA/2 is transaction-based
in which the TEE is considered to be a new type
of requested resource over the Internet. In addi-
tion to protecting sensitive data transmitted to
TEE-based services (TServices), HTTPA/2 can
potentially be used to optimize the end-to-end
performance of Internet or cloud backend traﬃc,

*. Both authors contributed equally to this work.

1

 
 
 
 
 
 
thus saving energy and reducing the operational
costs of Cloud Service Providers (CSPs).

HTTP is a predominant Layer 7 proto-
col for website traﬃc on the Internet. The
HTTPA/1 [12] deﬁnes an HTTP extension to
handle requests for remote attestation, secret
provisioning and private data transmission, so
Internet visitors can access a wide variety of
services running in Trusted Execution Environ-
ments (TEEs) [11] to handle their requests with
strong assurances. In this way, visitors’ Person-
ally Identiﬁable Information (PII) and their pri-
vate data are better protected when being trans-
mitted from a client endpoint to a trusted ser-
vice endpoint inside the TEE. The HTTPA/1
supports mutual attestation if both client and
service endpoints run inside the TEE. Although
HTTPA/1 helps build trust between L7 end-
points with data-level protection, HTTPA/1
needs TLS to defend against attacks over the In-
ternet, e.g., replay attacks and downgrade at-
tacks. Note that TLS cannot guarantee end-
to-end security for the HTTPS message ex-
change [1] when the TService is hosted behind
a TLS termination gateway or inspection appli-
ance (a.k.a. middle boxes). Despite the fact that
TLS provides conﬁdentiality, integrity and au-
thenticity (ConfIntAuth) to ensure secure mes-
sage exchange for the HTTPA/1 protocol, it is
not a complete end-to-end security solution to
serve web services at L7. For example, TLS ter-
mination on the middleboxes makes it highly vul-
nerable to cyber-attacks. Both HTTPA/1 and
TLS need to generate key material through key
exchange and derivation processes. This requires
additional round trips at L5 and increases net-
work latency. Thus, there is room to further
optimize the network performance and reduce
communication complexity by avoiding the repe-
tition of key negotiations. Due to the limitation
of TLS mentioned above, a version of HTTPA
with message-level security protection is a nat-
ural candidate to address the issues mentioned
above at once.
This paper proposes an upgraded protocol,
HTTPA/2, which makes it possible to secure

HTTPA transactions even with no underlying
presence of TLS. HTTPA/2 is designed to im-
prove the processes of key exchange, RA and
secret provisioning in HTTPA/1.
It also en-
ables end-to-end secure and trustworthy re-
quest/response transactions at L7, which is cryp-
tographically bound to an attestable service base
that can be trusted by Internet visitors regard-
less of the presence of untrusted TLS termination
in between.
The rest of the paper is organized as follows.
Section 2 provides necessary preliminaries. Sec-
tion 3 elaborates on the protocol transactions.
Section 4 talks about security considerations.
Section 5 concludes the whole paper.

2 Technical Preliminaries

This section provides preliminaries related to the
construction of HTTPA/2. We ﬁrst introduce
using a Trusted Execution Environment (TEE)
in a web service setting. Then we describe sev-
eral important primitives to be used for con-
structing the HTTPA protocol described in sec-
tion 3.

2.1 Trusted Execution Environ-

ment (TEE)

In a TEE, trustworthy code is executed on data
with CPU-level isolation and memory encryption
inaccessible to anyone even those with system-
level privileges. The computation inside the
TEE is protected with conﬁdentiality and in-
tegrity. A TEE is more trustworthy than a
Rich Execution Environment (REE) [5] where
codes are executed on data without isolation. Al-
though most web services are deployed in REE,
it is an emerging trend to deploy web services
in a TEE for better security. Upon implementa-
tion, a service initialized and run inside the TEE
is known as a Trusted Service, called a TSer-
vice. TService uses TEE to eﬀectively reduce its
trusted computing base (TCB), which is the min-
imal totality of hardware, software, or ﬁrmware
that must be trusted for security requirements,

2

thus reducing the attack surface to as minimal
as possible.
For some TEE, such as Intel® Software Guard
Extensions (Intel® SGX) or Intel® Trust Do-
main Extensions (Intel® TDX), it can provide
evidence (or we call the evidence “Attest Quote
(AtQ)” in the section 2.2) reﬂecting conﬁgura-
tion and identities [8] to the remote relying party.
After successfully verifying the evidence and be-
ing convinced of the result, both parties ﬁnish
the RA process [2] [20]. With the RA completed
successfully, TServices can be shown more trust-
worthy to its relying party.
Not all TEEs are attestable, and the HTTPA
is only applicable to attestable TEE which can
generate such evidence for the purpose of RA.

2.2 Attest Quote (AtQ)

AtQ is an opaque data structure signed by a
Quoting Service (QService) with an attestation
key (AK), and it can be called a quote [17] or evi-
dence, which is used to establish trustworthiness
through identities. Because of this, the quote en-
capsulates code identity, ISV identity, TEE iden-
tity, and various security attributes, e.g., secu-
rity version number (SVN) of a TEE [10], asso-
ciated with a TService instance. A relying party
can examine the quote to determine whether the
TService is trustworthy or not via veriﬁcation in-
frastructure.
The quote is not a secret, and it must ensure its
uniqueness, integrity and authenticity (UniqIn-
tAuth). The quote generation involves cryp-
tographically measuring the instantiated TCB,
signing the measurements with an AK, includ-
ing a nonce.
The AtQ accommodates a piece of user-deﬁned
information, called Quote User Deﬁned Data
(QUDD). The QUDD can provide extra iden-
tities speciﬁc to a TService. Therefore, the AtQ
can in turn help protect the integrity of At-
test Header Lines (AHLs) during the handshake
phase which we will discuss in section 3.2.
It’s worth noting that not all quotes are the
same, especially if they are structured by diﬀer-

ent vendors, so a label of quote type should be
attached along with AtQ.

2.3 Attest Base (AtB)

AtB is the totality of computing resources serv-
ing client request handling, including hardware,
ﬁrmware, software, and access controls to work
together to deliver trustworthy service quality
with enforced security/privacy policy. It can also
be considered as a group of collaborating TSer-
vice instances running in their own attestable
TEEs respectively, which are capable of proving
the integrity of the execution state.
In this paper, the computing resources of TSer-
vice are oﬀered by AtB to be accessible to the
client through a series of trusted transactions.
How to attest those trustworthy services is deter-
mined by the speciﬁed policy in the handshake
phase. We suggest using a single TService in-
stance for each AtB to reduce the complexity
and attack surface as much as possible.
The AtB, serving for a particular service tied to
a Uniform Resource Identiﬁer (URI), should be
directly or indirectly attested by a client through
HTTPA/2 protocol.
In the case of a AtB formed by multiple TSer-
vices instances, an upfront TServices instance
takes responsibility for performing local attesta-
tion on the rest of TServices instances to estab-
lish trustworthy relationships with them. After
that, the upfront TServices can selectively collect
their quotes for client-side veriﬁcation during the
HTTPA/2 handshake phase.

2.4 Three Types of Request

(UtR) Attest Request

There are three types of request deﬁned by
including Un-trusted
the HTTPA/2 protocol,
Request
(AtR), and
Trusted Request (TrR). UtR is used in HTTP
transactions; AtR is used in both transactions
of Attest Handshake (AtHS) and Attest Secret
Provisioning (AtSP); TrR is used in trusted
transaction. For convenience we refer to the
AtR and TrR as “HTTPA/2 request”.

3

Regarding HTTP method, we propose a new
HTTP method, called “ATTEST”, to perform
the transactions of AtHS and AtSP. The HTTP
request using ATTEST method is called AtR.
Regarding HTTP header ﬁelds, we propose
to augment them with additional ones called
Attest Header Fields (AHFs) preﬁxed with
string “Attest-”. Without AHFs, it must be a
UtR in terms of HTTPA/2.

The AHFs are dedicated to HTTPA traﬃc.
For example, they can be used to authenticate
the identity of HTTPA/2 transactions, indicate
which AtB to request, convey conﬁdential meta-
data (see section 2.7), provision secrets, present
ticket (see section 2.5), etc.
Last one is AHL, it consists of AHF and its values
in a standard form [19]. We use it to signify a
single piece of annotated data associated with
the current HTTPA/2 request.

2.4.1 Un-trusted Request (UtR)

The UtR is simply an ordinary type of HTTP re-
quest, which does not use ATTEST method nor
does it contain any AHLs.
Before a UtR reaches a TService, the UtR can be
easily eavesdropped on or tampered with along
the communication path. Even protected by
TLS,
it is still possible to be attacked when
crossing any application gateway or L7 ﬁre-
wall since those intervening middle-boxes are un-
trusted and will terminate TLS connections hop
by hop [1]. Therefore, there is no guarantee of
ConfIntAuth. That’s why the TService cannot
treat the request as trustworthy, but it is still
possible for TService to handle UtR if allowed
by the service-side policy. Thus, we don’t sug-
gest TService to handle any one of them for the
sake of security.

2.4.2 Attest Request (AtR)

The AtR is an HTTP request equipped with
both ATTEST method and AHLs for AtHS and
AtSP. If any AtR was not successfully handled

by corresponding TService, subsequent TrR, de-
scribed in the section 2.4.3, will no longer be ac-
ceptable to this TService. We describe the ma-
jor diﬀerence between an AtR used in AtHS and
AtSP respectively as follows:

AtHS The AtR used in AtHS is designed to
request all necessary resources for handling both
types of AtR used in AtSP and TrR. For exam-
ple, one of the most important resources is AtB
(see section 2.3), which may be scheduled or al-
located by a server-side resource arbiter. Typi-
cally (but not always), an upfront TService can
directly designate itself as the AtB for this client.
For the complete explanation in detail, see sec-
tion 3.2.
In addition, this AtR should not be used to
carry any conﬁdential information, because the
key material cannot be derived at this moment.
TService can encrypt sensitive data in the re-
sponse message since it has already received the
required key share from the client and be able to
derive the key material for encryption.

AtSP The AtR of AtSP is optional and may
not be present in HTTPA/2 traﬃc ﬂow since
in some cases the TService does not need any
AtB-wide secrets provided by the client to work.
In the common case, TService needs secret pro-
visioning to conﬁgure its working environment,
such as connecting to databases, setup signing
keys, and certiﬁcates, etc. This AtR must be is-
sued after all TEE resources have been allocated
through the AtHS transaction described above.
It’s worth noting that this request is not required
to be issued before any TrR 2.4.3. With such
ﬂexibility, TService can get extra information or
do some operations beforehand through preced-
ing TrRs.
Importantly, this AtR is responsible to provision
AtB-wide secrets to AtB, such as key credentials,
tokens, passwords, etc. Those secrets will be
wrapped by an encryption key derived from the
key exchange in the AtHS phase 3.2. Further-
more, the TService must ensure that those pro-
visioned secrets will be eliminated after use, AtB

4

get released, or any failure occurred in process-
ing AtR. For the complete explanation in detail,
see section 3.3.

The two kinds of AtR introduced above are
the core of HTTPA/2 protocol. Both of them
can be treated as GET request messages to save
a RTT, and they can also be used to transmit the
protected sensitive data to both sides, except for
the AtR of AtHS due to the key exchange not
yet completed as noted earlier.

2.4.3 Trusted Request (TrR)

The TrR can be issued right after successful
AtHS (see section 2.4.2) where an AtB is allo-
cated. Although, TrR does not use ATTEST
method, it should contain AHLs to indicate that
it is a TrR not a UtR. In other words, the TrR
is nothing but an ordinary HTTP request with
some AHLs. Within those AHLs, one of them
must be AtB ID to determine which AtB is tar-
geted in addition to the speciﬁed URI. With
that, the TrR can be dispatched to proper TSer-
vice to handle this request.
In essence, the TrR is designed to interact with
a TService for sensitive data processing. The
HTTPA/2 must ensure ConfIntAuth of a set of
selected data, which may be distributed within
the message body or even in the header or re-
quest line, for end-to-end protection. It turns out
that not all message bytes would be protected
under HTTPA/2 like TLS does. As a result, the
HTTPA/2 may not be suitable for certain sce-
narios, e.g., simply want to encrypt all traﬃc
bytes hop by hop. However, in most cases, the
HTTPA/2 can oﬀer a number of obvious beneﬁts
without TLS. For example, users do not need to
worry about data leakage due to TLS termina-
tion, and they can save the resources required by
the TLS connections. In some special cases, the
HTTPA/2 can be combined with TLS to provide
stronger protection but the performance over-
head can be signiﬁcant (see section 2.8).
There are many potential ways to optimize Inter-
net service infrastructure/platform by means of

adopting HTTPA/2 since the insensitive part of
HTTPA/2 messages can be used as useful hints
to improve the eﬃciency of message caching or
routing/dispatching, risk monitoring, malicious
message detection and so on, helping protect sen-
sitive data in motion, as well as in processing by
the client-chosen TServices.

2.5 Attest Ticket (AtT)

AtT is a type of AHL used to ensure the in-
tegrity and authenticity (IntAuth) of AHLs and
freshness by applying AAD to each HTTPA/2
request, except for the AtR of AtHS which is
the initiating request for the handshake. AtT is
required to be unique for single use so as to mit-
igate the replay attack as it can be ensured by
AAD in practice. Moreover, the AtT should be
appended at the very end of the request body as
the last trailer [6] because there might be TrC or
other trailers which need to be protected by the
AtT as well.
Regarding the AtR of AtHS, there is no protec-
tion from AtT, because there are no derived keys
available to use at such an early stage.
In or-
der to protect the AtR of AtHS, we can use ei-
ther client-side quote or pre-conﬁgured signing
key methods to ensure the IntAuth instead of
AtT. Typically, there are four situations to con-
sider: mHTTPA, client with CA-signed certiﬁ-
cate, client with self-signed certiﬁcate, and noth-
ing to provide.

Mutual HTTPA (mHTTPA) With mutual
HTTPA being used, the client must be running
on a TEE as TEE-based client (TClient), which
is capable of generating a client-side AtQ. The
AtQ can be used to ensure the IntAuth of AtR
by means of including the digest of AHLs into its
QUDD, and the server-side should have a proper
trusted attestation authority to verify it.
This is the recommended approach to build mu-
tual trust between TClient and TService, but the
client-side usually lacks of TEE feature support.

5

Client with CA-signed Certiﬁcate In this
case, the client signs the AHLs of AtR along with
a trusted certiﬁcate, and TService should be able
to verify the signature with respective CA certiﬁ-
cate chain. This way helps TService to identify
the user identity.
In addition, the mHTTPA can be enabled at the
same time to make it more secure and trustwor-
thy on both sides if possible.

Client with self-signed Certiﬁcate In this
situation, the client should sign the AHLs of
AtR using temporary signing key, and TService
should verify the signature using its self-signed
certiﬁcate enclosed in the same AHL. This ap-
proach is not safe since the TService may receive
compromised AtR.

Nothing to provide There is no way to
protect
these
the integrity of AHLs under
circumstances. We recommend at least using
the temporary generated signing key with
the corresponding self-signed certiﬁcate.
It’s
worth noting that even if the AHLs of AtT is
compromised, the client is able to detect the
problem by checking the received AtQ of the
TService as the QUDD embedded in AtQ will
ensure the integrity of AHLs in its request and
response messages altogether.

It is diﬃcult for the client to simply use the
self-signed certiﬁcate to prove its identity,
let
alone in the case of nothing to provide. Again we
recommend the client to combine mHTTPA and
CA signed certiﬁcate approaches together to es-
tablish strong trustworthy relationship between
TClient and TService if the server also wants to
identify the client’s identity at the initiating re-
quest, AtR. If it is not the case, the client must
detect whether any unexpected changes occurred
in the AHLs of AtR as an additional critical step
to defend against Man-in-the-Middle (MITM)
and downgrade attacks.

2.6 Attest Binder (AtBr)

AtBr is a type of AHL used to ensure the binding
between HTTPA/2 request and the correspond-
ing response. The AHL of AtBr should be added
into the response message as the last trailer [6].
The AtBr typically holds the Message Authenti-
cation Code (MAC) to protect two components:
all AHLs of the current response, and the value of
AtT in its corresponding request. We can choose
other cryptographic algorithms for encryption
and message authentication, e.g., Authenticated
Associated Data (AAD), Authenticated Encryp-
tion with Associated Data (AEAD) [16] to en-
sure the IntAuth of the AtBr.
The AtBr should present in all HTTPA/2 re-
sponse messages, except for the response of AtR
in the AtHS phase 3.2. The reason is the quote of
TService can achieve the same purpose without
the help of AtBr.

2.7 Trusted Cargo (TrC)

The TrC can appear in both of HTTPA/2 re-
quest and response messages, except for the AtR
of AtHS. The TrC serves as a vehicle to carry
conﬁdential information which needs to be pro-
tected by authenticated encryption.
TrC can be used to protect some sensitive meta-
data such as data type, location, size, and key
index to tell the places in which the ciphertext or
signed plaintext is located in the message body.
The key index indicates which key should be used
to decrypt those encrypted messages or verify the
message’s integrity. Potentially, there is much
useful metadata that can be included in TrC,
but we should keep it minimum as size limits
might be enforced by intermediaries in the net-
work path.
The way to structure the metadata and how to
parse it is not deﬁned by this paper. We leave it
to the future extensions of HTTPA/2 or it can
be customized by application.
Finally, the TrC should be put in a trailer [6]
since its variable length aﬀects the position in-
formation it contains. Again, the value of TrC
must be protected from eavesdropping on or ma-

6

nipulating by the means of AE.

2.8 Trusted Transport Layer Secu-

rity (TrTLS)

HTTPA/2 protects the selected parts of an
HTTP message. If users want to protect the en-
tire HTTP message—every bit of the message,
TLS can leverage HTTPA/2 to establish a se-
cure connection at L5 between the client and its
adjacent middlebox, which we call TrTLS. The
TrTLS makes use of AtHS to transmit HELLO
messages of TLS [21] to the client and TSer-
vice respectively for handshake. This way can
make the initial handshake of the secure trans-
port layer protocol trustworthy. We consider
three cases of endpoints as follows:

In the case of TClient endpoint, the
TClient
TClient leverages its QUDD to ensure the In-
tAuth of the client hello message to establish
TLS connection. The server-side veriﬁer helps
verify the QUDD. If the attestation is success-
ful, the trusted endpoint of TClient will be es-
tablished as TrTLS. Note that the TrTLS mod-
ule should be co-located in the same TEE with
TClient.

proxy, or L7 load balancer. Although TSer-
vice has no direct connection with its client, the
trusted connection of TLS between the client and
the ﬁrst middlebox can be established by check-
ing the results of RA from the backend TService.
The middlebox needs to consider the mapping of
the request and the response with the backend
TService to be correct in order to decide whether
to use the results of RA to build a trusted con-
nection or not. Admittedly, this is the least
trustworthy conﬁguration in terms of full traf-
ﬁc encryption when it is compared with the two
cases mentioned above because the attack sur-
face includes those vulnerable middleboxes in the
TrTLS connection.

After the initial message is exchanged through
AtHS, the encrypted channel can be established
under the HTTPA/2 at L5, so the following traf-
ﬁc will be encrypted and inherit the attested as-
surances of the TEE from HTTPA/2.
In the
case of the ordinary TLS connection prior to
HTTPA/2, the TrTLS mechanism can discon-
nect the already built TLS connection and then
re-establish a trustworthy TLS connection seam-
lessly. We simply present the high-level concept
of TrTLS in this paper and may discuss more
details in another paper.

Frontend TService The frontend TService is
deﬁned as a TService which can communicate
with the client without any L7 middleboxes in
between. In other words, the communication be-
tween the TService and the client has no TLS
terminators. This implies that TService can es-
tablish a secure transport layer connection di-
rectly with its client. Thus, the IntAuth of the
server-side HELLO message can be fully pro-
tected by the QUDD of TService in a similar
way described in the above case of TClient but
in the reverse direction.

Backend TService In the case of a backend
TService endpoint, the connection of the secure
transport layer will be terminated by at least
one middle-box e.g., application gateway, reverse

3 Protocol Transactions

In this section, we provide detailed deﬁnitions of
all HTTPA/2 transactions.

3.1 Preﬂight Check Phase

The preﬂight request gives the Web service a
chance to see what the actual AtR looks like
before it is made, so the service can decide
whether it is acceptable or not. In addition, the
client endpoint performs the preﬂight check as
a security measure to ensure that the visiting
service can understand the ATTEST method,
AHFs, and its implied security assurance.
To start with HTTPA/2, a preﬂight request
could be issued by a client as optional to check

7

whether the Web service, speciﬁed by URI in
the request line,
is TEE-aware and prepare
for AtHS. In the case that the client is a Web
browser, the preﬂight request can be automat-
ically issued when the AtR qualiﬁes as “to be
preﬂighted”.
The reason we need the preﬂight transaction
is that it is a lightweight HTTP OPTIONS [7]
request, which will not consume a lot of com-
puting resources to handle, compared to the
AtR. Caching the preﬂight result can avoid
the re-check operation during a speciﬁed time
window.

Passing this check does not guarantee that the
AtR can be successfully handled by this service.
For example, the TService may run out of re-
sources, or the client’s cipher suites are not sup-
ported, and so on.
The preﬂight is an idempotent operation, e.g.,
there is no additional eﬀect if it is called more
than once with the same input parameters. The
client can also use the preﬂight to detect the ca-
pabilities of AtB 2.3, without implying any real
actions.

In the preﬂight transaction,

As shown in Figure.1, an OPTIONS request
should be honored by an HTTPA/2 compliant
TService.
it has
standard HFs to specify the method and AHLs
which will be sent out later to the same TService
if they are acceptable. Those HFs are described
respectively as follows:

1. HFs in request message

(a) Access-Control-Request-Method

This HF carries a list of methods in-
dicating that ATTEST method will be
used in the next request if the service
can support it.

(b) Access-Control-Request-Headers

This HF carries a list of ﬁeld names
indicating that the AHFs will be in-
cluded in the next request if the service
can support it.

2. HFs in response message

(a) Allow

This HF carries a list of supported
It
methods by the visiting service.
must contain the ATTEST method for
the client to proceed with AtR; other-
wise, the AtR is not acceptable by this
service and will be denied if received it.

(b) Access-Control-Allow-Headers

This HF carries a list of allowed AHFs.
The client needs to check that all of the
requested AHFs should be contained in
this resulting ﬁeld.

(c) Access-Control-Max-Age

This HF indicates how long the pre-
ﬂight check results can be cached.

3.2 Attest Handshake

(AtHS)

Phase

The AtHS phase contains a core transaction of
HTTPA/2.
In a single round trip time (one
RTT), the AtR and its response accomplishes
three major tasks, including key exchange, AtB
allocation and AtQ exchange, as shown in Fig-
ure.2:

1. Key Exchange

It is necessary to complete the key exchange
process before any sensitive information
can be transmitted between the client and
TService.
The exact steps within this
will vary depending upon the kind of key
exchange algorithm used and the cipher
suites supported by both sides.
In HTTPA/2, the key exchange process
follows TLS 1.3 [21] and recommends a set
of key exchange methods to meet evolving
needs for stronger security.
Insecure cipher suites have been excluded,
and all public-key-based key exchange
mechanisms now provide Perfect Forward
Secrecy (PFS), e.g., Ephemeral Elliptic
Curve Diﬃe-Hellman (ECDHE). Note that
it is mandatory that the fresh ephemeral
keys are generated and used, and destroyed
afterward [18] inside the TEE of TService.

8

Figure 1: Preﬂight transaction

When the key exchange is completed, we
recommend using HMAC-based Extract-
and-Expand Key Derivation Function
(HKDF) [13] as an underlying primitive for
key derivation.
We describe the key negotiation between the
client and the TService in terms of AHFs
set in request and response respectively as
follows:

(a) AHFs in request message (or AtR):

i. Attest-Cipher-Suites

It is a list of cipher suites that indi-
cates the AEAD algorithm/HKDF
hash pairs supported by the client.

ii. Attest-Supported-Groups

the

indicates

It is a list of named groups [15]
that
(EC)DHE
groups supported by the client
for key exchange, ordered from
most preferred to least preferred.
The AHL of Attest-Key-Shares

contains corresponding (EC)DHE
key shares e.g., pubkeys for some
or all of these groups.

iii. Attest-Key-Shares

Its value contains a list of the
client’s cryptographic parameters
for possible supported groups in-
dicated in the AHL of Attest-
Supported-Groups for negotiation.
We can refer to the corresponding
data structure described in TLS
1.3 [21]. It is a time-consuming op-
eration to generate those parame-
ters (see 3.1 in Figure.2)

iv. Attest-Random

It is 32 bytes of a random nonce,
which is used to derive the master
secret and other key materials by
TService. The purpose of the ran-
dom nonce is to bind the master
secret and the keys to this particu-
lar handshake. This way mitigates

9

Figure 2: Attest handshake (AtHS) transaction

10

the replay attack to the handshake
as long as each peer properly gen-
erates this random nonce.

(b) AHFs in response message

i. Attest-Cipher-Suite
It
the
indicates
pher suites,
cipher/HKDF hash
HTTPA/2 message protection.

selected
ci-
a symmetric
for
pair

i.e.

ii. Attest-Supported-Group

It indicates the selected named
group to exchange ECDHE key
share generated by the TService.

iii. Attest-Key-Share

Its value contains the TService’s
cryptographic parameters accord-
ingly (see 3.7 in Figure.2).

iv. Attest-Random

It takes the same mechanism as
the Attest-Random in the request.
Instead, it is used by the client to
derive the master secret and other
key materials.

This handshake establishes one or more in-
put secrets combined to create the actual
keying materials. The key derivation pro-
cess (see 3.9, 3.15 in Figure.2), which makes
use of HKDF, incorporates both the input
secrets and the AHLs of handshake. Note
that anyone can observe this handshake pro-
cess if it is not protected by the byte-to-byte
encryption at L5, but it is safe since the se-
crets of the key exchange process will never
be sent over the wire.

2. AtB Allocation

This task takes care of resource allocation.
The upfront TService needs to prepare es-
sential resources before assigning an unique
AtB identiﬁer to the AtB, which is used by
the client to ask TService to process its sen-
sitive data on this AtB (see 3.6 in Figure.2).

(a) AHFs in request message or AtR:

11

i. Attest-Policies

It can contain various types of se-
curity policies, which can be se-
lectively supported by this AtB of
TService. There are two aspects
to consider as follows:

Instances attestation

direct: all instances should be
veriﬁed by the client.
indirect: only the contact in-
stance should be veriﬁed by
the client remotely.

Un-trusted requests
allowUntrustedReq:
it allows
UtR to be handled by the
TService on this AtB (disabled
by default).

ii. Attest-Base-Creation

It speciﬁes a method used for the
creation of AtB. There might be
several options available to select:

new

It means that the AtB should
be newly created for the client
to use. If the contact TService
is a new one, then it can be
assigned to this client immedi-
ately.

reuse

This option allows reusable
AtB to be used by this client,
but the AtB should ensure
that all traces associated with
the previous client are erased.
So far, there is no such TEE,
which can achieve this security
feature strictly, and we cannot
fully rely on software to emu-
late it. As a result, the client
should evaluate the risks be-
fore specifying this option.

shared

A shareable AtB can be allo-
cated to this client. The client
does not care whether it is a

clean base or not. Use it with
caution.

iii. Attest-Blocklist

It indicates a list of blocked identi-
ties and other types of identiﬁers,
which allows TService to ﬁlter out
unqualiﬁed AtB beforehand. This
feature is used to optimize the per-
formance of AtB allocation, as it is
quite expensive and ineﬃcient to
rely only on the client to collect a
set of TService instances by using
the trial and error method.

(b) AHFs in response message:

i. Attest-Base-ID

This identiﬁer signiﬁes the allo-
cated AtB, which has been tied to
this particular client who sent the
AtHS request. It should be used in
subsequent HTTPA/2 requests to
ensure those requests can be eﬃ-
ciently dispatched into TServices.
Given that the HTTPA/2 request
dispatcher may not be trustwor-
thy, and won’t be capable to check
its integrity of it. As a result,
it cannot guarantee that those re-
quests could be delivered into their
matched AtBs. To remedy this
problem, the dispatcher should be
capable to identify invalid AtB
ID as possible, and the receiving
TService should validate it right
after integrity check (see 4.2 in
Figure.3, 5.2 in Figure.4).
Note that the max-age directive
set here indicates how long this
AtB could be kept alive on the
server side.

3. AtQ Exchange

In HTTPA/2, a successful RA [2] increases
client’s conﬁdence by assuring the targeting
services running inside a curated and trust-
worthy AtB. The client can also determine
the level of trust in the security assurances

12

provided by TServices through AtB.
The RA is mainly aimed to provision se-
crets to a TEE, In this solution, we lever-
age this mechanism to set it as the root
trust of the HTTPA/2 transactions instead
of certiﬁcate-based trust, e.g., TLS. To fa-
cilitate it, we integrate the RA with the
key exchange mechanism above to perform
a handshake, which passes the assurance to
derived ephemeral key materials (see 3.9 in
Figure.2). Those keys can be in turn used to
wrap secrets and sensitive data designated
by the client or TService in either direction.
During RA process,
the AtQ (see sec-
tion 2.2) plays a key role to attest TSer-
vice. It provides evidence (quote) to prove
authenticity of the relevant TService (see 3.8
in Figure.2). The client can just rely on it
to decide whether the TService is a trust-
worthy peer or not [4].
To appraise AtQ, we need a trusted author-
ity to be the veriﬁer to perform the process
of AtQ veriﬁcation, and reports issues on
this AtQ, e.g.,TCB issues (see 3.12 in Fig-
ure.2). The result of veriﬁcation produced
by the veriﬁer should be further assessed
by the client according to its pre-conﬁgured
policy rules and applied security contexts.
Importantly, the TService should ensure the
integrity and authenticity of all AHLs of
AtR and its response through the QUDD of
AtQ, and vice versa in case of mHTTPA/2.
The following AHFs should be supported by
HTTPA/2 protocol for RA.

(a) AHFs in request message (or AtR):

i. Attest-Quotes

It can only appear in mHTTPA/2
mode to indicate a set of AtQs gen-
erated from the TClients for tar-
geting TService to verify. (see 3.2,
3.3, 3.4, 3.5 in Figure.2). These
quotes should be used to ensure
IntAuth of the AHLs of this AtR
through their QUDD.
Note that the max-age directive

indicates when these quotes are
outdated and its cached veriﬁca-
tion results should be cleared up
from AtB to avoid broken assur-
ance.
In addition, all client-side
quotes must be veriﬁed by server-
side veriﬁer and validated by TSer-
vices before a AtB ID can be is-
sued.

(b) AHFs in response message

i. Attest-Quotes

It is mandatory for a AtB to
present its AtQs to the client for
client-side veriﬁcation. The In-
tAuth of both AHLs of the AtR
and its response should be ensured
by its QUDDs to protect the trans-
action completely.
The client must verify the AtQ
to authenticate its identities of re-
mote AtB (see 3.8, 3.10, 3.11,
3.12 in Figure.2).
The client
should not trust anything received
from TService before AtQs is suc-
cessfully veriﬁed and evaluated.
Whether the integrity of AHLs
is held should be determined by
client-side security policies. Note
that the TService quotes can be
selectively encrypted in its parts
through TrC to hide its identity in-
formation.

There are several remaining AHFs, which
are important to this transaction as they
provide other necessary information and
useful security properties:

(a) AHFs in request message

i. Attest-Versions

The client presents an ordered list
of supported versions of HTTPA
to negotiate with its targeting
TService.
ii. Attest-Date

It is the Coordinated Universal

13

Time (UTC) when client initiates
a AtHS.

iii. Attest-Signatures

It contains a set of signatures,
which are used to ensure IntAuth
of AHLs in this AtR through
client-side signing key (see sec-
tion 2.5).

iv. Attest-Transport

As described in section 2.8, the
client HELLO message should be
put in here. With this, the TSer-
vice can enforce a trustworthy and
secure connection at L5, which
is a bit similar to what HTTP
Strict Transport Security (HSTS)
does [9].

(b) AHFs in response message

i. Attest-Version

It shows client which version of
HTTPA is selected by TService to
support.

ii. Attest-Transport

Similarly, the TService returns its
HELLO message to the client for a
secure transport layer handshake.

iii. Attest-Expires

It indicates when the allocated
AtB will go expire and its related
resources will get released. It pro-
vides another layer of security to
reduce the chance of this AtB be-
ing attacked.
iv. Attest-Secrets

It is an ordered list of AtB-wide
secrets, which are provisioned by
TService if client expects them.
This way can save a RTT of AtSP
(see section 3.3) in case of TService
won’t demand secrets from client
immediately.
v. Attest-Cargo

The usage of this ﬁeld is described
in section 2.7. Note that “Attest-
Cargo” is a AHF while TrC is the

corresponding content which plays
an important role on sensitive data
encryption and authentication.

Apart from those tasks above, this AtR can
act as a GET request, but it cannot be
trusted due to incomplete key exchange at
this moment, which means it cannot con-
tains any sensitive data, but its response can
be trusted as the key exchange process com-
pleted at TService-side, and before it gets
returned. Therefore, the TService-side sen-
sitive data can be safely transmitted back
to the client through the TrC.

3.3 Attest

Secret Provisioning

(AtSP) Phase

As mentioned in section 3, the main purpose of
AtSP is to securely deliver secrets to a trustwor-
thy AtB, which has been veriﬁed by a server-side
veriﬁer. The AtR of AtSP is intended to be used
for this purpose. To be precise, it is for AtB-wide
and client-wide secret provisioning. On the con-
trary, the request-wide or response-wide secrets
should be carried by the TrCs (see section 2.7)
of HTTPA/2 transactions. In addition, the fail-
ure of AtSP will causes AtB termination imme-
diately.

As shown in Figure.3, the AtSP transaction
can be used to provision secrets in two directions
since the AtB and its key materials already got
derived through AtHS (see section 3.2) on both
sides; thus, the AHLs can be fully protected dur-
ing this phase. Moreover, AtR of AtSP can be
issued by the client any number of times at any-
time after AtHS.
These AHLs described in following:

1. AHFs in request message (or AtR)

(a) Attest-Base-ID

This identiﬁer is used to specify which
AtB is targeted to handle this AtR of
AtSP. With this ID, the TService can
ﬁrstly validate it against its serving list
to make sure correctly handling of this

request (see 4.2 in Figure.3). However,
the TService should quietly ignore it
if the ID is not valid for its residing
AtB as the receiving TService should
not expose any information for an ad-
versary to exploit.

(b) Attest-Ticket

The usage of this ﬁeld is explained in
section 2.5. The value of this ﬁeld
must be unique to prevent a replay at-
tack. Also, it ensures the IntAuth of
the AHLs in this request.

(c) Attest-Secrets

It contains an ordered list of secrets,
which is wrapped up by means of AE
as a standard way for strong protec-
tion. Moreover, each secret should be
able to be referred to by the client later
using the index. For example, speci-
fying a provisioned secret that is used
to decrypt embedded sensitive data.
Again, the receiving AtB should be ter-
minated if any of these provisioned se-
crets cannot be validated or accepted
by the AtB (see 4.3 in Figure.3).

(d) Attest-Cargo

This ﬁeld is optional, it can be used to
carry any sensitive information, which
is meaningful to TService (see sec-
tion 2.7). Note that this paper is not
intended to deﬁne the structure of its
content, which could be addressed in
another one.

2. AHFs in response message:

(a) Attest-Binder

It is used to make sure the request to
response is binding together to iden-
tify this transaction uniquely (see sec-
tion 2.6).

(b) Attest-Secrets

In this HF, these contained wrapped
secrets will be provisioned back to the
client. As noted earlier, this can be

14

Figure 3: Attest secret provisioning (AtSP) transaction

merged into the response AHLs in AtR
of AtHS (see section 3.2).

(c) Attest-Cargo

Similarly, it can be used to carry sen-
sitive information/data back to the
client (see section 2.7).

3.4 Trusted

Communication

Phase

When AtB is allocated for the client, it can sub-
sequently issue TrR (see section 2.4.3) to do the
real work. Basically, the TrR is an ordinary
HTTP request with some extra AHLs, which are
described in detail as follows:

1. AHFs in request message:

(a) Attest-Base-ID

It speciﬁes which AtB to handle this re-
quest, and should be validated by tar-
geting TService (see 5.2 in Figure.4)
before processing this request (see 5.3
in Figure.4).

15

(b) Attest-Ticket

This ﬁeld has been explained above
(see section 2.5), which is intended to
authenticate this request, and prevent
other AHLs from being tampered with
or being replayed.

(c) Attest-Cargo

As noted earlier, this ﬁeld is optional,
and the client can use it to transfer ar-
bitrary sensitive information to TSer-
vice (see section 2.7).

(d) Attest-Base-Termination

We can include this AHF if it is the
last TrR towards the AtB. It is rec-
ommended way to terminate a AtB ac-
tively.
The termination method can be one of
the following options:

cleanup

This means that the terminated
AtB can be reused by other clients.

destroy

Figure 4: Trusted transaction

16

Specify this method,
if the AtB
should not be reused or shared by
any other clients.

keep

This allows AtB to be shared with
other clients.
Be careful, this
method is less safe as the residual
data could be exploited and leaked
to the next client if any.

2. AHFs in response message:

(a) Attest-Binder

As explained earlier, the HTTPA/2
uses it to ensure the IntAuth of both
request and response together (see sec-
tion 2.6).

(b) Attest-Cargo

As noted earlier, the TService can
leverage this mechanism to transfer ar-
bitrary sensitive information back to
its client (see section 2.7).

3.5 Protocol Flow

As shown in Figure.5, we illustrate those transac-
tions from client perspective, including preﬂight,
AtHS, AtSP, and trusted request in a workﬂow
diagram. In the design of HTTPA/2, only the
phase of AtHS is required, which not only largely
simpliﬁes the interaction between the client and
the TService but also improves the user experi-
ence (UX).

Figure.6 shows the workﬂow, which can help
understand how those transactions are distin-
guished in TService.

4 Security Considerations

In this section, we discuss security properties and
the potential vulnerabilities, as is necessary for
understanding HTTPA/2.

Figure 5: HTTPA transaction workﬂow from the
client view.

4.1 Layer 7 End-to-End Protec-

tion

In cloud computing scenarios,
intermediary
nodes, such as L7 load balancer or reverse proxy,
are used commonly to improve the network per-
formance to deliver the best web experience.
However, the great web experience does not
come for free. The secure communication based
on TLS only protects transmitted data hop-by-
hop at layer 5 (L5). The intermediary nodes
may need TLS termination to inspect HTTP
messages in plain text for better network per-
formance. As a consequence, the intermedi-
ary nodes can read and modify any HTTP in-
formation at L7. Although TLS itself is not
the problem, it cannot protect sensitive informa-
tion above L5 where most Web services are lo-
cated. That is the gap between L5 and L7 that
causes the underlying vulnerability. Therefore,
the trust model including intermediary nodes,
which are over L5, is problematic [23], because,
in reality, intermediary nodes are not necessar-

17

Figure 6: HTTPA transaction workﬂow from the TService view

Intermediary nodes may leak
ily trustworthy.
the privacy and manipulate the header lines of
HTTP message. Even in the case, where inter-
mediaries are fully trusted, an attacker may ex-
ploit the vulnerability of the hop-by-hop archi-
tecture and lead to data breaches. HTTPA/2
helps protect AHLs and the sensitive informa-
tion of HTTP message end-to-end at L7. As
long as the protection does not encrypt the nec-
essary information against proxy operations [23],
HTTPA/2 can provide guarantees that the pro-
tected message can survive across middleboxes
to reach the endpoint. Especially, HTTPA/2
provides an encryption mechanism at the level
of HTTP message, where only the selected in-
formation, some header lines or payloads, is en-
crypted rather than the entire message. Thus,
the parts of HTTPA information without pro-
tection may be exploited to spoof or manipulate.
If we want to protect every bit of HTTPA mes-
sage hop-by-hop, TLS is highly recommended in
combine with HTTPA/2 for use.

In the implementation, the TServices can
make a privacy policy to determine to what de-
gree the HTTPA message is protected to the L7
endpoint without TLS for better network perfor-
mance. If the message is highly sensitive entirely,

TLS can come to help in addition, but only up
to the security of the L5 hop point.

4.2 Replay Protection

A replay attack should be considered in terms
of design and implementation. To mitigate re-
play attacks, most AEAD algorithms require a
unique nonce for each message. In AtR, random
numbers are used. In TrR, a sequential nonce is
used on either endpoint accordingly. Assuming
strictly increasing numbers in sequence, the re-
play attack can be easily detected if any received
number is duplicated or no larger than the pre-
viously received number. For reliable transport,
the policy can be made to accept only TrR with
a nonce that is equal to the previous number plus
one.

4.3 Downgrade Protection

The cryptographic parameters of conﬁguration
should be the same for both parties as if there
is no presence of an attacker between them. We
should always negotiate the preferred common
parameters with the peer. If the negotiated pa-
rameters of conﬁguration are diﬀerent for both

18

parties, it could make peers use a weaker cryp-
tographic mode than the one they should use,
thus leading to a potential downgrade attack [3].
In HTTPA/2, TService uses AtQ to authenti-
cate its identity and the integrity of the AtHS to
the client. In mHTTPA/2, the client uses AtQ
carried by AtR for proving its own authenticity
and the message integrity. Thus, the communi-
cation traﬃc of the handshake across intermedi-
aries cannot be compromised by attackers.

4.4 Privacy Considerations

Privacy threats are considerably reduced by
means of HTTPA/2 across intermediary nodes.
End-to-end access restriction of integrity and en-
cryption on the HTTPA/2 AHLs and payloads,
which are not used to block proxy operations,
aids in mitigating attacks to the communica-
tion between the client and the TService. On
the other hand, the unprotected part of HTTP
headers and payloads, which is also intended to
be, may reveal information related to the sensi-
tive and protected parts. Then privacy may be
leaked. For example, the HTTP message ﬁelds
visible to on-path entities are only used for the
purpose of transporting the message to the end-
point, whereas the AHLs and its binding pay-
loads are encrypted or signed. It is possible for
attackers to exploit the visible parts of HTTP
messages to infer the encrypted information if
the privacy-preserving policy is not well set up.
Unprotected error messages can reveal informa-
tion about the security state in the communica-
tion between the endpoints. Unprotected signal-
ing messages can reveal information about reli-
able transport.

The length of HTTPA/2 message ﬁelds can re-
veal information about the message. TService
may use a padding scheme to protect against
traﬃc analysis. After all, HTTPA/2 provides a
new dimension for applications to further protect
privacy.

4.5 Roots of Trust (RoT)

Many security mechanisms are currently rooted
in software; however, we have to trust under-
lying components, including software, ﬁrmware,
and hardware. A vulnerability of the compo-
nents could be easily exploited to compromise
the security mechanisms when the RoT is bro-
ken. One way to reduce that risk of vulnerability
is to choose highly reliable RoT. RoT consists of
trusted hardware, ﬁrmware, and software com-
ponents that perform speciﬁc, critical security
functions [22]. RoT is supposed to be trusted
and more secure, so it is usually used to pro-
vide strong assurances for the desired security
In HTTPA/2, the inherent RoT is
properties.
the AtB or TEEs, which provide a ﬁrm founda-
tion to build security and trust. With AtB being
used in HTTPA/2, we believe that the risks to
security and privacy can be greatly reduced.

5 Conclusion

In this paper, we propose the HTTPA/2 proto-
col, a major revision of HTTPA/1. HTTPA/2 is
a layer 7 protocol that builds trusted end-to-end
communication between Hypertext Transfer
Protocol (HTTP) endpoints. An integral part of
HTTPA/2 is based on conﬁdential computing,
e.g., TEE, which is used to build veriﬁable trust
between endpoints with remote attestation.
Communication between trusted endpoints is
better protected across
intermediary nodes
which may not have TLS protection. This
protection helps prevent HTTPA/2 metadata
and the selected HTTP data from being com-
promised by internal attackers, even with TLS
termination.

In addition to security advantage,

the
HTTPA/2 also illustrates the performance ad-
vantages over HTTPA/1, as it is not mandatory
to enforce TLS; hence the overheads of TLS
can be saved. Furthermore, HTTPA/2 provides
ﬂexibility for a service provider to decide which
part of the HTTP message is required to be

19

protected.
This feature can potentially be
leveraged by CSPs to optimize their networking
conﬁguration and service deployment to improve
the throughput and response time. With those
improvements, the energy of electricity can be
saved as well.

6 Future Work

To further realize HTTPA/2 in the real world,
we will be focused on proof-of-concept (PoC) to
demonstrate its validness and soundness. We
will apply the PoC codes of HTTPA/2 to various
use cases in practice. Lastly, we plan to release a
reference implementation towards generalization
to open source.

In the future, we expect emerging private AI
applications to leverage HTTPA/2 to deliver its
end-to-end trusted service for processing sensi-
tive data and protecting model IP. HTTPA/2
will enable Trust-as-a-Service (TaaS) for more
trustworthy Internet. With HTTPA/2 and
TaaS, Internet users will have freedom of choice
to trust, the right to verify assurances, and the
right to know the veriﬁed details. Users are able
to make their decision out of free will based on
the faithful results that they consider and choose
to believe. It becomes possible that we can build
genuine trust between two endpoints. Thus, we
believe that HTTPA/2 will accelerate the trans-
formation process towards trustworthy Internet
for a better digital world.

7 Acknowledgements

We would like to acknowledge the support from
the HTTPA workgroup members, including our
partners and reviewers. We thank their valuable
feedback and suggestions.

8 Notices & Disclaimers

No product or component can be absolutely se-
cure.

20

Acronyms

HSTS HTTP Strict Transport Security. 13

HTTP Hypertext Transfer Protocol. 1–5, 8,

15, 18, 19

(EC)DHE Ephemeral (Elliptic Curve) Diﬃe-

HTTPA HTTP Attestable. 1–8, 11–14, 17–20

Hellman. 9

HTTPS HTTP Secure. 2

AAD Authenticated Associated Data. 5, 6

IntAuth integrity and authenticity. 5–7, 12–14,

AE Authenticated Encryption. 7, 14

17

AEAD Authenticated Encryption with Associ-

ated Data. 6, 9

AHF Attest Header Field. 4, 7–9, 11–15, 17

AHL Attest Header Line. 3–6, 8, 9, 11–15, 18,

19

AK attestation key. 3

Intel® SGX Intel® Software Guard Exten-

sions. 3

Intel® TDX Intel® Trust Domain Exten-

sions. 3

ISV independent software vendor. 3

MAC Message Authentication Code. 6

AtB Attest Base. 3–5, 8, 11–15, 17, 19

mHTTPA Mutual HTTPA. 5, 6, 12, 19

AtBr Attest Binder. 6

MITM Man-in-the-Middle. 6

AtHS Attest Handshake. 3–8, 10, 12–15, 17, 19

AtQ Attest Quote. 3, 5, 6, 8, 12, 13, 19

AtR Attest Request. 3–9, 11–15, 18, 19

AtSP Attest Secret Provisioning. 3, 4, 13–15,

17

AtT Attest Ticket. 5, 6

CA certiﬁcation authority. 5, 6

PFS Perfect Forward Secrecy. 8

PII Personally Identiﬁable Information. 2

PoC proof-of-concept. 20

QService Quoting Service. 3

QUDD Quote User Deﬁned Data. 3, 5–7, 12,

13

ConfIntAuth conﬁdentiality, integrity and au-

RA remote attestation. 1–3, 7, 12

thenticity. 2, 4, 5

REE Rich Execution Environment. 2

CSP Cloud Service Provider. 2, 20

RoT Root of Trust. 19

ECDHE Ephemeral Elliptic Curve Diﬃe-

RTT round trip time. 5, 8, 13

Hellman. 8, 11

HF Header Field. 8, 14

HKDF HMAC-based Extract-and-Expand Key

SVN security version number. 3

TaaS Trust-as-a-Service. 20

Derivation Function. 9, 11

TCB trusted computing base. 1–3, 12

21

TClient TEE-based client. 5–7, 12

TEE Trusted Execution Environment. 1–5, 7,

8, 11, 12, 19

TLS Transport Layer Security. 1, 2, 4, 5, 7–9,

12, 17–19

TrC Trusted Cargo. 5, 6, 13, 14

TrR Trusted Request. 3–5, 15, 18

TrTLS Trusted Transport Layer Security. 7

TService TEE-based service. 1–9, 11–15, 17–

19

UniqIntAuth uniqueness,

integrity and au-

thenticity. 3

URI Uniform Resource Identiﬁer. 3, 5, 8

UTC Coordinated Universal Time. 13

UtR Un-trusted Request. 3–5, 11

UX user experience. 17

22

References

[1] A Backman, J Richer, and M Sporny.
draft-ietf-
Tech.
IETF, 2019. URL:

HTTP Message Signatures
httpbis-message-signatures-08.
rep.
https://www.ietf.org/archive/id/draft-
ietf-httpbis-message-signatures-08.html.

Internet-Draft.

[2] Alexander Sprogø Banks, Marek Kisiel,
and Philip Korsholm. “Remote Attesta-
tion: A Literature Review”. In: CoRR
abs/2105.02466 (2021). arXiv: 2105 .
02466. url: https : / / arxiv . org / abs /
2105.02466.

[3] Karthikeyan Bhargavan et al. “Downgrade
resilience in key-exchange protocols”. In:
2016 IEEE Symposium on Security and
Privacy (SP). IEEE. 2016, pp. 506–525.

[4] H. Birkholz

et
tion
Procedures
ietf-rats-architecture-12.
Internet-Draft.
IETF,
https://www.ietf.org/archive/id/draft-
ietf-rats-architecture-12.html.

al. Remote Attesta-
draft-
rep.
URL:

Architecture
Tech.
2021.

[5] Execution Environments. url: https :
/ / www . sciencedirect . com / topics /
computer - science / execution -
environments.

[6] Roy T. Fielding and Julian Reschke.
Hypertext Transfer Protocol (HTTP/1.1):
Message Syntax and Routing. RFC 7230.
June 2014. doi: 10.17487/RFC7230. url:
https : / / www . rfc - editor . org / info /
rfc7230.

[7] Roy T. Fielding and Julian Reschke. Hy-
pertext Transfer Protocol (HTTP/1.1): Se-
mantics and Content. RFC 7231. June
2014. doi: 10 . 17487 / RFC7231. url:
https : / / www . rfc - editor . org / info /
rfc7231.

[8] Sarah C. Helble et al. “Flexible Mecha-
nisms for Remote Attestation”. In: ACM
Trans. Priv. Secur. 24.4 (2021). issn: 2471-

23

2566. doi: 10.1145/3470535. url: https:
//doi.org/10.1145/3470535.

[9] Jeﬀ Hodges, Collin Jackson, and Adam
Barth. HTTP Strict Transport Security
(HSTS). RFC 6797. Nov. 2012. doi: 10.
17487/RFC6797. url: https://www.rfc-
editor.org/info/rfc6797.

[10]

Innovative Technology for CPU Based At-
testation and Sealing. url: https://www.
intel . com / content / dam / develop /
external / us / en / documents / hasp -
2013 - innovative - technology - for -
attestation-and-sealing.pdf.

[11] Patrick Jauernig, Ahmad-Reza Sadeghi,
and Emmanuel Stapf. “Trusted execu-
tion environments: properties, applica-
tions, and challenges”. In: IEEE Security
& Privacy 18.2 (2020), pp. 56–60.

[12] Gordon King and Hans Wang. HTTPA:
HTTPS Attestable Protocol. 2021. doi: 10.
48550/ARXIV.2110.07954. url: https:
//arxiv.org/abs/2110.07954.

[13] Dr. Hugo Krawczyk and Pasi Eronen.
HMAC-based Extract-and-Expand Key
Derivation Function (HKDF). RFC 5869.
May 2010. doi: 10.17487/RFC5869. url:
https : / / www . rfc - editor . org / info /
rfc5869.

[14] Hugo Krawczyk. “SIGMA: The ‘SIGn-and-
MAc’ Approach to Authenticated Diﬃe-
Hellman and Its Use in the IKE Pro-
tocols”.
In: Advances in Cryptology -
CRYPTO 2003. Ed. by Dan Boneh. Berlin,
Heidelberg: Springer Berlin Heidelberg,
2003, pp. 400–425. isbn: 978-3-540-45146-
4.

[15] Adam Langley, Mike Hamburg, and Sean
Turner. Elliptic Curves for Security. RFC
7748. Jan. 2016. doi: 10.17487/RFC7748.
url: https : / / www . rfc - editor . org /
info/rfc7748.

[16] David McGrew. An Interface and Algo-
rithms for Authenticated Encryption. RFC
5116. Jan. 2008. doi: 10.17487/RFC5116.
url: https : / / www . rfc - editor . org /
info/rfc5116.

[17] J¨ames M´en´etrey et al. “An Exploratory
for
Study of Attestation Mechanisms
Trusted Execution Environments”.
In:
(2022). doi: 10 . 48550 / ARXIV . 2204 .
06790. url: https : / / arxiv . org / abs /
2204.06790.

[18] Yoav Nir, Simon Josefsson, and Manuel
P´egouri´e-Gonnard. Elliptic Curve Cryp-
tography (ECC) Cipher Suites for Trans-
port Layer Security (TLS) Versions 1.2
and Earlier. RFC 8422. Aug. 2018. doi:
10.17487/RFC8422. url: https://www.
rfc-editor.org/info/rfc8422.

Structured Field Values

[19] Mark Nottingham and Poul-Henning
Kamp.
for
HTTP. RFC 8941. Feb. 2021. doi:
10 . 17487 / RFC8941. url: https :
//www.rfc-editor.org/info/rfc8941.

[20] Remote Attestation. url: https://www.
intel . com / content / www / us / en /
developer / tools / software - guard -
extensions / attestation - services .
html.

[21] Eric Rescorla. The Transport Layer Se-
curity (TLS) Protocol Version 1.3. RFC
8446. Aug. 2018. doi: 10.17487/RFC8446.
url: https : / / www . rfc - editor . org /
info/rfc8446.

[22] Roots of Trust (RoT). url: https : / /
csrc . nist . gov / Projects / Hardware -
Roots-of-Trust.

[23] G¨oran Selander et al. Object Security for
Constrained RESTful Environments (OS-
CORE). RFC 8613. July 2019. doi: 10 .
17487/RFC8613. url: https://www.rfc-
editor.org/info/rfc8613.

24

