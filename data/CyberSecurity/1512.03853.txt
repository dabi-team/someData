Secure Estimation based Kalman Filter for
Cyber-Physical Systems against Adversarial Attacks
Young Hwan Chang∗, Qie Hu∗, Claire J. Tomlin

1

6
1
0
2

n
u
J

9

]

Y
S
.
s
c
[

2
v
3
5
8
3
0
.
2
1
5
1
:
v
i
X
r
a

Abstract—Cyber-physical systems are found in many applica-
tions such as power networks, manufacturing processes, and air
and ground transportation systems. Maintaining security of these
systems under cyber attacks is an important and challenging
task, since these attacks can be erratic and thus difﬁcult to model.
Secure estimation problems study how to estimate the true system
states when measurements are corrupted and/or control inputs
are compromised by attackers. The authors in [1] proposed a
secure estimation method when the set of attacked nodes (sensors,
controllers) is ﬁxed. In this paper, we extend these results to
scenarios in which the set of attacked nodes can change over time.
We formulate this secure estimation problem into the classical
error correction problem [2] and we show that accurate decoding
can be guaranteed under a certain condition. Furthermore, we
propose a combined secure estimation method with our proposed
secure estimator and the Kalman Filter for improved practical
performance. Finally, we demonstrate the performance of our
method through simulations of two scenarios where an unmanned
aerial vehicle is under adversarial attack.

Index Terms—Cyber-physical systems, Error correction, Se-

cure estimation

I. INTRODUCTION

Cyber-physical systems (CPS) consist of physical compo-
nents such as actuators, sensors and controllers that communi-
cate with each other over a network. For example, unmanned
aerial vehicles (UAV) may obtain position measurements from
a Global Positioning System (GPS) or communicate with
remote control centers. Although communication networks are
often protected by security measures, cyber attacks can still
take place when a malicious attacker obtains unauthorized
launching jamming attacks [3] or spooﬁng sensor
access,
readings and sending erroneous control signals to actuators
[4]. For CPS, cyber attacks not only compromise information
but can also cause damage in the physical process. This
presents new challenges and thus demands new strategies and
algorithms [5].

There has been extensive work on the security of CPS.
Each of them relies on speciﬁc assumptions about attackers’
strategies and it is rarely the case, if not impossible, that
one estimator/detector can protect against all possible attacks.
[6]–[9] studied optimal attack strategies for different control
systems and applications. From the controller’s point of view,
researchers have studied how to detect attacks [10], [11] and

Y. H. Chang is with the Department of Biomedical Engineering,
Oregon Health and Science University, Portland, OR 97201 USA (e-
mail:chanyo@ohsu.edu).

Q. Hu, C.J Tomlin are with the Department of Electrical Engineering and
Computer Sciences, University of California, Berkeley, CA 94720 USA (e-
mail:{qiehu, tomlin}@eecs.berkeley.edu).

*These authors contributed equally

how to accurately estimate the states and control the system
when it is under attack. One approach for the latter, which is
adopted in robust control and ﬁltering methods, is to model
the attack signal as process or measurement noise, and assume
that they are bounded [12] or follow a certain probabilistic
distribution [13], [14]. An alternative approach uses game
theory, where the controller and attacker are players with
competing goals in a game [15]–[19]. Finally, the authors
of [20] proposed a hybrid controller, where each constituent
controller protects against a speciﬁc type of attack.

Recently, [1] studied secure estimation of a linear time
invariant system where attack signals can be arbitrary and
unbounded, thus protecting the system against more general
cyber-attacks. Later, [21] and [22] extended this work by
relaxing the assumption of having an exact system model and
proposing an SMT-based observer that handles large systems
with thousands of sensors, respectively. One limiting assump-
tion of [1], [21], [22] is that the set of attacked nodes/sensors
is ﬁxed and can not change over time. If a malicious attacker
is aware of this, then he or she can exploit this weakness and
attack different sensors at different time steps so that such a
decoder would fail.

In this paper, we are interested in the case in which the
set of attacked nodes can change over time. By doing so,
our proposed decoder can protect the system against more
general attack scenarios than that presented in [1]. We believe
this is a signiﬁcant contribution, because it is difﬁcult, if
not impossible, to anticipate cyber attackers’ strategies and
behavior, thus a decoder that is able to handle more general
attacks is an improvement. Furthermore, security studies on
the current trafﬁc infrastructure [23] demonstrated that once
a cyber attacker gains access to the trafﬁc network at a
single point, the attacker can send commands to any trafﬁc
intersection in the network. In other words, the attacker can
freely attack a different set of trafﬁc signals (sensors) at any
time. Indeed, an attacker who desires to travel through a set of
roads as fast as possible would attack different trafﬁc lights to
always give him/herself green lights as he/she moves through
the road network.

A. Contributions

There are four main contributions in this paper:
1) We propose a secure decoder for a linear time invariant
system under sensor attack, where the attacked sensors
can change with time, and attack signals can be un-
bounded and arbitrary. The proposed decoder is based
on l1 optimization and is computationally efﬁcient.

 
 
 
 
 
 
2) We prove the maximum number of sensor attacks that
can be corrected with our decoder, which turns out to
be the same as that of the decoder proposed in [1]. This
is a very nice result as it shows that, compared to [1],
our decoder can protect the system against more general
attacks, and at the same time, it does not compromise the
number of attacks that can be corrected.

3) We propose a practical method for decoder design that
guarantees accurate decoding. First, we formulate the
secure estimation problem into the classical error cor-
rection (EC) problem [2]. In EC, accurate decoding can
be guaranteed if the coding matrix satisﬁes the Restricted
Isometric Properties (RIP), which unfortunately are very
difﬁcult to check, in addition, we cannot choose a random
coding matrix a priori in our problem setting. Instead of
using RIP, in Theorem 1, we provide a sufﬁcient condition
for perfect recovery of the system states against sensor
attacks.

4) Finally, we propose to combine our decoder with a
Kalman Filter (KF) to improve its practical performance.
The KF ﬁlters out both occasional estimation errors by the
secure decoder and noisy measurements. We demonstrate
the effectiveness of our combined estimator using two
examples of UAVs under adversarial attack.

B. Organization of the Paper

This paper is organized as follows. Section II gives an
overview of secure estimation for CPS when attacked nodes
are ﬁxed, as well as compressive sensing and error correction.
Section III formulates the problem of secure estimation when
attacked nodes can change over time and compares it with
the case when attacked nodes are ﬁxed. In Section IV, we
describe our decoder design method and assess the decoder’s
practical performance through extensive simulations. In addi-
tion, we describe how to combine it with a KF to improve its
performance in practice. Finally we present two more realistic
numerical examples of UAVs subject to adversarial attack in
Section V. In this paper, we focus on estimation of states
under sensor attack, hence the terms ‘estimator’ and ‘decoder’,
‘sensor’ and ‘node’, ‘attack vector’ and ‘error vector’ are used
interchangeably.

C. Notation

• |supp(x)| denotes the support of vector x,

i.e.,

the

number of nonzero components in x1.

• (cid:107)x(cid:107)l1

:= (cid:80)n

i=1|xi| where x ∈ Rn. Note that this is not

the same as |rowsupp(·)| deﬁned in [1].

• For a matrix M ∈ Rm×n, N (M ) = {x ∈ Rn|M x = 0}
represents the null space of M . R(M ) denotes the range
space of M , and is deﬁned as the set of all possible linear
combinations of its column vectors.

2

II. OVERVIEW

A. Secure Estimation for Fixed Attacked Nodes [1]

Consider a linear dynamical system in the presence of

attacks:

x(t+1) = Ax(t)

y(t) = Cx(t) + e(t)

(1)

where x(t) ∈ Rn represents the state of the system at time t ∈
N, y(t) ∈ Rp is the output of the sensors at time t and e(t) ∈
Rp represents attack signals injected by malicious agents at
the sensors.

In [1], the authors proposed an elegant state estimation
algorithm against adversarial attacks, where the attack signals
can be unbounded and arbitrary, but they assumed that the
set of attacked nodes K does not change over time. More
precisely, if K ⊂ {1, ..., p} is the set of nodes that were
attacked, then we have for all t, supp(e(t)) ⊂ K. The problem
of reconstructing the initial state x(0) of the plant from the
corrupted observations (y(t)) was formulated as follows:

Deﬁnition 1. ([1]) q errors are correctable after T steps by
the decoder D : (Rp)T → Rn if for any x(0) ∈ Rn, any
K ⊂ {1, .., p} with |K| ≤ q, and any sequence of vectors
e(0), ..., e(T −1) in Rp such that supp(e(t)) ⊂ K, we have
D(y(0), ..., y(T −1)) = x(0) where y(t) = CAtx(0) + e(t) for
t = 0, ..., T − 1.
Proposition 1. ([1]) Let T ∈ N\{0}. The following are
equivalent:
(i) There is a decoder that can correct q errors after T steps;
(ii) For all z ∈ Rn\{0}, |supp(Cz) ∪ supp(CAz) ∪ · · · ∪
supp(CAT −1z)| > 2q.

The authors then proposed the optimal decoder:
(cid:13)
(cid:13)
(cid:13)l0

(cid:13)
(cid:13)Y (T ) − Φ(T )(x)
(cid:13)

x(0) = arg min

x

(2)

where the l0 “norm” of matrix M is the number of nonzero
rows in M [1]:

(cid:44) |rowsupp(M )| = |{i ∈ {1, ..., p}|Mi (cid:54)= 0}|

(cid:107)M (cid:107)l0
where Mi
Y (T ) = (cid:2)y(0)
and Φ(T )
a
(cid:2)Cx | CAx |

is

represents
y(1)

|

row

i-th
|

the
...

of M .
y(T −1)(cid:3) ∈ Rp×T
|
linear map such that Φ(T )(x) =
| CAT −1x(cid:3) ∈ Rp×T . Therefore
...
e(T −1)(cid:3) ,

e(1)

...

|

|

|

Y (T ) − Φ(T )(x) = (cid:2)e(0)

which we refer to as the error matrix in the sequel, and consists
of horizontally stacked attack/error vectors from time t = 0
to t = T − 1. In other words, the decoder ﬁnds the x(0)
that minimizes the number of nonzero rows in the resulting
error matrix. The foundation for this decoder to work is the
assumption of ﬁxed attacked nodes. As an illustration, consider
a system with a single attacked node and construct the error
matrix

1If f is any real-valued or vector-valued function on a topological space
X, the support of f , denoted by supp(f ), is the closure of the set points
where f is nonzero: supp(f ) = {x ∈ X | f (x) (cid:54)= 0}.

(cid:2)e(0)

|

e(1)

|

...

|

e(T −1)(cid:3) =


0
∗


0

0

0
∗
0
0

· · ·
· · ·
· · ·
· · ·







0
∗
0
0

,

where ∗ denotes a nonzero component (i.e., attack or corrup-
tion). Observe that the set of nonzero rows corresponds to
the set of attacked nodes, and furthermore, if a small number
of nodes are attacked, then necessarily only a small number
of rows are not identically zero and the error matrix has a
small row support. The decoder in [1] works by leveraging
this property of ﬁxed attacked nodes.

What happens if the attacked nodes can change over time?
To answer this, let’s look at another example where the system
has a single attacked node again, however the attacked node
is cycled through all nodes such that the error matrix is as
follows

(cid:2)e(0)

|

e(1)

|

...

|

e(T −1)(cid:3) =


0
∗
0
∗


0 0

0 0

· · ·
· · ·
· · ·
· · ·



0
0


0

∗

.

Observe that although a single node is attacked at any time
t, since the attacked node is changing over time, the error
matrix has full row support. Therefore a decoder that attempts
to ﬁnd the optimal x(0) by minimizing the row support of
the error matrix does not work here. One may argue that this
decoder can be used with T = 1, to solve a secure estimation
problem where the attacked nodes change over time. However,
when T = 1, the number of correctable errors cannot be large.
From Proposition 1 (i.e. Proposition 2 in [1]), “the decoder
can correct q errors after T = 1 step if and only if for all
z ∈ Rn\{0}, |supp(Cz)| > 2q”. As an example, for any
C ∈ Rp×n where p < n, C has a nontrivial null space, hence
there exists z ∈ Rn\{0} such that |supp(Cz)| = 0; in other
words, zero errors are correctable. Therefore, the decoder for
ﬁxed attacked nodes cannot be easily extended to when the
attacked nodes can change over time, and a new decoder is
required for the latter.

In this paper, we propose such a new decoder, one that is
suitable for when the set of attacked nodes can change over
time. Our decoder is inspired by the error correction problem
[2] and by observing that if we construct the error matrix by
stacking the error vectors e(0), · · · , e(T −1) vertically, instead
of horizontally, then even when the attacked nodes can change
over time, as long as the number of attacked nodes at each time
t is small, the error matrix (which is a large error vector in this
case) is sparse. Before we dive into details of this method and
its properties, we ﬁrst give a brief overview about compressive
sensing and error correction in the following section.

B. Overview: Compressive Sensing and the Error Correction
Problem [2]

1) Compressive Sensing: Sparse solutions x ∈ Rn, are

sought to the following problem:

min
x

(cid:107)x(cid:107)0 subject to b = Ax

(3)

where b ∈ Rm are the measurements, A ∈ Rm×n (m (cid:28) n) is
a sensing matrix and (cid:107)x(cid:107)0 denotes the number of nonzero
elements of x. The following lemma provides a sufﬁcient
condition for a unique solution to (3) [2]:

3

Lemma 1. ([24]) If the sparsest solution to (3) has (cid:107)x(cid:107)0 = q,
m ≥ 2q and all subsets of 2q columns of A are full rank, then
the solution is unique.

Proof. Suppose the solution is not unique, hence there exists
xa (cid:54)= xb such that Ax1 = b and Ax2 = b where (cid:107)x1(cid:107)0 =
(cid:107)x2(cid:107)0 = q. Then A(x1 − x2) = 0 and x1 − x2 (cid:54)= 0. Since
(cid:107)x1 − x2(cid:107)0 ≤ 2q and all 2q columns of A are full rank (i.e.
linearly independent), it is impossible to have x1 − x2 (cid:54)= 0
that satisﬁes A(x1 − x2) = 0 (contradiction).

2) The Error Correction Problem [2]: Consider the classi-
cal error correction problem: y = Cx+e where C ∈ Rp×n is a
coding matrix (p > n) and assumed to be full rank. We wish to
recover the input vector x ∈ Rn from corrupted measurements
y. Here, e is an arbitrary and unknown sparse error vector. To
reconstruct x, note that it is obviously sufﬁcient to reconstruct
the vector e since knowledge of Cx + e together with e gives
Cx, and consequently x since C has full rank [2]. In [2], the
authors construct a matrix F which annihilates C on the left,
i.e. F Cx = 0 for all x. Then, they apply F to the output y
and obtain

˜y = F (Cx + e) = F e

(4)

Thus, the decoding problem can be reduced to that of recon-
structing a sparse vector e from the observations ˜y = F e.
Therefore, by Lemma 1, if all subsets of 2q columns of F are
full rank, then we can reconstruct any e whose |supp(e)| ≤ q.
We refer to a decoder that can correct q errors as a q-error-
correcting decoder.

3) Equivalence between the two programs l0 and l1: In
[2], the authors mentioned that the computational intractability
of the l0-program led researchers to develop alternatives, and
a frequently discussed approach considers a similar program
in the l1 norm which goes by the name of Basis Pursuit.
Motivated by the problem of ﬁnding sparse decompositions of
special signals in the ﬁeld of mathematical signal processing,
a series of beautiful and ground breaking works [25]–[28]
showed exact equivalence between the two programs l0 and
l1 when the RIP conditions are satisﬁed. Therefore, the l0
norm in (3) can be approximated by an l1 norm to give a
convex decoder and is therefore computationally feasible. We
will discuss in more detail the conditions required to ensure
accurate decoding using an l1-optimization based decoder in
Section IV.

III. SECURE ESTIMATION WHEN ATTACKED NODES CAN
CHANGE WITH TIME

A. Problem Formulation

Consider the linear time invariant system as follows:

x(t+1) = Aox(t) + Bu(t)
y(t) = Cx(t) + e(t)

(5)

where x(t) ∈ Rn, y(t) ∈ Rp and u(t) ∈ Rm are the states,
measurements and control inputs at time t. e(t) ∈ Rp is the
attack signal, and we assume that the attacked nodes can
change over time. We deﬁne the number of correctable errors
as follows:

Deﬁnition 2. When the set of attacked nodes can change over
time, q errors are correctable after T steps by the decoder
D : (Rp)T → Rn if for any x(0) ∈ Rn and any sequence of
vectors e(0), ..., e(T −1) in Rp such that |supp(e(t))| ≤ q, we
have D(y(0), ..., y(T −1)) = x(0) where y(t) = CAtx(0) + e(t)
for t = 0, ..., T − 1.

Note that the closed-loop system with state-feedback is con-
trollable if and only if the open-loop system is controllable.
the observability of a
However, state-feedback may affect
system.

Proposition 2 below, gives two equivalent sufﬁcient condi-

tions for the existence of a unique solution x(0) to (6).

4

In addition, assume that a local control loop implements
secure state feedback: u(t) = Gx(t), i.e. the local control
loop is not subject to attack. The resulting closed loop system
matrix is A (= Ao + BG). In practice, this represents the
following scenario: a physical system possesses a local control
loop that has direct access to the state of the plant and can
control the evolution of the physical system. This is reasonable
if the sensors are connected to the local controller through
a wired link that is not subject to external attacks. Also,
as part of the overall plant, a higher-level supervisory and
monitoring system receives measurements from the sensors
through wireless and vulnerable communication links that are
subject to attacks [1]. A concrete example is a UAV that uses
measurements from onboard, hardwired sensors such an Iner-
tial Measurement Unit (IMU) for its autopilot and trajectory
following (i.e. secure local control loop), and communicates
wirelessly with a remote control center (i.e. vulnerable link
subject to attack).

B. Reformulation into an Error Correction Problem

The problem that we want to solve is how to reconstruct the
initial state x(0) of the system from the corrupted observations
(y(t)) where t = 0, ..., T − 1. Let Eq,T denote the large vector
with error vectors from time t = 0 to t = T − 1 stacked
vertically: (cid:2)e(0); ... ; e(T −1)(cid:3) ∈ Rp·T , where each e(t) satisﬁes
|supp(e(t))| ≤ q ≤ p as in Deﬁnition 2.








Y (cid:44)

=






y(0)
y(1)
...
y(T −1)
C
CA
...
CAT −1




















=

Cx(0) + e(0)
CAx(0) + e(1)
...
CAT −1x(0) + e(T −1)











(6)

x(0) + Eq,T (cid:44) Φx(0) + Eq,T

where Y ∈ Rp·T is the set of vertically stacked corrupted
measurements and Φ ∈ Rp·T ×n represents the observability
matrix of the closed loop system. Assume rank(Φ) = n, which
is reasonable because otherwise, the system is unobservable
and thus x(0) cannot be determined even if there is no attack
(Eq,T = 0).

• Open-loop case (B = 0): A full column rank condition
represents the pair (Ao, C) being observable. In other
words, if not, one cannot reconstruct x(0) even if there
are no errors in the measurements.

• State-feedback case: Since state-feedback may affect the
observability of a system (even though the pair (Ao, C)
is observable), we have to satisfy rank(Φ) = n for the
closed-loop system with state-feedback.

Proposition 2. Given Y = Φx + E, Φ ∈ Rp·T ×n is full rank
and 2s = 2q · T ≤ p · T − n, then the following are equivalent:
(i) all subsets of 2s columns of Q(cid:62)
2 are linearly independent,
where Φ = (cid:2)Q1 Q2
is the QR decomposition of Φ
and Q(cid:62)
(ii) |supp(Φz)| > 2s for all z ∈ Rn\{0}.

2 ∈ R(p·T −n)×p·T ;

(cid:20)R1
0

(cid:21)

(cid:3)

Proof. (ii) =⇒ (i)
: Suppose there exist 2s columns of
Q(cid:62)
2 that are linearly dependent. Then, there exists E0 (cid:54)= 0
such that Q(cid:62)
2 E0 = 0 where |supp(E0)| ≤ 2s. Observe that
N (Q(cid:62)
2 ) = R(Φ), therefore there exists z such that E0 = Φz
(i.e., E0 ∈ R(Φ)). Then, |supp(Φz)| = |supp(E0)| ≤ 2s
(contradiction).

(i) =⇒ (ii): We again resort to contradiction. Suppose
that there exists z (cid:54)= 0 such that |supp(Φz)| ≤ 2s. Let L1
and L2 be two disjoint subsets of {1, ..., p · T } with |L1| ≤ s
and |L2| ≤ s such that L1 ⊕ L2 = supp(Φz) (such L1 and L2
exist since |supp(Φz)| ≤ 2s < p · T ). Let E1 = Φz|L1 be the
vector obtained from Φz by setting all the components outside
of L1 to 0, and similarly let E2 = −Φz|L2 (i.e., E1 (cid:54)= E2).
Then we have Φz = E1 − E2 with supp(E1) ⊂ L1 and
supp(E2) ⊂ L2 with |L1| ≤ s and |L2| ≤ s. Now, consider
Y = Φz + E

˜Y = Q(cid:62)
= Q(cid:62)
=⇒ Q(cid:62)

2 (Φz + E) = Q(cid:62)
2 E = Q(cid:62)

2 Y = Q(cid:62)
2 (E1 − E2) + Q(cid:62)
2 (E1 − E2) = 0

2 (E1 − E2 + E)
2 E

The last equality is due to N (Q(cid:62)
Since all subsets of 2s columns of Q(cid:62)
dent, E1 − E2 = 0 (contradiction).

2 ) = R(Φ) (i.e. Q(cid:62)

2 Φ = 0).
2 are linearly indepen-

Next, we present two methods, inspired by error correction
techniques [2] [24], for estimating x(0). We show their equiv-
alence and provide sufﬁcient conditions for the existence of a
unique solution.
Decoder 1: The ﬁrst method determines the error vector Eq,T
ﬁrst, and then solves for x(0). Consider the QR decomposition
of Φ ∈ Rp·T ×n,

Φ = (cid:2)Q1 Q2

(cid:3)

(cid:21)

(cid:20)R1
0

= Q1R1

(7)

(cid:3) ∈ Rp·T ×p·T

where (cid:2)Q1 Q2
is orthogonal, Q1 ∈
Rp·T ×n, Q2 ∈ Rp·T ×(p·T −n) and R1 ∈ Rn×n is a rank-n
upper triangular matrix. Pre-multiply (6) by (cid:2)Q1 Q2
(cid:20)R1
0

x(0) +

Eq,T .

Y =

(8)

(cid:3)(cid:62)

(cid:21)

(cid:21)

(cid:21)

(cid:20)Q(cid:62)
1
Q(cid:62)
2

(cid:20)Q(cid:62)
1
Q(cid:62)
2

:

We can now solve for Eq,T using the second block row:

˜Y (cid:44) Q(cid:62)

2 Y = Q(cid:62)

2 Eq,T

(9)

2 ∈ R(p·T −n)×p·T . From Lemma 1, Equation (9) has
where Q(cid:62)
a unique, s(≤ q · T )-sparse solution if all subsets of 2s(≤
2q · T ) columns of Q(cid:62)
2 are full rank (this is a reasonable
assumption if (p · T − n) ≥ 2s = 2q · T ). Therefore, the
secure decoder has two steps, we ﬁrst solve the following l1-
minimization problem

ˆEq,T = arg min
E

(cid:107)E(cid:107)l1

subject to ˜Y = Q(cid:62)

2 E

(10)

Note that the l0 norm in (3) was replaced with with the l1
norm in (10) to give a convex program, which was proposed
by Candes and Tao in [2]. In addition,
in Section II-B3
we discussed the conditions for equivalence of these two
programs.

With ˆEq,T in hand, we then solve for x(0) in the second

step using the ﬁrst block row of Equation (8):

x(0) = R−1

1 Q(cid:62)

1 (Y − ˆEq,T )

(11)

Decoder 2: The second method recovers x(0) from the
corrupted data Y directly by solving the following l1-
minimization problem [2]:

min
x

(cid:107)Y − Φx(cid:107)l1

(12)

Lemma 2. x(0) is the unique solution of (12) if and only if
ˆEq,T is the unique solution of (10).
Proof. (By [2]) Observe that on one hand, since Y = Φx(0) +
Eq,T and we may decompose x = x(0) + v, hence

(12) ⇔ min

v

(cid:107)Eq,T − Φv(cid:107)l1

On the other hand, the constraint Q(cid:62)
2 Eq,T
means that E = Eq,T − Φv for some v ∈ Rn and, therefore,

2 E = ˜Y = Q(cid:62)

(10) ⇔ min

v

⇔ min

v

E = Eq,T − Φv

,

(cid:107)E(cid:107)l1
(cid:107)Eq,T − Φv(cid:107)l1

Thus, (10) and (12) are equivalent programs [2].

Even though we are interested in the state x(0) and not
necessarily the error vectors Eq,T , Lemma 2 states that
if the attack vectors cannot be uniquely determined from
(10), then we cannot estimate x(0) uniquely from (12). [1]
also mentioned this notion: the existence of a decoder that
can correct q errors is equivalent to saying that the map,
(cid:3) : Rn × Eq,T → (Rp)T has an inverse for the ﬁrst
(cid:2)Φ Iq·T
(cid:21)
n components of its domain where Y = (cid:2)Φ Iq·T
since the attack vectors are uniquely determined by x(0) and
the y(t)’s, i.e., e(t) = y(t) − CAtx(0).

(cid:20) x(0)
Eq,T

(cid:3)

C. Comparison with Secure Estimation for Fixed Attacked
Nodes

We refer to a decoder that can correct q errors as a q-error-
correcting decoder. It is interesting to compare the conditions
for the existence of a q-error-correcting decoder for when
the attacked nodes are ﬁxed (Proposition 1) and when the

5

attacked nodes can change over time (Proposition 2) are :
∀z ∈ Rn\{0},

(i) |supp(Cz) ∪ supp(CAz) ∪ · · · ∪ supp(CAT −1z)| > 2q

(the set of attacked nodes is ﬁxed)
T −1
(cid:88)

(ii) |supp(Φz)| =

|supp(CAiz)| > 2q · T

i=0

(the set of attacked nodes can change)

(13)
It is easy to see that when T = 1, conditions (i) and (ii)
are equivalent as both of them reduce to |supp(Cz)| > 2q
for all z ∈ Rn\{0}. When T > 1 (i.e., with dynamics), the
comparison is not so straightforward. In [1], the authors proved
an equivalent condition for (i):

Lemma 3. Assume A has n distinct positive eigenvalues (0 <
λ1 < λ2 < · · · < λn) and T ≥ n. Then, the following are
equivalent:

(i) ∀z ∈ Rn\{0},

|supp(Cz) ∪ supp(CAz) ∪ · · · ∪ supp(CAT −1z)| > 2q

(ii) ∀vi ∈ Rn where Avi = λivi (i.e., eigenvector of A),

|supp(Cvi)| > 2q

Proof. Refer to the proof in [1].

The signiﬁcance of this lemma is that
in order to check
whether a decoder can guarantee accurate decoding of q errors
when the attacked nodes are ﬁxed, one no longer needs to
check satisﬁability of condition (i) which is stated for all
z ∈ Rn\{0} and hard to check, instead, one can simply check
condition (ii) for the eigenvectors of A which is much simpler.
Next, we derive a similar result for our decoder for when the
attacked nodes can change with time.
Theorem 1. Let A ∈ Rn×n, C ∈ Rp×n. Assume that C is
full rank, (A, C) is observable and A has n distinct positive
eigenvalues such that 0 < λ1 < λ2 < · · · < λn. Deﬁne:
• si (cid:44) |supp(Cvi)|, where vi is an eigenvector of A,
• S (cid:44) {s1, s2, · · · , sn},
• For every m ∈ {2, . . . , n}, let Sm be any subset of S
with m elements, deﬁne TSm
. Then
Tm is such that Tm > TSm for all subsets Sm, i.e. all
subsets of m elements from the set S.

(cid:44) (m−2)·p+min Sm

max Sm−2q

Choose T such that T ≥ max{T2, · · · , Tn}. Then,
following are equivalent:

the

(i) ∀vi ∈ Rn where Avi = λivi, |supp(Cvi)| > 2q
(ii) ∀vi ∈ Rn where Avi = λivi, |supp(Φvi)| > 2q · T
(iii) ∀z ∈ Rn\{0}, |supp(Φz)| > 2q · T

(i.e. condition (ii) in Equation (13))

In order to prove Theorem 1, we make use of Lemmas 5, 6
and Proposition 5 (see Appendix):

Proof. (Proof of Theorem 1)
is
simple to prove that
|supp(Φvi)| = (cid:80)T −1
i Cvi)| = T · |supp(Cvi)|.

First,
it
equivalent:
(cid:80)T −1

k=0 |supp(λk

(i) and (ii) are
k=0 |supp(CAkvi)| =

Second, we want to show that (ii) and (iii) are equivalent.
The direction (iii) =⇒ (ii) is trivial, since (ii) is a speciﬁc
case of (iii) with z = vi. The other direction is more complex.
Note that A is diagonalizable, therefore its eigenvectors form
a basis for Rn. Now consider the decomposition of z in the
eigenbasis of A, i.e. z = (cid:80)n
i=1 αivi with αi (cid:54)= 0 for at least
one i.

1) m = 1: Suppose there exists z ∈ Rn\{0} such that
|supp(Φz)| ≤ 2q · T . Without loss of generality, let
αi
(cid:54)= 0 and αj = 0 for all j (cid:54)= i, then, 2q · T ≥
|supp(Φz)| = |supp(αiΦvi)| = |supp(Φvi)| for all T
(contradiction, ∵ ∀vi, |supp(Φvi)| > 2q · T ).
2) m = 2: By Lemma 5, if we choose T > T2.
3) m ≥ 3: By Lemma 6 and Proposition 5, if we choose

T > Tm for each value of m, respectively.

We need to choose T to satisfy the worst case for any m such
that n ≥ m ≥ 2. Thus, if T ≥ max{T2, · · · , Tn}, then (ii)
and (iii) are also equivalent.

Proposition 3. Given C is full rank, the closed-loop matrix
A (= Ao + BG) has n distinct positive eigenvalues, the open-
loop pair (Ao, B) is controllable, the closed-loop pair (A, C)
is observable and T is chosen to satisfy Theorem 1. Then,
the condition for secure estimation of q-errors when the set of
attacked nodes is ﬁxed ((i) in (13)) is the same as the condition
for when the set of attacked nodes can change over time ((ii)
in (13)), except the condition on T .

Proof. Since the pair (Ao, B) is controllable, there exists a
feedback matrix G such that the eigenvalues of the closed-
loop matrix A, i.e., λ1, ..., λn can be arbitrarily located on
the complex plane. Then Proposition 3 directly follows from
Proposition 2, Lemmas 3 and Theorem 1

Theorem 1 and Proposition 3 state that if the feedback
system and the secure decoder are designed such that the
conditions in Proposition 3 are satisﬁed, then we can guarantee
accurate correction of q errors using our proposed secure
decoder for attacked nodes that can change over time, by
checking the following very simple condition:

∀vi ∈ Rn where Avi = λivi, |supp(Cvi)| > 2q.

And interestingly, this is the exact same condition that one
should check if one is designing the decoder from [1] for
ﬁxed attack nodes. In other words, it is equally easy to check
satisﬁability of the sufﬁcient condition for q-error-correction
for both types of decoders.

D. Discussion on Sufﬁcient Condition of T

Unsurprisingly, the condition on T from Theorem 1, is
different from that for a decoder designed for ﬁxed attack
nodes (T ≥ n). In [1], since the set of attack nodes is
ﬁxed, one can leverage the property of ﬁxed attacked nodes
(i.e., the number of nonzero rows in (2)). However, in our
setting, since the set of attack nodes can change over time,
we cannot leverage this property and thus, we need more
time steps T . In general, it is difﬁcult to see what the value
of T is, from the formula in Theorem 1. However it
is

6

reasonable to assume that one would design the feedback
matrix G and matrix C to maximize the number of errors
that can be corrected, i.e. q = max q = (cid:100)p/2 − 1(cid:101) (proved
in Section III-E). To achieve this, we must design G and C
such that si = |supp(Cvi)| = p for all eigenvectors of A.
In other words, max Sm = min Sm = p for all m and for
all subsets Sm. In this case, it is easy to see that according
Theorem 1, for any p that is an even number, we must choose:
T ≥ Tn > (n − 1) · p/2. In most cases, this T is larger than
n (the value of T required for the decoder for ﬁxed attacked
nodes).

At the ﬁrst look, this may seem like an unsatisfying result,
however there are two important points to note. First, a larger
value of T merely translates to a longer initial delay from time
t = 0 to t = T − 1 when the decoder collects enough (T )
measurements. From time t = T − 1 onwards, the decoding is
in real time and takes place at every time step t as the decoder
uses a “sliding window” of observations. Second, extensive
simulation results in this paper show that a value of T = n
is often sufﬁcient for our proposed decoder to achieve good
estimation, i.e. to perfectly recover the state under attacks
where the attacked nodes change over time.

This is because we consider the worst case (conservative)
scenario in Theorem 1. In the proof, we consider the case
where A has n distinct positive eigenvalues. What if A has
complex eigenvalues? For instance, assume that A ∈ R3×3
(n = 3) and it has one pair of complex conjugate eigenvalues
and one real eigenvalue, i.e., λ1, λ2(= ¯λ1), λ3 where λ1, λ2 ∈
C, λ3 ∈ R and ¯· represents the complex conjugate. We denote
v1 = x+iy, v2 = ¯v1 = x−iy and v3 = w where x, y, w ∈ Rn
are linearly independent. Any z ∈ Rn can be represented by a
linear combination of n independent vectors in Rn, i.e., z =
αv1 + ¯αv2 + βw = 2Re(αv1) + βw = α1x + α2y + βw where
α ∈ C, β ∈ R and α1 = Re(α) ∈ R and α2 = −Im(α) ∈ R.
Therefore, the same results for real eigenvalues applies. In
other words, if |supp(Cx)| = |supp(Cy)| = |supp(Cw)| =
, then |supp(Φz)| > 2q · T where
p and T >
sk
r,123 represents the number of cancelled support of linear
combinations of x, y and w at time step k.

k=0 sk
p−2q

(cid:80)T −1

r,123

E. Number of Correctable Errors

Given that

the set of attacked nodes can change over
time and e(t) satisﬁes |supp(e(t))| ≤ q for all t, we prove
in Proposition 4 (see below) that the maximum number of
correctable errors (as deﬁned in Deﬁnition 2) by our decoder
is (cid:100)p/2−1(cid:101), where p is the number of measurements. This is in
fact the same as the maximum number of correctable errors
for the decoder proposed in [1] which is for ﬁxed attacked
nodes. This is a pleasing result, because it demonstrates that
with our proposed decoder, we can relax the assumption of
the system against more
ﬁxed attacked nodes and protect
general attacks, without compromising the maximum number
of correctable errors.
Proposition 4. Let A0 ∈ Rn×n, B ∈ Rn×m and C ∈ Rp×n
and assume that the pair (A0, B) is controllable, C is full rank
and each row of C is not identically zero. Then there exists

7

a ﬁnite set F ⊂ C such that for any choice of n numbers
λ1, · · · , λn ∈ C\F such that 0 < λ1 < · · · < λn, there exists
G ∈ Rm×n such that:

4) The length of the sliding window of measurements T of

the decoder satisﬁes Theorem 12;

5) Maximize q subject to: ∀vi ∈ Rn where Avi = λvi,

• The eigenvalues of the closed-loop matrix A (= A0 +

|supp(Cvi)| > 2q.

BG) are λ1, · · · , λn.

• If the pair (A, C) is observable, then the number of
correctable errors for the pair (A, C) is maximal after
T = max{n, T ∗} time steps and is equal to (cid:100)p/2 − 1(cid:101),
where T ∗ is the value of T from Theorem 1.

Proof. The proof for Proposition 4 in [1] shows that if the
chosen poles λ1, · · · , λn are distinct, positive and do not fall
in some ﬁnite set F , then there is a choice of G such that the
eigenvalues of A (= A0 + B) are exactly the λ1, · · · , λn, and
the corresponding eigenvectors vi are such that |supp(Cvi)| =
p. Thus, by Proposition 3, the number of correctable errors for
(A, C) is (cid:100)p/2 − 1(cid:101).

In addition, recall that Eq,T consists of vertically stacked
error vectors from e(0), · · · , e(T −1), and observe that our
proofs for accurate decoding are independent of how the
individual error (nonzero) terms are distributed in the vector
Eq,T . Thus, if we remove the assumption: |supp(e(t))| ≤ q
for all t, and allow e(t) to appear in an arbitrary fashion,
e.g. |supp(e(0))| = 0 and |supp(e(1))| = 2q, as long as
(cid:80)T −1
t=0 |supp(e(t))| ≤ q·T , then our q-error-correcting decoder
can still recover the true states. In other words, our proposed
decoder can protect the system against more general attacks,
where the number of attacked nodes is not necessarily less
than or equal to q at every time.

IV. OPTIMAL DECODER DESIGN

In the classical error correction problem, to ensure accurate
decoding, the coding matrix must satisfy the RIP conditions
[2], which are extremely difﬁcult
to check in general. In
practice, Theorem 1.4 from [2] is almost always used to design
a coding matrix a priori. This theorem states that a coding ma-
trix whose entries are sampled from independent and identical
distributions satisﬁes the RIP condition with overwhelming
probability. In secure estimation, however, it is impossible
to choose such a coding matrix a priori because it is the
observability matrix Φ, which is structurally constrained: as
shown in (6), Φ consists of CAi’s where i = {0, · · · , T − 1}.
In this Section, we use Lemma 3, the results from Proposition
4 in [1] and state feedback to design a matrix Φ for accurate
decoding.

A. System and Decoder Design

Since conditions (i) and (iii) in Theorem 1 are equivalent,
condition (i) can be used to design a state feedback controller
such that the closed system can achieve accurate decoding.
Therefore, given a controllable open-loop pair (A0, B), design
C and choose an adequate feedback control law u(t) = Gx(t)
and construct a secure decoder such that:

1) Each row of C is not identically zero, and C is full rank;
2) The closed-loop matrix A (= A0 + BG) has n distinct

positive eigenvalues: 0 < λ1 < λ2 < · · · < λn;

3) (A, C) is observable;

loss of generality,

Without
the ﬁrst condition holds. For
example, if there exists a zero row in C, we can simply
remove that row from C without changing the system’s
behavior. Conditions 2, 3 and 4 are required for equivalence in
Theorem 1. The last condition is needed for accurate decoding
and for maximizing the number of correctable attacks. From
Proposition 4 the maximum number of correctable errors can
be achieved when |supp(Cvi)| = p (i.e.,
the number of
measurements) for all eigenvectors of A.

Conditions 2, 3 and 5 depend on the feedback controller. So
how do we choose a controller that achieves good performance
in both control and secure estimation? Below, we describe
an approach that we have taken in all simulations in this
paper, and has proved to work well. This is by no means the
only method. First, we design a controller that achieves good
control, for example, Linear Quadratic Regulators (LQR),
which are optimal with respect to a certain quadratic cost
function. However, these controllers may not have good secure
estimation properties, meaning the value of q that satisﬁes
|supp(Cvi)| > q for all eigenvectors of A may be small,
i.e., the resulting decoder can only correct few errors. It is
often easy to increase the value of q and make the decoder
more resilient to attacks by slightly perturbing the closed-loop
poles from those resulting from the LQR controller, such as
placing the poles closer to the origin, and making the poles
more spread out amongst themselves. We chose to keep the
perturbations small as to not lose too much control perfor-
mance. Although this is a heuristic method, it is relatively easy
to carry out in order to satisfy the above conditions; whereas
in the classical error correction method [2], checking whether
a coding matrix satisﬁes RIP is extremely difﬁcult.

To summarize, we start from some optimal controller which
may not result in a good decoder, then we perturb the closed-
loop poles slightly to improve the resulting decoder’s secure
estimation capability. Therefore there is a trade-off between
a system’s control and secure estimation performances, and
the feedback controller can be designed to achieve a desired
trade-off between them.

B. Practical Performance

In this Section, we show the performance of our proposed
decoder using an arbitrary system with n = 8, p = 10 and
T = n, where A is chosen arbitrarily (i.e., the entries of A
are chosen as independent and identically distributed random
variables) and C is chosen such that every row of C has only
one nonzero component (i.e., each row of C is not identically
zero) and is full rank. For each value of S (i.e. number of
total attacked nodes during T steps), we test the decoder
on 500 independent trials. For each trial, both the system
matrices and initial conditions are re-generated. The initial

2We found that much smaller T ’s are often sufﬁcient for good secure
estimation performance, i.e. to perfectly recover the attack signals. In all
simulations in this paper, T = n is used, where n is the number of states.

8

Fig. 1. Success rate and mean error of l1 decoder on different systems (ideal coding matrix, designed state feedback and poorly designed system with n = 8,
p = 10 and T = n, where black dot lines show the fundamental limit for dynamical systems and ideal coding matrix case respectively. We see that as the
number of attacked nodes increase, success rate decreases. Also, by designing state feedback gain properly, we improve success rate and decrease mean error.

system with a state feedback controller designed using the
method in Section IV-A and (3) a LTI system with a poorly
designed feedback controller. The performance metric used is
the success rate, which is deﬁned as the fraction of the total
500 trials that our decoder is able to perfectly recover the
attack signals. System 1 acts as the baseline for the comparison
because a random coding matrix has good RIP and represents
the best achievable decoding performance. However it is not
a realistic dynamical system. For a realistic LTI system, the
coding matrix Φ is constructed by stacking CAt’s as in (6)
where t = {0, ..., T − 1}. This structural constraint can reduce
the restricted isometry constant (i.e., a measure of how good
the RIP is, larger restricted isometry constants correspond to
better RIP), and indeed, the success rates for system 3 are
lower than those for system 1. Figure 1 also shows that by
designing the feedback controller, we can recover some of
the lost RIP due to the structure in the system dynamics, and
improve the success rate (system 2). Fundamental limits of the
l1-optimization for both secure decoding and ideal coding are
also shown in Figure 1.

Figure 2 shows that as S increases, more measurements
(p) are needed to correctly recover the state of the system. In
practice, this can be done by fusing different types of measure-
ments and sensors together. For example, consider a simpliﬁed
UAV dynamics where x = (cid:2)px, py, pz, vx, vy, vz
and p(·)’s
and v(·)’s represent positions and velocities, respectively. The
observation equations of the IMU and GPS are as follows:

(cid:3)(cid:62)

CIM U = (cid:2)03×3

I(cid:3) , CGP S = (cid:2)I 03×3

(cid:3)

By combining measurements from both IMU and GPS,
we can increase the types of measurements (p), C =
(cid:2)CIM U ; CGP S

(cid:3) ∈ R6×n.

Finally, we want to point out that T = n = 8 in all
these simulations, which is much smaller than that dictated
by Theorem 1 (T = 35). Nevertheless, our decoder’s success
rates are quite high: in Figure 1, it achieves success rates of
more than 0.8 for system 2 for all attacks where the number of

Fig. 2. Success rate and mean error of l1 decoder on three different systems
(ideal coding matrix, designed state feedback and poorly designed system with
n = 8 and T = n) with different p = [8, 10, 12]. Black solid lines show
the fundamental limit for dynamical systems and black dashed lines show the
fundamental limit for the ideal coding matrix case. We see that as the number
of attacked nodes increases, the success rate decreases. Also, by designing
the state feedback gain properly, we improve success rate and decrease mean
error.

conditions x(0) were randomly generated from the standard
Gaussian distribution and the set of attacked nodes are chosen
at random and can change over time. Since we increase S in
steps of 1 as shown in Figure 1, we ﬁrst distribute q = (cid:98)S/T (cid:99)
attacks arbitrary for each time step t and randomly distribute
the remaining (S −q·T ) attacks amongst e(0), · · · , e(T −1). For
example, in Figure 1, for S = 20, we have at least 2 attacks
for each e(t) where t = {0, ..., 7} and distribute the remaining
4 attacks arbitrary.

Figures 1 and 2 show the performance of our proposed
decoder on three different systems: (1) an ideal random
coding matrix (i.e., with i.i.d. Gaussian entries), (2) a LTI

051015202530354000.20.40.60.811.2S: the number of total attacted nodes during Tsuccess raten=8,p=10, T=8 where [p/2−1]=4 and Trial=500  ceil(p/2−1)*Tfundamental limit CSideal(A,C)w/o design051015202530354000.050.10.150.20.250.30.350.40.450.5S: the number of total attacted nodes during Tmean errorn=8,p=10, T=8 where [p/2−1]=4 and Trial=500  ceil(p/2−1)*Tfundamental limit CSideal(A,C)w/o designS: the number of total attacked nodes during TS: the number of total attacked nodes during TS: the number of total attacted nodes during T05101520253035404550Success rate00.20.40.60.81n=8, T=8, p=[8,10,12] and Trial=500Ideal (p=10)Proposed (p=10)w/o design (p=10) (p=12) (p=12)(p=12) (p=8) (p=8) (p=8)qmax=4qmax=5qmax=3S: the number of total attacked nodes during T9

decoder occasionally fails to perfectly recover the states. The
green dashed line in Figure 3 depicts a possible result from
this decoder: the estimated state trajectory follows the true
trajectory most of the time with occasional errors.

Therefore,

to improve the performance, we propose to

combine our secure decoder with a KF as follows:

Algorithm 1 Combined secure estimator with KF

1: Initialize the KF
2: for each t do
3:
4:

if t ≥ T then

Estimate the attack signal at time t, ˆe(t), using

Illustrative comparison of three schemes: KF only (KF), secure
Fig. 3.
estimator only (SE), secure estimator with a KF (SE+KF). KF fails to estimate
the true state as attack signal is non-Gaussian. SE correctly estimates the
system state most of the time but has occasional large estimation errors.
SE+KF tracks the true state trajectory perfectly.

attacked nodes is below the maximum number of correctable
errors, in Figure 2, these success rates increase to above 0.9
when 12 measurements are available. These results suggest
that the sufﬁcient condition on T given in Theorem 1 is
conservative, and can be relaxed in practice.

C. Combination of Secure Estimation and Kalman Filter

Consider the state estimation problem for the following LTI

system under attack:

x(t+1) = Ax(t) + Bu(t) + w(t)
y(t) = Cx(t) + e(t) + v(t)

(14)

where x(t), y(t), u(t) and e(t) are as deﬁned in (5); w and v
are zero mean i.i.d. Gaussian process noise and measurement
noise, respectively.

We can model the attack signal as noise and use a KF
to estimate the states. More speciﬁcally, one would deﬁne a
new measurement noise vector ˜v(t) = e(t) + v(t), so that the
measurement equation becomes y(t) = Cx(t) + ˜v(t). A KF can
then estimate the states from the inputs u(t) and the corrupted
measurements y(t) [7]. However, KFs are derived using the
assumption that both process and measurement noises are
zero mean i.i.d. white Gaussian processes, but attack signals
are usually erratic and may be poorly modeled by Gaussian
processes [7]. For example, in GPS spooﬁng attacks, attack
signals are often structured to resemble normal GPS signals
or can be genuine GPS signals captured elsewhere. When the
system is subjected to attacks that are poorly modeled by
Gaussian processes, a KF is expected to fail to recover the
true states. Figure 3 gives an illustrative example where an
attack signal that increases linearly with time is injected into
the measurements of state xi. The red dashed line shows a
plausible estimated state trajectory from a KF.

On the other hand, our proposed secure decoder works for
arbitrary and unbounded attacks. Nevertheless, Figures 1 and
2 show that when the number of attacked nodes are close
to the theoretical maximum number of correctable errors, our

5:

6:
7:
8:

secure estimator

else

Set ˆe(t) = 0

end if
Form a new measurement equation: ˜y(t) = Cx(t) +
˜v(t), where ˜y(t) = y(t) − ˆe(t) and ˜v(t) = e(t) − ˆe(t) + v(t)

Apply standard KF using u and ˜y

9:
10: end for

The intuition is that the secure decoder acts as a pre-ﬁlter for
the KF, so that ˜v(t) is close to a zero mean i.i.d. Gaussian
process even when the true attack signal e(t) is not. More
speciﬁcally,
the secure decoder usually perfectly recovers
e(t), thus e(t) − ˆe(t) = 0 and ˜v(t) = v(t). What happens
when the secure decoder fails? Equation (6) shows that the
estimated state at time t, ˆx(t), does not directly depend on
the estimated state at another time point ˆx(τ ) (t (cid:54)= τ ). As
a result, when the secure decoder fails, its estimation error,
e(t) − ˆe(t), appears to be quite random. Putting these together:
˜v(t) = e(t) − ˆe(t) +v(t) is closer to a zero mean white Gaussian
process than the original attack signal e(t), and this improves
the KF’s performance.

Finally, the if statement in Algorithm 1 ensures that the
secure estimator always has access to T past measurements, as
required by Theorem 1. A more realistic example illustrating
these behaviors is shown in Figure 8.

V. NUMERICAL EXAMPLES

On February 15, 2015, the Federal Aviation Administration
proposed to allow routine use of certain small, non-recreational
UAVs in today’s aviation system [29]. Thus in the near future,
we may see thousands of UAVs such as Amazon Prime
Air [30] and Google Project Wing vehicles [31] sharing the
airspace simultaneously. To ensure safety of this immense
UAV trafﬁc, UAVs may periodically update their position
and velocity measurements wirelessly to a Remote Control
Center (RCC) for trafﬁc management (Channel 1 in Figure
4). At the same time, UAVs may broadcast this information to
other UAVs in its vicinity for collaborative collision avoidance
(Channel 2 in Figure 4). Finally, autonomous UAVs may use
GPS for their position measurements (Channel 3 in Figure 4).
All these communication channels are subject to cyber attacks.
If corrupted information are used in collision avoidance or
path planning algorithm, they can lead to possible collisions or
loss of UAVs, causing physical and ﬁnancial damage and even
injury to civilians. To help protect against these attacks and

TimeTrue state traj.KF onlySE onlySE + KFFig. 4. Different communication channels that are subject to adversarial
attacks.

consequences, participating entities such as the UAVs and the
RCC can use secure estimation to estimate a target UAV’s true
position and velocity before using any received information for
collision avoidance, for instance. In this section, we focus on
2 types of adversarial cyber attacks on UAVs and demonstrate
the effectiveness of our secure estimator through simulations.

A. UAV Model

We consider a quadrotor with the following dynamics:

x(t+1) = A0x(t) + Bu(t) + k + w(t)

y(t) = Cx(t) + e(t) + v(t)

(15)

where x = [px, vx, θx, ˙θx, py, vy, θy, ˙θy, pz, vz]T is the state
vector. px, py and pz represent the quadrotor’s position along
the x, y and z axis, respectively. vx, vy and vz represent its
velocities. θx and θy are the pitch and roll angles respec-
˙θx and ˙θy are their corresponding angular velocities.
tively,
u = [θr,x, θr,y, F ]T is the input vector: θr,i is the reference
pitch or roll angle, and F is the commanded thrust in the
vertical direction. y = [˜px, ˜py, ˜pz]T represents compromised
position measurements from the GPS under attack signal e. w
and v represent process and measurement noise respectively.
k is a constant vector which represents gravitational effects,
and can be dropped without loss of generality because we can
always subtract it out in u. Ai,j
refers to the ij-th entry of the
θ
subsystem matrix of the discretized rotational dynamics Aθ,

10

and Bi
θ refers to the i-th entry of the input-to-state map Bθ
for the discretized rotational dynamics. Ts is the discrete time
step, g is the gravitational acceleration, m is the mass of the
quadrotor and KT is a thrust coefﬁcient. Further details about
this model and its derivation can be found in [32]. Finally,
the matrix C depends on the particular measurements taken
in each example.

B. Decoder Design via Pole-Placement

Assume that the UAV uses the state feedback control law
u(t) = Gx(t), where G is the feedback matrix which can be
designed3. If the pair (A0, B) is controllable, then we can
choose G to place the closed loop poles anywhere in the
complex plane. We ﬁrst design a Linear Quadratic Regulator
(LQR) and evaluate its secure estimation performance by
checking whether the sufﬁcient condition for q-error correction
(i.e., |supp(Cvi)| > q for all i) holds. Figure 5 shows the
results for a matrix C ∈ R5×10 (i.e., 5 measurements) and
|supp(Cvi)| < p = 5 for i = 1, 2, 9 and
observe that
10. Furthermore, |supp(Cvi)| = 1 > 0 for i = 9 and 10,
therefore the resulting secure decoder can correct zero errors!
To improve the secure estimation performance, we perturb the
closed-loop poles slightly until |supp(Cvi)| = p for all i, as
shown in Figure 5. Therefore the resulting secure decoder can
achieve the maximum number of correctable errors within the
limits of p (i.e., the number of measurements). By keeping the
perturbations on the poles small, our ﬁnal controller achieves
both good control and estimation performances (see Figure 6).

C. UAV under Adversarial Attack

1) MITM Attack in Communication with a RCC or with
other UAVs:
In this section, we consider MITM attacks
targeted at Channels 1 and 2 in Figure 4, where a malicious
agent spoofs the information being sent and/or received over
these channels. The goal of the RCC or other UAVs is to
accurately estimate the true ﬂight path of a target UAV from
corrupted measurements. Note that the true path of the target
UAV is unaffected by the attack. Assume that the attacker
spoofs the position measurements in order to deceive the
receiver that the target UAV is deviating in the x-direction,
i.e., he/she injects a continuous and increasing signal in the
x-position measurement. To make the estimation task even
harder for the receiver, the attacker also injects a random
Gaussian noise to an additional measurement, and the choice
of this measurement can change at each time step.

In this example, we ﬁrst demonstrate the effectiveness of
our proposed decoder design via pole-placement method by
comparing the estimation performance of the decoder resulting
from (1) a LQR controller and (2) a controller designed using
pole-placement as described in the previous section. We then
implement the latter feedback controller, and compare the
performance of three different state estimation schemes: (1)
KF only (KF), (2) secure estimator only (SE), and (3) secure
estimator combined with KF (KF+SE).

|supp(Cvi)| for all eigenvectors vi of closed-loop matrix A for 2
Fig. 5.
feedback controllers: a LQR and a controller designed by pole-placement.
Black dashed line is at p = 5, i.e., the number of measurements.

3In the GPS spooﬁng example, direct uncorrupted state measurements are
not available. Therefore a KF is used to give estimated states which are then
used for state feedback control.

UAVRemote Control CenterSatelliteUAV321i12345678910| supp (C vi) |0123456pLQRPole-PlacementA0 =



1 Ts

1
0


0
0


0
0


0
0


0
0


0
0


0
0


0
0

0
0

g · T 2
s
2
gTs
A11
θ
A21
θ
0
0
0
0
0
0

0
0
A12
θ
A22
θ
0
0
0
0
0
0

0
0
0
0
0
0
0
0
1 Ts
1
0
0
0
0
0
0
0
0
0

0
0
0
0
g T 2
s
2
g · Ts
A11
θ
A21
θ
0
0

0
0
0
0
0
0
A12
θ
A22
θ
0
0




















0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1 Ts
1
0

, B =



















0
0
0
0
B1
0
θ
B2
0
θ
0
0
0
0
0 B1
θ
0 B2
θ
0
0
0
0

11

(16)



















0
0
0
0
0
0
0
0
kT ·T 2
s
2m
kT ·Ts
m

,

Throughout this example, y ∈ R5, measurements include
the x, y and z positions and 2 additional randomly selected
states. The left plots in Figure 6 show the true attack signal
on all 5 sensors (solid lines) and the estimated attack signals
(dashed lines) by the secure decoder if the feedback controller
is a LQ regulator (top) or one designed via pole-placement
(bottom). It is obvious that the latter estimates the attack signal
much more accurately. The right plots of this ﬁgure highlights
this observation by explicitly showing the estimation error of
the attack signal for each measurement.

The same information is shown in Figure 7, where each
row corresponds to one sensor, and the ﬁrst 3 rows are the
x, y and z position measurements, respectively. This ﬁgure
highlights three points: ﬁrst, the attacked sensors change with
time; second, the number of attacked sensors at each time t
is less or equal to 2; third, only position measurements are
corrupted.

Figure 8 shows the estimated ﬂight paths by all

three
methods. The true path of the UAV (solid blue line) starts
from the position marked by the blue triangle and ends at
the position marked by the blue square. KF fails to ﬁlter out
the attack signal in the x-position measurements as the attack
is highly non-Gaussian, and the estimated trajectory (dashed
red line) signiﬁcantly differs from the true one. On the other
hand, SE correctly estimates some portions of the trajectory
and the ﬁnal position of the vehicle, nevertheless it produces
spontaneous errors in the x direction. Finally the combined
method KF+SE perfectly recovers the true path of the target
UAV.

2) GPS Spooﬁng: In this section, we focus on adversarial
attacks in the GPS navigation system (Channel 3 in Figure 4).
Consider the scenario where a UAV uses a Linear Quadratic
Gaussian (LQG) controller to follow a desired path, x(t)
r ,
designed by LQ control. In other words, a KF takes com-
promised and noisy measurements y(t) and outputs a state
estimate ˆx(t), which is then used for state feedback control:
u(t) = G(ˆx(t) − x(t)
r ), where G is the feedback matrix. Note
that in the previous example (Section V-C1), the feedback
controller had access to uncorrupted state measurements x(t),
therefore the true path of the UAV is unaffected by attacks.
On the other hand, in this example, the UAV uses estimated
states ˆx(t) for feedback control and path following. Hence, if
measurements are corrupted and the state estimates are poor,
then the UAV may not be able to follow its desired path and
may deviate away from it. The goal is to correctly estimate the

Fig. 6. True attack signal, estimated attack signal and estimation error in
the attack signal of the estimator (SE) with 2 different feedback controllers:
LQR, controller designed via pole-placement (PP); with 5 measurements. In
the left plots, solid lines are true attack signals, dashed lines are estimated
signals. The right plots show the estimation error in the attack signal.

Fig. 7. Estimated attack signal, true attack signal and estimation error in
the attack signal of the estimator (SE) with 2 different feedback controllers:
LQR, controller designed via pole-placement (PP); with 5 measurements. Left
column shows estimated attack signals. Middle column shows true attack
signal. Right column shows estimation error. Each row corresponds to one
type of measurement. Red pixels indicate positive values, green pixels are
negative values and black indicates zero.

true states of the UAV and therefore, follow the desired path.
Assume an attacker spoofs the GPS position measurements in
order to deviate the UAV from its planned path. He/she injects
a sinusoidal signal to x-position measurement, as well as a
Gaussian noise to a randomly chosen position measurement
at each time step.

In this example, we explore the effect of the number of

0204060-40-200204060Attack Estimation (LQR)0204060-40-2002040Attack est. Error (LQR)Time0204060-40-200204060Attack Estimation (PP)Time0204060-40-2002040Attack est. Error (PP)Attack Est. (LQR)102030405012345True Attack (LQR)102030405012345Est. Error (LQR)102030405012345Attack Est. (PP)Time102030405012345True Attack (PP)Time102030405012345Est. Error (PP)Time10203040501234512

Fig. 8. Estimated UAV trajectory by three methods under MITM attack: KF
only (KF), secure estimator only (SE), secure estimator with KF (KF+SE).
Solid blue lines are the true UAV trajectories. They start from the blue triangle
and end at the blue square. Red dotted lines represent estimated trajectories
by each method, with 5 measurements.

sensor measurements on the secure estimation performance
of two schemes: (a) KF only, (b) KF+SE. We ﬁrst assume
that the UAV only uses GPS for navigation, i.e., 3 positional
measurements. Figure 9 shows that KF completely fails to
estimate the attack signal (KF, ny = 3, plots in Row 1),
consequently the actual UAV trajectory (red dashed line)
deviates signiﬁcantly from its desired path (solid blue line)
as shown in Figure 10, and deviations are largest along the
x- and z-axis (Figure 11). On the other hand, Figures 9 (KF
+ SE, ny = 3) shows that KF+SE’s estimated attack signals
are signiﬁcantly more accurate with only a small estimation
error in the x-position (plots in Row 2). Therefore the UAV
can follow its planned path much more closely (Figures 10
and 11). Recall from Proposition 4 that the maximum number
of correctable errors for a system with p measurements is
(cid:100)p/2 − 1(cid:101), which equals 1 in this case. There are at most
2 attacked nodes at any time t in this example, which exceeds
the above limit. This explains the estimation error in the x-
position. Despite this small estimation error, the combined
scheme KF+SE still outperforms the KF on its own.

We now show the effect of increasing the number of mea-
surements (ny, or equivalently p) through sensor fusion, on
the estimation performance and consequently, the UAV’s path
following performance. Autonomous UAVs often use IMUs in
addition to GPS for navigation, the former provides additional
measurements such as the UAV’s velocities, pitch and roll
angles. Figure 9 shows that increasing the number of measure-
ments has no affect on the KF’s estimation accuracy (compare
plots in Rows 1, 3 and 5). Even when 8 measurements are used
the UAV equipped with a KF still fails to follow the desired
path (Figures 10 and 11). On the other hand, increasing the
number of measurements improves the estimation performance
of the secure decoder SE and consequently the performance of
the combined scheme KF+SE (compare plots in Rows 2, 4 and
6 in Figure 9). Observe that for both 3 and 5 measurements,
the combined scheme KF+SE perfectly estimate the attack
signals and therefore, can completely subtract them out from
the corrupted measurements. As a result, the UAV can follow
its original planned path perfectly (KF + SE ny = 5, KF +
SE ny = 8 in Figures 10 and 11).

Fig. 9. Estimated attack signal, true attack signal and estimation error in
different cases: KF and KF+SE, each using 3, 5 and 8 different measurements.
Left column shows estimated attack signals. Middle column shows true attack
signal. Right column shows estimation error. Each row corresponds to one
sensor measurement and the ﬁrst three rows in each plot are the x, y and z
position measurements, respectively. Red pixels indicate positive values, green
pixels are negative values and black indicates zero.

Fig. 10. Desired and actual UAV trajectory in different cases: KF and KF+SE,
each using 3, 5 and 8 different measurements. Blue solid lines are the desired
trajectory. Red dash lines are the actual UAV trajectory under adversarial
attack.

VI. CONCLUSION

In this paper, we consider the problem of secure estima-
tion for CPS under adversarial attacks. Unlike [1] where
the attacked nodes are assumed to be ﬁxed, we allow the
set of attacked nodes to change over time, and propose a
computationally efﬁcient secure decoder for the latter scenario
that works for arbitrary and unbounded attacks. In addition,
we propose to combine the secure decoder with a KF for
improved practical performance. We demonstrate through nu-
merical examples, that our proposed secure estimator based KF
outperforms standard KF. Furthermore, we illustrate practical

1050KF (ny=5)-5-10010-10-510501050SE (ny=5)-5-100101050-5-10105KF + SE (ny=5)0-5-100101050-5-10xyzKF (ny=3)1020304050123True Attack (ny=3)1020304050123Est. Error (ny=3)1020304050123KF + SE (ny=3)1020304050123True Attack (ny=3)1020304050123Est. Error (ny=3)1020304050123KF  (ny=5)102030405024True Attack (ny=5)102030405024Est. Error (ny=5)102030405024KF + SE (ny=5)102030405024True Attack (ny=5)102030405024Est. Error (ny=5)102030405024KF  (ny=8)10203040502468True Attack (ny=8)10203040502468Est. Error (ny=8)10203040502468KF + SE (ny=8)10203040502468True Attack (ny=8)10203040502468Est. Error (ny=8)102030405024681050KF (ny=3)-5-100101050-5-10105KF + SE (ny=3)0-5-100101050-5-101050KF  (ny=5)-5-10010-10-51050105KF + SE (ny=5)0-5-100101050-5-101050KF  (ny=8)-5-100101050-5-10105KF + SE (ny=8)0-5-100101050-5-10xyz13

Before we present

is the i-th row of C, v (cid:44) (cid:2)v1

the proof, we deﬁne the following
(cid:3) ∈
notations: c(cid:62)
i
Rn×n, Λ (cid:44) diag{λ1, · · · , λn} ∈ Rn×n. For all z ∈ Rn,
z = v · α where α = (cid:2)α1, α2, · · · , αn
. In addition, with
these notations, Φz = (cid:2)Cvα; CvΛα; · · · ; CvΛT −1α(cid:3).

· · ·

vn

(cid:3)(cid:62)

v2

We will ﬁrst consider two simple cases where z is spanned
by two and three eigenvectors (m = 2 and m = 3) respec-
tively, and then generalize the results to 3 < m ≤ n. The
proofs use the following result.

Lemma 4. For m real numbers 0 < λ1 < λ2 < · · · < λm,
and m positive integers 0 < x1 < x2 < · · · < xm, the Gener-
alized Vandermonde matrix GV (λ1, · · · , λm; x1, · · · xm) de-
ﬁned as








λx1
1
λx2
1
...
λxm
1

λx1
2
λx2
2
...
λxm
2

· · ·
· · ·

· · ·

GV (λ1, · · · , λm; x1, · · · xm) =

is nonsingular.








,

λx1
m
λx2
m
...
λxm
m

(17)

Proof. GV (λ1, · · · , λm; x1, · · · xm) is a submatrix of a Van-
dermonde matrix V (λ1, · · · , λT −1) deﬁned as











1
λ1
λ2
1
...
λT −1
1

1
λ2
λ2
2
...
λT −1
2

· · ·
· · ·
· · ·

· · ·

1
λT −1
λ2

T −1

...
λT −1
T −1

.

(18)








V (λ1, · · · , λT −1) =

where T is a positive integer, 0 < λ1 < λ2 < · · · < λT −1,
{x1, x2, · · · , xm} ⊆ {0, 1, · · · , T − 1} and {λ1, · · · , λm} ⊆
{λ1, · · · , λT −1}.

V (λ1, · · · , λT −1) is a Totally Positive (TP) matrix [33], and
by deﬁnition of TP matrices, all minors of V (λ1, · · · , λT −1),
i.e., the determinant of all submatrices of V (λ1, · · · , λT −1),
are positive. Therefore GV (λ1, · · · , λm; x1, · · · xm) is nonsin-
gular.
Lemma 5. (m = 2) Consider z = (cid:80)2
α2 (cid:54)= 0, αj = 0, ∀j ≥ 3):

i=1 αivi (i.e., α1 (cid:54)= 0,

1) If there exists i ∈ {1, 2, · · · , p} such that c(cid:62)

i v1 (cid:54)= 0 and
c(cid:62)
i v2 (cid:54)= 0 but the i-th row of CvΛkα = 0, i.e., there is a
cancellation of the i-th row at time k, then the i-th row
of CvΛlα (cid:54)= 0 for all l ∈ {0, · · · , T − 1} where l (cid:54)= k.
In other words, there cannot be another cancellation of
the i-th row at any other time step, or equivalently, there
is a maximum of one cancellation of the i-th row over T
time steps.

2) If we choose T > min{s1,s2}

max{s1,s2}−2q , then |supp(Φz)| >

2q · T .

l

(cid:54)= k and l ∈

Proof. (1)
{0, · · · , T − 1} such that c(cid:62)

(Suppose not) There exist
i vΛlα = c(cid:62)
(cid:20)α1
0
(cid:20)α1
0

0 = c(cid:62)
i

= c(cid:62)
i

(cid:2)v1

(cid:2)v1

v2

v2

(cid:3)

(cid:3)

(cid:21)

i vΛkα = 0:
(cid:21) (cid:20)λl
1
λl
2
(cid:21) (cid:20)λk
1
λk
2

0
α2
0
α2

(cid:21)

Fig. 11. Desired and actual UAV trajectory in different cases: KF and KF+SE,
each using 3, 5 and 8 different measurements. Blue solid lines are the desired
x, y and z trajectories. Red dashed lines are the actual UAV trajectories under
adversarial attack.

applications of secure estimation in UAVs under adversarial
cyber attacks. This is important not only for today’s aviation
system but also UAV delivery systems in the near future.

(Proof of Theorem 1)

APPENDIX

In the following lemmas and proposition, we assume the

following:

1) A ∈ Rn×n has n distinct positive eigenvalues such that

0 < λ1 < λ2 < · · · < λn.

2) C ∈ Rp×n is full rank.
3) The pair (A, C) is observable.
4) ∀vi ∈ Rn where Avi = λivi (i.e., vi is an eigenvector of

A), |supp(Cvi)| > 2q.

Recall that we want to show that given |supp(Φvi)| > 2q·T
for all eigenvectors vi of A, then |supp(Φz)| > 2q · T for all
z ∈ Rn\{0}. Now, A has n distinct eigenvalues, hence the
eigenvectors of A form a basis for Rn, and any z ∈ Rn can
be expressed in the eigenbasis of A, i.e., z = (cid:80)n
i=1 αivi.
Therefore, Φz = (cid:80)n
i=1 αiΦvi, and thus, the only way that
the number of nonzero terms in Φz may be less than 2q · T
is if too many nonzero terms in Φvi are cancelled during
this summation. In other words,
there are rows that are
nonzero in the vectors Φvi, however after the scaling by αi’s
and summation, these rows become zero in Φz. Therefore
our goal is to prove upper bounds on the number of such
cancellations, and use these upper bounds to derive a value of
T such that even in the worst case (i.e., with most number of
cancellations), the number of nonzero terms in Φz is greater
than 2q · T for all z ∈ Rn\{0}.

0204060x-10010200204060y-20020KF (ny=3)0204060z-200200204060x-100100204060y-20020KF + SE (ny=3)0204060z-200200204060x-10010200204060y-20020KF  (ny=5)0204060z-200200204060x-100100204060y-20020KF + SE (ny=5)0204060z-200200204060x-10010200204060y-20020KF  (ny=8)0204060z-200200204060x-100100204060y-20020KF + SE (ny=8)0204060z-20020Without loss of generality, assume l < k. We can reformulate
above equation as follows:
(cid:20)λl
(cid:21) (cid:20)α1
1 λl
2
λk
1 λk
0
2

(cid:21) (cid:20)v(cid:62)
1
v(cid:62)
2

(cid:20)0
(cid:21)
0

0
α2

ci =

(cid:21)

.

Now, the ﬁrst matrix on the left hand side (LHS) is a General-
ized Vandermonde matrix GV (λ1, λ2; l, k) with 0 < λ1 < λ2
and 0 < l < k, thus by Lemma 4 it is nonsingular. The second
matrix on the LHS is also nonsingular as α1 (cid:54)= 0 and α2 (cid:54)= 0.
Therefore we must have v(cid:62)
2 ci = 0 (contradiction,
i v1 (cid:54)= 0 and c(cid:62)
since c(cid:62)

1 ci = v(cid:62)
i v2 (cid:54)= 0 by assumption).

(2) Let L1, L2, L12 be three disjoint subsets of {1, · · · , p}
such that L1 = supp(Cv1)∩supp(Cv2)c, L2 = supp(Cv2)∩
supp(Cv1)c, and L12 = supp(Cv1) ∩ supp(Cv2) where
represents the set complement. Then,
the superscript
supp(Cv1) = L1 ⊕ L12, supp(Cv2) = L2 ⊕ L12, s1 (cid:44)
|supp(Cv1)| = |L1 ⊕ L12| > 2q, s2 (cid:44) |supp(Cv2)| = |L2 ⊕
L12| > 2q and s12 (cid:44) |L12| ≤ min{s1, s2}. Also, possible
cancellations only occur in the subset L12 by deﬁnition.

c

|supp(Φz)| = |supp(α1Φv1 + α2Φv2)|

= T · (s1 − s12) + T · (s2 − s12)

T −1
(cid:88)

(s12 − sk

r,12)

+

k=0

= T · (s1 + s2 − s12) −

T −1
(cid:88)

k=0

sk
r,12

≥ T · (s1 + s2 − min{s1, s2}) −

T −1
(cid:88)

k=0

sk
r,12

where sk
step k. More speciﬁcally, i ∈ sk
but c(cid:62)

r,12 is the number of cancelled support in L12 at time
r,12 if c(cid:62)
i v2 (cid:54)= 0,

i v1 (cid:54)= 0 and c(cid:62)
i vΛkα = 0. From (1), we have the followings:

s0
r,12 ≤ |L12|
s1
r,12 ≤ |L12| − s0
r,12 ≤ |L12| − s0
s2

r,12
r,12 − s1

r,12

...

sT −1
r,12 ≤ |L12| −

T −2
(cid:88)

k=0

sk
r,12

Thus, (cid:80)T −1

k=0 sk

r,12 ≤ |L12| ≤ min{s1, s2}, and

|supp(Φz)| ≥ T · max{s1, s2} − min{s1, s2} > 2q · T.

Lemma 6. (m = 3) Consider z = (cid:80)3
α2 (cid:54)= 0, α3 (cid:54)= 0 and αi = 0 for i = {4, 5, · · · , n}.
1) (cid:80)T −1

r,123 ≤ 2 · s123 where s123 = |L123| =

i=1 αivi where α1 (cid:54)= 0,

k=0 sk

|supp(Cv1) ∩ supp(Cv2) ∩ supp(Cv3)|.

2) If we choose T > p+min{s1,s2,s3}

max{s1,s2,s3}−2q , then |supp(Φz)| >

2q · T .

Proof. (1) Claim: the i-th row of CvΛkα is cancelled at most
2 times over T time steps, i.e. for at most 2 distinct values of
k ∈ {0, 1, · · · , T − 1}.

14

(Suppose not) There exist 3 distinct time steps d, e, f ∈
i vΛf α =

{0, 1, · · · , T −1} such that c(cid:62)
0. Without loss of generality, assume d < e < f :



i vΛdα = c(cid:62)

i vΛeα = c(cid:62)



λd
1 λd
λe
1 λe
1 λf
λf

2 λd
3
2 λe
3
2 λf
3







α1
0
0

0
α2
0

0
0
α3


 v(cid:62)ci =



0
0


0

Again, the ﬁrst matrix on the LHS is a Generalized Vander-
monde matrix satisfying the conditions of Lemma 4, hence it is
nonsingular. The second matrix on the LHS is also nonsingular
as α1 (cid:54)= 0, α2 (cid:54)= 0 and α3 (cid:54)= 0. Therefore we must have
v(cid:62)ci = 0 (contradiction). A similar derivation as in Lemma
5 then shows (cid:80)T −1
r,123 ≤ 2 · s123.

k=0 sk
(2) Consider Cv1, Cv2, Cv3 and Φz:

supp(Cv1)
L1
0
0
L12
0
L13
L123

supp(Cv2)
0
L2
0
L12
L23
0
L123

supp(Cv3)
0
0
L3
0
L23
L13
L123

Without loss of generality, assume s3 ≥ s2 ≥ s1 (recall s1 =
|L1 ⊕ L12 ⊕ L13 ⊕ L123| = |L1| + s12 + s13 + s123):

|supp(Φz)| = T · (s1 − s12 − s13 − s123)
+ T · (s2 − s12 − s23 − s123)
+ T · (s3 − s23 − s13 − s123)

T −1
(cid:88)

(cid:18)

+

k=0

(s12 − sk

r,12) + (s23 − sk

r,23)

+ (s13 − sk

r,13) + (s123 − sk

r,123)

(cid:19)

= T · (s3 + s1 + s2 − s12 − s13 − s23 − 2 · s123)

T −1
(cid:88)

(sk

r,12 + sk

r,23 + sk

r,13 + sk

r,123)

−

k=0

≥ T · s3 − p − s123 ≥ T · s3 − p − min{s1, s2, s3}
> 2q · T

k=0 (sk
r,13) ≤ s12 +s23 +s13≤ p−s123,
r,123 ≤ 2 · s123 and s123 ≤ min{s1, s2, s3} and note

r,23 +sk

r,12 +sk

where (cid:80)T −1
(cid:80)T −1
k=0 sk
that T > p+min{s1,s2,s3}
max{s1,s2,s3}−2q .

Proposition 5. Consider m eigenvector combinations (n ≥
m ≥ 2). Then, the total number of cancellations over T
time steps satisﬁes (cid:80)T −1
r,12···m ≤ (m − 1) · s12···m where
s12···m = |supp(Cv1) ∩ · · · ∩ supp(Cvm)|.

k=0 sk

Proof. Claim: the i-th row of CvΛkα is cancelled at most
(m − 1) times over T time steps, i.e. for at most (m − 1)
distinct values of k ∈ {0, 1, · · · , T − 1} (Suppose not)








λd
1 λd
2
λe
1 λe
2
...
...
1 λr
λr
2

· · ·
· · ·
. . .
· · ·








λd
m
λe
m
...
λr
m








α1
0
...
0

0
α2
...
0








· · ·
0
· · ·
0
...
. . .
· · · αm

v(cid:62)ci =



0
0




...




0

15

[20] C. Kwon and I. Hwang, “Hybrid robust controller design: Cyber attack
attenuation for cyber-physical systems,” 52nd IEEE Conference on
Decision and Control, 2013.

[21] M. Pajic, J. Weimer, N. Bezzo, P. Tabuada, O. Sokolsky, I. Lee, and
G. Pappas, “Robustness of attack-resilient state estimators,” in Cyber-
Physical Systems (ICCPS), 2014 ACM/IEEE International Conference
on, 2014, pp. 163–174.

[22] Y. Shoukry, M. Chong, M. Wakaiki, P. Nuzzo, A. L. Sangiovanni-
Vincentelli, S. A. Seshia, J. P. Hespanha, and P. Tabuada, “SMT-
based observer design for cyber-physical systems under sensor attacks,”
International Conference on Cyber-Physical Systems, 2016.

[23] B. Ghena, W. Beyer, A. Hillaker, J. Pevarnek, and A. J. Halderman,
“Green lights forever: analyzing the security of trafﬁc infrastructure,”
Proceedings of the 8th USENIX workshop on offensive technologies,
August 2014.

[24] D. Hayden, Y. H. Chang, J. Goncalves, and C. Tomlin, “Sparse network
identiﬁability via compressed sensing,” Automatica, vol. 52, 2016.
[25] D. L. Donoho and M. Elad, “Optimally sparse representation in general
(nonorthogonal) dictionaries via l1 minimization,” Proc. Natl. Acad. Sci.,
pp. 2197–2202, 2003.

[26] M. Elad and A. M. Bruckstein, “A generalized uncertainty principle and
sparse representation in pairs of rn bases,” Information Theory, IEEE
Transactions on, vol. 48, no. 9, pp. 2558–2567, 2002.

[27] R. Gribonval and M. Nielsen, “Sparse representations in unions of
bases,” Information Theory, IEEE Transactions on, vol. 49, no. 12, pp.
3320–3325, 2003.

[28] J. Tropp, “Greed is good: algorithmic results for sparse approximation,”
Information Theory, IEEE Transactions on, vol. 50, no. 10, pp. 2231–
2242, 2004.

[29] “Press release – DOT and FAA propose new rules for small unmanned
aircraft systems,” http://www.faa.gov/news/press releases/news story.
cfm/?newsId=18295, accessed: 2015-02-15.

[30] “Amazon Prime Air,” http://www.amazon.com/b?node=8037720011.
[31] “Google project wing,” http://www.theatlantic.com/technology/archive/

2014/08/inside-googles-secret-drone-delivery-program/379306/?single
page=true, accessed: 2014-08-28.

[32] P. Bouffard, “On-board model predictive control of a quadrotor heli-
copter: Design, implementation, and experiments,” University of Califor-
nia Berkeley, http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-
2012-241.html, Technical Report UCB/EECS-2012-241, December
2012.

[33] S. M. Fallat and C. R. Johnson, Totally nonnegative matrices. Princeton

University Press, 2011.

Again, the ﬁrst matrix on the LHS is a Generalized Vander-
monde matrix satisfying the conditions of Lemma 4, hence it is
nonsingular. The second matrix on the LHS is also nonsingular
as αi (cid:54)= 0 for all i ∈ {1, 2, · · · , m}. Therefore we must have
v(cid:62)ci = 0 (contradiction). A similar derivation as in Lemma
5 then shows (cid:80)T −1

r,12···m ≤ (m − 1) · s12···m.

k=0 sk

ACKNOWLEDGMENT

This work was supported by the NSF CPS project Ac-
tionWebs under grant number 0931843, NSF CPS project
FORCES under grant number 1239166.

REFERENCES

[1] H. Fawzi, P. Tabuada, and S. Diggavi, “Secure estimation and control for
cyber-physical systems under adversarial attacks,” Automatic Control,
IEEE Transactions on, vol. 59, no. 6, pp. 1454–1467, June 2014.
[2] E. Candes and T. Tao, “Decoding by linear programming,” Information
Theory, IEEE Transactions on, vol. 51, no. 12, pp. 4203–4215, Dec
2005.

[3] V. D. Gligor, “A note on denial-of-service in operating systems,” IEEE
Transactions on Software Engineering, vol. 10, no. 3, pp. 320 – 324,
May 1984.

[4] Y. Mo and B. Sinopoli, “False data injection attacks in control systems,”
Preprints of the 1st Workshop on Secure Control Systems, 2010.

[5] A. A. Cardenas, S. Amin, and S. Sastry, “Secure control:

towards
survivable cyber-physical systems,” 28th international conference on
distributed computing systems workshop, pp. 495–500, June 2008.
[6] O. Kosut, J. Liyan, R. J. Thomas, and L. Tong, “Malicious data attacks
on the smart grid,” IEEE Trans. Smart Grid Special Issue on Cyber,
Physical, and System Security for Smart Grid, vol. 2, no. 4, pp. pp.
645–658, 2012.

[7] C. Kwon, W. Liu, and I. Hwang, “Security analysis for cyber-physical
systems against stealthy deception attacks,” American Control Confer-
ence, 2013.

[8] Y. Liu, P. Ning, and M. K. Reiter, “False data injection attacks against
state estimation in electric power grids,” ACM Transactions on Informa-
tion and System Security, vol. 14, no. 13, May 2011.

[9] A. Teixeira, S. Amin, H. Sandberg, K. H. Johansson, and S. Sastry,
“Cyber security analysis of state estimators in electric power systems,”
49th IEEE Conference on Decision and Control, pp. 5991 – 5998,
December 2010.

[10] M. Blanke, M. Kinnaert, J. Lunze, and M. Staroswiecki, Diagnosis and
fault-tolerant control, 2nd ed. Berlin, Germany: Springer, 2006.
[11] M.-A. Massoumnia, G. C. Verghese, and A. S. Willsky, “Failure de-
tection and identiﬁcation,” IEEE Transactions on Automatic Control,
vol. 34, no. 3, pp. 316–321, March 1989.

[12] K. Zhou and J. C. Doyle, Essentials of Robust Control. Englewood,

Cliffs, NJ, USA: Prentice-Hall, 1998.

[13] F. Pasqualetti, F. Dorﬂer, and F. Bullo, “Cyber-physical attacks in
power networks: models, fundamental limitations and monitor design,”
50th IEEE conference on decision and control and european control
conference, pp. 2195 – 2201, December 2011.

[14] K. Manandhar, X. Cao, F. Hu, and Y. Liu, “Combating false data injec-
tion attacks in smart grid using kalman ﬁlter,” International Conference
on Computing, Networking and Communications, pp. 16–20, February
2014.

[15] S. Roy, C. Ellis, S. Shiva, D. Dasgupta, V. Shandilya, and Q. Wu, “A
survey of game theory as applied to network security,” 43rd Hawaii
International Conference on System Sciences, 2010.

[16] A. Gupta, C. Langbort, and T. Basar, “Optimal control in the presence
of an intelligent jammer with limited actions,” 49th IEEE Conference
on Decision and Control, pp. 1096 – 1101, December 2010.

[17] M. H. Manshaei, Q. Zhu, T. Alpcan, T. Basar, and J.-P. Hubaux, “Game
theory meets network security and privacy,” ACM Computing Surveys,
vol. 45, no. 3, June 2013.

[18] A. Gueye, V. Marbukh, and J. C. Walrand, “Towards a metric for
communication network vulnerability to attacks: A game theoretic
approach,” 3rd International ICST Conference on Game Theory for
Networks, May 2012.

[19] M. Fei, M. Pajic, and G. J. Pappas, “Stochastic game approach for replay
attack detection,” 52nd IEEE Conference on Decision and Control, pp.
1854 – 1859, December 2013.

