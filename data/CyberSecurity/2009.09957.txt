1
2
0
2

r
p
A
9
1

]

R
C
.
s
c
[

2
v
7
5
9
9
0
.
9
0
0
2
:
v
i
X
r
a

SPChain: Blockchain-based Medical Data Sharing and
Privacy-preserving eHealth System

Renpeng Zoua,1, Xixiang Lva,1,∗, Jingsong Zhaoa,1

aSchool of Cyber Engineering, Xidian University,Xian 710071, China

Abstract

The sharing of electronic medical records (EMRs) has great positive signiﬁcance

for research on disease and epidemic prevention. Recently, blockchain-based

eHealth systems have achieved great success in terms of EMRs sharing and

management, but there still remain some challenges. Permissioned blockchain-

based solutions provide high throughput and scalability, but may suﬀer from

rollback attacks and lead to privacy leakage. Designs based on the public

blockchain, on the other hand, are more open and secure, but sacriﬁce scal-

ability and have no incentives for medical institutions to join into the systems.

Moreover, data retrieval in blockchain-based eHealth systems is ineﬃcient be-

cause of the basic blockchain structure. To solve the above problems, we propose

a blockchain-based medical data sharing and privacy-preserving eHealth system

named SPChain. To achieve quick retrieval, we devise special keyblocks and

microblocks for patients to store their EMRs. A reputation system is also con-

structed to motivate medical institutions to participate in SPChain. By using

proxy re-encryption schemes, SPChain achieves medical data sharing for pa-

tients in a privacy-preserving manner. To evaluate SPChain, we leverage the

distribution of miners in the real world to test the system’s performance and

ability to resist mentioned attacks. The results show that SPChain can achieve

high throughput (220 TPS) with low storage overhead. Compared with the

∗Corresponding author
Email address: xxlv@mail.xidian.edu.cn (Xixiang Lv)
1The work of Xixiang Lv, Renpeng Zou and Jingsong Zhao is supported by the National

Natural Science Foundation of China (Grant No. 62072356).

Preprint submitted to Journal of Information processing & management

April 20, 2021

 
 
 
 
 
 
existing schemes, SPChain achieves lower time complexity in terms of data re-

trieving, and can resist proposed blockchain attacks as well as SPChain attacks.

Keywords: Blockchain; Electronic Medical Record; Privacy; Data Sharing;

Reputation system;

1. Introduction

The era of big data brings new opportunities and challenges to the medi-

cal ﬁeld. Recently, more and more infectious diseases, such as COVID-19 [1],

have drawn our attentions due to their strong infection and destructive ability.

Researchers have found that the sharing of medical data can prevent the large-

scale spread of diseases to some extent [2]. Through the analysis and sharing

of medical data, we can detect the symptoms of disease transmission in ad-

vance and control the large scale spread of diseases in time. On the other hand,

some research institutions need large numbers of reliable samples to study the

incidence rate of disease.

i.e. artiﬁcial intelligence techniques are utilized on

diagnostics in some intractable diseases such as glaucoma, hyperactivity, and

Parkinson’s disease [3]. Therefore, medical data sharing is of great signiﬁcance

to the development of human health.

As an indispensable tool for medical services [4], electronic medical records

(EMRs) not only provide medical data for diagnosis and scientiﬁc research but

also give one kind of judgment basis for handling medical disputes. EMRs have

become the most original record of patients in the whole process of medical

treatment, but the current EMR data management systems are not perfect

[5]. EMRs are usually stored in a private database, which brings a problem

that patients leave data scattered across various medical institutions because

life events take the patients away from one medical institution into another.

What’s worse, since medical data is recorded into EMRs in hospitals or medical

institutions after diagnosis, patients lose easy access to these data even if it

belongs to them [6].

To address these problems, researchers leverage cloud platform to manage

2

EMRs [7]. To a certain extent, the application of cloud technology has promoted

the sharing of EMRs, but there still remain some problems. Considering the

fact that users and cloud providers usually belong to diﬀerent administrative

domains, the diﬃculty of cloud-based data sharing lies in how much trust users

can place on cloud service providers. Such a lack of trust stems from the lack

of transparency and the loss of data control [8] by users in cloud environments.

e.g. in recent years, many accidents about medical-record leakages [9], [10], [11]

have occurred frequently. Besides, the multi-tenancy characteristic of public

cloud services decides that virtual machines (VMs) are shared among various

applications, which may expose the data to diﬀerent types of attacks. Worse

still, it is diﬃcult to detect or monitor such attacks in a shared VM environment.

Therefore, eHealth systems crave innovations to assure the security and privacy

of medical records.

Blockchain, which is widely leveraged in cyptocurrency systems [12], [13], is

a promising technology that can be used to maintain a transparent ledger and

share data among participants. With the tamper-resistant and distributed na-

ture, the blockchain technology can provide integrity and restoration guarantees

for medical records. Many countries have combined the blockchain technology

with eHealth systems and achieved great success. For instance, Estonia [14]

makes use of the blockchain technology to provide patients with safer and more

convenient medical services. An ample amount of solutions, i.e. [15], [16], [17],

[18], [19] strive to leverage the latest technologies, such as smart contracts and

privacy protection modules, to enhance the operability and conﬁdentiality of

eHealth systems. Through the literature review, it would be an eﬀective way

to use blockchain to serve as a decentralized storage platform and replace the

central servers, but there still remain some drawbacks.

Currently, blockchain-based eHealth systems can be divided into two cate-

gories, permissioned blockchain-based eHealth systems and public blockchain-

based eHealth systems [2], [20]. Permissioned blockchain-based eHealth systems

(e.g.

[21], [22] and [23]) rely on some super nodes to manage the storage and

sharing of EMRs. In spite of the high throughput, the permissioned blockchain

3

is far from a perfect solution for secure medical data sharing because it adopts

central authorities which are comprised of a group of companies with a shared

interest that will oversee the whole system. Therefore, the immutability of data

in permissioned blockchain is discounted, which increases the possibility of a

central authority rolling back the blockchain records.

Designs based on public blockchain, on the other hand, provide stronger

security and openness, but sacriﬁce scalability. The public blockchain is cryp-

tocurrency driven, which means a certain amount of cryptocurrencies have to be

paid for transaction inclusion and block mining. Such systems are suitable for

cleaning institutions such as banks, but have no incentive for medical institu-

tions. Another obstacle to the development of public blockchain-based eHealth

systems is the low eﬃciency of data retrieval. For the data stored in the gen-

eral database, we can search directly. But in the blockchain, we need to search

the block ﬁrst, and then search the needed transactions contained in the block.

These systems utilize smart contracts and the scripting language to exchange

medical data between medical institutions with blockchain systems. Due to the

data storage and exchange model, the medical data is scattered in blockchain

systems. In this case, consulting the medical records of patients in a mass of

block data is ineﬃcient. And obtaining a patient’s whole medical records in such

systems consumes a lot of time. Worse still, public blockchain-based eHealth

systems are ineﬃcient in processing transactions. Taking Bitcoin and Ethereum

as examples, the throughput of Bitcoin is 7 TPS (transactions per second) and

that of Ethereum is 15 TPS [24], [25], which is far from enough to meet the

urgent needs of patients.

In terms of the above problems, we propose a public blockchain-based eHealth

system with high throughput to achieve medical data sharing in a privacy-

preserving manner. In order to provide eﬃcient retrieval for patients, we design

new block and chain structures with chameleon hash functions. We also de-

vise new incentive mechanism for medical institutions to join into SPChain.

Speciﬁcally, the contributions of this paper are as follows.

4

• We propose a data sharing and privacy-preserving public blockchain sys-

tem named SPChain. We use chameleon hash functions to design new

block structures which provide whole medical history for each patient. We

also devise new chain structure to mitigate forking problem. To motivate

medical institutions to participate in SPChain, we construct a reputation

system with which the reputable medical institutions can acquire EMRs

for medical research.

• We use SPChain to construct a concrete eHealth system which can achieve

secure data sharing and retrieval in a privacy-preserving manner. We use

the proxy re-encryption schemes to protect the EMRs stored in medical

institutions’ local databases. Only authorized medical institutions can

access patients’ EMRs. Besides, the system provides special transactions

for patients to register in SPChain and label wrong medical records.

• We discuss how the proposal can satisfy the security requirements and

demonstrate the feasibility and eﬀectiveness of SPChain by developing the

system in an analog network with the miner distribution in the real world.

Compared with existing systems, SPChain achieves high throughput with

minimal storage overhead, and provides signiﬁcant resilience to Blockchain

attacks as well as SPChain attacks.

The remaining part of the paper is organized as follows. We begin by in-

troducing some related works in Section 2. Section 3 is concerned with some

preliminaries used in this paper. In Section 4, we describe the system model and

design goals. The detailed blockchain-based medical data sharing and privacy-

preserving eHealth system is given in Section 5. Section 6 illustrates the per-

formance evaluation and security analysis of SPChain. Finally, this paper is

concluded in Section 7.

5

2. Related Work

In this section, we review some research trends about medical data sharing

via cloud service and blockchain technology.

In order to solve the problem of low eﬃciency and poor scalability of tradi-

tional eHealth systems, some solutions (e.g. [26], [27], [28] and [7]) are dedicated

to use access control technologies to manage the EMRs outsourced to clouds.

Such mechanisms are designed to protect the security of remotely stored data

in cloud computing, which demonstrates that providing owners with data ac-

cess control is more important than letting the cloud take the full control over

their data. However, patients still lose control of their data. Moreover, the

distrust of the cloud and the compatibility of various cloud devices still restrict

the development of cloud-based eHealth systems.

Recently, with the adoption of blockchain technology becoming a widespread

trend in distributed computing, many researchers consider using blockchain

to provide secure medical data sharing and management. Blockchain-based

eHealth systems can be divided into two types [2]: permissioned blockchain-

based approaches and public blockchain-based approaches.

Permissioned blockchain-based eHealth systems ([22], [21], [29],

[30] and [31]). To preserve patients’ privacy in the process of disseminating

EMRs, Xia et la. [22] designed a system that addresses the issue of medical data

sharing among medical big data custodians in a trust-less environment. The

system employed smart contracts and an access control mechanism to eﬀectively

trace behaviors on the data, and revoked access to violated rules and permissions

on data. With a data custodian system, the system can monitor entities that

access data for malicious behaviors. The author also proposed BBDS [21], a

similar blockchain-based framework that provides data provenance, auditing,

and control in cloud repositories among healthcare providers. However, their

secure sharing of sensitive medical information is limited to invited and veriﬁed

users.

Fan et al. proposed MedBlock [29], a hybrid blockchain-based architecture

6

to secure EMRs. In MedBlock nodes are divided into endorsers, orderers and

committers.

Its consensus protocol is a variant of the PBFT [32] consensus

protocol. However, the authors did not explicitly explain the access control

policies to allow third-party researchers to access medical data.

Zhang and Lin [30] designed a hybrid blockchain-based secure and privacy-

preserving (BSPP) EMRs sharing scheme, where a private blockchain is used to

store EMRs for each hospital and a consortium blockchain is used to keep secure

indices of the EMRs. In their design, a public encryption-based keyword search

scheme [33] is adopted to secure the search of EMRs and to ensure identity

privacy.

Public blockchain-based eHealth systems ([34], [35], [36], [37] and

[38]). In order to prompt patients to engage in the details of their healthcare

and restore agency over their medical data, Azaria et al. [34] proposed a decen-

tralized record management system to handle EMRs. The system utilized smart

contracts to manage medical records of patients. With modular design, patients

can make access control rules and share their EMRs with diﬀerent institutions.

The authors also designed reward system to motivate researchers and public

health authorities to participate in the network as blockchain miners.

Based on MedRec, Yang and Yang [35] used signcryption and attribute-

based authentication to enable the secure sharing of healthcare data. EMRs

are encrypted with a symmetric key, which further encrypted with an attribute

key set. The concatenation of both ciphertexts (encrypted EMRs and encrypted

key) is signed with a private key. For data accessing, a user veriﬁes the signature

and performs EMRs decryption to get the plaintext EMRs.

Cao et al.

[37] proposed a secure cloud-assisted eHealth system to protect

outsourced EMRs from illegal modiﬁcations. The key idea of the system is

that the EMRs can only be outsourced by authenticated participants and each

operation on outsourced EMRs is integrated into the public blockchain as a

transaction. The system took into account the situations of a single doctor and

multiple doctors and utilized key exchange protocol to protect the privacy of

EMRs. The tamper-prooﬁng property of blockchain guaranteed the correctness

7

and integrity of EMRs.

3. Preliminaries

In this section, we review some basic preliminaries used in this paper, includ-

ing cryptographic hash functions, chameleon hash functions, proxy re-encryption

schemes and the Proof-of-Reputation blockchain system.

3.1. Hash function and chameleon hash function

Cryptographic Hash Function. A cryptographic hash function H(·) is a

deterministic mathematical algorithm that maps an arbitrary-length string to

a ﬁxed-length bit string, i.e. H(m) = h, where m is the message and h is the

hash value. In theoretical cryptography, the security of a cryptographic hash

function has been deﬁned using the following properties [39]:

• Pre-image resistance. Given a hash value h it should be diﬃcult to

ﬁnd any message m such that h = H(m).

• Second pre-image resistance. Given an input m1, it should be diﬃcult

to ﬁnd a diﬀerent input m2 such that H(m1) = H(m2).

• Collision resistance. It should be diﬃcult to ﬁnd two diﬀerent messages

m1 and m2 such that H(m1) = H(m2).

In some scenarios [40], the authorized entities should be allowed to easily

ﬁnd hash collisions to replace the wrong or harmful messages. To achieve this

function Krawczyk and Rabin put forward the concept of chameleon hashing

[41] on the notion of chameleon commitments.

Chameleon hash function. Informally, a chameleon hash [42] is a cryp-

tographic hash function that contains a trapdoor: Without the trapdoor, it

should be hard to ﬁnd collisions, but knowledge of the trapdoor information al-

lows collisions to be generated eﬃciently. A chameleon hash function is a tuple

of eﬃcient algorithms CH = (HGen, Hash, HVer, HCol) speciﬁed as follows.

8

• (hk, tk) ← HGen(1K). The key generation algorithm HGen takes as input
the security parameter λ ∈ N, and outputs a public hash key hk and a

secret trapdoor key tk.

• (h, R) ← Hash(m, hk). The hashing algorithm Hash takes as input the

hash key hk, a message m ∈ M, and returns a pair (h, R), where r ∈ Rhash

denotes the implicit random coin used to generate the hash value.

• d = HVer(hk, m, (h, R)). The veriﬁcation algorithm HVer takes as input a

message m ∈ M and a pair (h, R), and returns a bit d that equals “1” if

HVer(hk, m, (h, R)) = h (otherwise d equals “0”).

• R(cid:48) ← HCol(tk, (h, m, R), m(cid:48)). The collision ﬁnding algorithm HCol takes

as input the trapdoor key tk, a valid tuple (h, m, R), and a new message

m(cid:48) ∈ M, and returns a new random coin R(cid:48) such that HVer(hk, m, (h, R)) =

HVer(hk, m(cid:48), (h, R(cid:48))) = 1. If (h, R) is not a valid hash for message m, then

the algorithm returns ⊥.

3.2. Proxy re-encryption

In order to achieve privacy-preserving data sharing, we introduce the proxy

re-encryption scheme. In a proxy re-encryption (PRE) scheme, the proxy con-

verts the ciphertext encrypted with the delegator’s public key into a ciphertext

that can be decrypted with the delegatee’s secret key through a re-encryption

key from the delegator. A PRE scheme is illustrated as follows.

• (par) ← Setup(1K). Accepting an input security parameter K, public

parameters par is produced by this algorithm.

• (Rpki, Rski) ← KeyGen(par). This algorithm accepts the public parame-

ter par as input, and produces a pair of public key/private key (Rpki, Rski).

• rk ← ReKeyGen(par, Rpkj, Rski). In this algorithm, user i takes a private

key Rski, the public parameter par and the user j’s public key Rpkj as

input, and produces rk.

9

• Ci ← Enc(par, Rpki, m). On input a user’s Rpki, a message m and public

parameter par, this algorithm returns the original ciphertextCi.

• Ci→j ← ReEnc(rk). This algorithm is operated by a semi-honest proxy.

On input the original ciphertext Ci and a re-encryption key rk, this algo-

rithm outputs the ciphertext Ci←j which can be decrypted by user j.

• m ← Dec1(Ci, Rski). This algorithm takes as input the ciphertext Ci and

the private key Rski of user i, and outputs the plaintext m.

• m ← Dec2(Ci→j, Rskj). This algorithm inputs the ciphertext Ci→j and

user j’s private key Rskj, and outputs the plaintext m.

3.3. Blockchain and Proof-of-Reputation blockchain system

The blockchain technology is a data structure and serves as a distributed

ledger in which multiple transactions are maintained by trustless nodes in a

P2P network. Information may include data records of diﬀerent types, such as

cryptocurrency transactions, smart contracts and account balances. The most

successful blockchain system is the Proof-of-Work (PoW) blockchain underlying

Bitcoin, where miners solve crypto-puzzles via hash computation. However, the

PoW blockchain is resource-consuming and vulnerable to bribery attacks or ﬂash

attacks which allow attackers quickly gain computational power to control the

blockchain network. To mitigate these attacks, Yu et al [43] proposed a Proof-

of-Reputation (PoR) blockchain, RepuCoin, which considers miners’ integrated

power rather than using instantaneous mining power to select members. The

integrated power is calculated using the total amount of valid work contributed

by miners to the system. We make use of notations in [44] to describe the basics

of a PoR blockchain.

In a blockchain system, a transaction is the basic unit of transferring ac-

counts from a sender to a receiver. It is deﬁned as the form of tx =< addressinput,

addressoutput, data, sig >, where addressinput indicates the sender’s address,

addressoutput is the receiver’s address, data is the optional ﬁelds that can be

padded with some extra data and sig represents the sender’s signature. There

10

Figure 1: The block structure of [43].

are two kinds of blocks in a PoR blockchain [43], namely keyblocks and mi-

croblocks. A miner creates keyblocks by solving the Bitcoin mining puzzle and

may become a leader for a period of time. A leader can then verify and include

transactions into microblocks directly. We call the microblocks are bonded with

the keyblocks. As shown in Fig. 1, a keyblock is a triple of the form KB =<

s, nonce, pk > while a microblock is the form of M B =< prevhash, tx, sig >.

Here s ∈ {0, 1}K, nonce ∈ N, pk is the blockchain public key of the current

leader, prevhash is the hash value of the previous microblock, txs denote trans-

actions and sig is the signature signed by using pk. Block KB and M B are

valid if

• validBlockD(KB) = H(nonce, G(s, pk)) < D.

• sig is the signature signed by using pk.

• Transactions contained in M B are valid.

Here H(·) and G(·) are cryptographic hash functions with output in {0, 1}K,

and the parameter D ∈ N is the block’s diﬃculty level. As illustrated in Fig.

2, we call a sequence of blocks a blockchain or simply a chain C. The right-

most keyblock is the head of the chain, denoted head(C). Any chain C with a

head Head(C) =< s, nonce, pk > can be extended to a new longer chain C(cid:48) by

attaching a valid keyblock KB(cid:48) or microblock M B(cid:48) such that C(cid:48) = C||KB(cid:48) or

C(cid:48) = C||M B(cid:48). The function len(C) denotes the length of a chain C. Note that

11

Figure 2: The chain structure in PoR blockchain [43].

microblocks do not contain any proof of work.

We deﬁne the consensus mechanism of a PoW blockchain system as the

form CM =< mining, policy >. In the mining process, miners try to calculate

a hash value H(nonce, G(s, tx)) less than D to create a new block. In order to

ensure the consistency of a PoW blockchain, all miners accept the policy that the

longest chain is the only chain. While in a PoR blockchain system, the consensus

mechanism is deﬁned as CM =< mining, BF T (R) >. That is, in mining

process, miners calculate H (cid:48)(nonce, G(s, pk)) less than D to accumulate their

reputation scores. Then the miners with the top n reputation scores execute

the Byzantine fault tolerance (BFT) protocol to generate new blocks.

4. System and threat model

In this section, we ﬁrst delineate the workﬂow of SPChain. Thereafter we

present the adversary model and the security requirements respectively.

4.1. High-level overview

As shown in Fig. 3, there are two participants in our system: patients

and medical institutions. Patients and medical institutions possess their own

blockchain addresses of the form < (pk, sk), address >, where (pk, sk) is a

blockchain key pair and address is the entity’s blockchain address. Each entity

also holds a PRE key pair (Rpk, Rsk) to share EMR in a privacy-preserving

manner. The procedure that patients consult medical institutions in SPChain

is illustrated as follows.

Firstly, a patient ˜i sends a transaction to register into medical institution
˜M . Upon receiving the register transaction, ˜M generates EMRs for ˜i. After

12

Figure 3: The architecture of SPChain.

being encrypted with the patient ˜i’s PRE public-key Rpk˜i, the EMRs are stored
in the medical institution’s local database. The hash values and pointers of the

encrypted EMRs are then uploaded to the blockchain via transactions. Then
˜M participates in mining to commit transactions into blocks.

In return, the

winning miners gain rewards and reputation scores which can be used to apply

for the patients’ EMRs.

When the patient ˜i wants to share EMRs to medical institution ˜N , ˜i should
generate re-encrypted key rk by using own private key and the public key of ˜N .
Then the decryption right of the ciphertext can be delegated to ˜N . In the case
of misdiagnosis, patients send transactions to label the wrong records. Also, ˜i

can access EMR history in SPChain, and do not need double registration.

4.2. Adversary model

In SPChain, medical institutions work as miners to mine new blocks to

accumulate their reputation scores. That is, the medical institutions ﬁrst solve a

cryptographic puzzle to join the consensus group. Then the medical institutions

with the top n reputation scores of the consensus group execute the Byzantine

fault tolerance (BFT) protocol to generate new blocks. Therefore, we consider

an adversary (a.k.a. Byzantine) who can drop, delay, re-order, insert or modify

messages arbitrarily. The medical institutions can also collude with others to

13

model a malicious real organization capable of deploying a signiﬁcant number

of virtual miners under its direct dependence.

In consequence, the consensus group can be inﬁltrated by adversaries. How-

ever, we hold the assumption that the number of Byzantine nodes in the system

does not exceed 1

tation is less than 1

3 the total number of group members whose collective repu-
3 of the cumulative reputation of the consensus members,

which is the same as in RepuCoin [43].

4.3. Design goals

Under the adversary model mentioned above, SPChain should satisfy the

following security requirements.

Conﬁdentiality. SPChain achieves EMRs sharing for patients without re-

vealing sensitive data of patients. That is, the contents of EMRs should not be

recovered by unauthorized medical institutions or attackers.

Patient centric sharing. In SPChain, patients take control of their EMRs.

The unauthorized medical institutions cannot access the patients’ EMRs.

Quick retrieval. SPChain provides special storage structure for patients

such that patients can retrieve their medical history quickly.

Label and correctness. SPChain provides special transactions for autho-

rized medical institutions to label wrong EMRs. Also, SPChain guarantees the

integrity of EMRs, which means that any illegal modiﬁcations on EMRs should

be detected by the system.

Resistance to blockchain attacks. SPChain should prevent attackers

from launching blockchain attacks, such as 51% attacks under the proposed

adversary model.

• 51% attacks [45] and ﬂash attacks [46]. An attacker can obtain a tem-

porary majority of computing power by renting enough mining capac-

ity, which would break the security assumption of Proof-of-Work based

blockchain systems.

• Selﬁsh mining attacks (block withholding attack) [47].

In this case, an

14

attacker controls a signiﬁcant amount (> 25%) of mining power in the

system. Instead of publishing the mined block to the network, the selﬁsh

miner mines the block continuously maintaining its track. The attacker

only publishes the chain of the transaction to increase the amount of

revenue earned.

• Sybil attacks. In permissioned blockchains that without proof of work, an

attacker can launch Sybil attacks to create multiple identities for voting

and thus gain an advantage in consensus.

Resistance to SPChain attacks. SPChain should prevent attackers from

launching the following SPChain attacks under the proposed adversary model.

• Reputation fraud attacks. A malicious medical institution may create

”zombie” patient nodes to send fake transactions to increase its reputation

scores.

• Inhibition attacks. When a medical institution of the consensus group

becomes a leader successfully, it may only package its own transactions

and ignore other medical institutions’ transactions on purpose to increase

the reputation scores.

5. Construction of SPChain

In this section, we present details describing the diﬀerent concepts and mod-

ules underlying SPChain. We ﬁrst introduce the basic elements of SPChain.

Thereafter, we describe how to integrate the SPChain with eHealth systems to

achieve patient centric medical data sharing in a privacy-preserving manner.

5.1. Basic elements in SPChain

Transaction. As shown in Fig. 4, there are three types of transactions in

our system, namely register transactions, medical transactions and label trans-

actions. Transactions in SPChain are presented as the form of (T ype, addressinput,

addressoutput, data, sig), where T ype denotes the type of a transaction, addressinput

15

and addressoutput represent the blockchain address of the sender and the re-

ceiver respectively, data identiﬁes the contents in diﬀerent types of transactions

and sig speciﬁes the signature of the transaction sender. In our system, regis-

ter transactions are packed into keyblocks while medical transactions and label

transactions are attached to the microblocks bound to the patients. We use RE

to represent the encrypted ciphertext in a PRE scheme.

Figure 4: The structure of transactions in SPChain.

• Register transaction. This transaction is send to the medical institution

which the patient wants to be treated at the ﬁrst time. We denote a reg-

ister transaction as TR = (register, H(N o.||Age), sigP ), where register

speciﬁes the transaction type, H(N o.||Age) denotes the hash value of a

patient’s medical record number, age and other auxiliary information, and

sigP is the signature of the patient. Every patient should send this trans-

action to register in SPChain.

• Medical transaction. This transaction is send by patients to upload records

to the blockchain. We deﬁne a medical transaction TM = (medical, CH

(RE P (EM Rs))||r||pointer, sigP ), where medical indicates that this is a

medical transaction, CH(RE P (EM Rs)) represents the chameleon hash

value of the encrypted EMRs, pointer is the pointer to the encrypted

EMRs stored in the local database and sigP is the signature of the patient.

• Label transaction. When medical errors occurs, patients send this transac-

tion to label the wrong records. We deﬁne a label transaction TM = (label,

16

H(TM ), CH(RE P (EM Rs(cid:48)))||r(cid:48)||pointer, sigP ), where label indicates the

transaction is a label transaction, H(TM ) is the transaction hash value
of the medical transaction to be labeled, CH(RE P (EM Rs(cid:48))), r(cid:48), pointer

and sigP are the same as the above deﬁnitions.

Blocks. As shown in Fig. 5, SPChain contains two diﬀerent blocks, namely

keyblocks and microblocks. In RepuCoin [43] and Bitcoin-ng[48], the keyblocks

do not contain transactions, while the keyblocks of SPChain contain register

transactions TR such that KB =< s, TR, nonce, pk >. The Register transaction

hash root in a keyblock is calculated by a cryptographic hash function such as

SHA-256 used in Bitcoin, which means that the registers transactions contained

in the keyblock cannot be modiﬁed without changing the hash root.

Figure 5: The structure of blocks in SPChain.The red blocks is a fork of the main blockchain

(red blocks).

We deﬁne a microblock M B =< prevhash, TM , TL, sig > as a patient block

which contains all EMRs of the patient in diﬀerent medical institutions.

In

order to facilitate the retrieval of records, we use merkle tree structure to con-

struct the institution hash root. We leverage the chameleon hash function to

calculate the Medical institution hash root to update and retrieve EMRs of a

patient in the microblock. The leaf nodes of the tree are the basic information

(for example, the public key which is certiﬁed by authority) of medical institu-

tions. Fig. 6 details the calculation of hash root. There are two cases in the

17

calculation, an even number n and an odd number n. Medical transactions and

label transactions are attached behind the basic information in chronological

order.

Figure 6: The calculation of the Medical institution hash root in a Microblock.

Chain structure. We regard the register transactions stored in the key-

block as the indexes of the bonded microblocks. That is, the microblocks that

follow each keyblock correspond one-to-one with the register transactions in the

keyblock. In this case, the chain structures in [43], [49] and [48] do not suit for

SPChain because the chain structure may fork as shown in Fig. 5, resulting

in a mismatch problem between register transactions of the keyblock and the

bonded microblocks. In order to avoid the mismatch, we devise a new chain

structure which is illustrated in Fig. 7. Suppose a miner wants to mine the

keyblock KBi to extend the chain C with Head(C) = KBi−1. The miner takes
the hash values of microblock M Bi−2

and keyblock KBi−1 as inputs and tries

j

to calculate a hash value H(nonce, G(M Bi−2

j

), G(KBi−1), pk) that less than D,

where H(·), G(·) are cryptographic hash functions and D is the block’s diﬃculty

level. This design avoids the mismatch problem because it gives the leader of

keyblock KBi−1 enough time to generate the bonded microblocks before the

keyblock KBi is minded.

Consensus mechanism. We deﬁne the consensus mechanism of SPChain

as the form CM =< P oW, BF T (R) >. That is, medical institutions try to

calculate H(nonce, G(s, pk)) less than D to accumulate their reputation scores

R. Then the miners with the top n reputation scores execute the Byzantine

18

Figure 7: The chain structure in SPChain. From the blue arrows we can see that the input
of the keyblock KBi is coming from two parts, the hash value of the microblock M Bi−2

and

j

the hash value of the keyblock KBi−1. The genesis part is set by the system management.

fault tolerance (BFT) protocol to generate new blocks. RepuCoin [43] gives a

method to calculate the reputation score R1 by evaluating the frequency of min-

ers creating keyblocks and microblocks. In SPChain, we leverage the number of

registered patients and medical records in diﬀerent medical institutions to cal-

culate the reputation score R2. We call R1 the blockchain reputation score and

R2 the medical reputation score. The reputation score of a medical institution is
deﬁned as R = 1

2 (R1 + R2) and can be regarded as the metric to assess whether
a medical institution is worthy of obtaining patients’ EMRs. The notions are

deﬁned in Table 1 and R2 is calculated in Algorithm 1.

In order to prevent a malicious medical institution in the consensus group

from launching inhibition attacks, we devise a transaction processing algorithm

which stipulates that the transactions of medical institutions are veriﬁed propor-

tionally according to their reputation. We illustrate the notations of reputation

calculating in Table 2 and detail the transaction processing algorithm to resist

inhibition attacks in Algorithm 2.

We call a round l is a process where a keyblock and the corresponding

microblocks are generated. In each round the keyblock is the sorting index of

the following microblocks, which means the microblocks are mined in the order

19

Table 1: The notations of reputation calculating.

Symbol Description

L

c

l

N

T

the length of the current blockchain;

the size of a block chunk, i.e. the number of keyblocks contained in a

chunk, pre-deﬁned by the system;

l = (cid:100) L

c (cid:101) is the number of keyblocks contained in a blockchain with

length L;

the total number of the current microblocks;

total transactions in blockchain;

T M Li

the number of medical transactions and label transactions whose re-

ceiptor is miner in chunk i;

T Ri

the number of register transactions whose receiptor is miner in chunk

i;

H

a binary presenting whether the miner is honest (”1”) or not (”0”);

meani

the mean value of medical transactions and label transactions (if i =

T M L) or register transactions (if i = T R) created by a miner or a

leader across all epochs in the blockchain, respectively;

the standard deviation corresponding to meani, for i ∈ {T M L, T R};

reputation score deﬁned in RepuCoin;

si

R1

(a, λ)

reputation system parameters.

of the register transactions packed in the keyblocks. When sending medical or

label transactions, patients should append rounds number to transactions to

shard them in the consensus group.

To mitigate the fork problem, we use the pinned blocks mentioned in Re-

puCoin [43]. Fig. 8 details the formats of a pinned keyblock and a pinned

transaction. A pinned keyblock is a keyblock that is agreed upon and signed

by the consensus group. A pinned keyblock is ﬁnal and canonical, and all key-

blocks that conﬂict with a pinned keyblock are considered invalid. Based on this

deﬁnition, we also deﬁne the pinned transactions. Each time the transactions

are generated by patients, the medical institutions collect the transactions sent

to themselves, and propose them to the consensus group. The group veriﬁes

20

Algorithm 1
Input: L, c, l, T Ri, T M Li, R1, a and λ

Output: The miners’ reputation R2 ∈ [0, 1].

1: for All medical institutions do

The reputation algorithm

2:

3:

4:

5:

calculate meanT R =

calculate meanT M L =

(cid:80)l

i=1 T Ri
N
(cid:80)l
i=1 T M Li

calculate sT R =

calculate sT M L =

(cid:113)

(cid:80)l

T
i=1( T R

l · (cid:80)l
1
(cid:113)
l · (cid:80)l

1

c −
i=1( T M L

c −

i=1 T Ri
N
(cid:80)l

)2

i=1 T M Li

)2

T

6: end for

7: Set q1 = meanT R
1+sT R

and q2 = meanT M L
1+sT M L

8: Deﬁne x = q1 · q2 · L
9: Deﬁne f (x) = 1

2 (1 + x−a

λ+|x−a| )

10: R2 = min(1, H · f (x))
11: R = 1

2 (R1 + R2)

Figure 8: The formats of a pinned keyblock and a pinned transaction.

the received transactions and signs to the valid transaction. Then the medical

institutions append the pinned transactions to the corresponding microblocks.

Reward mechanism.

In SPChain the rewards can be divided into two

parts, transaction fees and mining rewards. Medical institutions can deﬁne

the determined amount of diﬀerent type transactions to gain the corresponding

transaction fees. After mining a pinned keyblock successfully, the medical insti-

tutions can get a reward contained the predeﬁned mining rewards and the reg-

ister transaction fees in the keyblock. Similar to keyblock rewards, microblock

rewards also contain mining rewards and transaction fees, which are shared

among the reputable medical institutions who create the microblocks and verify

21

the contained transactions.

Table 2: The notations of reputation calculating

Symbol Description

mi

Ti

G

n

Ri

∆

k

Tm

the i-th medical institution;

the transaction set of mi;

the consensus group;

the total number of the medical institutions;

the reputation score of mi;

the time interval;

a nonce;

the maximum number of transactions processed by consensus group at

a time;

Algorithm 2
Input: mi, Ri, Ti, k, p = (cid:80)k
Output: The pinned transaction set T .

Transaction processing algorithm
i=1 |Ti|, P = (cid:80)k

i=1 Ti, ∆ and G.

1: mi sends Ti within ∆ to G

2: G collects Ti and forms a table B = [T1, . . . , Tn]

3: G selects ti ∈ Ti according to reputation ranking , where ti = 10(cid:98)Ri(cid:99)

4: Case 1: k ≤ N

G picks Ti from B until p = (cid:80)k

i=1 |Ti|

5: Case 2: k > N

G picks transactions from the beginning medical
(cid:80)k

i=1 |Ti|

institution until p =

6: P is the ﬁnal veriﬁed set T

5.2. Description of SPChain

In this part, we present the detailed workﬂow of SPChain upon the above

basics. Every entity (e.g. patients and medical institutions) in SPChain holds

a blockchain account of the form < (pk, sk), address >. Fig.9 details the or-

chestration of SPChain. The system is consist of the following phases, namely

22

Setup, Register, Upload, Label, Share and Retrieval, which are illustrated

as follows.

Setup. This phase initializes the system parameters and generates ac-

counts for entities. Firstly entities invoke PRE.KeyGen and bitcoin accounts

algorithms to generate the PRE key pair (Rpk, Rsk) and the bitcoin accounts

< (pk, sk), address > respectively. Then medical institutions initialize the

chameleon hash function parameters by invoking the algorithm CH.HGen.

• Patients:

(Rpkp, Rskp) ← KeyGen,

< (pkp, skp), addresspkp >← Bitcoin(rand).

• Medical institutions:

(Rpkm, Rskm) ← KeyGen(par),

< (pkm, skm), addresspkm >← Bitcoin(rand),
(hk, tk) ← HGen(1K).

Figure 9: The orchestration of SPChain.

23

Register. In the register phase, patients send register transactions to the

medical institutions to register in SPChain.

(1) Patient ˜i sends register transaction TR˜i
transaction contains proper register fees to ˜C.

to medical institution ˜C. The

(2) Medical institutions (miners) collect register transactions and pack them

into keyblocks. Then Medical institutions propose keyblocks to consensus group.

(3) The consensus group veriﬁes the validity of the keyblocks, and runs

Byzantine agreement protocol to decide which keyblock is the ﬁnal pinned key-

block (if multiple conﬂicting keyblocks are proposed). Then the reputable miner

is selected to commit microblocks according to the register transactions in the

keyblock.

Upload. The serial number (4)-(6) given in Fig. 9 illustrate the process

of a patient uploading the EMRs to SPChain. There are three cases in this
phase, patient ˜j is diagnosed in medical institution ˜A for the ﬁrst time; patient
˜j updates EMRs in the same medical institution ˜A; or patient ˜j is diagnosed
in another department of medical institution ˜B. We describe the three cases in

detail in Fig.10.

Case 1: Patient ˜j is diagnosed in medical institution ˜A for the ﬁrst time.
(4(cid:48)) Patient ˜j registers in the system and is diagnosed in medical institution
˜A. Firstly, ˜A generates EMR for ˜j and invokes PRE.Enc to encrypt the EMR
with the PRE public key Rpk˜j of patient ˜j. Then medical institution ˜A invokes
CH.Hash to generate chameleon hash value (RE Rpk˜j
(EM R)||r) of the encrypted
EMRs. Besides, ˜A generates a pointer that point to the local database, and
sends them to ˜j.

Upon receiving (RE Rpk˜j

(EM R)||r, pointer), patients ˜j generates transac-
and sends it to the medical institution ˜A. Note that the ciphertext
(EM R) is stored in the local database of medical institution ˜A.

tion TM˜j
(RE Rpk˜j

(5(cid:48)) The consensus group invokes the transaction processing algorithm (Al-

gorithm 2) to verify the transactions proportionally according to the medical

institutions’ reputation scores.

(6(cid:48)) The consensus group veriﬁes the validity of the transactions and signs

24

Figure 10: The three cases in U pload

to them. To become pinned transactions, the transactions should not only get

two-thirds of signatures, but also get more than two-thirds of the reputation
scores. Then the medical institution ˜A appends the pinned transactions to the

microblock M B˜j.

Case 2: Patient ˜j updates EMRs in the same medical institution ˜A.
In
this case, patient ˜j goes to the medical institution ˜A for treatment again and

updates the EMRs on the basis of Case 1.

(4(cid:48)(cid:48)) The medical institution ˜A generates EMR* for ˜j and invokes PRE.Enc

and CH.Hash to get RE Rpk˜j

(EM R∗), CH(RE Rpk˜j

(EM R∗)) and r∗.

(5(cid:48)(cid:48)) Patient ˜j generates transaction T ∗
M˜j

and sends it to medical institution

˜A. Then the consensus group collects the transactions, validates T ∗
M˜j

and signs

it.

(6(cid:48)(cid:48)) After the transaction T ∗
M˜j

is pinned, medical institution ˜A appends the

transaction to the microblock M B˜j.

Case 3: Patient ˜j is diagnosed in other medical institution ˜B.

25

(4(cid:48)(cid:48)(cid:48)) Medical institution ˜B generates EMR(cid:48) for ˜j and invokes PRE.Enc and

CH.Hash to obtain RE Rpk˜j

(EM R(cid:48)), CH(RE Rpk˜j
(5(cid:48)(cid:48)(cid:48)) Then patient ˜j generates transaction T (cid:48)

stitution ˜B. The consensus group validates T (cid:48)

M˜j

(EM R(cid:48))) and r(cid:48).

and sends it to medical in-

M˜j
and signs it.

(6(cid:48)(cid:48)(cid:48)) After the transaction T (cid:48)

M˜j

is pinned, medical institution ˜B appends the

transaction to the microblock M B˜j.

Label. In this phase, patient ˜j labels the wrong EMRs in case of misdiag-

nosis. The transaction which contains the wrong EMR should be labeled by a

label transaction.

(7) The medical institution ˜B generates the correct EMR(cid:48)(cid:48) for ˜j and invokes

PRE.Enc and CH.Hash to generate RE Rpk˜j
r(cid:48)(cid:48).

(EM R(cid:48)(cid:48)), CH(RE Rpk˜j

(EM R(cid:48)(cid:48))) and

(8) After that patient ˜j generates transaction TL˜j
institution ˜B. Then the consensus group validates TL˜j

and sends it to medical

and signs it.

(9) Finally the pinned transaction TL˜j

labels the wrong transaction in mi-

croblock M B˜j. And patients can verify the new transaction through the new
proof r(cid:48)(cid:48).

Share and retrieval. Patient ˜j shares EMRs to the medical institution ˜D

and retrieve EMRs as follows.

(10) Suppose patient ˜j wants to go to medical institution ˜D for diagnosis.
˜j wants to share his/her EMRs in medical institution ˜A to medical institution
˜D to get a better treatment. Firstly, ˜j takes the public parameter par, his/her
private key Rsk˜j and the medical institution ˜D’s public key Rpk ˜D as input
and invokes PRE.ReKeyGen to generate the re-encryption key rk˜j→ ˜D. Then
he/she transmits rk˜j→ ˜D to the medical institution ˜A which is the ﬁrst medical
institution he/she registered. Using rk˜j→ ˜D the medical institution A invokes
PRE.ReEnc to generate the ciphertext C˜j→ ˜D, and transmits the ciphertext to
medical institution ˜D. Then ˜D invokes PRE.Dec2 to obtain the EMRs of patient
˜j. In addition, the medical institution ˜D can apply for EMRs from patients ˜j.
With a reputation score higher than the threshold set by ˜j, ˜D can require access
to ˜j’s EMRs from medical institution ˜A.

26

The patient ˜j can also access his/her EMR history. In this case ˜j submits

his block number to any medical institutions and obtain the entire history of

diagnosis.

6. Performance evaluation and security analysis.

In this section, we ﬁrst evaluate the performance of SPChain. Thereafter

we discuss whether SPChain can fulﬁll the requirements and prevent attacks

proposed in Section 4.

6.1. Implementation

In order to show the feasibility of SPChain, we build a Bitcoin network in

a desktop computer (equipped with a Ubuntu 16.04 LTS, Intel (R) Core (TM)

i5-8500 CPU of 3.00GHz and 16GB RAM). In our deployment of SPChain,

we adopt a state-of-the-art Byzantine-resilient consensus protocol called BFT-

SMaRt [50] which is widely used in diﬀerent programs such as Hyperledger

Fabric. We adopt the computing power of Bitcoin miners 2 in the real world to

simulate the mining process of diﬀerent medical institutions. We make use of

Github programs Repuify 3 to simulate the communication process of SPChain.

Similar to Bitcoin, we stipulate that keyblocks are generated every 10 minutes

on average. Diﬀerently, the medical institutions which create microblocks send

them at the highest rate they can maintain.

6.2. Performance evaluation

We evaluate the performance of SPChain in the following aspects.

Storage cost. We choose the Nursery dataset from University of California,

Irvine (UCI) Machine Learning Repository [51] as the test dataset. The dataset

2The computing power of the top 26 mining pools are 17.02%, 15.9%, 12.99%, 11.25%,

6.37%, 6.15%, 5.22%, 4.58%, 4.01%, 3.81%, 3.21%, 1.84%, 1.68%, 1.64%, 1.55%, 1.20%,

0.50%, 0.44%, 0.33%, 0.1%, 0.05%, 0.04%, 0.04%, 0.03%, 0.01%, 0.01% respectively.

https://btc.com/stats/pool?pool mode=year
3https://github.com/JeevanPillay/repuify

27

Figure 11: Storage overhead Comparison.

Table 3: The size of diﬀerent transactions.

Size(byte)

Type

type

input

output data

sig

total

TR

TM

TL

4

4

4

110

110

110

70

70

70

32

288

320

70

70

70

286

542

574

contains 12960 EMRs and the average size of each EMR is 32KB. We expand

the number of EMRs in the original dataset to 500000 to evaluate SPChain. We

leverage the chameleon hash function in Github 4 to generate chameleon hash

values for encrypted EMRs. Table 3 describes the sizes of diﬀerent transactions.

We also test the storage overhead of diﬀerent schemes under diﬀerent numbers

of EMRs, and the results are shown in Fig. 11. Compared with hybrid solution

[7], MedRec [34] and MedChain [52], SPChain has lower storage overhead. For

example, when sharing 250000 EMRs, the blockchain size of SPChain is 119MB,

4https://github.com/julwil/chameleon hash

28

less than that of hybrid solution (350MB), MedChain (651MB) and MedRec

(411MB).

Figure 12: The throughput of SPChain (key-

Figure 13: The throughput of SPChain (mi-

blocks).

croblocks).

Throughput.

In this part we analyze the maximum throughput of our

system. We assume the consensus group controls 90% computing power. Since

keyblocks in SPChain contain register transactions, so we analyze the through-

put in terms of keyblocks and microblocks. From Fig. 12 we can see that the

throughput of keyblocks is similar to that of bitcoin systems since they are under

the same mining strategy. When ﬁx the block size to 4MB, the system has higher

throughput than that of 1MB and 2MB. As for microblocks, our results in Fig.

13 shows that when the block size is ﬁxed, as the number of consensus nodes in-

creases, throughput decreases gradually. For example, with the block size 1MB,

the through decreases from 145 TPS to 116 TPS. Besides, from Fig. 13 we can

see that when ﬁx the block size to 2MB, the system has higher throughput than

that of 1MB and 4MB. In particular, when the consensus group consists of 4

nodes, the through can reach 218 TPS.

Time cost. We analyze time cost in terms of EMRs sharing and EMRs

retrieval. Note that patients encrypt EMRs before storing them to the local

database of a medical institution and later the medical institution re-encrypts

EMRs for sharing them. Fig. 14 illustrates the data sharing time cost in

29

Figure 14: The time cost of EMRs sharing in a medical institution.

SPChain. For example, when a patient shares 50 EMRs from medical institution
˜A to medical institution ˜D, ˜A spends 21 seconds to generate the re-encryption

key and 5 seconds to re-encrypt the shared EMRs.

Table 4: Comparison between existing blockchain-based eHealth systems and SPChain.

Scheme

First part (block)

[21]

O(n)

[38]

O(n)

[34]

O(n)

[31]

SPChain

O(n)

O(1)

Second part (record) O(logn) O(logn) O(logn) O(logn)

O(logn)

Table 4 illustrates the time complexity of retrieving medical records in diﬀer-

ent schemes. In SPChain, the time consumption of retrieving an EMR is divided

into two part. The ﬁrst part is to locate a speciﬁc block. Due to the special

construction of blocks in SPChain, each patient holds his/her own unique block.

Thus a patient can acquire the block according to the block number directly, so

the time complexity is O(1). The second part of time consumption is to locate

speciﬁc medical records or subtrees by searching in Merkle tree which stores

30

numerous EMRs. The average time complexity is O(logn). From Table 4 we

can conclude that our scheme performs better than other schemes in terms of

retrieving a speciﬁc block.

6.3. Security analysis

SPChain can satisfy all the security requirements described in Section 4.3,

according to the proposed transactions, blocks and chain structure.

Conﬁdentiality. Note that the EMRs are encrypted by patients’ PRE

public-keys and stored in the local databases of medical institutions. In this

circumstance, the medical institutions cannot acquire any information of the

EMRs. When sharing the EMRs to other medical institutions, the encrypted

EMRs can only be decrypted by the authorized medical institutions, which en-

sures that the patients’ EMRs are not disclosed to unauthorized medical institu-

tions during the sharing process. Thus SPChain guarantees the conﬁdentiality

of patients’ EMRs.

Patient centric sharing. We use proxy re-encryption schemes to encrypt

the patients’ EMRs. In this case, medical institutions cannot use or share EMRs

without patients’ authorization because only the authorized medical institutions

can decrypt the encrypted EMRs. Besides, only the reputable medical institu-

tions have the right to request EMRs from patients.

Quick retrieval. We devise special block structure and chain structure for

patients. As illustrated in table 4, SPChain has less time complexity in retrieval

than other schemes.

Label and correctness. SPChain permits medical institutions to label

wrong EMRs and allows patients to verify the correctness of the labeled EMRs.

In the case of misdiagnosis, patients can ask authorized medical institutions to

label the wrong EMRs with the label transaction and to generate the correct

EMRs corresponding to the label transaction. With the parameter r, patients

can invoke CH.HVer to check whether the label is correct.

Resistance to blockchain attacks. To demonstrate that SPChain is

resistant to blockchain attacks and SPChain attacks illustrated in Section 4.3,

31

Figure 15: The distribution of medical institutions’ reputation scores over time.

we simulate the reputation cores of medical institutions by choosing the top 26

mining pools in Bitcoin. We set the parameter a = 5000 and λ = 20000. Fig.

15 describes the distribution of medical institutions with diﬀerent reputation

scores over time. With the operation of SPChain, the reputation score of miners

increase gradually, and the higher computing power the miner holds, the higher

the reputation score it receives.

• 51% attacks and ﬂash attacks. SPChain is resilient to 51% attacks and

ﬂash attacks. Fig 16 shows the time required for an attacker with diﬀerent

computing powers to destroy SPChain. For example, an attacker with

65% computing power would take a month to break SPChain. But after

launching the attacks successfully, the attacker lose all his/her reputation

scores he/she accumulates within one month. We point out that the longer

the system runs, the longer it takes for the attacker to attack. After a

suﬃciently long period of time (a.k.a one year), SPChain can tolerate 51%

attacks and ﬂash attacks.

32

Figure 16: Time to break SPChain.

• Selﬁsh mining attacks. SPChain pins each keyblock, and the pinned key-

blocks cannot be rolled back. Every new created keyblock is chained

behind the pinned keyblocks. So if an attacker publishes a keyblock which

is conﬂict with the pinned keyblock, he/she cannot get advantage of gain-

ing rewards over the honest miners because the keyblock he/she publishes

would not be admitted by the system. When mining a new keyblock,

the miners need to take the hash value of the previous keyblock and the

last microblock of the penultimate keyblock as inputs. Since there is

no conﬂict when generating microblocks, we do not need to consider the

microblock withholding attacks. In summary, SPChain can resist selﬁsh

mining attacks.

• Sybil attacks. Since SPChain adopts PoW consensus mechanism, all med-

ical institutions in SPChain need a lot of computations to accumulate

reputation scores to get voting rights. Thus SPChain can resist Sybil

attacks.

33

Resistance to SPChain attacks. In this part we illustrate how SPChain

can thwarts the following attacks.

• Reputation fraud attacks. To prevent malicious medical institutions from

creating fake patients to increase their reputation scores, we require pa-

tients to register in SPChain with the hash values of unique identiﬁers (e.g.

ID numbers), thus the zombie patients can be ﬁltered out of SPChain. Be-

sides, we stipulate that every transaction should contain transaction fees,

which can increase the attacker’s cost to launch reputation fraud attacks.

• Inhibition attacks. As shown in Algorithm 2, the medical institution in

the consensus group should deal with transactions according to the med-

ical institutions’ reputation scores, which can prevent an attacker from

launching inhibition attacks.

Finally we compare SPChain with other blockchain-based eHealth systems.

From Table 5 we can see that [21], [38], [34] and [52] cannot label wrong EMRs

in the case of misdiagnosis. And these systems are vulnerable to blockchain

underlying attacks such as ﬂash attacks and selﬁsh mining attacks.

Table 5: Comparison between existing systems and SPChain.

Scheme

Share Privacy Label wrong EMRs Flash attacks

Selﬁsh mining attacks

Sybil attacks

[21]

[38]

[34]

[52]

SPChain

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

×

(cid:88)

(cid:88)

×

×

×

×

(cid:88)

×

×

×

×

(cid:88)

×

×

×

×

(cid:88)

×

(cid:88)

(cid:88)

(cid:88)

(cid:88)

7. Conclusion and future work

In this paper, we achieved medical data sharing and retrieval in a privacy-

preserving manner. We have designed register transactions, medical transac-

tions and label transactions for patients to achieve register, EMR uploading

and labeling wrong EMRs respectively. To quickly retrieve the patients’ med-

ical history, we devised special microblocks for each patient. We also designed

34

an reputation-based consensus mechanism to motivate medical institutions such

that the medical institutions can participate in the mining process to accumu-

late reputation scores to require patients’ EMRs. Finally, we discussed how the

proposal can satisfy the security requirements by developing the system in an

analog network with the miner distribution data in the real world. We com-

pared the time costs of data retrieval and the storage costs with some existing

solutions. The results proved the feasibility and eﬀectiveness of our system.

We also analyzed the impact of our reputation-based consensus mechanism on

the security of SPChain and demonstrated that SPChain can eﬀectively resist

blockchain attacks and the proposed SPChain attacks.

For the future work, we intend to reduce the patients’ communication over-

head and improve the throughput of our system.

References

References

[1] A. S. Fauci, H. C. Lane, R. R. Redﬁeld, Covid-19—navigating the un-

charted (2020).

[2] H. Jin, Y. Luo, P. Li, J. Mathew, A review of secure and privacy-preserving

medical data sharing, IEEE Access 7 (2019) 61656–61669.

[3] T. J. Hirschauer, H. Adeli, J. A. Buford, Computer-aided diagnosis of

parkinson’s disease using enhanced probabilistic neural network, Journal

of medical systems 39 (11) (2015) 179.

[4] G. Liu, H. Dong, Z. Yan, X. Zhou, S. Shimizu, B4sdc: A blockchain system

for security data collection in manets, IEEE Transactions on Big Data

(2020).

[5] T. Hardin, D. Kotz, Amanuensis: Information provenance for health-data

systems, Information Processing & Management 58 (2) (2021) 102460.

35

[6] L. Campanile, M. Iacono, F. Marulli, M. Mastroianni, Designing a gdpr

compliant blockchain-based iov distributed information tracking system,

Information Processing & Management 58 (3) (2021) 102511.

[7] J.-J. Yang, J.-Q. Li, Y. Niu, A hybrid solution for privacy preserving med-

ical data sharing in the cloud environment, Future Generation computer

systems 43 (2015) 74–86.

[8] K. Ren, C. Wang, Q. Wang, Security challenges for the public cloud, IEEE

Internet Computing 16 (1) (2012) 69–73.

[9] Q. Zhao, S. Chen, Z. Liu, T. Baker, Y. Zhang, Blockchain-based privacy-

preserving remote data integrity checking scheme for iot information sys-

tems, Information Processing & Management 57 (6) (2020) 102355.

[10] G. Liu, Z. Yan, W. Feng, X. Jing, Y. Chen, M. Atiquzzaman, Sedid: An

sgx-enabled decentralized intrusion detection framework for network trust

evaluation, Information Fusion 70 (2021) 100–114.

[11] Y. Liu, G. Liu, C. Cheng, Z. Xia, J. Shen, A privacy-preserving health

data aggregation scheme, KSII Transactions on Internet and Information

Systems (TIIS) 10 (8) (2016) 3852–3864.

[12] S. Nakamoto, Bitcoin: A peer-to-peer electronic cash system, Tech. rep.,

Manubot (2019).

[13] F. Casino, T. K. Dasaklis, C. Patsakis, A systematic literature review of

blockchain-based applications: current status, classiﬁcation and open is-

sues, Telematics and informatics 36 (2019) 55–81.

[14] C. Sullivan, E. Burger, E-residency and blockchain, Computer Law & Se-

curity Review 33 (4) (2017) 470–481.

[15] N. Jing, Q. Liu, V. Sugumaran, A blockchain-based code copyright manage-

ment system, Information Processing & Management 58 (3) (2021) 102518.

36

[16] C. Esposito, M. Ficco, B. B. Gupta, Blockchain-based authentication and

authorization for smart city applications, Information Processing & Man-

agement 58 (2) (2021) 102468.

[17] F. J. de Haro-Olmo, ´A. J. Varela-Vaca, J. A. ´Alvarez-Bermejo, Blockchain

from the perspective of privacy and anonymisation: A systematic literature

review, Sensors 20 (24) (2020) 7171.

[18] J. B. Bernabe, J. L. Canovas, J. L. Hernandez-Ramos, R. T. Moreno,

A. Skarmeta, Privacy-preserving solutions for blockchain: Review and chal-

lenges, IEEE Access 7 (2019) 164908–164940.

[19] D. Berdik, S. Otoum, N. Schmidt, D. Porter, Y. Jararweh, A survey on

blockchain for information systems management and security, Information

Processing & Management 58 (1) (2021) 102397.

[20] W. J. Gordon, C. Catalini, Blockchain technology for healthcare:

facili-

tating the transition to patient-driven interoperability, Computational and

structural biotechnology journal 16 (2018) 224–230.

[21] Q. Xia, E. B. Sifah, A. Smahi, S. Amofa, X. Zhang, Bbds: Blockchain-

based data sharing for electronic medical records in cloud environments,

Information 8 (2) (2017) 44.

[22] Q. Xia, E. B. Sifah, K. O. Asamoah, J. Gao, X. Du, M. Guizani, Med-

share: Trust-less medical data sharing among cloud service providers via

blockchain, IEEE Access 5 (2017) 14757–14767.

[23] X. Liang, J. Zhao, S. Shetty, J. Liu, D. Li, Integrating blockchain for data

sharing and collaboration in mobile healthcare applications, in: 2017 IEEE

28th annual international symposium on personal, indoor, and mobile radio

communications (PIMRC), IEEE, 2017, pp. 1–5.

[24] T. Hu, X. Liu, T. Chen, X. Zhang, X. Huang, W. Niu, J. Lu,

K. Zhou, Y. Liu, Transaction-based classiﬁcation and detection approach

37

for ethereum smart contract, Information Processing & Management 58 (2)

(2021) 102462.

[25] X. Xu, G. Sun, L. Luo, H. Cao, H. Yu, A. V. Vasilakos, Latency perfor-

mance modeling and analysis for hyperledger fabric blockchain network,

Information Processing & Management 58 (1) (2021) 102436.

[26] R. A. Popa, J. R. Lorch, D. Molnar, H. J. Wang, L. Zhuang, Enabling secu-

rity in cloud storage slas with cloudproof., in: USENIX Annual Technical

Conference, Vol. 242, 2011, pp. 355–368.

[27] A. Kumbhare, Y. Simmhan, V. Prasanna, Cryptonite: a secure and perfor-

mant data repository on public clouds, in: 2012 IEEE Fifth International

Conference on Cloud Computing, IEEE, 2012, pp. 510–517.

[28] J. Li, J. Wu, G. Jiang, T. Srikanthan, Blockchain-based public auditing for

big data in cloud storage, Information Processing & Management 57 (6)

(2020) 102382.

[29] K. Fan, S. Wang, Y. Ren, H. Li, Y. Yang, Medblock: Eﬃcient and secure

medical data sharing via blockchain, Journal of medical systems 42 (8)

(2018) 136.

[30] A. Zhang, X. Lin, Towards secure and privacy-preserving data sharing in

e-health systems via consortium blockchain, Journal of medical systems

42 (8) (2018) 140.

[31] H. Huang, P. Zhu, F. Xiao, X. Sun, Q. Huang, A blockchain-based scheme

for privacy-preserving and secure sharing of medical data, Computers &

Security 99 (2020) 102010.

[32] M. Castro, B. Liskov, Practical byzantine fault tolerance and proactive

recovery, ACM Transactions on Computer Systems (TOCS) 20 (4) (2002)

398–461.

38

[33] D. Boneh, G. Di Crescenzo, R. Ostrovsky, G. Persiano, Public key encryp-

tion with keyword search, in: International conference on the theory and

applications of cryptographic techniques, Springer, 2004, pp. 506–522.

[34] A. Azaria, A. Ekblaw, T. Vieira, A. Lippman, Medrec: Using blockchain

for medical data access and permission management, in: 2016 2nd Interna-

tional Conference on Open and Big Data (OBD), IEEE, 2016, pp. 25–30.

[35] H. Yang, B. Yang, A blockchain-based approach to the secure sharing of

healthcare data, Nisk Journal (2017) 100–111.

[36] J. Zhang, N. Xue, X. Huang, A secure system for pervasive social network-

based healthcare, Ieee Access 4 (2016) 9239–9250.

[37] S. Cao, G. Zhang, P. Liu, X. Zhang, F. Neri, Cloud-assisted secure ehealth

systems for tamper-prooﬁng ehr via blockchain, Information Sciences 485

(2019) 427–440.

[38] L. Chen, W.-K. Lee, C.-C. Chang, K.-K. R. Choo, N. Zhang, Blockchain

based searchable encryption for electronic health record sharing, Future

Generation Computer Systems 95 (2019) 420–429.

[39] P. Rogaway, T. Shrimpton, Cryptographic hash-function basics: Deﬁ-

nitions,

implications, and separations for preimage resistance, second-

preimage resistance, and collision resistance, in: International workshop

on fast software encryption, Springer, 2004, pp. 371–388.

[40] G. Ateniese, B. Magri, D. Venturi, E. Andrade, Redactable blockchain–or–

rewriting history in bitcoin and friends, in: 2017 IEEE European Sympo-

sium on Security and Privacy (EuroS&P), IEEE, 2017, pp. 111–126.

[41] H. Krawczyk, T. Rabin, Chameleon hashing and signatures (1998).

[42] M. Khalili, M. Dakhilalian, W. Susilo, Eﬃcient chameleon hash functions

in the enhanced collision resistant model, Information Sciences 510 (2020)

155–164.

39

[43] J. Yu, D. Kozhaya, J. Decouchant, P. Esteves-Verissimo, Repucoin: Your

reputation is your power, IEEE Transactions on Computers 68 (8) (2019)

1225–1237.

[44] J. Garay, A. Kiayias, N. Leonardos, The bitcoin backbone protocol: Anal-

ysis and applications, in: Annual International Conference on the Theory

and Applications of Cryptographic Techniques, Springer, 2015, pp. 281–

310.

[45] M. Apostolaki, A. Zohar, L. Vanbever, Hijacking bitcoin: Routing attacks

on cryptocurrencies, in: 2017 IEEE Symposium on Security and Privacy

(SP), IEEE, 2017, pp. 375–392.

[46] J. Bonneau, Why buy when you can rent?, in: International Conference on

Financial Cryptography and Data Security, Springer, 2016, pp. 19–26.

[47] A. Sapirshtein, Y. Sompolinsky, A. Zohar, Optimal selﬁsh mining strategies

in bitcoin, in: International Conference on Financial Cryptography and

Data Security, Springer, 2016, pp. 515–532.

[48] I. Eyal, A. E. Gencer, E. G. Sirer, R. Van Renesse, Bitcoin-ng: A scalable

blockchain protocol, in: 13th {USENIX} symposium on networked systems

design and implementation ({NSDI} 16), 2016, pp. 45–59.

[49] G. Yu, L. Zhang, X. Wang, K. Yu, W. Ni, J. A. Zhang, R. P. Liu, A novel

dual-blockchained structure for contract-theoretic lora-based information

systems, Information Processing & Management 58 (3) (2021) 102492.

[50] A. Bessani, J. Sousa, E. E. Alchieri, State machine replication for the

masses with bft-smart, in: 2014 44th Annual IEEE/IFIP International Con-

ference on Dependable Systems and Networks, IEEE, 2014, pp. 355–362.

[51] U. of California, Irvine, nursery data set, http://archive.ics.uci.edu/

ml/datasets/Nursery.

[52] B. Shen, J. Guo, Y. Yang, Medchain: eﬃcient healthcare data sharing via

blockchain, Applied sciences 9 (6) (2019) 1207.

40

