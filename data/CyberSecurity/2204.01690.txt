SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

1

Deep Image: A precious image-based deep learning
method for online malware detection in IoT
Environment

Meysam Ghahramani, Rahim Taheri, Member, IEEE, Mohammad Shojafar,
Senior Member, IEEE, Reza Javidan, Shaohua Wan, Senior Member, IEEE

2
2
0
2

r
p
A
4

]

R
C
.
s
c
[

1
v
0
9
6
1
0
.
4
0
2
2
:
v
i
X
r
a

Abstract—The volume of malware and the number of attacks
in IoT devices are rising everyday, which encourages security
professionals to continually enhance their malware analysis tools.
Researchers in the ﬁeld of cyber security have extensively
explored the usage of sophisticated analytics and the efﬁciency
of malware detection. With the introduction of new malware
kinds and attack routes, security experts confront considerable
challenges in developing efﬁcient malware detection and analysis
solutions. In this paper, a different view of malware analysis is
considered and the risk level of each sample feature is computed,
and based on that the risk level of that sample is calculated.
In this way, a criterion is introduced that is used together
with accuracy and FPR criteria for malware analysis in IoT
environment. In this paper, three malware detection methods
based on visualization techniques called the clustering approach,
the probabilistic approach, and the deep learning approach are
proposed. Then, in addition to the usual machine learning criteria
namely accuracy and FPR, a proposed criterion based on the risk
of samples has also been used for comparison, with the results
showing that the deep learning approach performed better in
detecting malware.

Index Terms—Malware Detection, Image-based Clustering,

Deep Learning, IoT Devices, Visualization Analysis.

I. INTRODUCTION

I N today’s digital world, with the rise of IoT devices

malware development continues at a dizzying rate, despite
measures to recognise and combat it. Malware analysis is
essential to defend against the sophisticated behaviour of this
form of malware. Manual heuristic inspection, on the other
hand, is no longer effective or efﬁcient. To address these
basic challenges, methods based on behavior-based malware
detection mixed with machine learning approaches have been
enthusiastically accepted. It applies supervised classiﬁers to
assess their forecasting ability in terms of identifying the most

M. Ghahramani and R. Javidan are with the Computer Engineering
Iran E-

and IT Department, Shiraz University of Technology, Shiraz,
mails:(m.ghahramani@sutech.ac.ir, javidan@sutech.ac.ir)

R. Taheri

is with the King’s Communications, Learning and In-
lab, King’s College London, UK E-mail:

formation Processing (kclip)
rahim.taheri@kcl.ac.uk

M. Shojafar is with the 5G & 6G Innovation Centre (5GIC & 6GIC),
Institute for Communication Systems, University of Surrey, Guildford, United
Kingdom E-mail: m.shojafar@surrey.ac.uk

Sh. Wan is with the School of Information and Safety Engineering,
Zhongnan University of Economics and Law, 182 Nanhu Avenue, East
Lake High-tech Development Zone, Wuhan, 430073, Hubei, China E-mail:
shaohua.wan@ieee.org

Copyright (c) 2022 IEEE. Personal use of this material

is permitted.
However, permission to use this material for any other purposes must be
obtained from the IEEE by sending a request to pubs-permissions@ieee.org

relevant features from the original feature set and balancing a
high detection rate with cheap computation cost. While ma-
chine learning-based malware detection systems have proved
efﬁcient at identifying malware, their shallow learning archi-
tecture is still not good enough for complicated malware to be
identiﬁed.

The exponential growth of malware is owing to the ﬁnan-
cial rewards connected with malware vulnerabilities such as
cryptocurrency coin miners, banking Trojans, and ransomware.
Analysts depend largely on machine learning algorithms to
discover and classify malware intelligently. Machine learning
algorithms will develop models of benign software and mal-
ware in order to identify malware in IoT environments. The
features that are selected and made available are crucial to
the effective utilization of these automation systems. These
aspects comprise data acquired from static binary executable
ﬁles and dynamic malware/software execution behavior.

The majority of deep learning-based windows malware
detection algorithms now identify the test input ﬁle using static
PE ﬁle attributes. They also create an image from the whole
content of the PE ﬁle. Because PE ﬁles come in a variety of
sizes, a scaling technique is necessary to transform images
with different dimensions to a single dimension. The static
feature-based detection and classiﬁcation technique’s main
drawback is that it is easily evaded by disguised malware.
However, most of the present research in malware analysis is
based on the assumption that a malware sample is accessible.
Frequently, this is not the case. For instance, advanced persis-
tent threat organisations are known to conduct targeted attacks
and then self-delete the malware they have planted.

The methods used in most malware detection systems are
focused on increasing accuracy and decreasing FPR. However,
in this paper, we show that although these two metrics are very
suitable, they are not enough and in some cases even with high
accuracy and low FPR, the detection system does not work
properly. Therefore, in this paper, a metric is presented that
can be used in addition to accuracy and FPR to improve the
detection system.As will be demonstrated, in contrast to the
research literature, which deﬁnes accuracy and FPR in terms
of reducing mean squared error, the strategy described in this
paper is risk-based. This implies that for each sample, a risk
percentage is considered, which is a value between zero and
one, and the risk criterion is set and a decision is made using
this risk percentage.

 
 
 
 
 
 
SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

2

TABLE I: Notations

Notation
Ξ
0 ≤ ξ ≤ 1
φi,1 ≤ i ≤ n
ξ

Description
Time series of Malware
Maliciousness level
availability at the time τi
label

D. Roadmap

The remainder of this paper is structured as follows. Sec-
tion II provides a brief summary of related studies that have
been designed to tackle malware analysis and visualization
technique. Section III presents proposed architecture,include:
clustering, probabilistic and deep learning approaches. A per-
formance analysis of the proposed methods is presented in
section IV. Finally, section V summarises the main achieve-
ments of the paper and gives some directions for future work.

II. RELATED WORK

It has been proposed in the literature a number of ways
for malware analysis that are based on machine learning
techniques. We will highlight some of the research work
that has been done using machine learning techniques to
combat Windows malware. Malwares and other malicious
software are a collection of instructions designed to do damage
to businesses, their processes, networks, and infrastructure.
Malware may be either an executable or a non-executable
object, and its identiﬁcation can be accomplished by either
static,dynamic or hybrid examination of the infected system.

A. Malware analysis

Static analysis is the most basic and widely used method for
determining the functionality of a system. In this method, the
system monitors features of samples and tries to ﬁnd malwares
without running them. It is a technique for extracting features
from an executable application, such as APIs,Permissions,
hardware components and the Intent of the application [1].
These extracted features may be used alone or in combination
to detect malware. Machine learning techniques have been
used to ﬁnd malware in the case of static detection.

Dynamic approaches examine the functionality of an appli-
cation in running time to determine if it is malicious or not. For
example, the paper [2] came up with a way to detect Android
malware called DroidCat that uses features from method calls
and inter-component communication(ICC) to make a multi-
class classiﬁer and ﬁgure out if an app is malicious or not.

Hybrid approaches combines features of both static and
dynamic analysis in a single procedure. Applications that
become malware during runtime cannot be detected by static
techniques, while malware that conceals its harmful behavior
during operating cannot be detected by dynamic methods.
Therefore, some authors develop their detection model using
a combination of both dynamic and static techniques. They
will be able to minimise the downsides while maximising the
beneﬁts of both in this manner.

Throughout literature, there are more researches have been
In addition to ransomware [3], Tro-
done in this area.
jans [4], Keyloggers [5], Backdoors [6], Launchers [7], there

Fig. 1: 2D form of a time series.

A. Motivation and open issues

In high-risk applications such as malware detection, un-
derstanding when a machine learning model
is uncertain
about its prediction is essential. When an automated malware
detection algorithm is uncertain about a sample, the estimated
uncertainty can be utilised to ﬂag the sample for investigation
by a more computationally demanding algorithm or for human
review. Therefore, proposing a method that can predict the
result with more certainty is important and it is an open
problem that this paper has tried to increase this certainty by
introducing a risk criterion.

B. Problem deﬁnition

Malware behavior can be demonstrated using time series
Ξ shown in eq. 1. In this representation, 0 ≤ ξ ≤ 1 shows
the maliciousness level. Also, each malware has features φi’s,
1 ≤ i ≤ n, so that the feature φi is available at the time τi.

Ξ = [ξ , φ1 : τ1, φ2 : τ2, · · · , φn : τn]

(1)

This paper intends to propose a malware detection method to
calculate ξ from [φ1 : τ1, · · · , φn : τn]. Note that eq. 1 is not
the only representation for Ξ. For example, a two-dimensional
diagram with label ξ , as in Figure 1, can be used.

The symbols and notation of this paper are summarized in

Table I.

C. Contribution

To summarise, the following are the most signiﬁcant con-

tributions made by this paper:

• We have proposed new visualization-based methods for

Windows malware detection.

• We provide clustering and probabilistic as trivial methods for
predicting the labels of samples that have been converted to
images.

• It is proven that accuracy and false positive rate are not
necessarily adequate criteria for estimating the risk weight
of malware samples using a criterion that is supplied.

• A method based on deep learning is proposed that has been
converted samples to images samples is presented, which
has high performance with both accuracy and FPR criteria
and with the introduced risk-based criteria.

SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

3

are other categories of malware. Both signature-based and
behavior-based techniques are used for malware detection.
The signature-based approach is useful for identifying known
threats without producing an excessive number of
false
alarms [8], but it needs regular manual updates of the database
containing rules and signatures. According to [9], a malware
detection strategy in the Internet of Things environment based
on a similarity hashing algorithm has been presented. The
scores of binaries were computed in the proposed approach
in order to determine the similarity between malicious PEs.

Hybrid techniques combine aspects of both static and dy-
namic analysis. Static methods can’t ﬁnd apps that become
malware during runtime, and dynamic methods can’t ﬁnd
malware that hides its bad behaviour during operation. As a
result, some papers use a combination of both dynamic and
static approaches to design their detection model. This way,
they can minimise the drawbacks and maximise the beneﬁts
of both.

B. Visualization technique

Image-based malware classiﬁcation algorithms can over-
come code obfuscation or encoding difﬁculties, comparable
to and more advanced than static analysis approaches [8].
These image-based methods employ static analysis techniques
to turn malware samples into image representations [10]. Conti
et al. [11]conducted the ﬁrst research on the visualisation of
binary data as images. They demonstrated how to convert
binary data into visual images, referred known as ”byte-plots,”
in order to increase the capabilities of text-based hex editors.
Instead of depending on behaviour or signatures, researchers
utilise transformation methods to turn raw malware binaries
into pixel-based representations that may be used by machine
learning algorithms to classify malware [12].

One developing method in machine learning for malware
detection is to employ visual features from malware samples
in conjunction with powerful machine learning algorithms in
computer vision to maximise the beneﬁts of advanced machine
learning algorithms [13], [14]. The majority of these methods
convert a binary ﬁle to an image by reading the binary ﬁle’s
byte sequences as grayscale pixel values.

There was a study done by Yajamanam et al [15] that
looked at the GIST-based byte-plot method with a limited set
of features. Further testing was done with deep learning and
Tensorﬂow. Results were similar to the original research by
Nataraj et al.
[16], but they used a smaller set of 60 features
instead of the original 100 features. This is how Le et al. [17]
used convolutional neural networks to look at binary ﬁles
from the Microsoft Malware Classiﬁcation Challenge dataset
(Ronen et al., [18]) that had been turned into byte-plot images.
Results from the data show that 98.8% of the validation data
was correct with a processing time of about 20ms per sample.
The researchers in [19] used local gray-level co-occurrence
matrices and global colour moments to extract features from
grayscale and colour byte-plots. Classiﬁers such as Random
Forest, Support Vector Machine , and K-Nearest Neigh-
bor were then trained on these features. The studies in this
paper used a dataset of 7087 malware samples from 15 various

malware families. The Random Forest classiﬁer’s accuracy,
precision, recall, and f-measure were all more than 97%.

Unlike the work on byte-plots, there has been relatively
little study on how to identify malware using space-ﬁlling
curves. The authors of
[20] devised a method for classi-
ﬁcation malware based on its nature, which makes use of
Hilbert curves and a Self-Organizing Incremental Network.
Experiments were conducted on 180 samples, with 78 of them
proving to be completely innocuous. The malware was clas-
siﬁed into these classes: Trojans, ransomware, and unknown.
Even though the author claimed that the Hilbert curve was
89% correct, if you look at just 180 samples, it’s not apparent
whether the Hilbert curve is an effective method of classifying
malware. When working with smaller datasets, overﬁtting is
more likely to occur, which implies the model will not be able
to perform effectively with additional samples.

Vu et al. [21] devised a method that combined statistical and
syntactic elements, which were then translated into an image
format using a variety of layout functions, such as space-
ﬁlling curves, to create a visual representation of the infection.
An experimental dataset of 16,000 excellent and poor images
was used to evaluate the technology, which was named hybrid
image transformation (HIT). HIT was tested using four distinct
layout functions, including two SFC implementations, Hilbert
and Hcurve, which were both employed in the testing. Ac-
cording to the authors, their hybrid approach and Hilbert SFC
layout function are the most accurate methods for achieving 93
percent accuracy. Throughout this essay, only two categories
of objects are considered: those that are good and those that
are harmful. It does not introduce malware onto a family’s
network. When it came to categorization, the only way to
determine how well you did was by your accuracy. It would
have been possible to utilize other metrics to demonstrate how
effectively the method functioned, such as accuracy, recall,
and F1- score. It is possible that accuracy alone will not be
sufﬁcient to demonstrate how effectively it worked. Aside from
that, there was no testing done with a holdout dataset to assess
how well the model might generalize to new data.

III. PROPOSED METHOD

The method proposed in this paper is dedicated to mon-
itoring target programs during τ seconds, which is called
monitoring time. During this time, applications invoke ex-
tracted features by the monitoring system as a time series
that is accessible using known datasets. The proposed method
maps the samples into an image with dimensions nφ × τ
using algorithm 1, where nφ and τ represent the number of
extracted features and the monitoring time, respectively. After
obtaining the images, different methods analyze them, and
by introducing a more efﬁcient method, the problems of the
previous method are solved. Figure 2 shows this process.

A. Clustering Approach

In this section, images are analyzed and their labels are
extracted using the clustering technique. To calculate labels, a
clustering image that contains malware information is needed.
This image is a nφ -by-τ × (cid:96) black and white image CI

SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

4

Algorithm 1 Proposed malware detection algorithm.

Required matrices for (cid:96) maliciousness levels:

1: Set a zero nφ by τ × (cid:96) matrix as CI, for clustering image.
2: Set a zero nφ by τ × (cid:96) matrix as PI, for Probabilistic image.
3: Create a zero 1 by (cid:96) matrix as CW , for the weight of clusters.
4: Create a zero 1 by (cid:96) matrix as CL, for the label of clusters.
5: Create (cid:96) empty folders named 1, · · · , (cid:96), for storing deep learning images.
6: for Ξ ∈ Trainset do
7:
8:
9:
10:
11:
12:

Set the label of Ξ as ξ .
Set the Target Cluster TC as: TC = (cid:98)(cid:96) × ξ (cid:99) + 1.
CW1,TC ← CW1,TC + 1
CL1,TC ← CL1,TC + ξ
Set a zero nφ by τ matrix as Z.
for (φi : τi) ∈ Ξ do

Time series to image conversion:

13:

14:

15:
16:

Zφi,τi ← 1

Clustering image computation:

CIφi,(TC−1)×τ+τi ← 1

Probabilistic image computation:
PIφi,(TC−1)×τ+τi ← PIφi,(TC−1)×τ+τi + 1

end for

Image generation for deep learning detection:

Save image form of Z in folder TC.

17:
18: end for
19: for Ξ ∈ Testset do
20:
21:
22:
23:

end for

Set a zero nφ by τ matrix as Z.
for (φi : τi) ∈ Ξ do
Zφi,τi ← 1

Cluster-based Approach (CA):

Compute i that minimizes ∑
Return

nφ
r=1 ∑τ
as the estimated maliciousness level ξ (cid:48).

c=1 |Zr,c −CIr,(i−1)×τ+c|

CL1,i
CW1,i

Probability-based Approach (PA):

Compute j that minimizes:
nφ
r=1 ∑τ
∑

c=1 |Zr,c −CIr,( j−1)×τ+c ×
CL1, j
CW1, j

Return

PIr,( j−1)×τ+c
CW1, j

|

as the estimated maliciousness level ξ (cid:48).

Deep learning-based Approach (DA):

Find the returned image of Convolution Neural Network (CCN) from

folders 1, · · · , (cid:96).

Return the label of returned image as the estimated maliciousness

24:

25:

26:

27:

28:

29:

level ξ (cid:48).
30: end for

consisting of a number of black or white pixels. This image
can be considered as a binary matrix that contains information
about (cid:96) clusters. If the element in position (φi, j) is equal to
1, it means that there is at least one malware with label ξ , as
eq. 2, that called feature φi at time τi = j − τ × (cid:98) j/τ(cid:99).

1
(cid:96)

× (cid:98)

j
τ

(cid:99) ≤ ξ <

(cid:18)
(cid:98)

×

j
τ

1
(cid:96)

(cid:19)

(cid:99) + 1

(2)

Figure 3 shows a clustering image of the data set used as
the train set for proposed clustering approach (CA), which
contains more than 80,000 malware for eight maliciousness
levels. In this ﬁgure, the white pixels represent 1, and the
black pixels represent 0. To detect malware, it is enough to
get a visual representation of it, comparison with the clusters
in the clustering image, and report the label of the nearest
cluster as a malware label. The proposed clustering approach
is summarized in algorithm 1.

B. Probabilistic Approach

In the previous section, the clustering approach through
clustering image was brieﬂy introduced for malware detec-
tion. The clustering image provides suitable information for

analysts. For example, at the bottom of Figure 3 there is a
black rectangle, which means that none of the features in
this rectangle are called in any of the malware, which can
be a useful point in identifying malware behaviours. For this
reason, this section proposes another method to improving
the performance of clustering image, called the probabilistic
image. This image is very similar to the clustering image and
can be represented by a nφ -by-τ × (cid:96) matrix PI with integer
elements. The element PIφi, j on the position (φi, j) indicates
that there were PIφi, j malware in the used database, labeled
by ξ , which called φi at time τi = j − τ × (cid:98) j/τ(cid:99). Algorithm 1
summarizes how to create PI, and calculate the malware labels.
Similar to the previous method, ξ satisﬁes eq. 2, and the
method called Probabilistic Approach (PA).

C. Deep Learning Approach

Although clustering and probabilistic methods can provide
valuable information to malware analysts, these methods do
not examine or link the different situations. For example,
consider a malware that uses feature φ1 after 1 second of
monitoring, and this malware is available in the used database
to train the malware detection system. Suppose again that the
same malware is present in the test dataset and uses φ1 after 2
seconds. In this case, the previous two methods verify CIφ1,2
and PIφ1,2 to assess the maliciousness level, while there is
no valuable information in such positions. In other words,
previous methods lose their effectiveness against dynamic
feature delays. To solve this problem, deep learning-based
methods seem to be a good solution. For example, pooling
techniques in Convolution Neural Networks (CNN) address
adjacent pixels. Therefore, this method converts the samples
to images with black and white pixels, stores them according
to their maliciousness levels in folders with labels 1, · · · , (cid:96),
and examines them by CNN. The details of three method are
integrated in algorithm 1.

D. Space & Time complexity

The proposed method stores several matrices and images,
the sum of their dimensions determines the space complexity.
The matrices stored in algorithm 1 are CI, PI, CW , CL and
Z, whose dimensions are nφ × τ × (cid:96), nφ × τ × (cid:96), (cid:96), (cid:96), and
nφ × τ, respectively. In addition, the algorithm stores NT R
images in different folders, each of which has dimensions
nφ × τ. Therefore, the space complexity of algorithm 1 is
2 × (cid:96) × (cid:0)nφ × τ + 1(cid:1) + (NT R + 1) × (cid:0)nφ × τ(cid:1).

Similarly, the time complexity of algorithm 1 can be calcu-
lated. The training part of the algorithm consists of two loops
in lines 6 and 12. So the time complexity of this part is equal
to NT E × SΞ, where SΞ is the size of Ξ. At the worst case, Ξ
includes nφ × τ elements. So, SΞ ≤ nφ × τ. In the test section,
there are two loops in lines 19 and 21, and the complexity
of lines 24, 26, and 28 is assigned to each approach. In line
24, the complexity for calculating i is nφ × τ × (cid:96), and in line
26, the complexity of calculating j is the same. Finally, the
time complexity of line 28 depends on the complexity of the
used deep learning method, which is assumed to be TCNN.

SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

5

Fig. 2: Architecture of proposed method.

Fig. 4: Histogram of maliciousness level.

important features. These features fall into the following four
categories:

1) Application Programming Interface (API) with 353 fea-
tures, which is dedicated to accessing the basic functions
of the operating system.

2) Directory with 4 features, which is dedicated to global

conﬁguration of operating system.

3) File System with 11 features, which is dedicated to

operating system’s data organization.

4) Miscellaneous with 118 features, to risk level indication

of an executable ﬁle.

The used dataset
is available on UCI Machine Learning
Repository [23]. Figure 4 shows the distribution of the ma-
liciousness level ξ . As this ﬁgure shows, there are more than
6K malware with 0.74 < ξ ≤ 0.76. Also,
the Cumulative
Distribution Function for ξ is depicted in 5, which shows
that 100 − 27.67 = 72.33% of the analysed malware is very
dangerous with ξ > 0.5. All simulations of this paper are
performed in MATLAB R2017a on a laptop with 2.2GHz i7-
3632QM CPU and 8GB RAM.

Fig. 3: Clustering image.

As a result, the total space complexity is as eq. 3, and eq. 4
represents the time complexity.

O (cid:0)max{(cid:96), NT R} × nφ × τ(cid:1)

(3)

O (cid:0)NT E × (cid:0)nφ × τ × (cid:96) + TCNN
The numerical value for these parameters is (cid:96) = 10, nφ = 482,
τ = 60, NT R = 86284, NT E = 21572, and NT E × TCNN ≈ 5318
seconds per epoch, where NT E × TCNN is required time for
training and testing the dataset using CNN.

(4)

(cid:1)(cid:1)

IV. EXPERIMENTAL EVALUATION

A. Simulation setup

B. Comparison of solutions

This section compares the proposed method with the state
of the art ones by a comprehensive database. The results
in this paper are obtained using the database introduced
in [22], which contains more than 100K malware. The malware
was obtained by analyzing millions of executable ﬁles by
52 antiviruses over a period of 4 years and extracting 486

In the previous section, three approaches to detect ma-
liciousness level of malware were suggested. This section
introduces two methods for comparison. In 2020, Taheri et al.
[24] proposed a similarity-based method for detecting malware
which is based on Hamming distance. They showed that the
static features used in malware are so similar to each other that

SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

6

Fig. 5: CDF of maliciousness level.

TABLE II: Test metrics for ith label.

Fig. 7: Confusion Matrix important regions for test metrics.

(cid:96)1

(cid:96)i

(cid:96)(cid:96)










λ1,1
...
λi,1
...
λ(cid:96),1
(cid:96)(cid:48)
1

· · ·
. . .
· · ·
. . .
· · ·

· · ·
. . .
· · ·
. . .
· · ·

λ1, j
...
λi, j
...
λ(cid:96), j
(cid:96)(cid:48)
j










λ1,(cid:96)
...
λi,(cid:96)
...
λ(cid:96),(cid:96)
(cid:96)(cid:48)
(cid:96)

Metric

Region-based Formula

Accuracy

Error Rate

Precision

Recall

F1-Score

R1+R4
R1+R2+R3+R4

R2+R3
R1+R2+R3+R4
R1
R1+R3
R1
R1+R4
2R1
2R1+R3+R4

∑(cid:96)

c=1 λr,c

c(cid:54)=i,c=1 λr,c

Confusion Matrix-based Formula
r(cid:54)=i,r=1 ∑(cid:96)
λi,i+∑(cid:96)
∑(cid:96)
r=1 ∑(cid:96)
j(cid:54)=i, j=1 λi, j +λ j,i
r=1 ∑(cid:96)
∑(cid:96)
c=1 λr,c
λi,i
λi,i+∑(cid:96)
c=1 λi,c
λi,i
r(cid:54)=i,r=1 ∑(cid:96)
2λi,i
r(cid:54)=i,r=1 ∑(cid:96)

c(cid:54)=i,c=1 λr,c

2λi,i+∑(cid:96)

λi,i+∑(cid:96)

c=1 λr,c

Fig. 6: Confusion Matrix. (cid:96)i= True label, and (cid:96)(cid:48)

j= Estimated label.

by examining the similarity of the samples with pre-identiﬁed
dataset samples, malware can be identiﬁed with an accuracy
of over 99%. This method has a better performance compared
to ﬁxed size clustering, automatic clustering, neural networks,
SVM, etc. For this reason, the method proposed in this paper
will be compared with First Nearest Neighbour (FNN) that has
the least complexity among the methods in [24]. This method
is easy to implement, and to calculate the maliciousness level
of a test sample, it is enough to calculate its distance from all
the members in the trainset. In other words, ξ (cid:48) = ξk, where
1 ≤ k ≤ NT R minimizes eq. 5. In this case, ξk is the label of
kth sample in the trainset with NT R elements. Z(cid:48) is the image
form of the test sample, and Zk is the the same for kth sample.

nφ
∑
i=1

τ
∑
j=1

|Z(cid:48)

i, j − Zk
i, j|

(5)

In 2021, Ritter and Urcid [25] published a very interesting
study on lattice algebra, which deals with the applications of
lattice algebra in image processing, pattern recognition, and
artiﬁcial intelligence. As a second method to compare with the
proposed method, Lattice-based Associated Memory (LAM)
is used, which has a stronger mathematical background and
much higher efﬁciency than other methods such as Hopﬁeld
Memory. This method integrates the trainset instances into an
nφ -by-τ image LAM as in eq. 6, and uses eq. 7 to estimate
the maliciousness level ξ (cid:48).

LAMi, j = max{ξk − Zk

i, j} : 1 ≤ k ≤ NT R.

ξ (cid:48) = min{Z(cid:48)

i, j + LAMi, j} : 1 ≤ i ≤ nφ , 1 ≤ j ≤ τ.

(6)

(7)

C. Test metrics

The most well-known evaluation criterion is mean cumula-
tive absolute error (MCAE), which is shown in eq. 8. This

criterion shows the average difference between the actual
maliciousness level and the estimated one.

∑n

i=1 |ξi − ξ (cid:48)
i |
n

(8)

In eq. 8, n represents the size of test set, ξi represents the
actual maliciousness level of ith test, and ξ (cid:48)
i represents the
estimated one.
The next section shows that the MCAE is not sufﬁcient to
demonstrate the performance of the proposed method, and
it is easy to suggest methods that have a low MCAE but
are not suitable for practical purposes and provide unreliable
results. For this reason, MCAE and Confusion Matrix are used
simultaneously in evaluating the proposed method. This matrix
displays valuable information about the performance of the
proposed method, the structure of which is shown in Figure 6.
In ith row and jth column of confusion matrix there is λi, j,
which means that in evaluation process there were λi, j samples
that had the true label (cid:96)i, while the proposed method estimates
label (cid:96)(cid:48)
j. In evaluating the proposed method, the maliciousness
levels are divided into 10 parts and if (i − 1)/10 ≤ ξi < i/10,
(cid:96)i = i is considered, where 1 ≤ i ≤ 10. The same thing is for
(cid:96)(cid:48)
j.
The performance evaluation criteria by the confusion matrix
are based on the four numbers shown in Figure 7. To calculate
these numbers for a target
the confusion matrix is
divided into four regions, represented by R1, R2, R3, and
R4, which show True Positive, True Negative, False Positive,
and False Negative, respectively. Using these values, different
test metric can be obtained that show the performance of the
proposed method well. Some of these metrics are summarized
in Table II. In addition to the metrics introduced in this section,
this section introduces two other metrics. A malware detection
method is called conservative when eq. 9 is established
is called a loose detector. In this
(R6 ≤ R5), otherwise it
case, R5/R6 is called conservativeness ratio. Finally, the total

label,

SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

7

Fig. 8: MCAE of clustering based approach.

Fig. 10: MCAE of similarity based approach.

Fig. 9: Confusion Matrix of clustering based approach.

Fig. 11: Confusion Matrix of similarity based approach.

accuracy of an algorithm can be expressed by eq. 10.
r=1 ∑(cid:96)
∑(cid:96)
r=1 ∑r−1
∑(cid:96)

c=r+1 λr,c
c=1 λr,c

R5
R6

≥ 1

=

R7
R5 + R6 + R7

=

i=1 λi,i

∑(cid:96)
r=1 ∑(cid:96)

c=1 λr,c

∑(cid:96)

(9)

(10)

In the next part, the methods introduced in this article are
evaluated using the metrics and their pros and cons are
examined.

D. Experimental results

In this section, the proposed methods are evaluated and the
dataset is divided into two parts. The ﬁrst one is for training
and the second, which constitutes 20% of the data, is used
to evaluate. The result of the ﬁrst experiment is summarized
in Figure 8, which deals with the MCAE of clustering-based
approach. This ﬁgure shows that in the ﬁrst 60 evaluation
samples,
the average error has an upward trend while it
gradually decreases so that after evaluating 400 samples, the
average error does not change much. The average error after
evaluating 21572 samples is 41.59%, which is a large error.

Figure 9 shows the Confusion Matrix of this experiment. As
this ﬁgure shows, R6’s weight is much more than R5, which
means that the clustering approach is a loose method. In this
case, the probability that the true maliciousness level be less
than the estimated one is 5/6=83.33%, and its total accuracy
is only 7.31%.

Figure 10 shows the evaluation results of the similarity-
based approach under the same conditions as before, while
the error trend is the opposite of the previous approach. The
average error trend in this ﬁgure is downward and eventually
tends to 26.36%, which improves the previous error by 37%.
Checking the Confusion Matrix gives a similar result. As

the weights of R5 is much more than
Figure 11 shows,
R6, meaning that the similarity approach is a conservative
approach and is more likely to identify low-risk malware as
high risk one. In other words, P(ξ (cid:48) ≥ ξ ) = 80.67%.

Examination of the Confusion Matrix of the previous two
experiments show a result that cannot be deduced from their
MCAE comparisons, as expressed by R5 and R6 regions.
Figure 11 shows another result that can be used to improve
the MCAE of the proposed methods. As Figure 11 shows,
the weights of columns 2 and 4 are zero, which means that
no ξ (cid:48) ∈ [0.1, 0.2) ∪ [0.3, 0.4) is estimated for similarity-based
approach. Similarly, the weight of 6th column is 4, and the
weight of 3rd, 5th, and 10th columns is one. These results show
that the variety of malware with maliciousness level ξ < 0.1
and 0.6 ≤ ξ < 0.9 is so great that there is always a sample
in them that bears the closest similarity to the samples being
evaluated. The total accuracy for similarity-based approach is
15.79%, which is so better in comparison to clustering one.

Figures 12 and 13 show the results of the probabilistic
approach evaluation. The general
trend of MCAE in this
approach is similar to the clustering method, while its Con-
fusion Matrix behavior follows the similarity-based method.
The average error of this method ﬂuctuates per 1000 evaluated

Fig. 12: MCAE of probability based approach.

SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

8

Fig. 13: Confusion Matrix of probability based approach.

Fig. 15: MCAE of deep learning based approach..

Fig. 14: MCAE of single level based approach.

samples, later it does not change signiﬁcantly, and eventually
converges to 17.6%, which has less error compared to the
previous two approaches. As Figure 13 shows, the Confusion
Matrix of this approach has a large number of zero columns,
which was also observed in the similarity-based one. In this
ﬁgure, there are only three non-zero columns C5, C8, and C9,
where C8 has more weight. This ﬁgure shows that with 97.67%
probability, the probabilistic approach identiﬁes all evaluated
malware as a malware with maliciousness level 0.7 ≤ ξ (cid:48) < 0.8.
The total accuracy of this method is 25.51%, which has a much
better performance compared to the previous two approaches.
The number of non-zero columns in the lattice-based Confu-
sion Matrix reaches its peak so that there is only one non-zero
column in this matrix, which means that the output of this
method with is always a constant maliciousness level c. By
analyzing eq. 6 and eq. 7, the constant output of this method
i, j, Zk
can be calculated. In the used database, Z(cid:48)
i, j ∈ {0, 1}
in eq. 7, LAMi, j
and 0 ≤ ξ < 1. Assume that
is a ﬁxed
number c. In this case, since Z(cid:48)
i, j ∈ {0, 1} and LAMi, j = c, so
ξ (cid:48) = min{0+c, 1+c} = c means that the output of this method
is always equal to c. In evaluating lattice-based approach, the
method returns c = 0.9828. Now the question is: If a particular
method, such as in lattice-based approach, always provides a
ﬁxed output c, is this output always the best possible output
that keeps the error to minimum?

Figure 14 shows the MCAE for 10000 ﬁxed maliciousness
levels. As this ﬁgure shows, for c = 0, the lattice-based method
is a loose approach that identiﬁes all dangerous malware as
harmless, the MCAE is over 60%, which is very high. As
c increases, the mean error decreases so that at 0.6613 ≤
c ≤ 0.6697 the mean error reaches the lowest possible value
of 17.1%. As shown in Figure 5, 72.33% of the evaluated
malware are high-risk, and to reduce the average error in the
presence of a constant maliciousness level, the samples should
be estimated at c > 0.5, as Figure 14 conﬁrms.

Fig. 16: Confusion Matrix of deep learning based approach.

The results of the last experiment are provided in Figures 15
and 16. As Figure 15 shows, in the ﬁrst 100 tests, the average
error has an upward trend, followed by a downward trend.
The downtrend eventually converges to an average error of
11.1%, which is better than all previous methods. Confusion
Matrix analysis in the deep learning method also indicates
the high accuracy of this method compared to other methods.
As Figure 16 shows, the weight of region R7 is higher than
other methods, which means that this method has the highest
total accuracy of 45.1%. All methods in this section have been
compared using different test metrics in Table III, except for
error rate which is equal to 1 - accuracy.

The bold values in Table III represent the best results for
each class, which are assigned to the estimated maliciousness
levels ξ (cid:48)’s, and ”-” represents the undeﬁned test metric. For
example, in the similarity-based method R1, R3 = 0, which
makes the precision at 0.1 ≤ ξ (cid:48) < 0.2 equal to (0 + 0)/0.
As discussed earlier, the presence of zero column Ci in the
Confusion Matrix of an algorithm indicates that this algorithm
is unable to generate output ξ (cid:48)
i , and this appears ”-” in the
precision column corresponding to the ith estimated label.

In Table III, a per class metric score is assigned to each
approach, which shows the number of best results obtained for
each metric test in different classes. For example, the accuracy
of the probabilistic approach with score 8 has the best value,
except for ξ (cid:48) ∈ [0.5, 0.6) ∪ [0.7, 0.8), which is in the best rank
compared to all other approaches. This score corresponds to
the number of bold values for each column. Note that the total
accuracy of this method is 25.51%, which is at the second
rank. The results show that except for the accuracy per class
metric, deep learning is in the best position for all test metrics.

SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

9

TABLE III: Accuracy, Precision, Recall, F1-Score, MCAE, Conservativeness Ratio, and Total Accuracy values for evaluated dataset (Acc=
accuracy; Pre= precision; Rec= recall; F1-S= F1-Score).

Clustering

Similarity-based

Evaluated Approach
Probabilistic

Lattice-based

Deep Learning

l
e
b
a
L

d
e
t
a
m

-
0
-
0

Maliciousness level Acc Pre Rec F1-S Acc Pre Rec F1-S Acc Pre Rec F1-S Acc Pre Rec F1-S Acc Pre Rec F1-S
0 0.974 0.495 0.013 0.026
0 0.903 0.345 0.015 0.028
0 0.954 0.33 0.008 0.016
0 0.902 0.4 0.037 0.068
0 0.904 0.416 0.029 0.055
0 0.851 0.377 0.059 0.102
0 0.819 0.457 0.105 0.170
0 0.796 0.508 0.147 0.228
0 0.834 0.488 0.11 0.18
0.063 0.036 1 0.07 0.964 0.492 0.013 0.025

0.974
0.518 0.046 0.044 0.044 0.855 0.04 0.006 0.01 0.974
0
0.974
0.974
0.864 0.047 0.007 0.012 0.974
0
0.954
0.954
0.871 0.056 0.006 0.011 0.954
0
0.921
0.921
0.858 0.077 0.007 0.012 0.921
0
0.91
0.81 0.038 0.005 0.009 0.91
0.91
0
0.874 0.435 0.004 0.008 0.875
0.839 0.112 0.006 0.012 0.874 0.75
0.824 0.238 0.006 0.011 0.752 0.153 0.024 0.042 0.835
0.835
0
0.758 0.464 0.016 0.03 0.754 0.317 0.006 0.012 0.263 0.246 0.912 0.388 0.76
0.841 0.533 0.009 0.018 0.362 0.176 0.36 0.236 0.847 0.742 0.013 0.026 0.84
0.964 0.4
1
0
0
2
0
1
1
26.36%
41.59%
3.3572
0.203
15.79%
7.31%

0.0 ≤ ξ (cid:48) < 0.1
0.1 ≤ ξ (cid:48) < 0.2
0.2 ≤ ξ (cid:48) < 0.3
0.3 ≤ ξ (cid:48) < 0.4
0.4 ≤ ξ (cid:48) < 0.5
0.5 ≤ ξ (cid:48) < 0.6
0.6 ≤ ξ (cid:48) < 0.7
0.7 ≤ ξ (cid:48) < 0.8
0.8 ≤ ξ (cid:48) < 0.9
0.9 ≤ ξ (cid:48) ≤ 1.0
Per class metric score
MCAE
Conservativeness Ratio
Total Accuracy

1

4

0

1
36.93%
∞
3.63%

6

7
6
11.1%
1.2814
45.1%

0
-
1
1
17.6%
3.012
25.51%

0
0
0
0
0
0
0
0
0

0.964
5

0.964
8

-
-
-
-
-
-
-
-
-

0
0
0
0
0

0
0
0
0
0

0
0
0
0
0

-
-
-
-
-

0
1

0
1

0
1

i
t
s
E

1

0

7

-

V. DISCUSSIONS

In the previous section, several methods for malware detec-
tion were analyzed, and the proposed method was compared
with similar ones. This section discusses other ideas.

In the previous section, the proposed solution was compared
with the similarity-based approach, presented in [24]. In this
comparison, the samples were ﬁrst converted into an image
and then the method was applied to the obtained images.
This approach is for detecting malware using static features,
while the proposed method is based on dynamic ones. For this
reason, instead of calculating the images using the proposed
method, a vector corresponding to the extracted features can be
used, and then the similarity-based method can be applied. In
this case, the features call times are removed and the resulting
vector contains the maliciousness level with the features shown
in eq. 11.

Xi = [ξ , φ1 : τ1, · · · , φn : τn] → [ξ , φ1, · · · , φn]

(11)

After this conversion,
the similarity-based method can be
applied to the calculated vector. Unfortunately, our implemen-
tation shows that this method suffers more errors than the
image-based method, and therefore was not described in detail
in the previous section.

is about

The next point

the clustering image shown in
Figure 3. As mentioned earlier, this image gives us a lot of
information about malware. For example, the black lines in
this image indicate that there are features in the dataset that
do not affect any of the clusters. Black columns, on the other
hand, indicate that there are times when no feature is called.
By removing these two black areas, the dimensions of the
images can be reduced. Our implementation shows that this
increases CNN 4 times faster. Unfortunately, this reduced the
accuracy of the deep learning method by 4%, which is why it
was not covered in detail in the previous section.

The next point is to analyze the results of the lattice-based
method. As stated in the previous section, the outputs of this
method are always c = 0.9828. The reader may be asked:
what this number is and why labels are always estimated
with this number? This number is the largest label in our
trainset. To prove this, suppose our dataset has nmax samples
with the largest maliciousness level c. The image form of the
ﬁrst instance can be represented as a binary Z1 matrix. Using

Fig. 17: Number of kernels in different clusters.

eq. 6 and eq. 7, we can deduce the result in eq. 12, which
shows that a large number of zero elements in Z1 increases
the probability of convergence to c.

Z1
i, j = 0 → LAMi, j = c

(12)

Now consider the second train instance Z2 with label c.
Among the situations in which Z1 contains 1, Z2 may be zero.
Similar to the previous case, Z2
i(cid:48), j(cid:48) = 0 makes LAMi(cid:48), j(cid:48) = c. This
continues until eq. 13 is established.

∃1 ≤ i ≤ nφ , 1 ≤ j ≤ τ, 1 ≤ k ≤ nmax

s.t Zk

i, j = 0

(13)

Note that the binary matrices are sparse with a large number
of zeros. For example, the size of Z1 corresponding to the
maliciousness level 0.9828 in our dataset is 482 × 60 = 28920,
while it has only 17 non-zero elements, meaning that at least
99.94% of LAM’s elements are c. Because c − 1 is a negative
number, the remaining 17 elements will probably converge
to the second largest number in the dataset, 0.9815. This
analysis shows that at best, the evaluated samples are com-
pared with a maximum of 18 maliciousness levels. Although
this observation reduces the performance of the lattice-based
method in detecting malware in this paper, it also has some
interesting applications, which are discussed in [25]. Again,
see the clustering image corresponding to the 8 clusters in
Figure 3. In this image, there are pixels that are common
in all clusters. These points will probably impose additional
overhead on the system. Our focus is on pixels that are
in only one cluster, which can lead to the emergence of
interesting ideas. These points are referred to as kernels in
lattice-based approach. Figure 17 shows the number of kernels
in each cluster. In the kernel-based method, instead of using all

SUBMITTED TO IEEE INTERNET OF THINGS JOURNAL, MARCH 2022

10

trainset samples, only the samples containing kernels can be
used, which increases the efﬁciency. Implementing this method
improves the accuracy of the lattice-based approach from
3.6% to 7.65% while still not being competitive with other
compared methods. Also, the conservativeness ratio of lattice-
based method was ∞, while in the kernel-based approach it
is 0.0178, meaning that the kernel-based approach is a loose
method that treats high-risk samples such as low-risk ones.

VI. CONCLUSION AND FUTURE DIRECTIONS

This paper introduced a method to detect online malware.
The proposed method monitored the behavior of malware for a
period of time, and extracts the dynamic called features during
this period in the form of a vector. Due to the fact that we do
not have much storage and processing space in IoT devices,
proposed method in this paper transformed the extracted vector
into a sparse binary image, and clustering, similarity-based,
probabilistic, lattise-based, and deep learning approaches are
introduced for the generated image dataset analysis. The
results showed that the mean error of the clustering method is
more than 40%, which puts this method in the worst rank, and
on the other hand, deep learning with an error of 11.1% is in
the best position. The evaluated methods were compared with
8 different metrics, among which the probabilistic method was
in the best position in terms of accuracy per class metric, and
deep learning with 45.1% accuracy in the remaining 7 metrics
surpassed others.

This paper provides valuable results for future research. For
example, we have shown that MCAE is not the only effective
parameter in the performance of methods, and if regions R1
and R3 in the Confusion Matrix of a target class are equal
to zero, there will be a zero column in this matrix that makes
precision metric calculation impossible. This result can be used
to suggest a multi objective optimization learning base method.
The results of this article can be used in other areas such as
label ﬂipping in adversarial machine learning. For example,
we showed that
the lattice-based approach always returns
the maximum maliciousness level c as output, for the used
dataset. In this case, changing label c(cid:48) < c will not change the
performance of this method. In addition, the conservativeness
ratio can be used to identify vulnerable methods against
adversarial targets. If this rate is too high, the probability of
identifying dangerous samples increases, while if the rate is
less than 1, this method returns smaller maliciousness levels as
output, and this can encourage adversaries to produce malware
with high maliciousness level.

REFERENCES

[1] S. K. J. Rizvi, W. Aslam, M. Shahzad, S. Saleem, and M. M.
Fraz, “Proud-mal: static analysis-based progressive framework for deep
unsupervised malware classiﬁcation of windows portable executable,”
Complex & Intelligent Systems, vol. 8, no. 1, pp. 673–685, 2022.
[2] H. Cai, N. Meng, B. Ryder, and D. Yao, “Droidcat: Effective android
malware detection and categorization via app-level proﬁling,” IEEE
Transactions on Information Forensics and Security, vol. 14, no. 6, pp.
1455–1470, 2018.

[3] D. W. Fernando and N. Komninos, “Fesa: Feature selection architecture
for ransomware detection under concept drift,” Computers & Security,
p. 102659, 2022.

[4] R. Fani and M. Saheb Zamani, “Runtime hardware trojan detection by
reconﬁgurable monitoring circuits,” The Journal of Supercomputing, pp.
1–27, 2022.

[5] A. Singh, P. Choudhary et al., “Keylogger detection and prevention,” in
Journal of Physics: Conference Series, vol. 2007, no. 1. IOP Publishing,
2021, p. 012005.

[6] J. Guo, A. Li, and C. Liu, “Backdoor detection in reinforcement

learning,” arXiv preprint arXiv:2202.03609, 2022.

[7] G. X. Cun, S. Wang, D. Guo, S. Guan, B. Liu, and B. Wu, “Design and
implementation of a high-speed real-time position detection system in
electromagnetic coil launcher,” IEEE Transactions on Plasma Science,
vol. 48, no. 9, pp. 3203–3210, 2020.

[8] I. Obaidat, M. Sridhar, K. M. Pham, and P. H. Phung, “Jadeite: A novel
image-behavior-based approach for java malware detection using deep
learning,” Computers & Security, vol. 113, p. 102547, 2022.

[9] A. P. Namanya, I. U. Awan, J. P. Disso, and M. Younas, “Similarity
hash based scoring of portable executable ﬁles for efﬁcient malware
detection in iot,” Future Generation Computer Systems, vol. 110, pp.
824–832, 2020.

[10] M. Cho, J.-S. Kim, J. Shin, and I. Shin, “Mal2d: 2d based deep learning
model for malware detection using black and white binary image,”
IEICE Transactions on Information and Systems, vol. 103, no. 4, pp.
896–900, 2020.

[11] G. Conti, E. Dean, M. Sinda, and B. Sangster, “Visual reverse engineer-
ing of binary and data ﬁles,” in International Workshop on Visualization
for Computer Security. Springer, 2008, pp. 1–17.

[12] Z. Cui, L. Du, P. Wang, X. Cai, and W. Zhang, “Malicious code detection
based on cnns and multi-objective algorithm,” Journal of Parallel and
Distributed Computing, vol. 129, pp. 50–58, 2019.

[13] F. Abdullayeva, “Malware detection in cloud computing using an image
visualization technique,” in 2019 IEEE 13th International Conference
on Application of Information and Communication Technologies (AICT).
IEEE, 2019, pp. 1–5.

[14] R. U. Khan, X. Zhang, and R. Kumar, “Analysis of resnet and googlenet
models for malware detection,” Journal of Computer Virology and
Hacking Techniques, vol. 15, no. 1, pp. 29–37, 2019.

[15] S. Yajamanam, V. R. S. Selvin, F. Di Troia, and M. Stamp, “Deep
learning versus gist descriptors for image-based malware classiﬁcation.”
in Icissp, 2018, pp. 553–561.

[16] L. Nataraj, S. Karthikeyan, G. Jacob, and B. S. Manjunath, “Malware
images: visualization and automatic classiﬁcation,” in Proceedings of the
8th international symposium on visualization for cyber security, 2011,
pp. 1–7.

[17] Q. Le, O. Boydell, B. Mac Namee, and M. Scanlon, “Deep learning at
the shallow end: Malware classiﬁcation for non-domain experts,” Digital
Investigation, vol. 26, pp. S118–S126, 2018.

[18] R. Ronen, M. Radu, C. Feuerstein, E. Yom-Tov, and M. Ah-
madi, “Microsoft malware classiﬁcation challenge,” arXiv preprint
arXiv:1802.10135, 2018.

[19] J. Fu, J. Xue, Y. Wang, Z. Liu, and C. Shan, “Malware visualization
for ﬁne-grained classiﬁcation,” IEEE Access, vol. 6, pp. 14 510–14 523,
2018.

[20] I. Baptista, “Binary visualisation for malware detection,” 2018.
[21] D.-L. Vu, T.-K. Nguyen, T. V. Nguyen, T. N. Nguyen, F. Massacci, and
P. H. Phung, “Hit4mal: Hybrid image transformation for malware classi-
ﬁcation,” Transactions on Emerging Telecommunications Technologies,
vol. 31, no. 11, p. e3789, 2020.

[22] N. A. Huynh, W. K. Ng, and K. Ariyapala, “A new adaptive learning
algorithm and its application to online malware detection,” in Interna-
tional Conference on Discovery Science. Springer, 2017, pp. 18–32.

[23] D. Dua and C. Graff, “UCI machine learning repository,” 2017.

[Online]. Available: http://archive.ics.uci.edu/ml

[24] R. Taheri, M. Ghahramani, R. Javidan, M. Shojafar, Z. Pooranian, and
M. Conti, “Similarity-based android malware detection using hamming
distance of static binary features,” Future Generation Computer Systems,
vol. 105, pp. 230–247, 2020.

[25] G. X. Ritter and G. Urcid, “Introduction to lattice algebra: With
applications in ai, pattern recognition, image analysis, and biomimetic
neural networks,” 2021.

