Secure Information Flow Typing in Lustre

Sanjiva Prasad, R. Madhukar Yerraguntla, Subodh Sharma

2
2
0
2

n
a
J

1

]
L
P
.
s
c
[

1
v
4
8
1
0
0
.
1
0
2
2
:
v
i
X
r
a

Abstract

Synchronous reactive data ﬂow is a paradigm that provides a high-level abstract programming model for em-
bedded and cyber-physical systems, including the locally synchronous components of IoT systems. Security
in such systems is severely compromised due to low-level programming, ill-deﬁned interfaces and inattention
to security classiﬁcation of data. By incorporating a Denning-style lattice-based secure information ﬂow
framework into a synchronous reactive data ﬂow language, we provide a framework in which correct-and-
secure-by-construction implementations for such systems may be speciﬁed and derived. In particular, we
propose an extension of the Lustre programming framework with a security type system. The novelty of
our type system lies in a symbolic formulation of constraints over security type variables, in particular the
treatment of node calls, which allows us to reason about secure ﬂow with respect to any security class lattice.
The main theorem is the soundness of our type system with respect to the co-inductive operational
semantics of Lustre, which we prove by showing that well-typed programs exhibit non-interference. Rather
than tackle the full language, we ﬁrst prove the non-interference result for a well-behaved sub-language called
“Normalised Lustre” (NLustre), for which our type system is far simpler. We then show that Bourke et
al.’s semantics-preserving “normalisation” transformations from Lustre to NLustre are security-preserving
as well. This preservation of security types by the normalisation transformations is a property akin to
“subject reduction” but at the level of compiler transformations. The main result that well-security-typed
Lustre programs are non-interfering follows from a reduction to our earlier result of non-interference for
NLustre via the semantics-preservation (of Bourke et al.) and type preservation results.

1. Introduction

Motivation. The impetus for this work was to address the problems of correctness and security in em-
bedded and cyber-physical systems, especially in the Internet of Things paradigm [34]. Several high-proﬁle
attacks such as those on CAN systems [31, 15], smart lighting [27], and pacemakers [21, 45] have exploited
vulnerabilities arising from lacunae such as (L1) ill-deﬁned interfaces and hidden attack surfaces; (L2) no
secure information ﬂow (SIF) architecture and weak security mechanisms; (L3) components operating with
greater privilege or more capability than necessary.

Our contention is that much of this unfortunate insecurity arises from low-level programming approaches
in these domains, which can be avoided by using a high-level programming paradigm. While Domain-Speciﬁc
Languages suggest a principled way to build more reliable systems, we contend that for the large subset
of locally synchronous systems there already is a quintessential solution – namely, reactive synchronous
data-ﬂow languages.

The merits to taking this view include: (M1) “Things”, embedded and cyber-physical systems, can be
treated abstractly as generators, consumers and transformers of (clocked) streams of data. Indeed, this ex-
tensional view supports not only abstract “things” but composite computations as ﬁrst-class entities. (M2)
The data ﬂow model makes explicit all interfaces, connections and data dependencies, and (clocked, named)
ﬂows – thus greatly reducing attack surfaces and unanticipated interactions. (M3) In synchronous reactive
data ﬂow languages, monitoring safety properties is easy and can be achieved using ﬁnite-state automata
[55, 29]. Not only can monitors be expressed within the model, but the same framework can be used to
specify axioms and assumptions, to constrain behaviour, and specify test cases. (M4) In particular, Lustre
[14, 28] is an eminently suitable synchronous reactive data ﬂow language, for which there already exist

Preprint submitted to Elsevier

January 4, 2022

 
 
 
 
 
 
elegant formal semantics and a suite of tools for (a) certiﬁed compilation from the high-level model into
lower-level imperative languages [7, 8], (b) model-checkers [53, 37] (c) simulation tools [35], etc. Indeed, the
simplicity of Lustre – with its underlying deterministic, clocked, structured model – makes it both attrac-
tive and versatile as a programming paradigm: It can express distributed embedded controllers, numerical
computations, and complex Scade 6 [19] safety-critical systems with its support for diﬀerence equations.
Moreover, the gamut of formal structures such as automata, regular expressions, temporal logic, test har-
nesses, synchronous observers, etc., can all be eﬃciently expressed within the Lustre model. The only
missing piece in this picture is a security model.

In this paper, we seek to integrate Denning’s lattice-based secure information ﬂow (SIF) framework [22]
into Lustre and propose a type system for SIF. In this type system, (i) each stream of data is assigned a
security type that is mapped to a security class from the security lattice, based on assumptions made about
security types of the program variables, and (ii) the output streams from a node have security levels at least
as high as the security levels of the input streams on which they depend. The rules are simple, intuitive
and amenable to incorporation into the mechanised certiﬁed compilation already developed for Lustre [13]
that integrates into the CompCert eﬀort [41].

Contributions.
The main contributions of this paper are: (C1) the proposal of a security type system
which ensures SIF in Lustre (section 3). The security types are as simple as possible, which makes possible
further reﬁnements. The main technical achievement lies in formulating appropriate type inference rules for
Lustre equations and node (function) calls. The security types and constraints are stated in a symbolic
style employing security type variables, thus abstracting the inference rules from any particular security
lattice. The type system is equipped with an equational theory, which is shown to be sound with respect to
any security class lattice. Based on the security typing rules, we propose a deﬁnition of security for Lustre
programs.

The main result in this paper (Theorem 12) is (C2) proving that our security type system is sound with
respect to the co-inductive Stream semantics for Lustre; we do so by establishing non-interference [26]
for well-typed programs. Rather than directly proving this result for the full language Lustre, we follow
an approach that is common in programming language semantics and compiler correctness: We ﬁrst prove
(C2a) the non-interference result (Theorem 8) for a well-behaved sub-language called “Normalised Lustre”
(NLustre) which has a simpler structure and from which subsequent compilation is easier. NLustre is
the language taken from [8] (though without the reset operator introduced there) and into which there
is a semantics-preserving translation from the full language [10]. We show that Bourke et al.’s semantics-
preserving “normalisation” transformations from Lustre to NLustre are (C2b) security-preserving as well
(Theorem 9). This preservation of security types by the normalisation transformations is a property akin to
“subject reduction” but at the level of compiler transformations. The main result that well-security-typed
Lustre programs are non-interfering (Theorem 12) follows from a reduction to our earlier result of non-
interference for NLustre (Theorem 8) via the semantics-preservation results of Bourke et al. [9, 10] and
our type preservation result (Theorem 9). Figure 1 situates the results within the framework of Lustre’s
compilation ﬂow.

A supplement, in the Appendices, is a consolidated (Coq-independent) speciﬁcation of Lustre’s stream

semantics, consistent with the Vélus formalisation [13].

Security type systems have so far been proposed for imperative [22, 23] and for functional
Novelty.
languages with imperative features [61, 32, 5]. We believe that ours is the ﬁrst presentation of a SIF
type system for a synchronous, reactive data-ﬂow language, together with its soundness with respect to the
operational semantics, While our approach to showing that securely-typed programs exhibit non-interference
broadly follows that of Volpano et al [61], we believe that the adaptation to a data-ﬂow setting is both novel
and inventive. In particular, instead of notions of conﬁnement checking used to specify security in imperative
paradigms, we generate and solve constraints for equations and programs. Thus we go beyond just checking
that a program is secure to inferring constraints that suﬃce to ensure security, abstracting the SIF analysis
from reasoning with respect to a ﬁxed security lattice.

2

Parsing

Untyped

Lustre

Elaboration

Lustre

Normalisation

NLustre

i-translation

STC

scheduling

s-translation

Printing

Assembly

Compilation

Clight

Generation

OBC

Compcert

Argument

Fusion

initialization

optimization

Figure 1: Lustre compilation ﬂow: This paper focuses on security in the phases in the blue dotted rectangle. q.v.
Fig 1 from [11]

Security type synthesis. Our treatment wherein security type constraints are accumulated over symbolic
variables allows us to synthesize suitable security types. It is noteworthy that the resulting type inference
system is divorced from a speciﬁc security lattice, but in fact can accommodate on-demand analysis of the
various modes under which a system may operate. Consider an example (abstracted from a circuit design
in which one of us was involved) where one has to implement one-time programmable SoC memory allowing
for a secret key to be written once on the memory. The design may operate in one of the many modes:

1. Write-mode where the secret-key is burned into the memory,
2. Lock-mode where one can only verify whether an input matches the etched secret key, and
3. Debug-mode where cyclic redundancy check (CRC) value is generated

There are various combinations of input and output security levels to the parameters (key, input, CRC),
some of which are secure and others insecure. For instance, once the memory is in Lock-mode, any access to
CRC value must have a suitably high privilege security level. If a user wishes to access the memory in Debug-
mode while the secret-key is at the root privilege level, then this exhibits a case of insecure combination of
security levels. By generating type constraints parametric in the types of the secret key, input, and CRC,
one can reason over diﬀerent scenarios without having to repeatedly analyse the program or to re-compute
the system of constraints. The same inferred constraints could be used to determine, e.g., whether or not
to escalate a user’s security in debug mode when the secret key has been already etched on the memory.

In section 2, we brieﬂy overview the language Lustre (§2.1), and present its
Structure of the paper.
syntax (§2.2) as well as that of its core sub-language NLustre. After a small example (§2.3), we highlight
the main features of its Stream semantics (§2.4; see also Appendix C for complete details). In section 3, after
recapitulating the notion of Denning’s lattice-based model for secure information ﬂow (SIF), we motivate the
need for SIF types, which are then presented with their equational theory in §3.1. The basic type inference
system is then presented in a syntax-oriented manner (§3.2). Based on these rules, we propose a deﬁnition of
security for Lustre programs. In §3.3, we provide a glimpse into our formalisation in Coq of the equational
theory of our SIF types. Soundness of the type system (for NLustre) follows in section 4, where we
show that securely-typed Lustre programs exhibit non-interference with respect to the Stream semantics
(Theorem 8). Bourke et al ’s translation from Lustre to NLustre [9, 10] in presented in section 5. The
main result here is the preservation of security types during this translation (Theorem 9). We illustrate this

3

result with an example (§5.2). The main result (Theorem 12) that well-typed Lustre programs exhibit
non-interference follows in section 6. The paper concludes with a discussion of the related work (section 7)
and directions for future work in section 8. Appendix C presents a consolidated speciﬁcation of the Stream
semantics of Lustre that is consistent with the Vélus/CompCert/Coq encoding on a github repository [13]
mentioned in [8]. Auxiliary deﬁnitions are presented in Appendix A and Appendix B.

This paper combines the results of [52], in which the type system for NLustre and its semantic soundness
were established, with the extension of the type system to the full Lustre language and the preservation
of types during normalisation which was presented in [51], and integrates them into a single self-contained
account. The motivations and discussions have been expanded, and fortiﬁed with worked-out examples.
Additional formalisation and proof details have been added, as well as directions for future work.

2. Lustre

2.1. A brief overview of Lustre

Lustre [28, 49, 8] is a synchronous data-ﬂow language used for modelling, simulating, and verifying
a wide range of reactive programs including embedded controllers, safety-critical systems, communication
protocols, railway signal networks, etc. In Lustre, a reactive system is represented as a data-ﬂow network
with clocked data streams ﬂowing between operators and nodes, i.e., a synchronous analogue to Kahn Process
networks [36].

The main characteristics of the language are:
1. Declarative Style: A Lustre program consists of a set of deﬁnitions of named nodes, each parame-
terised by tuples of clocked input and output ﬂows. Node deﬁnitions are unique, and may appear in
any order. Each node comprises a set of equations, which may be possibly mutually recursive provided
they are “well-clocked” [49, 28]. The order in which equations are written has no eﬀect on the seman-
tics of the program. Each equation in a node uniquely deﬁnes a local variable or an output ﬂow in
terms of ﬂow expressions. The ﬂow expressions mention only input, output or local variables (nodes
do not have free variables), and may involve node calls. Nodes cannot make recursive calls or have
cyclic dependencies; therefore, the dependency order on nodes forms a DAG. Equations thus exhibit
referential transparency, referred to as Lustre’s Substitution Principle.

2. Deterministic Behaviour: Program behaviours in Lustre are completely determined by sequences
of clocked occurrences of events. Lustre’s Deﬁnition Principle states that the context does not
determine the meaning of an expression.

3. Synchronous Semantics: Each variable and expression deﬁnes a data stream, indexed with respect to
a clock. A clock is a stream of Boolean values. A ﬂow takes its nth value on the nth clock tick, i.e.,
when the clock has value true. A clock is either a base clock or one derived from another clock when
a variable takes a speciﬁc (boolean) value (on x = k, where k ∈ {T, F}).

4. Temporal Operators when (sampling), merge (interpolation) and fby (delay) are used to express com-
plex clock-changing and clock-dependent behaviours. Following a static analysis to determine clock
dependencies, all expressions and equations can be annotated with a clock.

Lustre has a carefully designed system of static analyses including type checking, clock checking [49] and
cyclic dependency checks [28], the details of which are beyond the scope of this paper, which ensure the well-
formedness and bounded space execution of programs. Lustre has seen a steady development of its suite
of tools over three decades, commencing with its introduction [14] through to formally certiﬁed compiler
developments [7, 8].

2.2. Syntax of Lustre and NLustre

As is common in compilation, the full language Lustre can be translated into a core sub-language
NLustre [9], from which subsequent compilation is easier. The language NLustre considered in this paper
is the core language taken from [8, 1], but without the reset operator introduced there. Figure 2–Figure 4

4

e :=

| c

| x

| ⋄ e

|

| e ⊕ e
#»
e when x = k
#»
e
#»
e else

| if e then

| merge x

#»
e

#»
e

|

#»
e fby
#»
e )

| f (

eq :=

#»
x =

|

#»
e

(expr)

(cnst)

(var)

(unop)

(binop)

(whn)

(mrg)

(ite)

(fby)

#»
e

(ncall)
(equation)

(eq)

e :=

| c

| x

| ⋄ e

| e ⊕ e

| e when x = k

ce :=

| e

| merge x ce ce

| if e then ce else ce

eq :=

| x =ck ce
| x =ck c fby e

#»
x =ck f (

#»
e )

|

(expr’)

(cnst)

(var)

(unop)

(binop)

(whn’)
(cntrl expr)

(expr’)

(mrg’)

(ite’)
(equation)

(eq’)

(fby’)

(ncall’)

Figure 2: Lustre syntax

Figure 3: NLustre syntax

ck :=

| base
| ck on (x = k)

(clock)

(base)
(on)

d :=

(node declr)

#   »
xck) returns
#»
eq tel

#   »
yck

| node f (
#»
var
z let
#»
d

G :=

(program)

Figure 4: Common syntax of programs, nodes and clocks

present the syntax of Lustre and NLustre. (Notation: Lustre keywords are written in teletype face
and coloured in example listings; meta-variables are in italic face.)

Lustre expressions (Figure 2) include ﬂows described by constants, variables, unary and binary op-
erations on ﬂows, as well as the ﬂows obtained by sampling when a variable takes a particular boolean
value (when), interpolation based on a boolean variable ﬂow (merge), and conditional combinations of ﬂows
(if_then_else). Of particular interest are ﬂows involving guarded delays (fby) and node calls.

The syntax for clocks, node deﬁnitions and programs is given in Figure 4, while the syntax for expressions

and equations in NLustre is listed in Figure 3.

The main diﬀerences between Lustre and NLustre are (i) the former supports lists of ﬂows (written
#»
e ) for conciseness, whereas in the latter all ﬂows are single streams; (ii) NLustre requires that conditional
and merge “control” expressions are not nested below unary and binary operators or sampling; (iii) node
call and delayed ﬂows (fby) are treated as ﬁrst-class expressions, whereas in NLustre, they can appear
only in the context of equations; (iv) Lustre permits nested node calls, whereas nesting in disallowed in
NLustre; (v) ﬁnally, the ﬁrst argument of fby expressions in NLustre must be a constant, to enable a
well-deﬁned initialisation that can be easily implemented.

The translation from Lustre to NLustre [9, 10] involves distributing constructs over the individual
components of lists of expressions, and de-nesting expressions by introducing fresh local variables (See
section 5 for details).

5

-- a simple c o u n t e r node with a reset
node Ctr ( initα1 , incrα2 : int , rstα3 : bool )

r e t u r n s ( nβ : int );

var fstδ1 : bool , pre_n δ2 : int ;
let

n =baseγ if ( fstδ1 or rstα3 ) then initα1

else pre_n δ2 + incr α2 ;
=baseγ true⊥ fby false ⊥;

fst
pre_n =baseγ 0⊥ fby nβ ;

tel

Figure 5: Counter

2.3. Lustre Example

-- using the c o u n t e r node
node SpdMtr ( accα4 : int )

r e t u r n s ( spdβ1 , posβ2 : int );

let

spd =baseγ2 Ctr (0⊥ , accα4 , false ⊥ );
pos =baseγ2 Ctr (3⊥ , spdβ1 , false ⊥ );

tel

Figure 6: Speedometer

We present a small example of a Lustre program. (For the moment, let us ignore the blue superscript

security type annotations.)

Example 2.1 (Counter). Ctr, deﬁned in Figure 5, is a node which takes two integer stream parameters
init and incr and a boolean parameter rst, representing (respectively) an initial value, the increment and
a reset signal stream. The output is the integer stream n. Two local variables are declared:
the boolean
stream fst, which is true initially and false thereafter, and the integer stream pre_n, which latches onto the
previous value of n. The equation for n sets it to the value of init if either fst or rst is true, otherwise
adding incr to n’s previous value (pre_n). pre_n is initialised to 0, and thereafter (using fby) trails the
value of n by a clock instant. All equations here are on the same implicit “base” clock, and the calculations
may be considered as occurring synchronously.

An example run of Ctr is:

Flow

Values

init
incr
rst
fst
n
pre_n

‹1›
‹1›
‹F›
‹T›
‹1›
‹0›

‹2›
‹2›
‹F›
‹F›
‹3›
‹1›

‹1›
‹2›
‹F›
‹F›
‹5›
‹3›

‹1›
‹3›
‹F›
‹F›
‹8›
‹5›

‹0›
‹3›
‹T›
‹F›
‹0›
‹8›

‹2›
‹1›
‹F›
‹F›
‹1›
‹0›

‹4›
‹2›
‹T›
‹F›
‹4›
‹1›

. . .
. . .
. . .
. . .
. . .
. . .

Example 2.2 (Speedometer). In Figure 6, we next deﬁne another node, SpdMtr, using two instances of
node Ctr. spd is calculated by invoking Ctr with suitable initial value 0 and increment acc, while pos is
calculated with initial value 3 and increment spd. Again, both equations are on the same base clock, and the
calculations are synchronous. In the exaample code in Figure 6, the two instances of Ctr are never reset.

2.4. Stream Semantics of Lustre

The semantics of Lustre and NLustre programs are synchronous: Each variable and expression deﬁnes
a data stream which pulses with respect to a clock. A clock is a stream of booleans (CompCert/Coq’s [41, 20]
true and false in Vélus). A ﬂow takes its nth value on the nth clock tick, i.e., some value, written ‹v›, is
present at instants when the clock value is true, and none (written ‹›) when it is false. The temporal operators
when, merge and fby are used to express the complex clock-changing and clock-dependent behaviours of
sampling, interpolation and delay respectively.

Formally the stream semantics is deﬁned using predicates over the program graph G, a (co-inductive)
stream history (H∗ : Ident → value Stream) that associates value streams to variables, and a clock bs
[8, 52, 9]. Semantic operations on (lists of) streams are written in blue sans serif typeface. Streams are

6

written in red, with lists of streams usually written in bold face. All these stream operators, deﬁned co-
inductively, enforce the clocking regime, ensuring the presence of a value when the clock is true, and absence
when false. Appendix B contains a complete speciﬁcation of these auxiliary predicates.

The predicate G, H∗, bs ⊢ e ⇓e es relates an expression e to a list of streams, written es. A list consisting
of only a single stream es is explicitly denoted as [es]. The semantics of equations are expressed using the
#  »
eqi, which requires consistency between the assumed and deﬁned stream histories in
predicate G, H∗, bs ⊢
#  »
eqi. Finally, the semantics of a node named f in
H∗ for the program variables, induced by the equations
program G is given via a predicate G s
f that
maps the list of streams xs to the list of streams ys.

f (xs) u ys, which deﬁnes a stream history transformer

We discuss here only some constructs, especially those that are important to the normalisation trans-
formations. Appendix C presents a complete account of the stream semantics for Lustre and NLustre,
consistent with the Coq developments in [13].

b

b

Rule (LSvar) associates the expression consisting of a variable x to the stream given by H∗(x).

H∗(x) = xs
G, H∗, bs ⊢ x ⇓e [xs]

(LSvar)

∀i : G, H∗, bs ⊢ e0i ⇓e e0si

∀j : G, H∗, bs ⊢ ej ⇓e esj

#      »
e0si)) (♭(

#   »
esj)) = os

fbyL (♭(
#»
ej ⇓e os

#  »
e0i fby
d
A delay operation is implemented by e0 fby e. The rule (LSfby) is to be read as follows. Let each expression
e0i denote a list of streams e0si, and each expression ej denote a list of streams esj. The predicate
fbyL
maps the predicate fbyL to act on the corresponding components of lists of streams, i.e.,

G, H∗, bs ⊢

(LSfby)

fbyL xs ys = zs abbreviates

fbyL xsi ysi = zsi

d

d

[when, \merge, and

ite.) The operation ♭(_) ﬂattens a list of lists (of possibly
(Similarly for the predicates
diﬀerent lengths) into a single list. Flattening is required since expression ei may in general denote a list
of streams esi. The output list of streams os consists of streams whose ﬁrst elements are taken from each
stream in ♭(

#      »
e0si) with the rest taken from the corresponding component of ♭(

c

^i∈[1,m]

∀i ∈ [1, .., k] G, H∗, bs ⊢ ei ⇓e esi
G, H∗, bs ⊢

[H∗(x1), . . . , H∗(xn)] = ♭(
#»
xj =

#»
ei

(LSeq)

#   »
esj).
#  »
esi)

The rule (LSeq) for equations checks the consistency between the assumed meanings for the deﬁned variables
#  »
esi) to which
xj according to the history H∗ with the corresponding components of the tuple of streams ♭(
a tuple of right-hand side expressions evaluates.

#»
x ; var =

#»
z ;

name = f; in =
out =

#»
y ; eqs =

#»
eq

(
H∗(f.out) = ys base-of xs = bs ∀eq ∈

)

G s

f (xs) u ys

∈ G H∗(f.in) = xs

#»
eq : G, H∗, bs ⊢ eq

(LSndef)

The rule (LSndef) presents the meaning given to the deﬁnition of a node named f ∈ G as a stream list
transformer. If history H∗ assigns lists of streams to the input and output variables for a node in a manner
f transforms
such that the semantics of the equations
input stream list xs to output stream list ys. The operation base-of ﬁnds an appropriate base clock with
respect to which a given list of value streams pulse.

#»
eq in the node are satisﬁed, then the semantic function

b

b

G, H∗, bs ⊢

#»
e ⇓e es G s

f (es) u os

G, H∗, bs ⊢ f (

#»
e ) ⇓e os
b

7

(LSncall)

H∗, bs ⊢ e :: ck ⇓e [vs]

fbyN L c vs = H∗(x)

G, H∗, bs ⊢ x =ck c fby e

(NSfby’)

name = f; in =
out =

#»
y ; eqs =

#»
eq

#»
x ; var =

#»
z ;

)

(

respects-clock H∗ bs H∗(f.out) = ys
f (xs) u ys

G s

H∗, bs ⊢

#»
e ⇓e es

b
H∗, bs ⊢ ck ⇓ck base-of es
#»
e )

#»
x =ck f (

G, H∗, bs ⊢

∈ G H∗(f.in) = xs base-of xs = bs

∀eq ∈

#»
eq : G, H∗, bs ⊢ eq

(NSndef’)

G s

f (es) u

#            »
H∗(xi)

(NSncall’)

b

Figure 7: Stream semantics of NLustre nodes and equations

The rule (LSncall) applies the stream transformer semantic function
list es corresponding to the tuple of arguments

#»
e , and returns the stream list os.

f deﬁned in rule (LSndef) to the stream

Stream semantics for NLustre. The semantic relations for NLustre are either identical to (as in con-
stants, variables, unary and binary operations) or else the singleton cases of the rules for Lustre (as in
merge, ite, when). The main diﬀerences lie in the occurrences of fby (now in a restricted form) and node
call, which can only be in the context of (clock-annotated) equations.

b

The (NSfby’) rule for fby in an equational context uses the semantic operation fbyN L, which diﬀers from
fbyL in that it requires its ﬁrst argument to be a constant rather than a stream. The (NSndef’) rule only
diﬀers from (LSndef) in that after clock alignment during transcription, we make explicit the requirement of
H∗ being in accordance with the base clock bs, enforced by respects-clock. Finally, the rule rule (NSncall’)
for node call, now in an equational context, is similar to (LSncall) combined with (LSeq), with the condition
that the base clock of the input ﬂows annotates the equation.

We end this section with a result that states that only those variables that appear in an expression are
relevant to its behaviour. Since the treatment of Lustre expressions and clocks have much in common, as
also with “control expressions” in NLustre, for convenience we sometimes speak of “general expressions”,
written ge, and use the generic predicate H∗, bs ⊢ ge ⇓? vs.

Lemma 1 (Relevant variables for expression evaluation). If f v(ge) ⊆ X and for all x ∈ X : H∗(x) =
H ′

∗(x), then G, H∗, bs ⊢ ge ⇓? vs iﬀ G, H ′

∗, bs ⊢ ge ⇓? vs.

Proof sketch. By induction on the structure of ge.

(cid:3)

3. A Security Type System for Lustre

Security class lattice. Denning proposed lattices as the appropriate mathematical model for reasoning about
secure information ﬂow [22, 23]. An information ﬂow model hN, SC, ⊑, ⊔, ⊥i consists of a set N of all data
variables/objects in the system, which are assigned security classes (typically t, possibly with subscripts)
from SC, which is a (usually ﬁnite) lattice, partially ordered by the relation ⊑, and with ⊔ being the least
upper-bound (LUB) operator and ⊥ the least element of the lattice. The intuitive reading of t1 ⊑ t2 is that
the security class t1 is less secure (i.e., less conﬁdential, or dually, more trusted) than t2, and so a ﬂow from
t1 to t2 is permitted.

Information ﬂow leaks. Suppose we decorated variables in a Lustre program with security levels drawn
from a Denning-style lattice. We give two simple instances of insecure expressions which can leak information
implicitly. The conditional expression if e0 then e1 else e2 which, depending on whether e0 is true or
false, evaluates expression e1 or else e2 (all expressions are on the same clock), can leak the value of the

8

Types: α, β, γ, θ ::= ⊥ | δ ∈ STV | α ⊔ β | α{|ρ|} Constraints: ρ ::= (θ ⊑ α)∗

(α ⊔ β) ⊔ θ = α ⊔ (β ⊔ θ), α ⊔ α = α, α ⊔ β = β ⊔ α, α ⊔ ⊥ = α = ⊥ ⊔ α,

α{||} = α,

α1{|ρ1|} ⊔ α2{|ρ2|} = (α1 ⊔ α2){|ρ1 ∪ ρ2|},

α{|ρ1|}{|ρ2|} = α{|ρ1 ∪ ρ2|},

#»
αi{|ρ|} =

#           »
αi{|ρ|},

{α{|ρ1|} ⊑ β{|ρ2|}} = {α⊑β} ∪ ρ1 ∪ ρ2,

# »
αj[θi/δi] =

#                 »
αj[θi/δi] ,

α{|ρ|}[θi/δi] = α[θi/δi]{|ρ[θi/δi]|},

(α⊑β)[θi/δi] = α[θi/δi] ⊑ β[θi/δi] .

Figure 8: Security types, constraints and their properties

e0. Consider the following example, where by observing the public ﬂow named c, we can learn the secret
variable b:

-- b secret , c public

c = if b then 1 else 0

Similarly, the expression merge x e1 e2 – which merges, based on the value of x at each instant, the
corresponding value from streams e1 or e2 into a single stream – also can leak the variable x’s values. This
is evident in the following:

-- x secret , c0 public

c0 = merge x 1 0

Our type system aims at preventing such implicit ﬂows. Further, it should be able to correctly combine
the security levels of the arguments for all operators, and allow only legal ﬂows in equational deﬁnitions of
variables, node deﬁnitions and node calls.

3.1. Security Types

We deﬁne a secure information ﬂow type system, where under security-level type assumptions for program
variables, Lustre expressions are given a symbolic security type (ST ), and Lustre equations induce a set
of ordering constraints over security types.

Syntax. Security type expressions (α, β) for Lustre are either (i) type variables (written δ) drawn from
a set STV, or (ii) of the form α ⊔ β where ⊔ is interpreted as an associative, commutative and idempotent
operation. (iii) The identity element of ⊔ is ⊥. While this idempotent abelian monoid structure suﬃces for
NLustre, node calls in Lustre require (iv) reﬁnement types α{|ρ|}, where type expression α is subject to
a symbolic constraint ρ. Constraints on security types, typically ρ, are (conjunctions of) relations of the
form α⊑β. The comparison ⊑ is deﬁned in terms of the equational theory: α⊑β exactly when α ⊔ β = β.
Our proposed security types and their equational theory are presented in Figure 8. The security types for
NLustre and their equational theory [52] are highlighted in grey within the diagram. This congruence on
NLustre types (henceforth ≡N L), which is given in the highlighted second line of Figure 8, is signiﬁcantly
simpler since it does not involve reﬁnement types! (Notation: Security types and constraints are written in
blue. In program listings, we will write them as superscripts.)

We write α[θi/δi] for i = 1, . . . , k to denote the (simultaneous) substitution of security types θi for
#»
α[θi/δi]) and

security type variables δi in security type α. The notation extends to substitutions on tuples (
constraints ((α⊑β)[θi/δi]).

Semantics. Security types are interpreted with respect to a complete lattice hSC, ⊑, ⊔, ⊥i of security
levels [22]. Given a ground instantiation s : STV → SC, security type expressions and tuples are interpreted
#        »
according to its homomorphic extension: s(⊥) = ⊥, s(α ⊔ β) = s(α)⊔s(β), s(
s(αi), and constraints are
interpreted according to the lattice ordering: s(α⊑β) = s(α) ⊑ s(β). The “reﬁnement types” are interpreted
as: s(α{|ρ|}) = s(α) if s(ρ) holds wrt SC, i.e., if “s satisﬁes ρ”, else is undeﬁned.

#»
α) =

9

Γ(base) = γ

ck
⊢base : γ

Γ

(LTbase)

ck
⊢ck : γ2

Γ(x) = γ1 Γ
ck
⊢ck on x = k : γ1 ⊔ γ2

Γ

(LTon)

Figure 9: Lustre security typing rules for clocks

Lemma 2 (Soundness). The equational theory induced by the equalities in Figure 8 is sound with respect
to any ground instantiation s, i.e., (i) α = β implies s(α) = s(β), and (ii) ρ1 = ρ2 implies s(ρ1) is satisﬁed
iﬀ s(ρ2) is.

Proof sketch. Most of the properties follow from s being a homomorphism, and the bijection between
idempotent abelian monoids and join semi-lattices (the monoid operation maps to LUB in the lattice). (cid:3)
The following facts are useful since we often want to reason about equality of security types or about

constraints independently of any given security lattice.

Lemma 3 (Conﬂuence). All equations other than those of associativity and commutativity (AC) can be
oriented (left-to-right) into rewriting rules. The rewriting system is conﬂuent modulo AC. Equal types
(respectively, equal constraints) can be rewritten to a common form modulo AC.

Proof sketch. The equational theory ≡N L trivially yields a convergent rewriting system modulo AC.
The rules in lines 3 and 4 of Figure 8 can all be oriented left to right. We use Knuth-Bendix-completion [38]
to introduce rules α1{|ρ1|} ⊔ α2 −→ (α1 ⊔ α2){|ρ1|}, when α2 is not a reﬁnement type. Type equality and
(cid:3).
constraints are eﬃciently decided using the theory of strongly coherent rewriting modulo AC [60].

3.2. Security Typing Rules

Assume typing environment Γ : Ident ⇀ ST, a partial function associating a security type to each free
variable x in a Lustre program phrase. Expressions and clocks are type-checked using the predicates:

e
⊢e :

#»
α and Γ

ck
⊢ck : α respectively. These are read as “under the context Γ mapping variables to security
Γ
#»
types, e and ck have security types
α and α”. Since the predicates for expressions and clocks (and in
NLustre, “control expressions” too) have much in common, for convenience we use a generalized predicate

?
⊢ge : α to represent a parametric analysis over the appropriate syntactic structure ge (this notation is used

Γ
in stating results of subsection 4.2).

The types for tupled expressions are (ﬂattened) tuples of the types of the component expressions. For

eqn
⊢ eq :> ρ, which states that under the context Γ, equation eq when
equations, we use the predicate: Γ
type-elaborated generates constraints ρ. Elementary constraints for equations are of the form α ⊑ β, where
β is the security type of the deﬁned variable, and α the security type obtained from that of the deﬁning
expression joined with the clock’s security type. Since every ﬂow in Lustre is deﬁned exactly once, by the
Deﬁnition Principle, no further security constraints apply.

The security typing rules for Lustre are presented in Figures 9 – 11, plus the rules for node deﬁnition
and node call. These rules generalise those in [52] to handle expressions representing lists of ﬂows, and
nested node calls. The rules for NLustre expressions other than node call and fby are just the singleton
cases. Node call and fby are handled by the rule for equations.

In (LTbase), we assume Γ maps the base clock base to some security variable (γ by convention). In
(LTon), the security type of the derived clock is the join of the security types of the clock ck and that of the
variable x.

Constants have security type ⊥, irrespective of the context (rule (LTcnst)). For variables, in rule (LTvar),
we look up their security type in the context Γ. Unary operations preserve the type of their arguments (rule
(LTunop)). Binary (⊕,when and fby) and ternary (if-then-else and merge) operations on ﬂows generate
a ﬂow with a security type that is the join of the types of the operand ﬂows (rules (LTbinop), (LTwhn),

10

Γ

e
⊢e2 : α2

e
⊢e1 : α1 Γ
e
⊢e1 ⊕ e2 : α1 ⊔ α2

Γ

(LTbinop)

Γ(x) = α

e
⊢x : α

Γ

(LTvar)

e
θ = Γ(x) Γ
⊢
e
#»
⊢merge x
et

Γ

(LTunop)

#»
β

e
⊢e : α
Γ
e
⊢⋄ e : α
e
#»
#»
α Γ
⊢
ef :
#                             »
(θ ⊔ αi ⊔ βi)i
#»
et :

Γ
#»
et :
#»
ef :
e
⊢e : θ Γ
#»
et else

e
⊢

Γ

ce
⊢if e then

Γ

(LTmrg)

(LTcnst)

e
⊢c : ⊥

Γ

e
⊢

#»
α Γ
#»
ef :

#»
β

#»
ef :
#                             »
(θ ⊔ αi ⊔ βi)i

(LTite)

#»
e0 :

e
Γ
⊢
e
#»
e0 fbyl
⊢

#»
α Γ
#»
e :

Γ

#»
e :

#»
e
β
⊢
#                   »
(αi ⊔ βi)i

Γ

(LTfby)

e
⊢e1 : α1 . . . Γ
#»
e when x = k :

e
⊢

Γ

e
⊢en : αn Γ(x) = γ

#                 »
(αi ⊔ γ)i

(LTwh)

Figure 10: Lustre Security Typing Rules for Expressions

#»
β = Γ(
eqn
#»
x ck =
⊢

#»
e :

#»
α Γ

#»
x ) Γ
#»
e :> {(γ ⊔ αi ⊑ βi)i}

ck
⊢ck : γ

e
⊢

Γ

(LTeq)

eqn
⊢ eq :> ρ Γ

eqn
⊢ eqs :> ρ′

Γ

eqn
⊢ eq; eqs :> ρ ∪ ρ′

Γ

(LTeqs)

Figure 11: Lustre security typing rules for equations

(LTmrg), (LTite), and (LTfby). In operations on lists of ﬂows, the security types are computed component-
wise. There is an implicit dependency on the security level of the common clock of the operand ﬂows for
these operators. This dependence on the security level of the clock is made explicit in the rule for equations.
In general, the security type for any constructed expression is the join of those of its components (and of
the clock).

Example 3.1 (Constraints from equations). With respect to Example 2.1, the constraints generated for
the deﬁnitions of variables n, fst and pre_n are the following:
ρ1 := {γ ⊔ δ1 ⊔ α3 ⊔ α1 ⊔ δ2 ⊔ α2 ⊑ β},
ρ2 := {γ ⊔ ⊥ ⊔ ⊥ ⊑ δ1}, i.e., {γ ⊑ δ1}, and
ρ3 := {γ ⊔ ⊥ ⊔ β ⊑ δ2}, i.e., {γ ⊔ β ⊑ δ2} respectively.

Node call. Node calls assume that we have a security signature for the node deﬁnition (described below).
We can then securely type node calls by instantiating the security signature with the types of the actual
arguments (and that of the base clock). Note that the rule (LTncall) creates reﬁnement types consisting
of the output types βi constrained by ρ′, i.e., the instantiated set of constraints ρ taken from the node
signature:

N ode

⊢ Node f (

#»
α )γ ρ
−→

#»
β Γ

#»
e :

e
⊢
e
⊢f (

#»
α′ Γ(base) = γ′ ρ′ = ρ[γ′/γ][
#»
e ) :

#»
β {|ρ′|}

#»
α′/

#»
α]

(LTncall)

Γ

Node deﬁnition. A node deﬁnition is given a signature
saying that the node named f relates the security types
clock) to the types of the output variables

#»
β , via the constraints ρ.
Let α1, . . . , αn, δ1, . . . δk, β1, . . . βm, γ be distinct fresh type variables. Assume these to be the types of the
input, local and output variables, and that of the base clock. We compute the constraints over these variables
induced by the node’s equations. Finally, we eliminate, via substitution using procedure simplify, the type

#»
β , which is to be read as
#»
α of the input variables (and γ, that of the base

⊢ Node f (

#»
α )γ ρ
−→

N ode

11

#»
α , ρ) = simplify (

#»
α, ρ) [ ]

(

#»
α′, ρ′) = simplify (
(
#»
α , ρ ∪ {ν ⊑ δ}) (δ ::

#»
α′, ρ′) = simplify (
(

#»
α [ν/δ], ρ[ν/δ])

#»
δ

δ not in ν

#»
δ )

#»
α′, ρ′) = simplify (
(

#»
α[ν/δ], ρ[ν/δ])

#»
δ

#»
α′, ρ′) = simplify (
(

#»
α , ρ ∪ {ν ⊔ δ ⊑ δ}) (δ ::

#»
δ )

δ not in ν

Figure 12: Eliminating local variables’ security type constraints

variables δi given to the local program variables, since these should not appear in the node’s interface. The
security signature of a node deﬁnition is thus given as:

G(f ) = n : {in =
#»
α,

#»
x 7→

ΓF := {

#»
y , var =

#»
x , out =
#»
β , base 7→ γ}

#»
y 7→
#»
eq :> ρ′ (_, ρ) = simplify (_, ρ′)

ΓL := {

#»
z , eqn =
#»
z 7→

#»
eq}
#»
δ }
#»
δ

ΓF ∪ ΓL

eqn
⊢
N ode

⊢ Node f (

#»
α )γ ρ
−→

#»
β

(LTndef)

The node signature (and call) rules can be formulated in this step-wise and modular manner since Lustre
does not allow recursive node calls and cyclic dependencies. Further, all variables in a node deﬁnition are
explicitly accounted for as input and output parameters or local variables, so no extra contextual information
is required.

Observe that in the (LTndef) rule, δi are fresh security type variables assigned to the local variables. Since
there will be exactly one deﬁning equation for any local variable zi, note that in constraints ρ′, there will be
exactly one constraint in which δi is on the right, and this is of the form νi⊑δi. Procedure simplify (Figure
12) serially (in some arbitrary but ﬁxed order for the δi) eliminates such type variables via substitution
in the types and type constraints. Our deﬁnition of simplify here generalises that given for the types of
NLustre in [52].

For Example 3.1, simplify (_, ρ1 ∪ ρ2 ∪ ρ3) [δ1; δ2] yields ρ = {γ ⊔ α1 ⊔ α2 ⊔ α3 ⊑ β}. Thus the node

signature for Ctr is

N ode

⊢ Node Ctr (α1, α2, α3)γ ρ

−→ β

For Example 2.2, the constraints generated for the equations deﬁning spd and pos are
ρ4 := {γ1 ⊔ ⊥ ⊔ α4 ⊔ ⊥ ⊑ β1}, i.e., {γ1 ⊔ α4 ⊑ β1}, and
ρ5 := {γ1 ⊔ ⊥ ⊔ β1 ⊔ ⊥ ⊑ β2} i.e., {γ1 ⊔ β1 ⊑ β2} respectively.
ρ4∪ρ5 simpliﬁes to {γ1 ⊔ α4 ⊑ β1, γ1 ⊔ β1 ⊑ β2}. Since γ1 ⊑ β1, the latter constraint is equivalent to β1 ⊑ β2.

#»
Lemma 4 (Correctness of simplify (
δ ). Let ρ be a set of constraints such that for a security type
variable δ, there is at most one constraint of the form µ ⊑ δ. Let s be a ground instantiation of security type
variables wrt a security class lattice SC such that ρ is satisﬁed by s.

#»
α , ρ)

1. If ρ = ρ1 ∪ {ν ⊑ δ}, where variable δ is not in ν, then ρ1[ν/δ] is satisﬁed by s. (Assume disjoint

union.)

2. If ρ = ρ1 ∪ {ν ⊔ δ ⊑ δ}, where variable δ is not in ν, then ρ1[ν/δ] is satisﬁed by s. (Assume disjoint

union.)

Proof sketch. Note that ρ1 is satisﬁed by s, and that δ appears to the right of ⊑ in only one constraint.
Suppose β1⊑β2 is a constraint in ρ1, with variable δ appearing in β1. Since FM |= s(ν) ⊑ s(δ), by transitivity
(cid:3)
and monotonicity of s with respect to ⊔: s(β1[ν/δ]) ⊑ s(β1) ⊑ s(β2).

12

3.3. Mechanisation in Coq

We are mechanising our proofs using the proof assistant Coq, and integrating our SIF type system into
the Vélus veriﬁed compiler framework [13]. We provide here some snippets related to the formalisation of
our type system, focusing here only on parts that can be presented without having to invoke details from
the Vélus development.

Inductive nonCanonST : Type :=
| Bot : nonCanonST
| Var : ident → nonCanonST
| Lub : nonCanonST → nonCanonST → nonCanonST
| Ref : nonCanonST → uConstraint → nonCanonST
with uConstraint: Type :=
| CNil : uConstraint
| Cns : (nonCanonST ∗ nonCanonST) → uConstraint → uConstraint.

(*Canonical types*)
Definition ST := list ident.
Definition constraint := (ST∗ST)%type.

The syntax of security types are represented as an inductive data type nonCanonST, and constraints
(type uConstraint) essentially as a list of security type pairs. We represent the canonical types as lists of
ident (where identiﬁers are given some ﬁxed order, e.g., lexical), and a (canonical) constraint as a list of
canonical type pairs. A routine canon (not shown here) turns the original type syntax into a canonical form
using the left-right oriented forms of ≡L rewrite rules.

(*Equational Theory*)
Inductive EqL : nonCanonST → nonCanonST → Prop :=
| refl_case: ∀ α , α ≡L α
| lub_assoc: ∀ α β θ , (Lub (Lub α β ) θ ) ≡L(Lub α (Lub β θ ))
| lub_idem : ∀ α , (Lub α α ) ≡L α
| lub_comm : ∀ α1 α2, (Lub α1 α2) ≡L (Lub α2 α1)
| lub_id : ∀ α , (Lub α \Bot) ≡L α
| ref_base : ∀ α , (Ref α CNil) ≡Lα
| ref_lub : ∀ α1 α2 ρ1 ρ2,

(Lub (Ref α1 ρ1) (Ref α2 ρ2)) ≡L (Ref (Lub α1 α2) (ρ1 ∪ ρ2))
| ref_ref : ∀ α ρ1 ρ2, (Ref (Ref α ρ1) ρ2) ≡L (Ref α ( ρ1 ∪ ρ2))
(*Knuth Bendix completion rules*)
| ref_lub_assocl: ∀ α1 α2 ρ ,

(Lub α1 (Ref α2 ρ ) ) ≡L (Ref (Lub α1 α2) ρ )

| ref_lub_assocr: ∀ α1 α2 ρ ,

(Lub (Ref α1 ρ ) α2) ≡L (Ref (Lub α1 α2) ρ )

where (a ≡L b) = (EqL a b)(at level 40, left associativity).

(*Homomorphic extension of mapping ’s’ to canonical types*)

Fixpoint hm_ext (s: ident → Lat.t ) (xs: ST): Lat.t :=

match xs with
| nil ⇒ Lat.bottom
| x:: xs’ ⇒ Lat.join (s x) (hm_ext s xs’)
end.

Lemma Soundness_EqL1: ∀ α1 α2, α1 ≡L α2 → ∀ s, hm_ext s α1 = hm_ext s α2.

(* ≡LC and canon_cons are the equality and rewrite routine (canon) extended to constraints *)
Lemma Soundness_EqL2: ∀ ρ1 ρ2, ρ1 ≡LC ρ2 →

13

canon_cons ρ1 = ρ′
canon_cons ρ2 = ρ′
∀ s, listSatisfiable s ρ′

1 →
2 →

1 ↔ listSatisfiable s ρ′
2.

Lemma Confluence_EqL: ∀ α1 α2, α1 ≡L α2 → canon α1 = canon α2.

The function hm_ext is the homomorphic extension (to canonical types) of the mapping s from ident to
lattice elements Lat.t. It is straightforward to state and prove the soundness of equational theory and the
conﬂuence of the rewrite system (Lemmas 2 and 3.

(*subAll is the substitution routine: subAll cns δ st ≡ cns[st\{δ } / δ ].*)
(*subAll eliminates δ from both cns and st during substitution.*)

(*findST returns a constraint with RHS as the singleton [δ ] from the list cns.*)

Inductive simplifyRel : list constraint → list ident → list constraint → Prop :=
| baseCase : ∀ cns,

simplifyRel cns [ ] cns

| elimCase1 : ∀ cns δ st cns’ ds cns’’,

simplifyRel cns’ ds cns’’ →
findST cns δ = Some st →
subAll cns δ st = cns’ →
simplifyRel cns (δ ::ds) cns’’

| elimCase2 : ∀ cns δ cns’ ds,

findST cns δ = None →
simplifyRel cns ds cns’ →
simplifyRel cns (δ ::ds) cns’.

(*Specification of simplify is correct*)
Theorem simplifyRel_is_correct :
∀ (s: ident → Lat.t) cns cns’ δs,

listSatisfiable s cns → simplifyRel cns δs cns’ → listSatisfiable s cns’.

By suitable deﬁnitions of substitution, and function to pick a constraint with a single (local) variable
to be eliminate, we give a relation speciﬁcation of simplify, which can be proved correct quite easily (q.v.
Lemma 4).

4. Security and Non-Interference for NLustre

4.1. Security of Nodes

We now present the notion of security of nodes. Our ﬁrst result concerns when node calls are secure.

Lemma 5 (Security of Node Calls in Lustre). For a call f (
nature

N ode

⊢ Node f (

#»
α)γ ρ
−→

#»
β

#»
e ) to a node with the given security sig-

assume the following

e
⊢

#»
e :

Γ

#»
α′

e
⊢f (

#»
e ) :

Γ

#»
β′

ck
⊢ck : γ

Γ

where ck is the base clock underlying the argument streams
#»
α′) =
variables such that for some security classes
#»
β 7→

#»
t , w ∈ SC: s(
#»
α 7→

Now, if ρ is satisﬁed by the ground instantiation {
s(

#»
β′) ⊑ s(

#»
β {|ρ|}).

#»
t ,

#»
e . Let s be a ground instantiation of type

#»
t and s(γ) = w.
#»
u , γ 7→ w}, then the s(

#»
β′) are deﬁned, and

14

Lemma 5 relates the satisfaction of constraints on security types generated during a node call to satisfaction
in a security lattice via a ground instantiation. (We rely on the modularity of nodes — that no recursive
calls are permitted, and nodes do not have free variables.) We do not provide a proof of Lemma 5 here,
since we are currently considering only NLustre programs. In the context of NLustre, since node calls
only occur in the context of an equation, we consider the (mildly) reformulated version.

Lemma 6 (Security of Node Calls in NLustre). Suppose f is a node named f in the graph G of a
Lustre program, which has security signature

and also suppose

N ode

⊢ Node f (

#»
α )γ ρ
−→

#»
β .

eqn
⊢

Γ

#»
x =ck f (

#»
e ) :> ρ1

Let s be a ground instantiation of type variables such that for some security classes

where Γ

e
⊢

#»
e :

#»
α′, s(

#»
ν ) =

#»
u′ where Γ(

#»
x ) =

#»
ν , and s(γ) = w where Γ

Now, if ρ is satisﬁed by the ground instantiation {
ordering on the tuples), then ρ1 is satisﬁed by s.

#»
α 7→

#»
t ,

#»
u′, w ∈ SC: s(

#»
α′) =

#»
t

ck
⊢ck : γ.
#»
u , γ 7→ w} where

#»
u ⊑

#»
u′ (point-wise

#»
t ,

#»
β 7→

Proof sketch. Note that in the node signature the constraint ρ guarantees that the type βi of each output
ﬂow is at least as high as the types αj of all input ﬂows on which it depends (and also the clock’s level γ).
#»
#»
u′. This ground
Suppose ρ is satisﬁed by the ground instantiation {
α 7→
#»
#»
#»
u′, then clearly
assignment coincides with s on
u to the output ﬂows. Now since
α and γ, and assigns
#»
x by s are (pointwise) at least as high as those of
the security classes
(cid:3)
the outputs ﬂows of the node call f (

#»
u′ assigned to the deﬁned variables
#»
e ).

#»
u , γ 7→ w}, where

#»
u ⊑
#»
u ⊑

#»
β 7→

#»
t ,

Deﬁnition 4.1 (Node Security). Let f be a node in the program graph G with security signature

N ode

⊢ Node f (

#»
α )γ ρ
−→

#»
β .

Let s be a ground instantiation that maps the security type variables in the set {(α1, . . . αn)}∪{(β1, . . . βm)}∪
{γ} to security classes in lattice SC.
Node f is secure with respect to s if (i) ρ is satisﬁed by s; (ii) For each node g′ on which f is directly dependent
in the program DAG, each call to g′ in f is secure with respect to its appropriate ground instantiation, as
given by the conditions in Lemma 6.

This deﬁnition captures the intuition of node security in that all the constraints generated for the equations
within the node must be satisﬁed, and that each internal node call should also be secure.

4.2. Soundness of the Type System

We establish the soundness of the type system by adapting the main idea of Volpano et al [61] to a
data-ﬂow setting. The novelty of our approach is to dispense with the usual notion of conﬁnement checking
but instead to generate and solve security type constraints.

The Simple Security Lemma for expressions (respectively, control expressions and clock expressions
says: “if, under given security assumptions for the free program variables, the type system gives a general
expression ge (expression, control expression, clock expression) a security type α, then all variables which
may have been read in evaluating the expression have a security level that is α or lower”.

Lemma 7 (Simple Security). For any general expression ge and security type assumption Γ, if Γ
then for all x ∈ f v(ge) : Γ(x) ⊑ α.

?
⊢ge : α,

15

6=

f

xH

xL

yH

yL

xH

xL

f

yH

yL

t

=

=

Figure 13: Non-interference: Two runs of a program f . Inputs xL and output yL of security level below t are the
same in both runs, whereas inputs on xH at level above t are diﬀerent

Proof sketch. By induction on the structure of ge. Constants, variables and base are the base cases.

The result is immediate from the fact that in the rules for Γ
expression is the join of the security levels of the component sub-expressions.

?
⊢ge : α, the security level of a (generalised)
(cid:3)
The notion of non-interference requires limiting observation to streams whose security level is at most a

given security level t.

Deﬁnition 4.2 ((⊑ t)-projected Stream). Suppose t ∈ SC is a security class. Let X be a set of program
variables, Γ be security type assumptions for variables in X, and s be a ground instantiation, i.e., Γ ◦ s maps
variables in X to security classes in SC. Let us deﬁne X⊑t = {x ∈ X | (Γ ◦ s)(x) ⊑ t}. Let H∗ be a Stream
history such that X ⊆ dom(H∗). Deﬁne H∗|X⊑t as the projection of H∗ to X⊑t, i.e., restricted to those
variables that are at security level t or lower:

H∗|X⊑t (x) = H∗(x)

for x ∈ X⊑t.

Figure 13 conveys the intuition behind the notion of non-interference.

Informally, the idea is that a
program displays non-interference if two runs diﬀering only in secret (high) inputs exhibit the same observable
behaviour on the public (low) outputs

Theorem 8 (Non-interference for NLustre). Let f ∈ G be a node with security signature

N ode

⊢ Node f

#»
α γ ρ
−→

#»
β

which is secure with respect to ground instantiation s of the type variables.
Let eqs be the set of equations in f . Let X = f v(eqs) − dv(eqs), i.e., the input variables in eqs.
Let V = f v(eqs) ∪ dv(eqs), i.e., the input, output and local variables.

eqn
⊢ eqs :> ρ and ρ is satisﬁed by s. Let t ∈ SC be any security level. Let bs be

Let Γ (and s) be such that Γ
a given (base) clock stream.
Let H∗ and H ′
∗ be such that

1. for all eq ∈ eqs: G, H∗, bs ⊢ eq and G, H ′

∗, bs ⊢ eq, i.e., both H∗ and H ′

∗ are consistent Stream histories

on each of the equations.

2. H∗|X⊑t = H ′
Then H∗|V⊑t = H ′
or below.

∗|X⊑t , i.e., H∗ and H ′
∗|V⊑t , i.e, H∗ and H ′

∗ agree on the input variables which are at a security level t or below.

∗ agree on all variables of the node f that are given a security level t

16

Proof. The proof is by induction on the dependency level of f ∈ G.

∗(x).

∗, bs ⊢ ge ⇓? [vs]. Therefore by the rules in Figure 7, H∗(x) = H ′

For level 0 nodes (leaves in the DAG), the only equations are of the form x =ck ce and x =ck c fby e.
We ﬁrst consider only single equations. Consider the case when x ∈ X⊑t (the other case does not matter).
From the rules (CSeqn) and (CSfby), we have β ⊔ γ ⊑ α, and consequently s(β ⊔ γ) ⊑ s(α) ⊑ t. By Lemma
7, f v(ge) ⊆ X⊑t (otherwise we would contradict s(α) ⊑ t). So by Lemma 1: H∗, bs ⊢ ge ⇓? [vs] iﬀ
H ′
Since the constraints of each equation must be satisﬁed by s, the result extends in a straightforward way to
sets of equations. Thus we have established the result for nodes at dependency level 0.
In the general case, we assume that the result holds for all nodes up to a dependency level k, and now
consider a node at level k + 1.
There can now be 3 forms of equations: x =ck ce and x =ck c fby e (as before), and node calls. For any of
the two simple cases of equation, the proof follows the same reasoning given above for level 0 nodes.
#»
x =ck f ′(
We now consider the case of node call equations
is nothing to show. So we only need to consider the case where s(νi) ⊑ t.
Since g is secure wrt s, by Deﬁnition 4.1, each call to a node g′ at a dependency level ≤ k is secure with respect
to the ground instantiation speciﬁed in Lemma 6. Therefore, by invoking the induction hypothesis on g′ and
the Stream semantics rules in Figure 7, let us consider the Stream histories H∗ and H ′
∗ augmented to include
the ﬂows on variables of this instance of g′. Let us call these H +g′
. For the corresponding output
variable y′
(y′
j).
(cid:3)
Whence by the rules in Figure 7: H∗(xi) = H ′

j in node g′ on which xi depends, since β′′
∗(xi).

#»
x }. If (Γ ◦ s)(xi) 6⊑ t, there

j ⊑ νi we have: H +g′

#»
e ). Suppose xi ∈ {

j of security type β′′

j) = H ′+g′

and H ′+g′

(y′

∗

∗

∗

∗

5. Normalisation

We now present Bourke et al.’s “normalisation transformations” , which de-nest and distribute operators
over lists (tuples) of expressions, and ﬁnally transform fby expressions to a form where the ﬁrst argument
is a constant.

Normalising an n-tuple of Lustre expressions yields an m-tuple of Lustre expressions without tupling
and nesting, and a set of equations, deﬁning fresh local variables (Figure 14). We denote the transformation
as

([e′

1, . . . , e′

m]α1,...,αm, eqsρ) ← ⌊e1, ..., en⌋

where we have additionally decorated the transformations of [9] with security types for each member of
the tuple of expressions, and with a set of type constraints for the generated equations. We show that
the normalisation transformations are indeed typed transformations. Our type annotations indicate why
security types and constraints of well-security-typed Lustre programs are preserved (modulo satisfaction),
as in Theorem 9.

The rules (Xcnst) and (Xvar) for constants and variables are straightforward, generating no equations.
The rules (Xunop)-(Xbinop) for unary and binary operators are obvious, collecting the equations from the
recursive translations of their sub-expression(s) but generating no new equations. In rule (Xwhn), where
the sampling condition is distributed over the members of the tuple, the security type for each component
expression in the result of translation is obtained by taking a join of the security type αi of the expression
e′
i with γ, i.e., that of the variable x.

Of primary interest are the rules (Xfby) for fby and (Xncall) for node call, where fresh program variables
xi and their deﬁning equations are introduced. In these cases, we introduce fresh security type variables δi
for the xi, and add appropriate type constraints where the security type expressions for the expressions are
bounded above by the type δi. In (Xncall), where the constraints are obtained from the node signature via
substitution, note that this is achieved by substituting the δi for the security types βi of the output streams.
The rules (Xite) and (Xmrg) resemble (Xfby) in most respects, collecting the equations (and their
corresponding security type constraints) generated for their sub-expressions. (In fact, here too, new equations
are generated, and thus these “control expressions” are not nested below the simpler expressions).

17

⌊c⌋ = ([c⊥], [ ]∅)
⌊xα⌋ = ([x]α, [ ]∅)

⌊⋄ e⌋ = let ([e′]α, eqsρ) ← ⌊e⌋

in ([⋄ e′]α, eqsρ)

Xcnst
Xvar

Xunop

⌊e1 ⊕ e2⌋ = let ([e′
in ([e′

1]α1 , eqsρ1
1 ⊕ e′

1 ) ← ⌊e1⌋ and ([e′
2]α1⊔α2 , (eqs1 ∪ eqs2)ρ1∪ρ2 )

2]α2 , eqsρ2

2 ) ← ⌊e2⌋ Xbinop

⌊

⌊

#»
e0 fby

αm ], eqsρ) ← ⌊

#»
e when xγ = k⌋ = let ([e′
α1 , . . . , e′
m
1
1 when x = kα1⊔γ, . . . , e′
in ([e′
#»
#»
#»
α , eqsρ0
e′
e1⌋ = let (
0
#»
#»
δ , ({(xi = e′
0i fby e′
in (
x
where ρ = {(αi ⊔ βi⊑δi)k

#»
e0⌋ and (
1i)k
i=1} ∪ ρ0 ∪ ρ1
#»
#»
#»
#»
#»
α , eqsρ1
e′
e′
e2⌋ = let (
e1⌋ and (
1 ) ← ⌊
1
2
#»
#»
2i)k
δ , ({(xi = merge x e′
1i e′
in (
x
where ρ = {(γ ⊔ αi ⊔ βi⊑δi)k

0 ) ← ⌊

⌊merge xγ #»
e1

#»
e ⌋

Xwhn

m when x = kαm⊔γ], eqsρ)
#»
#»
e′
e1⌋
1
i=1} ∪ eqs0 ∪ eqs1)ρ)

#»
β , eqsρ1

1 ) ← ⌊

Xfby

#»
β , eqsρ2
i=1} ∪ eqs1 ∪ eqs2)ρ)

2 ) ← ⌊

#»
e2⌋

Xmrg

i=1} ∪ ρ1 ∪ ρ2

⌊if e then

else

#»
et
#»
ef ⌋ = let (e′κ, eqsρc
c ) ← ⌊e⌋ and (
#»
ef ⌋ in
and (
#»
#»
δ , ({(xi = if e′ then e′
x
(
where eqs = eqsc ∪ eqst ∪ eqsf
ρ = (κ ⊔ αi ⊔ βi⊑δi)k

#»
β , eqsρf

f ) ← ⌊

#»
e′
f

#»
e′
t

i=1 ∪ ρc ∪ ρt ∪ ρf

#»
α , eqsρt

t ) ← ⌊

#»
et⌋

Xite

ti else e′

f i)k

i=1} ∪ eqs)ρ)

⌊f (e1, ..., en)⌋ = let ([e′
in ([x1

#»
α′
δk ],

, eqsρ1) ← ⌊e1, ..., en⌋

1, ..., e′
m]
δ1 , ..., xk
1, ..., e′
({(x1, ..., xk) = f (e′
#»
#»
#»
#»
β ][γ′/γ] ∪ ρ1
α′/
δ /
α][
#»
#»
α)γ ρ
β and γ′ = Γ(base)
−→

m)} ∪ eqs)ρ2 )

⊢ Node f (

where ρ2 = ρ[

given

N ode

⌊[e1, . . . , ek]⌋ = let for i ∈ {1, . . . , k} :
αi1 , . . . , e′

([e′
i1
α11 , . . . , e′
in ([e′
11
i=1..k eqsi)∪iρi )
(

1m1

αimi ], eqsρi

imi
α1m1 , . . . , e′

i ) ← ⌊ei⌋
αk1 . . . , e′

k1

αkmk ],

kmk

⌊base⌋ = base
⌊ck on x = k⌋ = ⌊ck⌋ on x = k

S

#»
x

#»
β =ckγ

⌊

#»
e ⌋ = let (

#»
e′
in ({(

#»
α , eqsρ) ← ⌊
#»
j)m
x j =ck e′

#»
e ⌋

j=1} ∪ eqs){(γ⊔αi⊑βi)k

i=1}∪ρ

Figure 14: Lustre to NLustre normalisation

18

Xncall

Xtup

Xbase
Xon

Xeqs

⌊xθ =ckγ eα

xinitδ1 =ckγ true⊥ fbynl false⊥ ⊥ ⊔ γ ⊑ δ1
pxδ2 =ckγ c⊥ fbynl eβ
γ ⊔ β ⊑ δ2
0 fbyl eβ⌋fby = 
xθ =ckγ if xinitδ1then eα

0 γ ⊔ δ1 ⊔ α ⊔ δ2 ⊑ θ
else pxδ2


Figure 15: Explicit fby initialisation

The rules (Xbase) and (Xon) for clocks also introduce no equations, and are straightforward. The
rules (Xtup) for tuples (lists) of expressions and (Xeqs) for equations regroup the resulting expressions
appropriately. The translation of node deﬁnitions involves translating the equations, and adding the fresh
local variables.

For the further transformation involving explicit initialisation of fby with a constant (Figure 15), the
new equations are constraints are straightforward: two local deﬁnitions deﬁne (i) a ﬂow named xinit that
is initially true and thereafter false, and (ii) a ﬂow named px the delayed expression e with an arbitrarily
chosen initial constant c (of appropriate data type). These are combined via a conditional on xinit that
chooses the expression e0 in the ﬁrst instant, and thereafter px. Two new security variables δ1 and δ2 are
introduced, and three constraints for the three equations introduced.

5.1. Subject Reduction and Non-Interference
Theorem 9 (Preservation of security types). Let f ∈ G be a node in Lustre program G. If the node

N ode

#»
α )γ ρ
−→

#»
β , correspondingly in ⌊G⌋ it is

N ode

⊢ Node f (

#»
α )γ ρ′
−→

#»
β , and

signature for f in G is
for any ground instantiation s, s(ρ) implies s(ρ′).

⊢ Node f (

Proof sketch. The proof is on the DAG structure of G. Here we rely on the topological dependency
order on nodes, and in their modularity (i.e., that nodes have no free variables and make no recursive
calls), and the correctness of simplify (Lemma 4) in determining node signatures. Within a node, the proof
employs induction on the structure of equations and expressions. (The reader can get some intuition about
type preservation by inspecting the annotations in Figure 14). Lemma 4 is central to establishing that the
type signature of a node does not change in the normalisation transformations of section 5, which introduce
equations involving fresh local program variables (and the associated security type constraints involving
fresh type variables). These fresh type variables are eliminated from the constraints via substitution in
simplify.

For the further explicit initialisation of fby (Figure 15), the preservation of security via simplify is also
(cid:3)

easy to see.

5.2. An Example With Typing Analysis

We adapt the examples given in [9] of the translation from Lustre to NLustre, and show how our
typing rules and security analysis work at both source and target languages. In this process, we illustrate
the preservation of the security types during the translation. We annotate the programs with security types
(as superscripts) on program variables and expressions and write constraints over these security types for
each equation (as Lustre comments), according to the typing rules.

The node cnt_dn deﬁned in Figure 16 implements a count-down timer that returns stream cpt, which is
initialized with the value of n on 0th tick and whenever there is a T on reset res, and which decrements on
each clock tick otherwise. Changing the value of n when the reset res is F doesn’t aﬀect the count on cpt.
We assign security types α1 to input res, and α2 to input n. The output cpt is assigned security type β,
and the clock ck the type γ. There are no local variables. Based on the rules (LTvar), (LTbinop), (LTfby)
and (LTite), we get constraint ρL. After simpliﬁcation, the resultant security signature of cnt_dn is given
by:

N ode

⊢ Node cnt_dn (α1, α2)γ {γ⊔α1⊔α2 ⊑ β}
19

−−−−−−−−−−−→ β

node cnt_dn

( res α1 : bool ; nα2 : int )
returns ( cpt β : int );

let

( cpt ck )βγ

= if res α1 then nα2

else ( nα2 fby ( cpt β -1));
-- ρL = {γ ⊔ α1 ⊔ α2 ⊔ α2 ⊔ β ⊔ ⊥⊑β}

tel

simplifyL (β, ρL) {} =

(β, {γ ⊔ α1 ⊔ α2 ⊑ β})

simplifyNL (β, (ρ1 ∪ ρ2 ∪ ρ3 ∪ ρ4))
= (β, {γ ⊔ α1 ⊔ α2 ⊑ β})

where

#»
δ = {{δ1, δ2, δ3}}

node cnt_dn

( res α1 : bool ; nα2 : int )

returns ( cpt β : int );
var v14 δ1 , v24 δ2 , v25 δ3 : int ;

let

v24 δ2 =γ true fby false ;
-- ρ1 = {γ ⊔ ⊥ ⊔ ⊥ ⊑ δ2}
v25 δ3 =γ 0 fby ( cpt β -1);
-- ρ2 = {γ ⊔ β ⊔ ⊥ ⊑ δ3}
v14 δ1 =γ if v24 δ2 then n

else v25 δ3 ;

-- ρ3 = {γ ⊔ δ2 ⊔ δ3 ⊑ δ1}
cpt β =γ if res α1 then nα2

else v14 δ1 ;

-- ρ4 = {γ ⊔ α1 ⊔ α2 ⊔ δ1⊑β}

tel

#»
δ

Figure 16: Example of normalisation with security analysis

The normalisation pass de-nests the fby expression and explicitly initializes it into 3 diﬀerent local
streams (v14,v24,v25). These have security types δ1, δ2, δ3 respectively. The local variables generate con-
straints ρ1, ρ2, ρ3 which are eliminated by simplify.

It can be checked that the resultant signature of cnt_dn in the translated program is also given by:

N ode

⊢ Node cnt_dn (α1, α2)γ {γ⊔α1⊔α2 ⊑ β}

−−−−−−−−−−−→ β

The re_trig node in Figure 17 uses the cnt_dn node of Figure 16 to implement a count-down timer
that is explicitly triggered whenever there is a rising edge (represented by edge) on i. If the count v expires
to 0 before a T on i, the counter isn’t allowed restart the count. Output o represents an active count in
progress.

The input streams i and n are given security types α′

security type β′. The local variables edge, ck, and v are given security types δ′
further the nested call to cnt_dn is annotated with δ′
the comments.

1, α′

2 respectively, and the output stream o the
1, δ′
3 respectively, and
6. The typing rules yield the constraints mentioned in

2, δ′

Using simplify to eliminate the security types δ′

2, δ′
6, of the local variables edge, ck, v and nested
call to cnt_dn respectively from the constraints (in lines 8,11,16-17,19 on the left), we get the constraint
{γ′ ⊔ α′

3, and δ′

1, δ′

1 ⊔ α′

2⊑β′}.

After simpliﬁcation, the resultant security signature of re_trig is given by:

N ode

⊢ Node re_trig (α′

1, α′

2)γ′ {γ′⊔α′

1⊔α′

2 ⊑ β′}

−−−−−−−−−−−−→ β′

Normalisation introduces local variables (v21,v22,v24) with security types δ′

6 (see lines 7,12,16
on the right). (Identical names have been used to show the correspondence, especially between the nested
call to cnt_dn and its equational version in the NLustre translation, both of which are given δ′
6.) The
6{|ρ′|} for the node call in the Lustre version
i are eliminated by simplify, and the reﬁnement type δ′
δ′
becomes an explicit constraint ρ5 (line 19) in NLustre. Observe that due to simplify also eliminating the
newly introduced type variables δ′
6 annotating the new program variables (v21,v22,v24), the security
signature of re_trig remains the same across the translation.

4, δ′

5, δ′

5, δ′

4, δ′

6. Security and Non-Interference for Lustre

Having shown that NLustre programs which are well-typed exhibit non-interference, and that the
translation of a Lustre program to NLustre preserves well-typedness, we proceed to show the main

20

1
2

3
4
5

6
7
8

9
10
11

12

13

14

15
16
17

18
19
20

node re_trig ( iα′
returns ( oβ′
var edge δ′
vδ′
3 : int ;

1 , ckδ′

1 : bool ; nα′
: bool )

2 : bool ,

2 : int )

let

′γ′
( edge base )δ
1

1 and
( false ⊥ fby ( not iα′
1 ⊑ δ′

-- ρ1L = {γ′ ⊔ α′

= iα′

1 ));
1}

1 ⊔ ⊥ ⊔ α′
= edgeδ′
1 or
);

′γ′
( ckbase )δ
2

2}

( false ⊥ fby oβ′

2

2 ))δ′

6{|ρ′|}δ′

-- ρ2L = {γ′ ⊔ δ′

1 ⊔ ⊥ ⊔ β′ ⊑ δ′
= merge ckδ′
1 , nα′
2 )

′γ′
( vbase )δ
3
( cnt_dn (( edge δ′
when ckδ′
(0 when not ckδ′
-- ρ′ = {δ′
2 ⊔ (δ′
-- ρ3L = {γ′ ⊔ δ′
( obase )β
-- ρ4L = {γ′ ⊔ δ′
tel

2 );
2) ⊔ (α′
6 ⊔ ⊥ ⊔ δ′
3 > 0⊥ ;

1 ⊔ δ′
2 ⊔ δ′
= vδ′
3 ⊔ ⊥ ⊑ β′}

′γ′

2

2 ⊔ δ′

2) ⊑ δ′

6}
3} ∪ ρ′

2 ⊑ δ′

1 : bool ; nα′

2 : int )

3 : int ,

node re_trig ( iα′
returns ( oβ′
var edgeδ′
v22 δ′
v24 δ′

1 , ckδ′
4 : bool , v21 δ′
6 : int when ck ;

: bool )

2 : bool , vδ′
5 : bool ,

let

v22 δ4 =γ′ false ⊥ fby
1 );

( not iα′
-- ρ1 = {γ′ ⊔ ⊥ ⊔ α′

edgeδ′

1 =γ′ iα′

1 ⊑ δ′

4}
1 and v22 δ′

4 ;

-- ρ2 = {γ′ ⊔ α′

1 ⊔ δ′
5 =γ′ false ⊥ fby oβ′

4 ⊑ δ′

1}

v21 δ′

;

5}
1 or v21 δ′
5 ⊑ δ′
2}

5 ;

ckδ′

v24 δ′

-- ρ4 = {γ′ ⊔ δ′

-- ρ3 = {γ′ ⊔ ⊥ ⊔ β′ ⊑ δ′
2 =γ′ edge δ′
1 ⊔ δ′
cnt_dn (
1 when ckδ′

6 =δ′
2
edge δ′
2 when ckδ′
nα′
2 ⊔ (δ′
-- ρ5 = {δ′
3 =γ′ merge ckδ′
(0⊥ when not ckδ′

2 );
1 ⊔ δ′

vδ′

2 ,

2 ⊔ δ′
3 >0⊥ ;

oβ′

-- ρ6 = {γ′ ⊔ δ′
=γ′ vδ′
-- ρ7 = {γ′ ⊔ δ′
tel

3 ⊔ ⊥ ⊑ β′}

2) ⊔ (α′

2) ⊑ δ′

6}

2 ⊔ δ′
6

2 v24 δ′
2 );
6 ⊔ ⊥ ⊔ δ′

2 ⊑ δ′

3}

1
2

3

4
5
6
7

8
9

10
11
12
13

14
15

16

17
18
19

20

21
22

23
24
25

simplifyL (β′, {ρ1L ∪ ρ2L ∪ ρ3L ∪ ρ4L}) {δ′

1, δ′

2, δ′

3, δ′

6} = (β′, {γ′ ⊔ α′

simplifyNL (β′, {ρ1 ∪ ρ2 ∪ ρ3 ∪ ρ4 ∪ ρ5 ∪ ρ6 ∪ ρ7}) {δ′

1, δ′

2, δ′

1 ⊔ α′
3, δ′
1 ⊔ α′

2 ⊑ β′})
4, δ′
5, δ′
6}
2 ⊑ β′})

= (β′, {γ′ ⊔ α′

Figure 17: Example: Security analysis and normalisation. when ck and when not ck] abbreviate when ck = T and
when ck = F respectively.

21

ck : γ

fL

x1 : α1

x2 : α2

y1 : β1

y2 : β2

Normalisation

Semantics Preservation

x1 : α1

x2 : α2

ck : γ

fN L

y1 : β1

y2 : β2

N ode

⊢ Node f (

#»
α )γ ρ
−→

#»
β

ρ =⇒ ρ′

Type Preservation

N ode

⊢ Node f (

#»
α )γ ρ′
−→

#»
β

Non-interfering if s(ρ′) holds

Figure 18: Non-interference for Lustre by reduction, via preservation of semantics and types

result (Theorem 12) that well-security-typed Lustre programs are non-interfering. Our strategy is problem
reduction to our earlier result of non-interference for NLustre (Theorem 8), using Theorem 9.

6.1. Semantics preservation

The remaining piece for the reduction to work is that the semantics of a program does not change during
the transformation from Lustre to NLustre. We recall here (without proofs) the important results from
[9, 10], which establish the preservation of stream semantics by the transformations.

Theorem 10 (Preservation of semantics. Theorem 2 of [9]). De-nesting and distribution preserve the
semantics of Lustre programs. (La passe de désimbrication et distributivité préserve la sémantique des pro-
grammes.)

∀G f xs ys : G s

f (xs) u ys =⇒ ⌊G⌋ s

f (xs) u ys

Theorem 11 (Preservation of semantics. Theorem 3 of [9]). The explicit initialisations of fby pre-
serve the semantics of the programs. (L’explicitation des initialisations préserve la sémantique des pro-
grammes.)

b

b

∀G f xs ys : G s

f (xs) u ys =⇒ ⌊G⌋f by s

f (xs) u ys

6.2. Non-Interference for Lustre via reduction

b

b

We now prove the main result of the soundness of the type system with respect to Lustre’s Stream
semantics, via a reduction. Figure 18 diagrams our approach. The upper part of the diagram depicts that
the normalisation transformations from Lustre to NLustre preserve semantics, while the lower part of
the diagram depicts the type preservation relationship between the signatures of the source and translated
program nodes. The satisfaction of signature constraints ρ by an assignment s implies the satisfaction of ρ′
by s, and the satisfaction of ρ′ by s indicates that the translated program node exhibits non-interference.
Theorem 12 (Non-interference for Lustre). If program G is well-security-typed in Lustre, then it
exhibits non-interference with respect to Lustre’s stream semantics.

Proof sketch. Let G be a Lustre program that is well-security-typed (in Lustre’s security type
system). This means that each node f ∈ G is well-security-typed. By induction on the DAG structure
of G, using Theorem 9, each node in ⌊G⌋ is well-security-typed (in NLustre’s security type system). By
Theorem 8, ⌊G⌋ exhibits non-interference. (That is, for any ground instantiation of security type variables,
for any given security level t, two executions of ⌊G⌋ which agree on the inputs of streams assigned a security
level at most t exhibit the same behaviour on all output streams of security level at most t.) By Theorems
10 and 11, ⌊G⌋ and G have the same extensional semantics for each node. Therefore, G exhibits non-
interference (since two executions of G which agree on the inputs of streams assigned a security level at
(cid:3)
most t will also exhibit the same behaviour on all output streams of security level at most t.

22

7. Related Work

Security type systems: Denning’s seminal paper [22] proposed lattices as the appropriate structure for
information ﬂow analyses. The subsequent paper [23] presented static analysis frameworks for certifying
secure information ﬂow. A gamut of secure ﬂow analyses were based on these foundations.

Only much later did Volpano et al. [61] provide a security type system with a semantic soundness result
by showing that security-typed programs exhibit non-interference [26]. Type systems remain a powerful way
of analysing program behaviour, particularly secure information ﬂow. For instance, the Jif compiler [48]
for the JFlow language [46] (based on Java) not only checks for IFC leaks but also deals with declassiﬁ-
cation, using the Decentralised model of data ownership [47]. Matos et al. proposed a synchronous reactive
extension of Volpano’s imperative framework. Their language is at a lower level than Lustre, and has ex-
plicit synchronization primitives for broadcast signals, suspension, preemption and scheduling of concurrent
threads. While they employ the notion of reactive bisimulation to deal with concurrency, the techniques
employed there closely follow Volpano’s formulation of the type system (which use var and cmd “phrase”
types) and a reduction semantics (necessitating a subject reduction theorem to deal with type preservation
during program execution). These operational formulations of these approaches rely on comparing program
state on termination of execution of a program phrase, which is not appropriate for Lustre, where the
behaviour of programs involves inﬁnite streams. In contrast, we are able to leverage the declarative elegance
and simplicity of Lustre to present a far simpler type system and its soundness proof in terms of Lustre’s
co-inductive stream semantics.

Semantics and logics: Non-interference [26] is considered a standard semantic notion for security although
other notions of semantic correctness have been proposed, e.g., [6]. Non-interference is a typical hyperprop-
erty [18], i.e., a set of sets of program traces. Clarkson et al. [17] have presented temporal logics HyperLTL,
HyperCTL∗, for veriﬁcation of hyperproperties.

Beyond type systems: Zanotti [62] proposed an abstract interpretation framework similar to the earlier
work from Volpano et al., but strictly more general in its applicability. Hunt and Sands [33] extended
type-based IFC checking with ﬂow-sensitivity. In Paragon, a Java-based language proposed by Broberg
et al. [12], one can additionally handle the runtime tracking of typestate. However, in general, type-based
techniques can exhibit imprecision as they lack ﬂow and context sensitivity and do not systematically handle
unstructured control ﬂow and exceptions in programs. Hammer and Snelting [30] proposed the usage of
program dependence graphs (PDGs) to oﬀer a ﬂow-, context- and object-sensitive analysis to detect IFC
leaks. Livshits et al. [44] use data propagation graphs to automatically infer explicit information ﬂow leaks.

Runtime techniques: Dynamic analyses provide greater precision, particularly in systems which rely on
dynamic typing, when static dependency graph or type-based approaches are not adequate. Shroﬀ et al.
[58] have proposed dynamic tracking of dependencies to analyse noninterference. Austin and Flanagan [2, 3]
have proposed dynamic checks to eﬃciently detect implicit ﬂows based on the no-sensitive-upgrade semantics
and the permissive-upgrade semantics. Their subsequent work [4] addressed limitations in the semantics due
to which executions where implicit ﬂows cannot be tracked are prematurely terminated.

IFC analyses in hardware and systems: We refer to but do not further discuss here work addressing
IFC analyses in hardware systems, e.g. [59, 42, 64, 25], in programming languages [56, 50, 43, 54], in op-
erating systems, [39, 63, 16, 24, 54], and in databases [57]. In the context of embedded systems, it will be
interesting to see how our higher-level Lustre-based approach compares with lower-level secure hardware
description languages such as SecVerilog [64] and ChiselFlow [25] in which ﬁne-grained security policies can
be expressed.

8. Conclusions and Future Work

We have presented a simple security type system for a synchronous reactive data-ﬂow language, and
shown its semantic soundness with respect to the language’s stream semantics in the form of non-interference.
We took an approach common in programming language research (employed, e.g., by Landin [40]), namely

23

focusing on a core sub-language for which we presented a security type system and its soundness results,
and then extended these to the full language, exploiting the fact that the compiler transformations are
both semantics-preserving and security-type-preserving. The type system for the full language employed
a version of reﬁnement types under a sub-typing constraints regime. By formulating the type system in a
symbolic form rather than in terms of a ﬁxed security lattice, we are able to infer conditions under which
an assignment of security levels to variables can ensure security.

Most prior work on type systems for security (based on the ﬂow models of [22, 23]) and their corresponding
soundness proofs have been for imperative programming languages and (higher-order) functional-imperative
languages such as ML with imperative features. In those frameworks, the focus of the analysis has mainly
been on control ﬂow eﬀects (including termination), and in the latter case of higher-order languages, on
the security type constructions necessitated by records and higher-order function spaces (e.g., the phrase
types in [61]), and the sub-typing relations induced on them. In contrast, declarative data-ﬂow languages
such as Lustre pose a diﬀerent set of issues, since their semantics involve reactive transformations between
inﬁnite input and output streams. While our approach to showing that securely-typed programs exhibit non-
interference broadly follows the paradigmatic approach of Volpano et al [61], we believe that the adaptation
to a synchronous data ﬂow setting is both novel and inventive. The traditional issues of control ﬂow eﬀects
and termination cannot be used in the same way, and indeed the results such as the conﬁnement lemma, so
central to Volpano et al ’s formulation, become unimportant in the stream semantics model. Non-interference
requires a novel re-interpretation to handle possibly recursively deﬁned ﬂows, and to cater to the inﬁnite
stream semantics. On the other hand, declarative data-ﬂow languages usually have much simpler data
types, and only ﬁrst-order functions. Moreover, deﬁnitions in these “single assignment” frameworks allow us
to formulate type inference rules and symbolic sub-type constraints over type variables. Finally, the simple
and elegant semantics of Lustre, particularly that all variables have unique deﬁnitions and that node
calls are not recursive, greatly simpliﬁes our formulation of the type system, the notion of security and the
non-interference proof.

While Lustre’s type system for data values is quite unremarkable, our security type system is not. It is
therefore satisfying to note that the transformation that was coincidentally dubbed “normalisation” happens
to satisfy a “subject reduction” property, albeit within a compilation phase and for SIF types (and so without
a Curry-Howard interpretation). We believe that there may be other issues of interest in secure information
ﬂow in declarative frameworks that diﬀer from those studied in frameworks involving data objects with
mutable state.

A diﬃcult aspect encountered during the transcription phase [10, 9] concerns alignment of clocks in
the presence of complex clock dependencies. We clarify that our type system, being static, only considers
security levels of clocks, not actual clock behaviour, and therefore is free from such complications. Further,
the clocks induce no timing side-channels since the typing rules enforce, a fortiori, that the security type of
any (clocked) expression is at least as high as that of its clock.

Future work. We are currently developing mechanised proofs of our results, so that these can be integrated
into the Vélus veriﬁed compiler framework [13], which dovetails into the CompCert approach of certiﬁed
compilers [41]. This formalisation will realise our objective of developing correct-and-secure-by-construction
implementations of a variety of embedded and reactive systems. Accordingly, we have been careful to align
our formulations to correspond closely with the Vélus project.

The next step on our agenda is the following compiler phase, namely the translation from NLustre
to the imperative language STC in the Vélus chain [7, 8]. STC programs involve assignments of values to
variables, but continue to have equation-style ﬂavour to them. The only special case arises for the memory
elements introduced for the fby construct, where the contents of a memory element are latched to be used
the next instant.

We believe that our type system poses no major problems in this phase. Our preliminary results indicate
that the instantaneous semantics for Lustre provides the necessary scaﬀolding in showing that our notions
of security and non-interference are mapped by the translation to their counterparts in a more traditional
imperative state-transition setting. Our intuition relies on the following observations about the target STC
programs, which considerably simplify the ﬂow analysis, and the preservation of security types:

24

• since in a NLustre node, each deﬁned variable has a unique equation associated with it, the resulting
STC program follows a single assignment regime for each variable. An appropriate order of evaluation
can easily be determined, which has little or no eﬀect on the security types of variables that are not
dependent on one another. The conﬁnement type can be inferred easily, and is determined only by the
security levels of the variables appearing in its deﬁning expression.

• in each “instant”, even in a conditional instruction, the same set of variables are assigned values in

diﬀerent branches.

• the initialisation by constants in the delayed (fby ﬂows construct) of a NLustre program ensures
that the security type associated with a ﬂow is determined by the type of the remainder of the ﬂow
(it can at best go up once, from ⊥ to this security level).

Acknowledgements: This work was initiated under an Indo-Japanese project DST/INT/JST/P-

30/2016(G) Security in the IoT Space, DST, Govt of India.

References

[1] Auger, C. Certiﬁed compilation of SCADE / LUSTRE. Theses, Université Paris Sud - Paris XI, Feb. 2013.
[2] Austin, T. H., and Flanagan, C. Eﬃcient Purely-Dynamic Information Flow Analysis. In Proceedings of the ACM
SIGPLAN Fourth Workshop on Programming Languages and Analysis for Security (New York, NY, USA, 2009), PLAS
’09, Association for Computing Machinery, p. 113–124.

[3] Austin, T. H., and Flanagan, C. Permissive Dynamic Information Flow Analysis. In Proceedings of the 2010 Workshop
on Programming Languages and Analysis for Security, PLAS 2010, Toronto, ON, Canada, 10 June, 2010 (New York,
NY, USA, 2010), PLAS ’10, Association for Computing Machinery.

[4] Austin, T. H., Schmitz, T., and Flanagan, C. Multiple Facets for Dynamic Information Flow with Exceptions. ACM

Trans. Program. Lang. Syst. 39, 3 (May 2017).

[5] Barthe, G., D’Argenio, P. R., and Rezk, T. Secure Information Flow by Self-Composition. In Proceedings. 17th

IEEE Computer Security Foundations Workshop, 2004. (June 2004), pp. 100–114.

[6] Boudol, G. Secure Information Flow as a Safety Property. In Formal Aspects in Security and Trust, 5th International
Workshop, FAST 2008, Malaga, Spain, October 9-10, 2008, Revised Selected Papers (2008), vol. 5491 of Lecture Notes
in Computer Science, Springer, pp. 20–34.

[7] Bourke, T., Brun, L., Dagand, P.-E., Leroy, X., Pouzet, M., and Rieg, L. A Formally Veriﬁed Compiler for
Lustre. In Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation
(New York, NY, USA, 2017), PLDI 2017, Association for Computing Machinery, p. 586–601.

[8] Bourke, T., Brun, L., and Pouzet, M. Mechanized Semantics and Veriﬁed Compilation for a Dataﬂow Synchronous

Language with Reset. Proc. ACM Program. Lang. 4, POPL (Dec. 2019).

[9] Bourke, T., Jeanmaire, P., Pesin, B., and Pouzet, M. Normalisation vériﬁée du langage Lustre.

In 32ièmes
Journées Francophones des Langages Applicatifs (JFLA 2021) (online, Apr. 2021), Y. Regis-Gianas and C. Keller, Eds.
[10] Bourke, T., Jeanmaire, P., Pesin, B., and Pouzet, M. Veriﬁed lustre normalization with node subsampling. ACM

Trans. Embed. Comput. Syst. 20, 5s (2021), 98:1–98:25.

[11] Bourke, T., Jeanmaire, P., Pesin, B., and Pouzet, M. Veriﬁed lustre normalization with node subsampling. ACM

Trans. Embed. Comput. Syst. 20, 5s (sep 2021).

[12] Broberg, N., van Delft, B., and Sands, D. Paragon for Practical Programming with Information-Flow Control. In
Programming Languages and Systems (Cham, 2013), C.-c. Shan, Ed., Springer International Publishing, pp. 217–232.
[13] Brun, L., Bourke, T., and Pouzet, M. Vélus Compiler Repository. https://github.com/INRIA/velus , 2020. Ac-

cessed: 2020-01-20.

[14] Caspi, P., Pilaud, D., Halbwachs, N., and Plaice, J. A. LUSTRE: A Declarative Language for Programming
Synchronous Systems. In Proc. 14th Symposium on Principles of Programming Languages (POPL’87). ACM (1987).
[15] Checkoway, S., McCoy, D., Kantor, B., Anderson, D., Shacham, H., Savage, S., Koscher, K., Czeskis, A.,
Roesner, F., and Kohno, T. Comprehensive Experimental Analyses of Automotive Attack Surfaces. In Proceedings of
the 20th USENIX Conference on Security (Berkeley, CA, USA, 2011), SEC’11, USENIX Association, pp. 6–6.

[16] Cheng, W., Ports, D. R. K., Schultz, D. A., Popic, V., Blankstein, A., Cowling, J. A., Curtis, D., Shrira,
L., and Liskov, B. Abstractions for Usable Information Flow Control in Aeolus. In 2012 USENIX Annual Technical
Conference, Boston, MA, USA, June 13-15, 2012 (2012), pp. 139–151.

[17] Clarkson, M. R., Finkbeiner, B., Koleini, M., Micinski, K. K., Rabe, M. N., and Sánchez, C. Temporal
In Principles of Security and Trust (Berlin, Heidelberg, 2014), M. Abadi and S. Kremer,

Logics for Hyperproperties.
Eds., Springer Berlin Heidelberg, pp. 265–284.

[18] Clarkson, M. R., and Schneider, F. B. Hyperproperties. J. Comput. Secur. 18, 6 (Sept. 2010), 1157–1210.
[19] Colaço, J., Pagano, B., and Pouzet, M. SCADE 6: A Formal Language for Embedded Critical Software Development
(invited paper). In 2017 International Symposium on Theoretical Aspects of Software Engineering (TASE) (Sep. 2017),
pp. 1–11.

25

[20] Coq Development Team. The Coq proof assistant reference manual. https://coq.inria.fr/distrib/V8.9.1/refman/,

2020. Accessed: 2021-06-30.

[21] Cranford, N. IoT security concerns prompt massive pacemaker recall. https://enterpriseiotinsights.com/20170901/abbott-recalls-almost-50000-pacemakers-due-to-security-concerns-tag27 .

Accessed: 2020-05-02.

[22] Denning, D. E. A Lattice Model of Secure Information Flow. Commun. ACM 19, 5 (May 1976), 236–243.
[23] Denning, D. E., and Denning, P. J. Certiﬁcation of Programs for Secure Information Flow. Commun. ACM 20, 7

(July 1977), 504–513.

[24] Efstathopoulos, P., Krohn, M. N., Vandebogart, S., Frey, C., Ziegler, D., Kohler, E., Mazières, D.,
Kaashoek, M. F., and Morris, R. T. Labels and Event Processes in the Asbestos Operating System. In Proceedings
of the 20th ACM Symposium on Operating Systems Principles 2005, SOSP 2005, Brighton, UK, October 23-26, 2005
(2005), pp. 17–30.

[25] Ferraiuolo, A., Zhao, M., Myers, A. C., and Suh, G. E. Hyperﬂow: A Processor Architecture for Nonmal-
leable, Timing-Safe Information Flow Security. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security, CCS 2018, Toronto, ON, Canada, October 15-19, 2018 (2018), pp. 1583–1600.

[26] Goguen, J. A., and Meseguer, J. Security Policies and Security Models. In 1982 IEEE Symposium on Security and

Privacy, Oakland, CA, USA, April 26-28, 1982 (1982), IEEE Computer Society, pp. 11–20.

[27] Graham, J. Now a smart lightbulb system got hacked. https://www.usatoday.com/story/tech/2020/02/05/how-to-avoid-smart-lights-getting-hacked/4660430002/,

2020. Accessed: 2020-02-25.

[28] Halbwachs, N., Caspi, P., Raymond, P., and Pilaud, D. The Synchronous Data Flow Programming Language

LUSTRE. Proceedings of the IEEE 79, 9 (Sep. 1991), 1305–1320.

[29] Halbwachs, N., Lagnier, F., and Raymond, P. Synchronous Observers and the Veriﬁcation of Reactive Systems. In
Third Int. Conf. on Algebraic Methodology and Software Technology, AMAST’93, Twente (1993), Springer Verlag.
[30] Hammer, C., and Snelting, G. Flow-sensitive, Context-sensitive, and Object-sensitive Information Flow Control based

[31] Hardigree,

on program dependence graphs. International Journal of Information Security 8, 6 (Dec. 2009), 399–422.
kill

car.
https://jalopnik.com/carshark-software-lets-you-hack-into-control-and-kill-5539181, 2014. Accessed: 2020-
01-20.

Carshark

software

control

hack

into,

and

any

you

lets

M.

[32] Heintze, N., and Riecke, J. G. The SLam Calculus: Programming with Secrecy and Integrity.

In Proceedings of
the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (New York, NY, USA, 1998),
POPL ’98, Association for Computing Machinery, p. 365–377.

[33] Hunt, S., and Sands, D. On Flow-Sensitive Security Types. In Conference Record of the 33rd ACM SIGPLAN-SIGACT
Symposium on Principles of Programm ing Languages (New York, NY, USA, 2006), POPL ’06, Association for Computing
Machinery, p. 79–90.

[34] Internet of Things Global Standards

Initiative.

Internet

of

things global

standards

initiative.

https://www.itu.int/en/ITU-T/gsi/iot, 2015. Accessed: 2020-01-20.

[35] Jahier,

E.

The

Lurette

V2

User

guide,

V2

ed.

Verimag,

October

2015.

http://www-verimag.imag.fr/DIST-TOOLS/SYNCHRONE/lurette/doc/lurette-man.pdf.

[36] Kahn, G. The Semantics of a Simple Language for Parallel Programming. In Information Processing, Proceedings of the
6th IFIP Congress 1974, Stockholm, Sweden, August 5-10, 1974 (1974), J. L. Rosenfeld, Ed., North-Holland, pp. 471–475.
[37] Kind 2 group. Kind 2 User Documentation, version 1.2.0 ed. Department of Computer Science, The University of Iowa,

April 2020. https://kind.cs.uiowa.edu/kind2_user_doc/doc.pdf.

[38] Knuth, D. E., and Bendix, P. B. Simple Word Problems in Universal Algebras. In Computational Problems in Abstract

Algebra, J. LEECH, Ed. Pergamon, 1970, pp. 263–297.

[39] Krohn, M. N., Yip, A., Brodsky, M. Z., Cliffer, N., Kaashoek, M. F., Kohler, E., and Morris, R. T.
In Proceedings of the 21st ACM Symposium on Operating

Information Flow Control for Standard OS Abstractions.
Systems Principles 2007, SOSP 2007, Stevenson, Washington, USA, October 14-17, 2007 (2007), pp. 321–334.

[40] Landin, P. J. The next 700 Programming Languages. Commun. ACM 9, 3 (1966), 157–166.
[41] Leroy, X. Formal veriﬁcation of a realistic compiler. Commun. ACM 52, 7 (2009), 107–115.
[42] Li, X., Kashyap, V., Oberg, J. K., Tiwari, M., Rajarathinam, V. R., Kastner, R., Sherwood, T., Hardekopf,
B., and Chong, F. T. Sapper: A Language for Hardware-Level Security Policy Enforcement. SIGARCH Comput. Archit.
News 42, 1 (Feb. 2014), 97–112.

[43] Liu, J., Arden, O., George, M. D., and Myers, A. C. Fabric: Building open distributed systems securely by

construction. Journal of Computer Security 25, 4-5 (2017), 367–426.

[44] Livshits, B., Nori, A. V., Rajamani, S. K., and Banerjee, A. Merlin: Speciﬁcation Inference for Explicit Information
In Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Im

Flow Problems.
plementation (New York, NY, USA, 2009), PLDI ’09, Association for Computing Machinery, p. 75–86.

[45] Marin, E., Singelée, D., Garcia, F. D., Chothia, T., Willems, R., and Preneel, B. On the (in)Security of
the Latest Generation Implantable Cardiac Deﬁbrillators and How to Secure Them. In Proceedings of the 32nd Annual
Conference on Computer Security Applications (New York, NY, USA, 2016), ACSAC ’16, ACM, pp. 226–236.

[46] Myers, A. C. JFlow: Practical Mostly-Static Information Flow Control. In Proceedings of the 26th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages (San Antonio, Texas, USA, Jan. 1999), POPL ’99, Asso-
ciation for Computing Machinery, pp. 228–241.

[47] Myers, A. C., and Liskov, B. A Decentralized Model for Information Flow Control. In Proceedings of the Sixteenth
ACM Symposium on Operating Systems Principles (New York, NY, USA, 1997), SOSP ’97, Association for Computing
Machinery, p. 129–142.

26

[48] Myers, A. C., Zheng, L., Zdancewic, S., Chong, S., and Nystrom, N.

Jif 3.0: Java information ﬂow.

http://www.cs.cornell.edu/jif.

[49] Plaice, J. The LUSTRE Synchronous Dataﬂow Programming Language: Design and Semantics. Annals of the New

York Academy of Sciences 661 (12 2006), 118 – 151.

[50] Pottier, F., and Simonet, V. Information Flow Inference for ML. ACM Trans. Program. Lang. Syst. 25, 1 (Jan.

2003), 117–158.

[51] Prasad, S., and Yerraguntla, R. M. Normalising lustre preserves security. In Theoretical Aspects of Computing -
ICTAC 2021 - 18th International Colloquium, Virtual Event, Nur-Sultan, Kazakhstan, September 8-10, 2021, Proceedings
(2021), A. Cerone and P. C. Ölveczky, Eds., vol. 12819 of Lecture Notes in Computer Science, Springer, pp. 275–292.
[52] Prasad, S., Yerraguntla, R. M., and Sharma, S. Security Types for Synchronous Data Flow Systems. In 2020
18th ACM-IEEE International Conference on Formal Methods and Models for System Design (MEMOCODE) (2020),
pp. 1–12.

[53] Raymond, P. Synchronous Program Veriﬁcation with Lustre/Lesar. In Modeling and Veriﬁcation of Real-Time Systems:

Formalisms and Software Tools. Wiley, 2010, pp. 171 – 206.

[54] Roy, I., Porter, D. E., Bond, M. D., McKinley, K. S., and Witchel, E. Laminar: Practical Fine-Grained De-
centralized Information Flow Control. In Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language
Design and Implementation, PLDI 2009, Dublin, Ireland, June 15-21, 2009 (2009), pp. 63–74.

[55] Rushby, J. M. The Versatile Synchronous Observer. In Formal Methods: Foundations and Applications - 15th Brazil-
ian Symposium, SBMF 2012, Natal, Brazil, September 23-28, 2012. Proceedings (2012), vol. 7498 of Lecture Notes in
Computer Science, Springer, p. 1.

[56] Sabelfeld, A., and Myers, A. C. Language-based Information-Flow Security. IEEE Journal on Selected Areas in

Communications 21, 1 (2003), 5–19.
[57] Schultz, D. A., and Liskov, B.

IFDB: Decentralized Information Flow Control for Databases.

In Eighth Eurosys

Conference 2013, EuroSys ’13, Prague, Czech Republic, April 14-17, 2013 (2013), pp. 43–56.

[58] Shroff, P., Smith, S., and Thober, M. Dynamic Dependency Monitoring to Secure Information Flow. In Proceedings
of the 20th IEEE Computer Security Foundations Symposium (USA, 2007), CSF ’07, IEEE Computer Society, p. 203–217.
[59] Tiwari, M., Oberg, J. K., Li, X., Valamehr, J., Levin, T., Hardekopf, B., Kastner, R., Chong, F. T., and
Sherwood, T. Crafting a Usable Microkernel, Processor, and I/O System with Strict and Provable Information Flow
Security. In Proceedings of the 38th Annual International Symposium on Computer Architecture (New York, NY, USA,
2011), ISCA ’11, Association for Computing Machinery, p. 189–200.

[60] Viry, P. Equational rules for rewriting logic. Theoretical Computer Science 285, 2 (2002), 487–517.
[61] Volpano, D., Irvine, C., and Smith, G. A Sound Type System for Secure Flow Analysis. J. Comput. Secur. 4, 2–3

(Jan. 1996), 167–187.

[62] Zanotti, M. Security Typings by Abstract Interpretation. In Proceedings of the 9th International Symposium on Static

Analysis (Berlin, Heidelberg, 2002), SAS ’02, Springer-Verlag, p. 360–375.

[63] Zeldovich, N., Boyd-Wickizer, S., Kohler, E., and Mazières, D. Making Information Flow Explicit in Histar. In
7th Symposium on Operating Systems Design and Implementation (OSDI’06), November 6-8, Seattle, WA, USA (2006),
pp. 263–278.

[64] Zhang, D., Wang, Y., Suh, G. E., and Myers, A. C. A Hardware Design Language for Timing-Sensitive Information-
Flow security.
In Proceedings of the Twentieth International Conference on Architectural Support for Programming
Languages and Operating Systems (Istanbul, Turkey, Mar. 2015), ASPLOS ’15, Association for Computing Machinery,
pp. 503–516.

Appendix A. Free Variable Deﬁnitions

The deﬁnitions of free variables (f v) in expressions and equations, and deﬁned variables (dv) in equations

are given in Figure A.19 and Figure A.20.

Appendix B. Auxiliary Predicate Deﬁnitions

The deﬁnitions of the auxiliary semantic stream predicates when, const, merge, ite are given in Figure B.21.
All predicates except fbyL and fbyN L (deﬁned in Figure B.23) are reused to deﬁne semantics of both Lustre
and NLustre.

All auxiliary stream operators are deﬁned to behave according to the clocking regime. For example,
the rule (DcnstF) ensures the absence of a value when the clock is false. Likewise the unary and binary
operators lifted to stream operations ˆ⋄ and ˆ⊕ operate only when the argument streams have values present,
as in (Dunop) and (Dbinop), and mark absence when the argument streams’ values are absent, as shown in
(DunopA) and (DbinopA). The rules (Dtl) and (Dhtl) are obvious.

Note that in the rules (DmrgT) and (DmrgF) for merge, a value is present on one of the two streams
being merged and absent on the other. When a value is absent on the stream corresponding to the boolean

27

f v(c) = {}
f v(x) = {x}
f v(⋄ e) = f v(e)

f v(e1 ⊕ e2) = f v(e1) ∪ f v(e2)

#»
e when x = k) = f v(
#»
e2) = {x} ∪ f v(
#»
#»
e2) = f v(
e1) ∪ f v(
#»
e3) = f v(e1) ∪ f v(
#»
e )) =

f v(
#»
f v(merge x
e1
#»
e1 fby
f v(
#»
e2 else
f v(f (

#»
e ) ∪ {x}
#»
e1) ∪ f v(
#»
e2)
#»
e2) ∪ f v(

#»
e2)

#»
ei)

i f v(

#»
e3)

f v(if e1 then

f v(base) = {base}
f v(ck on x = k) = f v(ck) ∪ {x}

S

#»
e ) =

f v(

i f v(ei)

f v(e :: ck) = f v(e) ∪ f v(ck)

S

Figure A.19: Free variables for expressions

#»
x =

#»
e ) = f v(

#»
e ) \ {

#»
x }

f v(

#»
x =

#»
e ) = {

#»
x }

dv(

f v(x =ck ce) = f v(ck) ∪ f v(ce) \ {x}
f v(x =ck c fby e) = f v(ck) ∪ f v(e) \ {x}
#»
x }

#»
e )) = f v(ck) ∪ f v(

#»
x =ck f (

#»
e ) \ {

f v(

dv(x =ck ce) = {x}
dv(x =ck c fby e) = {x}
#»
x }

#»
e )) = {

#»
x =ck f (

dv(

Figure A.20: Free and deﬁned variables for equations

variable, values are absent on all streams (DmrgA). The rules for ite require all streams to have values
present, i.e., (DiteT) and (DiteF), or all absent, i.e., (DiteA). We have already discussed the when operation
in some detail earlier.

The fbyN L operation is a bit subtle, and rule (Dfby) may look non-intuitive. However, its formulation
corresponds exactly to the Vélus formalisation, ensuring that a value from the ﬁrst argument stream is
prepended exactly when a leading value would have been present on the second argument stream. The
operation base-of converts a value stream to a clock, i.e., a boolean stream. The operation respects-clock is
formulated corresponding to the Vélus deﬁnition.

The main diﬀerence between fbyL and fbyN L is that the former takes a stream while the latter takes
a constant value. The fbyN L predicate assigns the currently saved constant as the stream value and delays
the current operand stream by storing its current value for the next clock cycle (eﬀectively functioning as
an initialized D-ﬂip ﬂop). fbyL on the other hand extracts the 0th tick value of the ﬁrst operand stream and
uses the predicate fbydl for delaying.

28

const bs′ c = cs′
const (true · bs′) c = ‹c› · cs′

(DcnstT)

const bs′ c = cs′
const (false · bs′) c = ‹› · cs′

(DcnstF)

⋄ es′ = os′ v′ = ⋄ v
⋄ (‹v› · es′) = ‹v′› · os′
b
es = v · es′
b
(tl es) = es′

(Dtl)

(Dunop)

⋄ es′ = os′
⋄ (‹› · es′) = ‹› · os′

(DunopA)

b

es′
1
(‹v1› · es′
b

⊕es′
1)

b

2 = os′ v1 ⊕ v2 = v
⊕(‹v2› · es′

2) = ‹v› · os′

(Dbinop)

x ∈ dom(H∗)
(htl H∗)(x) = (tl H∗(x))

(Dhtl)

b
(‹› · es′

2 = os′

⊕es′
es′
1
⊕(‹› · es′
1)

2) = ‹› · os′

b

(DbinopA)

respects-clock H∗ bs vs
respects-clock H∗ (false · bs) (‹› · vs)

(DresA)

base-of vs = bs
b
base-of (v · vs) = true · bs

(Dbase1)

respects-clock H∗ bs vs
respects-clock H∗ (true · bs) (‹v› · vs)

(Dres)

base-of vs = bs
base-of (‹› · vs) = false · bs

(Dbase2)

Figure B.21: Deﬁnitions of auxiliary predicates-1

Appendix C. Stream Semantics

We present here a speciﬁcation of core Lustre’s co-inductive stream semantics, with some commentary
and intuition. This consolidates various earlier presentations of rules [7, 8, 52, 9], and can be seen as an
abstract Coq-independent speciﬁcation of the semantics encoded in the Vélus development.

The semantics of Lustre and NLustre programs are synchronous: Each variable and expression deﬁnes
a data stream which pulses with respect to a clock. A clock is a stream of booleans (CompCert/Coq’s true
and false in Velus). A ﬂow takes its nth value on the nth clock tick, i.e., some value, written ‹v›, is present
at instants when the clock value is true, and none (written ‹›) when it is false. The temporal operators when,
merge and fby are used to express the complex clock-changing and clock-dependent behaviours of sampling,
interpolation and delay respectively.

Formally the stream semantics is deﬁned using predicates over the program graph G, a (co-inductive)
stream history (H∗ : Ident → value Stream) that associates value streams to variables, and a clock bs
[8, 52, 9]. Semantic operations on (lists of) streams are written in blue sans serif typeface. Streams are
written in red, with lists of streams usually written in bold face. All these stream operators, deﬁned co-
inductively, enforce the clocking regime, ensuring the presence of a value when the clock is true, and absence
when false.

The predicate G, H∗, bs ⊢ e ⇓e es relates an expression e to a list of streams, written es. A list consisting
of only a single stream es is explicitly denoted as [es]. The semantics of equations are expressed using the
#  »
predicate G, H∗, bs ⊢
eqi, which requires consistency between the assumed and deﬁned stream histories in
H∗ for the program variables, as induced by the equations. Finally, the semantics of nodes is given as a
stream history transformer predicate G s

f (xs) u ys.

Figure C.24 presents the stream semantics for Lustre. While rules for some constructs have been
variously presented [7, 8, 52, 9], our presentation can be considered as a deﬁnitive consolidated speciﬁcation
of the operational semantics of Lustre, consistent with the Vélus compiler encoding [13].

b

• Rule (LScnst) states that a constant c denotes a constant stream of the value ‹c› pulsed according to

given clock bs. This is eﬀected by the semantic operator const.

• Rule (LSvar) associates a variable x to the stream given by H∗(x).

29

merge xs′ ts′ f s′ = os′
merge (‹T › · xs′) (‹vt› · ts′) (‹› · f s′) = ‹vt› · os′

(DmrgT)

merge xs′ ts′ f s′ = os′
merge (‹F › · xs′) (‹› · ts′) (‹vf › · f s′) = ‹vf › · os′

(DmrgF)

merge xs′ ts′ f s′ = os′
merge (‹› · xs′) (‹› · ts′) (‹› · f s′) = ‹› · os′

(DmrgA)

ite es′ ts′ f s′ = os′
ite (‹T › · es′) (‹vt› · ts′) (‹vf › · f s′) = ‹vt› · os′

(DiteT)

ite es′ ts′ f s′ = os′
ite (‹F › · es′) (‹vt› · ts′) (‹vf › · f s′) = ‹vf › · os′

(DiteF)

ite es′ ts′ f s′ = os′
ite (‹› · es′) (‹› · ts′) (‹› · f s′) = ‹› · os′

(DiteA)

when k xs′ es′ = os′
when k (‹¬k› · xs′) (‹v› · es′) = ‹› · os′

(DwhA1)

fbyN L v xs = ys
fbyN L c (‹v› · xs) = ‹c› · ys

(Dfby)

when k xs′ es′ = os′
when k (‹k› · xs′) (‹v› · es′) = ‹v› · os′

(Dwhk)

fbyN L c xs = ys
fbyN L c (‹› · xs) = ‹› · ys

(DfbyA)

when k xs′ es′ = os′
when k (‹› · xs′) (‹› · es′) = ‹› · os′

(DwhA2)

Figure B.22: Deﬁnitions of auxiliary predicates-2

fbyL xs ys = os
fbyL (‹› · xs) (‹› · ys) = ‹› · os

fbydl y xs ys = os
fbyL (‹x› · xs) (‹y› · ys) = ‹x› · os

fbydl v xs ys = os
fbydl v (‹› · xs) (‹› · ys) = ‹› · os

fbydl y xs ys = os
fbydl v (‹x› · xs) (‹y› · ys) = ‹v› · os

Figure B.23: Lustre’s fby semantic predicates

30

const c bs = cs
G, H∗, bs ⊢ c ⇓e [cs]

(LScnst)

H∗(x) = xs
G, H∗, bs ⊢ x ⇓e [xs]

(LSvar)

G, H∗, bs ⊢ e ⇓e [es]

⋄ es = os

G, H∗, bs ⊢ ⋄ e ⇓e [os]

(LSunop)

b

G, H∗, bs ⊢ e1 ⇓e [es1] G, H∗, bs ⊢ e2 ⇓e [es2] es1

⊕es2 = os

G, H∗, bs ⊢ e1 ⊕ e2 ⇓e [os]

(LSbinop)

∀i G, H∗, bs ⊢ ei ⇓e esi H∗(x) = xs ∀i :
G, H∗, bs ⊢

#»
ei when x = k ⇓e ♭(

#   »
osi)

b
[when k xs esi = osi

G, H∗, bs ⊢ e ⇓e [es] ∀i : G, H∗, bs ⊢ eti ⇓e etsi
#     »
efsj)) = os

ite es (♭(

∀j : G, H∗, bs ⊢ efj ⇓e efsj

#     »
etsi)) (♭(
#   »
efj ⇓e os

# »
eti else

G, H∗, bs ⊢ if e then

c

(LSwhn)

(LSite)

∀j : G, H∗, bs ⊢ efj ⇓e efsj \merge xs (♭(
#   »
efj ⇓e os

G, H∗, bs ⊢ merge x

# »
eti

H∗(x) = xs ∀i : G, H∗, bs ⊢ eti ⇓e etsi
#     »
efsj)) = os

#     »
etsi)) (♭(

(LSmrg)

∀i : G, H∗, bs ⊢ e0i ⇓e e0si

G, H∗, bs ⊢

∀i ∈ [1, k] G, H∗, bs ⊢ ei ⇓e esi

G, H∗, bs ⊢

∀j : G, H∗, bs ⊢ ej ⇓e esj

#      »
e0si)) (♭(

#   »
esj)) = os

fbyL (♭(
#»
ej ⇓e os

#  »
e0i fby
d
[H∗(x1), . . . , H∗(xn)] = ♭(
#»
xj =

#»
ei

(LSfby)

#  »
esi)

(LSeq)

name = f; in =
out =

#»
y ; eqs =

#»
eq

#»
x ; var =

#»
z ;

)

(

∈ G H∗(n.in) = xs base-of xs = bs

H∗(n.out) = ys ∀eq ∈

G s

f (xs) u ys

#»
eq : G, H∗, bs ⊢ eq

(LSndef)

G, H∗, bs ⊢

#»
e ⇓e xs G s

b

f (xs) u ys

G, H∗, bs ⊢ f (

#»
e ) ⇓e ys
b

(LSncall)

∀i : G, H∗, bs ⊢ ei ⇓e esi
#  »
esi)
G, H∗, bs ⊢

#»
ei ⇓e ♭(

(LStup)

Figure C.24: Stream semantics of Lustre

31

• In rule (LSunop), ˆ⋄ denotes the operation ⋄ lifted to apply instant-wise to the stream denoted by

expression e.

• Likewise in rule (LSbinop), the binary operation ⊕ is applied paired point-wise to the streams denoted
by the two sub-expressions (which should both pulse according to the same clock). In all these rules,
an expression is associated with a single stream.

• The rule (LSwhn) describes sampling whenever a variable x takes the boolean value k, from the ﬂows
#»
ei, returning a list of streams of such sampled values. The predicate

arising from a list of expressions
[when maps the predicate when to act on the corresponding components of lists of streams, i.e.,

[when k xs [es1, . . . , esk] = [os1, . . . , osk] abbreviates

when k xs esi = osi.

^i∈[1,k]

The operation ♭(_) ﬂattens a list of lists (of possibly diﬀerent lengths) into a single list. Flattening is
required since expression ei may in general denote a list of streams esi.

#»
eti

• The expression merge x

# »
ef j produces (lists of) streams on a faster clock. The semantics in rule
(LSmrg) assume that for each pair of corresponding component streams from ♭(etsi) and ♭(efsj), a
value is present in the ﬁrst stream and absent in the second at those instances where x has a true
value ‹T ›, and complementarily, a value is present in the second stream and absent in the ﬁrst when
x has a false value ‹F ›. Both values must be absent when x’s value is absent. These conditions are
enforced by the auxiliary semantic operation merge. The predicate \merge maps the predicate merge
to act on the corresponding components of lists of streams, i.e.,

\merge xs [ets1, . . . , etsk] [ef s1, . . . , ef sk] = [os1, . . . , osk] abbreviates

merge xs etsi ef si = osi.

^i∈[1,k]

# »
#»
et else
• In contrast, the conditional expression if e then
ef requires that all three argument streams
#     »
#     »
efsj) pulse to the same clock. Again, values
etsi) and ♭(
es, and the corresponding components from ♭(
are selected from the ﬁrst or second component streams depending on whether the stream es has the
value ‹T › or ‹F › at a particular instant. These conditions are enforced by the auxiliary semantic
operation ite. The predicate
ite maps the predicate ite to act on the corresponding components of lists
of streams, i.e.,

ite xs [ets1, . . . , etsk] [ef s1, . . . , ef sk] = [os1, . . . , osk] abbreviates

ite xs etsi ef si = osi.

c

c

^i∈[1,k]

• A delay operation is implemented by e0 fby e. The rule (LSfby) is to be read as follows. Let each
expression e0i denote a list of streams e0si, and each expression ej denote a list of streams esj. The
output list of streams consists of streams whose ﬁrst elements are taken from the each stream in
#   »
esj). These are achieved using
♭(
the semantic operation fbyL. The predicate
fbyL maps the predicate fbyL to act on the corresponding
components of lists of streams, i.e.,

#      »
e0si) with the rest taken from the corresponding component of ♭(

fbyL xs ys = zs abbreviates

fbyL xsi ysi = zsi

d

d

^i∈[1,m]

• The rule (LStup) deals with tuples of expressions, where the lists of streams from each expression are

ﬂattened into a list of streams.

32

H∗, bs ⊢ base ⇓ck bs

(LSbase)

H∗, bs ⊢ ck ⇓ck (true · bk) H∗(x) = (‹k› · xs)
(htl H∗), (tl bs) ⊢ ck on x = k ⇓ck bs′

H∗, bs ⊢ ck on x = k ⇓ck (true · bs′)
H∗, bs ⊢ ck ⇓ck (false · bk) H∗(x) = (‹› · xs)
(htl H∗), (tl bs) ⊢ ck on x = k ⇓ck bs′

H∗, bs ⊢ ck on x = k ⇓ck (false · bs′)
H∗, bs ⊢ ck ⇓ck (true · bk) H∗(x) = (‹k› · xs)
(htl H∗), (tl bs) ⊢ ck on x = ¬k ⇓ck bs′

H∗, bs ⊢ ck on x = ¬k ⇓ck (false · bs′)

(LSonT)

(LSonA1)

(LSonA2)

H∗, bs ⊢ e ⇓e [‹› · es]
H∗, bs ⊢ ck ⇓ck false · cs
H∗, bs ⊢ e :: ck ⇓e [‹› · es]

(NSaeA)

H∗, bs ⊢ e ⇓e [‹v› · es]
H∗, bs ⊢ ck ⇓ck true · cs
H∗, bs ⊢ e :: ck ⇓e [‹v› · es]

(NSae)

Figure C.25: Stream semantics of clocks and annotated expressions

Equations, node deﬁnitions and node call.

• The rule (LSeq) for equations checks the consistency between the assumed meanings for the deﬁned
variables xj according to the history H∗ with the corresponding components of the list of streams
♭(

#  »
esi) to which a tuple of right-hand side expressions evaluates.

• The rule (LSndef) presents the meaning given to the deﬁnition named f of a node as a stream list
transformer
f . If history H∗ assigns lists of streams to the input and output variables for a node in a
manner such that the semantics of the equations in the node are satisﬁed, then the semantic funnction
f transforms input stream list xs to output stream list ys. The operation base-of ﬁnds an appropriate
base clock with respect to which a given list of value streams pulse.
b

b

• The rule (LSncall) applies the stream transformer semantic function
#»
ei, and returns the stream list ys.

sponding to the tuple of arguments

f to the stream list xs corre-

b

Clocks and clock-annotated expressions. We next present rules for clocks. Further, we assume that all
(NLustre) expressions in equations can be clock-annotated, and present the corresponding rules.

The predicate H∗, bs ⊢ ck ⇓ck bs′ in Figure C.25 deﬁnes the meaning of a NLustre clock expression ck
with respect to a given history H∗ and a clock bs to be the resultant clock bs′. The on construct lets us
deﬁne coarser clocks derived from a given clock — whenever a variable x has the desired value k and the
given clock is true. The rules (LSonT), (LSonA1), and (LSonA2) present the three cases: respectively when
variable x has the desired value k and clock is true; the clock is false; and the program variable x has the
complementary value and the clock is true. The auxiliary operations tl and htl, give the tail of a stream, and
the tails of streams for each variable according to a given history H∗. Rules (NSaeA)-(NSae) describe the
semantics of clock-annotated expressions, where the output stream carries a value exactly when the clock is
true.

Stream semantics for NLustre. The semantic relations for NLustre are either identical to (as in con-
stants, variables, unary and binary operations) or else the (simple) singleton cases of the rules given for
Lustre (as in merge, ite, when).

The signiﬁcant diﬀerences are in treatment of fby, and the occurrence of fby and node call only in the

context of equations.

33

name = f; in =
out =

#»
y ; eqs =

#»
eq

#»
x ; var =

#»
z ;

)

(

∈ G H∗(n.in) = xs base-of xs = bs

respects-clock H∗ bs H∗(n.out) = ys ∀eq ∈

G s

f (xs) u ys

#»
eq : G, H∗, bs ⊢ eq

(NSndef’)

b

H∗, bs ⊢ e :: ck ⇓e H∗(x)
G, H∗, bs ⊢ x =ck e

(NSeq)

H∗, bs ⊢ e :: ck ⇓e [vs]

fbyN L c vs = H∗(x)

G, H∗, bs ⊢ x =ck c fby e

(NSfby’)

H∗, bs ⊢

#»
e ⇓e vs H∗, bs ⊢ ck ⇓ck base-of vs G s

G, H∗, bs ⊢

#»
x =ck f (

#»
e )

f (vs) u

#            »
H∗(xi)

(NSncall’)

b

Figure C.26: Stream semantics of NLustre nodes and equations

The (NSndef’) rule only diﬀers from (LSndef) in that post-transcription clock alignment, we have an
additional requirement of H∗ being in accordance with the base clock bs, enforced by respects-clock. The
(NSeq) rule for simple equations mentions the clock that annotates the deﬁning expression, checking that it
is consistent with the assumed history for the deﬁned variable x. The (NSfby’) rule for fby in an equational
context uses the semantic operation fby, which diﬀers from fbyL in that it requires its ﬁrst argument to be a
constant rather than a stream. Finally, the rule rule (NSncall’) for node call, now in an equational context,
is similar to (LSncall) except that it constrains the clock modulating the equation to be the base clock of
the input ﬂows.

34

