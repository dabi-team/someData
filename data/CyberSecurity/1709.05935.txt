Data Integrity Threats and Countermeasures in
Railway Spot Transmission Systems

Hoon Wei Lim, William G. Temple, Bao Anh N. Tran, Binbin Chen, Zbigniew Kalbarczyk and Jianying Zhou

1

7
1
0
2

p
e
S
8
1

]

R
C
.
s
c
[

1
v
5
3
9
5
0
.
9
0
7
1
:
v
i
X
r
a

Abstract—Modern trains rely on balises (communication bea-
cons) located on the track to provide location information as
they traverse a rail network. Balises, such as those conforming
to the Eurobalise standard, were not designed with security in
mind and are thus vulnerable to cyber attacks targeting data
availability, integrity, or authenticity. In this work, we discuss
data integrity threats to balise transmission modules and use
high-ﬁdelity simulation to study the risks posed by data integrity
attacks. To mitigate such risk, we propose a practical two-
layer solution: at the device level, we design a lightweight and
low-cost cryptographic solution to protect the integrity of the
location information; at the system layer, we devise a secure
hybrid train speed controller to mitigate the impact under various
attacks. Our simulation results demonstrate the effectiveness of
our proposed solutions.

I. INTRODUCTION

In railway systems, communications-based train control
(CBTC) [1], [2] and positive train control (PTC) [3] systems
are widely adopted and deployed in the Europe and the U.S.,
respectively. This is to ensure a safe distance between two
(successive) moving trains. In particular, knowledge of the
accurate location of a front train is critical for the train that
follows behind, so an appropriate speed limit and braking
distance can be estimated and imposed on the back train. This
enables shortening of headways between successive trains.

A. Communications-based Train Control (CBTC)

The principal intent of a train control system is to prevent
collisions when trains are traveling on the same track, either
in the same or opposite direction. CBTC was designed to
minimize headway, improve ﬂexibility and utilization through
the concept of moving blocks—giving the following train
a movement authority up to the exact rear-end location of
the lead train [2]. This,
in turn, can be realized through
a combination of: (i) accurate train location tracking based
on balises1 (also known as beacons) mounted between rails;
(ii) continuous track-to-train and train-to-track communication
of control and status information; and (iii) trackside and
train-borne vital processors to process the train status and

H.W. Lim is with Singtel. The work was done while the author was working

at the Institute for Infocomm Research (I2R), Singapore.

W.G. Temple and B. Chen are with the Advanced Digital Sciences Center

(ADSC), Illinois at Singapore, Singapore.

B.A.N. Tran is with Wargaming, Sydney, Australia. The work was done

while the author was with ADSC.

Z. Kalbarczyk is with the University of Illinois, Urbana-Champaign.
J. Zhou is with the Singapore University of Technology and Design

(SUTD).

1A balise, which is a passive RIFD tag, is originally a French word to

distinguish a beacon for railway than other beacons.

control data and provide continuous automatic train protection
(ATP) [1]. Typically, an ATP unit determines the permissible
safe speed proﬁle of a train on which it is installed. An auto-
matic train operation (ATO) unit then controls the train under
the supervision of the ATP. The latter controls the movement of
the train by making use of geographical data deﬁning physical
characteristics of a railway track, and location data associated
with the routes to be taken along the track by the train [4].

Generally, CBTC is developed speciﬁcally for metro (urban)
or high-capacity railway systems. It is not a standard product,
but mostly proprietary. In contrast, the European Rail Trafﬁc
Management System (ERTMS) and European Train Control
System (ETCS) [5] are developed for main lines (inter-city
or suburban) to address railway interoperability requirements
mandated by the European Railway Agency. Nevertheless,
commercial CBTC solutions by leading railway signaling
vendors, such as Alstom [6], Siemens [7] and Thales [8], are
typically compliant with the ERTMS/ETCS standards.

B. Location Tracking

An integral part of CBTC (and ETCS) is a spot transmission
system that provides train location information with high-
degree of precision. This is realized through transmission of
location data from a balise to a passing train. Balises need
to be powered up by a passing train in response to radio
frequency energy broadcast by a balise transmission module
(BTM) mounted under the train. Such data transmission is
intermittent on the order of fractions of a second. Moreover,
no handshake is required, so that the BTM is able to receive
as much data as possible when a train passes a balise even at
speed as high as 500 km/h.

Modern balise technology, introduced in early 1990s, was
pioneered by Alstom (French KVB) and Siemens (German
ZUB). The development of the Eurobalise standard was largely
inﬂuenced by them and some other vendors such as Ansaldo,
Bombardier, and Thales. Hence, the design of telegrams and
their usage for Eurobalise have been continuously reﬁned over-
time and well-tested to meet high-level of safety requirements.
However, while the Eurobalise technology has been designed
to be safe, security concerns, such as false data injection
and replay attacks, have never been seriously considered.
This is perhaps because the art and science of cybersecurity
was previously not yet well-understood when Eurobalise was
initially designed.

C. Contribution

In this paper, we study the Eurobalise spot transmission
system [9] that is adopted by ERTMS/ETCS and commer-

 
 
 
 
 
 
cial CBTC solutions. Particularly, we examine the encoding
and decoding schemes designed for the Eurobalise standard
and provide insights on potential security issues related to
intermittent wireless communications. (Note that we focus on
Eurobalise because of its internationally high adoption rate and
that its design details are publicly available.) We identify open
technical challenges that need to be addressed to improve the
security of the Eurobalise spot transmission system.

To address those challenges, we propose a lightweight and
low-cost cryptographic solution to protect the location integrity
of a train. In particular, we embed authentication code into
speciﬁc parameters used in Eurobalise telegrams such that any
intentional or unintentional changes to a telegram’s user data
would be detected. Our approach is lightweight in the sense
that the additional computational overhead introduced by our
technique is negligible compared to the allowance permitted
in the current standard for CBTC systems [1]. Furthermore,
our approach is low-cost because no additional hardware or
devices are required compared to the existing system.

Finally, to provide an additional layer of security assurance
for train operation, we leverage prior work on control-theoretic
countermeasures for balise data attacks [10] and integrate the
cryptographic countermeasure into a secure hybrid train speed
controller. Integrating those techniques preserves the advan-
tages of the telegram authentication scheme while providing
an operationally-viable response strategy when data integrity
attacks are detected. We demonstrate the performance of this
hybrid countermeasure through simulation using the case study
of train automatic stop control.

II. BALISE BACKGROUND

In this section, we give an overview of the design of
the Eurobalise spot transmission system as speciﬁed in the
UNISIG Standard SUBSET-036 [9]. We also introduce balise
applications in train control.

A. System Design

Spot transmission in our context refers to a phenomenon
when a transmission path exists between the trackside and the
on-board BTM at discrete locations. The location data (pre-
programmed and stored on a balise) is emitted and picked up
by a passing train only as its antenna unit passes over the
corresponding balise. The length of track on which the data
is passed and received is limited to approximately one meter
per balise.

Figure 1 shows the architectural design of the Eurobalise
spot transmission system. It comprises three major compo-
nents: on-board transmission equipment, balise, and trackside
signaling equipment. Generally there are two types of balises:
ﬁxed and controlled. However, from a vendor point of view the
devices are largely the same and this distinction is a matter of
conﬁguration (e.g., the two balise models in [7] are available
as either ﬁxed or controlled).

A ﬁxed balise is programmed to transmit the same data
in the form of a telegram to every train. Fixed balises
information such as the location of the
typically transmit
balise, geometry of the line (e.g., curves and gradients), and

2

Fig. 1. Key components of the Eurobalise transmission system [9].

any speed restriction(s) in that particular area. On the other
hand, a controlled balise is used when the spot transmission
system is required to be overlaid onto a traditional (national
or mainline) signalling system. The controllable balise is
typically connected to a lineside electronics unit (LEU), which
transmits dynamic data to the train. The LEU then integrates
with the conventional signaling system either by connecting to
the lineside railway signal or to the signalling control tower.2
The main role of the on-board transmission equipment is to
provide support for balise localization. It uses an amplitude
modulation on the 27.095 MHz frequency to power the pas-
sive balises, typically known as tele-powering. In addition to
generation of tele-powering signal, the on-board transmission
equipment provides a range of safety functionalities, including
immunity to environmental noise,
detection of bit errors,
and physical cross-talk3 protection. Further details on the
aforementioned functionalities can be found in [9].

B. Applications in Train Control

Balises, whether ﬁxed or controlled, are a vital component
of automatic train operation and automatic train protection sys-
tems. Balises may be deployed individually (e.g., to provide a
reference position) or in groups of up to eight to communicate
a larger quantity of information to a passing train [9]. In main
line systems, balises are often deployed in pairs along the track
at regular intervals (on the order of 1km apart) to support train
localization and help the train infer its direction of travel.

In automated train systems, such as a metro or an airport
people mover, balises serve another important purpose: helping
the trains stop correctly at
the station. More speciﬁcally,
balises placed near the station help the train determine when
to start braking and when it has reached the desired stop

2The LEU obtains variable data from the interlocking control system signal

on aspects, train location, temporary speed restrictions, and etc.

3The term “cross-talk” refers to a situation when a telegram is read from

a balise that should not be read, e.g., balise on another track.

3

• Cloning Attack: a special case of the Tampering Attack
where the attacker copies a valid telegram from one balise
onto another.

In addition, we assume that the attacker is knowledgeable
about railway systems and operating principles. Although we
focus on capability rather than intent, one could imagine
the above attacks being initiated by a disgruntled employee
or contractor, or a determined outsider (e.g., industrial es-
pionage). Since the outcome of a successful balise integrity
attack is likely to be a service disruption rather than a safety
incident, the negative outcome for a rail transit operator is
likely to be reputation damage (e.g., negative press, unhappy
commuters) or monetary loss (e.g., ﬁnes based on quality of
service metrics).

Note that we do not consider attacks involving the rede-
ployment of existing balises (e.g., removing a balise from
one location and reinstalling it elsewhere). However,
the
attacker may compromise multiple balises using the tampering
and/or cloning attacks. After countermeasures are introduced
(see Section V), the attacker does not have access to the
cryptographic key material used to protect data integrity.

B. Case Study: Train Automatic Stop Control

While the threat model presented above is applicable to any
train system using a Eurobalise transmission system, we select
a speciﬁc case study to provide an illustration of the impact
of attacks and the efﬁcacy of our countermeasures. We select
a train automatic stop control case study that has been used
in prior work to examine availability attacks targeting balise
transmission [10]. The model is based on real systems in use
today, as discussed in [15].

Fig. 3.

Illustration of a train stop with position input from ﬁxed balises.

In this case study a driverless train approaching a station
controls its braking action using balise position references
to stop at a desired position (see Figure 3). There are a
series of m balises at a station, B = {B1, B2, . . . , Bm}.
Note that the number m and spacing of balises may vary
between train systems depending on a vendor’s technology and
the application requirements. A stop is considered successful
if the train is within ±γ from the desired stop point Bm.
Each balise Bi is represented as a tuple Bi =< loci, loc(cid:48)
i >
where loci is the physical location of the balise and loc(cid:48)
i is
its reported location in the telegram. Positions are deﬁned
relative to the stopping point: in other words locm = 0, and
loc1 < loc2 < . . . < locm.

A number of train stop control algorithms have been
proposed and/or implemented in operational train systems.

Fig. 2. A reprogramming attack using a wireless balise programming tool.

point. In systems with platform screen doors, which prevent
passengers from accidentally falling into the track area, the
stopping requirements are stringent (on the order of tenths of
a meter) since the train doors and platform doors must align.

III. BALISE SECURITY CHALLENGES AND THREATS

Traditionally, railway systems have been designed with
safety in mind. Hence, current railway systems are generally
thought to provide a sufﬁciently high-level of safety for their
to
passengers, and it may be difﬁcult,
circumvent these safety mechanisms by exploiting vulnera-
bilities in the cyber aspect of railway systems. However, with
the advancement and availability of wireless communication
technology, it is unclear what could be the security impact to
a train spot transmission system.

impossible,

if not

Bloomﬁeld et. al. [11] conducted a security assessment
on ERTMS/ETCS [5], which includes the Eurobalise system.
Here is an excerpt from their ﬁndings:

“Messages from balises are protected against accidental
transmission errors and interference from outside the im-
mediate area of the track. However, the interface does
not address the possibility that an attacker might have
subverted existing balises, or placed a new balise on the
track at a strategic location.

An independent

study by Bezzateev, Voloshina, and
Sankin [12] shows that there is no concerted effort in devel-
oping not only safe, but also secure railway systems, in the
current ERTMS/ETCS standards.

We note that balises can now be activated and deactivated
by a wireless device, such as Alstom’s Balise Encoder Pro-
gramming and Test (BEPT) tool [13] and Siemens’s TPG
Eurobalise V2 [14]. This feature, partly motivated by safety
considerations, allows railway maintenance staff to work re-
motely away from the track to carry out programming of
telegrams on both ﬁxed and controlled balises. However,
conversely, this also opens up the possibility of unauthorized
re-programming of telegrams by a malicious insider or an
attacker in possession of such a tool with the intent of causing
a major train disruption.

A. Threat Model

In this paper, we consider data integrity and authenticity
threats arising from balise reprogramming devices, as shown
in Figure 2. Speciﬁcally, we assume that an adversary is able
to obtain or replicate a balise reprogramming device, gain
physical access to balises on the track, and implement one
of the following attacks:

• Tampering Attack: modifying or re-writing the telegram

on a balise to inject false data.

Programming deviceWireless connection(up to 50 m)Balise Read / write Attacker rewrites a baliseusing a handheld devicePos.B1B2B3B4B6B5Vel.4

Fig. 4. Block diagram of the stop control model with no countermeasures against balise attacks.

These include conventional proportional-integral-derivative
(PID) controllers, online learning algorithms [15], and the
use of pre-calculated velocity proﬁles (run curves) or upper
and lower velocity bounding curves (see [16] and references
therein). In this work we consider a learning-based braking
controller. As the train passes over balise Bi it will adjust its
deceleration rate α as it tries to achieve a full stop at Bm.
Adjustment is needed due to the various disturbances (e.g.,
actuator delay, friction, wheel slip) a train may encounter as
it slows. Further detail about the braking control model is
given in [10]. To provide context for the results presented in
Section VII, we summarize key elements of the model below.

Control Algorithm For this case study we employ the heuris-
tic online learning algorithm (HOA) in [15], which has been
successfully applied in an operational subway system over
several years. In this model there are three key parameters: the
expected deceleration without disturbances (αe
i ), the controller
deceleration (αc
i ), and the estimation of the actual deceleration
(αr
i ) realized by the train. The expected deceleration as a train
passes a balise is obtained from the equations of motion:

αe

i =

v2
i
2loc(cid:48)
i

.

(1)

Note that this takes a negative value since loc(cid:48)
i is negative
with respect to the zero point. The controller deceleration is
obtained by adjusting αe
in response to the observed train
i
deceleration. Speciﬁcally,
i+1 = αe
αc

i+1 − ηi(αr

i − αc

i ),

(2)

where

ηi+1 =

(cid:40)

0.95 × ηi
1.05 × ηi

if |αr
if |αr

i − αc
i − αc

i | > 0.05
i | ≤ 0.05

(3)

αr
i

is calculated using vi, vi+1, and the distance between

successive balises

Di = |loc(cid:48)

i| − |loc(cid:48)

i+1|.

(4)

The acceleration is given by:
i = (v2
αr

i )/2Di.

i+1 − v2
The actual train deceleration, αtrain
, is inﬂuenced by various
i
disturbances and system implementation features. We use a
train braking model which was empirically determined based
on data from an operating subway system [15]. The actual
deceleration of the train is given by the transfer function:

(5)

αtrain =

α0
Tps + 1

e−Tds

(6)

where Td is the system’s time delay and Tp is the time
constant. The overall control model, which is implemented
in Matlab/Simulink, is illustrated in Figure 4. In Section VII
we simulate this stop control process with and without attacks
on balise data to evaluate the countermeasures presented in
the following sections.

IV. RELATED WORK

In this section we give an overview of related prior work on
secure localization, cryptographic checksums, and commercial
train localization solutions to provide context for the counter-
measures introduced in Sections V and VI.

1) Secure Localization of Moving Objects: It is well-known
that the coordinates of a moving object, e.g., train, car, or
airplane, can be determined with a relatively high precision
with the aid of at least three veriﬁers (receivers). The latter are
typically satellites that are capable of individually calculating
the position of the moving object. This is generally known
as location veriﬁcation through multilateration, an approach
taken by [17], [18], [19], for example. However, such a
system was typically not designed to prevent unauthorized
or intentional modiﬁcation to the location data sent to the
veriﬁers. Hackers and academic researchers [20], [21], [22]
have demonstrated the feasibility of various message injection
and manipulation attacks against the multilateration system
used for next generation air trafﬁc control, i.e., Automatic
Dependent Surveillance - Broadcast (ADS-B). Furthermore,
deployment of navigation satellites or the like could be expen-
sive, and multilateration is highly susceptible to measurement
errors due to noisy environments.

2) Cryptographic Checksums: Checksum algorithms can
range from simple parity bits, ﬁngerprints, hash functions, to
more advanced error-detecting codes, such as cyclic redun-
dancy codes (CRCs) [23], and error-correcting codes, such as
Reed-Solomon codes (RSCs) [24]. An error-correcting code
(ECC) not only detects common errors, but also recovers the
original data in some cases when using appropriate parameter
choices. However, while checksums are often used to verify
data integrity, they should not be relied upon for verifying data
authenticity.

In cryptography, HMAC [25] and CBC-MAC [26] are
widely used MACs in real world applications. Nevertheless,
MACs are not designed to detect and correct errors, such as
random or burst errors, introduced during transmission as with
what ECCs do. Consequently, various techniques for crypto-
graphically secure checksum algorithms, which concurrently
detect errors and ensure data authenticity/integrity, have been
proposed [27], [28], [29]. A notable result is that a MAC may

BrakingControlBaliseDetectionPhysicalBrakingSystemcontrolaccel.velocity1/s1/s++++balisepositionvoactualaccel.baliselocationsxopositionbe constructed as the composition of a universal hash function
(UHF) with a pseudorandom function (PRF).4

It turns out that ECCs such as RSCs can be suitable candi-
dates for UHFs. As shown by Bowers, Juels, and Oprea [31], it
is possible to embed MACs in the parity blocks of ECCs, such
that a block is simultaneously both a MAC and a parity block.
They called this integrity-protected error-correcting code (IP-
ECC), a key enabler of their proposal of a distributed crypto-
graphic solution for high-availability and integrity-protected
cloud storage system. Independently, error-tolerant MACs
[32] and
based on Bose-Chaudhuri-Hocquenghem (BCH)
Reed-Solomon error-correcting codes have been investigated
in [33], [34]. More recently, Dubrova et. al. [35], [36] proposed
techniques for constructing cryptographically secure CRCs
based on different variants of generator polynomials.

Despite the above advancement

in secure cryptographic
checksum algorithms,
these techniques cannot be directly
applied to address our security concerns. This is due to various
unique physical and design constraints that exist in a train spot
transmission system (to be further discussed in Section V-B).
3) Commercial Patented Technologies: We have examined
relevant granted patents owned by various railway signaling
vendors, including Alstom [17], Ansaldo STS [37], General
Electric [38], Thales [39], [40], and Wabtec [41].

Our ﬁndings are that

the inventions disclosed in these
patents aim to improve on the accuracy and reliability of a train
location tracking system. Generally, these inventions make use
of one or a combination of the following methods:

• Multilateration through sensors or navigation satellites;
• Track map;
• Challenge-response protocol;
• Groups of transponders.
there exist

However,
trade-offs between deployment cost,
maintainability, accuracy/reliability. In comparison with our
approach, the above methods seem to be either much more
costly, or more challenging to deploy and maintain. For
example, Alstom has a method for secure determination of an
object location, particularly a vehicle moving along a known
course using multilateration based on at least 4 navigation
satellites (including radio and sensor), and relying on a secure
(integrity-protected) on-board mapping database for cross-
checking purposes. The latter may grow quickly if the database
also stores data such as track geometry and feature geo-
locations, and thus, may not be easy to maintain and high-
rate bandwidth is required to upload/update the database to an
on-board storage equipment.

V. INTEGRITY PROTECTION: DEVICE LEVEL

In this section, we present the ﬁrst of two countermeasures
designed to protect against balise data integrity attacks: a low-
cost and lightweight cryptographic solution that is especially
designed to augment the existing balise. Before introducing
this device-level countermeasure, we ﬁrst introduce additional
technical detail relating to balise telegrams and their coding

4A UHF is an algebraic function [30] that compresses a message or
data block into a compact digest based on a key. However, it is not a
cryptographically secure primitive.

5

strategy to provide necessary context. We then discuss the
technical challenges in addressing the security concerns and
the limitations of the current state-of-the-art. Finally, we
present the countermeasure and discuss the security assurance
it can provide, as well as its efﬁciency and deployment consid-
erations. Subsequently in Section VI, we discuss and propose
a complimentary system-level countermeasure to secure spot
transmission in the railway setting.

A. Telegrams and Coding Strategy

The Eurobalise telegram is designed with the following key

requirements in mind [42]:

• Safety: It must be safe in the presence of error events,
such as error bursts, random bit errors, bit slips, etc.;
• Large number of information bits: It must provide at

least hundreds of information bits;

• Mixing of format: For economic reasons, the telegram

length should be adjustable to user needs;

• Availability: Virtually all telegrams should be received

correctly.

To meet the above requirements, two compatible telegram
lengths, 1023 and 341 bits, respectively, are used.5 A distinct
and critical feature is that the transmission of a telegram
respects cyclic shifts. That is, the transmission needs not start
(or end) at the beginning of a telegram, and thus the detection
procedure is completely transparent with respect to cyclic
shifts of a telegram.

Fig. 5. Format of Eurobalise telegram [9].

The telegram format as speciﬁed in the Eurobalise stan-
dard [9] is illustrated in Figure 5. As mentioned, there are
two versions: a long format of length nl = 1023 = 93 · 11,
and a short format of length ns = 341 = 31 · 11. Using
the notation from [9], the bits of a telegram are denoted by
bn−1, bn−2, . . . , b1, b0 (with n = nl = 1023 or n = ns =
341). The numbering with descending indices (from left to
right) is chosen such that “left” and “right” conform with
Figure 5. The order of transmission is from left to right (but
need not begin with the leftmost bit bn−1). The format can be
described as follows:

• Shaped data which contains the user data scrambled and
shaped during encoding. In the long format, this block
consists of 913 bits, while in the short format, the block
consists of 231 bits.

• Control bits (cb) where the ﬁrst bit is the “inversion
bit”, which shall be set to zero.6 The other two control
bits are not currently used and are intended for future

5Note that 1023 is chosen because most good and well-understood cyclic
codes have lengths of the form n = 2m − 1 for some integer m. Also, 1023
is divisible by 3; this allows the use of a shorter cyclic code (341) together
with a longer code (1023) with no mixing cost.

6This is needed to detect the case when all bits of the telegram have been

inverted.

format variations. For the present format, these spare bits
shall be set to b108 = 0 and b107 = 1.

• Scrambling bits (sb) are used to store the initial state of
a scrambler that operates on the data bits before shaping.
• Extra shaping bits (esb) are used to enforce the shaping
constraints on the check bits independent of the scram-
bling. They are disregarded by the receiver (except that
the shaping constraints are checked).

• Check bits comprise 75 parity bits for error-detecting

and 10 bits for synchronization.

User data includes a 50-bit header (containing 14-bit balise
group identiﬁer allowing for a unique ID of every balise
group) followed by multiple packets. Typical data packets
used in a telegram are linking data (distance to the next
balise group), movement authority (maximum speed), gradient
proﬁle (uphill/downhill), and end of information.

In a nutshell, the encoding scheme for Eurobalises com-

prises the following three key steps:

1) Scrambling: This is to “shape” (or randomize) the
user data (or user bits) to facilitate robust and efﬁcient
modulation/demodulation during data transmission, i.e.,
eliminate long sequences of 0’s or 1’s. The data scram-
bling algorithm takes as input the scrambling bits (sb)
as initial state to derive a scrambling key S, which in
turn, is fed to a linear feedback shift register (LFSR)
along with the user data. We note that such a LFSR-
based randomization process is not designed to be
cryptographically secure7, but rather for data scrambling
purposes.

2) Substitution: In this step, the scrambled bits are parti-
tioned into blocks of 10 bits each. Each such block shall
be transformed into an 11-bit word by a substitution
table containing 1024 values (in the order of increasing
magnitude), which are listed in [9].

3) Computing check bits: In the last step, a cyclic code
based on Bose-Chaudhuri-Hocquenghem (BCH) [32] is
computed to ensure that the telegram is sufﬁciently re-
sistant to various form of transmission errors. However,
as we describe in Section IV, such cyclic code is not a
cryptographically secure checksum.

On the other hand,

the corresponding decoding scheme
to be performed by a receiver, i.e., on-board transmission
equipment, on the received bits involves the following steps:

1) Window shifting: Consider a window of n + r consec-
utive received bits, where r = 77 for long format and
r = 121 for short format. If the window has already been
shifted over 7500 bits, set r = n. Repeat the following
checks by shifting the window by 1 if any of them fails:
• Is the parity check satisﬁed, i.e., are the ﬁrst n
bits (considered as a polynomial) divisible by the
relevant generator polynomial?

• Do the r extra bits (rightmost in window) coincide

with the ﬁrst r bits (leftmost in window)?

• Are all 11-bit words valid?

7In the current Eurobalise encoding scheme, both sb and S are not

considered secret values.

6

2) Verifying control bits: This step checks the validity of
the inversion bit (b109) and the control bits (b108 and
b107).

3) Substitution and descrambling: In this step, the re-
ceived bits are partitioned into blocks of 11 bits each
and transformed back to blocks of 10 bits. Finally, they
are descrambled into the original user bits.

Full details of

the Eurobalise encoding and decoding

schemes can be found in [42], [9].

B. Technical Challenges

1) Setting: Eurobalise-compliant telegrams have relatively
short sizes, either 1023 or 341 bits, out of which 85 bits are
check bits. These ﬁxed sizes are designed to support various
train speed and different types/sizes of balise. The total number
of bits transferred in one train passage is dependent on the data
rate, the contact length (physical length of the balise) and the
train speed. Due to the nature of intermittent communication
in spot transmission, the block length (of a telegram) is chosen
such that the number of bits transferred per train passage is
always at least three block length.

Given the above requirement, it is not at all clear how one
could embed cryptographic secure authentication code which
offers a sufﬁcient level of security (i.e., integrity protection)
without expanding the sizes or modifying the format of
current telegrams. Moreover, as required by the Eurobalise
standard [9], up-link data transmission from a balise to the
antenna unit of on-board transmission equipment is performed
without handshaking. This rules out the possibility of deploy-
ing a classic challenge-response authentication protocol widely
used in wireless communication, for example those proposed
in [12], on ﬁxed balises.8

Furthermore, according to the IEEE standard 1474.1 for
CBTC [1], the trackside CBTC equipment reaction (nominal)
times should be between 0.07 and 1 sec, while the train-borne
CBTC equipment reaction times between 0.07 and 0.75 sec.
This implies that whatever techniques or mechanisms used
to protect the integrity of telegrams should be sufﬁciently
lightweight.

2) Legacy: Eurobalise-compliant telegrams have ﬁxed data
format and structure. Moreover, they have already been widely
deployed. Therefore,
ideally any introduction of security
mechanism for securing telegrams should not result in major
changes to the current speciﬁcation. For example, we could
easily destroy the algebraic properties embedded in a telegram
if we introduce new authentication code into the current tele-
gram structure in a naive way. Also, any message expansion
would not be desirable. This rules out the use of a standard
MAC in a straightforward manner.

3) Design Constraints: While the techniques proposed
in [31], [35], [36] could be a sensible starting point, there
remain non-trivial technical challenges that need to be ad-
dressed. For example, we may consider adopting the concept

8While in principle a challenge-response authentication protocol may be
deployable on controlled balises (which support both up-link and down-link
communications), controlled balises are designed for communicating variable
signal data from a traditional signalling system via the LEU [7], [9] (see
Section II-A for usage of LEU and controlled balises).

of integrity-protected error-correcting code (IP-ECC) [31].
More concretely (but informally), we may combine both MAC
and CRC for achieving corrupt-resilient MAC of the form

hk(m) ⊕ gk(cid:48)(m(cid:48))

where h is a linear UHF family, g is a PRF family, and the
⊕ operator is bitwise exclusive-OR. That is, the check bits of
a telegram (see Figure 5) is replaced by IP-ECC as deﬁned
above. However, we are still left with the following unsolved
issues:

• MAC destroys the cyclic property required in the tele-
gram, and thus, may prevent or slow down the decoding
process;

• IP-ECC would result in message expansion, since the
input (m(cid:48)) to the g function should be made available
to the receiver;

• Key k for the h function should be secret, however, the
key (i.e., polynomial generator) in the telegram is publicly
known;

The above challenges seem non-trivial and may require

techniques beyond the realm of coding.

C. Our Integrity Protection Approach

1) Assumption: Henceforth, we use encoder to denote
the Eurobalise encoding scheme and decoder to denote the
corresponding decoding scheme as described in Section V-A.
In our approach, we treat the encoder and decoder as “black
boxes”. That is, we use the encoder/decoder as it is as a
building block to which our technique is applied to realize our
solution. No modiﬁcation on the design of the encoder/decoder
is required.

2) Key Idea: The scrambling bits (sb) of a telegram is
unstructured and random-looking. Hence, these seem to be
a suitable avenue for embedding an authentication tag. Intu-
itively, we bind user data to scrambling bits (sb) such that any
change to the user data would result in different scrambling
bits. However, one issue with such an approach is that the
size of sb is too small, i.e., only 12 bits. We, therefore, also
make use of the corresponding 32-bit scrambling key (S),
which is taken as input by the LFSR circuit of the encoder,
as part of the authenticity/integrity check. More concretely,
we employ a technique that binds user data to the scrambling
bits (sb) and the LFSR scrambling key (S) of a telegram, in a
way that allows the reader (on-board transmission equipment)
to verify the authenticity and integrity of the telegram. This
way, sb can serve as an authentication tag without explicitly
expanding the size of the telegram. Recall that S is derived
from sb (in the current encoder). In addition, we require that
both sb and S are constructed based on a pair of distinct
and secret cryptographic keys (k0, k1), respectively. In other
words, our technique ensures that only an authorized party
with knowledge of the keys is able to generate and verify the
correct sb and S values for some user data. Since the length
of S is still relatively smaller than standard sizes used for
cryptographic primitives (e.g., 80 or 128 bits), we require that
the key pair (k0, k1) must be unique for each balise and no
tag veriﬁcation queries are allowed.

7

3) Implication: Our technique is designed such that any
modiﬁcation to user data would lead to incorrect descrambling
of the associated shaped data. In order to forge valid shaped
data, an adversary is forced to ﬁrst construct both valid sb and
S. This, in turn, requires knowledge of both keys (k0, k1). Note
that here, sb is analogous to a traditional MAC tag; hence, it
needs not to be kept secret and it should not leak information
about the key on which it was based. Similarly, S is generated
such that it leaks no information about the associated key from
which it was constructed.

D. Construction of Authentication Tag

In what follows, we use F to denote a key derivation
function, MAC a message authentication code scheme, and
PRF a pseudorandom function.

1) Key Generation: Let mk a master key and id a unique
balise identiﬁer.9 Our key generation algorithm then computes
the required authentication key pair for each balise by setting

k0 := F(mk, id, ‘0’), k1 := F(mk, id, ‘1’)

where |k0| and |k1| can be 128 bits, for example.10

2) Tag Generation: Our authentication tag generation algo-

rithm performs the following steps:

1) Take as input the user data U and the key k0, set sb to

be the ﬁrst 12 bits of MAC(k0, U );

2) Take as input the key k1 and the scrambling bits sb, set

S to be the ﬁrst 32 bits of PRF(k1, sb);

3) Feed S and the user data U into the encoder (as the

initial state of the LFSR circuit).

The output authentication tag here is sb. Our tag generation
algorithm is illustrated in Figure 6. Note that while sb is
explicitly speciﬁed in a telegram, S is not, but must be
computed from sb.

Fig. 6. Generation of authentication tag sb.

3) Tag Veriﬁcation: Given an authentication tag sb, our tag

veriﬁcation algorithm performs the following steps:

1) Take as input the key k1, set S(cid:48) to be the ﬁrst 32 bits

of PRF(k1, sb);

2) Feed S(cid:48) into the decoder to recover user data U (cid:48);
3) Take as input the key k0 and decoded user data U (cid:48), set

sb(cid:48) to be the ﬁrst 12 bits of MAC(k0, U (cid:48));
4) Check if sb = sb(cid:48), if so, veriﬁcation passes.

8

data would be detected through the tag veriﬁcation algorithm
described before.

We now (informally) examine the security guarantee pro-
vided by sb and S. The former is essentially a truncated MAC,
while the latter is a truncated output of a PRF.

1) Truncated MACs: There are two main classes of attack
on a MAC scheme, namely key recovery and forgery attacks.
In the former, an attacker attempts to discover the secret key
used to compute the MACs, while in the latter, an attacker
attempts to determine the correct MAC for a message without
knowledge of the corresponding secret key. When assessing
the security of a MAC scheme, we typically quantify the
resources needed for the attack in terms of the required
numbers of known message/MAC pairs, chosen message/MAC
pairs, and on-line MAC veriﬁcations. Mitchell [46] showed
that truncated MACs could be vulnerable to serious attacks
should the following two assumptions hold: (i) the attacker
is allowed to submit messages and accompanying MACs, and
determine whether or not the MAC is correct; and (ii) the
attacker is able to determine the degree of truncation of the
MAC, i.e., the MAC length. However, these two assumptions
do not hold in our context since our approach does not allow
any tag veriﬁcation queries to be made by the attacker, and the
MAC length is always ﬁxed, i.e., 12 bits. In other words, we
restrict the probability of a successful MAC forgery to 1/212.
A more recent study by Gaˇzi, Pietrzak, and Tessaro [47]
provides a proof of the security inherent in truncated CBC-
MACs (TCBC). Let n be a block size of TCBC and r a
relatively small (truncated) output length. They proved that no
polynomial-time adversary making q queries of length at most
l < 2n/4 to TCBC using a random permutation can distinguish
it from a random function (returning random output for each
distinct message), except with a distinguishing gap of

(cid:15)(q) = O

(cid:18) lq2

2n +

q(q + l)
2n−r

(cid:19)

.

It is easy to see that the above security bound is reasonable
for small r, as long as q is kept fairly small (< 2r) and n is
sufﬁciently large, for example n = 128.

Moreover, as pointed out in [47], there is a folklore belief
that given a secure MAC, truncating its output may actually
increase its security by hindering collision detection. However,
this has never been formally veriﬁed at the time of writing.

2) Pseudorandom Numbers: It is well-known that if PRF
is a pseudorandom function, and given a random x value,
PRF(x) can be served as a one-time pad outputting an
unpredictable, random value. In our setting, we deﬁne S =
PRF(k1, sb), where sb (truncated MAC) is considered random
and key k1 is used to ensure that S can only be correctly
computed by an authorized entity with knowledge of the
key. Moreover, since PRF is a one-way function, even if
the attacker has knowledge of S, no information about k1
can be learned. To construct a valid S(cid:48) for user data U (cid:48),
the attacker must ﬁrst forge a valid sb(cid:48) corresponding to
U (cid:48), and then predict S(cid:48) corresponding to the forged sb(cid:48).
This is computationally infeasible if MAC and PRF are both
cryptographically secure.

Fig. 7. Veriﬁcation of authentication tag.

It is important to note that we treat the current encoder
and decoder as black boxes in our approach, in the sense
that we did not make modiﬁcation to existing the LFSR-based
scrambling and check bits generation algorithms. Instead, we
merely deﬁne how sb and S are computed before the actual
encoding process takes place, and how these values are veriﬁed
before decoding.

4) Key Management: Standard key management techniques
can be applied to derive and protect the master key mk. For
example, each railway line may use a distinct mk derived
from a root key owned by the relevant railway operator. We
assume that all keys, including mk, k0, and k1 are not updated
regularly, unless is necessary due to security compromise,
for example. Hence, it is critical that the root key and each
master key are appropriately protected, for example, through a
tamper-resistant storage system. We envision that one possible
way to update the keys (ki for i ∈ {0, 1}) associated with a
speciﬁc balise is by setting

ki := F(mk, id, ver, i)

where ver denotes a version number. Such a key diversiﬁ-
cation technique is commonly used in public transportation
systems based on contactless smart card payment technology.
For example, EZ-Link cards deployed in Singapore are com-
pliant to the CEPAS standards [43], [44], which in turn, require
that each terminal or card reader has embedded multiple
distinct master keys in a secure access module. This is to
avoid reissuance of a master key in the event of key exposure
during the life-time of the terminal or reader. Formal security
analysis of key derivation and diversiﬁcation techniques based
on bootstrapped master keys has been well-studied, see for
example [45].

E. Security

Recall that our security goal is to ensure that the adversary
is unable to forge or construct valid authentication tag (sb)
and LFSR scrambling key (S) without
the knowledge of
keys (k0, k1), respectively. Since both sb and S are bound
to the corresponding user data, any modiﬁcation to the user

9We assume that the balise identiﬁer can be extracted from a track-map

database accessible by the on-board transmission module.

10Different key sizes may be used but may result in different security vs.

efﬁciency trade-offs.

F. Efﬁciency

We tested our algorithms implemented in Python 3.4.3, on
Inter Core i3-2120 CPU at 3.30 GHz and 8GB of RAM, and
running with Ubuntu 14.04.4 LTS. Particularly, we compared
the computation time required to calculate S in both cases: cur-
rent Eurobalise encoder/decoder (without security protection),
and our cryptographically integrity-enhanced approach. Our
experimental results (taken over 10 iterations) are summarized
in Table I.

TABLE I
COMPUTATION TIME (IN MS) FOR CALCULATING THE S VALUE.

Encoder Decoder

Current Eurobalise
Our approach

0.0047
0.0274

0.0016
0.0145

Our evaluation shows that the additional computational cost
incurred for ensuring data integrity protection is negligible,
approximately in the range of between 0.013 and 0.023 ms.
Note here that the encoder is typically executed ofﬂine (during
initialization or deployment of balises) using a balise encoder
programming tool [13], [14]; while the decoder is run by an
on-board transmission equipment with reasonably powerful
computing resources. Also, we do not evaluate the latency
caused by our algorithms because we did not modify the
format and size of the Eurobalise telegram and its parameters.
Hence, in practice, we do not foresee any noticeable perfor-
mance impact to the actual deployment of a spot transmission
system.

G. Deployment

We reiterate that our technique of embedding an authen-
tication tag does not require any changes to the existing
standardized encoding/decoding schemes. What is needed is to
update the software of a balise programming tool (e.g., [13],
[14] such that the scrambling bits (sb) and the scrambling key
(S) are generated as speciﬁed before. Moreover, the on-board
transmission equipment of a train needs to be updated with
our tag veriﬁcation algorithm and given access to the required
cryptographic keys in a secure manner.

VI. INTEGRITY PROTECTION: SYSTEM LEVEL

In this section, we discuss the second of our two coun-
termeasures: a system-level approach considering information
from multiple sources to determine whether the telegram
received from a balise is trustworthy.

A. Importance of System-level Logic

Recall from Section III-A that we consider two types
of attacks on balise spot
tampering
attacks, and cloning attacks. The device-level countermeasure
presented above secures the communication interface between
a balise and the train’s onboard receiver. The presence of an
authentication tag addresses tampering attacks—an adversary

transmission systems:

9

who does not possess the necessary keys will be unable to
program a valid (modiﬁed) telegram on a balise.

While this authentication scheme provides a strong layer of
protection on its own, there are two important areas where
security can be further enhanced. First, although a train
receiving data from a compromised balise would be able to
determine whether or not the data were modiﬁed, this device-
level countermeasure on its own does not address cloning
attacks. An attacker could copy a valid telegram onto multiple
balises. A broader system perspective, considering multiple
balises and the manner in which they are deployed and used
by passing trains, is necessary to cover both types of attacks.
Furthermore, a train relying on data from balises for a real-
time control process such as speed control needs to know more
than simply whether balise data is trusted or not: it needs a
response strategy to address situations where data is missing
or invalid. The system-level countermeasure we present in
the remainder of this section seeks to address these gaps. To
provide a speciﬁc system use case, we use the train automatic
stop control scenario introduced in Section III-B.

B. Improving Security from System-level Insight

The design of our countermeasure is based on four key
observations about stop control for automated trains, which
we discuss in the paragraphs below.

Observation 1: Trains can leverage the trustworthy and
static physical conﬁguration of a rail system. In a railway
environment, the distance between stations and the position
of balises are ﬁxed once the system is built and put into
operation. It is a common practice to load such physical-
world information into a train’s on-board computers (e.g.,
track maps discussed in IV) and a braking controller can
use that trustworthy information to make decisions. Note that
our threat model in Section III-A assumes the attacker cannot
change the physical setup, e.g., moving a balise to a different
position. Balises have detailed installation requirements gov-
erning orientation and distance from the track [9], therefore
a physical movement attack would be time-consuming and
easier to detect than a re-programming attack.

Observation 2: Trains can leverage less accurate but more
trustworthy sensing data. A train can infer its location using
multiple onboard sensors, such as a tachometer or Doppler
radar sensor. The location estimate from onboard sensors is
not as accurate as the value obtained directly from balises. For
example, estimates based on wheel rotation can be inaccurate
when the wheels slip on the rails. As a result, the onboard
estimation error accumulates with the distance that a train
travels from the last reference point. Fortunately, with modern
information fusion techniques, the onboard system is able
to provide well-bounded accuracy based on these imperfect
sensors. For ETCS, the minimum accuracy requirement for
on-board train position measurement is ±(5m + 5%d) where
d is the distance travelled since the last reference point [48].
In practice, the performance can be better: for example an
error less than ±20m for every 1000m travelled (±2%d [49]).
Under our threat model, we consider the on-board location
estimate to be more trustworthy than location information
received from balises, however it is less accurate.

10

(a) Block diagram of the train stop control model with countermeasure logic.

(b) Details of conservative controller

Fig. 8. Resilient train stop control logic with anomaly detection & correction and conservative braking controller.

Observation 3: Trains can reduce stopping error by sac-
riﬁcing performance As a train approaches a station, it will
ideally stop with high accuracy, i.e., on or close enough to
the target point (balise Bm in our model) for passengers to
alight, and it should complete the process of slowing and
stopping in the shortest time possible, subject to operating
constraints (e.g., maximum braking rate). In normal situations,
the position references received by ﬁxed balises help the
train optimize its braking curve for these two objectives. As
we will show in Section VII, tampering or cloning attacks
can make the train overshoot or undershoot the target stop
point by a wide margin. However, even in the case where a
train cannot receive any trustworthy position input from ﬁxed
balises during the approach, it can still stop close to the right
position by travelling at a low speed and applying the brake
when it passes the controlled balise at the stop point which
interfaces with the platform screen doors. If the speed is low
enough, the train should be able to stop within a short distance
from the correct position. The drawback of this conservative
strategy is that the train will take longer to stop.

Observation 4: Trains can use trusted information to
verify information from untrusted sources. As discussed above,
knowledge of the physical conﬁguration of the train system
(e.g., station, balise locations) and the position estimate de-
rived from on-board sensors are considered to be trustworthy
information. This information can be used to cross check
the input from less trustworthy sources: namely, the balise
telegrams. Once the information from balises is deemed trust-
worthy, it can be used to improve performance.

C. Our Resilient Control Approach

Based on the four system-level observations above, we have
developed a software-only countermeasure for dealing with
attacks on balise telegrams in train automatic stop control sys-
tems. As with the device-level countermeasure in Section V,
this scheme does not require changes to the legacy balise
infrastructure that is in use today: it simply requires new
braking logic in the trains themselves.

To describe our countermeasure in detail we introduce
some additional notation: let p denote the train’s position as
it approaches a station; let pest denote the train’s onboard
position estimate, which has an associated position error δ;
let vcon denote a reduced speed setting. At a high level,
our resilient controller uses two parallel control modules—
the original controller (e.g., PID, HOA, or GOA [15]), and
a new conservative controller—which are selected based on
an anomaly detection and correction module, which includes

integrity checking via the scheme in Section V. This control
architecture is shown in Figure 8(a). The logic is described
in Algorithm 1. Note that this controller is effective against
attacks rendering balise telegrams unavailable [10] as well as
against the tampering and cloning attacks discussed in this
paper.

By default a train will operate using the normal controller:
in this case the heuristic online algorithm [15]. If the Anomaly
Detection & Correction module detects that there is a balise
missing, by using it’s knowledge about the physical world
setup, its onboard estimated position pest in conjunction with
whether or not data is received, (Algorithm 2) it will fall
back to a conservative controller (Observation 3). Such a
detection is possible, thanks to the static physical-world setup
information (Observation 1) and the less accurate but more
trustworthy local sensing data (Observation 2).

Internally, as shown in Figure 8(b), the conservative con-
troller is composed of 2 PID controllers which act depending
on the velocity of the train. The ﬁrst PID controller, PID1,
is tuned to be more aggressive with the main objective of
quickly bringing down the speed of the train to vcon. The
second PID controller PID2 adopts less aggressive parameters
to stably maintain the speed of the train at vcon till it reaches
the stop marker. In addition to the two PIDs,
there is a
multiplexer block to switch between these two PIDs as well
as (αmax). At ﬁrst PID1 is selected, and the multiplexer only
switches to PID2 when the velocity of train reaches vcon. Once
the stop marker is detected, the multiplexer will switch to
maximum braking of αmax. There is a need to select between
multiple PIDs at different velocity stages due to conﬂicting
requirements in terms timing and stability. To explain this
rationale, assume there is only PID1 in the design. PID1
promptly helps lower down the speed of the train to vcon but
because of its aggressively-tuned nature, maintaining the speed
at vcon becomes a challenge. Wide undershooting can make
the velocity 0, stopping the train ahead of the stop marker.
On the other hand, if there is only PID2 in the design, the
slower response of this controller takes the train much longer
time to reach vcon. By the time the velocity reaches vcon,
there can be cases that when the stop marker is detected, the
velocity of the train is much higher than vcon and switching to
αmax stil fails to to make it stop within the allowable stopping
error. Through experiments we obtain the parameters for PID1
Kp = 0.8423, Ki = 0.0648, Kd = 0.4082 as and for PID2 as
Kp = 0.0377, Ki = 0.0002, Kd = 0.2205.

AnomalyDetection&Correctioncontrolaccel.velocity1/s++voactualaccel.balisevalueDefaultBrakingControlConservativeBrakingControlPhysicalBrakingSystemvelocitybaliseindexcorrectedbalisevalue++noisecorrectedbalisevaluePID1PID2αmaxcontrolaccel.velocityvconbalise valueSwitch from DEFAULT to CONSERVATIVE;

if Running controller is DEFAULT then
if Balise-Missing() returns TRUE then

Algorithm 1 Resilient Train Stop Control
1: while true do
2:
3:
4:
5:
6:
7:
8:
9:
10:
11: end while

else if Encountering a new balise then

Update the trustworthy information;

end if

end if

end if

if Derive-Trustworthy-Info() returns TRUE then

Algorithm 2 Balise-Missing()

// Train is provided with known balise locations before
operation. In this paper, the known locations are assumed
to be [-100, -64, -36, -16, -4]

1: update pest and δ based on trustworthy information;
2: if there is a balise location loci such that abs(pest) < abs(loci)−
δ or abs(pest) < abs(loci+1) + δ while no position reference
of loci has been received then

return TRUE;

3:
4: end if
5: return FALSE;

Algorithm 3 Derive-Trustworthy-Info(), with (pest, δ) being
the estimate so far.
1: if AuthenticateBalise()=TRUE then // could be correct balise or

replay attack

if reported position loc(cid:48)

i satisﬁes |pest − loc(cid:48)

return (loc(cid:48)

i, 0) as new (pest, δ);

i| < δ then
// otherwise estimate

2:
3:

remains
end if

4:
5: else if AuthenticateBalise()=FALSE then // balise has been

6:

7:
8:

9:
10:
11:
12:
13:
14:

15:

tampered with. Try to recover useful information

if there is a unique known balise position loci such that |pest −

loci| < δ then

return (loci, 0) as new (pest, δ);

else

// there are multiple known balise positions loci ∈ B

such that |pest − loci| < δ

set r ← {local = pest, candidates = B};
append r into R, an unveriﬁed record list;
if there are multiple records r1, . . . rk in R then

for i in 1, . . . , k − 1 do

d ← rk.local − ri.local;
compute

distance

between

all

combinations

of

ri.candidates and rk.candidates;

if there is only one pair of candidates (locl, locm) that

has distance of d then

return (locm, 0) as new (pest, δ);

end if
end for

16:
17:
18:
19:
20:
21: end if

end if

end if

VII. EVALUATION

From Sections V and VI we see that balise transmission can
be secured at both the device and system levels. In this section,
we simulate a train stopping at a station to illustrate the
negative impact of tampering and cloning attacks, as well as
the beneﬁts derived from implementing our countermeasures.
We start by describing simulation parameters and the normal
(no attack) scenario to illustrate how automated trains use

11

balise input during a stop.

A. Normal Braking Scenario

As discussed in Section III-B, this scenario concerns an
automated train approaching a station and using position data
from sequence of balises to adjust its brake force and stop in
alignment with the platform screen doors. This model is based
on a particular system used in Asia [15], however we are aware
of other train lines employing a similar operating principle
with differences in the balise layout and braking control.

We consider a train approaching a station with balises
located at positions loc = [−100, −64, −36, −16, −4, 0]. The
ﬁrst ﬁve balises are ﬁxed, while the ﬁnal one is controlled.
There are several parameters that characterize the train stop
scenario. We assume an initial position of −100m, initial ve-
locity of 10m/s, maximum deceleration of αmax = −1m/s2,
and an allowable stopping error of γ = 0.3m. In our analysis
we vary the train brake parameters—the time delay (Td) and
time constant (Tp)—to capture the impact of control distur-
bances and variations between different trains. We consider
default values Td = 0.6 and Tp = 0.4.

To illustrate the train’s braking performance in the normal
(no attack) case, Figure 9(a) shows the train’s acceleration
curve under the default simulation setting described above.
Observe that at each balise’s location the train’s brake con-
troller acceleration changes and the actual acceleration follows
the change based on parameters Td and Tp. Figure 9(b) shows
the resulting train speed curve, which achieves a smooth and
accurate stop.

If an attacker carries out a tampering or cloning attack,
the timing of brake actions or the degree of braking may be
altered, leading to a stop outside of the allowable range of
±0.3m from the target. If a train stops too far before or after
the target it needs to correct its position. For an unattended
train (the highest grade of automation, with no driver onboard)
this can be done with a process called jogging, where the
train makes a series of incremental movements (< 1m) until
it reaches the target. Alternatively, a human operator may
intervene. In either case, the result will be a delay in the train
network: the train affected by the attack will take more time
at the station, thereby delaying trains behind it.

B. Tampering Attack

Attack Impact: An attacker wishing to disrupt train oper-
ations could tamper with balises deployed near train stations.
Intuitively, the further a train can be made to stop away from
the target point, the greater the disruption. One potential data
integrity attack is re-programming the ﬁrst (earliest) balise in
a stopping sequence to make the train think it has already
reached, or is about to reach, the stop point. Using the TASC
model, we set loc(cid:48)
1 = loc5 = −1 to make the train think it is
about to reach the target11.

Figures 10(a) and 10(b) show the acceleration and speed
proﬁles of the train as it proceeds toward the stopping point

11Depending on the system implementation, it may not be possible for a

ﬁxed balise such as B1 to impersonate a controlled balise (i.e., B6).

12

(a) Train acceleration with no attacks.

Fig. 11. Speed proﬁle, response to Tampering attack, initial pest = −80.

(b) Train speed with no attacks.

Fig. 9. Train acceleration/speed with HOA controller and default parameters.

(a) Train acceleration with low value attack.

(b) Train speed with low value attack.

Fig. 10. Train acceleration/speed with B1 altered to a low value (-4).

(location 0). The high speed of the train combined with the
sudden (perceived) need to stop results in the acceleration
controller saturating (dashed line is overlaid with the y axis)
and the train slowing at its maximum rate of −1m/s2. As
a result the train stops 43.9m before the correct position,
and the passengers would be stranded until the train was
able to adjust its location. The adjustment could be done via
human intervention or by an automatic routine to slowly and
incrementally move the train forward (referred to as jogging).
Countermeasure Effectiveness: Consider the attack shown
in Figure 10, where the ﬁrst balise in the stop sequence is
tampered with to report a low value (in this case −1m),
causing the train to stop early. Implementing the authentication
countermeasure in Section V renders the attack infeasible,
however if the train simply ignores input from balise B1,
the result is identical to an availability attack on that balise,
which has been shown to cause an overshoot of 1.3m beyond
the stop point [10]. This error, while much smaller than
the original −43.9m distance error, is still outside of the
allowable ±0.3m range and would therefore cause a delay.
Adding additional system-level logic to respond gracefully, as
described in Algorithms 1–3, allows the train to infer (from
its onboard position estimate) that it has passed balise B1, and
begin braking in an appropriate manner. The result is a smooth
stop with an allowable stopping distance error of 0.15m if the

initial pest = −120, or 0.23m if the starting position estimate
is pest = −80. In the latter case, the train believes it has
missed the ﬁrst balise and switches to the conservative braking
controller; this results in a swift deceleration followed by a
slow approach to the target point, as shown in Figure 11.

C. Cloning Attack

Attack Impact: An interesting observation from the HOA
braking control model is that the position input from consec-
utive balises must be different. In Equation 5 if loc(cid:48)
i+1
there is a division by zero. It is unclear whether the operational
implementations of the HOA algorithm cited in [15] would
be vulnerable, or if additional logic addresses this issue. In
our model, we implemented two error handling strategies:
(i) the train brakes at full force αmax (similar to emergency
braking); (ii) the train continues decelerating at its current rate,
effectively ignoring the balise.

i = loc(cid:48)

1 = loc(cid:48)

As was the case in the early stop attack, an adversary
wishing to cause a large disruption would tamper with the ﬁrst
few balises, since the train is far from the station and moving
quickly. We consider an attack where an attacker tampers with
B2 causing loc(cid:48)
2 = −100. The results are shown in
Figure 12 for both error handling strategies. In both cases, the
train stops before the target point, and outside of the allowable
range: Figures 12(a) and 12(b) show a stop at -21.8m in the
case with full braking, while Figures 12(c) and 12(d) show a
less severe position error of -4.22m for ignoring the repeated
input. In both cases, the train would incur additional waiting
time at the station, and this additional time would propagate
through the system as shown in [10].

Countermeasure Effectiveness: Consider the attack shown
in Figure 12, where the second balise in the stopping sequence
is used in a replay attack to impersonate the previous balise.
Even after adding balise authentication,
this replay attack
(copying B1’s data to B2) is still possible. However, by
using the train’s knowledge about the static (physical) balise
deployment and local position estimate in Algorithm 3 the
attack can be detected and corrected. In the cases where the
train’s onboard position estimate when it encounters the ﬁrst
balise is −120m or accurate at 100m, the train obtains a useful
data point and therefore knows that the second balise it passes
should be loc2 = −64 even if the reported value is wrong. As
a result, the train stops normally with a small error of 0.15m.
The worst case occurs when the train’s initial pest = −80.
As in the previous attack (Figure 11), the train believes it has
missed a balise, so it switches to the conservative controller
and stops at 0.23m.

Position[m]-100-64-36-16-40Acceleration[m/s2]-1.25-1-0.75-0.5-0.2500.25ActualControllerPosition[m]-100-64-36-16-40Velocity[m/s]0246810Position[m]-100-64-36-16-40Acceleration[m/s2]-1.25-1-0.75-0.5-0.2500.25ActualControllerPosition[m]-100-64-36-16-40Velocity[m/s]0246810Position[m]-100-64-36-16-40Velocity[m/s]024681013

(a) Train acceleration with duplicate attack (full brake).

(b) Train speed with duplicate attack (full brake).

(c) Train acceleration with duplicate attack (maintain accel.).

(d) Train speed with duplicate attack (maintain accel.).

Fig. 12. Train acceleration/speed with B1 altered to same as B2.

VIII. CONCLUSION

[9] P. Lundberg and P. Prieels, “UNISIG FFFIS for Eurobalise,” SUBSET-

In this work we present two countermeasures to secure
railway spot transmission systems against data integrity and
authenticity attacks. The ﬁrst
technique, a low-cost and
lightweight authentication method, allows a passing train to
detect whether the telegram data provided by a Eurobalise-
compliant beacon has been altered. The second countermea-
sure, a resilient speed controller for train stop control applica-
tions, leverages this authentication scheme and adds another
layer of security by providing an operationally-viable response
strategy when bad data is encountered. Both countermeasures
are applicable to legacy systems, in the sense that no additional
hardware or sensors are required.

ACKNOWLEDGMENTS

This work was supported in part by the National Research
Foundation (NRF), Prime Minister’s Ofﬁce, Singapore, un-
der its National Cybersecurity R&D Programme (Award No.
NRF2014NCR-NCR001-31) and administered by the National
Cybersecurity R&D Directorate, and supported in part by
Singapore’s Agency for Science, Technology, and Research
(A*STAR) under a research grant for the Human-centered
Cyber-physical Systems Programme at the Advanced Digital
Sciences Center.

REFERENCES

[1] IEEE Vehicular

Technology

Society,

Communications-Based Train Control
Functional Requirements (1474.1-2004),” 2004.

“IEEE

Standard
(CBTC) Performance

for
and

[2] R. D. Pascoe and T. N. Eichorn, “What is communication-based train
control?” IEEE Vehicular Technology Magazine, 4(4): 16–21, 2009.
[3] J. C. Peters and J. Frittelli, “Positive train control (PTC): Overview and

policy issues,” congressional Research Service R42637, 2012.

[4] G. D. Newman, “Railway signalling system,” Patent, patent No. US

5437422 A, granted in Aug 1995.

[5] “The european rail trafﬁc management system,” http://www.ertms.net/.
[6] “Signaling solutions: URBALIS CBTC,” https://signallingsolutions.com/

wp-content/uploads/ﬁles/urbalis.pdf.
[7] “Siemens Trainguard Eurobalise

s21

and

s22,”

https://www.

mobility.siemens.com/mobility/global/SiteCollectionDocuments/
en/rail-solutions/rail-automation/train-control-systems/
trainguard-eurobalise-s21-s22-en.pdf.

[8] “Thales SelTrac CBTC,” https://www.thalesgroup.com/sites/default/ﬁles/

asset/document/cbtc brochure 0.pdf.

036, Issue 3.1.0, Dec 2015.

[10] W. G. Temple, B. A. N. Tran, B. Chen, Z. Kalbarczyk, and W. H.
Sanders, “On train automatic stop control using balies: Attacks and
a software-only countermeasure,” in Proc. of the IEEE Paciﬁc Rim
International Symposium on Dependable Computing (PRDC), 2017.

[11] R. Bloomﬁeld, R. E. Bloomﬁeld, I. Gashi, and R. J. Stroud, “How
secure is ERTMS?” in Proceedings of the Workshop on Dependable
and Secure Computing for Large-scale Complex Critical Infrastructures
(DESEC4LCCI), 2012, pp. 247–258.

[12] S. Bezzateev, N. Voloshina, and P. Sankin, “Joint safety and secu-
rity analysis for complex systems,” in Proceedings of
the Confer-
ence of Finnish-Russian University Cooperation in Telecommunications
(FRUCT) Association, 2013.

[13] “Alstom ATLAS trackside ETCS solution,”

http://www.alstom.

com/Global/Transport/Resources/Documents/brochure2014/Atlas%
20Trackside%20-%20Brochure%20-%20EN.pdf.

[14] “Siemens TPG Eurobalise V2 web test and programming device,”
http://w1.siemens.ch/mobility/ch/de/topics/download-center/Documents/
Siemens%20Unterhalts-%20und%20Diagnosesysteme/9096-316
Test-und Programmierger%C3%A4t TPG-Eurobalise V2-Web en.pdf.
[15] D. Chen, R. Chen, Y. Li, and T. Tang, “Online learning algorithms for
train automatic stop control using precise location data of balises,” IEEE
Trans. Intell. Transp. Syst., 14(3:1526–1535, 2013.

[16] S. Di Cairano, M. Ulusoy, and S. Haghighat, “Automatic train stop

control system,” Patent, US 9387866 B1, granted in Jul 2016.

[17] J.-P. Franckart, “Method for secure determination of an object location,
preferably a vehicle moving along a known course,” Patent, US 6768447
B2, granted in Jul 2004.

[18] M. Strohmeier, V. Lenders, and I. Martinovic, “Lightweight location
veriﬁcation in air trafﬁc surveillance networks,” in Proceedings of the
ACM Workshop on Cyber-Physical System Security (CPSS), 2015, pp.
49–60.

[19] M. Sch¨afer, V. Lenders, and J. B. Schmitt, “Secure track veriﬁcation,”
in Proceedings of the IEEE Symposium on Security and Privacy (SP),
2015, pp. 199–213.

[20] R. Kunkel, “Air trafﬁc control insecurity2.0,” in DEFCON 18, Jul 2010.
[21] A. Costin and A. Francillon, “Ghost in the air (trafﬁc): On insecurity
of ADS-B protocol and practical attacks on ADS-B devices,” in Black
Hat USA, Jul 2012.

[22] M. Sch¨afer, V. Lenders, and I. Martinovic, “Experimental analysis of
attacks on next generation air trafﬁc communication,” in Proceedings
of the International Conference on Applied Cryptography and Network
Security (ACNS), 2013, pp. 253–271.

[23] W. W. Peterson, “Cyclic codes for error detection,” in Proceedings of

the Institute of Radio Engineers (IRE), 1961, pp. 228–235.

[24] I. S. Reed and G. Solomon, “Polynomial codes over certain ﬁnite ﬁelds,”
Journal of the Society for Industrial and Applied Mathematics (SIAM),
8(2):300–304, 1960.

[25] M. Bellare, R. Canetti, and H. Krawczyk, “Keying hash functions for
message authentication,” in Advances in Cryptology – Proceedings of
the Annual International Cryptology Conference (CRYPTO), 1996, pp.
1–15.

Position[m]-100-64-36-16-40Acceleration[m/s2]-1.25-1-0.75-0.5-0.2500.25ActualControllerPosition[m]-100-64-36-16-40Velocity[m/s]0246810Position[m]-100-64-36-16-40Acceleration[m/s2]-1.25-1-0.75-0.5-0.2500.25ActualControllerPosition[m]-100-64-36-16-40Velocity[m/s]0246810[26] M. Bellare, J. Kilian, and P. Rogaway, “The security of cipher block
chaining,” in Advances in Cryptology – Proceedings of the Annual
International Cryptology Conference (CRYPTO), 1994, pp. 341–358.

[27] M. O. Rabin, “Fingerprinting by random polynomials,” Center for
Research in Computing Technology, Harvard University, vol. Technical
Report TR-CSE-03-01, 1981.

[28] H. Krawczyk, “LFSR-based hashing and authentication,” in Advances
in Cryptology – Proceedings of the Annual International Cryptology
Conference (CRYPTO), 1994, pp. 129–139.

[29] V. Shoup, “On fast and provably secure message authentication based
on universal hashing,” in Advances in Cryptology – Proceedings of the
Annual International Cryptology Conference (CRYPTO), 1996, pp. 313–
328.

[30] L. Carter and M. N. Wegman, “Universal classes of hash functions,”
Journal of Computer and System Sciences, 18(2):143–154, 1979.
[31] K. D. Bowers, A. Juels, and A. Oprea, “HAIL: A high-availability and
integrity layer for cloud storage,” in Proceedings of the ACM Conference
on Computer and Communications Security (CCS), 2009, pp. 187–198.
[32] R. C. Bose and D. K. Ray-Chaudhuri, “On a class of error correcting
binary group codes,” Information and Control, 3(1)68–79, 1960.
[33] C. C. Y. Lam, G. Gong, and S. A. Vanstone, “Message authentica-
tion codes with error correcting capabilities,” in Proceedings of the
International Conference on Information and Communications Security
(ICICS), 2002, pp. 354–366.

[34] R. Ge, G. R. Arce, and G. D. Crescenzo, “Approximate message authen-
tication codes for n-ary alphabets,” IEEE Transactions on Information
Forensics and Security, 1(1):56–67, 2006.

[35] E. Dubrova, M. N¨aslund, and G. Selander, “CRC-based message au-
thentication for 5G mobile technology,” in Proceedings of the IEEE
TrustCom/BigDataSE/ISPA Conference, 2015, pp. 1186–1191.

[36] E. Dubrova, M. N¨aslund, G. Selander, and F. Lindqvist, “Lightweight
CRC-based message authentication,” IACR Cryptology ePrint Archive,
vol. 2015, p. 1138, 2015.

[37] M. B. Haynie and W. R. Laurune, “System and method for vitally
determining position and position uncertainty of a railroad vehicle
employing diverse sensors including a global positioning system sensor,”
Patent, US 8296065 B2, granted in Oct 2012.

[38] J. M. Fries, “Systems and methods for determining route location,”

Patent, US 8924066 B2, granted in Dec 2014.

[39] A. Kanner, “Vehicle localization system,” Patent, US 8477067 B2,

granted in Jul 2013.

[40] B. McKillican and A. Kanner, “Method of determining the position of
a vehicle moving along a guideway,” Patent, US 9085310 B2, granted
in Jul 2015.

[41] J. D. Kernwein, “System and method to determine train location in a

track network,” Patent, US 8214091 B2, granted in Jul 2012.

[42] “Transport research EURET rail

transport VII - 5, Eurobalise sub-

system,” 1996.

[43] F. Kerschbaum, H. Lim, and I. Gudymenko, “Privacy-preserving billing
for e-ticketing systems in public transportation,” in Proceedings of the
ACM Workshop on Privacy in the Electronic Society (WPES), 2013, pp.
143–154.

[44] “Singapore Standard: Speciﬁcation for contactless e-purse application,”

SS 518: 2006.

[45] E. Brier and T. Peyrin, “A forward-secure symmetric-key derivation
protocol – how to improve classical DUKPT,” in Advances in Cryp-
tology – Proceedings of the International Conference on the Theory
and Application of Cryptology and Information Security (ASIACRYPT),
2010, pp. 250–267.

[46] C. J. Mitchell, “Truncation attacks on MACs,” IET Electronic Letters,

39(20):1439–1440, 2003.

[47] P. Gaˇzi, K. Pietrzak, and S. Tessaro, “The exact PRF security of trunca-
tion: Tight bounds for keyed sponges and truncated CBC,” in Advances
in Cryptology – Proceedings of
the Annual Cryptology Conference
(CRYPTO), Aug 2015, pp. 368–387.

[48] “ETCS SUBSET-041 3.1.0: Performance requirements for interoperabil-

ity,” Mar. 2012.

[49] M. Malvezzi, B. Allotta, and M. Rinchi, “Odometric estimation for au-
tomatic train protection and control systems,” Vehicle System Dynamics,
49(5):723–739, 2011.

Hoon Wei Lim is a senior R&D manager at Cyber Security R&D, Singtel.
His recent research interests have been centered around data security &

14

privacy, and security intelligence & analytics within enterprise environments
and cyber-physical systems. In the past, he has held research positions
the Institute for Infocomm Research (Singapore), National University
at
of Singapore, Nanyang Technological University, and SAP (France). Lim
received a Ph.D. in Information Security from Royal Holloway, University
of London.

William G. Temple received the B.S. degree in Mechanical Engineering
from Tufts University, USA, in 2010. He received the M.Eng. degree in
Mechanical Engineering from Cornell University, USA, in 2011. Currently, he
is a Project Manager and Senior Research Engineer at the Advanced Digital
Sciences Center (ADSC): a research center afﬁliated with the University of
Illinois, located in Singapore. His research interests include cyber security,
risk assessment, and resilience of critical infrastructure systems, particularly
in the energy and transportation sectors.

Bao Anh N. Tran received the B.S. in Computer Engineering and M.S.
in Embedded Systems from Nanyang Technological University in 2005 and
2008, respectively. Currently he is a Software Engineer with Wargaming,
Sydney, Australia.

Binbin Chen received his B.S. from Peking University, China, in 2003 and
his Ph.D. from the National University of Singapore in 2010. He is currently a
Senior Research Scientist at the Advanced Digital Sciences Center (ADSC), a
research center of the University of Illinois located in Singapore. His current
research interests include wireless networks, cyber-physical systems, applied
algorithms in networking, and network security. More information about his
research can be found at http://adsc.illinois.edu/people/binbin-chen.

Zbigniew Kalbarczyk is a research professor at the University of Illinois,
Urbana-Champaign. His research interests include automated design,
im-
plementation, and evaluation of dependable and secure computing systems.
Kalbarczyk received a Ph.D. in computer science from the Bulgarian Academy
of Sciences. He is a member of the IEEE and the IEEE Computer Society.

Jianying Zhou is a professor at the Singapore University of Technology
and Design (SUTD). His research interests are in applied cryptography,
computer and network security, cyber-physical security, mobile and wireless
security. Zhou is a co-founder and/or steering committee co-chair of leading
international security conferences, including ACNS, AsiaCCS, and Asiacrypt.
He received a Ph.D. in Information Security from Royal Holloway, University
of London.

