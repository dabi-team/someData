Chaff Bugs: Deterring Attackers by Making Software Buggier

Zhenghao Hu
New York University
huzh@nyu.edu

Yu Hu
New York University
yh570@nyu.edu

Brendan Dolan-Gavitt
New York University
brendandg@nyu.edu

8
1
0
2

g
u
A
2

]

R
C
.
s
c
[

1
v
9
5
6
0
0
.
8
0
8
1
:
v
i
X
r
a

Abstract—Sophisticated attackers ﬁnd bugs in software, eval-
uate their exploitability, and then create and launch exploits for
bugs found to be exploitable. Most efforts to secure software
attempt either to eliminate bugs or to add mitigations that
make exploitation more difﬁcult. In this paper, we introduce a
new defensive technique called chaff bugs, which instead target
the bug discovery and exploit creation stages of this process.
Rather than eliminating bugs, we instead add large numbers
of bugs that are provably (but not obviously) non-exploitable.
Attackers who attempt to ﬁnd and exploit bugs in software will,
with high probability, ﬁnd an intentionally placed non-exploitable
bug and waste precious resources in trying to build a working
exploit. We develop two strategies for ensuring non-exploitability
and use them to automatically add thousands of non-exploitable
bugs to real-world software such as nginx and libFLAC; we
show that the functionality of the software is not harmed and
demonstrate that our bugs look exploitable to current triage tools.
We believe that chaff bugs can serve as an effective deterrent
against both human attackers and automated Cyber Reasoning
Systems (CRSes).

I. INTRODUCTION

Bugs in software are both common and costly. Particularly
in languages that lack memory safety guarantees, such as C
and C++, it is all too easy for programmer errors to result in
memory corruption. Worse, these bugs can often be exploited
by attackers to achieve arbitrary code execution.

However, not all bugs are created equal. Depending on the
exact nature of the bug and the runtime environment when
it is triggered, a bug may not lead to a violation of any of
the program’s security goals. In these cases we say that the
bug is non-exploitable. For example, although null pointer
dereferences are certainly violations of memory safety and
therefore bugs, on systems that prohibit mapping the ﬁrst page
of memory these bugs can only crash the program.

If an attacker wants to exploit a ﬂaw in a program, they
must therefore triage any bugs they ﬁnd to determine their
exploitability and then work to develop an exploit for any
deemed exploitable;
this attacker workﬂow is depicted in
Figure 1. The process of going from an initial bug to a working
exploit is generally long and difﬁcult. And although some
research has sought to automate exploit generation [1], [2],
it is still a largely manual process.

On the defensive side, current efforts to secure software
generally focus on one of two areas: bug ﬁnding and exploit
mitigation. In terms of the attacker workﬂow in Figure 1, the
former attempts to reduce the supply of bugs available to the
attacker in step 1 , while the latter attempts to reduce the
effectiveness of the exploit launched in step 4 . Unfortunately,

Fig. 1: Simpliﬁed attacker workﬂow. Attackers ﬁnd bugs,
triage them to determine exploitability, then develop exploits
and deploy them to their targets.

despite decades of effort, automated techniques to ﬁnd bugs
cannot guarantee their absence for any but the smallest pro-
grams. Exploit mitigations such as ASLR and CFI [3] raise
the bar for attackers, but typically come with performance
penalties and do not deter the most sophisticated attackers.

In this paper, we introduce a new defensive technique that
is aimed at disrupting steps 2 and 3 : the bug triage and
exploit development process. Rather than eliminating bugs, we
propose instead to increase the number of bugs in the program
by injecting large numbers of chaff bugs1 that can be triggered
by attacker-controlled input. By carefully constraining the
conditions under which these bugs manifest and the effects
they have on the program, we can ensure that chaff bugs are
non-exploitable and will only, at worst, crash the program. As
long as it is difﬁcult for attackers to determine that a chaff
bug is non-exploitable, we can greatly increase the amount of
effort required to obtain a working exploit by simply adding so
many non-exploitable bugs that any bug found by an attacker
is overwhelmingly likely to be non-exploitable.

Although in some cases bugs that cause crashes consti-
tute denial of service and should therefore be considered
exploitable,
there are large classes of software for which
crashes on malicious inputs do not affect the overall reliability
of the service and will never be seen by honest users. Such
programs include most microservices [4] (which are designed
to gracefully handle the failure of a server by restarting it),
server-side conversion utilities, or even web servers such as
nginx that maintain a pool of server processes and restart any
process that crashes. In these cases, failures caused by attempts
to exploit a non-exploitable bug are invisible to normal users
with benign inputs.

Prior work [5], [6] has developed techniques for injecting

Portions of this work were carried out while Zhenghao Hu was attending

1Named after the strips of foil dispensed by military aircraft to confuse

Shanghai Jiao Tong University.

enemy radar.

✘✔✘✔TriageFind Bugs(cid:1)☠☠(cid:2)Exploit Dev(cid:3)Deploy(cid:4)""#$$$$ 
 
 
 
 
 
potentially exploitable bugs into programs, but it is not imme-
diately obvious that creating non-exploitable bugs is possible
without making it easy for attackers to triage them. We devise
two strategies for guaranteeing that an injected bug is non-
obviously non-exploitable. The ﬁrst strategy overconstrains the
value used to corrupt memory so that can only take on safe
values, while the second ensures that the data to be overwritten
is unused by the program. We build a working prototype of a
chaff bug injector that can create non-exploitable stack- and
heap-based overﬂows, and use it to put thousands of bugs into
three large, real-world programs, demonstrating the feasibility
of our techniques.

II. SCOPE AND THREAT MODEL

Typical information security goals are to protect the conﬁ-
dentiality, integrity, and availability of data or services. For
a given program, we assume that the attacker’s goal is to
compromise one of these properties by ﬁnding and exploiting
memory safety bugs in the program. We make no assumptions
about how the attacker ﬁnds the bugs: they may use manual
analysis, automated techniques based on static or dynamic
analysis, etc.

We assume that the attacker has access to a compiled (bi-
nary) version of the program but not its source code. Although
this is a severe limitation (it means that our technique cannot
be used to protect open source software), it is a necessary one.
Developers are unlikely to be willing to work with source code
that has had extra bugs added to it, and more importantly future
changes to the code may cause previously non-exploitable
bugs to become exploitable. Hence we see our system as useful
primarily as an extra stage in the build process, adding non-
exploitable bugs.

Once an attacker ﬁnds a memory safety bug, he must triage
it to determine its exploitability. In general, this is thought to
be a difﬁcult task (though not one that has received much
academic attention; we discuss some existing approaches to
determining exploitability in Section VII). Aside from straight-
forwardly determining exploitability, the fact that our bugs are
injected automatically offers the attacker another strategy: he
can attempt to distinguish an injected bug from a naturally
occurring bug, by identifying some artifact of injected bugs
that is not present in natural bugs. This would allow the
attacker to bypass the triage process and ignore any injected
bugs.

Some of the bugs we create (speciﬁcally the overconstrained
bugs described in Section IV-B2) can cause the program
to crash. This would appear to break the requirement of
availability for our threat model. In order to satisfy our threat
model, we must restrict our scope further: we can only add
chaff bugs to programs where crashes on malicious inputs
do not degrade the program’s availability on honest inputs.
Despite this limitation, we note that many applications ﬁt
this model. Modern web browsers split each tab into its own
process [7], and many web servers such as nginx (used
in our evaluation) create a process pool to handle incoming
connections; in these cases crashing on a malicious input does

not affect the usability of the program as a whole. Likewise,
command line utilities that process a single ﬁle at a time ﬁt
our model; while they may crash on a malicious input, this
does not affect their ability to process other inputs.

For our current work, we explicitly choose not to address
the distinguishability problem mentioned above, even though
it is within our threat model. Although we believe it is possible
to make our bugs indistinguishable from naturally occurring
bugs, we do not currently have a good understanding of
what makes a naturally occurring bug look “realistic”, and
without such an understanding our attempts would necessarily
be incomplete. We also see the distinguishability problem as
orthogonal to the problem of making bugs non-exploitable,
and choose to focus on the latter in this paper. Nonetheless,
we recognize that distinguishing attacks are a valid threat, and
we hope to address them in future work (we offer a few ideas
on this front in Section VII).

III. BACKGROUND: AUTOMATED VULNERABILITY
ADDITION

In order

to automatically add large numbers of non-
exploitable bugs to software to software, we ﬁrst need to
be able to add large numbers of bugs of any sort. In prior
work, Dolan-Gavitt et al. [5] developed LAVA, a system for
automatically adding potentially exploitable memory safety
errors into C/C++ programs. Although LAVA is intended to
create high-quality bug corpora for testing bug-ﬁnding tools,
in this work we repurpose and extend it to create chaff bugs. In
this section we brieﬂy provide background information on how
LAVA adds bugs to programs before moving on to describe
our extensions to ensure non-exploitability.

LAVA takes a program and a set of input ﬁles to that
program. It then runs the program on each input and performs
a dynamic taint analysis [8] to determine how each byte of
the input ﬁle is used in the program. It looks for points in
the program where the input is dead (not used to decide any
branches up to that point in the program), uncomplicated (not
transformed), and available in some program variable. These
variables, which are called DUAs, represent attacker-controlled
inputs that can be used to later trigger memory corruption in
the program. When a DUA is encountered, its value is copied
to a global variable so that it can later be retrieved at the point
where the memory corruption is triggered.

To actually trigger the bug, LAVA also makes note of attack
points along the trace—that is, places where the stored data
from the DUA could be used to corrupt memory. In its original
implementation, LAVA considers any pointer argument to a
function call to be an attack point; in our work we instead
create new attack points that cause controlled stack and heap
overﬂows at arbitrary points in the program. At the attack
point, a trigger condition is also checked before the DUA
is allowed to corrupt memory; this ensures that the bug is
triggered under controlled conditions.

For the purposes of LAVA, a bug is simply the combination
of a DUA and an attack point that occurs after the DUA in
the trace. Each bug created by LAVA comes with a triggering

void get_external_input(int fd) {

...
read(fd, buf, 1024);
lava_set(*(int *)buf);
...

}
...
int foo(int y) {

int x[10];
// Original:
// x[0] = 10;
// BUG:
x[0 +

(cid:44)→

(cid:44)→

(lava_get()==0x6c617661)*lava_get()]
= 10;

}

Fig. 2: A bug inserted by the original LAVA system. If the
input contains the correct trigger value, then an out-of-bounds
write will occur through the array x.

input, which makes it easy to verify that the bug is actually
present in the program. Dolan-Gavitt et al. [5] demonstrated
that thousands of bugs can be added to a program using this
technique, which makes it a good ﬁt for creating chaff bugs,
since we must ensure that any bugs found in the program are
likely to be our own non-exploitable bugs.

The bugs themselves are injected by performing a source-to-
source transformation on the program. At the DUA site, code
is inserted to copy the DUA’s value into a global variable via a
call to lava_set. At the attack point, lava_get retrieves
the value, compares it to the trigger value, and, if the condition
is met, adds the DUA to the attacked pointer in order to cause
a memory corruption. An example of this type of bug is shown
in Figure 2.

Following the publication of LAVA, Pewny and Holz de-
scribed an alternative approach to bug injection called Evil-
Coder [6]. Rather than creating new bugs in the target program,
EvilCoder identiﬁes potentially vulnerable code (i.e., points
where attacker-controlled data reaches a sensitive operation
such as a memcpy), and then removes any safety checks that
currently prevent the attacker-controlled data from causing a
vulnerability. Although in principle this technique could be
adapted to create chaff bugs, the number of bugs it can create
is inherently limited by the number of points in the program
where attacker-controlled data reaches a sensitive sink. This
prevents us from using EvilCoder for our chaff bugs, since we
need to guarantee that we can add large amounts of chaff to
deter attackers.

IV. DESIGN

To achieve the goal of increasing adversarial workload
without compromising the security of the software, we must
ensure that chaff bugs are 1) non-exploitable, and 2) difﬁcult
to triage to determine exploitability. In this section, we discuss

Fig. 3: Stack Overﬂow. The areas overwritten when our bugs
are triggered are indicated in red.

Fig. 4: Heap Overﬂow

our strategies for achieving these goals for stack- and heap-
based buffer overﬂows.

As mentioned in Section II, guaranteeing non-exploitability
requires that we have some control over the compiler and
runtime environment. Speciﬁcally, we need to control
the
layout of local variables on the stack and the heap allocator
used, and we need to be able to predict what memory ranges
will be unmapped at runtime. We believe these constraints
are reasonable for commercial software since the software
developers have full control over their development toolchain.

A. Bug Types

In this work, we focus on two different memory safety
errors: stack buffer overﬂows and heap buffer overﬂows. These
bug types were chosen because they are already implemented
in LAVA, and are still very common in software written in
unsafe languages such as C.

Figure 3 shows a stack-based buffer overﬂow. In this type of
overﬂow, a buffer on the stack that stores attacker-controlled
data can be overﬂowed, causing the attacker’s data to overwrite
other variables on the stack, the saved frame pointer, and
the return address. Because the stack layout of a function is
determined at compile time, we can control what data will
be overwritten when the overﬂow occurs, which gives us an
opportunity to ensure the overﬂow will not be exploitable.

frame pointerreturn addresslocal varreturn addressStack Frameframe pointerlocal varreturn addressframe pointerlocal varreturn addressframe pointerlow addresshigh addresslocal varOverflow UnusedOverflow Overconstrainedmetadatametadataheap chunksOverconstrainedStack-based overﬂows that overwrite the frame pointer or
return address will manifest as soon as the function returns,
whereas those that overwrite another local variable will have
more complex effects that depend on how the overwritten local
variable is used by the program after the overwrite.

In a heap-based buffer overﬂow, shown in Figure 4, an
attacker can overﬂow a buffer allocated on the heap, causing
heap metadata (e.g., freelist pointers or size ﬁelds) stored
in between the heap chunks to be overwritten. These bugs
may manifest when the heap implementation interacts with
the corrupted heap chunk (e.g., when the chunk is freed or a
new allocation is requested). Unlike the stack, the layout of
the heap is not known at compile-time; as we will explain,
this means that extra care must be taken to ensure non-
exploitability, and some heap bugs cannot be made non-
exploitable and must be avoided.

1) Bug Injection: Recall from Section III that the bugs
LAVA injects consist of DUAs (program inputs that are dead,
uncomplicated, and available) and attack points. LAVA creates
bugs by siphoning the input data from the DUA into a global
variable and then later retrieving that data at some point in the
program where we want to trigger a bug.

Each chaff bug we inject uses two DUAs. The ﬁrst, which
we will call the trigger DUA, is used as a trigger; if the input
data does not satisfy some condition (e.g., equality with some
constant), then the bug will not be activated. This allows us
to ensure that the bug does not manifest for too many inputs
and thereby cause the program to fail on benign inputs. The
second DUA (the attack DUA) is used as the source buffer for
the overﬂow. As with the original LAVA system, both DUAs
should have low liveness (number of branches inﬂuenced by
the input data) and TCN (taint compute number, a measure of
how much computation has been done on the data).

Unlike LAVA, however, we have an additional constraint
on how we can select DUAs. The DUAs selected must be
fully initialized at the point where we wish to siphon them
into global data. If we fail to do so, we may inadvertently
add unintentional bugs (such as a use-after-free or a read of
an uninitialized local variable) to the program; since we do
not intend to inject these bugs we cannot guarantee that they
are non-exploitable. We discuss our technique for avoiding
uninitialized DUAs in more detail in Section V-B3.

We have considerable freedom in where we place our attack
points. We can create an attack point at any point along the
execution trace for our seed inputs as long as the attack point
is reached after the trigger DUA. This allows us to place bugs
in any part of the program that can be reached by the inputs
we have available; in Section VI-A we show experimentally
that we can, in fact, place bugs throughout the program given
an adequate set of test inputs.

B. Ensuring Non-Exploitability

When injecting an overﬂow, two key quantities determine
exploitability: the target of the overﬂow (i.e., what data is
overwritten) and the value that is written. Each of these can be
manipulated so that exploitation becomes impossible. With this

in mind, we designed two strategies for ensuring our bugs are
non-exploitable: making the target of the overﬂow a variable
that is unused by the program, and ensuring that the value used
in the overﬂow is constrained so that it can only take on safe
values at the site of the overﬂow. In principle, each strategy
can (with some care) be used with both stack- and heap-based
overﬂows, yielding four classes of non-exploitable bugs, but in
practice heap-based unused variable bugs cannot be guaranteed
to be non-exploitable and must be excluded. In this section we
discuss our strategies for ensuring non-exploitability in detail.
1) Unused Variable Overwrite: Our ﬁrst strategy is to
arrange the overﬂow so that it can only overwrite a variable
that is unused by the program. Although it is difﬁcult in
general to determine statically whether a given variable is
unused, as the bug injector we have a signiﬁcant advantage:
rather than trying to ﬁnd an existing unused variable we can
simply add our own variables and then overwrite them. We
note that these overwrites will not cause a program crash, but
they should be detectable through either static analysis or ﬁne-
grained bounds checking.

For stack-based overﬂows, the unused variable must also be
on the stack—in other words, it must be a local variable. We
rely on the compiler to guarantee the two variables (the buffer
we overﬂow and the unused variable) are allocated adjacent
to one another. In our current implementation, we simply rely
on our knowledge of how our chosen compiler lays out local
variables on the stack, but for a stronger guarantee we could
also extend the compiler to provide annotations that allow the
stack layout to be speciﬁed explicitly.

Heap-based unused variable overwrites seem plausible at
ﬁrst, but cannot in practice be made non-exploitable. Ensuring
the safety of an overﬂow requires that we be able to precisely
predict what will be overﬂowed. However, for a heap-based
unused variable overﬂow, we would need to guarantee that
the following heap chunk is one we allocated. Because the
placement of a given chunk depends on the current state of
the heap, which in turn depends on the sequence of allocations
and deallocations made in the program so far, we can make
no such guarantee, and so these bugs might be exploitable.
Hence, we exclude them from our system.

2) Overconstrained Values: Our second strategy ensures
non-exploitability by using overconstrained values. Because
we control the data-ﬂow path by which the malicious input
(i.e., the attack DUA) reaches the attack point, we can add
constraints to the data that restrict it to a set of known-safe
values. This ensures that the bug can be triggered, but only
with values that we can prove do not lead to code execution.
Overconstrained values can be used to overwrite any sen-
sitive data as long as a safe subset of values can be found.
In our prototype, our bugs overwrite sensitive data such as
the stored frame pointer, return address or heap metadata.
The return address is used to restore program counter after
function returns, so constraining the value to addresses in
unmapped or non-executable ranges is safe. Similarly, if we
overwrite the frame pointer saved on the stack, then it will be
restored (into ebp on x86) when the function returns; since

the restored frame pointer will be dereferenced to access local
variables (e.g. mov eax, [ebp-0xC]), values that result
in unmapped addresses are once again safe.

Finally, for heap overﬂows we can target the heap metadata.
Safe values for metadata overwrites vary depending on the
allocator, so we assume that the defender can specify which
heap allocator is used. Safe values here are those that will be
detected by the allocator’s sanity checks; for example, we can
overwrite the size ﬁeld of the metadata for a heap chunk with
the value 0. When the chunk is freed, the allocator will detect
that the chunk size is invalid and safely terminate the program.
This type of overwrite requires some care to ensure that it
is not exploitable regardless of the state of the heap, which
requires careful analysis of the heap allocator implementation.
We provide such an analysis in Section V-B2 for the GNU
glibc ptmalloc implementation.

C. Increasing Triage Difﬁculty

Upon ﬁnding a bug, an attacker must triage it to determine
its exploitability. In order to increase the attacker’s work factor,
we must therefore make our bugs difﬁcult to triage. This
requires some additional work, as a na¨ıve implementation of
the above strategies will result in bugs that are relatively simple
to triage. Overconstrained values can be easily identiﬁed as
non-exploitable as long as the attacker is able to ﬁnd the
constraint checking code. Unused variable overwrites are also
easy to triage since our unused variable’s value will not
escape the current function scope; this means that an attacker
only needs to look at a single function to tell whether the
overwritten value could be used for an exploit.

To increase triage difﬁculty, we need to obfuscate the
constraints used in overconstrained value bugs and create ad-
ditional dataﬂow that propagates our unused variables’ values
beyond the scope of the function containing the overﬂow. In
general, we want each bug to require reading and understand-
ing signiﬁcant amounts of additional code before and after the
point where the bug is triggered.

1) Overconstrained values: To obfuscate constraints, we
split the constraint check into multiple parts and spread the
parts throughout the execution trace that leads to the bug. Each
check along the way excludes some subset of unsafe values
before propagating the input onward, as shown in Figure 5.
To check whether the bug is exploitable, an attacker has to
reconstruct the exact path that would reach the bug and verify
that no other path can reach the bug with more permissive
constraints. Each check in isolation does not rule out all unsafe
values, so unless an attacker considers all of them he cannot
rule out the possibility that the bug is exploitable.

One concern with overconstrained values is the possibil-
ity that more advanced techniques, such as hybrid concolic
fuzzers [9], could use an SMT solver to determine that the
input that triggers a crash is constrained to safe values and
automatically discard it. However, we note that ruling out a
bug as non-exploitable requires reasoning not just about the
path leading to a crash, but reasoning about all other paths
that may lead to the same crash but with fewer constraints;

Fig. 5: An overconstrained value bug. By adding constraints
along the path leading to the bug, we gradually eliminate
unsafe values.

Fig. 6: An unused variable bug. Data ﬂow is added to
propagate the “unused” values outside the initial scope, hiding
the fact that they are actually unused.

failing to do so would discard real, exploitable bugs as well.
Additionally, we note that in principle arbitrarily complex
functions could be constructed that map the original attacker-
controlled input
the
associated constraints could be constructed to make them
difﬁcult for SMT solvers to check. Such functions are a
generalization of opaque predicates [10], which are known to
be difﬁcult to analyze.

to a safe subset of values, and that

2) Unused variables: In order to make triage harder for
the unused variable strategy, we must make it appear that the
unused variable is, in fact, used by other parts of the program.
To do so, we add data ﬂow after the overﬂow takes place that
carries the overwritten value to other parts of the program
(but, ultimately, does not use it). As shown in Figure 6, we
add additional output arguments to the function that contains
the unused variable bug and a ﬁxed number of its parents.
After the overﬂow, we add code to copy the overwritten value
into this output argument and propagate it back up the stack

All Possible Values00xffff ffffSafe ValueC1: a & 0xff00 0000 == 0C2: a & 0x00ff 0000 == 0C3: a & 0xff == 00x01000xff00vSYSCALLGlibcMemoryMappingsFunc :    int lava_dataflow_var[1];Calling Foo :    ( int *lava_dataflow_arg,   )Calling Fun :   ( int *lava_dataflow_arg,   )Unused Local Variable 1Unused Local Variable 2Top Level CallerCallee 1Callee 2Callee 3Overflowof calling functions. This increases the difﬁculty of triage by
forcing the attacker to check how the value is used in all
the callers. This process could be extended by introducing
dataﬂow from the calling functions to later callees; for our
current prototype, however, we only create dataﬂow to the
calling functions.

V. IMPLEMENTATION

In this section we discuss the details of our implementation.
We implement our non-exploitable bug injection system on top
of LAVA [5], a previously published bug injection system that
is itself based on the PANDA dynamic analysis platform [11]
and the clang compiler [12]. Our implementation currently
assumes a 32-bit x86 Linux environment, but the ideas are
general and could be adapted to other operating systems and
architectures with minor modiﬁcations.

A. Extensions to LAVA

Apart from the changes to LAVA to make bugs non-
exploitable (which are discussed in detail below), the major
extensions to LAVA involve ﬁxes to avoid unintended bugs.
The original LAVA system can, in some cases, add accidental
bugs such as use-after-frees and uninitialized variable reads.
For this work, we eliminated these unindented bugs by taking
care not to use any uninitialized DUAs and adding extra safety
checks around pointer uses.

We also extended PANDA to support

in
programs that take input from the network rather than a local
ﬁle, and added monitoring of heap allocations and stack layout
to PANDA’s analyses.

tracking taint

Overall, our changes to LAVA comprise 7,935 lines added
and 325 deleted across 82 ﬁles in the LAVA codebase (as
somewhat crudely measured by git diff). Our system will
be released under an open source license upon publication.

B. Bug Injection

We implemented two types of non-exploitable bugs: 1) bugs
overwriting unused data, and 2) bugs overwriting sensitive data
but over-constrained to non-exploitable values. We implement
the unused data overwrite bugs as a stack overﬂow, overwriting
an unused local variable, and implement both stack- and heap-
based overﬂows with the overconstrained value strategy.

1) Stack-Based Overﬂows: For the unused variable strategy,
we ensure that the overwritten variable is unused by inserting
dummy local variables so that the overﬂow does not corrupt
other local variables. To achieve this, it is important to know
the order of local variables on the stack since we have to make
sure the dummy variables are placed directly adjacent to the
variable we are going to overﬂow. In our implementation, we
took advantage of the fact that clang allocates local variables
sequentially from the higher to lower stack addresses in the
order of their declarations in the source. gcc, by contrast, uses
a more complicated reordering strategy [13] that makes the
order hard to predict. This solution is somewhat brittle since
it depends on the speciﬁc compiler version used; in future

work, we hope to implement a compiler extension that allows
us to explicitly specify a stack layout at compile time.

In the overconstrained value strategy, overﬂowing the stored
frame pointer and return address requires knowledge of where
on the stack the target is relative to the buffer we’re over-
ﬂowing. We implement this by placing the buffer we will
overﬂow at the bottom of the current stack frame; during the
taint analysis phase of bug injection we also measure the exact
distance between the end of this buffer and the frame pointer
and return address. This distance is then used to determine
the maximum amount by which we will overﬂow the buffer,
ensuring that we cannot accidentally overwrite data in previous
frames.

We observed that in some functions arguments will be ﬁrst
copied to the bottom of the stack and local variables will be
allocated above them. Overﬂowing the stored frame pointer or
return address would also overwrite these stored arguments. As
we want to focus our overconstrained target on only the stored
frame pointer and return address, we add an offset to local
variable we are going to overﬂow when the bug is triggered.
This skips over the copied arguments and overwrites precisely
the target data we want to corrupt. As with the ordering of
stack variables, this workaround could be avoided with minor
changes to the compiler.

2) Heap-Based Overﬂows: Our current

implementation
uses GNU ptmalloc as found in Debian 9.3’s glibc 2.242
because it is a widely used, real-world allocator. The heap
the metadata for heap chunk
overﬂows we inject corrupt
just after an allocation we make, and so our analysis of
the values that are safe to use in the overﬂow depends on
the speciﬁc allocator in use. We believe the analysis in this
section is correct, but we acknowledge that the argument is
fairly detailed and it is possible that we have missed a case
that would allow exploitation. However, we note that stronger
assurance could be gained by implementing and using our own
allocator with simpliﬁed semantics that make it easier to prove
our bugs are non-exploitable. We leave the design of such an
allocator to future work.

In our implementation, we create a heap allocation and
then overﬂow it, corrupting the prev_size and size ﬁelds
of the subsequent heap chunk. We set prev_size to the
constant 12 and then use the overconstrained value strategy
to set the value of size to 0. In addition, we set the second-
to-last 4-byte word of our allocation to the constant value 16.
By analyzing the implementation of ptmalloc, we can
verify that heap overﬂow bugs are non-exploitable for our
chosen overﬂow values. We split the analysis into three cases,
depending on what type of heap chunk follows our allocation:
an in-use chunk, the “top” chunk, or a freed chunk. The
ﬁnal case needs particular care, because other allocations may
trigger heap consolidation, where adjacent free chunks are
merged together. In all cases, we need to guarantee that the
allocator detects an inconsistency in the heap metadata and

2Note that this version includes a patch by Chris Evans that adds an extra
assertion to unlink; our analysis below depends on this assertion being
present.

scope. As a result, the DUAs found by LAVA are not guaran-
teed to be initialized in all program executions. An example of
this is shown in Listing 1: in the execution trace observed by
LAVA, cond is 0 and so pointer is initialized and detected
as a DUA. However, if we then try to inject DUA siphon code
after the if statement, there may be executions in which this
creates an uninitialized use of pointer. This would add an
unintended (and potentially exploitable) bug to the program.

Fig. 7: Layout of the heap for heap-based overﬂows.

aborts the program, preventing the memory corruption from
being exploitable.

}

Initialize(pointer);

if (cond == 0) {

The ﬁrst two cases are relatively simple. If the next chunk is
in use, the only way to trigger the bug is to free the corrupted
chunk. In this case, ptmalloc aborts with an invalid size
assertion in the free operation. If the next chunk is the top
chunk, then the next memory request (i.e., malloc) from the
top chunk will abort as intended because setting the size ﬁeld
to a small value will make the program fail in the veriﬁcation
of the size of the top chunk and raise an assertion error.

In the ﬁnal case, the next heap chunk is a free chunk. The
allocation can be in either the fast bins, unsorted bins, or the
normal bins (including small bins and large bins) according
to their size and the state of the heap. The corrupted heap
metadata could be referenced either in a subsequent memory
allocation or during chunk consolidation. For malloc oper-
ations, ptmalloc will trigger an assertion failure when the
memory allocator checks that the size ﬁeld is not less than
16.

that

During chunk consolidations, ptmalloc will reference
the heap chunk metadata to merge adjacent freed chunks
to reduce heap fragmentation. To ensure an assertion failure
the unlink
is triggered, we make use of the fact
operation veriﬁes that the size ﬁeld of the current chunk
is equal to the prev_size ﬁeld of the next chunk. Our
heap overﬂow sets the prev_size ﬁeld of the next chunk to
12, which points to a “fake” heap chunk inside our allocated
buffer with a size ﬁeld equal
to 16. The fake chunk,
in turn, points to a heap chunk whose metadata partially
overlaps the metadata we originally overﬂowed—in particular,
it points to a heap chunk whose previous_size ﬁeld is
0 (this is depicted in Figure 7). This violates the invariant
“chunk.next.prev_size == size”, so an assertion
failure will be triggered as desired.

Based on our reading of the ptmalloc code, these cases
fully account for the behavior of the allocator after we have
overﬂowed the next chunk’s metadata with our speciﬁed
values. All cases result in an assertion failure, which is not
exploitable, so we can say that our heap-based overﬂows are
not exploitable with the values we used. It is probable that
further analysis would ﬁnd other values that could safely be
used as well (allowing us greater freedom in what attacker-
controlled values we can permit and improving the realism of
the injected bugs), but we defer this analysis to future work.
3) Handling Uninitialized DUAs: LAVA’s taint analysis
operates at the binary level does not take into account function

lava_set(pointer);

Listing 1: Example of an uninitialized DUA siphon. We may
encounter an uninitialized use of pointer when cond is 0.

To handle this issue, we restrict the DUAs we use to those
that we can guarantee have been initialized by only using
DUAs once we have seen them referenced in the same scope
or in an enclosing scope. This strategy guarantees that we do
not add any new uninitialized uses to the program (though if
the program already contains an uninitialized use, we may add
additional uses of the same uninitialized variable). In the case
of Listing 1, the DUA will be discarded because we cannot
ﬁnd a properly initialized point in the scope.

This solution guarantees that the pointer itself is safe to
dereference, but in many cases the DUA identiﬁed by LAVA
will in fact be an offset from a base pointer. In particular,
string buffers often contain input data that can be used for
DUAs, but string pointers in C point to the ﬁrst character of the
string. Because we have no way of knowing how large the area
pointed to by a C string pointer may be statically, we instead
insert runtime checks that call strlen and only attempt to
reference offsets less than the string’s length. This results
in many more available DUAs than simply discarding all
character pointers with offsets, and is important for achieving
amounts of chaff in programs that process text-based input
such as nginx. Our pointer safety checks can be seen in
Listing 2.

if (pointer->field) {

...

}

temp_pointer = pointer->field;
...

// lava_set(*(pointer->field));
if (pointer->field &&

strlen(pointer->field) > offset)
lava_set(*(pointer->field) + offset);

Listing 2: Example of a safe DUA siphon

…-16120Our AllocationFollowingAllocationprev_sizesizesizeprev_sizesizeC. Increasing Triage Difﬁculty

1) Faking Data Flow: For the unused variable strategy
we increase triage difﬁculty by adding additional uses of the
unused variable after the site of the overﬂow. This ensures
that the exploitability of the bug cannot be determined by
simply observing that the corrupted value does not escape
the local scope; instead, an attacker must trace the ﬂow of
data after the overﬂow through several other functions. Since a
given function may have many call sites, this can signiﬁcantly
increase the amount of work required for the attacker.

Our implementation ﬁrst collects the call stack to get a trace
of callers at the attack point. We then ﬁlter the caller trace to
eliminate library calls and the “main” function, since these
functions are externally visible and their signatures cannot
be safely modiﬁed. An extra integer local variable is added
at the root of the call trace and is passed by reference to
each function in the call stack by adding an extra parameter
to each function between the root and the overﬂow site. At
the overﬂow site, the overﬂowed variable is assigned to this
parameter. Finally, for every modiﬁed function, we must also
modify its callers so that they also use our extra parameter.

Currently, our implementation does not attempt to modify
any function that is called via a function pointer, because it
is difﬁcult to statically determine all possible functions that
might be assigned to such a pointer. This leads to some
reduction in our ability to create fake data ﬂow; however, in
nginx we found only 310 indirect calls that we might miss
out of 4954 total function calls, so we believe the impact is
negligible.

2) Overconstrained Value Obfuscation: Our implementa-
tion of overconstrained value obfuscation is currently designed
to successively add constraints to an attacker controlled input
to eventually force its value to be zero. It does so by propa-
gating data from the DUA to the attack point in several stages.
Each stage uses a bitmask to eliminate some of the attacker
controlled data and then copies the result onward. Because our
bugs are created starting from a concrete input, we know the
full execution path between the DUA and the attack point, and
code to selectively propagate the data can be inserted along
this path.

An example of the code we insert can be found in Listing 3;
the ﬁrst stage clears the upper 16 bits of a 32-bit value, and
the second stage clears the lower 16 bits, leaving a constant
value of zero. However, to determine exploitability, an attacker
must ﬁnd and understand these statements, realize that they
produce a constant value, and check that there are no other
paths through the binary that reach the bug while retaining
the attacker-controlled data.

VI. EVALUATION

Our evaluation focuses on answering three key questions

about chaff bugs:

• Can we add a large number of chaff bugs distributed
throughout a given program, and will it still work cor-
rectly once we have done so? (Section VI-A)

// Initial Store of DUA
setConstraint(DUA_2);

// Update
// Update first 16 bits
v1 = DUA_2 & 0xffff;

// Update last 16 bits
v2 = v1 & 0xffff0000;

// Final DUA check and trigger
if (DUA_1 == trigger)

triggerBug(v2);

Listing 3: Overconstrained DUA propagation. In this example,
we want to constrain DUA 2 to 0 when the bug is triggered. v1
and v2 are global variables initialized to be null. So whatever
the order of “Update” code pieces being reached (even if some
of them are skipped in different execution paths), we can still
be sure that the ﬁnal data used to trigger the bug has been
properly constrained to 0.

• What is the performance impact of adding chaff bugs?

(Section VI-B)

• How successful are current bug-ﬁnding tools at ﬁnding
chaff bugs, and do automated triage tools think they’re
exploitable? (Section VI-C)

A. Functionality

We injected chaff bugs into three target programs: nginx
1.13.1, file 5.30, and libFLAC 1.3.2. The bugs are selected
randomly among the three types of bugs our prototype creates:
overconstrained stack (OC-Stack), overconstrained heap (OC-
Heap), and unused stack (Unused-Stack). For each bug, we
verify that it was successfully injected by running its triggering
input and observing a crash. Because our unused variable bugs
do not trigger crashes, we modiﬁed them to additionally raise
an exception by dividing by zero.

We generated two sets of inputs for each program: clean
inputs, which come from the corpus we used for bug gener-
ation (e.g. the ofﬁcial nginx test suite, libFLAC testing
examples, etc.), and triggering inputs, which are modiﬁed
versions of the clean inputs that will trigger one of our bugs.
For all clean inputs, we veriﬁed that the buggy programs
are able to process them with the expected output. For all
selected triggering inputs, we checked that the programs crash
as intended. Because there are so many candidate bugs, we
were only able to test a subset. Table I shows the number and
type of bugs we veriﬁed.

Two main factors account for the fact

that some bugs
cannot be successfully injected. First, a candidate bug may
be eliminated when we ensure that its DUA does not ref-
this also
erence an uninitialized variable (Section V-B3);
explains why there are generally fewer overconstrained bugs—
overconstrained bugs use two DUAs (one for the trigger
and one for the overconstrained value), so there are twice

TABLE I: Validated Bugs

Attempted
OC-Stack
OC-Heap
Unused-Stack

nginx
27400
192
853
5178

flac
176500
554
570
2045

file
132091
23039
24632
45547

as many opportunities for them to be eliminated. Second,
overconstrained bugs targeting the frame pointer may not be
triggerable because the calling function may not reference
any local variable before it returns, at which point its (non-
corrupted) frame pointer will be restored, avoiding a crash.

We next measured our ability to add bugs to all parts of the
target program. If all of our injectable bugs are concentrated in
some small part of the program, an attacker might be able to
simply ignore any bugs found in that area and ﬁnd preexisting,
exploitable bugs elsewhere.3

First, we measured the baseline coverage of our test corpus
for each program; because LAVA (and by extension our
system) relies on dynamic analysis, it cannot add bugs to parts
of the program that are not covered by the inputs in the test
corpus. We computed the function and ﬁle coverage using gcov
4.9.2 (lcov 1.1). All programs were conﬁgured with optional
modules disabled and compiled with clang 3.6.2.

The original inputs’ coverage is given in Table II. The
attack point (ATP) coverage columns indicate potential sites
where injected bugs may be triggered in our system. ATP
function coverage is relatively low; however, this is partially
because attack points can only occur after attacker-controlled
data is introduced to the program. If we exclude functions
that are executed before the ﬁrst byte of input is read, the
function coverage rises to 56.0% for nginx, 80.3% for file,
and 65.7% for flac. Higher coverage may be achievable
by changing conﬁguration settings for the programs, trying
different command line parameters, etc., but the problem of
ﬁnding high-coverage tests for a program is both difﬁcult and
orthogonal to our current research.
Finally, we ran an experiment

to estimate the number
of attack points that were actually usable in practice. We
randomly selected 100 unique attack points in each program.
Each attack point may be associated with many bugs (i.e.,
many different DUAs). We then attempt to inject bugs using
each attack point. If a given bug cannot be triggered at that
attack point, we try again with a different bug, until all bugs
have been exhausted.

Figure 8 shows the success rate after k tries. We ﬁnd that
nginx and file have a relatively higher trigger rate in
the beginning. With multiple tries of bug injection, file
achieved a 98% success rate within 6 tries, while nginx
ultimately reaches 71%. The differences here seem largely
due to programming style and the type of input processed
by each program. nginx, for example, makes extensive use

Fig. 8: Success rate at triggering bugs for each ATP

of pointer DUAs to parse string data so many potential bugs
are eliminated when we check for uninitialized data usage.
libFLAC takes longer to reach a high success rate (perhaps
because of the large number of potential bugs available), but
reaches 83% eventually.

B. Performance

We measured the performance overhead of chaff bugs by
benchmarking our buggy version of nginx with different
numbers of bugs added. We ran Weighttp [14] against nginx
1.13.1 injected with 10, 50, 200, 1000, and 2000 randomly
selected bugs. The nginx binary is compiled with LLVM
3.6.2. Our testbed is a 24-core Intel® Xeon® X5690 CPU at
3.47GHz with 189 GB of RAM running Debian 9.3.

Figure 9 shows the average requests processed per second
by nginx per second with one and 24 concurrent workers.
With more bugs injected, we observed higher overhead, mainly
due to the added cost of checking whether inputs match our
bugs’ trigger conditions. For 24 workers, we observed lower
overhead compared to a single worker. We speculate that with
more workers available, other performance bottlenecks (such
as disk and network I/O) dominate.

Proﬁling nginx with different numbers of bugs injected,
we identiﬁed some injected code accounting for more per-
formance overhead than the others—they were hit unusually
often in the run. We identiﬁed three functions, for memory
allocations and string formatting, in nginx that are extremely
“hot” and not heavily used in bug injection; excluding these
from bug injection resulted in around 15% performance gain
in the ﬁnal result. Further optimizing with LLVM’s Proﬁle-
Guided Optimization (PGO) [12] would also give us an extra
20% boost in performance.

C. Bug Detection and Triage

3In fact, it would be sufﬁcient to be able to place chaff bugs wherever
naturally occurring bugs exist in the program, but since we don’t know the
distribution of naturally occurring bugs for a given program we have to
conservatively assume they could be anywhere.

To get an estimate of the difﬁculty of ﬁnding and triaging
our bugs, we used off-the-shelf tools to test our buggy binaries
and triage any crashes found. We used the American Fuzzy

0100200300400500Number of Tries020406080100Trigger Rate (%)fileflacnginxTABLE II: Coverage of Original Inputs

nginx
file
libFLAC

Functions
52.8% (712/1349)
54.8% (142/259)
19.3% (145/752)

ATP ﬁle coverage
45.6% (47/103)
63.2% (12/19)
30.2% (13/43)

ATP function coverage
26.4% (188/712)
40.1% (57/142)
46.2% (67/145)

knowledge of each bug.

Table III shows the fuzzing results. For libFLAC, we found
1275 crashes that AFL considered unique—more crashes than
there are injected bugs, indicating that some of our bugs were
mistakenly counted multiple times by AFL. This is likely a
consequence of the heap-based bugs we injected: we only
corrupt the heap metadata when triggering the bug, so the
actual crash occurs later when the program allocates or frees
memory. In nginx, AFL did not ﬁnd any of our stack-based
bugs because there were fewer to ﬁnd and its detection rate
was relatively low overall.

Finally, we tested whether a popular open-source triage
tool, gdb exploitable, considered our bugs exploitable.
We used the same programs and bugs as for the fuzzing
experiment, but used our ground truth triggering inputs to
create crashes for exploitable to analyze. Table IV
shows the number of validated bugs and the category as-
signed by exploitable. In our experiments, all of our
chaff bugs were considered EXPLOITABLE or PROBA-
BLY EXPLOITABLE.

(a) 1 worker

All

were

classiﬁed

overﬂows

heap-based

as
EXPLOITABLE no matter what heap metadata we corrupted
in the injected heap-based bugs. Stack-based bugs that
overwrote the stored frame pointer were also classiﬁed
as EXPLOITABLE because the access violation happens
the destination operand of an instruction (e.g. mov
at
[ebp-0x10], eax where ebp is NULL). For stack-
based bugs, the return address overwrites were reported as
PROBABLY EXPLOITABLE because a segmentation fault
occurred on a program counter near NULL (recall that our
prototype only uses 0 for its overconstrained values). A more
reﬁned overconstrained value strategy that sets the return
address to non-executable or unmapped memory would likely
be considered EXPLOITABLE.

In the future, better triage tools may be more successful
at determining which bugs are truly exploitable. However, we
note that as a design choice, triage tools tend to be weighted in
favor of conservatively assuming that a bug may be exploitable
(so that bugs are not missed), which proves to be an advantage
in our case.

VII. LIMITATIONS & FUTURE WORK

The primary limitation of our current work is that we have
not yet attempted to make our bugs indistinguishable from real
bugs. This means that they currently contain many artifacts
that attackers could use to identify and ignore them. In future
work, we hope to investigate techniques for making our bugs
blend in with the surrounding code, and change their triggering
conditions to something more natural than the current test
against a magic value.

(b) 24 worker

Fig. 9: Performance Evaluation for nginx 1.13.1

Lop (AFL) fuzzer [15] to ﬁnd crashing test cases and then
used the gdb exploitable [16] plugin to evaluate their
exploitability.

Our fuzzing targets were each injected with 1000 randomly
selected overconstrained chaff bugs (unused variable bugs
were omitted because they do not cause crashes and hence
cannot be found by fuzzing without additional instrumenta-
tion). For file and flac, we injected 500 heap-based bugs
and 500 stack-based bugs; however, for nginx we were only
able to successfully inject a total of 54 stack-based bugs, so we
increased the number of heap-based bugs to 810 bugs. For each
program, we generated a fuzzing dictionary from the strings
and integer constants found in the target binary, and seeded
AFL with a held-out input ﬁle that was not used during the
bug injection step. We fuzzed each target with 11 concurrent
AFL processes in parallel for 24 hours (wall clock time) and
measured the number of unique crashes as determined both
by AFL’s built-in crash bucketing and our own ground truth

native10 bugs50 bugs200 bugs1000 bugs2000 bugs0.650.700.750.800.850.900.951.001.05Normalized Requests/snative10 bugs50 bugs200 bugs1000 bugs2000 bugs0.20.40.60.81.01.21.4Normalized Requests/sTABLE III: Fuzzing Results

nginx
file
flac

Unique Crashes
55
595
1275

Unique Bugs
55
350
315

Heap Bugs
55
305
155

Stack Bugs
0
45
160

TABLE IV: Triage Tool Results

nginx
file
flac

Heap Bugs
810
500
500

Stack Bugs
54
500
500

EXPLOITABLE
856
500
548

PROBABLY EXPLOITABLE
8
500
452

The diversity of bugs injected by our prototype is also
somewhat limited, which could allow an attacker to identify
patterns in the bugs we produce and exclude those that match
the pattern (for example, they could decide to ignore heap
overﬂows where the metadata header matches the constants
used by our overﬂow). We believe this can be alleviated
by introducing more types of bugs (such as use-after-free,
TOCTOU, integer overﬂows, etc.) and by expanding the range
of safe values in our overconstrained value strategy.

Our current bug injection requires source code, but in many
cases source code for legacy systems is unavailable. It may
therefore be useful to investigate whether chaff bugs can be
injected at the binary level as well. Although this is likely
to be more difﬁcult from a program analysis point of view,
from the point of view of ensuring non-exploitability it may
actually be easier. Exploitability depends heavily on low-level
details such stack layout, alignment, etc., and these features
are more readily visible at the assembly level [17].

Finally, when investigating automated crash triaging tools,
we found surprisingly few public tools apart from Microsoft’s
!exploitable and its gdb counterpart, exploitable. In
terms of academic study, the only work available seems to be
a masters thesis by Frederick Ulrich [18]. We hope that chaff
bugs will help draw more academic attention to the problem
of exploit triage.

VIII. RELATED WORK

There is a large body of work on mitigations for exploita-
tion of bugs in software, including Address Space Layout
Randomization (ASLR), Data Execution Prevention (DEP),
stack canaries, Control Flow Integrity [3], and Code Pointer
Integrity [19]. Our work represents a novel defense in software
security that focuses on wasting attacker effort during the bug
ﬁnding and exploit development process. It can be combined
with these existing mitigations, but our non-exploitability
analysis would need to be adapted to take this modiﬁed
execution environment into account.

Our work also ﬁts more broadly into the category of security
through deception. Almeshekah et al. [20] give an overview of
different types of deception in security, including honeypots,
honeyﬁles, and honeytokens. Juels and Rivest [21] describe
the use of honeywords—fake password hashes associated with
an account—to detect password cracking attempts. Araujo
et al. [22] describe honeypatches, which patch software but

transparently redirect exploit attempts to an unpatched instance
in order to deceive attackers into thinking their attack has
succeeded. Finally, one line of work on deception has focused
on generating believable decoy data [23], including decoy
documents [24] and source code [25]; the goal of this work is
to provide enticing but fake documents to attackers and then
detect their exﬁltration.

These sorts of honeypots are mainly focused on detecting
and analyzing attacker actions. However, some research has
also attempted to waste attacker resources upon detection.
Liston ﬁrst proposed the idea of a network tarpit and imple-
mented it in the LaBrea software [26]. Tarpits deliberately
delay network trafﬁc responses to slow down attackers’ net-
work reconnaissance. A similar countermeasure is the “endless
ﬁle,” [27] a technique in which a large, sparse ﬁle is created
on a remote system, which causes attackers to download large
amounts of data while using little space on disk.

Closest to our own work is research into anti-fuzzing, in
which modiﬁcations are made to software to make it harder
to ﬁnd bugs through fuzzing. Miller [28] described a technique
for detecting that a program was being tested with a fuzzer and
then triggering unique, non-exploitable crashes dynamically.
These techniques were further developed by Whitehouse [29],
who proposed a suite of defensive countermeasures to take
including throwing fake errors,
when fuzzing is detected,
degrading performance, masking legitimate crashes with an
exception handler. Most recently, Edholm and G¨oransson [30]
developed and evaluated a number of fuzzing detection and
evasion techniques on a subset of the DARPA Cyber Grand
Challenge [2] dataset. Our work differs in that we inject
real (but non-exploitable) bugs, which can be found through
any bug-ﬁnding technique, not just fuzzing. In addition, our
technique cannot be defeated by ﬁnding and disabling the anti-
fuzzing logic of the program.

IX. CONCLUSION

In this paper, we have presented a novel approach to
software security that adds rather than removes bugs in order
to drown attackers in a sea of enticing-looking but ultimately
non-exploitable bugs. Our prototype, which is already capable
of creating several kinds of non-exploitable bug and injecting
them in the thousands into large, real-world software, rep-
resents a new type of deceptive defense that wastes skilled
attackers’ most valuable resource: time. We believe that with

[21] A. Juels and R. L. Rivest, “Honeywords: Making password-cracking
detectable,” in Proceedings of
the 2013 ACM SIGSAC Conference
on Computer &#38; Communications Security, ser. CCS ’13. New
[Online]. Available:
York, NY, USA: ACM, 2013, pp. 145–160.
http://doi.acm.org/10.1145/2508859.2516671

[22] F. Araujo, K. W. Hamlen, S. Biedermann, and S. Katzenbeisser,
“From patches to honey-patches: Lightweight attacker misdirection,
deception, and disinformation,” in Proceedings of
the 2014 ACM
SIGSAC Conference on Computer and Communications Security, ser.
CCS ’14. New York, NY, USA: ACM, 2014, pp. 942–953. [Online].
Available: http://doi.acm.org/10.1145/2660267.2660329

[23] J. Voris, J. Jermyn, A. D. Keromytis, and S. J. Stolfo, “Bait and snitch:
Defending computer systems with decoys,” in Cyber Infrastructure
Protection Conference, 2013.

[24] J. Voris, J. Jermyn, N. Boggs, and S. Stolfo, “Fox in the trap:
Thwarting masqueraders via automated decoy document deployment,”
in Proceedings of the Eighth European Workshop on System Security,
ser. EuroSec ’15. New York, NY, USA: ACM, 2015, pp. 3:1–3:7.
[Online]. Available: http://doi.acm.org/10.1145/2751323.2751326
[25] Y. Park and S. J. Stolfo, “Software decoys for insider threat,” in
Proceedings of the 7th ACM Symposium on Information, Computer and
Communications Security. ACM, 2012, pp. 93–94.

[26] T. Liston, “LaBrea,” http://labrea.sourceforge.net/labrea-info.html.
[27] E. Spafford, “More than a passive defense,” https://www.cerias.purdue.

edu/site/blog/post/more than passive defense/, July 2011.

[28] Charlie Miller, “Anti-fuzzing,” Unpublished. Available: https://www.

scribd.com/document/316851783/anti-fuzzing-pdf.

[29] O. Whitehouse, “Introduction to anti-fuzzing: A defence in depth aid,”
https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/
2014/january/introduction-to-anti-fuzzing-a-defence-in-depth-aid.
[30] E. Edholm and D. G¨oransson, “Escaping the fuzz - evaluating fuzzing
techniques and fooling them with anti-fuzzing,” Master’s thesis, 2016,
64.

further research, chaff bugs can be a valuable layer of defense
that provides deterrence rather than simply mitigation.

REFERENCES

[1] T. Avgerinos, S. K. Cha, A. Rebert, E. J. Schwartz, M. Woo,
and D. Brumley, “Automatic exploit generation,” Commun. ACM,
[Online]. Available: http:
vol. 57, no. 2, pp. 74–84, Feb. 2014.
//doi.acm.org/10.1145/2560217.2560219

[2] DARPA, “Cyber Grand Challenge (CGC),” https://www.darpa.mil/

program/cyber-grand-challenge.

[3] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-
the 12th ACM Conference on
ser. CCS ’05. New
[Online]. Available:

ﬂow integrity,” in Proceedings of
Computer and Communications Security,
York, NY, USA: ACM, 2005, pp. 340–353.
http://doi.acm.org/10.1145/1102120.1102165

[4] N. Dragoni, S. Giallorenzo, A. Lluch Lafuente, M. Mazzara, F. Mon-
tesi, R. Mustaﬁn, and L. Saﬁna, “Microservices: yesterday, today, and
tomorrow,” ArXiv e-prints, Jun. 2016.

[5] B. Dolan-Gavitt, P. Hulin, E. Kirda, T. Leek, A. Mambretti, W. Robert-
son, F. Ulrich, and R. Whelan, “LAVA: Large-scale automated vulner-
ability addition,” in IEEE Symposium on Security and Privacy, May
2016, pp. 110–121.

[6] J. Pewny and T. Holz, “Evilcoder: Automated bug insertion,” in
Proceedings of the 32Nd Annual Conference on Computer Security
Applications, ser. ACSAC ’16. New York, NY, USA: ACM, 2016,
pp. 214–225. [Online]. Available: http://doi.acm.org/10.1145/2991079.
2991103

[7] Google, Inc., “Multi-process architecture,” https://blog.chromium.org/

2008/09/multi-process-architecture.html.

[8] J. Newsome and D. Song, “Dynamic taint analysis for automatic
detection, analysis, and signature generation of exploits on commodity
software,” in Network and Distributed Systems Symposium (NDSS),
2005.

[9] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting
fuzzing through selective symbolic execution.” in Network and Dis-
tributed Systems Symposium (NDSS), 2016.

[10] C. Collberg, C. Thomborson, and D. Low, “Manufacturing cheap,
resilient, and stealthy opaque constructs,” in Proceedings of the 25th
ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, ser. POPL ’98. New York, NY, USA: ACM, 1998, pp. 184–
196. [Online]. Available: http://doi.acm.org/10.1145/268946.268962
[11] B. Dolan-Gavitt, J. Hodosh, P. Hulin, T. Leek, and R. Whelan,
“Repeatable reverse engineering with panda,” in Proceedings of the 5th
Program Protection and Reverse Engineering Workshop, ser. PPREW-5.
New York, NY, USA: ACM, 2015, pp. 4:1–4:11. [Online]. Available:
http://doi.acm.org/10.1145/2843859.2843867

[12] C. Lattner, “LLVM: An Infrastructure for Multi-Stage Optimization,”
Master’s thesis, Computer Science Dept., University of Illinois at
Urbana-Champaign, Urbana, IL, Dec 2002.

[13] N. Sharma and S. K. Gupta, “Optimal stack slot assignment in gcc,” in

GCC Developers Summit, 2003, p. 223.

[14] ApacheBench - G-Wan, “abc,” http://gwan.com/source/ab.c.
[15] M. Zalewski, “American Fuzzy Lop (AFL),” http://lcamtuf.coredump.

cx/aﬂ/.

[16] J. Foote, “gdb exploitable,” https://github.com/jfoote/exploitable.
[17] G. Balakrishnan and T. Reps, “Wysinwyx: What you see is not
what you execute,” ACM Trans. Program. Lang. Syst., vol. 32,
no. 6, pp. 23:1–23:84, Aug. 2010.
[Online]. Available: http:
//doi.acm.org/10.1145/1749608.1749612

[18] F. Ulrich, “Exploitability assessment with TEASER,” Master’s thesis,

Northeastern University, 2017.

[19] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and
integrity,” in 11th USENIX Symposium
D. Song, “Code-pointer
on Operating Systems Design and Implementation (OSDI 14).
Broomﬁeld, CO: USENIX Association, 2014, pp. 147–163. [Online].
Available: https://www.usenix.org/conference/osdi14/technical-sessions/
presentation/kuznetsov

[20] M. J. A. Mohammed Almeshekah, Eugene H. Spafford, “Improving

security using deception,” Tech. Rep., 11 2013.

