8
1
0
2

l
u
J

4

]

B
D
.
s
c
[

2
v
2
3
6
6
0
.
3
0
8
1
:
v
i
X
r
a

A Guided FP-growth algorithm for multitude-targeted
mining of big data

Lior Shabtay ∗1, Rami Yaari †1,2 and Itai Dattner‡1

1Department of Statistics, University of Haifa, 199 Abba Khoushy Ave,
Mount Carmel, Haifa 3498838, Israel
2Bio-statistical and Bio-mathematical Unit, The Gertner Institute for
Epidemiology and Health Policy Research, Chaim Sheba Medical Center,
Tel Hashomer, 52621 Israel

July 5, 2018

Abstract

In this paper we present the GFP-growth (Guided FP-growth) algorithm, a novel
method for multitude-targeted mining: ﬁnding the count of a given large list of itemsets
in large data. The GFP-growth algorithm is designed to focus on the speciﬁc multitude
itemsets of interest and optimizes the time and memory costs. We prove that the GFP-
growth algorithm yields the exact frequency-counts for the required itemsets. We
show that for a number of diﬀerent problems, a solution can be devised which takes
advantage of the eﬃcient implementation of multitude-targeted mining for boosting
the performance.
In particular, we study in detail the problem of generating the
minority-class rules from imbalanced data, a scenario that appears in many real-life
domains such as medical applications, failure prediction, network and cyber security,
and maintenance. We develop the Minority-Report Algorithm that uses the GFP-
growth for boosting performance. We prove some theoretical properties of the Minority-
Report Algorithm and demonstrate its performance gain using simulations and real
data.

Keywords. data mining, itemset discovery, multi-targeted mining, imbalanced data, minority-
class rules, guided FP-growth.

∗lior.shabtay@yahoo.com
†ramiyaari@gmail.com
‡idattner@stat.haifa.ac.il

1

 
 
 
 
 
 
1

Introduction

This paper is concerned with the problem of targeted mining of itemsets from a given dataset
(e.g., [1], [2], [3], [4], [5], [6], [7], [8]). In particular, we develop a multitude-targeted mining
approach for counting the number of occurrences of a given large list of itemsets in large
data.

The main contribution of this paper is a novel procedure for focused mining of an FP-tree,
which we call the Guided FP-growth procedure or in short GFP-growth. The GFP-growth
procedure serves for mining the support of multitude pre-speciﬁed itemsets from an FP-tree.
The procedure mines only the relevant parts of the FP-tree, in a single and partial FP-growth
process, concurrently collecting the support of all speciﬁed itemsets.

Due to its popularity, availability, and many actual-use implementations, we chose to
base our work on the original FP-growth algorithm ([9] and [10]). Furthermore, many of the
works that attempt to improve the FP-growth algorithm (using improved data structures,
improved procedures for mining them, parallelization, etc., see e.g.,[11], [3], [12]) can also
be applied to the GFP-growth procedure presented below, providing additional time and
memory costs reduction. In addition, using the FP-growth leads us to consider the targeted
mining problem as a constraint which speciﬁes the subset of itemsets which are interesting
(see e.g. [13]). This gives rise to further potential advantages.

We demonstrate that the GFP-growth procedure is a very fast and generic tool, which
can be applied to many diﬀerent purposes. In particular, we study in detail the problem
of mining minority-class rules from imbalanced data, a scenario that appears in many real-
life domains such as medical applications, failure prediction, network and cyber security,
and maintenance. We develop the Minority-Report Algorithm that uses the GFP-growth
for boosting performance. We prove some theoretical properties of the Minority-Report
Algorithm and demonstrate its performance gain using simulations and real data.

Further emphasizing the usefulness and applicability of our eﬀorts to improve multitude
targeted mining are the works [5], [6], [7], [8]. Indeed, these works take advantage of tar-
geted mining in itemset tree, as a tool used by algorithms for solving problems like frequent
itemset mining and association rule mining. Each of these algorithm makes multitude calls
to targeted mining, hence the need for an improved multitude targeted mining algorithms.
The paper is organized as follows. In Section 2 we brieﬂy review related literatures. In
Section 3 we introduce the Guided FP-growth algorithm and explore its theoretical prop-
erties.
In Section 4 we study in detail the problem of mining minority-class rules from
imbalanced data. Section 5 includes a variety of additional examples for which the GFP-
growth algorithm can be applied in order to potentially boost performance. A summary of
our main contributions, and suggestions for future research are presented in Section 6.

2 Related work

Previous papers studying targeted mining ([1], [6], [3]) use an ’itemset tree’ which is similar
in concept to the FP-tree ([9], [10]). These algorithms mine the itemset tree given a single
target itemset at a time as input. Depending on the items comprising that input target-
itemset, each invocation of the procedure potentially traverses a considerable part of the

2

In case a large number of target-itemsets need to be mined, the diﬀerent
itemset tree.
respective invocations may overlap, resulting in increased time complexity.
In addition,
the data for each and every target-itemset is collected from many diﬀerent locations in the
complete itemset tree, again leading to increased complexity, as opposed to collecting data
from reduced conditional-trees in FP-growth.

Some of the works (e.g. [1], [4]) suggest an itemset mining procedure over itemset trees,
in which, given a single itemset as a parameter, all frequent supersets of that itemset are
found and counted.

The itemset tree is diﬀerent from an FP-tree in two aspects. First, it represents the entire
dataset, including all items, regardless of their frequency, in this way the itemset tree can be
reused for diﬀerent types of queries, e.g. with diﬀerent min-support. Second, the item-set
tree is arranged according to a pre-deﬁned lexical order of the items. This pre-deﬁned order
is actually used by the targeted mining procedures. These diﬀerences make the FP-tree more
compact than an itemset tree, improving the performance due to building the tree from the
frequent-items only from the start, and optimizing the order in which the items are used for
building the tree. This comes on the expense of an additional pass through the database
and less reusability of the tree for potential other required queries. The targeted itemset
tree mining procedures also do not involve recursion and creation of conditional sub-trees
which are required by the FP-growth procedure, but this comes with the penalty of reduced
performance when needing to mine a lot of itemsets, due to the need to traverse the tree
separately for each one.

[2] presents an addition of per sub-tree information regarding the minimum and maximum
item-id appearing in it (according to the lexical order). This information is used for improv-
ing the time complexity of the targeted mining procedure by allowing it to make smarter
[3] presents a memory-usage
decisions as to whether it is required to check each sub-tree.
related optimization of [1], in which each single-preﬁx path portion of the tree is represented
by a single node. Observe that the same optimization can also be applied on an FP-tree.

One can consider the targeted mining problem as a constraint which speciﬁes the subset
of itemsets which are interesting ([14], [15], [16], [17], [18], [19], and [13]). Constrained
mining is generally used for specifying limitations on the search space in which to look
for the itemsets of interest. In most cases, these limitations are manually set, and reﬂect
the preferences of the user. Item constraints are speciﬁc type of constraints which specify
limitations on the items and item combinations comprising the itemsets of interest. Most
works focus on the case in which the itemsets of interest are the supersets of itemsets in
the constraint list. Many existing item-constraint related works are based on the Apriori
principle of iterative candidate generation and enumeration. Other existing works do not
try to address the scalability of constraints number. One FP-growth based work that does
address the scalability of item constraints number is [16]. Still its scalability is not optimal for
our purposes due to checking all the subsets of each itemset-constraint, and due to executing
an additional FP-growth in parallel to the one executed over the dataset.
[20] provide a
more generic framework, with similar scalability characteristics.

A diﬀerent approach is to use a generic algorithm, and adapt it to solve the speciﬁc
problem at hand.
[14] and [15] provide a generic extention for pattern-growth algorithms,
like the FP-growth, supporting convertible monotone and anti-monotone constraints and
pushing such constraints deep into the pattern-growth process. One issue with this approach

3

is that the multitude-targeted itemset mining problem is not convertible monotone and not
convertible anti-monotone: for example, a convertible anti-monotone procedure, adapted to
mine the target itemsets has to include all their preﬁxes as well. Therefore, such a procedure
will explore, count, and output all the target itemsets as well as all their preﬁxes, which
will then need to be removed e.g. at a postprocessing stage. Additional penalty comes from
the generic nature of the solution: involving multitude calls to the anti-monotone boolean
function (where the complexity of each call depends on the respective itemset length), and
missing the problem-speciﬁc optimizations and adaptations, such as more focused search and
data-reduction.

In the next section we describe the Guided FP-growth procedure, which is speciﬁcally

adapted and optimized for mining multitude targeted-itemsets.

3 The Guided FP-growth procedure

3.1 Background

As mentioned above, the Guided FP-growth procedure developed in this work is based on
the original FP-growth algorithm, so we ﬁrst brieﬂy review some subjects in the context of
mining frequent itemsets and association rules. In particular, note that the classical data-
mining algorithms such as Apriori [21] and FP-growth ([9], [10]) are designed for ﬁnding all
frequent itemsets that comply to a speciﬁed minimum support. The problem of multitude-
targeted mining requires focusing on a speciﬁc set of itemsets, and thus the performance of
such algorithms is not optimal in this case, especially when the number of diﬀerent items is
large, the number of items per transaction is large, and the minimum-support is low.

The Apriori algorithm of [21] is one of the most popular methods for itemset mining.
Many studies adopt an Apriori-like approach, which is based on an anti-monotone heuristic,
as presented in [21]: if an itemset of length k is not frequent (i.e. its support is less than the
so called min-support), the support of any of its length k + 1 supersets is not frequent as well.
The Apriori algorithm iteratively generates candidate itemsets of length k + 1 from the set
of the frequent itemsets of length k, and checks their corresponding support in the database.
Apriori-like algorithms have two main drawbacks which may degrade their performance: the
number of candidate itemsets at each iteration may become huge; the database needs to be
scanned at each iteration, where the number of iterations is equal to the length of the longest
mined frequent itemset.

The FP-growth (frequent-pattern growth) algorithm, presented in [9] and [10] does not
require candidate generation and scans the database twice, thus resolving the two drawbacks
of the Apriori approach.

The FP-growth algorithm consists of two main steps: First, the content of the database
is compressed into a special tree structure called FP-tree. Then, the FP-tree is mined by an
algorithm called FP-growth to extract all frequent itemsets.

The FP-tree is constructed in two steps: in the ﬁrst step, the database is scanned in order
to decide which of the items is frequent. Only frequent items are used when building the
FP-tree. In the second step the database is scanned again and the actual tree is constructed.
The tree nodes are arranged according to the represented-item frequency, such that nodes

4

representing more frequent items have a better chance to be merged.

The FP-growth step of the algorithm mines the FP-tree and extracts the frequent item-
sets. The process uses a divide-and-conquer recursive approach: it loops through the frequent
items in ascending-support order, and for each such item, it ﬁrst reports its support and then
recursively mines the conditional FP-tree which represents only transactions containing that
item.

The FP-growth algorithm may still have high run-time and memory costs. When used
for solving the problem of multitude-targeted mining, we have an opportunity to reduce the
costs, since the target itemsets are speciﬁed, which opens the door to devise a more focused
mining eﬀort. Below we present the GFP-growth algorithm, which reduces the time required
for the procedure to complete as well as the memory costs, by focusing the eﬀorts to what
is required for mining the targets of interest.

For this purpose, we suggest implementing an itemset tree, which we call TIS-tree, rep-
resenting the pre-speciﬁed itemsets for which we would like to mine the support from the
FP-tree. The TIS-tree is built according to the order of the pattern-growth process, which in
the case of FP-growth is the reverse item-ordering of the one used for building the FP-tree
(i.e. support-ascending order). The TIS-tree does not need to include itemsets which are
known in advance not to appear in the FP-tree, e.g. those containing items which do not
appear in the FP-tree. Each node of the TIS-tree contains a ﬂag, called ’target’, indicating
whether this node represents a target itemset.

The following are the highlights of the GFP-growth algorithm, and the way it uses the

TIS-tree for solving the multitude targeted-itemsets mining problem:

1. The ﬂow of the GFP-growth procedure follows the TIS-tree at each step of its execution.
In this way, the GFP-growth procedure actually performs a partial walk over TIS-tree,
focusing the process on the target-itemset tree, which is generally smaller than the
FP-tree.

2. Since the algorithm follows the TIS-tree, it consults the FP-tree header-table (in O(1))
before diving into the creation and exploration of the respective conditional FP-tree
and sub TIS-tree.

3. In case the next TIS-tree node to process is a leaf (i.e. has no children), no conditional
FP-tree is created and no recursive call is conducted. This check is fast (O(1)) with
the right data structure - for example having such a ﬂag in each of the TIS-tree nodes.

4. The algorithm uses information about the sub-tree of the TIS-tree in order to conduct
data-reduction when building the conditional FP-tree. Speciﬁcally, the conditional
FP-tree does not need to include items which do not appear in the respective TIS-tree
sub-tree. The optimized conditional FP-tree creation procedure skips these items when
creating the conditional FP-tree.

5. We let the GFP-growth procedure provide its results by updating a counter, represent-
ing the itemset frequency-count, inside each of the respective nodes of TIS-tree. This
saves the work required for building a separate data strucuture for holding the results.

5

6. The following optimization takes advantage of the fact that in many applications the
GFP-algorithm is required not to apply a min-support constraint (and should only be
applied in these applications):
in case the node representing the currently processed
preﬁx is not a target node, there is no need to calculate the support for the itemset
represented by that node. For each such preﬁx, this enhancement eliminates the need
for the count-calculation work, which potentially requires going through the linked-list
of curerntly processed item in the FP-tree.

Observe that the above optimizations are all based on O(1) checks added at diﬀerent
steps of the algorithm, and therefore do not hurt the scalability and performance even in the
improbable extreme worst case. For this reason, these optimizations well ﬁt the multitude-
targeted mining problem requirements.

3.2 GFP-growth - detailed

The guided FP-growth procedure serves for mining the support of multitude pre-speciﬁed
itemsets from an FP-tree.

Let:

• I = {a1, a2, . . . , am} be a set of m items;

• DB = {T1, T2, . . . , Tn} a database that contains n transactions, Ti = {ai1, ai2, . . . , aik},

aij ∈ I, k ≤ m and i = 1, ..., n;

• An itemset α is a set of items {a1, a2, . . . , ak}, where k ≤ m;

• The count C (or occurrence frequency) of an itemset α, is the number of transactions

containing α in DB: C(α) = |Ti : α ⊆ Ti|;

• The support S of an itemset α, is C(α)/|DB|.

The inputs for a multitude-targeted mining problem are:

• An FP-tree which is the source for the target mining;

• A tree-based data-structure that contains the itemsets which are the mining targets.
We call this data-structure TIS-tree (Target Item-Set Tree). A node in TIS-tree which
represents an itemset α is denoted by TIS-tree(α).

We say that α ∈TIS-tree if and only if the itemset α was inserted to TIS-tree. For each
α ∈TIS-tree, TIS-tree(α).g-count is a counter. This counter is initiated to zero for each
α ∈TIS-tree. The GFP-growth (guided-FP-growth) procedure which is described below
updates this counter. For each α ∈TIS-tree, TIS-tree(α).target is a boolean ﬂag saying
whether this node represents a target itemset, for which data should be collected.

As discussed above, the GFP-growth procedure takes advantage of a coordinated arrange-
ment of the trees, and performs coordinated exploration of them. Therefore, the TIS-tree
should be built according to the order of the pattern-growth process, which in the case of
FP-growth is the reverse item-ordering of the one used for building the FP-tree (i.e. support-
ascending order). In other words, TIS-tree should be arranged such that for each pair of

6

nodes ai and aj in TIS-tree, where node aj is a child of node ai, C(aj) ≥ C(ai). In this way,
by following the TIS-tree in a top-down manner the GFP-growth procedure ensures that the
FP-tree is explored in a bottom-up manner, as done in FP-growth.

The pseudo-code implementing this coordinated TIS-tree guided FP-tree exploration is

described below. In the pseudo-code:

• ai ∈TIS-tree means that ai is a direct child of the root of TIS-tree - represented by a

node in TIS-tree denoted by TIS-tree(ai)

• ai ∈FP-tree means that ai appears in the header table of FP-tree, as deﬁned in [10].

• ’ai.count in FP-tree’ means the count of ai in the database represented by FP-tree.
The implementation of getting this count from FP-tree is as described in [10], which is
to follow the linked list starting at the entry of ai in the header table of FP-tree, and
summing the counts from the visited nodes

• The outcome of the procedure is that each entry in TIS-tree is updated with the

frequency of appearance in FP-tree of the respective itemset

Note that the GFP-algorithm code below does not assume a min-support constraint,
and indeed such a constraint is not required by the Minority-Report Algorithm use case
and other use-cases as suggested in the sequel. The min-support constraint can be added
to the algorithm, just as done in [10], [14], and [15], and if added, will aﬀect the created
conditional-trees, further reducing their size.

Algorithm 3.1: GFP-growth(TIS-tree, FP-tree)

for each item ai ∈ TIS-tree

do if (ai ∈ FP-tree)

if (TIS-tree(ai).target)

then TIS-tree(ai).g-count = ai.count in FP-tree;

then

if (TIS-tree(ai) has children)

construct ai’s conditional FP-tree c-Tree;
if c-Tree 6= ∅

then call GFP-growth(TIS-tree(ai), c-Tree);

then 









As explained above, the GFP-growth procedure actually performs a partial walk over
TIS-tree, focusing the process on the target-itemset tree, while consulting the FP-tree header-
table (in O(1)) before performing each recursive call. For example, let ai be an item attached
to the root of the TIS-tree. The GFP-growth procedure processes the node ai in the loop
of its ﬁrst, ’outmost’ invocation, and then it creates a conditional tree for ai and uses it for
invocating a recursive call. Let aj be an item processed in the loop of this recursive call,
which means that aj is attached to ai in TIS-tree. Since the order of TIS-tree is the reverse
of the one in the FP-tree, any transaction containing itemset (ai, aj) will be reﬂected in the
FP-tree as a node aj which is downstream of an ai node. Therefore that node will appear in

7

the conditional tree of ai. This, in turn, ensures that all occurrences of (ai, aj) are correctly
counted.

This pseudo code takes advantage of the TIS-tree-focus and provides an optimization
that in case TIS-tree(ai) is a leaf (i.e. has no children), no conditional FP-tree is created
and no recursive call is conducted. An additional optimization which takes the same idea
further is to use information about the sub-tree TIS-tree(ai) in order to optimize the cre-
ated conditional FP-tree c-Tree. Speciﬁcally, c-Tree does not need to include items which
are not in TIS-tree(ai). The optimized conditional FP-tree creation procedure skips these
items when creating the conditional FP-tree. For example, the call for ”GFP-growth(TIS-
tree(m), (f : 3, c : 3, b : 1))” in the example given below, can actually be replaced by ”GFP-
growth(TIS-tree(m), (f : 3))” since b and c do not appear in the sub-tree TIS-tree(m). Such
an optimization requires an implementation of TIS-tree that holds the required information
at each node. An example implementation is to maintain a bit-map at each node of the
TIS-tree, with a per-item bit telling whether it appears in the sub-tree rooted by that node.
In case the number of diﬀerent items is large, this bit-map can become too large. To cope
with this issue one can replace the bit-map with a hash-table, a linked-list, or a set of ranges.
Alternatively or additionally, known techniques which reduce the overhead of the conditional
FP-trees can be used, e.g. as in [11].

The GFP-growth procedure is a general-purpose procedure which can be used for diﬀerent
purposes (e.g. as part of the Minority-Report Algorithm described below). Regardless of
the context of the speciﬁc use-case, the GFP-growth updates TIS-tree(α).g-count for each
α ∈TIS-tree to be the frequency-count of α in its input FP-tree (e.g. F P0 in the Minority-
Report Algorithm below), and the actual meaning and use of this gathered information
diﬀers according to the speciﬁc use-case.

The following theorem shows the correctness of the GFP-growth procedure, in the sense

that the count information is correctly collected for all target itemsets.

Theorem 1. Guided FP-growth correctness

At the end of execution of the GFP-growth procedure, which is given an FP-tree FP and
an TIS-tree as input, TIS-tree(α).g-count = C(α) for each α ∈TIS-tree, where C(α) is the
count of the itemset α in the database represented by FP.

Note: observe that the database represented by FP does not contain infrequent items

which might exist in the original database.

Proof. Assume that C(α) > 0, since TIS-tree is ordered according to the pattern-growth
order, the GFP-growth procedure recursively traverses the path of α in the pattern-growth
order. As shown in [10], this means that each conditional tree created before reaching the
step of adding ai ∈ α to the tree-condition, contains a representation of all the occurrences
of α. This, in turn, means that whenever the code asks if (ai ∈FP-tree) for an ai ∈ α, the
answer is yes and the process continues.

Therefore, the complete recursion process continues and the node of α is reached. Now,
the code ”TIS-tree(ai).g-count = ai.count in FP-tree” is executed. At this point the condi-
tional tree contains a representation of all the transactions which are supersets of (α − ai),
so the operation is actually TIS-tree(α).g-count = C((α − ai) + ai) = C(α).

8

In case C(α) = 0, the above process will either reach a point in which the conditional
tree is empty and therefore TIS-tree(α).g-count will stay 0 as initiated, or follow the above
process till reaching the step in which it assigns TIS-tree(α).g-count = C((α − ai) + ai) =
C(α) = 0.

In the next section, we demonstrate the power of GFP-growth by showing how it en-
ables devising an eﬃcient solution to the common and practical problem of minority-class
association-rules from imbalanced data.

4 Case study: mining minority-class rules from imbal-

anced data

In this section we study the problem of mining the minority-class association-rules from
imbalanced data. Association rules represent relationships among sets of items in a dataset.
An association rule α → β, where α and β are disjoint itemsets, represents the likelihood of
β to occur in a transaction containing α. In many implementations, the process of mining
association rules is decomposed into two separate steps:

(i) Find the frequent itemsets that comply to a speciﬁed minimum support.

(ii) Use the frequent itemsets to generate association rules that meet a conﬁdence threshold.

The concept of using itemset mining for the purpose of ﬁnding per-class rules is introduced
in [22]. Mining of class association-rules can be viewed as a special form of association-rule
mining. With classiﬁcation, it is assumed that each record in the database is assigned
with a class. For the purpose of using itemset and association-rule mining in order to
derive classiﬁcation rules, each class is assigned with an item representing it, and each
transaction contains exactly one class-item. With such a database, a classiﬁcation rule-set
is a subset of the association rules: those with the speciﬁed classes as their consequences.
[22] introduces the notion of ruleitems for generating class association-rules (CARs) for
classiﬁcation purposes. A ruleitem is deﬁned as a pair <condset, y >, representing the
classiﬁcation rule condset → y, where condset is an itemset and y is a single item representing
a class.

As explained above, we are interested in mining the class association-rules of speciﬁc
subset of the classes. Mining such rules has a purpose of its own since it can generate
interpretable description of the individual classes. Example use-cases in which such reports
provide added value are failure detection and root-cause analysis. Such speciﬁc-class reports
are most insteresting in imbalanced data scenarios. By imbalanced data we mean that the
class distribution is unbalanced, so that the class or classes of interest have a considerably
lower probability of occurrence (we call such classes ’minority classes’ or ’rare classes’).
Scenarios of imbalanced data appear in many real-life domains such as medical applications,
failure prediction, network and cyber security, maintenance, etc.

One way to ﬁnd the class association-rules of the target class is to use one of the
known techniques for ﬁnding the ruleitems of all the classes. Such methods generally use
association-rule mining with the min-support set to a suﬃciently low value provides itemsets

9

that are correlated with the target class. However, in the case of imbalanced data, when
applying class-association rule discovery for mining rules for the rare classes, it is required to
set the min-support to a very low value. Unfortunately, class-association rule mining suﬀers
from very low performance when the min-support is low due to the large intermediate data
structures created and number of itemsets which pass this weak constraint (most of which
are not required when mining rare-class rules). Previous works aiming to resolve this issue
mainly focus on Apriori-based algorithms and apply remedies like the use of per-class min-
support, new interestingness criteria (e.g. [23], [24], [25]), and mining of the optimal rule set
as deﬁned in [26] (see also [23], [27], [25]) in order to reduce the amount of candidates created
at each level and the amount of produced rules. In [28] the authors present an algorithm for
mining association rules with class constraints, which can be used for focusing on a speciﬁc
class.

The above-mentioned algorithms involve an iterative candidate generation and enumer-
ation process, and therefore, their performance is derived from Apriori-like characteristics,
meaning that the complete data-set is scanned a number of times and that potentially a
huge number of candidates are created during at least some of the iterations. Thus, it makes
sense that an approach based on FP-growth will do better in that respect.

For the purpose of mining the minority-class rules from imbalanced data we develop
the Minority-Report Algorithm (MRA) which is based on the GFP-growth algorithm pre-
sented above. We prove some theoretical properties of MRA and demonstrate its superior
performance using simulations and real data.

4.1 Minority-Report Algorithm (MRA): Mining minority-class rules

from imbalanced data using the GFP-growth procedure

In this subsection, we present a novel FP-growth and GFP-growth based procedure, opti-
mized for mining of rules of a single rare-class from imbalanced data. The procedure uses
both the original FP-growth of [10] and the GFP-growth procedure presented above. The
main principles of the new procedure are as follows:

1. Apply a ﬁrst pass over the dataset in order to pick only the items which are frequent
in the rare class (i.e. the number of rare-class transactions which include each of these
items is above the required min-support threshold), and by this gain a smaller tree-
based representation of the database, leading to a large reduction in the usage of time
and memory resources.

2. Create two FP-trees, one for the rare class and one for the common class, where the

rare-class tree is expected to be considerably smaller.

3. Use the FP-growth procedure of [10] in order to mine the smaller tree and get the
frequent itemsets for the target class, which serve as the antecedent part of all potential
rules.

4. Use the Guided FP-growth procedure presented above, in order to mine the frequency
of the common class for the itemsets discovered in step 3 above. In this way, the mining
of the larger tree is focused and therefore much faster.

10

We choose to focus on a single rare-class, rather than a number of rare-classes, for the
purpose of simplicity. The procedure can be extended to mine a number of rare-classes
concurrently by either using per class trees or by maintaining per class counters on each
node of a single tree representing all the target classes.

A more formal description of the algorithm is as follows. Let:

• A classiﬁcation-target item c, is an item which is used for classifying transactions.
In a basic imbalanced-data scenario we assume that transactions containing this item
belong to class c, and all others belong to class 0

• An association rule is an implication α → β, where α and β are itemsets, and α ∩β = ∅

• A classiﬁcation rule is an association rule α → c, where α is an itemset, and c is a

classiﬁcation-target item

• The support of a rule α → c is deﬁned as the support(α ∪ c)

• The conﬁdence of a rule α → c is deﬁned as support(α ∪ c)/support(α)

In the discussion below, we assume a single target class, denoting the target class as ’1’, i.e.
c =’1’.

• DB1 is a subset of DB including only the transactions containing item 1. DB1 =

{Ti ∈ DB : 1 ∈ Ti}

• DB0 is a subset of DB including only the transactions which do not contain the item

1. DB0 = {Ti ∈ DB : 1 /∈ Ti}

• The count C1(α), is the number of transactions containing α ∪ 1 in DB, C1(α) = |{Ti :
α ∪ 1 ⊆ Ti}|. Observe that C1(α) is also the count of α in DB1, C1(α) = |{Ti ∈ DB1 :
α ⊆ Ti}|

• The count C0(α), is the number of transactions containing α and not 1 in DB, C0(α) =
|{Ti : α ∈ Ti & ∼ (1 ⊆ Ti)}|. Observe that C0(α) is also the count of α in DB0,
C0(α) = |{Ti ∈ DB0 : α ⊆ Ti}|

The input for the Minority-Report Algorithm are the transaction database DB, the
target-class, a minimum support threshold ξ, 0 ≤ ξ ≤ 1, and a minimum conﬁdence threshold
minconf, 0 ≤ minconf ≤ 1. The output of the algorithm is the set of the target-class rules
which conﬁrm to the minimum-support and minimum conﬁdence thresholds. Observe that ξ
should be smaller than the relative frequency of the target class in DB, i.e. ξ < |DB1|/|DB|,
or else no rules will be produced.

We assume an implementation of the FP-growth procedure which inserts each discovered

frequent-itemset, along with its frequency-count, into TIS-tree.

The Minority-Report algorithm uses the TIS-tree in order to store itemsets which are
frequent in DB1. After selecting the items to be used for building the trees as described
above, it creates two FP-trees, F P0 which is a representation of DB0, and F P1 which is
a representation of DB1. It then applies an FP-growth procedure on F P1 in order to set

11

TIS-tree to hold the set of frequent itemsets in DB1, and then applies the GFP-growth in
order to get their frequency count in DB0.

As already deﬁned above, for each α ∈ TIS-tree, TIS-tree(α).g-count is a counter, which
is initiated to zero and set by the GFP-growth procedure. In the Minority-Report algorithm,
the GFP-growth procedure is applied on DB0. We show that after GFP-growth is applied,
for each α ∈ TIS-tree, TIS-tree(α).g-count = C0(α). An additional counter for each α ∈
TIS-tree is TIS-tree(α).count. We assume that the FP-growth procedure, applied by the
Minority-Report procedure on DB1, inserts the count it calculated for α to TIS-tree(α).count.
Therefore, after FP-growth is applied, for each itemset α which is frequent in DB1, TIS-
tree(α).count = C1(α). The two counters are used for calculating the conﬁdence for each
reported rule.

Algorithm 4.1: Minority-Report(DB, ξ, minconf)

C ∗ = ξ × |DB|

// First pass over the dataset
I ′ = {ak ∈ I : C1(ak) ≥ C ∗}
DB′
DB′

i = Ti ∩ I ′ : Ti ∈ DB0}
i = Ti ∩ I ′ : Ti ∈ DB1}

0 = {T ′
1 = {T ′

// Second pass over the dataset
F P0 = FP-tree(DB′
0)
F P1 = FP-tree(DB′
1)

// Apply the classical FP-growth on F P1, creating TIS-tree
TIS-tree = FP-growth(F P1, min-count = C ∗)

// Apply the GFP-growth procedure on F P0, populating TIS-tree
GFP-growth(TIS-tree, F P0)

// Pruning in order to generate strong rules
// using the well-known technique
for each itemset α ∈ TIS-tree

do






conf = TIS-tree(α).count /
(TIS-tree(α).count + TIS-tree(α).g-count)
if (conf ≥ minconf)

then 


generate-rule R = (α → 1)
support(R) = TIS-tree(α).count/|DB|
conﬁdence(R) = conf



The Minority-Report algorithm can be performance-optimized by coordinating the way
in which the data-structures are organized. More speciﬁcally, a performance-optimized im-
plementation of Minority-Report should:

12

• Use identical item-ordering for the two FP-trees. For example, use the item-support
over the entire DB for determining the item ordering in both FP-trees (support-
descending order). Such an item-ordering ensures that the FP-trees used by the algo-
rithm are as-good-as and comparable to that of an FP-growth applied over the entire
DB.

• Build the TIS-tree, using support-ascending order, as described in Section 3.2.

This coordinated order of the trees optimizes the performance of the construction of the
TIS-tree since it is in-line with the order in which the FP-growth procedure traverses F P1.
In more details, let ai be a frequent item that is processed in the loop of the ﬁrst ’outmost’
invocation of FP-growth. The FP-growth procedure will insert it to the TIS-tree and attach
it to the root node. It will then create a conditional tree for ai, containing only items which
come after ai in the decided order of the pattern-growth process and use it for invocating a
recursive call. Let aj be an item processed in the loop of this recursive call, such that (ai, aj)
is a frequent itemset. The FP-growth procedure simply adds aj to the TIS-tree and attaches
it to ai. The process continues this way and the TIS-tree is created in the pattern-growth
process order.

Theorem 2. At the end of the GFP-growth step of the Minority-Report algorithm execution,
TIS-tree contains all and only the itemsets α, such that support(α ∪ 1) = C1(α)/|DB| ≥ ξ.
For each such itemset α, TIS-tree(α).count = C1(α) and TIS-tree(α).g-count = C0(α).

The claims in this theorem are divided into the following three lemmas, and therefore its

correctness is directly derived from their correctness, which is proved below.

Lemma 1. At the end of the GFP-growth step of algorithm execution, α ∈TIS-tree for all
the itemsets α for which support(α ∪ 1) = C1(α)/|DB| ≥ ξ, and for each such α, TIS-
tree(α).count = C1(α).

Proof. Observe that the way TIS-tree is created by the algorithm is by applying the exact
three steps of the classical FP-growth algorithm on DB1 with min-count of ξ × |DB|. Since
C1(α) is the count of α in |DB1|, and since C1(α) = C(α∪1) ≥ ξ×|DB|, the correctness of the
classical FP-growth leads to the conclusion that α is in TIS-tree and that TIS-tree(α).count
= C1(α) = C(α ∪ 1).

Lemma 2. At the end of the GFP-growth step of algorithm execution, each of the elements
of TIS-tree represents an itemset α for which support(α ∪ 1) = C(α ∪ 1)/|DB| ≥ ξ.

Proof. Since TIS-tree is created by applying the exact three steps of the classical FP-growth
algorithm on DB1 with min-count of ξ × |DB|, C1(α) ≥ ξ × |DB| holds for each itemset α
represented by a node in the resulting TIS-tree. Since C1(α) = C(α ∪ 1), we get C(α ∪ 1) ≥
ξ × |DB|, and therefore support(α ∪ 1) = C(α ∪ 1)/|DB| ≥ ξ.

Lemma 3. At the end of the GFP-growth step of algorithm execution, for each itemset
α ∈TIS-tree, TIS-tree(α).g-count = C0(α).

13

Proof. The algorithm mines the FP-tree created for DB0 (F P0) using the guided FP-growth
procedure and the TIS-tree as a guide. For each α ∈TIS-tree, F P0 correctly represents
C0(α) since all items in α were taken into consideration when building F P0 from DB0.
This is true since TIS-tree was extracted from F P1 and the same items were taken into
consideration while building F P0 and F P1. Therefore, according to Theorem 1 above (GFP-
growth correctness), each TIS-tree(α).g-count value reported for a rule α → 1 is equal to
C0(α).

Theorem 3. Minority-Report Algorithm correctness

The Minority-Report algorithm generates all and only the rules α → 1 which conﬁrm
to the required min-support and min-conﬁdence constraints, where 1 is the rare class. The
support and conﬁdence reported by the algorithm for each of these rules are their support and
conﬁdence in DB.

Proof. According to Theorem 2, at the end of the GFP-growth step of the Minority-Report
algorithm execution, TIS-tree contains all and only the itemsets α for which support(α ∪1) =
C(α∪1)/|DB| ≥ ξ. Since support(α → 1) = support(α∪1), all and only frequent rules α → 1
are considered for generation at that point in the algorithm. According to the deﬁnition of
conﬁdence and to Theorem 2, the conﬁdence calculated for each rule α → 1 at the next step
of the algorithm is indeed conﬁdence(α → 1). Therefore, the algorithm reports all and only
the rules α → 1 which conﬁrms to the support and conﬁdence constraints, and reports their
correct support and conﬁdence attributes.

4.2 Example of Minority-Report Algorithm using guided-FP-growth

This example illustrates an execution of the Minority-Report algorithm, using the GFP-
growth algorithm. Let DB be as given in Table 1.

Let us now follow the execution of the Minority-Report algorithm, with DB as the input
dataset, class 1 as the target class, min-support ξ = 0.125 (i.e. min-count C ∗ = 1), and
min-conﬁdence = 0.2. The ﬁrst pass over the dataset calculates I ′, which is the list of items
that count above C ∗ in DB1 (I ′ = {ak ∈ I : C1(ak) ≥ C ∗}). With the DB shown in Table 1,
I ′ = {f, c, b, m}. Items a, d, g, h, i, l, n, o, p are removed due to not passing the threshold in
class 1. Observe that this step is a signiﬁcant optimization of the algorithm in both time
and memory terms, as the fact that some items are not used for building the FP-trees leads
to much smaller trees. Smaller trees mean less memory and less time for their building and
mining. Observe also that all these items pass the min-support threshold in DB, so the
well-known solution which executes FP-growth for DB would end up with a much larger
FP-tree, including all of them.

The second pass through the dataset creates the two FP-trees, F P0 and F P1. F P1 is
presented in Figure 1, while F P0 is presented in Figure 2. Next, FP-growth is applied on
F P1, creating TIS-tree. TIS-tree is presented in Figure 3.

Now, the Minority-Report algorithm calls the GFP-growth procedure as follows: call
GFP-growth(TIS-tree, F P0). The GFP-growth loops through the items I ′ = {f, c, b, m}, as
follows:

1. For m: TIS-tree({m}).g-count = 3, c-Tree(m) = {(f : 3)} call GFP-growth(TIS-
tree({m}), {(f : 3)}) (observe that b and c are not included in the conditional tree,

14

Table 1: A database example

TID Items

Class

100
200
300
400
500
600
700
800

f, a, c, d, g, i, m, p 0
0
a, b, c, f, l, m, o
b, f, h, j, o
0
0
b, c, k, s, p
a, f, c, e, l, p, m, n 0
1
f, m
1
c
1
b

Figure 1: Tree F P1 of example of Minority-Report Algorithm using guided-FP-growth

Figure 2: Tree F P0 of example of Minority-Report Algorithm using guided-FP-growth

15

Figure 3: The TIS-tree of example of Minority-Report Algorithm using guided-FP-growth

since they do not appear in TIS-tree({m}))
GFP-growth(TIS-tree({m}), {(f : 3)}) performs a single-iteration loop for f as follows:
TIS-tree({m, f }).g-count = 3 (no need for a recursive call since TIS-Tree({m, f }) has
no children)

2. For b: TIS-tree({b}).g-count = 3 (no need for a recursive call since TIS-Tree({b}) has

no children)

3. For c: TIS-tree({c}).g-count = 4 (no need for a recursive call since TIS-Tree({c}) has

no children)

4. For f : TIS-tree({f }).g-count = 4 (no need for a recursive call since TIS-Tree({f }) has

no children)

Now, TIS-tree looks as presented in Figure 4.
At the end of the GFP-growth procedure, g-counter is updated at all nodes of TIS-tree.
The last step of the Minority-Report algorithm turns each node in TIS-tree into a rule,
calculates the conﬁdence from the counter and g-counter ﬁelds of the node, and checks against
the min-conﬁdence threshold (which is 0.2 in our example):

1. Conﬁdence({m}) = 1/(1 + 3) = 0.25

2. Conﬁdence({b}) = 1/(1 + 3) = 0.25

3. Conﬁdence({c}) = 1/(1 + 4) = 0.2

4. Conﬁdence({f }) = 1/(1 + 4) = 0.2

5. Conﬁdence({m, f }) = 1/(1 + 4) = 0.2

16

Figure 4: Second TIS-tree of example of Minority-Report Algorithm using guided-FP-growth

Turns out that all pass the min-conﬁdence threshold and therefore all are turned into
rules which are reported along with their respective support and conﬁdence: {m} → 1, {b} →
1, {c} → 1, {f } → 1, {m, f } → 1.

4.3 Numerical results

The computational performance of frequent itemsets mining algorithms is aﬀected by several
parameters: the min-support threshold which is a parameter of the method, the total number
of diﬀerent items in a dataset, the number of transactions, and the statistical characteristics
of the data. By ’statistical characteristics’ we mean that we view a dataset as a realization
of a random process that follows some probabilistic model. For instance, in the simulations
below we use a probabilistic model where each item in a transaction is a Bernoulli random
variable with success probability pX . Given a probabilistic model, one can determine other
data characteristics such as the average or maximum transaction length. This in turn aﬀects
the computational performance of frequent itemsets mining algorithms. In general, one can
say that the running time of frequent mining algorithms increases as the number of items and
number of transactions increases. However, this depends also on the statistical characteristics
of the data at hand; see for instance [29].

In this part of our study we are interested in understanding the data scenarios where
using the Minority Report algorithm, and hence the GFP-growth algorithm, leads to im-
provement in computational performance. In this use-case, there is another important pa-
rameter, the class distribution. By class distribution we mean the level of imbalance of the
response variable, or the target probability which we denote by pY , where Y =’1’ is the
target variable. Speciﬁcally, we consider various scenarios where we ﬁx some parameters
and calculate the running time of the algorithm. Each such scenario was repeated 20 times
(Monte Carlo experiments) and the average of all running times over the 20 simulations is re-
ported. The simulations were run over a Linux Virtual-Machine, m4.16xlarge Amazon Web

17

Services (AWS) instance with 256 GB RAM. We used the C implementation of FP-growth
by Christian Borgelt ([30], [31]) and altered it to perform the Minority Report algorithm.
The performance ﬁgures reported in this section are based on a partial GFP-growth imple-
mentation. Speciﬁcally it does not reﬂect the potential saving that would result from the
enhancements which save work and reduce data according to the content of the sub TIS-tree,
as described above.

Figures 5 (a), (b) and (c) present the running time (in seconds) of the FP-growth (a),
GFP-growth (Minority Report; b) and the ratio between their running time (c) as a function
of the number of the target-class ruleitems which appeared in the data. Here pX = 0.125,
pY = 0.01 and min-support is set to 5 ×10−5. Each plot includes three lines corresponding to
diﬀerent transaction numbers: 25, 000, 50, 000 and 100, 000. Each of such lines also delivers
information regarding the number of possible diﬀerent items that ranges from 60 to 100. One
can see that for a ﬁxed number of transactions, the running time of the algorithms increases as
the number of target-class ruleitems increases, which goes together with increasing number of
items and increasing average transaction length. Figure 5 (c) suggests that the GFP-growth
is faster than the FP-growth, where the improvement in this case ranges from about 10 up
to 80 times faster.

Figures 5 (d), (e) and (f) display a similar scenario, now with pY = 0.1 and min-support
of 5 × 10−4. There is an improvement of GFP-growth but not as substantial as for the case
where pY = 0.01 which resembles very unbalanced data.

In Figures 6 we present results of applying the algorithms to real data. We consider
the ’Census income’ dataset from http://archive.ics.uci.edu/ml/datasets/Adult. We
removed rows with missing information as well as the columns: ’capital.loss’, ’capital.gain’
and ’education.num’. The ’fnlwgt’ column was discretized into a categorical variable with
four categories. The age and hours.per.week columns were discretized into categorical
variables of ﬁve and six categories respectively: age=(’17-25’,’26-35’,’36-45’,’46-65’,’66+’),
hours.per.week=(’1-10’,’11-20’,’21-30’,’31-40’,’41-50’,’51+’). The number of columns in the
database after our manipulations are 12, with each column taking several possible categories,
summing up to 115 possible diﬀerent items. For the target we use the variable ’salary’, which
can be either ≤ 50K or > 50K. The resulting database had approximately 30, 000 rows,
with a distribution of the target class being 75% salary ≤ 50K and 25% salary > 50K.
In order to create an imbalanced problem, we sampled for each test 22, 500 rows with the
number of rows with salary more than 50K set to 22, 500 × pY , and the rest of the rows had
salary less than or equal to 50K. The results presented in Figures 6 summarize the mean
of 20 such test samplings for each scenario. As in the simulation results above, our main
observation is that the target probability has the most substantial eﬀect on the running time
of the GFP-growth algorithm and hence its improvement over the FP-growth which can be
as high as 50 times faster.

Note that the min-support threshold is a tuning parameter of the method and its ’optimal’
choice should be deﬁned according to the question of interest. For instance, for a supervised
learning problem such as classiﬁcation, it makes sense that the min-support threshold will
control the bias-variance trade-oﬀ of a method and as a results will aﬀect its accuracy
(generalization ability). Such an observation was made in [32]. In our case we are concerned
with an exploratory data analysis and are interested in mining all ruleitems so an ’optimal’
choice of min-support is not relevant.

18

(a)

(d)

16

12

8

4

)
c
e
s
(
g
p
f
.
e
m

i
t
n
u
r

0.6

0.4

0.2

)
c
e
s
(
a
r
m
e
m

.

i
t
n
u
r

80

60

40

20

a
r
m
e
m

.

i
t
n
u
r

/
g
p
f
.
e
m

i
t
n
u
r

10000

20000

30000

rule.items

(b)

10000

20000

30000

rule.items

(c)

trans.num

25000

50000

1e+05

items.num

60

70

80

90

100

trans.num

25000

50000

1e+05

items.num

60

70

80

90

100

trans.num

25000

50000

1e+05

items.num

60

70

80

90

100

15

10

5

)
c
e
s
(
g
p
f
.
e
m

i
t
n
u
r

2

1

)
c
e
s
(
a
r
m
e
m

.

i
t
n
u
r

a
r
m
e
m

.

i
t
n
u
r

/
g
p
f
.
e
m

i
t
n
u
r

8

7

6

5

4

3

250000

500000
rule.items

750000

(e)

250000

500000
rule.items

750000

(f )

trans.num

25000

50000

1e+05

items.num

60

70

80

90

100

trans.num

25000

50000

1e+05

items.num

60

70

80

90

100

trans.num

25000

50000

1e+05

items.num

60

70

80

90

100

10000

20000

30000

rule.items

250000

500000
rule.items

750000

Figure 5: Simulation results with pX = 0.125, pY = 0.01 and min-support of 5 × 10−5.
(a): running time of FP-growth as a function of number of target-class ruleitems. (b):
running time of GFP-growth as a function of number of target-class ruleitems. (c): ratio of
running time of FP-growth to GFP-growth as a function of number of target-class ruleitems.
Simulation results with pX = 0.125, pY = 0.1 and min-support of 5 × 10−4. (d): running
time of FP-growth as a function of number of target-class ruleitems. (e): running time of
GFP-growth as a function of number of target-class ruleitems. (f): ratio of running time of
FP-growth to GFP-growth as a function of number of target-class ruleitems

19

 
 
 
 
 
 
 
 
(a)

0e+00

1e+05

2e+05
rule.items

3e+05

4e+05

(b)

)
c
e
s
(
g
p
f
.
e
m

i
t
n
u
r

1.5

1.0

0.5

)
c
e
s
(
a
r
m
e
m

.

i
t
n
u
r

0.4

0.2

0.0

0e+00

1e+05

2e+05
rule.items

3e+05

4e+05

(c)

40

30

20

10

0e+00

1e+05

2e+05
rule.items

3e+05

4e+05

a
r
m
e
m

.

i
t
n
u
r

/
g
p
f
.
e
m

i
t
n
u
r

min.support

pY

5e−05

1e−04

5e−04

0.005

0.01

0.05

0.1

min.support

pY

5e−05

1e−04

5e−04

0.005

0.01

0.05

0.1

min.support

pY

5e−05

1e−04

5e−04

0.005

0.01

0.05

0.1

Figure 6: Real data results. (a): running time of FP-growth as a function of number of
target-class ruleitems. (b): running time of GFP-growth as a function of number of target-
class ruleitems. (c): ratio of running time of FP-growth to GFP-growth as a function of
number of target-class ruleitems

20

 
 
 
 
5 Extensions and future work

In the previous section we demonstrated the application of the GFP-growth algorithm to a
speciﬁc use case: mining ruleitmes from imbalanced data. However, the GFP-growth can be
used for solving a various of mining problems, some examples follow.

5.1 Mining frequent itemsets and optimal classiﬁcation-rules

[5] presents an algorithm which follows the principle of iterative candidate generation process
([21]). The paper uses the itemset tree of [1] in the process of counting the frequency of
the candidate itemsets. In particular, it introduces an enhancement in the context of their
algorithm for frequent-itemset mining, which is to maintain a per candidate list which records
all occurrences of the candidate in the itemset tree, and use the list for mining its direct
children candidates. It requires collecting the data for each and every target-itemset from
many diﬀerent locations in the complete itemset tree.

[6] presents an algorithm which follows the Apriori principle. The paper uses the itemset
tree of [1], and [3] in the process of counting the frequency of the candidate itemsets.
[6]
describes and uses a procedure which uses the itemset tree for counting frequency of the
candidate itemsets which share the leading items and diﬀer only in the last item. The
procedure is called per discovered frequent itemset, and depending on the items comprising
that itemset, each invocation of the procedure potentially traverses a considerable part of
the itemset tree. The diﬀerent invocations may overlap, meaning that the same parts of the
itemset tree are mined a number of times during the diﬀerent invocations. Still the authors
show that in some of the scenarios this procedure performs better than FP-growth.

One way to potentially boost the algorithm of [5] and [6] by eliminating the potential
repetitive mining overlap and fragmented information collection which are described above,
is to replace the per itemset procedure by a per-level single call to the guided FP-growth pro-
cedure as follows. At each level, use the Apriori candidate-generation procedure and create
a tree representing the candidates. Count the frequency of all the candidates by applying a
single invocation of the guided FP-growth procedure with the candidate-representing TIS-
tree as its guide. This procedure provides the advantage that no resources are wasted on
counting the frequency of non-candidate itemsets. Note that in this case the compact rep-
resentation of the dataset is created using an FP-tree instead of an itemset tree as used in
[6]. This adds two advantages, which are the performance and compactness due to building
the tree from the frequent-items only from the start, and optimizing the order in which the
items are used for building the tree. This comes at the expense of an additional pass through
the database and less reusability of the tree for potential other required queries.

Optimal classiﬁcation-rule set were introduced in [26] who showed that it has the same
predictive power of the complete class-association rule set when used for building a classiﬁer.
The optimal rule-set includes only rules such that no rule built of the same consequence and
a subset of the antecedent has an identical or better conﬁdence.
[8] presents a scheme for
mining the optimal classiﬁcation-rule set and then shows how to use this set for creating a
robust classiﬁer. [7] presents a distributed / parallel scheme for optimal-rule discovery, using
a similar concepts.

Both [7] and [8] refer to [1], [6] and [3] as the means for mining the next layer of rules.

21

Therefore, the enhancement suggested above for [6], which involves replacing the repetitive
and overlapping per rule invocation of a mining procedure by a per-layer invocation of the
guided FP-growth procedure, is valid also for [7] and [8], leading to potential improvement
in their performance. Clearly, as demonstrated above, the GFP-growth algorithm will be of
great use when dealing with imbalanced data. Speciﬁcally, we see a potential contribution
by taking advantage of the ideas of [26], [7] and [8] and combine them with the contributions
of the current paper, which may lead to better performance of the mining algorithms.

5.2

Incremental mining of frequent itemsets

Many interesting use-cases for frequent-itemset mining involve datasets which are dynami-
cally updated, with the most important case being addition of new data. Example domains in
which such use-cases exist are e-commerce and data-streaming. Especially in such domains,
fast response times are of importance as the insights need to reﬂect the current situation.

A data-set update may result in addition, deletion, or support-change of existing frequent
itemsets. The straightforward way to get the updated information is to mine the entire
amended dataset from scratch. However, signiﬁcant time saving can be achieved when
taking advantage of the previously gathered information.

Previous works present several diﬀerent incremental algorithms aiming as much as pos-
sible to limit the processing to the newly added data in order to update the already-mined
frequent itemsets. This allows minimization of the resources invested in this eﬀort, such as
time and memory.

A considerable amount of work was dedicated to incremental derivations of FP-growth.
Examples for such incremental FP-growth derivation are [33], [34], [35], [36], [37], [38], [39],
[40], [41], and [42]. The main challenge these papers attempt to address is the fact that an
FP-tree does not contain information about non-frequent items appearing in the original-
database transactions, which means that if an infrequent item becomes frequent due to the
update, the original-database needs to be scanned again.
[41] suggests creating a separate
FP-tree (or a similar structure) for the new incremental dataset, and shows that this tree
can be eﬃciently combined with the one representing the original dataset.

Most of these works assume that the resulting FP-tree needs to be mined again in order
to ﬁnd the new frequent item-sets created due to the update. [36] suggests addressing this
issue by maintaining information about each of the conditional FP-trees created during the
FP-growth procedure in a hyper-tree in order to re-execute only those that are aﬀected by
the update.

We suggest using the guided FP-growth algorithm in order to take advantage of the
frequent-itemset list already mined from the original dataset, and eﬃciently mine the up-
dated frequent itemset list. The main idea is to perform guided mining of the (potentially
huge) original FP-growth tree, focusing only on itemsets which may potentially become
frequent. The itemsets potentially becoming frequent are those that are not frequent in
the original dataset but are frequent on the incremental (new) dataset. This would enable
updating the frequency of the itemsets already appearing in the original frequent-itemset
tree.

22

6 Summary

The main contribution of this work is the development of the GFP-growth (Guided FP-
growth) algorithm, an FP-growth based algorithm for eﬃcient multitude-targeted mining.
The GFP-growth procedure serves for mining the support of multitude pre-specifed itemsets
from an FP-tree and mines only the relevant parts of the FP-tree, in a single and partial
FP-growth process. Our choice to base our algorithm on the original FP-growth was made
due to the popularity, availability, and many actual-use implementations of the FP-growth
algorithm. Indeed, our GFP-growth algorithm can take advantage of the many FP-growth
improvements that have been suggested in the literature. Such improvements will lead to
additional time and memory costs reduction. More so, we have considered our contribution
in the context of both targeted and constraint mining, which gives rise to further potential
advantages. We demonstrated that the GFP-growth procedure is a very fast and generic tool,
which can be applied to many diﬀerent purposes, and provided theoretical results concerning
its correctness.

An additional contribution of this work is the development of the Minority-Report Al-
gorithm that uses the GFP-growth for boosting performance when generating the minority-
In that respect, we studied in detail the problem of
class rules from imbalanced data.
mining minority-class rules from imbalanced data, a scenario that appears in many real-life
domains such as medical applications, failure prediction, network and cyber security, and
maintenance. We proved some theoretical properties of the Minority-Report Algorithm and
demonstrated its performance gain using simulations and real data.

Finally, looking ahead for future research, we discussed how mining of optimal class
association-rules and how incremental itemset mining can potentially beneﬁt from the use
of the GFP-growth algorithm. Additional subjects for future work are exploring whether
an eﬃcient method for mining class association-rules from imbalanced data can be devised
using the Minorty-Report algorithm, and whether the GFP-growth algorithm can be further
optimized.

Acknowledgments This work was supported by the Israeli Science Foundation grant
number 387/15.

References

[1] Kubat M, Hafez A, Raghavan VV, Lekkala JR, Chen WK.

Itemset trees for tar-
geted association querying. IEEE Transactions on Knowledge and Data Engineering.
2003;15(6):1522–1534.

[2] Lavergne J, Benton R, Raghavan VV. Min-Max itemset trees for dense and categor-
ical datasets. In: International Symposium on Methodologies for Intelligent Systems.
Springer; 2012. p. 51–60.

[3] Fournier-Viger P, Mwamikazi E, Gueniche T, Faghihi U. MEIT: Memory Eﬃcient
Itemset Tree for Targeted Association Rule Mining. In: ADMA (2); 2013. p. 95–106.

23

[4] Lewis JB. Enhancements to itemset tree. University of South Alabama; 2016.

[5] Li Y, Kubat M. Searching for high-support itemsets in itemset trees. Intelligent Data

Analysis. 2006;10(2):105–120.

[6] Yakout M, Hafez AM, Aly H. Mining Frequent Itemsets Using Re-Usable Data Struc-

ture. In: DMIN; 2007. p. 148–155.

[7] Ghanem SM, Mohamed MA, Nagi MH. EDP-ORD: eﬃcient distributed / parallel opti-
mal rule discovery. In: Computers and Communications (ISCC), 2011 IEEE Symposium
on. IEEE; 2011. p. 956–963.

[8] Ghanem SM, Mohamed MA, Nagi MH. Towards robust classiﬁers using optimal
International Journal of Data Mining, Modelling and Management.

rule discovery.
2014;6(3):261–284.

[9] Han J, Pei J, Yin Y. Mining frequent patterns without candidate generation. In: ACM

sigmod record. vol. 29. ACM; 2000. p. 1–12.

[10] Han J, Pei J, Yin Y, Mao R. Mining frequent patterns without candidate generation: A
frequent-pattern tree approach. Data mining and knowledge discovery. 2004;8(1):53–87.

[11] Wang K, Tang L, Han J, Liu J. Top down fp-growth for association rule mining.

Advances in Knowledge Discovery and Data Mining. 2002;p. 334–340.

[12] Wei W, Yu S, Guo Q, Ding W, Bian L. An eﬀective algorithm for simultaneously
mining frequent patterns and association rules. In: Service Operations and Logistics,
and Informatics, 2008. IEEE/SOLI 2008. IEEE International Conference on. vol. 1.
IEEE; 2008. p. 190–195.

[13] Aggarwal CC, Han J. Frequent Pattern Mining. 2016;.

[14] Pei J, Han J.

Constrained Frequent Pattern Mining:
Jun;4(1):31–39.
2002

A Pattern-growth
from:

Available

View.
SIGKDD Explor Newsl.
http://doi.acm.org/10.1145/568574.568580.

[15] Pei J, Han J, Lakshmanan LVS. Pushing Convertible Constraints in Frequent Itemset
Mining. Data Mining and Knowledge Discovery. 2004 May;8(3):227–252. Available
from: https://doi.org/10.1023/B:DAMI.0000023674.74932.4c.

[16] Cheung YL, Fu AWC. Mining frequent itemsets without support threshold: with and
without item constraints. IEEE Transactions on Knowledge and Data Engineering. 2004
Sept;16(9):1052–1069.

[17] Lin WY, Huang KW. MCFPTree: A FP-Tree-Based Algorithm for Multi-Constrained
In: 2009 International Conference on Complex, Intelligent and

Patterns Discovery.
Software Intensive Systems; 2009. p. 105–111.

24

[18] Nguyen D, Vo B, Le B.
rules with
association

class
cations
http://www.sciencedirect.com/science/article/pii/S0952197614002127.

of Artiﬁcial

Intelligence.

2015;37:115

constraints.

itemset

124.

–

for mining
Engineering Appli-
from:

Available

CCAR: An

eﬃcient method

[19] Lin WY, Huang KW, Li HY, Jiang CL. Mining Frequent Patterns with Item, Aggrega-
tion, and Cardinality Constraints. In: 2008 3rd International Conference on Innovative
Computing Information and Control; 2008. p. 325–325.

[20] Bonchi F, Goethals B. FP-Bonsai: The Art of Growing and Pruning Small FP-Trees.
In: Dai H, Srikant R, Zhang C, editors. Advances in Knowledge Discovery and Data
Mining. Berlin, Heidelberg: Springer Berlin Heidelberg; 2004. p. 155–160.

[21] Agrawal R, Srikant R, et al. Fast algorithms for mining association rules. In: Proc.

20th int. conf. very large data bases, VLDB. vol. 1215; 1994. p. 487–499.

[22] Ma BLWHY, Liu B. Integrating classiﬁcation and association rule mining. In: Pro-
ceedings of the fourth international conference on knowledge discovery and data mining;
1998. .

[23] Gu L, Li J, He H, Williams G, Hawkins S, Kelman C. Association rule discovery
In: Australasian Joint Conference on Artiﬁcial

with unbalanced class distributions.
Intelligence. Springer; 2003. p. 221–232.

[24] Arunasalam B, Chawla S. CCCS: a top-down associative classiﬁer for imbalanced class
distribution. In: Proceedings of the 12th ACM SIGKDD international conference on
Knowledge discovery and data mining. ACM; 2006. p. 517–522.

[25] Ndour C, Diop A, Dossou-Gb´et´e S. Classiﬁcation approach based on association rules

mining for unbalanced data. arXiv preprint arXiv:12025514. 2012;.

[26] Li J, Shen H, Topor R. Mining the optimal class association rule set. Knowledge-Based

Systems. 2002;15(7):399–405.

[27] Ndour C, Gb´et´e SD, Diop A, Dumont A. Classiﬁcation Approach based on Association
Rules mining for Unbalanced data: Application to In-hospital Maternal Mortality in
Senegal and Mali;.

[28] Nguyen D, Nguyen LTT, Vo B, Hong TP. A novel method for constrained class
Information Sciences. 2015;320:107 – 125. Available from:

association rule mining.
http://www.sciencedirect.com/science/article/pii/S0020025515003643.

[29] Heaton J. Comparing dataset characteristics that favor the Apriori, Eclat or FP-Growth
frequent itemset mining algorithms. In: SoutheastCon, 2016. IEEE; 2016. p. 1–7.

[30] Borgelt C. Frequent item set mining. Wiley Interdisciplinary Reviews: Data Mining

and Knowledge Discovery. 2012;2(6):437–456.

25

[31] Borgelt C. An Implementation of the FP-growth Algorithm. In: Proceedings of the
1st international workshop on open source data mining: frequent pattern mining imple-
mentations. ACM; 2005. p. 1–5.

[32] Coenen F, Leng P. Obtaining best parameter values for accurate classiﬁcation. In: Data

Mining, Fifth IEEE International Conference on. IEEE; 2005. p. 4–pp.

[33] Ezeife C, Su Y. Mining incremental association rules with generalized FP-tree. Advances

in Artiﬁcial Intelligence. 2002;p. 147–160.

[34] Gyorodi C, Gyorodi R, Cofeey T, Holban S. Mining association rules using Dynamic
FP-trees. In: Proceedings of Irish Signals and Systems Conference; 2003. p. 76–81.

[35] Cheung W, Zaiane OR. Incremental mining of frequent patterns without candidate gen-
eration or support constraint. In: Database Engineering and Applications Symposium,
2003. Proceedings. Seventh International. IEEE; 2003. p. 111–116.

[36] Ma XL, Tong YH, Tang SW, Yang DQ. Eﬃcient incremental maintenance of frequent
patterns with FP-tree. Journal of computer Science and Technology. 2004;19(6):876–
884.

[37] Hong TP, Lin JW, Wu YL. A fast updated frequent pattern tree. In: Systems, Man
and Cybernetics, 2006. SMC’06. IEEE International Conference on. vol. 3. IEEE; 2006.
p. 2167–2172.

[38] Lin CW, Hong TP, Lu WH. The Pre-FUFP algorithm for incremental mining. Expert

Systems with Applications. 2009;36(5):9498–9505.

[39] Pradeepini G, Jyothi S. Tree-based incremental association rule mining without can-
didate itemset generation. In: Trendz in Information Sciences & Computing (TISC),
2010. IEEE; 2010. p. 78–81.

[40] Lin CW, Hong TP, Lu WH. Using the structure of prelarge trees to incrementally mine

frequent itemsets. New Generation Computing. 2010;28(1):5–20.

[41] Totad SG, Geeta R, Reddy PP. Batch incremental processing for FP-tree construction
using FP-Growth algorithm. Knowledge and information systems. 2012;33(2):475–490.

[42] Lin CM, Hsieh YL, Yin KC, Hung MC, Yang DL. ADMiner: An Incremental Data

Mining Approach Using a Compressed FP-tree. JSW. 2013;8(8):2095–2103.

26

