1

9
1
0
2

n
u
J

3

]

R
C
.
s
c
[

2
v
6
1
9
0
0
.
3
0
8
1
:
v
i
X
r
a

Deep Learning for Signal Authentication and
Security in Massive Internet of Things Systems
Aidin Ferdowsi∗ and Walid Saad∗
∗ Wireless@VT, Bradley Department of Electrical and Computer Engineering,
Virginia Tech, Blacksburg, VA, USA, Emails: {aidin,walids}@vt.edu.

Abstract—Secure signal authentication is arguably one of the
most challenging problems in the Internet of Things (IoT), due
to the large-scale nature of the system and its susceptibility to
man-in-the-middle and data injection attacks. In this paper, a
novel watermarking algorithm is proposed for dynamic authen-
tication of IoT signals to detect cyber attacks. The proposed
watermarking algorithm, based on a deep learning long short-
term memory (LSTM) structure, enables the IoT devices (IoTDs)
to extract a set of stochastic features from their generated signal
and dynamically watermark these features into the signal. This
method enables the IoT gateway, which collects signals from the
IoTDs, to effectively authenticate the reliability of the signals.
Moreover, in massive IoT scenarios, since the gateway cannot
authenticate all of the IoTDs simultaneously due to computational
limitations, a game-theoretic framework is proposed to improve
the gateway’s decision making process by predicting vulnerable
IoTDs. The mixed-strategy Nash equilibrium (MSNE) for this
game is derived and the uniqueness of the expected utility at the
equilibrium is proven. In the massive IoT system, due to the large
set of available actions for the gateway, the MSNE is shown to be
analytically challenging to derive, and, thus, a learning algorithm
that converges to the MSNE is proposed. Moreover, in order to
handle incomplete information scenarios in which the gateway
cannot access the state of the unauthenticated IoTDs, a deep
reinforcement learning algorithm is proposed to dynamically
predict the state of unauthenticated IoTDs and allow the gateway
to decide on which IoTDs to authenticate. Simulation results
show that, with an attack detection delay of under 1 second, the
messages can be transmitted from IoTDs with an almost 100%
reliability. The results also show that, by optimally predicting
the set of vulnerable IoTDs, the proposed deep reinforcement
learning algorithm reduces the number of compromised IoTDs
by up to 30%, compared to an equal probability baseline.

I. INTRODUCTION
The Internet of Things (IoT) will encompass a massive
number of devices that must reliably transmit a environmental
observations to deliver a plethora of smart city applications
[2]–[6]. However, an effective deployment of IoT services
requires near real-time, secure, and low complexity message
transmission from the IoT devices (IoTDs) [7]. Most IoT
architectures consist of four layers: perceptual, network, sup-
port, and application [8]. The perceptual layer is the most
fundamental
layer which collects all sorts of information
from the physical world using devices such as accelerometers
or radio frequency identiﬁcation (RFID) tags. Due to the
simplicity of the devices and components at the perceptual
layer and their resource-constrained nature, securing the IoT
signals at this layer is notoriously challenging [8].

Recently, a number of security solutions have been pro-
posed for IoT signal authentication [9]–[15]. The work in [9]

This research was supported by the U.S. National Science Foundation under
Grants OAC-1541105, CNS-1446621, and CNS-1524634. A preliminary
version of this work appears in the proceedings of IEEE ICC 2018 [1].

investigated physical layer security techniques for securing IoT
applications. These methods include optimal sensor censoring,
channel-based bit ﬂipping, probabilistic ciphering of quantized
IoT signals, and artiﬁcial noise signal transmission. In [10],
the author suggested bridging the security gap in IoTDs by
applying information theory and cryptography at the physical
layer of the IoT. An authentication protocol for the IoT is
presented in [11], using lightweight encryption method in
order to cope with constrained IoTDs. Moreover, in [12], the
authors developed a learning mechanisms for ﬁngerprinting
and authenticating IoTDs and their environment. Other useful
signal authentication approaches are found in [13]–[15].

To secure IoT-like cyber-physical systems (CPSs), the idea
of watermarking has been studied in [16]–[19]. In [16], a new
method was proposed to watermark a predeﬁned signal unto a
CPS input signal so as to detect replay attacks. A dynamic
watermarking algorithm was proposed in [17] for integrity
attack detection in networked CPSs. In [18],
the authors
introduced a security scheme that ensures detection of data
injection attacks using a non-stationary watermarking tech-
nique. Finally, the authors in [19] analyzed the optimality of
Gaussian watermarked signals in presence of cyber attacks in
linear time-variant IoT-like systems. Moreover, the security of
massive IoT systems has gained attention in recent years [20]–
[23]. In [20], a blockchain-based approach was proposed to
provide a distributed security solution for the IoT. In [21], the
authors demonstrated the feasibility of implementing existing
device management protocols on resource-constrained devices.
A cloud-based algorithm was proposed in [22] to provide
privacy service for resource-constrained IoTDs. Finally, the
work in [23] investigated how cloud computing can be securely
integrated in large-scale IoT systems.

However, the authentication solutions of [9]–[15] remain
highly complex for deployment at the IoT perceptual layer, and
require high computational power. Moreover, these methods do
not take into account dynamic data injection attacks in which
the attacker collects data for a long time duration and uses it
for designing stealthy attacks. Furthermore, the watermarking
algorithms introduced in [16]–[19], can be detrimental to the
performance of a system such as the IoT since an augmented
watermark is applied in parallel to the control signal of the
system. This can, in turn, lead to a suboptimal performance
for the system. In addition, the input signals to IoTDs include
information such as temperature, heart rate, and location,
which are not controllable and require changing the IoTDs’
environment. Moreover, the works in [20]–[23] do not consider
resource constraints at the IoT gateway for authentication. In
a large-scale IoT system, the gateway cannot authenticate all
of the transmitted signals from the IoTDs due to the large

 
 
 
 
 
 
amount of required computational resources and bandwidth.
Therefore, in a practical IoT, the gateway must optimally and
intelligently choose which IoTDs to authenticate.

The main contribution of this paper is a comprehensive
framework that integrates new ideas from deep learning and
game theory to enable computationally-efﬁcient authentication
of IoT signals and devices, in massive IoT systems. The key
contributions include:

• We propose a novel watermarking framework that enables
the IoT’s gateway to authenticate IoTD signals and detect
the existence of a cyber attacker who seeks to degrade
the performance of the IoT by changing the devices’
output signal. The proposed watermarking algorithm
uses deep long short-term memory (LSTM) [24] blocks
to extract stochastic features such as spectral ﬂatness,
skewness, kurtosis, and central moments from IoT signal
and watermarks these features inside the original signal.
• This dynamic feature extraction approach allows the
gateway to detect dynamic data injection attacks in which
the attacker can record and process IoT signals, extract
the watermarking key, and inject faulty data. Moreover,
the proposed LSTM-based watermarking effectively com-
plements other security solutions, such as encryption, by
reducing the complexity and latency of data injection
attack detection.

• To enable the gateway to authenticate IoTDs in a massive
IoT system and under resource constraints, we formulate
a noncooperative game between the gateway and the
attacker to derive the gateway’s optimal action in predict-
ing vulnerable IoTDs while considering its computational
resource constraints. We derive the mixed-strategy Nash
equilibrium of the game and prove the uniqueness of the
gateway’s expected utility at this equilibrium.

• We show that analytically ﬁnding the gateway’s optimal
strategy is computationally expensive in the massive IoT
scenario. Therefore, we propose a learning algorithm
based on ﬁctitious play that converges to the mixed-
strategy Nash equilibrium. Finally, we extend our analysis
to a practical case in which the gateway does not have
complete information about all the IoTDs. To address
this challenge we propose a deep reinforcement learning
approach based on LSTM blocks, to learn the security
state of the IoTDs based on their past states. We show that
the gateway’s expected utility using this proposed deep
reinforcement learning method is higher than baseline
scenarios in which the gateway authenticates all
the
IoTDs with the same probability.

2

Fig. 1: A massive IoT system with heterogeneous IoTDs transmitting
their signals to a gateway. The gateway must solve two inter-related
problems: 1) How to authenticate the IoTDs and 2) Which IoTDs to
authenticate.

signal authentication. Section III analyzes the authentication
scenario in the case of a massive IoT with limited resources
at the gateway. Section IV presents the simulation results and
their analysis while conclusions are drawn in Section V.

II. IOT SIGNAL AUTHENTICATION: SYSTEM MODEL AND
DEEP LEARNING SOLUTION
Consider a massive IoT system having a set N of N IoTDs
communicating with a gateway such as a base station as
shown in Fig. 1 [25]. Any IoTD i in the system generates
a signal yi(t) at time step t with sampling frequency f s
i , and
transmits this signal to the gateway which uses the received
signal for estimation and control of the IoTD operation. In this
system, we consider an adversary that seeks to compromise
the IoTD by collecting the data from the communication link
between the IoTD and the gateway, and, then, manipulates
the transmitted signal. In this case,
the transmitted signal
from each IoTD i will be ¯yi(t) (cid:44) yi(t) which will cause
an estimation error at the gateway. Therefore, the gateway
must implement an attack detection mechanism to differentiate
between honest and false signals received from an IoTD.

First, we analyze the signal authentication process between
then, we propose a
a single IoTD and the gateway and,
dynamic watermarking framework based on deep learning
to authenticate this signal communication with a very small
delay. Subsequently, in Section III, we study the case in which,
due to the massive nature of the system, the gateway is unable
to authenticate all of the IoTDs and must choose an optimal
subset to authenticate.

Simulation results show that, using the proposed watermark-
ing approach and for a latency of under 1 second, the IoT
signals can be reliably transmitted from IoTDs to the gateway.
Moreover, in a massive IoT scenario, the learning algorithms
improves the protection of the system by reducing by about
30% the number of compromised IoTDs.

The rest of the paper is organized as follows. Section
II introduces the system model for IoTD-gateway signal
transmission in large-scale IoT systems and proposes the
deep learning-based dynamic watermarking for IoTD-gateway

A. Spread Spectrum Watermarking

Watermarking uses a hidden, predeﬁned non-perceptual
code (bit stream) inside a multimedia signal to authenticate
the ownership of such signals. One of the the most widely
used watermarking methods is spread spectrum (SS) [26] in
which a key pseudo-noise sequence is added to the original
signal. The watermarked signal from each IoTD i can then be
written as follows:

wi(t) = yi(t) + βi bpi(t)

for t = 1, . . . , ni,

(1)

𝑁IoTDsHowto authenticate?WhichIoTDto authenticate?IoTDsignalRecording by the attackerSignal compromise by the attackerGatewaywhere wi is the IoTD i’s watermarked signal, pi is a pseudo-
noise binary sequence of +1 and −1 for IoTD i, βi is the IoTD
i’s relative power of the pseudo-noise signal to the original
signal, bi is the hidden bit in the signal which can take values
+1 and −1, and ni is the number of samples (frame length) of
IoTD i’s original signal used to hide a single bit. To extract the
watermarked bit, the gateway receives the watermarked signal
from each IoTD i and correlates it with the key pseudo-noise
sequence. The extraction process will be:

=

< yi, pi >ni

< wi, pi >ni
βini

+βi bi < pi, pi >ni
βini

˜bi =

= ˜yi + bi,
(2)
where, for ˜bi > 0, the extracted bit is 1, for ˜bi < 0, the
extracted bit is −1 with < wi, pi >ni being the inner production
of ni samples of wi and pi. pi(t) and yi(t) are independent
stochastic variables at time t. We assume that yi(t) has mean
µi and variance σ2
i . Next, we analyze the bit error rate of the
extracted bit to evaluate the proposed watermarking scheme’s
performance.

Lemma 1. In the proposed SS watermarking scheme, the bit
if ni+ = ni− , where
extraction error for IoTD i is 1
2 erfc
ni+ and ni− are the number of samples in p(t) with values
equal to +1 and −1, respectively.

(cid:16) βi
σi

√
ni
√
2

(cid:17)

Proof. For ˜yi, we can write:

n
(cid:213)

t=1
1
ni+

˜yi = 1
βini

yi(t)pi(t) = 1
βini

=

ni+
βini

(cid:213)

yi(t) −

ni−
βini

t ∈ P+
i
= {t|pi(t) = 1}, P−
i

yi(t) −

(cid:213)

t ∈ P−
i

yi(t)(cid:170)
(cid:174)
(cid:172)

yi(t),

(3)

(cid:213)

(cid:169)
(cid:173)
t ∈ P+
i
(cid:171)
1
(cid:213)
ni−

t ∈ P−
i

where P+
= {t|pi(t) = −1}. Since (3) can
i
be expressed as a sum of i.i.d variables, then, for large values
of ni+ and ni− using the central limit theorem, we can write
(3) as a linear combination of two Gaussian distributions as
˜yi = Yi1 − Yi2, where
(cid:32)

(cid:33)

(cid:32)

(cid:33)

Yi1 ∼ N

ni+ µi
βini

,

ni+
i n2
β2
i

σ2
i

, Yi2 ∼ N

ni− µi
βini

,

ni−
i n2
β2
i

σ2
i

.

(4)

Since ˜y is a linear combination of two independent Gaussian
distributions, we have:

˜yi ∼ N

⇒ ˜yi ∼ N

(cid:32)

(cid:32)

ni+ µi
βini

−

ni− µi
βini

(ni+ − ni−)µi
βini

,

,

ni+
i n2
β2
i
1
β2
i ni

σ2 +

(cid:33)

.

σ2
i

(cid:33)

σ2
i

,

ni−
i n2
β2
i

(5)

(cid:16)
0,

1
β2
i ni

Since ni+ and ni− are design parameters, we choose ni+ = ni−.
(cid:17)
. Now, we can show that ˜b is a
σ2
Thus, we have ˜yi ∼ N
i
Gaussian variable since it is a summation of a constant value
˜bi ∼ N
.
with a Gaussian variable:
Then, to analyze the probability of error we consider bi = 1. In
this case an error occurs when ˜bi < 0, therefore, the probability
of an error is:
Pr (cid:8) ˜bi < 0|bi = 1(cid:9) = 1
2

E( ˜bi) = bi, σ2
˜bi

= σ2
i
β2
i ni

= 1
2

erfc

erfc

(6)

βi

(cid:32)

(cid:32)

(cid:33)

(cid:33)

(cid:17)

(cid:16)

.

√
ni
√
2

E( ˜bi)
√
σ ˜bi
2

σi

3

Fig. 2: Static watermarking for attack detection.

The same error probability can be obtained for bi = −1.

(cid:4)

From (6), we can observe that, for large values of βi and ni,
the bit extraction error goes to zero. However, selecting large
values for βi and ni will incur latency and computational costs
for IoTDs and gateway, as discussed next.

B. Static Watermarking for IoTD Attack Detection

Now, using the SS method, we present a technique for
authenticating the signals transmitted from an IoTD to the
gateway. We ﬁrst generate a random pseudo-noise binary
sequence with ni samples. Also, for every IoTD i, we deﬁne
a bit stream si with nsi samples. Then, using (1), we embed
every bit of si in ni samples of yi. Therefore, for any bit stream
si, we use ninsi samples of yi, and this embedding procedure
will repeat every ninsi samples of yi. At the gateway, using
(2), we extract the bit stream. In case of a cyber attack, the
received signal in the gateway will be ¯yi(t) rather than wi(t),
and, hence, the extracted bit stream will differ from si. Thus,
the gateway will trigger an alarm for declaring the existence
of a cyber attack. Fig. 2 shows the block diagram of static
watermarking for attack detection at the level of an IoTD.

In our proposed watermarking scheme, βi, ni, and nsi play
crucial roles in the security of a given IoTD. The value of βi
must be much smaller than the value of σi. Indeed, for com-
parable values of βi, an attacker can extract the key pi and bit
stream si, since wi(t) (cid:39) βi bi pi(t) if | βi bi p(t)| = βi >> |yi(t)|.
Therefore, we must choose small values for βi. However, from
Lemma 1, we know that a small βi will yields a higher bit
error rate. To overcome this issue, we have to increase the
pseudo-noise key length, ni. Although increasing the value of
ni will reduce the bit error rate, for large values of ni, the bit
extraction procedure in (2) will result in higher computation
load and will also cause higher latency since the gateway must
wait for ninsi samples from the IoTD to detect the attack.
Moreover, large values of nsi will also cause larger delay at
the gateway. Therefore, next, we propose a method to choose
suitable values for these three parameters.

Theorem 1. To reduce the attacker’s ability to extract the
hidden bit stream as well as minimize the attack detection
delay of the watermarking scheme βi, ni, and nsi must be
selected to satisfy the following conditions:

(1 + µ1i
i n2
β2
i
(cid:113)
2(σ2
1i

√

ni

)β2

i ni

+ 2σ2
i )

(cid:170)
(cid:174)
(cid:174)
(cid:172)

1
2

erfc (cid:169)
(cid:173)
(cid:173)
(cid:171)

≥ 1 − P,

(7)

IoTDKey (𝑝)Bit Stream (s)Extracted Bit Stream=?TrueFalseAttackNo Attack𝑦𝑤AttackGateway1
2

erfc

(cid:32)

βi

√
ni
√

2

σi

(cid:33)

≤ ¯P,

nsi ≤

d f s
i
ni

,

(8)

(9)

where d is the acceptable delay (in seconds) for attack
detection, µ1i and σ2
are the mean and variance of the
1i
multiplication of random variables y1i (t) and y2i (t) with the
same distribution as yi(t), P is our desired probability of
unsuccessful attack, and ¯P is our desired bit extraction error
probability.

Proof. See Appendix A.

(cid:4)

= 0, δ1i

Using (7), (8), and (9), we can ﬁnd the values for the
three parameters which satisfy our performance and delay
constraints. For example, in Fig. 3, we consider a scenario
= 0.5, δi = 0.5, P = 0.05, and
in which µ1i
¯P = 0.01. We can see from Fig. 3 that, βi = 0.5 and ni = 10
can satisfy conditions (7) and (8). Now, if we consider that
= 1000, from condition (9), to be able to have a delay at
f s
i
most d = 0.1 seconds, we must have nsi
= 10. The proposed
SS watermarking method can detect a cyber attack which can
only change the transmitted data from an IoTD to the gate-
way. By choosing optimal values for the three watermarking
parameters, the gateway can authenticate the transmitted data.
Consider a case in which an attacker can also collect data
from the IoTDs. Here, the attacker can launch a more complex
dynamic data injection attack by recording the transmitted data
from the IoTD and, then, summing the recorded data for a
long period of time. Such an attack can potentially reveal the
key p. For example, if the attacker collects the data for m
windows of size nns and adds this data together, it obtains:
¯wmi (t) = (cid:205)m
i (t) + mβi bi pi(t), where y j
is the signal
received in window j from an IoTD, and ¯wmi is the summation
of collected data. If we consider σ2
mi as the variance of the sum
i (t), . . . , ym
of m random variable y1
i (t), then, there will exist a
value for m where m2 β2
i >> σ2
mi . Hence, the attacker can use
¯wmi (cid:39) mβi bi pi as the key for watermarked signal. This attack
is successful because the embedded stream s is static, at all
times. However, if the bit stream si changes dynamically in
each window of ninsi samples then, the system can deter such
a dynamic data injection attack. Next, we propose a dynamic
bit stream generation using deep learning.

i=1 y j

i

C. Deep Learning for Dynamic IoT Signal Watermarking

To improve our authentication scheme, we propose a novel
deep learning watermarking method for dynamically generat-
ing the bit stream si which can thwart dynamic data injection
attacks. In the proposed dynamic watermarking scheme, we
use the ﬁngerprints of the signal yi generated by an IoTD
to dynamically update the bit stream, si. Signal ﬁngerprints
are unique identiﬁers of a signal that can be mapped to a
bit stream. Signal stochastic characteristics such as spectral
ﬂatness, central moments, skewness, and kurtosis can be used
for extraction of ﬁngerprints from signals [27]–[30]. Due to
time
time dependence of the IoTD signal stream on past
steps, we use the powerful deep LSTM framework, one of the

4

most effective deep learning methods for sequence analysis,
to extract the IoTD signal ﬁngerprints [24], [31], and [32].

1) Introduction to LSTM Cells: Recurrent neural networks
(RNNs) are a special type of artiﬁcial neural networks (ANNs)
which are useful for time series analysis [24]. ANNs are
function approximators which map an input vector to a target
vector. They are made of layers of artiﬁcial neurons which take
a vector as an input, aggregate such input vector, and pass the
aggregation through an activation function. The output of the
last layer’s activation function can be considered as the target
vector. While such ANNs map an input vector to an output
vector, RNNs also feedback the output to their input which
makes them suitable to analyze a time dependence in the input.
Fig. 4 shows a normal neuron and a recurrent neuron which
are used in different ANN architectures. Each of these neurons
will have a number of hyperparameters called bias and weights
in the aggregation and activation steps. Thus, the aim of using
this RNN is to derive those hyperparameters such that one can
ﬁnd an approximation of mapping from input to output. One
of the widely used methods to train the RNN and derive the
hyperparamters is the gradient descent algorithm [24], which
uses the chain rule and gradient of the RNN’s layers to ﬁnd
the optimal hyperparamters which minimize the difference
between the RNN’s output and the target vector. However,
RNNs have a vanishing gradient problem [32] during training
phase which means that the gradient of layers close to the
input does not change much compared to layers close to the
output which makes the convergence of the gradient descent
algorithm challenging. Moreover, conventional RNNs such as
the ones shown in Fig. 4 tend to forget the information about
past samples and emphasize on learning from recent samples.
To overcome these challenges, we use LSTM blocks [32]
which have three main components as shown in Fig. 5: 1) A
forget gate which receives an extra input called the cell state
input and learns how much it should memorize or forget from
the past, 2) An input gate which aggregates the output of past
steps and the current input and passes it through an activation
function as done in a conventional RNN, and 3) An output
gate which combines the current cell state and the output of
input gate and generates the LSTM output. Next, we explain
how we use the LSTMs for IoTD watermarking.

2) LSTM for Dynamic Signal Watermarking at the IoTDS:
To dynamically extract ﬁngerprints from IoTD signals, we use
an LSTM algorithm that allows an IoTD to update the bit
stream based on the sequence of generated data. An LSTM
algorithm processes an input (cid:0)yi(1), . . . , yi(ninsi )(cid:1) by adding
new information into a memory, and using gates which control
the extent to which new information should be memorized,
old information should be forgotten, and current information
should be used. The output of an LSTM algorithm will be
impacted by the network activation at previous time steps and,
hence, LSTMs are suitable for our IoT application in which we
want to extract ﬁngerprints from signals which are dependent
on previous time steps.

During the training phase, the parameters of the LSTM
algorithm are learned from a given training dataset of different
IoTDs such as accelerometer, gyroscope and positioning de-
vices. As done in [27]–[30], we choose spectral ﬂatness, mean,

5

Fig. 3: A visualization for Theorem 1 conditions.

IoTD and the DW-LSTM block of Fig. 6b at the gateway, we
propose a dynamic LSTM watermarking scheme to implement
an attack detector at the gateway.

In this method, a predeﬁned bit stream is not used since a bit
stream is dynamically generated inside the LSTM blocks at the
IoTD and the gateway. This dynamic bit stream generation at
the hidden layers of LSTMs solves the dynamic data injection
attack problem, since recording and summing the IoTD signals
will not increase the power ratio of the key sequence to the
signal and the attacker will not be able to extract the key and
bit stream. Using this method, the IoTD inserts the generated
signal and key in its LSTM block in each window of ninsi
samples and produces a watermarked signal with different
bit stream si in each window. At the gateway, the received
watermarked signal and key are passed from the LSTM. Then,
the two outputs (the extracted bits, and extracted features) are
compared. In case of dissimilarity between two sequences, an
attack alarm is triggered. Fig. 7 shows the block diagram if the
proposed dynamic LSTM watermarking for attack detection.
In addition, note that the computationally expensive phase in
this algorithm is actually the training phase where several
iterations are done during gradient descent algorithm to ﬁnd
the optimal weights for the neural network [24]. However, the
testing phase is actually a series of summations, multiplica-
tions, and activation functions which are not computationally
expensive and can be run on any device [24]. The training
phase of our proposed deep learning dynamic watermarking
can be done ofﬂine (e.g. on high performance computers), as
already adopted in the literature [24]. Hence, for every IoTD,
we train an LSTM network ofﬂine and then implement at the
corresponding IoTD. After implementation, the IoTDs will not
need to train their associated LSTM network online and they
will operate in the testing phase.1 Also, the proposed algorithm
enables the gateway to authenticate any IoTD signal with a
delay of d. To analyze the required computational resource at
the gateway, next, we derive the computational complexity of
the proposed watermarking algorithm.

1The training phase can be done online as well by using some recent

advances in LSTM architectures.

Fig. 4: A block diagram of artiﬁcial neurons used in ANNs.

Fig. 5: A generic LSTM block architecture.

variance, skewness, and kurtosis as features that are extracted
from a signal of length ninsi and then map these values to a
bit stream with length ni. Next, we watermark this extracted
bit stream into the original signal using a key. To train the
LSTM, we use the original signal yi and a pseudo noise key
pi as input stream and the watermarked signal wi as output
stream. Fig. 6a shows the training phase. Next, we illustrate
how we use the trained LSTM to dynamically watermark an
IoT signal.

3) LSTM for Dynamic Signal Authentication at the gate-
way: At the gateway, we use a dynamic watermarking LSTM
(DW-LSTM) for bit extraction. To train this DW-LSTM, we
use the watermarked signal wi and key pi as inputs to the
neural network and the features of the original signal and
extracted bit stream as outputs. The block diagram model
of the training phase at the gateway for our DW-LSTM is
shown in Fig. 6b. Using the DW-LSTM block of Fig. 6a at the

00.1600.20.3Probability of succesful attack0.40.5402201.510.50000.1600.20.3Probability of bit extraction error0.40.5402021.510.500InputOutput𝜮Activation FunctionAggregation of InputsInputOutput𝜮A recurrent artificial neuron:A normal artificial neuron:=Input at 𝑡+1Output at 𝑡−1𝜮𝜮𝜮Input at 𝑡Input at 𝑡−1Output at 𝑡Output at 𝑡+1TimeσσXX+Xσtanhtanh𝒘(𝒕−𝟏)𝒘(𝒕)𝒚(𝒕)Recurrent inputCell state inputOutputCell state outputInput gateOutput gateInputSigmoid𝒄(𝒕−𝟏)𝒄(𝒕)6

(a) Training phase of an LSTM in an IoTD.

(b) Training phase of an LSTM at the gateway.

Fig. 6: Training phase of the proposed deep learning methods.

Fig. 7: Dynamic watermarking for attack detection.

Proposition 1. The complexity of the proposed signal authen-
tication method at the gateway is bounded by O(d f s
i ).

Proof. From (2), we know that, in order to extract each bit
in stream s, we need n multiplications and n − 1 summations.
Therefore, the complexity of extracting one bit is O(ni) and
extracting all of the bits in s will have a complexity of
O(ninsi ). Moreover, from Theorem 1, we know that ni
is
chosen based on the watermarking performance criteria, while
d f s
nsi is bounded by
. Thus, the complexity of signal authenti-
i
ni
(cid:1). (cid:4)
cation at the gateway is bounded by O

(cid:17) = O (cid:0)d f s

(cid:16) d f s
i
ni

ni

i

Proposition 1 shows that the sampling rate of an IoTD’s
signal directly affects the complexity of the authentication
process. However, as previously mentioned, an IoTD with
higher sampling and packet transmission rates to the gate-
way will be more valuable for the IoT system [33]. Thus,
under limited computational resources, the gateway can only
authenticate a limited number of IoTD signals using our
proposed method and, thus, it has to choose which subset of
N it can authenticate. This computational limitation provides
an opportunity for the attacker to choose the IoTDs with
unauthenticated signals to attack and stay undetected. We
assume that the amount of computations that can be done at
the gateway is bounded by O(C) which means that the total
authentication complexity of all the received signals cannot
exceed O(C):

(cid:32)

O

d

(cid:33)

f s
i

(cid:213)

i ∈S

≤ O(C),

(10)

where S ⊆ N is the set of IoTDs whose signals will be
authenticated by the gateway and f s
is the sampling rate of
i
IoTD i. Since the arguments on both sides of (10) are linear,
we have:

Since the sampling rate fs of each IoTD corresponds to its
value for the gateway, vi, by considering a value proportional2
to each IoTD’s sampling frequency, vi =
, we can
rewrite (11) as:

f s
i
(cid:205)N
i=1 f s
i

(cid:213)

i ∈S

vi ≤

C
d

N
(cid:213)

i=1

f s
i

(cid:44) R,

(12)

Thus, the gateway must choose a set S ⊆ N that satisﬁes
(12). In addition, the attacker has a limitation on the number
of IoTDs that it can attack simultaneously due to its limited
available resources. We capture this resource limitation by
assuming that the attacker has only K devices that it can
use to dynamically inject data to IoTD signals. Thus, the
attacker must choose K target IoTDs, that are not S, while
the gateway must predict the IoTDs that the attacker will
target and, then, it will authenticate them. Since the attacker’s
and the gateway’s actions are interdependent, the outcome
of their decisions requires analyzing their interaction. In the
following, we address this interaction between the gateway
and the attacker in the large-scale IoT system using a game-
theoretic approach [34].

III. GAME THEORY FOR AUTHENTICATION UNDER
COMPUTATIONAL CONSTRAINTS
In the considered massive IoT system, we assume that
IoTDs that have more data to send will be more valuable for
the system since more important applications require more
frequent monitoring and control [33]. However, IoTDs with
more valuable data are also more likely to be selected as an
attack target by the adversary. As discussed in Section II, IoTD
signal authentication using our proposed technique requires
computational resources at the gateway to process the received
data from all IoTDs. Therefore, the gateway must optimally
predict the vulnerable IoTDs while the attacker must predict
which unauthenticated IoTDs to target so as to maximize the
disruption in the IoT system. We analyze this problem using
game theory.

A. Game Formulation

To model the interdependent decision making processes of
the attacker and the gateway, we introduce a noncooperative

(cid:213)

i ∈S

f s
i ≤

C
d

.

(11)

2Without loss of generality, our approach can accommodate any other

relationship between the IoTD’s value and sampling frequency.

Feature extractionLSTMWatermarkingKeyIoTsignalInputsOutputFingerprintKeyDW-LSTMBit extractionInputsOutputsIoTDKey (𝑝)TrueFalseAttackNo Attack𝑦𝑤AttackLSTMDW-LSTM=?Extracted bitsExtracted featuresGatewaygame (cid:8)P, Q j, u j, K, C(cid:9) deﬁned by ﬁve components: a) the
players which are the attacker a and the gateway g in the
set P (cid:44) {a, g}, b) the strategy spaces Q j for each player
j ∈ P, c) a utility function, u j
for each player, d) the
number of attacker’s devices, K, which can record IoT signals
and e) the available computational resources for the gateway,
C. Note that the gateway can get the information about K
using the typical attackers’ capabilities, past attacks, or known
data on similar attacks. Moreover, the attacker can extract
information about the computational capability of gateways
from data sheets and documentations, particularly for standard
IoT systems that typically deploy known types of hardware
the set of pure strategies
and software. For the gateway,
Qg corresponds to different feasible IoTD subsets whose
signals can be authenticated without exceeding the available
computational resources:
(cid:40)

(cid:41)

Qg =

S ⊂ N

vi ≤ R

.

(13)

(cid:12)
(cid:12)
(cid:12)

(cid:213)

i ∈S

On the other hand, for the attacker the set of pure strategies
Q a is a set of K IoTDs that will be targeted by an attack:
Q a = (cid:110)
. Moreover, the utility function3 of
|K | ≤ K
each player can be written as follows:

K ⊂ N

(cid:12)
(cid:12)
(cid:12)

(cid:111)

ug (S, K) =

N
(cid:213)

vi −

(cid:213)

vi = 1 −

i=1

ua (K, S) = (cid:213)
i ∈K,i(cid:60)S

i ∈K,i(cid:60)S

vi,

(cid:213)

vi,

i ∈K,i(cid:60)S

(14)

where vi is IoTD i’s value. These utility functions essentially
capture the fraction of secured IoTD signals for the defender,
and the fraction of IoTDs that the attacker can compromise
while remaining undetected. Therefore,
the attacker seeks
to maximize the fraction of compromised IoTDs while the
defender seeks to minimize it. This coupling in the players
strategies and utilities naturally leads to a game-theoretic
situation [35]. One of the most important solution concepts
for noncooperative games is that of a Nash equilibrium (NE).
The NE characterizes a state at which no player j can improve
its utility by changing its own strategy, given the strategy of
the other player is ﬁxed. For a noncooperative game, the NE
in pure (deterministic) strategies can be deﬁned as follows:

Deﬁnition 1. A pure-strategy Nash equilibrium of a noncoop-
, Xa∗ (cid:3) ∈ Qg × Q a
erative game is a vector of strategies (cid:2)Xg∗
such that ∀ j ∈ P, the following holds true: u j (cid:16)
≥
u j (cid:16)
opponent.

, ∀X j ∈ Q j, where − j is the identiﬁer for j’s

X j, X−j∗ (cid:17)

, X−j∗ (cid:17)

X j∗

The NE characterizes a stable game state at which the
gateway cannot improve the protection of IoTD signals by
unilaterally changing its action S given that the action of the
attacker is ﬁxed. Moreover, at the NE, the attacker cannot
manipulate more IoTD signals by changing its action K while

3Here, we use vi =

and the constraint in (12) between R and

vi . The following game model and calculations hold true for any other
relationship between R and IoTD values, vi .

f s
i

(cid:205) N

i=1

f s
i

7

the gateway keeps its action S ﬁxed. Before analyzing the NE
of our game, we introduce the useful concept of a dominated
strategy that we will use in our further analysis.

Deﬁnition 2. Player j’s strategy X j is weakly dominated if
there exists another strategy ˜X j ⊂ Q j such that: u j(X j, X−j) ≤
u j( ˜X j, X−j), ∀ X− ∈ Q−j, with the strict inequality for at least
one X−j. In case the above inequality holds strictly for all
X−j ∈ Q−j, X j is said to be strictly dominated (by ˜X j).

Essentially, a strategy is dominated if choosing it always
yields a smaller utility compared to any other strategy, given
all possible strategies for other players. Using this deﬁnition,
prior to ﬁnding the NE, we next derive the dominated strategies
of the gateway and the attacker.

Proposition 2. The gateway must choose as many IoTDs as
possible to authenticate and, thus, any strategy S ∈ Qg is
weakly dominated by ˜S ∈ Qg if S ⊆ ˜S.

Proof. From set theory we have:

S ⊆ ˜S, ⇒ K ∩ S ⊆ K ∩ ˜S, ⇒ K −
(cid:12)
(cid:12)i ∈ K, i (cid:60) ˜S
(cid:12)

(cid:110)
i

⇒

⊆

(cid:110)

(cid:111)

i

(cid:12)
(cid:12)i ∈ K, i (cid:60) S
(cid:12)

(cid:16)

(cid:17)

K ∩ ˜S
(cid:111)

⊆ K − (K ∩ S) ,

.

(15)

Therefore, we have:

(cid:213)

vi ≤

(cid:213)

vi,

ug (S, K) = 1 −

i ∈K,i(cid:60) ˜S
(cid:213)

i ∈K,i(cid:60)S

i ∈K,i(cid:60)S

vi ≤ 1 −

(cid:213)

vi = ug (cid:16) ˜S, K

(cid:17)

, (16)

i ∈K,i(cid:60) ˜S

which proves that S is weakly dominated by ˜S.

(cid:4)

Proposition 2 shows that the gateway must use all of its
available computational resource to authenticate the IoTD
signals since any strategy that is a subset of another strategy
uses less computational resources.

(cid:12) ˜K(cid:12)

Proposition 3. The attacker must use all of its K recording
devices, i.e., any strategy K ∈ Q a is weakly dominated by
˜K ∈ Q a if K ⊆ ˜K and (cid:12)
(cid:12) = K.
Proof. We know that K ⊆ ˜K, and, thus, the number of IoTDs
that are attacked by the adversary when choosing strategy ˜K
is higher than the number of attacked IoTDs when choosing
strategy K. Therefore, if the gateway chooses any strategy S,
then the number of unauthenticated IoTD devices for the ﬁrst
case will be greater than or equal to the latter case or:
(cid:111)

(cid:110)

(cid:111)

(cid:110)
i

(cid:12)
(cid:12)i ∈ K, i (cid:60) S
(cid:12)

⊆

(cid:12)
(cid:12)i ∈ ˜K, i (cid:60) S
(cid:12)

i

,

(17)

and, thus, we have:

ua (K, S) = (cid:213)
i ∈K,i(cid:60)S

vi ≤

(cid:213)

i ∈ ˜K,i(cid:60)S

vi = ua (cid:0) ˜K, S(cid:1) .

(18)

Since the attacker cannot choose more than K IoTDs to attack,
thus any strategy ˜K with K members, (cid:12)
(cid:12) = K, dominates all
the strategies that are K ⊆ ˜K.
(cid:4)

(cid:12) ˜K(cid:12)

Proposition 3 shows that non-dominated strategies for the
attacker are those that include K IoTDs to attack. Here, we
j’s non-dominated
deﬁne

˜Q j ⊆ Q j as the set of player

Algorithm 1 Dynamic Programming for ﬁnding the gateway’s
Non-dominated Strategies

1: Input F (cid:44) (cid:8) f s
2: Initialize M N +1×C/d− f s
1

1 , . . . , f s
N

(cid:9), C/d,

True,

+1 everywhere False apart from M[0, 0] =

3: Start ﬁlling all the entities of matrix M:
4: for i ← 1 to N do
for j ← f s
5:
1
6:

M[i, j] = M[i − 1, j] (cid:212) M[i − 1, j − f s

to C/d do

with the values less than f s
i

7: for k ← C/d to f s
8:

1 do
if maxm M[m, k − f s

i ], (True, if there is a subset

that sum up to j.)

i ] do (Checks the IoTD with highest f s such

that the IoTDs with less f s can sum up to k.)

9:
10:

Initialize R = { } ,
S ← RecPath(m, k, F, M, R): (This function follows the path in

M until reaching to the ﬁrst column.)
if M[m, k] do
B ← R,
RecPath(m − 1, k, F, M, B)

(cid:211) M[m, k − f s

if k ≥ f s
m
R ← f s
i ,
RecPath(m − 1, k, F, M, R)

m] do

Output R

11:
12:
13:
14:
15:
16:
17:
18: Output S

Fig. 8: Number of the gateway’s and the attacker’s strategies for
1000 IoTDs (logarithmic scale).

strategies. The attacker’s non-dominated strategies can be
interpreted as combination of K IoTDs from all N IoTDs.
Therefore, the number attacker’s strategies is (cid:0)N
(cid:1). Since the
K
number of attacker’s recording devices, K, is comparably less
than the number of IoTDs N, we can easily see that the
complexity of ﬁnding the attacker’s non-dominated strategy
set is O (cid:0)N K (cid:1) which is comparably smaller than considering
all the subsets of N , that results in a complexity of O(2N ).
Thus, Proposition 3 reduces the complexity of the attacker’s
game signiﬁcantly.

For the gateway, ﬁnding all the strategies that satisfy the
condition in Proposition 2 is an NP-hard problem [36]. Thus,
in Algorithm 1 we propose a novel dynamic programing ap-
proach to reduce the complexity of ﬁnding the non-dominated
strategies of the gateway. The algorithm takes the set of
all IoTD sampling frequencies and C/d as input. In this
algorithm, we ﬁrst deﬁne a (N + 1) × (C/d − f s
+ 1), matrix
1
M whose element M[i, j] is set to a “True” value if there is a
subset of IoTDs with a sampling frequency less than f s
i such
that the summation of all IoTD sampling frequencies in this
subset equals j.

Corollary 1. At each stage of computation, the Algorithm
1 uses the solutions of previous subproblems and since the
operations used to ﬁll each entity of M are similar,
the
complexity of ﬁnding the defender’s non-dominated strategies

8

gateway

Attacker

{1000}
{2000}
{3000}

{1000, 2000}

{1000, 3000}

{2000, 3000}

(0, 1)
(0, 1)
(3/6, 3/6)

(0, 1)
(2/6, 4/6)
(0, 1)

(1/6, 5/6)
(0, 1)
(0, 1)

Table I: An example of strategies and utilities for the game
between the gateway and the attacker.

reduces from O(2N ) to O(NC/d).

Even though Algorithm 1 reduces the complexity of ﬁnding
the gateway’s non-dominated strategies to a linear time, the
number of these non-dominated strategies is dependent on
the gateway’s available resources and the distribution of sam-
pling frequencies. Fig. 8 shows the number of non-dominated
strategies for the gateway and the attacker, when N = 1000
IoTDs, R ∈ (0, 1], and K ∈ [0.01N, 0.1N]. In this massive IoT
scenario, from Fig. 8, we can see that, the number of strategies
for both players is very large which consequently requires a
complex process to ﬁnd the pure-strategy NE. Moreover, even
though we derived the non-dominated strategies for both play-
ers, the NE is not guaranteed to exist for our game [34]. For
example, consider only three IoTDs with {1000, 2000, 3000}
as their sampling frequency, assume that C/d = 5000, and
an attacker having 1 recording device. This example game,
along with the non-dominated strategies of both players, is
summarized in Table I. Any element (i, j) in Table I is the
outcome of playing the gateway’s i-th and the attacker’s j-th
strategy. From Table I, we observe that, for any outcome of
the game, at least one of the players can change its strategy
to gain a better payoff. Therefore, this game cannot have a
pure-strategy NE for a general case. Thus, we investigate the
NE in mixed strategies which is guaranteed to exist for ﬁnite
noncooperative games [34]. When using mixed strategies, each
player will assign a probability for playing each one of its pure
strategies. For a massive IoT, the use of mixed strategies is
motivated by two facts: a) the gateway and the attacker must
randomize over their strategies in order to make it nontrivial
for the opponent to guess their potential action, and b) the
procedure of choosing IoTDs can be repeated over an inﬁnite
time duration and mixed strategies can capture the frequency
of choosing certain strategies for both players. Thus, next, we
analyze our game’s mixed-strategy NE.

B. Mixed-Strategy Nash Equilibrium

In our game, by using mixed strategies, the attacker and
defender will assign probabilities for playing each one of their
non-dominated strategies [34]. Let pa be the vector of mixed
strategies for the attacker where each element in pa is the
probability of choosing a set of IoTDs, i.e., selecting one
strategy from the attacker’s strategy set K. Moreover, pg is
the vector of mixed strategies for the gateway whose elements
represent the probability of choosing a certain strategy from
the gateway’s strategy set, S. Consequently, each player must
choose its own mixed-strategy to maximize its expected utility
which is deﬁned by:
U j( p j, p−j) = (cid:213)

pg(S)pa(K)u j(S, K),

for ∀ j ∈ P.

(cid:213)

S ∈Q g

K ∈ Q a

(19)

00.20.40.60.8101234567800.020.040.060.080.1020406080100120140To solve this problem, we seek to ﬁnd the mixed-strategy Nash
equilibrium, deﬁned as follows:

Deﬁnition 3. A mixed strategy proﬁle p∗ constitutes a mixed-
strategy Nash equilibrium (MSNE) if, for each player, j, we
have: U j( p j∗
, p−j∗) ≥ U j(p j, p−j∗), ∀ p j ∈ P j, where P j is
the set of all probability distributions for player j over its
action space Q j.

The MSNE for our game implies a state at which the gate-
way has chosen its optimal randomization over authenticating
the signals of its IoTDs and, therefore, cannot further improve
the system security by changing this randomization. Similarly,
for the attacker, an MSNE is a state at which the attacker has
chosen its probability distribution over the selection of IoTDs
that it will attack and, thus, cannot improve its expected utility
by changing its choice. Since our game is a constant-sum
two-player game, the von Neuman indifference principle can
be used to ﬁnd a closed-form solution for the MSNE [34].
Under this principle, at the MSNE, the expected utilities of
the players with respect to the mixed strategies played by the
opponent must be equal, for every pure strategy choice. To
derive the MSNE for our game, we ﬁrst deﬁne an allocation
vector ˆp j
N ×1 for each player j such that each element i in this
vector is the probability of choosing IoTD i. The relationship
between the allocation vector and the mixed-strategy of our
game can be written as follows:

ˆpg
i

= (cid:213)
S ∈Si

pg(S),

ˆpa
i

= (cid:213)
K ∈Ki

pa(K),

(20)

is element

where ˆpj
ˆp j. We deﬁne Ki =
i of vector
i
(cid:8)K ∈ ˜Q a |i ∈ K(cid:9) as the set of all attacker strategies that have
IoTD i, and Si = (cid:8)S ∈ ˜Qg |i ∈ S(cid:9) as the set of all gateway
strategies that have IoTD i. We next derive the mapping
between the expected utility of each player by playing mixed-
strategy vector p j and the allocation vector ˆp j, then we prove
that our game has inﬁnitely many, MSNEs all of which achieve
a unique expected value for both attacker and defender.

Proposition 4. To map the mixed strategy vectors to allocation
vectors the following conditions must hold true:

N
(cid:213)

i=1

ˆpa
i

= K,

N
(cid:213)

i=1

αi ˆpg
i

= D,

(21)

where D is the maximum number of IoTDs in a strategy S ∈
˜Qg and, ∀i ∈ N , αi is an integer.

Proof. First, we analyze the mapping between attacker’s al-
ˆpi. From the deﬁnition
location vector and mixed-strategy,
of Ki, we have (cid:205)
K ∈Ki pa(K) = ˆpa
i . Moreover, we know
that the summation of all the attacker’s non-dominated mixed
strategies equals to 1, i.e., (cid:205)
K ∈ ˜Q a pa(K) = 1. In addition,
since every strategy K ∈ ˆQ a has K IoTDs, then, if we make
˜Q a, we can build each Ki
a set by K times repeating the set
from this set to obtain:

N
(cid:213)

i=1

ˆpa
i

= K

(cid:213)

K ∈ ˜Q a

pa(K) = K.

(22)

9

i and (cid:205)

S ∈Si pg(S) = ˆpg

For the gateway, the procedure is similar. From the deﬁnition
of Si, we have (cid:205)
S ∈ ˜Q g pg(S) = 1.
Here, the number of IoTDs in each S ∈ ˜Qg is not equal,
however, to build Si, ∀i ∈ N , we must deﬁne a set with D
repetitions of ˜Qg where D is the maximum number of IoTDs
in a strategy S ∈ ˜Qg, i.e., D (cid:44) maxS ∈ ˜Q g |S|. Since some
of the IoTDs might not be included in the strategies which
consist of D IoTDs, the set Si can repeat more than once
for these IoTDs, and, therefore, we will have: (cid:205)N
=
D (cid:205)
S ∈ ˜Q g pg(S) = D, where αi is the number of times Si
shows up in D repetitions of set ˜Qg.
(cid:4)

i=1 αi ˆpg

i

Proposition 4 uncovers a linear relationship between the
allocation probabilities. Using this relationship, and given that
the attacker can have a successful attack on IoTD i if the
defender does not authenticate IoTD i, we can deﬁne the
expected utility of the players as follows:

U a( ˆpa, ˆpg) =

N
(cid:213)

i=1

i (1 − ˆpg
ˆpa

i )vi, Ug( ˆpg, ˆpa) = 1 − Ug( ˆpa, ˆpg),

(23)

with the condition in (21). Next, we derive the MSNE using
(21) and (23).

Theorem 2. The deﬁned game between the attacker and the
gateway has inﬁnitely many MSNEs that achieve a unique
expected utility, V j∗
, for each player j. These MSNEs can be
derived by solving the following minimax problem:

V j∗ (cid:44) 1 − V −j∗ = min
ˆp− j
N
(cid:213)

N
(cid:213)

ˆpa
i

= K,

s.t.

i=1

i=1

U j( ˆp j, ˆp−j),

max
ˆp j

αi ˆpg
i

= D.

(24)

Proof. Since the game between the players is constant-sum,
then the expected utility of the game at MSNE is the solution
the deﬁned
of minimax problem in (24) [34]. Moreover,
expected utilities and the constraints in (21) and (23) are
linear functions, therefore, the minimax problem in (24) has
a single solution which we call ˆp j∗
and thus the expected
utility is unique, V j∗
. Moreover, using the mapping between
the allocation vectors and mixed-strategy vectors we can ﬁnd
the mixed-strategies at MSNE, by solving a set of N equations
in (20). However, since the number of the attacker’s and the
gateway’s strategies are greater than N, then solving this set
of equations will result in an inﬁnite number of solutions, i.e.,
(cid:4)
inﬁnitely many MSNEs.

To solve problem (24), one must ﬁnd all the non-dominated
strategies of the gateway to derive values of D and αi.
However, as discussed before, ﬁnding all the gateway’s non-
dominated strategies is challenging in massive IoT scenarios.
Therefore, in a massive IoT scenario analytically deriving the
MSNE by using traditional algorithms such as minimax is
computationally expensive. Moreover, the gateway will need
to store the player’s massive strategy set and re-run the entire
steps of the conventional algorithms to reach an MSNE as the
IoT system changes or a new IoTD joins to the system. Hence,
the delay during the convergence process of such algorithms

may not be tolerable for massive IoT scenarios. Also, at each
time step, since the gateway cannot have complete information
about the unauthenticated IoTDs due to its resource limitation
which makes the convergence of conventional algorithms
not suitable for ﬁnding MSNE. Therefore, we propose two
learning algorithms: a) a ﬁctitious play (FP) for a complete
information game where the gateway knows all IoTDs’ states
at each time step and b) a deep reinforcement learning (DRL)
algorithm that considers the gateway’s lack of information
about the unauthenticated IoTDs.

C. Fictitious Play for Complete Information

To ﬁnd the allocation vector at MSNE, ˆp j∗

, we propose a
learning algorithm based on ﬁctitious play (FP) [37]. Since
our two-player game is constant-sum, using the results of [34]
and [37], we can guarantee convergence FP to an MSNE. In
the proposed algorithm, each player uses its belief about the
allocation vector that its opponent will adopt. This belief stems
from previous observations and is updated at every iteration.
Given that the FP algorithm learns the allocation vector rather
than the mixed strategies, it does not require storing the set of
players’ strategies thus signiﬁcantly reducing the complexity
of ﬁnding MSNE compared to von Neuman’s approach. Note
that the von Neuman approach has a combinatorial complexity
O(2N ). In contrast, by using FP, the complexity reduces to
O(N). Let δ j(t) be player j’s perception of the mixed strategy
that − j adopts at time instant t. Each element δ j
i (t) of δ j(t)
represents the belief that j has at time t, that is the probability
of attacking IoTD i (for the attacker) or authenticating an IoTD
i (for the defender). Such a belief can be built based on the
empirical frequency with which j has chosen IoTD i in the
past. Thus, let η j
i (t) be the number of times that j has observed
− j choosing IoTD i up to time instant t. Then, δ j
i (t) can be
calculated as follows:

.

i (t)

δ j
i (t) =

η j
i (t)
(cid:205)n
i=1 η j
To this end, at time instant t + 1, based on the vector
of empirical probabilities, δ j(t), that it has perceived until
time t, each player j chooses the IoTDs that maximize its
expected utility with respect to its belief about its opponent
while considering both players’ constraints, that is, the attacker
chooses a set H a of K IoTDs such that:

(25)

H a(t) = arg max
K

U a(K, δa(t)),

s.t |K | = K.

(26)

Meanwhile, the gateway chooses a set of IoTDs such that
the resulting computational complexity does not exceed its
computational resource constraints, as follows:

H g(t) = arg max
S

Ug(S, δg(t)),

s.t

(cid:213)

i ∈H g (t)

vi ≤ R.

(27)

After each player j chooses its strategy at time instant t + 1,
it can update its belief as follows:
i (t + 1) = t
δ j
t + 1

i (t) + 1
δ j
t + 1
This learning process proceeds until the calculated empir-
ical frequencies converge. Convergence is achieved when:

{i ∈H− j (t)}.

(28)

1

10

Fig. 9: Security architecture for massive IoT scenario with incom-
plete information. At the gateway, DW-LSTM blocks receive the
signal from IoTDs, and, then, they authenticate the received signal if
DRL triggers them by sending a value 1. Finally, DW-LSTMs send
their associated IoTD’s state to the DRL.
(cid:12)
i (t + 1) − δ j
(cid:12)δ j
(cid:12)
convergence error which is a very small number.

= (cid:15), ∀i ∈ N, ∀ j ∈ P, where (cid:15) is the

(cid:12)
(cid:12)
i (t)
(cid:12)

This algorithm assumes complete information for the play-
ers since they update their strategies based on (26) and (27) at
each step, i.e., this algorithm assumes that the attacker knows
which IoTDs the gateway authenticated at the previous step,
and the gateway knows which IoTDs the attacker attacked
at the previous step. This can be practical in scenarios in
which even the unauthenticated IoTDs can report their security
status to the gateway. However, in more realistic scenarios, the
gateway can only have information about the IoTDs that it
has authenticated at the previous steps. Note that, we consider
that the attacker can always observe the outcome of the game
since any intelligent attacker will normally have an end-goal
from its attack. For example, by attacking a smart grid sensor
(which can be considered as an IoTD), the attacker can aim at
changing the state estimation of the power grid [16] and [38].
Thus, next, we propose a DRL algorithm based on LSTM
blocks [39] to consider the incomplete information case.

D. Deep Reinforcement Learning for Authentication under
Incomplete Information

To capture the incomplete information at the gateway, we
propose a DRL [39] method using LSTM blocks as shown
in Fig. 9. The architecture consists of two components: a) a
deep learning-based dynamic watermarking for IoTD signal
authentication as discussed in Section II and b) a DRL
algorithm based on LSTM blocks to learn which IoTDs to
authenticate at each step based on the attacker’s previous
actions and the gateway’s computational constraints.

As discussed for the FP algorithm, the players use (26) and
(27) to ﬁnd the best action at each step and update their belief
about their opponent’s actions. The attacker can observe its
immediate payoff resulting from the action that it takes at each
time step (since the attacker can see if its attack was successful
or not) and then choose its best strategy at each time step using
(26). However, the gateway cannot compute its immediate
payoff at each time step since the gateway can only observe
the security state of the authenticated IoTDs, and, hence, the
state of the unauthenticated IoTDs will remain unknown to

DRLDW-LSTMDW-LSTMDW-LSTMIoTDIoTDIoTDDW-LSTMIoTD“1”“1”“0”“1”“1,0,1,2”“1,1,2,0”“1,0,2,1”“0,1,2,1”DRL actionDW-LSTM actionIoTDsignalGatewaythe gateway. Thus, the gateway cannot ﬁnd its best action at
each time step using (27). To overcome this challenge, we
propose to use deep neural networks to approximate the the
gateway’s payoff at each time step. In particular, we use an
LSTM at the gateway which receives the action stream of the
attacker at the previous time steps, approximates the gateway’s
payoff at each time step and, then, chooses the gateway’s
optimal action. As discussed previously, LSTM blocks are very
useful in sequence to sequence mapping and future prediction
based on past sequences. Such a (deep reinforcement learning)
DRL algorithm has been used in many applications such as in
imperfect-information games [39], autonomous vehicles [40],
and human-level control systems [41].

The proposed DRL algorithm has two components: (i) a
deep neural network (DNN) that summarizes the past actions
of the attacker and (ii) a reinforcement learning (RL) com-
ponent, which can be used by each player to decide on the
best action to choose based on the summary from the DNN,
as shown in Fig. 10.

To derive the gateway’s action that maximizes its expected
utility, we use a Q-learning algorithm (a special RL method)
[39]. In this algorithm, we deﬁne a state-action value Q-
function, Q(S, h), which is the expected return of the gateway
when starting at a state h and performing action S. The
state h is an N dimensional attacker action sequence which
is deﬁned as follows: Each dimension i of h is a stream
hi(t) = (cid:2)h1
i (t)(cid:3) from each DW-LSTM at the gateway
i (t), . . . , hq
where hl
i(t) is the action of the attacker on IoTD i at step
t − (q − l + 1). This action can take any value in {0, 1, 2}
where 0 indicates no attack, 1 indicates under attack, and 2
indicates that the gateway did not authenticate this IoTD at
this time instant. To derive the maximizer action at each time
step for the gateway, we use the following update rule for the
Q-function (known as Bellman equation [39]):

Qt+1(S(t), h(t)) = Qt (S(t), h(t)) + α

(cid:104)
Ug(S(t), δg(t))
(cid:105)
Qt+1(S,h(t + 1)) −Qt(S(t),h(t))

,

(29)

+γ max
S

where α is a learning rate and γ is a discount factor. From
(29), we can see that, at each step, the gateway must ﬁnd
the action which maximizes Qt . However since each hl
i(t) can
take any value in {0, 1, 2} and h has q × N elements, thus, h
can have 3q×N different values. Storing this many values in a
table and ﬁnding the maximizer action is challenging.

To solve such a challenging problem, we propose to use
LSTM blocks that can store information for long periods of
time and, thus, can learn long-term dependencies within a
given sequence. Thus, the proposed DRL algorithm will use a
DNN as shown in Fig. 10 to approximate the Q function for
the gateway and using this Q function we will choose optimal
actions for the gateway from (29). This then allows to over-
come the complexity challenges. Algorithm 2 summarizes the
proposed DRL approach that is used by the gateway to learn
its optimal action vectors. This algorithm takes the sampling
frequency and the gateway’s resource as input, then, starts
learning from a random belief for each player. The gateway
uses its belief vector at each time step to estimate the state of
the unauthenticated IoTDs. To this end, every IoTD that is not

11

Algorithm 2 Deep Reinforcement Learning for Authentication
Under Incomplete Information.
1: Input F (cid:44) {v1, . . . , vN }, R,
2: Initialize one replay memory M that stores the past experiences of the

gateway, one DNN for Q, δ a (0), and δg (0).

3: Repeat:
4:
5:
6:

Select an action K for the gateway using (26),
Observe state h(t) for the gateway.

∀i ∈ {1, . . . , N } if hi (t) = 2, then hi (t) = 1 with probability

δ g
i (t), otherwise hi (t) = 0.

7:
8:
9:
10:
11:

12:

with probability ε select a random action S ∈ ˜Q g ,
otherwise select S = arg maxS(cid:48) Q(S(cid:48), h(t)) s.t. S(cid:48) ∈ ˜Q g .
Perform actions S and K for both players simultaneously.
Observe utility U g (S, δg (t + 1)) and new state h(t + 1).
Store experience {h(t), S(n), U g (S(t + 1), δg (t + 1)), h(t + 1)} in

Sample

replay memory M for the gateway.
a
(cid:110)ˆh(τ), ˆS(τ), ˆU g ( ˆS(t + 1), ˆδ
memory M.

random

(cid:111)
g (t + 1)), ˆh(τ + 1)

experience
replay

the

from

Calculate the target value t for the gateway:

If the sampled experience is for τ = 0 then t = ˆU g ,
Otherwise t = ˆU g + γ maxS(cid:48) Q(S, α(cid:48)j ).

Train the network Q j for each player using [t j − Q( ˆS(τ), ˆh(τ)]2.
t = t + 1.
Update beliefs δg (t) and δ a (t) using (28).

13:
14:
15:
16:
17:
18:
19: Until convergence.

authenticated at time step t, i.e., ∀l ∈ {1, . . . , N } : hl(t) = 2, is
assigned a value hl(t) = 1 with probability δg
(t) and hl(t) = 0
l
with probability 1 − δg
(t). Then the gateway can approximate
l
its payoff. While the attacker performs the ﬁctitious play as in
the previous section, the gateway aims at ﬁrst approximating
its payoff (note that the gateway cannot ﬁnd its exact payoff
since it does not have complete information about the IoTD
states) and then ﬁnding the best action that maximizes its
payoff at each time step. Moreover, Fig. 10 shows the DNN
architecture for the proposed DRL algorithm. Note that in
this architecture the output of the LSTM block is fed to a
fully connected layer which is followed by a regression layer.
In a fully connected layer, neurons have connections to all
activations in the previous layer, as seen in regular neural
networks. In DNNs, high-level reasoning is done via fully
connected layers [24].

Although this algorithm might not converge to an MSNE,
since it does not have complete information about all the
IoTDs’ state, however, since the gateway uses an LSTM
method to predict the attacker’s future actions based on the
interdependence of attacker’s past actions, it can choose a
set of IoTDs at each step that minimizes the number of
compromised IoTDs. This, in turn, will yield a desirable solu-
tion for the system under incomplete information. In Section
IV, the simulation results will show that the expected utility
resulting from this DRL algorithm is higher than baseline
scenarios,
in which the gateway authenticates IoTDs with
equal probabilities or proportional to IoTDs’ values.

IV. SIMULATION RESULTS AND ANALYSIS

For our simulations, we use a real dataset from an ac-
celerometer with sampling frequency fs = 1kHz. In each
simulation, we derive the optimal values for β, n, and ns using
the method proposed in Section II such that they satisfy the
reliability and delay constraints.

12

Fig. 10: The proposed DRL architecture.

(a) Comparison of IoT signal, static watermarked signal, dynamic
watermarked signal, and training error.

Fig. 11: Training phase of LSTM blocks.

(b) Training performance.

Fig. 11a shows the output of the LSTM trainer with
n = 10, ns = 10, and β = 0.5. From Fig. 11a, we observe
that the trained output of the LSTM, which is the dynamic
watermarked signal, is very close to the training target w.
Moreover, Fig. 11b shows that the training phase converges
after 269 epochs. Here, an epoch is a measure of the number
of times all the training vectors are used once to update the
weights of the neural network. Since each IoTD has its own
LSTM, after training the IoTDs in parallel for approximately
one day, we can use and effectively authenticate the IoTDs in
the system. The training error is 0.0055 which is calculated
using mean squared error. Moreover, we tested the trained
LSTM on another accelerometer data, and the testing error is
small and close to 0.015.

Fig. 12a illustrates the higher performance of LSTM com-
pared to static watermarking in bit extraction. From (6), we
know that higher β/σ results in lower bit error. We can
see from Fig. 12a that the extraction error rate for LSTM
is approximately one order of magnitude lower than static
watermarking when β/σ = 1. This ratio improves for higher
β/σ, as Fig. 12a shows that the error rate of LSTM is almost
two orders of magnitude lower than static watermarking when
β/σ = 10. This result allows designing attack detectors with
lower delay, since we can choose lower n for LSTM which

results in smaller window size and reduces the detection delay.
In addition, Fig. 12b shows how a dynamic data injection
attack operates against the two watermarking schemes. We can
see that, in static watermarking, the attacker records the signal
and by summing the recorded data of each window, increases
the ratio of pseudo-noise key power to the signal power and
extracts the bit stream. However, since in LSTM the bit stream
dynamically changes in each window, the summation of the
recorded data will not increase the ratio of the key power to
the signal power. Therefore, the attacker will not be able to
extract the bit stream and key from the recorded data.

To analyze the effectiveness of our proposed watermarking
schemes in attack detection, we choose a static watermarking
block with n = 10, ns = 10, and β = 0.5. Note that, in order
to choose the number of LSTM blocks, we follow a trial and
error procedure by choosing different number of LSTM blocks
and checking the error rate. Finally, the best performance was
achieved using 100 successive LSTM blocks at the gateway
and IoTDs. We also train our LSTM blocks with these features.
Then, we implement two types of attacks: a) a data injection
attack in which the attacker starts to change the IoTD signal
and b) a dynamic data injection attack, in which the attacker
records the data from the IoTD, extracts the bit stream, and
implements an attack with the the same watermarking bit

𝑈𝑔approximatorMassive IoTsystemLSTMFully Connected LayerRegressionGateway’s Reinforcement LearningAttacker’s Fictitious Play𝑄𝑈𝑎𝒉(𝒕)𝑄𝒉(𝒕)-1.5-1-0.500.511.522.5OutputandtargetErrorsReponsewTrainingoutputsTesttargetsTestoutputsy0.10.110.120.130.140.150.160.170.180.190.2Time(s)-0.4-0.200.20.4ErrorTesttargets050100150200250300350400450Epochs10-310-210-1100101102Mean-squarederror(MSE)Besttrainingperformanceis0.0055067atepoch269TrainTestBest13

(a) Bit error rate of proposed watermarking algorithms.

(b) The power ratio of key to signal in presence of a dynamic data
injection attack.

Fig. 12: Dynamic watermarking LSTM performance.

Fig. 13: Attack detection analysis of static and LSTM watermarking schemes. The y-axis in the lower ﬁgures shows the percentage of
difference between the extracted bit stream and the hidden bit stream. This difference is used at the gateway as a metric to detect attacks on
the IoTDs.

stream. In Fig. 13, the attack detectors compare the extracted
bit stream with the actual hidden bit stream and the percentage
of difference between these two is considered as a metric for
attack detection. In other words, a high difference between
the two bit streams triggers an attack detection alarm. Fig. 13
shows that, for the ﬁrst attack, both watermarking schemes
can detect the attack. However, for a dynamic data injection
attack, static watermarking cannot detect
the existence of
attack while the LSTM performs well. The reason is that, in
static watermarking, the bit stream is the same for all the
time windows while in LSTM the watermarked bit stream
dynamically changes for each time window. In addition, we
can see from Fig. 13 that the delay of attack detection is 0.1
seconds since the attacks starts at 0.5s and the attack detector

triggers the alarm at 0.6s. The reason is that, for a window
size of n × ns/ fs = 0.1 seconds, the gateway must wait for
one window to collect the IoTD data.

Next, to evaluate the performance of the game-theoretic
framework, we consider a system with 1000 IoTDs with
sampling frequency in the range of [1000, 15000] Hz. In
these simulations, we compare our proposed algorithm to two
baseline scenarios: baseline (A) in which the gateway chooses
all the IoTDs with equal probability and baseline (B) in which
the gateway chooses the IoTDs with probabilities proportional
to their values. We simulate our proposed ﬁctitious play for full
information and our proposed DRL for incomplete information
at the gateway.

Fig. 14 shows a simulation in which the attacker has only

0.0010.010.111010-5010-4010-3010-2010-101050100150200250Numberofeavesdroppedwindows00.511.522.533.54Ratioofkeysequencepowertosignalpower(β/σ2)StaticwatermarkingLSTMwatermarking-10123400.10.20.30.40.50.60.70.80.91050100-10123400.10.20.30.40.50.60.70.80.9105010014

Fig. 14: The gateway’s and attacker’s expected utility as a function of gateway’s resource, R, for a scenario with k = 100 and 1000 IoTDs.

K = 100 recording devices, while for the gateway R takes
values in the range [0.1, 1]. We can see from Fig. 14 that, as
the gateway’s available resources increase from 0.1 to 1, the
gateway can protect more IoTDs and thus its expected utility
increases from 0.96 to 1, which indicates that when R = 1, the
gateway can protect all of the IoTDs. Fig. 14 also show that,
since the proposed FP algorithm converges to the MSNE, it
outperforms both the baseline scenarios. For instance, for low
available resources the attacker gains up to 40% more utility
which means that the attacker can compromise approximately
20 more IoTDs when the gateway chooses any one of the
baseline strategies compared to the proposed ﬁctitious play.
Moreover, from Fig. 14, we can see that, for low available
resources, the DRL algorithm yields approximately up to 30%
improvements compared to both baseline scenarios which is
equivalent to 13 less compromised IoTDs. However, it has
up to 10% less expected utility than FP, that is equivalent
to 7 more compromised IoTDs, which is expected due to its
operation under lack of information.

Fig. 15 shows the players’ expected utility as the number
of recording devices varies, for a scenario in which the
available computational resources for the gateway are such
that, R = 0.5. Fig. 15 shows that, as the number of attacker’s
recording devices increases, its expected utility increases and
the attacker can disrupt more IoTDs while staying undetected.
Fig. 15 also shows that using the proposed FP, the gateway can
gain a higher expected utility than the baseline scenarios. Note
that, when the attacker can attack all the IoTDs, K = 1000,
the proposed FP algorithm has almost 5 times higher expected
utility than the baseline scenarios. Furthermore, although pro-
posed DRL has a lower expected utility than FP, it yields
a 20% improvement in the expected utility compared to the
baseline scenarios for the cases where the attacker can attack
all of the IoTDs.

V. CONCLUSION

In this paper, we have proposed a novel deep learning
method based on LSTM blocks for enabling detection of data

injection attacks on IoTDs. We have introduced two water-
marking schemes in which the IoT’s gateway, which collects
the data from the IoTDs, can authenticate the reliability of
received signals. We have shown that our proposed LSTM
method is suitable for IoTD-gateway signal authentication
due to low complexity, small delay, and high accuracy in
attack detection. Moreover, we have studied the massive
IoT scenario in which the gateway cannot authenticate all
the IoTDs simultaneously due to computational limitations.
We have proposed a game-theoretic framework to address
this problem, and we have derived the mixed-strategy Nash
equilibrium and studied its properties. Furthermore, we have
shown that analytically deriving the equilibrium is highly
complicated in massive IoT scenarios, and, thus, we have
proposed two learning algorithms two address this problem: a)
a ﬁctitious play algorithm that considers complete information
about all the IoTDs’ state and converges to the mixed-strategy
Nash equilibrium and b) a deep reinforcement algorithm which
predicts the set of vulnerable IoTDs for the case in which the
gateway cannot have information about the unauthenticated
IoTDs’ state. Simulation results have shown the effectiveness
of the proposed authentication schemes.

A. Proof of Theorem 1

APPENDIX

βi must be chosen such that the attacker cannot use wi
instead of pi to extract the embedded bit. Therefore, we have
to adjust βi to cause a high bit error rate during the extraction
of the hidden bit using the w sequence. Thus, for two different
watermarked signals wi1 and wi2 with equal embedded bit bi =
1, we have:

ˆbi =

=

+

< wi1, wi2 >ni
i n2
β2
i
< yi1, yi2 >ni

=

< yi1

+ βi bi pi, yi2
i n2
β2
i
+ < yi1, βi bi pi >ni
+ < βi bi pi, yi2 >ni

+ βi bi pi >ni

< βi bi pi, βi bi pi >ni
i n2
β2
i

i n2
β2
i
+ Zi2

= Zi1

+ Zi3

+ b2
i ,

(30)

0.10.20.30.40.50.60.70.80.9100.010.020.030.040.050.060.10.20.30.40.50.60.70.80.910.940.950.960.970.980.99115

Fig. 15: The gateway’s and attacker’s expected utility as a function of attacker’s resource, K, for a scenario with R = 0.5 and 1000 IoTDs.

where Zi1, Zi2, and Zi3 are Gaussian random variables with
distributions N
, respec-

, N

, N

0,

0,

(cid:19)

(cid:16)

(cid:16)

(cid:17)

(cid:17)

,

(cid:18) µi1
i n2
β2
i

σ2
i1
i n3
β4
i

σ2
i
i n3
β4
i

tively (the proof is analogous to Lemma 1). Then, we can write
(cid:19)
ˆbi as ˆbi = b2
= bi + Zi4, where Zi4 ∼ N
i
Therefore, the bit error rate incurred during the extraction of
ˆbi will be:

+2σ2
σ2
i
i1
i n3
β4
i

+ Zi4

,

.

σ2
i
i n3
β4
i
(cid:18) µi1
i n2
β2
i

Pr (cid:8) ˆbi < 0|bi = 1(cid:9) = 1
2

erfc

(cid:32)

(cid:33)

E( ˆbi)
√
σ ˆbi
2
(1 + µi1
i n2
β2
i
(cid:113)

√

ni

)β2

i ni

= 1
2

.

(cid:170)
(cid:174)
(cid:174)
(cid:172)

(31)

2(σ2
i1

+ 2σ2
i )

erfc (cid:169)
(cid:173)
(cid:173)
(cid:171)
Since we want to have a high bit error rate for the attacker, we
can write: Pr (cid:8) ˆbi < 0|bi = 1(cid:9) ≥ 1−P. By using this inequelaity
and (31) we can ﬁnd the inequality in (7). Moreover we want
to have a small extraction error for gateway as in (6). Thus,
we have: Pr (cid:8) ˜bi < 0|bi = 1(cid:9) ≤ ¯P, and using (6) we can ﬁnd
(8). From (7) and (8), we can derive the values for βi and
ni which satisfy the security and performance requirement of
the proposed watermarking scheme. Now, since we know that
ni nsi
seconds are needed to receive all the watermarked signal,
f s
i

then the maximum value for nsi can be found by (9).

REFERENCES

[1] A. Ferdowsi and W. Saad, “Deep learning-based dynamic watermarking
for secure signal authentication in the Internet of Things,” in Proc. IEEE
International Conference on Communications (ICC), Kansas City, MO,
USA, May 2018.

[2] Z. Dawy, W. Saad, A. Ghosh, J. G. Andrews, and E. Yaacoub, “To-
ward massive machine type cellular communications,” IEEE Wireless
Communications, vol. 24, no. 1, pp. 120–128, February 2017.

[3] N. Abuzainab, W. Saad, C. S. Hong, and H. V. Poor, “Cognitive
hierarchy theory for distributed resource allocation in the Internet of
Things,” IEEE Transactions on Wireless Communications, vol. 16,
no. 12, pp. 7687–7702, Dec. 2017.

[4] S. M. R. Islam, D. Kwak, M. H. Kabir, M. Hossain, and K. S. Kwak,
“The Internet of Things for health care: A comprehensive survey,” IEEE
Access, vol. 3, pp. 678–708, 2015.

[5] M. Mozaffari, W. Saad, M. Bennis, and M. Debbah, “Unmanned aerial
vehicle with underlaid device-to-device communications: Performance
and tradeoffs,” IEEE Transactions on Wireless Communications, vol. 15,
no. 6, pp. 3949–3963, June 2016.

[6] L. D. Xu, W. He, and S. Li, “Internet of Things in industries: A survey,”
IEEE Transactions on Industrial Informatics, vol. 10, no. 4, pp. 2233–
2243, Nov 2014.

[7] S. Ali, N. Rajatheva, and W. Saad, “Fast uplink grant for machine
type communications: Challenges and opportunities,” arXiv preprint
arXiv:1801.04953, 2018.

[8] H. Suo, J. Wan, C. Zou, and J. Liu, “Security in the Internet of Things:
A review,” in Proc. International Conference on Computer Science and
Electronics Engineering, Hangzhou, China, March 2012, pp. 648–651.
[9] A. Mukherjee, “Physical-layer security in the Internet of Things: Sensing
and communication conﬁdentiality under resource constraints,” Proceed-
ings of the IEEE, vol. 103, no. 10, pp. 1747–1761, Oct. 2015.

[10] W. Trappe, “The challenges facing physical layer security,” IEEE Com-

munications Magazine, vol. 53, no. 6, pp. 16–20, June 2015.

[11] J. Y. Lee, W. C. Lin, and Y. H. Huang, “A lightweight authentication
protocol for Internet of Things,” in Proc. of International Symposium
on Next-Generation Electronics (ISNE), Kwei-Shan, Taiwan, May 2014,
pp. 1–2.

[12] Y. Sharaf-Dabbagh and W. Saad, “On the authentication of devices in
the Internet of Things,” in Proc. IEEE 17th International Symposium
on a World of Wireless, Mobile and Multimedia Networks (WoWMoM),
Coimbra, Portugal, June 2016, pp. 1–3.

[13] P. N. Mahalle, B. Anggorojati, N. R. Prasad, R. Prasad et al., “Identity
authentication and capability based access control (IACAC) for the
Internet of Things,” Journal of Cyber Security and Mobility, vol. 1,
no. 4, pp. 309–348, October 2014.

[14] M. Turkanovi, B. Brumen, and M. Hlbl, “A novel user authentication
and key agreement scheme for heterogeneous ad hoc wireless sensor
networks, based on the Internet of Things notion,” Ad Hoc Networks,
vol. 20, pp. 96 – 112, 2014.

[15] I. Butun, M. Erol-Kantarci, B. Kantarci, and H. Song, “Cloud-centric
multi-level authentication as a service for secure public safety device
networks,” IEEE Communications Magazine, vol. 54, no. 4, pp. 47–53,
April 2016.

[16] Y. Mo, S. Weerakkody, and B. Sinopoli, “Physical authentication of con-
trol systems: Designing watermarked control inputs to detect counterfeit
sensor outputs,” IEEE Control Systems, vol. 35, no. 1, pp. 93–109, Feb
2015.

[17] B. Satchidanandan and P. R. Kumar, “Dynamic watermarking: Active
defense of networked cyber-physical systems,” Proceedings of the IEEE,
vol. 105, no. 2, pp. 219–240, Feb 2017.

[18] P. Hespanhol, M. Porter, R. Vasudevan, and A. Aswani, “Dynamic wa-
termarking for general LTI systems,” arXiv preprint arXiv:1703.07760,
2017.

[19] M. Hosseini, T. Tanaka, and V. Gupta, “Designing optimal watermark
signal for a stealthy attacker,” in Proc. European Control Conference
(ECC), Aalborg, Denmark, June 2016, pp. 2258–2262.

100200300400500600700800900100000.10.20.30.40.50.60.70.80.91100200300400500600700800900100000.10.20.30.40.50.60.70.80.9116

Aidin Ferdowsi received his BS in Electrical En-
gineering from the University of Tehran, Iran, in
2016. He is currently a Ph.D. student at the Bradley
department of Electrical and Computer Engineering
at Virginia Tech. He is also a Wireless@VT Fellow.
His research interests include cyber-physical sys-
tems, machine learning, security, and game theory.

Walid Saad (S’07, M’10, SM15) received his Ph.D
degree from the University of Oslo in 2010. Cur-
rently, he is an Associate Professor at
the De-
partment of Electrical and Computer Engineering
at Virginia Tech, where he leads the Network
Science, Wireless, and Security (NetSciWiS) lab-
oratory, within the Wireless@VT research group.
His research interests include wireless networks,
machine learning, game theory, cybersecurity, un-
manned aerial vehicles, and cyber-physical systems.
Dr. Saad is the recipient of the NSF CAREER award
in 2013, the AFOSR summer faculty fellowship in 2014, and the Young
Investigator Award from the Ofﬁce of Naval Research (ONR) in 2015. He
was the author/co-author of six conference best paper awards at WiOpt in
2009, ICIMP in 2010, IEEE WCNC in 2012, IEEE PIMRC in 2015, IEEE
SmartGridComm in 2015, and EuCNC in 2017. He is the recipient of the 2015
Fred W. Ellersick Prize from the IEEE Communications Society, of the 2017
IEEE ComSoc Best Young Professional in Academia award, and of the 2018
IEEE ComSoc Radio Communications Committee Early Achievement Award.
From 2015-2017, Dr. Saad was named the Stephen O. Lane Junior Faculty
Fellow at Virginia Tech and, in 2017, he was named College of Engineering
Faculty Fellow. He currently serves as an editor for the IEEE Transactions
on Wireless Communications, IEEE Transactions on Communications, IEEE
Transactions on Mobile Computing, and IEEE Transactions on Information
Forensics and Security.

[20] A. Dorri, S. S. Kanhere, R. Jurdak, and P. Gauravaram, “Blockchain for
IoT security and privacy: The case study of a smart home,” in Proc. IEEE
International Conference on Pervasive Computing and Communications
Workshops (PerCom Workshops), Kona, HI, USA, March 2017, pp. 618–
623.

[21] A. Sehgal, V. Perelman, S. Kuryla, and J. Schonwalder, “Management
of resource constrained devices in the Internet of Things,” IEEE Com-
munications Magazine, vol. 50, no. 12, pp. 144–149, December 2012.
[22] H. Sun, X. Wang, R. Buyya, and J. Su, “Cloudeyes: Cloud-based mal-
ware detection with reversible sketch for resource-constrained Internet
of Things (IoT) devices,” Software: Practice and Experience, vol. 47,
no. 3, pp. 421–441, 2017.

[23] C. Stergiou, K. E. Psannis, B.-G. Kim, and B. Gupta, “Secure integration
of IoT and cloud computing,” Future Generation Computer Systems,
vol. 78, pp. 964 – 975, January 2018.

[24] M. Chen, U. Challita, W. Saad, C. Yin, and M. Debbah, “Machine
learning for wireless networks with artiﬁcial intelligence: A tutorial on
neural networks,” arXiv preprint arXiv:1710.02913, 2017.

[25] M. Aazam, I. Khan, A. A. Alsaffar, and E. N. Huh, “Cloud of things:
Integrating internet of things and cloud computing and the issues
involved,” in Proc. of 11th International Bhurban Conference on Applied
Sciences Technology (IBCAST), Jan 2014, pp. 414–419.

[26] H. S. Malvar and D. A. F. Florencio, “Improved spread spectrum: a new
modulation technique for robust watermarking,” IEEE Transactions on
Signal Processing, vol. 51, no. 4, pp. 898–905, Apr. 2003.

[27] J. Haitsma and A. Kalker, “A highly robust audio ﬁngerprinting system,”
in Proc. of International Symposium on Music Information Retrieval
(ISMIR), Paris, France, October 2002, pp. 107–115.

[28] C. Bertoncini, K. Rudd, B. Nousain, and M. Hinders, “Wavelet ﬁnger-
printing of radio-frequency identiﬁcation (RFID) tags,” IEEE Transac-
tions on Industrial Electronics, vol. 59, no. 12, pp. 4843–4850, Dec.
2012.

[29] R. E. Learned and A. S. Willsky, “A wavelet packet approach to transient
signal classiﬁcation,” Applied and Computational Harmonic Analysis,
vol. 2, no. 3, pp. 265 – 278, July 1995.

[30] J. B. Harley, Y. Ying, J. M. F. Moura, I. J. Oppenheim, L. Sobelman,
and J. H. Garrett, “Application of mellin transform features for robust
ultrasonic guided wave structural health monitoring,” Burlington, VT,
USA, July 2011, pp. 1551–1558.

[31] U. Challita, L. Dong, and W. Saad, “Proactive resource management
in LTE-U systems: A deep learning perspective,” IEEE Transactions on
Wireless Communications, to appear, 2018.

[32] A. Graves, A. R. Mohamed, and G. Hinton, “Speech recognition with
deep recurrent neural networks,” in Proc. IEEE International Conference
on Acoustics, Speech and Signal Processing, Vancouver, BC, Canada,
May 2013, pp. 6645–6649.

[33] J. Zhou, Z. Cao, X. Dong, and A. V. Vasilakos, “Security and privacy for
cloud-based iot: Challenges,” IEEE Communications Magazine, vol. 55,
no. 1, pp. 26–33, January 2017.

[34] T. Bas¸ar and G. J. Olsder, Dynamic noncooperative game theory. SIAM,

1998.

[35] G. Bacci, S. Lasaulce, W. Saad, and L. Sanguinetti, “Game theory
for networks: A tutorial on game-theoretic tools for emerging signal
processing applications,” IEEE Signal Processing Magazine, vol. 33,
no. 1, pp. 94–119, Jan. 2016.

[36] Pisinger, “Dynamic programming on the word RAM,” Algorithmica,

vol. 35, no. 2, pp. 128–145, Feb. 2003.

[37] J. Heinrich, M. Lanctot, and D. Silver, “Fictitious self-play in extensive-
form games,” in Proc. of International Conference on Machine Learning,
Lille, France, July 2015, pp. 805–813.

[38] A. Sanjab and W. Saad, “Data injection attacks on smart grids with
multiple adversaries: A game-theoretic perspective,” IEEE Transactions
on Smart Grid, vol. 7, no. 4, pp. 2038–2049, July 2016.

[39] J. Heinrich and D. Silver, “Deep reinforcement learning from self-play in
imperfect-information games,” arXiv preprint arXiv:1603.01121, 2016.
[40] L. Fridman, B. Jenik, and J. Terwilliger, “Deeptrafﬁc: Driving fast
through dense trafﬁc with deep reinforcement learning,” arXiv preprint
arXiv:1801.02805, 2018.

[41] V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G.
Bellemare, A. Graves, M. Riedmiller, A. K. Fidjeland, G. Ostrovski,
S. Petersen, C. Beattie, A. Sadik, I. Antonoglou, H. King, D. Kumaran,
D. Wierstra, S. Legg, and D. Hassabis, “Human-level control through
deep reinforcement learning,” Nature, vol. 518, no. 7540, p. 529, 2015.

