8
1
0
2
c
e
D
4

]

B
D
.
s
c
[

1
v
1
4
7
1
0
.
2
1
8
1
:
v
i
X
r
a

Exploiting Data Sensitivity on Partitioned Data

Sharad Mehrotra, Kerim Yasin Oktay, and Shantanu Sharma

Department of Computer Science, University of California, Irvine, USA.
sharad@ics.uci.edu, shantanu.sharma@uci.edu. (cid:63)

Abstract. Several researchers have proposed solutions for secure data outsourcing on the public clouds based on
encryption, secret-sharing, and trusted hardware. Existing approaches, however, exhibit many limitations including
high computational complexity, imperfect security, and information leakage. This chapter describes an emerging
trend in secure data processing that recognizes that an entire dataset may not be sensitive, and hence, non-sensitivity
of data can be exploited to overcome some of the limitations of existing encryption-based approaches. In particular,
data and computation can be partitioned into sensitive or non-sensitive datasets – sensitive data can either be
encrypted prior to outsourcing or stored/processed locally on trusted servers. The non-sensitive dataset, on the other
hand, can be outsourced and processed in the cleartext. While partitioned computing can bring new efﬁciencies
since it does not incur (expensive) encrypted data processing costs on non-sensitive data, it can lead to information
leakage. We study partitioned computing in two contexts - ﬁrst, in the context of the hybrid cloud where local
resources are integrated with public cloud resources to form an effective and secure storage and computational
platform for enterprise data. In the hybrid cloud, sensitive data is stored on the private cloud to prevent leakage and
a computation is partitioned between private and public clouds. Care must be taken that the public cloud cannot
infer any information about sensitive data from inter-cloud data access during query processing. We then consider
partitioned computing in a public cloud only setting, where sensitive data is encrypted before outsourcing. We
formally deﬁne a partitioned security criterion that any approach to partitioned computing on public clouds must
ensure in order to not introduce any new vulnerabilities to the existing secure solution. We sketch out an approach
to secure partitioned computing that we refer to as query binning (QB) and show how QB can be used to support
selection queries. We evaluate conditions under which partitioned computing approaches such as QB can improve
the performance of cryptographic approaches that are prone to size, frequency-count, and workload attacks.

1 Introduction

Organizations today collect and store a large volume of data, which is analyzed for diverse
purposes. However, in-house computational capabilities of organizations may become obstacles
for storing and processing data. Many untrusted cloud computing platforms (e.g., Amazon AWS,
Google App Engine, and Microsoft Azure) offer database-as-a-service using which data owners,
instead of purchasing, installing, and running data management systems locally, can outsource
their databases and query processing to the cloud. Such cloud-based services available using
the pay-as-you-go model offers signiﬁcant advantages to both small, medium and at times large
organizations. The numerous beneﬁts of public clouds impose signiﬁcant security and privacy
concerns related to sensitive data storage (e.g., sensitive client information, credit card, social

(cid:63) This chapter will appear in the book titled “From Database to Cyber Security: Essays Dedicated to Sushil Jajodia on
the Occasion of His 70th Birthday.” For the ﬁnal version, please check https://link.springer.com/book/10.
1007%2F978-3-030-04834-1 The full approaches proposed in this chapter may be found in [37,34]. This material
is based on research sponsored by DARPA under agreement number FA8750-16-2-0021. The U.S. Government is authorized
to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views
and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the ofﬁcial
policies or endorsements, either expressed or implied, of DARPA or the U.S. Government. This work is partially supported by
NSF grants 1527536 and 1545071.

 
 
 
 
 
 
security numbers, and medical records) or the query execution. The untrusted public cloud may be
an honest-but-curious (or passive) adversary, which executes an assigned job but tries to ﬁnd some
meaningful information too, or a malicious (or active) adversary, that may tamper the data or query.
Such concerns are not a new revelation – indeed, they were identiﬁed as a key impediment for
organizations adopting the database-as-as-service model in early work on data outsourcing [25,26].
Since then, security/conﬁdentiality challenge has been extensively studied in both the cryptography
and database literature, which has resulted in many techniques to achieve data privacy, query
privacy, and inference prevention. Existing work can loosely be classiﬁed into the following three
categories:

[24]), homomorphic encryption [21], bucketization [25],

1. Encryption based techniques. E.g., order-preserving encryption [3], deterministic encryption
searchable
(Chapter 5 of
encryption [42], private informational
[43],
retrieval
oblivious-RAM (ORAM) [23], oblivious transfers (OT) [40], oblivious polynomial evaluation
(OPE) [35], oblivious query processing [5], searchable symmetric encryption [13], and
distributed searchable symmetric encryption (DSSE) [27].

[8], practical-PIR (P-PIR)

(PIR)

2. Secret-sharing [41] based techniques. E.g., distributed point function [22], function
[18,19],

accumulating-automata

secret-sharing

functional

[30],

secret-sharing
[7],
OBSCURE [32], and others [20,33,31].

3. Trusted hardware-based techniques. They are either based on a secure coprocessor or Intel
SGX, e.g., [4,6]. The secure coprocessor and Intel SGX [12] allow decrypting data in a secure
area and perform some computations.

While approaches to compute over encrypted data and systems supporting such techniques
are plentiful, secure data outsourcing and query processing remain an open challenge. Existing
solutions suffer from several limitations. First, cryptographic approaches that prevent leakage,
e.g., fully homomorphic encryption coupled with ORAM, simply do not scale to large data sets
and complex queries for them to be of practical value. Most of the above-mentioned techniques
are not developed to deal with a large amount of data and the corresponding overheads of such
techniques can be very high (see Figure 1 comparing the time taken for TPC-H selection queries
under different cryptographic solutions). To date, a scalable non-interactive mechanism for efﬁcient
evaluation of join queries based on homomorphic encryption that does not leak information
remains an open challenge. Systems such as CryptDB [39] have tried to take a more practical
approach by allowing users to explore the tradeoffs between the system functionality and the
security it offers. Unfortunately, precisely characterizing the security offered by such systems
given the underlying cryptographic approaches have turned out to be extremely difﬁcult. For
instance, [36,28] show that when order-preserving and deterministic encryption techniques are
used together, on a dataset in which the entropy of the values is not high enough, an attacker
might be able to construct the entire plaintext by doing a frequency analysis of the encrypted
data. While mechanisms based on secret-sharing [41] are potentially more scalable, splitting data
amongst multiple non-colluding cloud operators (an assumption that is not valid in a general
setting) incurs signiﬁcant communication overheads and can only support a limited set of selection
and aggregation queries efﬁciently.

2

The x-axis shows the ratio between the selection query execution time on encrypted data using
a cryptographic technique and on cleartext data for a ﬁxed dataset on a speciﬁc database system
(in both cases), and The y-axis shows the security levels. Weak cryptographic techniques
(e.g., deterministic encryption (DET)) are very fast but provide no security (against output
size, frequency-count, access-patterns, and workload attacks), while access-pattern hiding
techniques are relatively secure but slow. The completely secure technique may retrieve the
entire dataset and process at the user-side but this technique is very slow. For join queries,
weak cryptographic techniques are efﬁcient since they can exploit hash/merge join. However,
more secure techniques, since they need nested loop join, tends to become worse. NDET
denotes non-deterministic encryption.

Fig. 1: Comparing different cryptographic techniques.

While the race to develop cryptographic solutions that (i) are efﬁcient, (ii) support complex
SQL queries, (iii) offer provable security from the application’s perspective is ongoing, this chapter
departs from the above well-trodden path by exploring a different (but complementary) approach
to secure data processing by partitioning a computation over either the hybrid cloud or the public
cloud based on the data classiﬁcation into sensitive and non-sensitive data. We focus on an
approach for situations when only part of the data is sensitive, while the remainder (that may consist
of the majority) is non-sensitive. In particular, we consider a partitioned computation model
that exploits such a classiﬁcation of data into sensitive/non-sensitive subsets to develop efﬁcient
data processing solutions with provable security guarantees. Partitioned computing potentially
provides signiﬁcant beneﬁts by (i) avoiding (expensive) cryptographic operations on non-sensitive
data, and, (ii) allowing query processing on non-sensitive data to exploit indices.

The data classiﬁcation into sensitive or non-sensitive may seem artiﬁcial/limiting at ﬁrst,
we refer to the readers to the ongoing dialogue in the popular media [1,2] about cloud
security and hybrid cloud that clearly identify data classiﬁcation policies to classify data as
sensitive/non-sensitive as a key strategy to securing data in a cloud. Furthermore, similar to the
model considered in this chapter, such articles emphasize either storing sensitive data on a private
cloud while outsourcing the rest in the context of hybrid cloud or encrypting only the sensitive

3

Security levelsDET1.43xAccess-pattern hiding3291xSGX6724xEntire DB retrieval11135xx= time to search a keyword in cleartextTimeNDET1.43xFull secureSize, frequency-count, and workload attacks but no access-pattern attackSize, frequency-count, and workload attacks but no access-pattern attackNot secureNot securepart of the data prior to outsourcing. Also, note that data classiﬁcation based on column-level
sensitivity is not a new concept. Papers [9,10,17,11,15,16] have explored many ways to outsource
column-level partitioned data to the cloud. However, these papers does not dictate a joint query
execution on two relations. Some recent database systems such as Jana1 and Opaque [46] are
exploring architectures will allow for only some parts of the data (that is sensitive) to be encrypted
while the remainder of the (non-sensitive) data remains in plaintext, thereby supporting partitioned
computing. That organizational data can actually be classiﬁed as sensitive/non-sensitive is not
difﬁcult to see if we consider speciﬁc datasets. For instance, in a university dataset, data about
courses, catalogs, location of classes, faculty and student enrollment would likely be not considered
sensitive, but information about someone’s SSN, or grade of the student would be considered
sensitive.

Contribution. Our contributions in this chapter are twofold:

Partition computation on the hybrid cloud. Our work is motivated by recent works on the
hybrid cloud that has exploited the fact that for a large class of application contexts, data can be
partitioned into sensitive and non-sensitive components. Such a classiﬁcation was exploited to
build hybrid cloud solutions [29,45,44,38,37] that outsource only non-sensitive data and enjoy
both the beneﬁts of the public cloud as well as strong security guarantees (without revealing
sensitive data to an adversary).

Partition computation on the public cloud. In the setting of the public cloud, sensitive data is
outsourced in an appropriate encrypted form, while non-sensitive data can be outsourced
in cleartext form. While partitioned computing offers new opportunities for efﬁcient and
secure data processing due to avoiding cryptographic approach on the non-sensitive data, it
raises several challenges when used in the public cloud. Speciﬁcally, the partitioned approach
introduces a new security challenge – that of leakage due to simultaneous execution of
queries on the encrypted (sensitive) dataset and on the plaintext (non-sensitive) datasets.
In this chapter, we will study such a leakage (Section 3), a partitioned computing security
deﬁnition in the context of the public cloud (Section 3), and a way to execute partitioned data
processing techniques for selection queries (Section 4) that support partitioned data security
while exploiting existing cryptographic mechanisms for secure processing of sensitive data
and cleartext processing of non-sensitive data. Note that the proposed approach can also be
extended to other operations such as join or range queries, which are provided in [34].

2 Partitioned Computations at the Hybrid Cloud

In this section, our goal is to develop an approach to execute SQL style queries efﬁciently in a
hybrid cloud while guaranteeing that sensitive data is not leaked to the (untrusted) public machines.
At the abstract level, the technique partitions data and computation between the public and private
clouds in such a way that the resulting computation (i) minimizes the execution time, and (ii)
ensures that there is no information leakage. Information leakage, in general, could occur either
directly by exposing sensitive data to the public machines, or indirectly through inferences that

1 https://galois.com/research-development/cryptography/

4

can be made based on selective data transferred between public and private machines during the
execution.

The problem of securely executing queries in a hybrid cloud naturally leads to two interrelated

subproblems:

Data distribution: How is data distributed between private and public clouds? Data distribution
depends on factors such as the amount of storage available on private machines, expected query
workload, and whether data and query workload is largely static or dynamic.

Query execution: Given a data distribution strategy, how do we execute a query securely and
efﬁciently across the hybrid cloud, while minimizing the execution time and obtaining the
correct ﬁnal outputs?

Since data is stored on public cloud in the clear text, data distribution strategy must guarantee
that sensitive data resides only on private machines. Non-sensitive data, on the other hand, could
be stored on private machines, public machines, or be replicated on both. Given a data distribution,
the query processing strategy will split a computation between public and private machines while
simultaneously meeting the goals of good performance and secure execution.

2.1 Split Strategy

In order to ensure a secure query execution, we develop a split strategy for executing SQL queries
in the hybrid cloud setting. In a split strategy, a query Q is partitioned into two subqueries that
can be executed independently over the private and the public cloud respectively, and the ﬁnal
results of the query can be computed by appropriately merging the results of the two sub-queries.
In particular, a query Q on dataset D is split as follows:

Q(D) = Qmerge

(cid:16)

Qpriv(Dpriv), Qpub(Dpub)

(cid:17)

where Qpriv and Qpub are private and public cloud sub-queries respectively. Qpriv is executed on
the private subset of D (i.e., Dpriv); whereas Qpub is performed over the public subset of D (i.e.,
Dpub). Qmerge is a private cloud merge sub-query that reads the outputs of former two sub-queries
as input and creates the outputs equivalent to that of original Q. We call such an execution strategy
as split-strategy.

Two aspects of split-strategy are noteworthy:

1. It offers full security, since the public machines only have access to Dpub that do not contain
any sensitive data. Moreover, no information is exchanged between private and public clouds
during the execution of Qpub, resulting in the execution at the public cloud to be observationally
equivalent to the situation where Dpriv could be any random data.

2. Split-strategy gains efﬁciency by executing Qpriv and Qpub in parallel at the private and public
cloud respectively, and furthermore, by performing inter-cloud data transfer at most once
throughout the query execution. Note that the networks between private and public clouds can
be signiﬁcantly slower compared to the networks used within clouds. Thus, minimizing the
amount of data shufﬂing between the clouds will have a big performance impact.

5

Split strategy, and its efﬁciency, depends upon the data distribution strategy used to partition the
data between private and public clouds. Besides storing sensitive data, the private cloud must also
store part of non-sensitive data (called pseudo sensitive data) that may be needed on the private side
to support efﬁcient query processing. For instance, a join query may necessitate that non-sensitive
data be available at the private node in case-sensitive records from one relation may join with
non-sensitive records in another. Since in the split-execution strategy, the two subqueries execute
independently with no communication, if we do not store non-sensitive data at the private side, we
will need to transfer entire relation to the private side for the join to be computed as part of the
merge query.
Split-strategy for selection or projection. An efﬁcient split-strategy for selection or projection
operation is straightforward. In this case, Qpriv is equivalent to the original query Q, but is
performed only over sensitive records in Dpriv. Likewise, Qpub = Q, but only runs over Dpub.
Finally, Qmerge = Qpriv ∪ Qpub.

Fig. 2: Example relations.

Split-strategy for equijoin. An efﬁcient split-strategy for performing a join query such as Q =
S is more complex. To see this, consider the relations R and S as shown above in Figure 2,
R (cid:46)(cid:47)
C
where sensitive portions of R and S are denoted as Rs and Ss, respectively, and remaining fraction
of them are non-sensitive, denoted as Rns and Sns, and the join condition is C = (R.region =
S.Region). Let us further assume that Rns and Sns, besides being stored in the public cloud are
also replicated on the private cloud.
The naive split-strategy for R (cid:46)(cid:47)
C

S would be:

– Qpub = Rns (cid:46)(cid:47)
C
– Qpriv = (Rs (cid:46)(cid:47)
C

Sns
Ss) ∪ (Rs (cid:46)(cid:47)
C

Sns) ∪ (Rns (cid:46)(cid:47)
C

Ss).

Note that if Q is split as above, Qpriv consists of three subqueries which scan 2, 3, and 3 tuples
in R and S respectively resulting in 8 tuples to be scanned and joined. In contrast, if we simply
executed the query Q on the private side (notice that we can do so, since R and S are fully stored
on the private side), it would result in lower cost requiring scan of 6 tuples on the private side.
Indeed, the overhead of the above split strategy increases even further if we consider multiway
T ) compared to simply implementing the multiway join locally. Thus, if we
joins (e.g., R (cid:46)(cid:47)
C
T , where C (cid:48) is S.Region = T.Region, then the number
use split-strategy for computing R (cid:46)(cid:47)
C
of tuples that are scanned/joined in the private cloud will be much higher than that of the original
query.

S (cid:46)(cid:47)
C(cid:48)

S (cid:46)(cid:47)
C(cid:48)

6

SNameRegionMatt1James2Chris1RFruitRegionapple1grape2orange1TCountryRegionU.S1France3Japan2𝑅𝑁𝑆𝑆𝑆𝑁𝑆𝑅𝑅𝑁𝑆𝑅𝑆𝑆𝑆𝑆𝑁𝑆𝑇𝑁𝑆𝑇𝑆A modiﬁed approach for equijoin. The cost of executing Q in the private cloud can be
signiﬁcantly reduced by pre-ﬁltering relations R and S based on sensitive records of the other
relation. To perform such a pre-ﬁltering operation, the tuples in the relations Rns and Sns have
to be co-partitioned based on whether they join with a sensitive tuple from the other table under
condition C or not.

Let RS

ns be a set of non-sensitive tuples of R that join with any sensitive tuple in S. In our case,
ns be non-sensitive tuples of S that join with any record from Rs,

RS
i.e., (cid:104)Chris, 1(cid:105). In that case, the new private side computation can be rewritten as:

ns = (cid:104)apple, 1(cid:105). Similarly, let SR

(Rs ∪ RS

ns) (cid:46)(cid:47)
C

(Ss ∪ SR

ns).

(1)

ns (cid:46)(cid:47)
C

Thus, the scan and join cost of this new plan at the private cloud is 4, which is lower compared to
computing the query entirely on the private side that had a cost of 6.
Guarded join. The above mentioned modiﬁed strategy, nonetheless, introduces a new challenge.
ns is both repeated at public and private cloud, the output of RS
Since RS
SR
ns, (cid:104)apple,
Chris, 1(cid:105), is computed on both private and public clouds. To prevent this, we do a guarded join
((cid:46)(cid:47)(cid:48)) on the private cloud, which discards the output, if it is generated via joining two non-sensitive
tuples. This feature can easily be implemented by adding a column to R and S that marks
the sensitivity status of a tuple, whether it is sensitive or non-sensitive, and then by adding an
appropriate selection after the join operation. In other words, the complete representation of private
side computation for R (cid:46)(cid:47)
C

S would be

ns (cid:46)(cid:47)
C

SR

σR.sens=true∨S.sens=true((Rs ∪ RS

ns) (cid:46)(cid:47)
C

(Ss ∪ SR

ns))

(2)

where sens is a boolean column (or partition id) appended to relations R and S on the private
cloud. Assume that it is set to true for sensitive records and false for non-sensitive records.
Challenges. There exist multiple challenges in implementing this new approach. First challenge is
the cost of creating RS
ns beforehand. Extracting these partitions for a query might take as
much time as executing the original query. However, the costs are amortized since these relations
are computed once, and used multiple times to improve join performance at the private cloud.

ns and SR

The second challenge is the creation of co-partitioning tables for complex queries. For instance,
S, and then to
in case of a query R (cid:46)(cid:47)
C
join them with T . However, if we do the private side computation of R (cid:46)(cid:47)
S, based on Equation 1
C
(no duplicate ﬁltering) and join the results with T , then we will not be able to obtain the complete
set of sensitive R (cid:46)(cid:47)
C

T , the plan would be to ﬁrst compute results of R (cid:46)(cid:47)
C

T results.

S (cid:46)(cid:47)
C(cid:48)

S (cid:46)(cid:47)
C(cid:48)

To see this, consider the sensitive record (in Figure 2) (cid:104)Japan, 2(cid:105) in T that joins with
ns or joins with non-sensitive (cid:104)James, 2(cid:105) tuple from S −SR
non-sensitive (cid:104)grape, 2(cid:105) tuple in R −RS
ns.
Thus, the non-sensitive records of R and S has to be co-partitioned based on the sensitive records
of T via their join paths from T . In R (cid:46)(cid:47)
R and
C
S. Similarly, the non-sensitive T records has to be co-partitioned based on the
from T to S is T (cid:46)(cid:47)
C(cid:48)
sensitive R and S records via join paths speciﬁed in the query.

T , the join path from T to R is T (cid:46)(cid:47)
C(cid:48)

S (cid:46)(cid:47)
C(cid:48)

S (cid:46)(cid:47)
C

7

Final challenge is in maintaining these co-partitions and feeding the right one when an arbitrary
query arrives. Given a workload of queries and multiple possible join paths between any two
relations, each relation R in the dataset may need to be co-partitioned multiple times. This
implies that any non-sensitive record r of R might appear in more than one co-partition of R.
So, maintaining each co-partition separately might be unfeasible in terms of storage. However, the
identiﬁers of each co-partition that record r belongs to can be embedded into r as a new column.
We call such a column as the co-partition (CPT) column. Note that CPT column is only deﬁned on
the private cloud data, since revealing it to public cloud would violate our security requirement.

CPT column initially will be set to null for sensitive tuples in the private side, since the
co-partitions are only for non-sensitive tuples. Thus, it can further be used to serve another purpose,
indicating the sensitivity status of a tuple r by setting it to “sens” only for sensitive tuples.
Join path. To formalize the concept of co-partitioning, we ﬁrst need to deﬁne the notion of join
path. Let Ri be a relation in our dataset D, and let Q be a query over the relation Ri. We say a join
path exists from a relation Rj to Ri, if either Ri is joined with Rj directly based on a condition C,
Ri, or Rj is joined with Ri indirectly using other relations in Q. A join path p can be
i.e., Rj (cid:46)(cid:47)
C
represented as a sequence of relations and conditions between Rj and Ri relations. Let P athSet
be the set of all join paths that are extracted either from the expected workload or a given dataset
schema.

P athSeti = {∀p ∈ P athSet : path p ends at relation Ri}.

(3)

Let CP (Ri, p) be the set of non-sensitive Ri records that will be joined with at least one
sensitive record from any other relation Rj via the join path p. Note that p starts from Rj and
ends at Ri that can be used as an id to CP (Ri, p). Any CP (Ri, p) is called as “co-partition” of Ri.
Given these deﬁnitions, the CPT column of a Ri record, say r, can be deﬁned as:

r.CP T =

(cid:40)

sens
{∀p ∈ P athSeti : r ∈ CP (Ri, p)}

if r is sens.
otherwise

(4)

Figure 3 shows our example R, S and T relations with their CPT column. For instance, the join
ns. Additionally, the CPT

path R (cid:46)(cid:47) S will be appended to the CPT column of all the tuples in SR
column of all tuples in Rs will be set to sens.

Fig. 3: Example relations with the CPT columns.

2.2 Experimental Analysis

To study the impact of table partitioning discussed in the previous section, we differentiate between
two realizations of our strategy: in our ﬁrst technique, entitled (CPT-C), every record in a table at

8

2TCountryRegionCPTU.S1𝑆⋈𝑇,𝑅⋈𝑆⋈𝑇Japan2sensFrance3nullSNameRegionCPTMatt1sensJames2𝑇⋈𝑆Chris1𝑅⋈𝑆RFruitRegionCPTapple1𝑆⋈𝑅grape2T⋈𝑆⋈𝑅orange1sensthe private cloud contains a CPT column and they are physically stored together; whereas in our
second approach, entitled CPT-P, the tables are partitioned based on their record’s CPT column
and each partition is stored separately. Each partition ﬁle then appended to the corresponding Hive
table as a separate partition, so at querying stage, Hive ﬁlters out the unnecessary partitions for that
particular query.
Sensitive data ratio. For these experiments, we varied the amount of sensitive records
(1, 5, 10, 25, 50%) in customer and supplier tables. Also, we set the number of public machines
to 36. As expected, Figure 4 shows that a larger percentage of sensitive data within the input
leads to a longer workload execution time for both, CPT-C and CPT-P in Hadoop and Spark.
The reason behind this is that a higher sensitive data ratio results in more computations being
performed on the private side and implies a longer query execution time in split-strategy. When
the sensitivity ratio increases, CPT-P’s scan cost increases dramatically. Since the scan cost of
queries is the dominant factor compared to other operators (join, ﬁltering etc.) in Spark, CPT-C
provides a very low-performance gain compared to All-Private in Spark. Because the scan cost
of these two approaches is same. Overall, when sensitivity ratio is as low as 1%, CPT-P provides
8.7× speed-up in Hadoop and 5× speed-up in Spark compared to All-Private.

Fig. 4: Running times for different sensitivity ratios.

Fig. 5: The CPT column’s creation for different sensitivity ratios.

Recall that we created the CPT column using a Spark job for CPT-C solution. We then
physically partitioned tables for CPT-P solution. Figure 5 shows how much time we spent in
preparing private cloud data for both CPT-C and CPT-P. It also indicates the gains of these
approaches compared to All-Private in terms of the overall workload execution time. As indicated

9

 0 5000 10000 15000 20000 25000 30000 3500015102550Workload Running Time (sec)Sensitive Data Ratio (%)Hadoop 200GBCPT-PAll-PrivateAll-Public 0 2000 4000 6000 8000 1000015102550Workload Running Time (sec)Sensitive Data Ratio (%)Spark 200GB 0 4000 8000 12000 16000 20000 24000 28000 3200015102550Time (sec)Sensitive Data Ratio (%)Hadoop 200GBCPT-P CreateCPT-P Gain 0 2000 4000 6000 8000 10000 12000 14000 1600015102550Time (sec)Sensitive Data Ratio (%)Spark 200GBFig. 6: Comparison of pseudo-sensitive data and sensitivity ratio.

in Figure 5, until 25% sensitivity, CPT-P’s data preparation time is less than that of performance
gain in Hadoop; whereas in Spark, data preparation time is always higher than the performance
gain for both CPT-P and CPT-C. Note that, we prepare the CPT column only once on a static
data for an expected workload that will more likely be executed more than once with different
selection and projection conditions. In Spark, if the sensitivity ratio is as high as 10%, executing
the workload more than once will be enough for the performance gain of CPT-P solution to be
higher than the overhead of data preparation time.
Size of Private Storage. Besides storing sensitive data,
in our technique, we also store
pseudo-sensitive data on the private cloud. This enables us to execute queries in a partitioned
manner while minimizing expensive inter-cloud communication during query execution. In
Figure 6, we plot the size of pseudo-sensitive data as a percentage of total database size at
different sensitivity levels. We note that even when sensitivity levels are as high as 5-10%, the
pseudo-sensitive data remains only a fraction (15-25% of the total data). At smaller sensitivity
levels, the ratio is much smaller.

2.3 Other Approaches to Partitioned Computing

The discussion above focused on partitioned computing in hybrid clouds in the context of SQL
queries and is based primarily on the work that appeared in [37]. Several other approaches to
partitioned computing in the hybrid cloud have also been developed in the literature that, similar
to the above-mentioned method, offer security by controlling data distribution between private
and public clouds. Many of these approaches [29,45,44,38] have been developed in the context of
MapReduce job execution, and they address security at a lower level compared to the approach
deﬁned above, which is at SQL level. Note that one could, potentially, transform SQL/Hive
queries into lower level MapReduce jobs and run such MapReduce jobs using privacy preserving
extensions. There are several limitations of such an approach, however, and we refer the reader
to [37] for a detailed discussion of the limitations of such an approach and to [14] for a detailed
survey on the hybrid cloud based MapReduce security.

10

 0 10 20 30 40 50 60 80 10015102550Ratio to All Data (%)Sensitive Data Ratio (%)Data Ratio 20GBPseudosensitive3 Partitioned Computations at the Public Cloud and Security Deﬁnition

In this section, we deﬁne the partitioned computation, illustrate how such a computation can
leak information due to the joint processing of sensitive and non-sensitive data, discuss the
corresponding security deﬁnition, and ﬁnally discuss system and adversarial models under which
we will develop our solutions.

Partitioned Computations

Let R be a relation that is partitioned into two sub-relations, Re ⊇ Rs and Rp ⊆ Rns, such that
R = Re ∪Rp. The relation Re contains all the sensitive tuples (denoted by Rs) of the relation R and
will be stored in encrypted form in the cloud. Note that Re may contain additional (non-sensitive)
tuples of R, if that helps with secure data processing). The relation Rp refer to the sub-relation
of R that will be stored in plaintext on the cloud. Naturally, Rp does not contain any sensitive
tuples. For the remainder of the chapter, we will assume that Re = Rs and Rp = Rns, though our
approach will be generalized to allow for a potentially replicated representation of non-sensitive
data in encrypted form, if it helps to evaluate queries more efﬁciently. Let us consider a query Q
over relation R. A partition computation strategy splits the execution of Q into two independent
sub-queries: Qs: a query to be executed on E(Re) and Qns: a query to be executed on Rp. The
ﬁnal results are computed (using a query Qmerge) by appropriately merging the results of the two
sub-queries at the trusted database (DB) owner side (or in the cloud, if a trusted component, e.g.,
Intel SGX, is available for such a merge operation). In particular, the query Q on a relation R is
partitioned, as follows:

Q(R) = Qmerge

Qs(Re), Qns(Rp)

(cid:16)

(cid:17)

Let us illustrate partitioned computations through an example.

EId FirstName LastName SSN Ofﬁce# Department

t1 E101 Adam
t2 E259 John
t3 E199 Eve
t4 E259 John
t5 E152 Clark
t6 E254 David
t7 E159 Lisa
t8 E152 Clark

111 1
Smith
Williams 222 2
Smith
333 2
Williams 222 6
444 1
Cook
555 4
Watts
666 2
Ross
444 3
Cook

Defense
Design
Design
Defense
Defense
Design
Defense
Design

Fig. 7: A relation: Employee.

Example 1: Consider an Employee relation, see Figure 7. In this relation, the attribute SSN
is sensitive, and furthermore, all tuples of employees for the Department = “Defense” are
sensitive. In such a case, the Employee relation may be stored as the following three relations:

11

(i) Employee1 with attributes EId and SSN (see Figure 8); (ii) Employee2 with attributes EId,
FirstName, LastName, Ofﬁce#, and Department, where Department = “Defense” (see Figure 9);
and (iii) Employee3 with attributes EId, FirstName, LastName, Ofﬁce#, and Department, where
Department <> “Defense” (see Figure 10). Since the relations Employee1 and Employee2
(Figures 8 and 9) contain only sensitive data, these two relations are encrypted before outsourcing,
while Employee3 (Figure 10), which contains only non-sensitive data, is outsourced in clear-text.
We assume that the sensitive data is strongly encrypted such that the property of ciphertext
indistinguishability (i.e., an adversary cannot distinguish pairs of ciphertexts) is achieved. Thus,
the two occurrences of E152 have two different ciphertexts.

EId SSN
t1 E101 111
t2 E259 222
t3 E199 333
t5 E152 444
t6 E254 555
t7 E159 666

Fig. 8: A sensitive relation: Employee1.

EId FirstName LastName Ofﬁce# Department

t1 E101 Adam
t4 E259 John
t5 E152 Clark
t7 E159 Lisa

Smith
1
Williams 6
1
Cook
2
Ross

Defense
Defense
Defense
Defense

Fig. 9: A sensitive relation: Employee2.

EId FirstName LastName Ofﬁce# Department
Williams 2
2
Smith
4
Watts
3
Cook

t2 E259 John
t3 E199 Eve
t6 E254 David
t8 E152 Clark

Design
Design
Design
Design

Fig. 10: A non-sensitive relation: Employee3.

Consider a query Q: SELECT FirstName, LastName, Office#, Department
from Employee where FirstName = ’’John’’. In partitioned computation, the query

12

Q is partitioned into two sub-queries: Qs that executes on Employee2, and Qns that executes on
Employee3. Qs will retrieve the tuple t4 while Qns will retrieve the tuple t2. Qmerge in this
example is simply a union operator. Note that the execution of the query Q will also retrieve the
same tuples.

Inference Attack in Partitioned Computations

Partitioned computations, if performed naively, could lead to inferences about sensitive data
from non-sensitive data. To see this, consider following three queries on the Employee2 and
Employee3 relations: (i) retrieve tuples of the employee Eid = E259, (ii) retrieve tuples of the
employee Eid = E101, and (iii) retrieve tuples of the employee Eid = E199. We consider an
honest-but-curious adversarial cloud that returns the correct answers to the queries but wishes to
know information about the encrypted sensitive tables, Employee1 and Employee2.

Table 1 shows the adversary’s view based on executing the corresponding Qs and Qns
components of the above three queries assuming that the tuple retrieving cryptographic approaches
are not hiding access-patterns. During the execution, the adversary gains complete knowledge
of non-sensitive tuples returned, and furthermore, knowledge about which encrypted tuples are
returned as a result of Qs (E (ti ) in the table refers to the encrypted tuple ti).

Query value Returned tuples/Adversarial view

E259
E101
E199

Employee2 Employee3
t2
E (t4 )
E (t1 )
null
t3
null

Table 1: Queries and returned tuples/adversarial view.

Given the above adversarial view, the adversary learns that employee E259 has tuples in both
Ds (= De) and Dp (= Dns). Coupled with the knowledge about data partitioning, the adversary can
learn that E259 works in both sensitive and non-sensitive departments. Moreover, the adversary
learns which sensitive tuple has an Eid equals to E259. From the 2nd query, the adversary learns
that E101 works only in a sensitive department, (since the query did not return any answer from
the Employee3 relation). Likewise, from the 3rd query, the adversary learns that E199 works only
in a non-sensitive department.

In order to prevent such an attack, we need a new security deﬁnition. Before we discuss the
formal deﬁnition of partitioned data security, we ﬁrst provide intuition for the deﬁnition. Observe
that before retrieving any tuple, under the assumption that no one except the DB owner can decrypt
an encrypted sensitive value, say E(si), the adversary cannot learn which non-sensitive value is
identical to cleartext value of E(si); let us denote si as cleartext of E(si). Thus, the adversary will
consider that the value si is identical to one of the non-sensitive values. Based on this fact, the
adversary can create a complete bipartite graph having |S| nodes on one side and |NS | nodes on
the other side, where |S| and |NS | are a number of sensitive and non-sensitive values, respectively.

13

The edges in the graph are called surviving matches of the values. For example, before executing
any query, the adversary can create a bipartite graph for 4 sensitive and 4 non-sensitive values of
EID attribute of Example 1; as shown in Figure 11.

Fig. 11: A bipartite graph showing an initial condition sensitive and non-sensitive values before
query execution.

The query execution on the datasets creates an adversarial view that guides the adversary to
create a (new) bipartite graph of the same number of nodes on both sides. The requirement is to
preserve all the edges of the initial bipartite graph in the graph obtained after the query execution,
leading to the initial condition that the cleartext of the value E(si) is identical to one of the
non-sensitive values. Note that if the query execution removes any surviving matches of the values,
it will leak that the value si is not identical to those non-sensitive values.

We also need to hide occurrences of a sensitive value. Before a query execution, due to
ciphertext indistinguishability, all occurrences of a single sensitive value are different, but a simple
search or join query may reveal how many tuples have the same value. Based on the above two
requirements, we can deﬁne a notion of partitioned data security.

Partitioned Data Security at the Public Cloud

Let R be a relation containing sensitive and non-sensitive tuples. Let Rs and Rns be the sensitive
and non-sensitive relations, respectively. Let q(Rs, Rns)[A] be a query, q, over an attribute A of the
Rs and Rns relations. Let X be the auxiliary information about the sensitive data, and PrAdv be the
probability of the adversary knowing any information. A query execution mechanism ensures the
partitioned data security if the following two properties hold:

– Pr Adv [ei

a= ns j|X] = Pr Adv [ei

a= ns j|X, q(Rs, Rns)[A]], where ei = E(ti)[A] is the encrypted
representation for the attribute value A for any tuple ti of the relation Rs and ns j is a value for
the attribute A for any tuple of the relation Rns. The notation a= shows a sensitive value is
identical to a non-sensitive value. This equation captures the fact that an initial probability
of linking a sensitive tuple with a non-sensitive tuple will be identical after executing several
queries on the relations.

r∼ vj|X] = Pr Adv [vi

r∼ vj|X, q(Rs, Rns)[A]], for all vi, vi ∈ Domain(A). The
notation r∼ shows a relationship between counts of the number of tuples with sensitive values.
This equation states that the probability of adversary gaining information about the relative
frequency of sensitive values does not increase by the query execution.

– Pr Adv [vi

14

SensitivevaluesNon-sensitive valuesE101E259E152E159E259E199E254E152The deﬁnition above formalizes the security requirement of any partitioned computation
approach. Of course, a partitioned approach, besides being secure, must also be correct in that
it returns the same answer as that returned by the original query Q if it were to execute without
regard to security.

4 Query Binning: A Technique for Partitioned Computations using a

Cryptographic Technique at the Public Cloud

In this section, we will study query binning (QB) as a partitioned computing approach. QB is
related to bucketization, which is studied in past [25]. While bucketization was carried over the
data in [25], QB performs bucketization on queries. In general, one may ask more queries than
original query while adding overhead but it prevents the above-mentioned inference attack. We
study QB under some assumption and setting, given below.2.
Problem Setup. We assume the following two entities in our model: (i) A database (DB) owner:
who splits each relation R in the database having attributes Rs and Rns containing all sensitive and
non-sensitive tuples, respectively. (ii) A public cloud: The DB owner outsources the relation Rns
to a public cloud. The tuples in Rs are encrypted using any existing mechanism before outsourcing
to the same public cloud. However, in the approach, we use non-deterministic encryption, i.e., the
cipher representation of two occurrences of an identical value has different representations.
DB Owner Assumptions. In our setting, the DB owner has to store some (limited) metadata
such as searchable values and their frequency counts, which will be used for appropriate
query formulation. The DB owner is assumed to have sufﬁcient storage for such metadata, and
also computational capabilities to perform encryption and decryption. The size of metadata is
exponentially smaller than the size of the original data.
Adversarial Model. The adversary (i.e., the untrusted cloud) is assumed to be honest-but-curious,
trustworthy. An
which is a standard setting for security in the public cloud that
honest-but-curious adversarial public cloud, thus, stores an outsourced dataset without tampering,
correctly computes assigned tasks, and returns answers; however, it may exploit side knowledge
(e.g., query execution, background knowledge, and the output size) to gain as much information as
possible about the sensitive data. Furthermore, the adversary can eavesdrop on the communication
channels between the cloud and the DB owner, and that may help in gaining knowledge about
sensitive data, queries, or results. The adversary has full access to the following information: (i) all
non-sensitive data outsourced in plaintext, and (ii) some auxiliary information of the sensitive data.
The auxiliary information may contain the metadata of the relation and the number of tuples in the
relation. Furthermore, the adversary can observe frequent query types and frequent query terms
on the non-sensitive data in case of selection queries. The honest-but-curious adversary, however,
cannot launch any attack against the DB owner.
Assumptions for QB. We develop QB initially under the assumption that queries are only on a
single attribute, say A. The QB approach takes as inputs: (i) the set of data values (of the attribute
A) that are sensitive along with their counts, and (ii) the set of data values (of the attribute A) that

is not

2 Some of these assumptions are made primarily for ease of the exposition and will be relaxed in [34].

15

are non-sensitive, along with their counts. The QB returns a partition of attribute values that form
the query bins for both the sensitive as well as for the non-sensitive parts of the query.

In this chapter, we also restrict to a case when a value has at most two tuples, where one of
them must be sensitive and the other one must be non-sensitive, but both the tuples cannot be
sensitive or non-sensitive. The scenario depicted in Example 1 satisﬁes this assumption. The EId
attribute values corresponding to sensitive tuples include (cid:104)E101, E259, E152, E159(cid:105) and from
the non-sensitive relation values are (cid:104)E199, E259, E152, E254(cid:105). Note that all the values occur
only one time in one set.
Full version. In this chapter, we restrict the algorithm for selection query only on one attribute.
The full details of the algorithm, extensions of the algorithm for values having a different number
of tuples, conjunctive, range, join, insert queries, and dealing with the workload-skew attack is
addressed in [34]. Further, the computing cost analysis and efﬁciency analysis of QB at different
or identical-levels of security against a pure cryptographic technique is given in [34].
The Approach. We develop an efﬁcient approach to execute selection queries securely (preventing
the information leakage as shown in Example 1) by appropriately partitioning the query at a
public cloud, where sensitive data is cryptographically secure while non-sensitive data stays in
cleartext. For answering a selection query, naturally, we use any existing cryptographic technique
on sensitive data and a simple search on the cleartext non-sensitive data. Naturally, we can use a
secure hardware, e.g., Intel SGX, for all such operations; however, as mentioned in §1 Figure 1,
SGX-based processing takes a signiﬁcant amount of time, due to limited space of the enclave.

Informally, QB distributes attribute values in a matrix, where rows are sensitive bins, and
columns are non-sensitive bins. For example, suppose there are 16 values, say 0, 1, . . . , 15, and
assume all the values have sensitive and associated non-sensitive tuples. Now, the DB owner
arranges 16 values in a 4 × 4 matrix, as follows:

NSB 0 NSB 1 NSB 2 NSB 3
5
8
6
12

2
3
15
1

14
7
4
9

SB 0 11
SB 1 10
SB 2 0
SB 3 13

In this example, we have four sensitive bins: SB 0 {11,2,5,14}, SB 1 {10,3,8,7}, SB 2 {0,15,6,4},
SB 3 {13,1,12,9}, and four non-sensitive bins: NSB 0 {11,10,0,13}, NSB 1 {2,3,15,1}, NSB 2
{5,8,6,12}, NSB 3 {14,7,4,9}. When a query arrives for a value, say 1, the DB owner searches for
the tuples containing values 2,3,15,1 (viz. NSB 1) on the non-sensitive data and values in SB 3 (viz.,
13,1,12,9) on the sensitive data using the cryptographic mechanism integrated into QB. While the
adversary learns that the query corresponds to one of the four values in NSB 1, since query values
in SB 3 are encrypted, the adversary does not learn any sensitive value or a non-sensitive value that
is identical to a clear-text sensitive value.

Formally, QB appropriately maps a selection query for a keyword w, say q(w),
to
corresponding queries over the non-sensitive relation, say q(Wns)(Rns), and encrypted relation,
say q(Ws)(Rs). The queries q(Wns)(Rns) and q(Ws)(Rs), each of which represents a set of query
values that are executed over the relation Rns in plaintext and, respectively, over the sensitive

16

Algorithm 1: Bin-creation algorithm, the base case.

Inputs: |NS |: the number of values in the non-sensitive data, |S|: the number of values in
the sensitive data.
Outputs: SB : sensitive bins; NSB : non-sensitive bins

3

4

1 Function create bins(S , NS ) begin
Permute all sensitive values
2
x, y ← approx sq factors(|NS |): x ≥ y
|NSB | ← x, NSB ← (cid:100)|NS |/x(cid:101), SB ← x, |SB | ← y
for i ∈ (1, |S|) do SB [i modulo x][∗] ← S[i];
for (i, j) ∈ (0, SB − 1), (0, |SB | − 1) do NSB [j][i] ← allocateNS (SB [i ][j ]) ;
for i ∈ (0, NSB − 1) do NSB [i][∗] ← ﬁll the bin if empty with the size limit to x ;
return SB and NSB

5

6

7

8

end

9 Function allocateNS (SB [i ][j ]) begin

ﬁnd a non-sensitive value associated with the jth sensitive value of the ith sensitive bin

end

relation Rs, using the underlying cryptographic method. The sets Wns from Rns and Ws from Rs
are selected such that: (i) w ∈ q(Wns)(Rns) ∩ q(Ws)(Rs) to ensure that all the tuples containing w
are retrieved, and, (ii) the execution of the queries q(Wns)(Rns) and q(Ws)(Rs) does not reveal any
information (and w) to the adversary. The set of q(Wns)(Rns) is entitled non-sensitive bins, and
the set of q(Ws)(Rs) is entitled sensitive bins. Algorithm 1 provides pseudocode of bin-creation
method.3 Results from the execution of the queries q(Wns)(Rns) and q(Ws)(Rs) are decrypted,
possibly ﬁltered, and merged to generate the ﬁnal answer.

Based on QB Algorithm 1, for answering the above-mentioned three queries in Example 1,
given in Section 3, Algorithm 1 creates two sets or bins on sensitive parts: sensitive bin 1, denoted
by SB 1, contains {E101, E259}, sensitive bin 2, denoted by SB 2, contains {E152, E159},
and two sets/bins on non-sensitive parts: non-sensitive bin 1, denoted by NSB 1, contains {E259,
E254}, non-sensitive bin 2, denoted by NSB 2, contains {E199, E152}.

Query value Returned tuples/Adversarial view

Employee1 Employee2
E (t4 ), E (t1 ) t2, t6
E (t4 ), E (t1 ) t3, t8
E (t4 ), E (t1 ) t3, t8
Table 2: Queries and returned tuples/adversarial view when following QB.

E259
E101
E199

3 The function approx sq factors in Algorithm 1 two factors x and y of a number n, such that either they are equal or close to
each other so that the difference between x and y is less than the difference between any two factors of n (and x × y = n).

17

Algorithm 2: Bin-retrieval algorithm.

Inputs: w: the query value.
Outputs: SB a and NSB b: one sensitive bin and one non-sensitive bin to be retrieved for
answering w.
Variables: found ← false

1 Function retrieve bins(q(w )) begin
2

for (i, j) ∈ (0, SB − 1), (0, |SB | − 1) do

if w = SB i[j] then

3

4

5

6

7

return SB i and NSB j; found ← true; break

end

end
if found (cid:54)= true then

for (i, j) ∈ (0, NSB − 1), (0, |NSB | − 1) do

if w = NSB i[j] then

return NSB i and SB j; break

end

end

end
Retrieve the desired tuples from the cloud by sending encrypted values of the bin SB i
(or SB j) and clear-text values of the bin NSB j (or NSB i) to the cloud

end

Algorithm 2 provides a way to retrieve the bins. Thus, by following Algorithm 2, Table 2
shows that the adversary cannot know the query value w or ﬁnd a value that is shared between
the two sets, when answering to the above-mentioned three queries. The reason is that the desired
query value, w, is encrypted with other encrypted values of the set Ws, and, furthermore, the query
value, w, is obscured in many requested non-sensitive values of the set Wns, which are in cleartext.
Consequently, the adversary is unable to ﬁnd an intersection of the two sets, which is the exact
value. Thus, while answering a query, the adversary cannot learn which employee works only in
defense, design, or in both.
Correctness. The correctness of QB indicates that the approach maintains an initial probability
of associating a sensitive tuple with a non-sensitive tuple will be identical after executing several
queries on the relations.

We can illustrate the correctness of QB with the help of an example. The objective of the
adversary is to deduce a clear-text value corresponding to an encrypted value of either {E101,
E259} or {E152, E159}, since we retrieve the set of these two values. Note that before
executing a query, the probability of an encrypted value, say Ei, (where Ei may be E101, E259,
E152, or E159) to have the clear-text value is 1/4, which QB maintains at the end of a query.
Assume that E1 and E2 are encrypted representations of E101 and E259, respectively. Also,
assume that v1, v2, v3, v4 are showing the cleartext value of E259, E254, E199, and E152,
respectively.

18

When the query arrives for (cid:104)E1, E2, v1, v2(cid:105), the adversary gets the fact that the clear-text
representation of E1 and E2 cannot be v1 and v2 or v3 and v4. If this will happen, then there is
no way to associate each sensitive bin of the new bipartite graph with each non-sensitive bin.
Now, if the adversary considers the clear-text representation of E1 is v1, then the adversary have
four possible allocations of the values v1, v2, v3, v4 to E1, E2, E3, E4, such as: (cid:104)v1, v2, v3, v4(cid:105),
(cid:104)v1, v2, v4, v3(cid:105), (cid:104)v1, v3, v4, v2(cid:105), (cid:104)v1, v4, v3, v2(cid:105).

Since the adversary is not aware of the exact clear-text value of E1, the adversary also considers
the clear-text representation of E1 is v2, v3, or v4. This results in 12 more possible allocations of
the values v1, v2, v3, v4 to E1, E2, E3, E4. Thus, the retrieval of the four tuples containing one of
the following: (cid:104)E1, E2, v1, v2(cid:105), results in 16 possible allocations of the values v1, v2, v3, and v4 to
E1, E2, E3, and E4, of which only four possible allocations have v1 as the clear-text representation
of E1. This results in the probability of ﬁnding E1 = v1 is 1/4.

Note that following this technique, executing queries under for each keyword will not eliminate
any surviving matches of the bipartite graph, and hence, the adversary can ﬁnd the new bipartite
graph identical to a bipartite graph before the query execution. Figure 11 shows an initial bipartite
graph before the query execution and Figure 12 shows a bipartite graph after the query execution
when creating bins on the values. Note that in Figure 12 each sensitive bin is linked to each
non-sensitive bin, that in turns, shows that each sensitive value is linked to each non-sensitive
value.

Fig. 12: A bipartite graph showing sensitive and non-sensitive bins after query execution, where
each sensitive value gets associated with each non-sensitive value.

5 Effectiveness of QB

From the performance perspective, QB results in saving of encrypted data processing over
non-sensitive data – the more the non-sensitive data, the more potential savings. Nonetheless, QB
incurs overhead – it converts a single predicate selection query into a set of predicates selection
queries over cleartext non-sensitive data, and, a set of encrypted predicates selection queries albeit
over a smaller database consisting only of sensitive data. In this section, we compare QB against a
pure cryptographic technique and show when using QB is beneﬁcial.

For our model, we will need the following notations: (i) Ccom: Communication cost of moving
one tuple over the network. (ii) Cp (or Ce): Processing cost of a single selection query on plaintext
(or encrypted data). In addition, we deﬁne three parameters:

19

SensitivevaluesNon-sensitive valuesE101E259E152E159E152E199E254E259SB1SB2NSB1NSB2α : is the ratio between the sizes of the sensitive data (denoted by S) and the entire dataset (denoted

by S + NS , where NS is non-sensitive data).

β : is the ratio between the predicate search time on encrypted data using a cryptographic
technique and on clear-text data. The parameter β captures the overhead of a cryptographic
technique. Note that β = Ce/Cp.

γ : is the ratio between the processing time of a single selection query on encrypted data and the
time to transmit the single tuple over the network from the cloud to the DB owner. Note that
γ = Ce/Ccom.

Based on the above parameters, we can compute the cost of cryptographic and

non-cryptographic selection operations as follows:

Cost plain(x, D) is the sum the processing cost of x selection queries on plaintext data and the
communication cost of moving all the tuples having x predicates from the cloud to the DB
owner, i.e., x(log(D)Pp + ρDCcom).

Cost crypt (x, D) is the sum the processing cost of x selection queries on encrypted data and the
communication cost of moving all the tuples having x predicates from the cloud to the DB
owner, i.e., PeD +ρxDCcom, where ρ is the selectivity of the query. Note that cost of evaluating
x queries over encrypted data using techniques such as [42,22,20], is amortized and can be
performed using a single scan of data. Hence, x is not the factor in the cost corresponding to
encrypted data processing.

Given the above, we deﬁne a parameter η that is the ratio between the computation and
communication cost of searching using QB and the computation and communication cost of
searching when the entire data (viz. sensitive and non-sensitive data) is fully encrypted using the
cryptographic mechanism.

η =

Cost crypt (|SB |, S)
Cost crypt (1, D)

+

Cost plain(|NSB |, NS )
Cost crypt (1, D)

Filling out the values from above, the ratio is:

η =

CeS + |SB |ρDCcom
CeD + ρDCcom

+

|NSB | log(D)Cp + |NSB |ρDCcom
CeD + ρDCcom

Separating out the communication and processing costs, η becomes:

η =

S
D

Ce
Ce + ρCcom

+

|NSB | log(D)Cp
CeD + ρDCcom

+

ρDCcom(|NSB | + |SB |)
CeD + ρDCcom

Substituting for various terms and cancelling common terms provides:

η = α

1
(1 + ρ
γ )

+

log(D)
D

|N SB|
β(1 + ρ
γ )

+

ρ
γ

|NSB | + |SB |
(1 + ρ
γ )

Note that ρ/γ is very small, thus the term (1 + ρ/γ) can be substituted by 1. Given the above, the
equation becomes:

η = α + log(D)|NSB /Dβ + ρ(|NSB | + |SB |)/γ

20

Note that the term log(D)|NSB |/Dβ is very small since |NSB | is the number of distinct values
(approx. equal to (cid:112)|NS |) in a non-sensitive bin, while D, which is the size of a database, is a large
number, and β value is also very large. Thus, the equation becomes:

η = α + ρ(|SB | + |NSB |)/γ

QB is better than a cryptographic approach when η < 1, i.e., α + ρ(|SB | + |NSB |)/γ < 1.

Thus,

α < 1 −

ρ(|SB | + |NSB |)
γ

Note that the values of |SB | and |NSB | are approximately (cid:112)|NS |, we can simplify the above
equation to: α < 1 − 2ρ(cid:112)|NS |/γ. If we estimate ρ to be roughly 1/|NS | (i.e., we assume uniform
distribution), the above equation becomes: α < 1 − 2/γ(cid:112)|NS |.

The equation above demonstrates that QB trades increased communication costs to reduce the
amount of data that needs to be searched in encrypted form. Note that the reduction in encryption
cost is proportional to α times the size of the database, while the increase in communication costs
is proportional to (cid:112)|D|, where |D| is the number of distinct attribute values. This, coupled with the
fact that γ is much higher than 1 for encryption mechanisms that offer strong security guarantees,
ensures that QB almost always outperforms the full encryption approaches. For instance, the
cryptographic cost for search using secret-sharing is ≈ 10ms [20], while the cost of transmitting
a single row (≈ 200 bytes for TPCH Customer table) is ≈ 4 µs making the value of γ ≈ 25000.
Thus, QB, based on the model, should outperform the fully encrypted solution for almost any value
of α, under ideal situations where our assumption of uniformity holds. Figure 13 plots a graph of
η as a function of γ, for varying sensitivity and ρ = 10%.

Fig. 13: Efﬁciency graph using equation η = α + ρ(|SB | + |NSB |)/γ.

Figure 14 plots η values for the three DB sizes: 150K, 1.5M, and 4.5M for a linear scan
cryptographic technique while varying sensitivity, denoted by α. The ﬁgure shows that η < 1,
irrespective of the DB sizes, conﬁrming that the approach scales to larger DB sizes, and we do
not pay any overhead while using linear-scan techniques. Recall that the reason is that the cost
of searching a single value over encrypted data using a linear scan absorbs the cost of searching
multiple values using a linear scan on the same data.

21

10010000200003000040000500000.00.51.01.5=1=0.3=0.6=0.9Fig. 14: Dataset size.

6 Conclusion

This chapter focuses on partitioned computing as a mechanism to scale cryptographic techniques
while still ensuring security. Inspired by current security practice wherein organizations classify
data as sensitive/non-sensitive prior to outsourcing, partitioned computing exploits the fact that
non-sensitive data can be outsourced to and processed at the public cloud in plaintext. Thus,
computation is partitioned into two parts — the one that executes non-sensitive data in plaintext and
the part that executes on sensitive data. We study partitioned computing in two different settings —
in the context of the hybrid cloud wherein sensitive data is kept on a private cloud and in the context
of a public cloud where sensitive data is encrypted using existing cryptographic mechanisms prior
to outsourcing. In both cases, partitioned computing if not done carefully could leak sensitive data.
We deﬁne a notion of partitioned security (primarily for the context of partitioned computing in
the public cloud) and develop mechanisms to ensure that partitioned computing does not lead to
any new vulnerabilities.

References

1. Available at: https://digitalguardian.com/blog/expert-guide-securing-sensitive-data-34-experts-reveal-biggest-mistakes-companies-make-data.
2. Available

http://www.computerworld.com/article/2834193/cloud-computing/

at:

5-tips-for-building-a-successful-hybrid-cloud.html.

3. R. Agrawal, J. Kiernan, R. Srikant, and Y. Xu. Order-preserving encryption for numeric data. In SIGMOD Conference, pages

563–574. ACM, 2004.

4. A. Arasu, S. Blanas, K. Eguro, R. Kaushik, D. Kossmann, R. Ramamurthy, and R. Venkatesan. Orthogonal security with

cipherbase. In CIDR. www.cidrdb.org, 2013.

5. A. Arasu and R. Kaushik. Oblivious query processing. In ICDT, pages 26–37. OpenProceedings.org, 2014.
6. S. Bajaj and R. Sion. Correctdb: SQL engine with practical query authentication. PVLDB, 6(7):529–540, 2013.
7. E. Boyle, N. Gilboa, and Y. Ishai. Function secret sharing. In EUROCRYPT (2), volume 9057 of Lecture Notes in Computer

Science, pages 337–367. Springer, 2015.

8. B. Chor, E. Kushilevitz, O. Goldreich, and M. Sudan. Private information retrieval. J. ACM, 45(6):965–981, 1998.
9. V. Ciriani, S. D. C. di Vimercati, S. Foresti, S. Jajodia, S. Paraboschi, and P. Samarati. Fragmentation and encryption to enforce
privacy in data storage. In Computer Security - ESORICS 2007, 12th European Symposium On Research In Computer Security,
Dresden, Germany, September 24-26, 2007, Proceedings, pages 171–186, 2007.

10. V. Ciriani, S. D. C. di Vimercati, S. Foresti, S. Jajodia, S. Paraboschi, and P. Samarati. Keep a few: Outsourcing data while
In Computer Security - ESORICS 2009, 14th European Symposium on Research in Computer

maintaining conﬁdentiality.
Security, Saint-Malo, France, September 21-23, 2009. Proceedings, pages 440–455, 2009.

11. V. Ciriani, S. D. C. di Vimercati, S. Foresti, S. Jajodia, S. Paraboschi, and P. Samarati. Combining fragmentation and encryption

to protect privacy in data storage. ACM Trans. Inf. Syst. Secur., 13(3):22:1–22:33, 2010.

22

0.00.20.40.60.80.00.20.40.60.81.0150K1.5M4.5M12. V. Costan and S. Devadas. Intel SGX explained. IACR Cryptology ePrint Archive, 2016:86, 2016.
13. R. Curtmola, J. A. Garay, S. Kamara, and R. Ostrovsky. Searchable symmetric encryption: Improved deﬁnitions and efﬁcient

constructions. Journal of Computer Security, 19(5):895–934, 2011.

14. P. Derbeko, S. Dolev, E. Gudes, and S. Sharma. Security and privacy aspects in mapreduce on clouds: A survey. Computer

Science Review, 20:1–28, 2016.

15. S. D. C. di Vimercati, R. F. Erbacher, S. Foresti, S. Jajodia, G. Livraga, and P. Samarati. Encryption and fragmentation for data
conﬁdentiality in the cloud. In Foundations of Security Analysis and Design VII - FOSAD 2012/2013 Tutorial Lectures, pages
212–243, 2013.

16. S. D. C. di Vimercati, S. Foresti, S. Jajodia, G. Livraga, S. Paraboschi, and P. Samarati. Fragmentation in presence of data

dependencies. IEEE Trans. Dependable Sec. Comput., 11(6):510–523, 2014.

17. S. D. C. di Vimercati, S. Foresti, S. Jajodia, S. Paraboschi, and P. Samarati. Fragments and loose associations: Respecting

privacy in data publishing. PVLDB, 3(1):1370–1381, 2010.

18. S. Dolev, N. Gilboa, and X. Li. Accumulating automata and cascaded equations automata for communicationless information

theoretically secure multi-party computation: Extended abstract. In SCC@ASIACCS, pages 21–29. ACM, 2015.

19. S. Dolev, Y. Li, and S. Sharma. Private and secure secret shared MapReduce - (extended abstract). In DBSec, pages 151–160,

2016.

20. F. Emekc¸i, A. Metwally, D. Agrawal, and A. El Abbadi. Dividing secrets to secure data outsourcing. Inf. Sci., 263:198–210,

2014.

21. C. Gentry. A fully homomorphic encryption scheme. PhD thesis, Stanford University, 2009.
22. N. Gilboa and Y. Ishai. Distributed point functions and their applications. In EUROCRYPT, volume 8441 of Lecture Notes in

Computer Science, pages 640–658. Springer, 2014.

23. O. Goldreich. Towards a theory of software protection and simulation by oblivious RAMs. In STOC, pages 182–194. ACM,

1987.

24. O. Goldreich. The Foundations of Cryptography - Volume 2, Basic Applications. Cambridge University Press, 2004.
25. H. Hacig¨um¨us, B. R. Iyer, C. Li, and S. Mehrotra. Executing SQL over encrypted data in the database-service-provider model.

In SIGMOD Conference, pages 216–227. ACM, 2002.

26. H. Hacig¨um¨us, S. Mehrotra, and B. R. Iyer. Providing database as a service. In ICDE, pages 29–38. IEEE Computer Society,

2002.

27. Y. Ishai, E. Kushilevitz, S. Lu, and R. Ostrovsky. Private large-scale databases with distributed searchable symmetric

encryption. In CT-RSA, volume 9610 of Lecture Notes in Computer Science, pages 90–107. Springer, 2016.

28. G. Kellaris, G. Kollios, K. Nissim, and A. O’Neill. Generic attacks on secure outsourced databases. In Proceedings of the 2016
ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, October 24-28, 2016, pages 1329–1340,
2016.

29. S. Y. Ko, K. Jeon, and R. Morales. The HybrEx model for conﬁdentiality and privacy in cloud computing. In 3rd USENIX

Workshop on Hot Topics in Cloud Computing, HotCloud’11, Portland, OR, USA, June 14-15, 2011, 2011.

30. I. Komargodski and M. Zhandry. Cutting-edge cryptography through the lens of secret sharing. In TCC, pages 449–479, 2016.
31. L. Li, M. Militzer, and A. Datta. rPIR: Ramp secret sharing based communication efﬁcient private information retrieval. IACR

Cryptology ePrint Archive, 2014:44, 2014.

32. Y. Li, S. Mehrotra, N. Panwar, S. Sharma, and S. Almanee. OBSCURE: Information-theoretic oblivious and veriﬁable
aggregation queries. Technical report, Department of Computer Science, University of California, Irvine, 2018. http:
//isg.ics.uci.edu/pubs/tr/Obscure.pdf.

33. W. Lueks and I. Goldberg. Sublinear scaling for multi-client private information retrieval. In Financial Cryptography and
Data Security - 19th International Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015, Revised Selected Papers,
pages 168–186, 2015.

34. S. Mehrotra, S. Sharma, J. D. Ullman, and A. Mishra. Partitioned data security on outsourced sensitive and non-sensitive
data. In ICDE, 2019. Also availale as a technical report at Department of Computer Science, University of California, Irvine,
http://isg.ics.uci.edu/publications.html.

35. M. Naor and B. Pinkas. Oblivious polynomial evaluation. SIAM J. Comput., 35(5):1254–1281, 2006.
36. M. Naveed, S. Kamara, and C. V. Wright. Inference attacks on property-preserving encrypted databases. In Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications Security, Denver, CO, USA, October 12-6, 2015, pages
644–655, 2015.

37. K. Y. Oktay, M. Kantarcioglu, and S. Mehrotra. Secure and efﬁcient query processing over hybrid clouds. In ICDE, pages

733–744. IEEE Computer Society, 2017.

38. K. Y. Oktay, S. Mehrotra, V. Khadilkar, and M. Kantarcioglu. SEMROD: secure and efﬁcient MapReduce over hybrid clouds.
In Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data, Melbourne, Victoria, Australia,
May 31 - June 4, 2015, pages 153–166, 2015.

23

39. R. A. Popa, C. M. S. Redﬁeld, N. Zeldovich, and H. Balakrishnan. Cryptdb: protecting conﬁdentiality with encrypted query

processing. In SOSP, pages 85–100. ACM, 2011.

40. M. O. Rabin. How to exchange secrets with oblivious transfer. IACR Cryptology ePrint Archive, 2005:187, 2005.
41. A. Shamir. How to share a secret. Commun. ACM, 22(11):612–613, 1979.
42. D. X. Song, D. A. Wagner, and A. Perrig. Practical techniques for searches on encrypted data. In IEEE Symposium on Security

and Privacy, pages 44–55. IEEE Computer Society, 2000.

43. S. Wang, X. Ding, R. H. Deng, and F. Bao. Private information retrieval using trusted hardware. IACR Cryptology ePrint

Archive, 2006:208, 2006.

44. C. Zhang, E. Chang, and R. H. C. Yap. Tagged-MapReduce: A general framework for secure computing with mixed-sensitivity
data on hybrid clouds. In 14th IEEE/ACM International Symposium on Cluster, Cloud and Grid Computing, CCGrid 2014,
Chicago, IL, USA, May 26-29, 2014, pages 31–40, 2014.

45. K. Zhang, X. Zhou, Y. Chen, X. Wang, and Y. Ruan. Sedic: privacy-aware data intensive computing on hybrid clouds. In
Proceedings of the 18th ACM Conference on Computer and Communications Security, CCS 2011, Chicago, Illinois, USA,
October 17-21, 2011, pages 515–526, 2011.

46. W. Zheng, A. Dave, J. G. Beekman, R. A. Popa, J. E. Gonzalez, and I. Stoica. Opaque: An oblivious and encrypted distributed

analytics platform. In NSDI, pages 283–298. USENIX Association, 2017.

24

