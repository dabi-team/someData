9
1
0
2

r
p
A
5
2

]

Y
S
.
s
c
[

1
v
7
9
5
1
1
.
4
0
9
1
:
v
i
X
r
a

A New Cyber-Secure Countermeasure for LTI systems under DoS attacks

Nilanjan Roy Chowdhury, Nandini Negi, Aranya Chakrabortty
Department of Electrical and Computer Engineering, North Carolina State University, USA
Email: nilanjan2008@gmail.com, nnegi@ncsu.edu, achakra2@ncsu.edu

Abstract

This paper presents a new counter-measure to mitigate denial-of-service cyber-attacks in linear time-invariant
(LTI) systems. We ﬁrst design a sparse linear quadratic regulator (LQR) optimal controller for a given LTI plant and
evaluate the priority of the feedback communication links in terms of the loss of closed-loop performance when the
corresponding block of the feedback gain matrix is removed. An attacker may know about this priority ordering,
and thereby attack the links with the highest priority. To prevent this, we present a message rerouting strategy by
which the states that are scheduled to be transmitted through the high priority links can be rerouted through lower
priority ones in case the former get attacked. Since the attacked link is not available for service, and the states of the
low priority links can no longer be accommodated either, we run a structured H2 control algorithm to determine the
post-attack optimal feedback gains. We illustrate various aspects of the proposed algorithms by simulations.

I. Introduction
Security of cyber-physical systems has drawn a signiﬁcant research attention in recent times. Due to notable
instances of cyber-attacks such as WannaCry [1], NotPetya [2], and Ukranian blackout [3], there have been increased
interests to design countermeasures to mitigate attacks for cyber-physical systems. A signiﬁcant part of the existing
work focuses on centralized systems (see e.g., [4], [5]) while the recent results in [6], [7] rely on distributed
algorithms. Prompted by these considerations, this paper presents a novel sparse optimization based countermeasure
to alleviate cyber-attacks for a general class of LTI systems.

System theoretic approaches to tackle a class of cyber-attacks namely Denial of Service (DoS in short) have
recently been investigated in [8, 9, 10]. Given a LTI system, [8] presents a novel analysis methodology to maintain
the closed loop stability under DoS attacks, while [9] unveils a similar analysis for its nonlinear counterpart. Given
a class of complex networks, [10] analyzes the consensus property of self-triggered agents in the presence of DoS
attacks. The analysis documented in [10] introduces the notion of persistence-of-communication and characterizes
DoS frequency and duration to attain consensus under DoS attacks.

Substantial studies have been undertaken on the analysis of consensus/ synchronization behavior under DoS
attacks, see, for example [11, 12, 13] and the references therein. In the context of multi-agent systems, a group
of agents is said to reach consensus/ synchronization when all individuals converge towards a common value
(consensus) / state (synchronization). Consensus analysis over unreliable networks has been motivated by the seminal
contribution from [11], in which, the authors consider a linear consensus model in the presence of misbehaving
agents whose behavior diverge from the nominal consensus evolution. Given a complex network having misbehaving
agents, [11] illustrates the problem of ensuring consensus under non-colluding and Byzantine attacks. Given a class
of general LTI systems, consensus under DoS attacks is analyzed for undirected [12] and directed [13] topology.
The results in [12, 13] hypothesize suﬃcient conditions to ensure asymptotic consensus and also characterize the
frequency and the duration of the DoS interval. However, the above analysis primarily relies on static graphs
illustrating an idealistic setup.

Recently game-theoretic results are employed in conjunction with distributed optimization to tackle the security
problems for large-scale cyber-physical networks. In the game-theoretic setup, the notion of interdependent security
games has recently been explored to compute optimal and strategic security investments by multiple defenders, for
example see [14, 15]. In [14, 15], the authors consider each defender is responsible for the security of multiple
assets, in which the inter-dependencies among the assets captured by an interdependency graph. The authors
redesign the problem of computing the optimal defense allocation by a single defender as a convex optimization
problem and establish the existence of a pure Nash equilibrium of the game between multiple defenders. Given a
networked control system, [16] investigates a slightly diﬀerent problem, where the authors reformulate a general-
sum, two-player, mixed strategy game between an attacker and a defender. The authors of [16] exploit the nonlinear
programming paradigm to analyze the dependence of a Mixed Strategy Nash Equilibrium on the relative budgets
of the players and preserve important network nodes to attain a desirable LQR performance.

Summary of Contributions: In light of the aforementioned works, in this paper we present a new appoach for
mitigating DoS attacks by using ideas from sparse optimal control. Given a LTI system deﬁned over a network of

 
 
 
 
 
 
N ≥ 2 nodes, we ﬁrst design a sparse linear quadratic regulator (LQR) optimal controller using l1-sparsity promotion
techniques, proposed in [17]. The LQR control law is given as u(t) = K x(t). The non-zero blocks Ki j of the sparse
matrix K indicate the existence of communication links between nodes i and j, carrying state xi(t) to controller
u j(t). We carry out an oﬄine analysis to evaluate the priority of these feedback communication links in terms of
how much loss is incurred in the closed-loop LQR objective function when any block Ki j is removed. We assume
that an attacker may also know about this priority ordering, and thereby is most likely to attack the links with
highest priority so that he/she can cause maximum damage to the closed-loop response. To prevent this, we present
a message rerouting strategy by which the states that are scheduled to be transmitted through the high priority links
can now be quickly rerouted through lower priority ones in case the former becomes dysfunctional from a DoS
attack. We present algorithms that capture various practical issues related to the size of the rerouted state vector
versus the volume of the low-priority link. One must note that following the re-routing, the attacked link is not
available for service, and the states of the low priority links can no longer be accommodated for communication
either. Thus, retaining the same control gains for the rest of the states may result in a severely sub-optimal closed-
loop performance. We, therefore, ﬁnally run a structured H2 control algorithm, proposed in [18] to determine the
post-attack optimal feedback gains. We illustrate various aspects of the proposed algorithms by simulations.

The rest of the paper is organized as follows: In Section II we formulate the problem, while in Section III we
document a preparatory note on the sparsity promoting optimal control problem. We present our proposed rerouting
algorithm in Section IV. Finally in Section V we provide an academic example to verify our contribution.

Notation: We denote the set of real and natural numbers by R and N respectively. 1 is a matrix with all its
entries equal to one, while Ik symbolizes the identity matrix of dimension k. 0pq denotes a zero matrix of dimension
p × q. Given a matrix M ∈ Rp×q, ||M||F deﬁnes the ‘Frobenius norm’ of M, and M( j, :) ∈ R1×q presents the jth row
of M, with j ∈ {1, 2, · · · , p}. For a square matrix N ∈ Rp×p, trace(N) is calculated as trace(N) := (cid:80)p
i=1 nii. Given
two matrices A ∈ Rp×q and B ∈ Rr×s, A ⊗ B ∈ Rpr×qs deﬁnes their kronecker product. Similarly, for two matrices
C, D ∈ Rm×n, the standard hadamard product is calculated as C ◦ D ∈ Rm×n.

Let us consider the continuous-time LTI system as

II. Problem Setup

˙x(t) = Ax(t) + Bu(t) + Wd(t),
y(t) = Cx(t) + Du(t),

x(0) = x0,

(1)

where x(t) = (cid:104)
(cid:105)(cid:62)
∈ Rn is the overall state vector, with x j(t) ∈ Rn j×1 is the state corresponding to node
1 (t), · · · , x(cid:62)
x(cid:62)
N(t)
j=1 n j, u(t) = (cid:104)
j ∈ {1, 2, · · · , N}, and n = (cid:80)N
∈ Rm is the overall control input with u j(t) ∈ Rm j×1 is
the control input of node j, and m = (cid:80)N
j=1 m j, d(t) ∈ Rq is the disturbance, and y(t) ∈ Rp is the system output. All
the matrices documented above i.e., A ∈ Rn×n, B ∈ Rn×m and W ∈ Rn×q are with appropriate dimensions. In addition,
the matrices C ∈ Rp×n and D ∈ Rp×m are deﬁned as C := (cid:104)
, where Q = Q(cid:62) ≥ 0 and
R = R(cid:62) > 0 are the state and the control performance weights. We assume, the matrix pair (A, B) is stabilizable
and (A, Q1/2) is detectable.

1 (t), · · · , u(cid:62)
u(cid:62)

and D := (cid:104)

0 R1/2(cid:105)(cid:62)

(cid:105)(cid:62)
0

Q1/2

N(t)

(cid:105)(cid:62)

We consider a state feedback control input

u(t) = K x(t),

where K ∈ Rm×n is the feedback gain matrix. In the vector form, (2) can be expressed as





u1(t)
u2(t)
...
uN(t)





=





K11 K12
K21 K22
...
...
KN1 KN2

· · · K1N
· · · K2N
...
. . .
· · · KNN













x1(t)
x2(t)
...
xN(t)

,

(2)

(3)

where the sub-matrix Ki j ∈ Rmi×n j represents a communication link that delivers a block of information of state
j ∈ {1, · · · , N} to control i ∈ {1, · · · , N}. For simplicity, for i = j, the feedback links are referred to as local links,
while for i (cid:44) j as communication links.

Notice that, given a LTI system (1), an optimal gain K ∈ Rm×n can be designed employing the LQR strategy [19].
When K is optimal, every Ki j and Kii, in general, are non-zero sub-matrices, implying that the communication

network required for exchanging the states is a dense graph i.e., communication links from every state to every
control input. Such dense graphs can result in high communication costs. Therefore, to reduce the cost, we impose
an additional structural constraint Ω on the structure of K as follows [18]

minimize
K

J(K)

subject to K ∈ Ω,

where the cost function J(K) is deﬁned as




J(K) :=

trace (W (cid:62)P(K)W)
+∞

if K is stabilizing
otherwise.

The P(K) ∈ Rn×n matrix stated above, denotes the closed-loop observability Gramian and presented as

(cid:90) ∞

P(K) :=

e(A−BK)(cid:62)σ(Q + K(cid:62)RK)e(A−BK) σ dσ,

(4)

(5)

which is obtained by solving the Lyapunov equation

0

(A − BK)(cid:62)P + P (A − BK) = −(Q + K(cid:62)RK).
(6)
Given a system (1) and (2), let K1 ∈ Ω be the solution of (4), in which, a communication link K1i j ∈ Rmi×n j delivers
a block of information of state j to control i. We assume, during the closed loop operation, an attacker attacks either
a communication link or a local link of K1 to destabilize the system. For instance, killing a communication/ local
is zeroed out. Let K2 ∈ Rm×n be the
link say K∗
, containing r > 0, number of messages equivalently signiﬁes K∗
1i j
1i j
= 0i j. Therefore, after the attack, we focus on addressing the objective of:
post-attack feedback gain in which K∗
1i j

Problem 2.1: ﬁnding some communication space in K2 to reroute the attacked r messages. In particular, we need
to determine ‘r spots’ in the oﬀ-diagonal and the diagonal blocks of K2 such that the resultant closed loop system
is stable, and it minimizes the cost function J(K2).

III. Technical preliminaries
In the following, we brieﬂy review the sparsity promoting optimal control problem. The readers are encouraged

to see [17] for details and further references.

A. Sparsity-Promoting Optimal Control Problems

The optimization problem (4) solely relies on the structure of the communication graph. Hence, in the following,
we characterize the optimization setup, in which the sparsity of the feedback gain directly subsumed into the
objective function as

(7)
where, card : Rm×n → N is the cardinality function i.e., the number of nonzero elements of a matrix (denoted as
nnz (·)), and is deﬁned as:

minimize

J(K) + β card (K),

In addition, β ∈ [0, ∞) is a scalar gain, and a large value of β leads to a sparser K.

card (K) :=

N(cid:88)

i, j=1

nnz (Ki j).

(8)

Since the objective function (7) is non-convex due to the cardinality function, therefore it is typically replaced
by the weighted l1 norm of the optimization variables [17]. Given a feedback gain K ∈ Rm×n, the weighted l1 norm
is represented as

card (K) =

(cid:88)

Gi j ||Ki j||F,

(9)

where Gi j are the non-negative weights, deﬁned as Gi j
minimization problem (7) can further be approximated as

i, j

minimize

J(K) + β

where, J(K) is the square of the closed loop H2 norm and (cid:80)

i, j

:= 1/

(cid:17)
(cid:16)
||Ki j||F + ε

with 0 < ε (cid:28) 1. Therefore, the

(cid:88)

Gi j ||Ki j||F,

i, j
Gi j ||Ki j||F is the sparsity promoting penalty function.

(10)

IV. Proposed Rerouting Algorithm
Given a continuous-time system (1), this section presents a rerouting algorithm to mitigate the cyber-attacks for
LTI systems. Our strategy can typically be categorized in three steps : i) link prioritization ranking algorithm,
ii) rerouting algorithm, and iii) structured H2 algorithm.

Remark 4.1: As indicated earlier, we consider K in (2) to be partitioned into r1 non-zero block matrices. Each
block Ki j is associated with a communication link carrying state xi(t) from the ith node to controller u j(t) at the jth
node. When an attacker deactivates a link, the entire block Ki j is zeroed out. Let us assume the block Ki j contains
r number of messages. Hence, as deﬁned in Problem 2.1, we need “r spots” in the lower priority control channels
to reroute the attacked messages. Now, let us consider a scenario, in which, we do not have a lower priority control
channel to reroute the entire r messages. For instance, we assume the lower priority control channels can reroute
(cid:109)
(cid:108) r
only ˆr (< r) unit of information. Under this circumstance, we further partition the attacked r messages and use
ˆr
communication channels to reroute the entire message.
Step 1: Link prioritization ranking algorithm: Given a LTI system (1) with the feedback gain K ∈ Rm×n, this
step evaluates the priority of the feedback communication links Ki j. It typically carries out an oﬄine analysis
technique to evaluate the priority of the feedback communication links in terms of how much loss is incurred in the
closed-loop LQR objective function when any block Ki j is removed. We initialize a small value of β ∈ R denoted
as βinitial. It results a centralized LQR gain K = Kc ∈ Rm×n, and starts minimizing (10). As stated earlier, the
solution of (10) becomes sparser as β increases; hence we obtain diﬀerent footprints of the sparsity pattern of K
by varying β. Therefore, from these diﬀerent sparsity patterns of K, we accumulate the knowledge of the priority
of each control blocks. Following this, we construct a matrix Ninitial : Rm×n → Rr1×r2 in which the control blocks
are placed based on their priority. In the sequel, we denote r1 ∈ N as the total number of non-zero control blocks
present in K, while r2 ∈ N deﬁnes the ‘size’ of each block i.e. the amount of information stored in each block.

Algorithm 1 (Oﬄine) link prioritization ranking algorithm
1: Input data: A, B, W, Q, R from (1), and βinitial,
2: Output data: K and Ninitial(K),
3:
4: for j = β1 , β2 , β3 , · · · with, β1 < β2 < β3 < · · · do
5:

Initialize β1 = βinitial, No(·) = 0r1 r2 ,

Minimize (10) and obtain the total number of nonzero control blocks in K at β j,
Determine the control blocks which are vanished to sparsify K at β j w.r.t β j−1,
Assign the vanished control blocks in No(·), with the priority pertaining to β j,

6:
7:
8: end for
9: Return Ninitial(K) = No(·).

The functionality of Algorithm 1 is illustrated in Fig. 1.

Fig. 1: A pictorial representaion of Algorithm 1 with β1 < β2 < β3.

Remark 4.2: The link prioritization ranking algorithm stated above, is performed oﬄine, and it typically considers
the class of problems in which the attacked communication links do not vary with time. For instance, let us assume
S(t∗) is the set of communication channels which are attacked by the attacker at time t∗ ≥ 0, then the link
prioritization ranking algorithm considers S(t) = S(t∗) for all t ≥ t∗.

Step 2: Rerouting1 algorithm: Given a continuous-time LTI system (1) and (2), Step-1 generates Ninitial(K) ∈
Rr1×r2 accumulating all the non-zero control blocks of K ∈ Rm×n and assigns priority to each of them. In addition,
let q : Rr1×r2 → Rr1 be the priority vector, which hold the priority information of the control blocks stacked in
Ninitial(K). We assume the attacker knows Ninitial(K) and q(Ninitial(K)) ∈ Rr1 and based on this information, it attacks
communication links to destabilize the overall closed-loop system. Let pattack(·) ∈ Rr1 be the attack index, and it
contains information about the attacked control blocks/ communication links, in which, the jth row denoted as
pattack( j), deﬁned as:

pattack( j) :=



1

0

if Ninitial( j, :) is under attack,
if Ninitial( j, :) is not attacked.

To design a countermeasure, we assume the defender knows Ninitial(K), q(·) and pattack(·). In the following, we
present three variants of the rerouting algorithms described in Algorithm 2 − 4.

Let us remark, the ﬁrst rerouting algorithm given in Algorithm 2, based on the following assumption:

Assumption 4.1: All the sub-matrices Ki j of K, are with the same dimension.

Given a feedback gain matrix K, the above assumption illustrates that all the block matrices Ki j ∈ Rmi×n j are required
to construct K, having same dimension. Additionally, it also signiﬁes that all the state vectors in (1), having same
dimension, i.e., x j(·) ∈ Rn j where, n1 = n2 = · · · = n for all, j ∈ {1, 2, · · · , N}.

Algorithm 2 Rerouting algorithm: all the sub-matrices have same dimensions

1: Input data: Ninitial(K), q(·), and pattack(·),
2: Output data: Nﬁnal(K),
3:
4: Determine the attacked links from pattack(·) ∈ Rr1 and the corresponding priority of the attacked links are stored

Initialize Rr1×r2 (cid:51) N(·) := Ninitial(K),

in a∗(·) ∈ Rr3 , where r3 ≤ r1,

STOP. No attack has occurred.

5: Sort a∗(·) in descending order and denote as a1(·) ∈ Rr3 ,
6: if (r3 = 0) then
7:
8: else if (r3 > r1/2) then
9:
10: else
11:

STOP. Countermeasure can not be implemented.

for ( j = 1, 2, · · · , r3) do

if (pattack( j) = 1) & (a1( j) < q( j + 1)) then

12:
13:

14:
15:

Lower priority communication space is unavailable, discard the attacked control block information

by N(a1( j), :) = 01 r2 ,

else

Lower priority communication space is available, reroute high priority information by N( j, :) = 01 r2 ,

end if

end for

16:
17:
18: end if
19: Return Nﬁnal(K) = N(·).

We present the following example to demonstrate Algorithm 2:

Example 1: Consider a continuous-time LTI system (1) with (A, B) ∈ R8×8 × R8×4. Let K ∈ Ω1 be the solution

of (4). The structural constraint Ω1 ∈ R4×8 is given as

(cid:63) 0 (cid:63) (cid:63)
0 (cid:63) 0 (cid:63)
0
0 (cid:63) 0
(cid:63) (cid:63) 0 (cid:63)

Ω1 =







,

1In this work, the notion of rerouting signiﬁes to give up some lower priority communication links to sustain an attacked one.

where (cid:63) and 0 denote a nonzero and a zero matrices of dimension 1 × 2 respectively. Let K ∈ Ω1 be evaluated as
0
5
1
8

3
1
0
5

7
0
0
0

3
0
0
2

9
0
0
0

2
2
0
3

1
0
0
4

0
1
5
6

K =

(11)









.

Given a feedback gain K stated above, we employ algorithm 1 to evaluate the priorities of the non-zero blocks Ki j.
(cid:104)
(cid:105)
The priorities corresponding to the non-zero blocks Ki j are presented as q(·) = 1 (cid:55)→
2 4
,
(cid:105)
(cid:104)
(cid:105)
(cid:105)
, q(·) = 7 (cid:55)→
, q(·) = 5 (cid:55)→
q(·) = 3 (cid:55)→
1 2
1
,
q(·) = 9 (cid:55)→

(cid:105)
, q(·) = 2 (cid:55)→
1
(cid:105)
, q(·) = 8 (cid:55)→
2

, q(·) = 4 (cid:55)→
.

(cid:105)
, q(·) = 6 (cid:55)→
8

(cid:105)
(cid:104)
1 5
(cid:105)
(cid:104)
5 3

(cid:104)
3
(cid:104)
3

(cid:104)
7

(cid:104)
6

5

9

(cid:104)

We assume the attacker knows the priorities of the control blocks Ki j stated above, and it attacks the control
blocks corresponding to the priority level q(·) = 3, 7, 8. Then, employing Algorithm 2, we obtain the post-attack
(cid:105)
(cid:104)
(cid:105)
Nﬁnal(K) as q(·) = 1 (cid:55)→
, q(·) = 3 (cid:55)→
0
6 8
,
(cid:104)
(cid:105)
(cid:104)
q(·) = 6 (cid:55)→
1
7 9

(cid:105)
, q(·) = 2 (cid:55)→
(cid:105)
(cid:104)
, q(·) = 8 (cid:55)→
3

(cid:105)
, q(·) = 4 (cid:55)→
0
(cid:105)
(cid:104)
.2
3
5

0
(cid:105)
, q(·) = 9 (cid:55)→
2

0
, q(·) = 7 (cid:55)→

(cid:105)
, q(·) = 5 (cid:55)→
1

(cid:104)
0

(cid:104)
5

2

0

(cid:104)

(cid:104)

Notice that, the defender reroutes the attacked information with priority level q(·) = 8 and q(·) = 7 via the lower
priority control channels with priority q(·) = 1 and q(·) = 2 respectively (see Step 15 in Algorithm 2). Likewise,
an alternative communication link to redirect the attacked information of the control block with q(·) = 3 will be
the control block with q(·) = 4. However, the priority of the control block with q(·) = 4 is higher than the priority
of the control block with q(·) = 3. Hence the defender discards the information corresponding to q(·) = 3 (see
Step 13 in Algorithm 2); see Fig. 2 for an illustration.

Fig. 2: (a) Communication topology of the control gain K ∈ Ω1 given in (11), where (•) deﬁnes the links which are attacked,
(b) post-attack communication graph in which (•) denotes the links whose data safely rerouted through lower priority blocks.
The dotted line signiﬁes lower priority communication links which are sacriﬁced to reroute the attacked information. Here each
communication link carries 2 unit of information, while the priority of each link denoted as q(·), are speciﬁed over it.

It is noteworthy that Algorithm 2 is designed based on Assumption 4.1, which implies each control block
contains the same amount of information. In the subsequent algorithms, we relax Assumption 4.1 and consider a
more generalized setup, in which, each control block contains diﬀerent amount of information. Hence in the sequel,
we present two variants of the rerouting algorithms described in Algorithm 3 and 4, in which Algorithm 3 presents
a rerouting strategy for a single link attack, while Algorithm 4 elucidates multiple links attack.

Remark 4.3: As stated in Step 1, given an Ninitial(·) ∈ Rr1×r2 , r1 denotes the total number of the non-zero control
blocks present in the gain matrix K, while r2 deﬁnes the size of each block. However, Algorithm 3 and 4 consider
a K matrix, in which, each control blocks are with diﬀerent sizes. Let, ¯r1, ¯r2, · · · , ¯rn with n ∈ N, be the sizes of the
control blocks present in K, then in the sequel, we select r2 := max {¯r1, ¯r2, · · · , ¯rn}.

Subsequently in the Algorithm 3, rattack denotes the single link which is attacked.

2The null matrix

(cid:104)

0

(cid:105)

0

information.

represented as the dotted line in Fig. 2, signiﬁes the control blocks which are scariﬁed to reroute the attacked

Initialization Rr1×r2 (cid:51) N(·) := Ninitial(K),

Algorithm 3 Rerouting algorithm: non-zero control blocks of diﬀerent sizes with a single link attack
1: Input data: Ninitial(K), rattack,
2: Output data: Nﬁnal(K),
3:
4: Deﬁne s(·) ∈ Rr1 , contains the amount of information accumulated by each control block,
5: if (rattack = 1) then
6:
7: else
8:
9:

Set c2 = s(rattack) and c1 = 0,
Calculate the number of available (not attacked) communication spaces (denoted as c1 ∈ R) to reroute c2 ∈ R

Set N(rattack, :) = 01 r2,

attacked messages,

if (c1 < c2) then

Insuﬃcient lower priority communication spaces are available; set N(rattack, :) = 01 r2 ,

else

Set k = 0,
while (c2 > 0) do

Update k = k + 1 and reroute c2 information via low priority control channel N(k, :) = 01 r2 ,
Update c2 = c2 − s(k),

10:

11:
12:
13:
14:
15:
16:

end while

end if

17:
18:
19: end if
20: Return Nﬁnal(K) = N(·).

We present a variant of Algorithm 3 with multiple links attack, as follows:

Initialization see Step 3 of Algorithm 3.

Algorithm 4 Rerouting algorithm: non-zero control blocks with diﬀerent sizes with multiple links attack
1: Input data: Ninitial(K), pattack(·),
2: Output data: Nﬁnal(K),
3:
4: Set b1 = b2 = 0,
5: Calculate s(·) ∈ Rr1 given in Step 4 of Algorithm 3,
6: Calculate a∗(·) , a1(·) ∈ Rr3 given in Step 4 − 5 of Algorithm 2,
7: Determine the location of the attacked control block with the highest priority and denote as a∗(end) ∈ R,
8: Calculate the total number of attacked information (determined as b1 ∈ R) and the available communication

space to reroute the attacked b1 information (determined as b2 ∈ R) upto a∗(end),

end for

STOP. No attack has happened.

for ( j = 1 , · · · , r3) do
Set N( j, :) = 01 r2 ,

9: if (b1 = 0) then
10:
11: else if (b2 = 0) & (r3 < r1/2) then
12:
13:
14:
15: else if (b1 > b2) & (r3 ≥ r1/2) then
16:
17: else
18:
19:
20:
21:
22: end if
23: Return Nﬁnal(K) = N(·).

for ( j = 1 · · · r3) do

Set c2 = s(a1( j)) and c1 = 0,
Go to Step 8 − 19 of Algorithm 3,

end for

STOP. Countermeasure can not be designed.

Remark 4.4: Notice that, in the algorithmic setup given in Algorithm 3 and 4, we recall the class of gain matrices

K in which, each communication link (say Ki j) carries diﬀerent amounts of information corresponding to state xi(t)
from the ith node to controller u j(t) at the jth node. Under these circumstances, a single link attack describes a
scenario, where the attacker attacks only one communication link, while in a multiple links attack, the attacker kills
several (more than one) communication channels. However, Algorithm 4 is capable enough to tackle multiple links
attack problem; it can also be implemented for a single link attack case as well. In other words, Algorithm 3 is
considered a simpler version of Algorithm 4 and provides a much-needed foundation to design Algorithm 4.

Example 2: This example illustrates the functionality of Algorithm 4. We revisit the continuous time LTI system (1)
with (A, B) ∈ R14×14 × R14×4. Let K ∈ Ω2 be the solution of (4), where Ω2 is structured as

Ω2 =


(cid:63) (cid:63) 0
0
(cid:63) 0
(cid:63) 0

0
0 (cid:63) 0
0 (cid:63)
0
0







.

(12)

(cid:63) and (cid:63) denote non-zero control blocks having dimensions 1 × 2 and 1 × 4 respectively. In other words, it contains
2 and 4 unit of information. The feedback gain K is evaluated as

K =





2
0
1
3

1 3 7
0 0 0
5 0 0
5 0 0

5
0
0
0

8
0
0
0

0
3
0
0

0
1
0
0

0
3
0
0



0
6
0
0
(cid:104)
2
2

0
0
7
0

.



0
0
6
0

0
0
4
0

0
0
2
0
(cid:105)
, q(·) = 2 (cid:55)→
1
4
6

(cid:105)

5

(cid:104)
3

(cid:105)
8

1 3

(cid:104)
3 7

, q(·) = 5 (cid:55)→

The priority vector q(·) of the K matrix in (13) is given as q(·) = 1 (cid:55)→
, q(·) = 6 (cid:55)→
q(·) = 4 (cid:55)→
We assume the attacker attacks the control blocks pertaining to the priority of q(·) = 5. Then, exploiting Algorithm 4,
(cid:105)
(cid:105)
, q(·) = 2 (cid:55)→
we obtain post-attack Nﬁnal(K) as, q(·) = 1 (cid:55)→
, q(·) = 4 (cid:55)→
5
(cid:104)
2
3 7 5 8
Notice that, as stated in Remark 4.1, the attacked information with the priority level q(·) = 5 contains 4 unit of
information and the information is rerouted through the communication links with the priority level q(·) = 1 and
q(·) = 3 respectively (2 unit each). An equivalent pictorial representation is presented in Fig. 3.

(cid:104)
0
, q(·) = 6 (cid:55)→

(cid:105)
, q(·) = 3 (cid:55)→
0

, q(·) = 5 (cid:55)→

(cid:104)
3 1

0
(cid:104)
7

(cid:105)
.3

(cid:105)
6

(cid:104)
7

(cid:105)
.

3

3

4

0

6

6

(cid:104)

(cid:104)

(cid:105)

(cid:104)
1

(cid:105)
, q(·) = 3 (cid:55)→
5

(cid:105)
(cid:104)
3 5
,

(13)

Fig. 3: (a) Communication topology of K ∈ Ω2 given in (13), where (•) signiﬁes the attacked link, (b) post-attack communication
graph where (•) denotes the link whose data are safely rerouted through lower priority blocks. The dotted line denotes lower
priority communication links which are sacriﬁced to reroute the attacked information, while, the nomenclature stated above the
communication links e.g., s(·) and q(·), speciﬁes the amount of information communicated over that links and the priority of
the link respectively.

Remark 4.5: The rerouting algorithms proposed in Algorithm 2, 3 and 4, are general enough to tackle cyber-
attacks for any class of structured gain K ∈ Rm×n with large values of m, n ∈ N. However, we adhere to the smaller
dimensions of K in example 1 and 2 in order not to blur the message of our work.
Step 3: Structured H2 algorithm: The structured H2 algorithm collects the post-attack Nﬁnal(K) ∈ Rr1×r2 from
Step-2. Nﬁnal(K) contains the information corresponding to the zero and non-zero control blocks, and allows us

3The null matrix

(cid:104)
0

(cid:105)

0

dotted lines.

symbolizes the control blocks which are scariﬁed to reroute the attacked information. It is illustrated in Fig. 3 by

to construct the post-attack structural constraint Ω (say ˆΩ). Then our objective boils down to solve the following
optimization problem

minimize
K

J(K)

subject to K ◦ Ic
ˆΩ

= 0,

(14)

where Ic
ˆΩ

= 1 − I ˆΩ, and I ˆΩ is the structural identity of the subspace ˆΩ with its i jth entry as

[I ˆΩ]i j :=





1
0

if Ki j is a free variable
if Ki j = 0 is required.

The augmented Lagrangian for (14) is evaluated as

Lγ(K, Λ) = J(K) + trace(Λ(cid:62)(K ◦ Ic

ˆΩ)) + γ
2
F is introduced to locally convexify the Lagrangian. (see [18], [20] for the details). In (15) the

||K ◦ Ic

ˆΩ||2
F,

in which, γ
penalty weight γ is a positive scalar, while, Λ ∈ Rm×n is the Lagrange multiplier.

2 ||K ◦ Ic

ˆΩ||2

(15)

Algorithm 5 Structured H2 algorithm
1: Initialize Λ0 = 0, and γ0 > 0
2: for (i = 0, 1, · · · ) do
3:
4:

For ﬁxed Λi, minimize (15) with respect to unstructured K
Update Λi+1 = Λi + γ (K ◦ Ic
ˆΩ)
Update γi+1 = α γi with α > 1
until: the stopping criteria ||Ki ◦ Ic

ˆΩ|| < (cid:15)

5:
6:
7: end for

The optimization paradigm given in (14), always yields a post-attack stabilizing control gain K; see [17, Remark

3] for details.

Remark 4.6: It is noteworthy that Step 1 of our proposed algorithm is mainly carried out oﬄine, while Step 2
and 3 are performed online after an attack occurs in the network. Step 1 can be executed at any time before the
attack, and it doesn’t depend on the characteristics of the attack model.

V. Simulation Results
In this section, we present an academic example to illustrate the functionality of our proposed algorithm. We

revisit a coupled dynamical system with N = 10 sub-systems, as

˙xi(t) =

N(cid:88)

j=1

Ai j xi(t) + Bii ui(t) + Wii di(t), ∀i ∈ {1, · · · , N} ,

(16)

where, xi(t) ∈ R2 is the state vector of the ith sub-system, while di(t) ∈ R2, and ui(t) ∈ R are the corresponding
disturbance and the control input. The overall system dynamics evolves as

˙x(t) = Ax(t) + Bu(t) + Wd(t),

(17)

where the drift matrix A ∈ R20×20 is structured as


A =



A11
A12
A21
A22
...
...
AN1 AN2

· · · A1N
· · · A2N
...
. . .
· · · ANN





.

We consider A to be a random matrix, in which, all the eigenvalues lie in the open left half of the complex plane,
while the dominant eigenvalue is placed relatively close to the origin. In addition, we calculate the overall B ∈ R20×10
and W ∈ R20×20 given in (17), as

B = Bii ⊗ I10, D = Dii ⊗ I10, ∀i ∈ {1, 2, · · · , N}

where

Bii =

(cid:34)

(cid:35)
10
0

, Wii =

(cid:34)
0.5
0

(cid:35)

.

0
0.5

We select the design parameters as Q = I20 and R = 10I10 respectively. Given the system dynamics (17), we
consider the control law u(t) = K x(t), where K ∈ R10×20 is the feedback gain matrix. The gain matrix K is
designed based on the sparsity promoting algorithm (10). First, we start minimizing (10) for a small initial value
of β. We consider the block sparsity structure with the weighted sum of the Frobenius norm given in (9), as the
(cid:17)
(cid:16)
with ε = 10−3. As stated earlier, the small (initial)
||Ki j||F + ε
sparsity-promoting penalty function and set Gi j = 1/
value of β yields a centralized LQR gain Kc ∈ R10×20, depicted in Fig. 4 (a). Then, we perform an oﬄine analysis
based on Algorithm 1 to collect all the non-zero control blocks of K ∈ R10×20 and prioritize each of them. We do
the prioritization in terms of the loss of closed-loop performance when the corresponding block of the feedback
gain matrix is removed. We assume, an anonymous attacker has the knowledge of the priority of each control
blocks of K and attacks a set of communication links (denoted in red in Fig. 4 (a)) to yield a poor closed loop
response. Finally, an application of the re-routing algorithms evaluates the post-attack sparsity structure illustrated
in Fig. 4 (b).

Fig. 4: (a) The sparsity pattern of the centralized LQR gain Kc ∈ R10×20. The (•) denotes the attacked control blocks. The
square box denotes the amount of information accumulated by each control block. (b) illustrates the post-attack sparsity pattern
after applying the rerouting algorithm given in Section IV.

TABLE I: Comparison between the pre and post-attack J(K) values

J(K)
Fig 4
Fig. 5

Before attack
0.47
0.46

Immediate after attack
0.48
0.47

After reroute
0.475
0.467

Notice that, initially the centralized LQR gain K = Kc has 50 control blocks, where each control block carries
4 unit of information (placed inside the rectangle shown in Fig. 4 (a), (b)). The attacker attacks 22 control blocks
(denoted in red in Fig 4 (a)) which are successfully rerouted via rest of the 28 control blocks shown in 4 (b), as
expected.

Next, we simulate another numerical setup illustrated in Fig. 5 (a), (b). We assume the centralized LQR gain
Kc ∈ R10×20 partitioned into 100 control blocks, in which, each control block contains 2 unit of information.
Notice that, the attacker attacks 48 control blocks (denoted in red in Fig. 5 (a)). Then, by exploiting the rerouting

algorithm the attacked information are safely rerouted via remaining unaﬀected (Lower priority) 52 control blocks;
see Fig. 5 (b).

Fig. 5: (a) The sparsity pattern of the centralized LQR gains Kc ∈ R10×20. The (•) denotes the control blocks which are attacked
by the attacker. The square box signiﬁes amount of information carried by each control block. In (b), we illustrate the post-attack
sparsity pattern after applying rerouting algorithm given in Section IV.

In Table I, we present a comparative study of the J(K) values corresponding to both the simulations stated above.

Remark 5.1: Notice that, the ﬁgures presented above in particular, Fig. 4 (b), 5 (b), illustrate the post-attack
structural constraint, in which, we employ the structured H2 algorithm given in Algorithm 5, to evaluate the
post-attack feedback gains and its corresponding J(K) values. The post-attack (after rerouting) J(K) values are
documented in Table I, however, we exclude the post-attack feedback gain matrices due to the space limitation.

Remark 5.2: In Table I, it seems that not a lot of control performance is lost when the DoS attack is happening,
and also not a lot of performance is gained when the proposed countermeasure is applied to the attacked systems.
This is occurred due to the choice of the system matrix A given in Eq. (17). Notice that, A is a random matrix in
which each element lies between [0, 1]. A larger value of the system matrix also alter the control performances.
However, as stated earlier, we adhere to simple examples to validate our contributions.

VI. Concluding remarks
Given a continuous-time LTI system, this work highlights a new algorithmic strategy to alleviate cyber-attacks for
LTI systems. We assume the anonymous attacker has the information corresponding to the structured feedback gain
matrix and the priority of its control channels. Then based on the attack model, we develop a rerouting strategy, in
which, after an attack, the higher priority communication data are rerouted through lower priority control channels.
The priority of the control channels are assigned employing sparse optimization methods with sparsity promoting
penalty functions. The rerouting functions allow us to determine the post-attack structural constraint, in which an
application of the structured H2 algorithm evaluates the post-attack feedback gain. Future work involves analyzing
the complexity of the proposed algorithms.

References
[1] J. M. Ehrenfeld, “WannaCry, cybersecurity and health information technology: A time to act,” Journal of medical systems,

vol. 41, no. 7, p. 104, 2017.

[2] S. Y. A. Fayi, “What Petya/NotPetya ransomware is and what its remidiations are,” in Information Technology-New

Generations. Springer, 2018, pp. 93–100.

[3] G. Liang, S. R. Weller, J. Zhao, F. Luo, and Z. Y. Dong, “The 2015 ukraine blackout: Implications for false data injection

attacks,” IEEE Transactions on Power Systems, vol. 32, no. 4, pp. 3317–3318, 2017.

[4] Y. Shoukry and P. Tabuada, “Event-triggered state observers for sparse sensor noise/attacks,” IEEE Transactions on

Automatic Control, vol. 61, no. 8, pp. 2079–2091, 2016.

[5] F. Pasqualetti, F. D¨orﬂer, and F. Bullo, “Attack detection and identiﬁcation in cyber-physical systems,” IEEE Transactions

on Automatic Control, vol. 58, no. 11, pp. 2715–2729, 2013.

[6] Y. Chen, S. Kar, and J. M. Moura, “Resilient distributed estimation through adversary detection,” IEEE Transactions on

Signal Processing, 2018.

[7] ——, “Distributed estimation under sensor attacks,” arXiv preprint arXiv:1709.06156, 2017.
[8] C. De Persis and P. Tesi, “Resilient control under denial-of-service,” IFAC Proceedings Volumes, vol. 47, no. 3, pp. 134–139,

2014.

[9] ——, “On resilient control of nonlinear systems under denial-of-service,” in 53rd Annual Conference on Decision and

Control (CDC), 2014 IEEE.

IEEE, 2014, pp. 5254–5259.

[10] D. Senejohnny, P. Tesi, and C. De Persis, “Self-triggered coordination over a shared network under denial-of-service,” in

54th Annual Conference on Decision and Control (CDC), 2015 IEEE.

IEEE, 2015, pp. 3469–3474.

[11] F. Pasqualetti, A. Bicchi, and F. Bullo, “Consensus computation in unreliable networks: A system theoretic approach,”

IEEE Transactions on Automatic Control, vol. 57, no. 1, pp. 90–104, 2012.

[12] Z. Feng and G. Hu, “Distributed secure average consensus for linear multi-agent systems under dos attacks,” in 2017

American Control Conference (ACC).

IEEE, 2017, pp. 2261–2266.

[13] ——, “Distributed secure leader-following consensus of multi-agent systems under dos attacks and directed topology,” in

2017 IEEE International Conference on Information and Automation (ICIA).

IEEE, 2017, pp. 73–79.

[14] A. R. Hota, A. A. Clements, S. Sundaram, and S. Bagchi, “Optimal and game-theoretic deployment of security investments
Springer, 2016, pp.

in interdependent assets,” in International Conference on Decision and Game Theory for Security.
101–113.

[15] A. R. Hota and S. Sundaram, “Interdependent security games on networks under behavioral probability weighting,” IEEE

Transactions on Control of Network Systems, vol. 5, no. 1, pp. 262–273, 2018.

[16] P. Shukla, A. Chakrabortty, and A. Duel-Hallen, “A cyber-security investment game for networked control systems,” arXiv

preprint arXiv:1810.00232, 2018.

[17] F. Lin, M. Fardad, and M. R. Jovanovi´c, “Design of optimal sparse feedback gains via the alternating direction method of

multipliers,” IEEE Transactions on Automatic Control, vol. 58, no. 9, pp. 2426–2431, 2013.

[18] F. Lin, M. Fardad, and M. R. Jovanovic, “Augmented lagrangian approach to design of structured optimal state feedback

gains,” IEEE Transactions on Automatic Control, vol. 56, no. 12, pp. 2923–2929, 2011.

[19] K. Zhou, J. C. Doyle, K. Glover et al., Robust and optimal control. Prentice hall New Jersey, 1996, vol. 40.
[20] D. P. Bertsekas, Nonlinear programming. Athena scientiﬁc Belmont, 1999.

