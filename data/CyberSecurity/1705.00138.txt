Contego: An Adaptive Framework for Integrating
Security Tasks in Real-Time Systems

Monowar Hasan∗, Sibin Mohan∗, Rodolfo Pellizzoni† and Rakesh B. Bobba‡
∗Dept. of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL, USA
†Dept. of Electrical and Computer Engineering, University of Waterloo, Ontario, Canada
‡School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA
Email: {∗mhasan11, ∗sibin}@illinois.edu, †rodolfo.pellizzoni@uwaterloo.ca, ‡rakesh.bobba@oregonstate.edu

7
1
0
2

y
a
M
3
2

]

R
C
.
s
c
[

3
v
8
3
1
0
0
.
5
0
7
1
:
v
i
X
r
a

Abstract—Embedded real-time systems (RTS) are pervasive.
Many modern RTS are exposed to unknown security ﬂaws,
and threats to RTS are growing in both number and sophis-
tication. However, until recently, cyber-security considerations
were an afterthought in the design of such systems. Any security
mechanisms integrated into RTS must (a) co-exist with the real-
time tasks in the system and (b) operate without impacting the
timing and safety constraints of the control logic. We introduce
Contego, an approach to integrating security tasks into RTS
without affecting temporal requirements. Contego is speciﬁcally
designed for legacy systems, viz., the real-time control systems in
which major alterations of the system parameters for constituent
tasks is not always feasible. Contego combines the concept of
opportunistic execution with hierarchical scheduling to maintain
compatibility with legacy systems while still providing ﬂexibility
by allowing security tasks to operate in different modes. We also
deﬁne a metric to measure the effectiveness of such integration.
We evaluate Contego using synthetic workloads as well as with
an implementation on a realistic embedded platform (an open-
source ARM CPU running real-time Linux).

I. INTRODUCTION

Embedded real-time systems (RTS) are used to monitor and
control physical systems and processes in many domains, e.g.,
manned and unmanned vehicles including aircraft, spacecraft,
unmanned aerial vehicles (UAVs), submarines and self-driving
cars, critical infrastructures like the electric grid and process
control systems in industrial plants, to name just a few. They
rely on a variety of inputs for correct operation and have to
meet stringent safety and timing requirements. Failures in RTS
can have catastrophic consequences for the environment, the
system, and/or human safety [1], [2].

Traditionally, RTS were designed using proprietary proto-
cols, platforms and software and were not connected to the
rest of the world, i.e., they were air gapped. As a result
cyber-security was not a design priority in such systems.
However, the drive towards remote monitoring and control
facilitated by the growth of the Internet, the rise in the use
of commercial-off-the-shelf (COTS) components, standardized
communication protocols and the high value of these systems
to adversaries have been challenging the status quo. While
safety and fault-tolerance have long been important design
considerations in such systems, traditional fault-tolerance tech-
niques that were designed to counter and survive random or
accidental faults are not sufﬁcient to deal with cyber-attacks
orchestrated by an intelligent and capable adversary. A number

of high-proﬁle attacks on real systems, e.g., Stuxnet [3] and
attack demonstrations by researchers on automobiles [2], [4]
and medical devices [5] have shown that the threat is real.

it

Given the increasing cyber-security risks,

is essential
to have a layered defense and integrate resilience against
such attacks into the design of controllers and actuators
(i.e., embedded RTS). It is also critical to retroﬁt existing
controllers and actuators with protection, detection, survival
and recovery mechanisms. However, any security mechanisms
have to co-exist with real-time tasks in the system and have to
operate without impacting the timing and safety constraints
of the control logic. This creates an apparent tension be-
tween security requirements (e.g., having enough cycles for
effective monitoring and detection) and the timing and safety
requirements. For example, how often and how long should
a monitoring and detection task run to be effective but not
interfere with real-time control or other safety-critical tasks?
While this tension could potentially be addressed for newer
systems at design time, it is especially challenging in the
retroﬁtting of legacy systems for which the control tasks are
already in place and perhaps cannot be modiﬁed. Another
challenge is to ensure that an adversary cannot easily evade
such mechanisms. Further, the deterministic nature of task
schedules in RTS may provide attackers with known windows
of opportunity in which they can run undetected [6], [7].

In order to integrate security mechanisms into RTS, per-
formance criteria such as frequency of monitoring and re-
sponsiveness must be considered. For example, security tasks1
may need to be executed quite frequently to provide good
protection. If the interval between consecutive monitoring
events is too large, then an attacker may remain undetected
and cause harm to the system between two invocations of the
security task. In contrast, if the security tasks are executed
very frequently, it may impact the schedulability (i.e., timely
execution) of the real-time tasks [8]. In some circumstances a
security task may need to complete with less interference (e.g.,
better responsiveness) from higher-priority real-time tasks. As
an example, consider the scenario in which a security breach
is suspected and a security task may be required to perform
more ﬁne-grained checking instead of waiting for its next

1We use the terms security tasks, intrusion detection tasks and monitoring

tasks interchangeably throughout the paper.

1

 
 
 
 
 
 
execution slot. At the same time, the scheduling policy needs
to ensure that the system does not violate real-time constraints
for critical, high-priority control tasks.

Our focus in this work is on retroﬁtting security mechanisms
into legacy RTS, for which modiﬁcation of existing real-time
tasks’ parameters (such as run-times, period, task execution
order, etc.) is not always feasible. In contrast to existing mech-
anisms [9], [10], the proposed method does not require any
architectural modiﬁcations and hence is particularity suitable
for systems designed using COTS components. The framework
developed in this paper is based on our earlier work [11] in
which we proposed to incorporate monitoring and detection
mechanisms by implementing them as separate sporadic tasks
and executing them opportunistically, that is, with the lowest
priority so that real-time tasks are not affected. However, if
the security tasks always execute with lowest priority, they
suffer more interference (i.e., preemption from high-priority
real-time tasks) and the consequent longer detection time
(due to poor response time) will make the security mecha-
nisms less effective. In order to provide better responsiveness
and increase the effectiveness of monitoring and detection
mechanisms, we now propose a multi-mode framework called
Contego2. For the most part, Contego executes in a PASSIVE
mode with opportunistic execution of intrusion detection tasks
as before [11]. However, Contego will switch to an ACTIVE
mode of operation to perform additional checks as needed
(e.g., ﬁne-grained analysis, used as an example in Section
VI-B). This ACTIVE mode potentially executes with higher
priority, while ensuring the schedulability of real-time tasks.
Thus Contego subsumes the approach in our earlier work [11]
and provides faster detection.

The contributions of this paper can be summarized as

follows:

• We introduce Contego, an extensible framework to inte-

grate security tasks into legacy RTS (Section II).

• Contego allows the security tasks to execute with minimal
perturbation of the scheduling order of the real-time tasks
while guaranteeing their timing constraints (Sections IV–
V). The proposed method can adapt to changes due to
malicious activities by switching its mode of operation.
• We propose a metric to measure the security posture of
the system in terms of frequency of execution (Section
III).

• We evaluate the schedulability and security of the pro-
posed approach using a range of synthetic task sets and
a prototype implementation on an ARM-based develop-
ment board with real-time Linux (Section VI).

II. SECURITY AND SYSTEM MODEL

A. Attack Model

RTS face threats in various forms, depending on the system
and the goals of an adversary. For example, adversaries may
insert, eavesdrop on or modify messages exchanged by system

2A preliminary version [12] of this work was presented at a workshop

without published proceedings.

components, may manipulate the processing of sensor inputs
and actuator commands and/or could try to modify the control
ﬂow of the system [10]. Further, rather than try to crash the
system aggressively, an intruder in reconnaissance mode may
want to monitor the system behavior and gather information
for later use. For instance, an intruder may utilize side-
channels to monitor the system behavior and infer system
information (e.g., hardware/software architecture, user tasks
and thermal proﬁles, etc.) that may eventually help maximize
the impact of an attack [6]. While the class of attacks can
be broadened, for illustrative examples let us consider the
following adversarial capabilities:

i) Integrity violation: An adversary can get a foothold in the
system [6], [7]. For example, an adversary may insert a
malicious task that respects the real-time guarantees of the
system to avoid immediate detection, and/or compromise
one or more existing real-time tasks. Such a task can be
used to manipulate sensor inputs and actuator commands
for instance and/or modify system behavior in undesirable
ways.

ii) Denial of Service (DoS): The attacker may take control
of the real-time task(s) and perform system-level resource
(e.g., CPU, disk, memory, etc.) exhaustion. In particular,
when critical tasks are scheduled to run an advanced
attacker may capture I/O or network ports and perform
network-level attacks to tamper with the conﬁdentiality
and integrity (viz., safety) of the system.

Threats to communications are usually dealt with by inte-
grating cryptographic protection mechanisms. From an RTS
perspective this increases the execution time of existing real-
time tasks [13], [14]. Contego is different from earlier work in
which integration of security impacted the schedulability [15]–
[17], required modiﬁcation of the existing schedulers [13],
[14], or necessitated architectural modiﬁcations [9], [10]. In
this work, we focus on incorporating security mechanisms into
legacy systems in which added security tasks are not allowed
to violate the temporal requirements (in either the PASSIVE or
ACTIVE modes) and must have minimal impact on the schedule
of existing real-time tasks.

6= vi

Let us consider an RTS (say an avionics electronic control
unit) developed using a multi-vendor model [17], viz., its com-
ponents are manufactured and integrated by different vendors.
For example, tasks in the system component manufactured
by vendor vi are very sensitive and considered classiﬁed or
mission-critical (e.g., images captured by the camera on the
surveillance UAV). It may be undesirable for any vendor
to gain unintended information about sensitive
vj
contents, even if, say, vendor vj is trusted with control tasks for
controlling the RTS. Similarly, the control laws from vendor vj
may contain a proprietary algorithm and vendor vj may not
want other vendors to gain knowledge about the algorithm.
Protected communications and network monitoring/detection
mechanisms are necessary but insufﬁcient to deal with such
threats. Therefore, additional security tasks may need to be
added into the system to deal with such threats [8].

2

• No anomalous activity is found within a predeﬁned time

duration, say T AC; or

• The intrusion is detected and malicious entities are re-
moved (or an alarm triggered if human intervention is
required).

Although we allow the security tasks to execute with higher
priority than some of the real-time tasks in ACTIVE mode, the
proposed framework ensures that the timeliness constraints
(e.g., deadlines) for all of the real-time tasks are always
satisﬁed in both modes. By using this strategy, Contego not
only enables compatibility with legacy systems (e.g., in normal
situation real-time scheduling order is not perturbed), but also
provides ﬂexibility to promptly deal with anomalous behaviors
(i.e., the security tasks are promoted to higher priority so
that they can experience less preemption and achieve better
response times).

C. System Model

1) Real-Time Tasks: In this paper we consider the widely
used ﬁxed-priority sporadic task model [18]. Let us consider
a uniprocessor system consisting of m ﬁxed-priority sporadic
real-time tasks ΓR = {τ1, τ2, · · · , τm}. Each real-time task
τj ∈ ΓR is characterized by (Cj , Tj, Dj), where Cj is the
time (or period)
WCET, Tj
between successive releases and Dj is the relative deadline.
We assume that priorities are distinct and assigned according
to the rate monotonic (RM) [19] order.

is the minimum inter-arrival

The processor utilization of τj is deﬁned as Uj = Cj
.
Tj
Let hpR(τj ) and lpR(τj) denote the sets of real-time tasks
that have higher and lower priority than τj, respectively. We
assume that the real-time task-set ΓR is schedulable by a
ﬁxed-priority preemptive scheduling algorithm. Therefore, the
worst-case response time wi
is less than or equal to the
deadline Di and the following inequality is satisﬁed for all
tasks τj ∈ ΓR: wj ≤ Dj, where wj = wk+1
j is obtained
by the following recurrence relation [20]:

j = wk

w0

j = Cj , wk+1

j = Cj +

wk
j
Th '

Ch.

(1)

Xτh∈hpR(τj) &

wk
j
Th

(cid:25)

τh∈hpR(τj ) (cid:24)
P

In Eq. (1),

Ch is the worst-case interference

j for some k.

to τj due to preemption by the tasks with higher priority
than τj (e.g., hpR(τj)). The recurrence will have a solution if
wk+1

j = wk
2) Security Tasks: With a view of integrating security
into the system, let us add additional ﬁxed-priority security
tasks that will be executed in PASSIVE and ACTIVE modes.
We model PASSIVE and ACTIVE mode security tasks as
independent sporadic tasks. The PASSIVE and ACTIVE mode
tasks are denoted by the sets Γpa
S = {τ1, τ2, · · · , τnp } and
Γac
S = {τ1, τ2, · · · , τna}, respectively. We assume that se-
curity tasks in both modes follow RM priority order. Each
security task τi ∈ {Γpa
S ∪ Γac
S } is characterized by the
tuple (Ci, T des
is
i
the most desired period between successive releases (hence

, ωi), where Ci is the WCET, T des

, T max
i

i

Fig. 1. Contego: Flow of operations depicting the PASSIVE and ACTIVE
modes for the security tasks.

The security mechanisms could be protection, detection or
response mechanisms, depending on the system requirements.
For example, a sensor measurement correlation task may be
added to detect sensor manipulation, a change detection task
may be added to detect intrusions or additional state-cleansing
tasks [15]–[17] can be added to deal with stealthy adversaries
trying to glean sensitive information through side channels.

It is worth mentioning that the addition of such security
mechanisms may necessitate changes to the schedule of real-
time tasks [13]–[17]. In contrast, Contego aims to integrate
such security tasks without
impacting the timeliness con-
straints (i.e., schedulability) required for safe operation (in
both modes) and retaining the original schedule of real-time
tasks most of the time (e.g., in PASSIVE mode when security
tasks are executing opportunistically with lowest priority).
that rather than designing speciﬁc intrusion
We highlight
detection tasks that target speciﬁc attack behaviors, the generic
framework proposed in this work allows one to integrate a
given security mechanism (referred to as security tasks) into
the system without perturbing the system parameters (e.g.,
period of the real-time tasks, execution order, etc.).

B. Overview of Contego

As illustrated in Fig. 1, Contego improves the security
posture of the system (that contains a set of real-time tasks)
by integrating additional security tasks and allowing them to
execute in two different modes (viz., PASSIVE and ACTIVE).
If the system is deemed to be clean (i.e., not compromised),
security routines can execute opportunistically3 (e.g., when
other real-time tasks are not running). However if any anomaly
or unusual behavior is suspected, the security policy may
switch to ACTIVE mode (e.g., more ﬁne-grained checking
or response) and execute with higher priority for a limited
amount of time (since our goal is to ensure security with
minimum perturbation of the scheduling order of the real-
time tasks). The security routines may go back to normal
(e.g., PASSIVE) mode if:

3Which is also the default mode of operation.

3

i

i = 1
F des
is the desired execution frequency of a security
T des
i
routine) and T max
is the maximum allowable period beyond
which security checking by τi may not be effective. The
parameter ωi > 0 is a designer-provided weighting factor
that may reﬂect the criticality of the security task4 τi. Critical
security tasks would have larger ωi. The security tasks have
implicit deadlines, e.g., Di = Ti, ∀τi that implies security
tasks should complete before their next monitoring instance.
We do not make any speciﬁc assumptions about the security
tasks in different modes. For instance, both PASSIVE and
ACTIVE mode task-sets may contain completely different sets
of tasks (e.g., {Γpa
S } = ∅) or may contain (partially)
identical tasks with different parameters (e.g., period and/or
criticality requirements).

S ∩ Γac

In PASSIVE mode, security tasks are executed with lower
priority than the real-time tasks. Hence the security tasks do
not have any impact on real-time tasks and cannot perturb
the real-time scheduling order. In ACTIVE mode, we allow the
security tasks to execute with a priority higher than that of
certain low priority real-time tasks. This provides us with a
trade-off mechanism between security (e.g., responsiveness)
and system constraints (e.g., scheduling order of real-time
tasks). Since the task priorities are distinct,
there are m
priority-levels for real-time tasks (indexed from 0 to m − 1
where level 0 is the highest priority). Among the m priority-
levels, we assume that ACTIVE mode security tasks can execute
with a priority-level up to lS (0 < lS ≤ m), lS ∈ Z.

i

Although any period Ti within the range T des

i ≤ Ti ≤ T max
is acceptable for PASSIVE (e.g., τi ∈ Γpa
S ) and ACTIVE (e.g.,
τi ∈ Γac
S ) mode security tasks, the actual period Ti is not
known a priori. Furthermore, for ACTIVE mode security tasks
(e.g., τi ∈ Γac
S ), we need to ﬁnd out the suitable priority level
l ∈ [lS, m]. Therefore our goal is to ﬁnd the suitable period
(for both PASSIVE and ACTIVE mode security tasks) as well as
the priority-level (for ACTIVE mode security tasks) that achieve
the best trade-off between schedulability and defense against
security breaches without violating the real-time constraints.

III. PERIOD ADAPTATION

As already mentioned, one fundamental problem in integrat-
ing security tasks is to determine which security tasks will be
running when. This brings up the challenge of determining the
right periods (viz., the minimum inter-execution times) for the
security tasks. For instance, some critical security routines may
be required to execute more frequently than others. However,
if the period is too short (e.g., the security task repeats too
often) then it will use too much of the processor time and
eventually lower the overall system utilization. As a result, the
security mechanism itself might prove to be a hindrance to the
system and reduce the overall functionality or, worse, safety.
In contrast, if the period is too long, the security task may

4As an example, the default conﬁguration of Tripwire [21], an intrusion
detection system (IDS) for Linux that we use as case study in Section VI-B,
has different criticality levels (viz., weights), i.e., High (for scanning ﬁles that
are signiﬁcant points of vulnerability), Medium (for non-critical ﬁles that are
of signiﬁcant security impact) and so forth.

not always detect violations, since attacks could be launched
between two instances of the security task.

i

i

T des
i

= 1

One may wonder why we cannot assign the desired period
(e.g., Ti = T des
) in both PASSIVE and ACTIVE modes and
set the ACTIVE mode priority level as l = lS so that the
security tasks can always execute with the desired frequency
(i.e., F des
) and experience less interference (e.g.,
preemption) from real-time tasks. However, since our goal
is to integrate security mechanisms in legacy systems with
minimal5 or no perturbation, setting Ti = T des
in
either or both mode(s) may signiﬁcantly perturb the real-
time scheduling order. If the schedulability of the system
is not analyzed after the perturbation, some (or all) of the
real-time tasks may miss their deadlines and thus the main
safety requirements of the system will be threatened. The same
argument is also true for ACTIVE mode if we set l = lS
(or arbitrarily from the range [lS, m]) and do not perform
schedulability analysis carefully.

, ∀τi

i

Tightness of

the Monitoring: As mentioned earlier,

the
actual period as well as the priority-levels of the security
tasks are unknown and we need to adapt the periods within
acceptable ranges. We measure the security of the system
by means of achievable periodic monitoring. Let Ti be the
period of the security task τi ∈ {Γpa
S } that needs to
be determined. Our goal is to minimize the gap between the
achievable period Ti and the desired period T des
and therefore
we deﬁne the following metric:

S ∪ Γac

i

ηi =

T des
i
Ti

,

(2)

that denotes the tightness of the frequency of periodic monitor-
ing for the security task τi. Thus ηpa =
ωiηi and ηac =

τi∈Γpa
S
P

ωiηi denote the cumulative tightness of the achievable

τi∈Γac
S
periodic monitoring for PASSIVE and ACTIVE mode, respec-
P
tively. This monitoring frequency metric, provides for instance,
one way to trade-off security with schedulability. Recall that
if the interval between consecutive monitoring events is too
large, the adversary may remain undetected and harm the
system between two invocations of the security task. Again,
a very frequent execution of security tasks may impact the
schedulability of the real-time tasks. This metric η(·) will allow
us to execute the security routines with a frequency closer to
the desired one while respecting the temporal constraints of
the other real-time tasks.

A. Problem Overview

One may wonder why we cannot schedule the security tasks
in the same way that the existing real-time tasks are scheduled.
For instance, a simple approach to integrating security tasks in
PASSIVE mode without perturbing real-time scheduling order
is to execute security tasks at a lower priority than all real-
time tasks. Hence, the security routines will be executing only

5In ACTIVE mode Contego does not introduce any timing violations for the
real-time tasks, but their execution might be delayed due to interference from
high-priority security tasks (e.g., the tasks with priority-level l ∈ [lS, m]).

4

during slack times when no other higher-priority real-time
tasks are running. Likewise, in ACTIVE mode, security tasks
can be executed at a lower priority than more critical, high-
priority real-time tasks. Hence, the security tasks will only
be executing when other real-time tasks with priority-levels
higher than lS are not running.

When both real-time and security tasks follow RM priority
order, we can formulate a nonlinear optimization problem for
PASSIVE mode with the following constraints that maximizes
the cumulative tightness of the frequency of periodic monitor-
ing:

approach similar to one we proposed in earlier work6 [11].
Speciﬁcally, we had proposed to use a server [22] to execute
security tasks. Our security server is motivated by the needs
of hierarchical scheduling [23]. Under hierarchical scheduling,
the system is composed of a set of components (e.g., real-
time tasks and a security server, in our context) and each
of which comprises multiple tasks or subcomponents (e.g.,
security tasks). The server abstraction not only allows us to
provide better isolation between real-time and security tasks,
but also enables us to integrate additional security properties
(such as responsiveness) as we discuss in the following.

(P1)

Subject to:

max
Tpa

ηpa

Xτi∈Γpa

S

Ci
Ti

≤ (m + np)(2

1

m+np − 1) −

Tj

Ti ≥ max
τj ∈ΓR
i ≤ Ti ≤ T max
T des

i

∀τi ∈ Γpa
S
∀τi ∈ Γpa
S

Cj
Tj

τj ∈ΓR
X

(3a)

(3b)

(3c)

where Tpa = [T1, T2, · · · , Tnp]T is the optimization variable
for PASSIVE mode that needs to be determined. The constraint
in Eq. (3a) ensures that the utilization of the security tasks
are within the remaining RM utilization bound [19]. The RM
priority order for real-time and security tasks is ensured by the
constraints in Eq. (3b), while Eq. (3c) ensures the restrictions
on periodic monitoring.

Recall that in ACTIVE mode, we allow the security tasks
to execute when the real-time tasks with priority-levels higher
than lS are not running. Hence, to ensure the RM priority
order in ACTIVE mode, we need to modify the constraints in
Eq. (3b) as follows:

Ti ≥ max

τj ∈ΓRhp(lS )

Tj,

∀τi ∈ Γac
S

(4)

where ΓRhp(lS ) represents the set of real-time tasks that are
higher priority than level lS. In addition, the constraints in
Eq. (3a) and Eq. (3c) also need to be updated to consider AC-
TIVE mode task-sets (e.g., Γac
S ) and the number of active mode
security tasks (na). Thus for ACTIVE mode we can formulate
an optimization problem similar to that of P1 with the objec-
ηac, where Tac = [T1, T2, · · · , Tna]T is
tive function: max
Tac
the ACTIVE mode optimization variable.

1

n(2

lim
n→∞

One of the limitations of the above approach is that the
overall system utilization is limited by the RM bound which
has the theoretical upper bound of processor utilization only
n − 1) = ln 2 ≈ 69.31% [19], where n is the
about
total number of tasks under consideration. Further, the security
tasks’ periods need to satisfy the constraints in Eq. (3b) and
Eq. (4) (for PASSIVE and ACTIVE modes, respectively) to
follow RM priority order. In addition, instead of focusing only
on optimizing the periods of the security tasks, Contego aims
to provide a uniﬁed framework that can achieve other security
aspects (viz., responsiveness). Thus we follow an alternative

IV. THE SECURITY SERVER

The server [22] is an abstraction that provides execution
time to the security tasks according to a predeﬁned scheduling
algorithm. Our proposed security server is characterized by
the capacity Q and replenishment period P and works as
follows. The server is executed with lowest-priority in PASSIVE
mode. However, in ACTIVE mode, the server can switch to
any allowable priority-level7 within the range [lS, m]. If any
security task is activated at time t, then the server is activated
with capacity Q and the next replenishment time is set as t+P .
When the server is scheduled, it executes the security tasks
according to its own scheduling policy. In this work we assume
that the server schedules the security tasks using ﬁxed-priority
RM scheduling. When a security task executes, the current
available capacity is decremented accordingly. The server can
be preempted by the scheduler to service real-time tasks. When
the server is preempted, the currently available capacity is not
decremented. If the available capacity becomes zero and some
security task has not yet ﬁnished, then the server is suspended
until its next replenishment time (t′). At time t′, the server is
recharged to its full capacity Q, the next replenishment time
is set as t′ + P , and the server is executed again. When the
last security task has ﬁnished executing and there is no other
pending task in the server, the server will be suspended. Also,
the server will become inactive if there are no security tasks
ready to execute.

A. Reformulation of the Period Adaptation Problem using
Servers

When security tasks execute within the server, we need
to modify the constraints in the period adaption problem
considering the server parameters Q and P . In the following
we brieﬂy discuss how to customize the period adaptation
problem with the inclusion of the server.

Let us use U BS(Q,P ),Γ to denote the utilization bound
for the set of tasks Γ executing within the server. When
the smallest period of the task is greater than or equal to
3P − 2Q,
the upper bound
of the utilization factor for the security tasks is given by

it has been shown [24] that

6The approach we proposed in our earlier work [11] is analogous to the

PASSIVE mode of Contego.

7Calculation of the server priority-level is described in Section V.

5

U BS(Q,P ),Γ = n

tasks in the set Γ.



(cid:18)



3−

3−2

Q
P
Q
P (cid:19)

1
n

− 1

, where n is number of





Thus with the inclusion of the server in PASSIVE mode, we

can modify the constraints in Eqs. (3a) and (3b) as follows:

Ci
Ti

≤ np



3−

3−2

Qpa
P pa
Qpa
P pa !

1
np

− 1




Ti ≥ 3P pa − 2Qpa,

∀τi ∈ Γpa

S .

Xτi∈Γpa

S

(5a)

(5b)

Therefore, selection of the periods for security tasks in PAS-
SIVE mode is a nonlinear constrained optimization problem
that can be formulated as follows:

(P2) max

Tpa

ωi

T des
i
Ti

Xτi∈Γpa

S

, Subject to:

(5a), (5b), (3c).

where Qpa and P pa are the server capacity and replenishment
period in PASSIVE mode, respectively. The formulation of the
PASSIVE mode period adaptation problem presented above is
similar to that we proposed in earlier work [11].

Similarly, in ACTIVE mode, the period adaptation problem

can be reformulated as follows:

(P3)

Subject to:

ωi

T des
i
Ti

max
Tac

τi∈Γac
X
S

Ci
Ti

≤ na



3−

3−2

Qac
P ac
Qac
P ac !

1
na

− 1



(7a)

τi∈Γac
X
S

Ti ≥ 3P ac − 2Qac ∀τi ∈ Γac


S
∀τi ∈ Γac
i ≤ Ti ≤ T max
T des
S
where Qac and P ac are the server capacity and replenishment
period in ACTIVE mode, respectively.

(7b)

(7c)

i

B. Selection of the Server Parameters

The period adaptation problem illustrated in Section IV-A
is derived based on a given set of server parameters, e.g.,
(Q(·), P (·)). However, a fundamental problem is to ﬁnd a
suitable pair of server capacity Q(·) and replenishment period
P (·) that respects the real-time constraints of the tasks in the
system. Our approach to selecting the server parameters in
PASSIVE and ACTIVE mode is described below.

1) Parameter Selection in Passive Mode: Recall that in
PASSIVE mode, the server will execute with the lowest priority
to have compatibility with existing real-time tasks. Since the
security tasks execute within the server, we need to ensure the
following two constraints:

• The server is schedulable: that is the server’s capacity
and interference from higher priority real-time tasks are
less than the replenishment period; and

• The security tasks are schedulable: the minimum supply
by the server to the security tasks is greater than the
worst-case workload generated by the security tasks.

Note that since the server is running with lowest priority,
the real-time constraints (e.g., wj ≤ Dj, ∀τj ∈ ΓR) and the
task execution order are not affected in the PASSIVE mode.
Based on the above two constraints, we illustrate an approach
for determining the server parameters by formulating it as a
constraint optimization problem.

The security server is referred to as schedulable if the worst-
case response time of the server does not exceed its replenish-
ment period [22]. Thus, following an approach similar to ones
in earlier work [11], [25], the server schedulability constraint
can be represented as follows:

Qpa + ∆S pa ≤ P pa

(8)

where ∆S pa =

P pa
Th

+ 1

Ch is the worst-case

τh∈hpR(τSpa )
P

(cid:17)

(cid:16)
interference experienced by the server when preempted by the
higher priority real-time tasks. In the above equation, the set
of real-time tasks with higher priority than the server (i.e.,
hpR(τ pa

S ) = ΓR) is ﬁxed.

Let us use hppa

S (τi) to denote the set of PASSIVE mode
security tasks that are higher priority than τi ∈ Γpa
S . To ensure
schedulability of the security tasks, we can derive the minimum
supply of the server delivered to the security tasks by using the
periodic resource model from the literature [11], [23], [25].
In particular, the constraints on the server supply to ensure
schedulability of the security tasks [11] can be expressed as:

Qpa
P pa [Ti − (P pa − Qpa) − ∆S pa ] ≥ I pa

i

, ∀τi ∈ Γpa
S

(9)

where I pa

i = Ci +

Ti
Th

Ch is the worst-case

τh∈hppa
workload generated by the security task τi and hppa
P
S (τi) during
the time interval of Ti. This workload is a constant for a given
input.

S (τi)

l

m

Since we need to ensure maximal processor utilization for
the security tasks without violating the real-time constraints
of the system, we deﬁne the following objective function:
Qpa
P pa . With this objective function and the constraints
max
Qpa,P pa
in Eqs. (8)-(9), the PASSIVE mode server parameter selection
problem can be formulated as follows:

(P4)

Qpa
P pa ,
where server parameters Qpa and P pa are the optimization
variables.

max
Qpa,P pa

Subject to:

(8), (9)

2) Parameter Selection in Active Mode: In ACTIVE mode,
the security server is no longer the lowest priority task. Since
the server can execute with priority lS, there could be up to
m−lS low priority real-time tasks than that of the server. Thus
we need to ensure the schedulability of the real-time tasks that
are executing with a priority lower than the server. Hence, in
addition to the constraints described in Section IV-B1 (i.e.,
Eqs. (8)-(9)), we need to consider the following:

• The real-time tasks with lower priority than the server
are schedulable: that is, the interferences from the server

6

 
 
and other higher priority real-time tasks do not violate
the deadlines for these low-priority tasks.

mode), the schedulability of the real-time tasks is already
guaranteed by the analysis presented in Section IV-B.

We therefore deﬁne the following constraints to ensure the

schedulability of the low-priority real-time tasks:

Cj +

Xτh∈hpR(τj ) (cid:24)

Dj
Th (cid:25)

Ch +

(cid:18)

Dj
P ac + 1

Qac ≤ Dj,

(cid:19)
∀τj ∈ lpR(τ ac
S )

(11)

where

Dj
Th

Ch is the interference experienced by

τh∈hpR(τj )
P

l

m

(cid:16)

Dj
P ac + 1

Qac is the worst-
τj from other real-time tasks and
case interference caused to τj by the server in ACTIVE mode.
As illustrated in Section V, we iterate through the allowable
priority ranges (e.g., [lS, m]) to ﬁnd the server priority in
ACTIVE mode. Note that for a given priority-level, the set
of tasks lp(τ ac
S ) is predeﬁned. Thus the only variables for
the constraints in Eq. (11) are the server capacity Qac and
replenishment period P ac.

(cid:17)

Let us use hpac

S (τi) to denote the set of ACTIVE mode
security tasks that are higher priority than τi ∈ Γac
S . Just as
in P4 we can now formulate the ACTIVE mode parameter
selection problem as follows:

(P5)

Qac +

max
Qac,P ac
P ac
Th

Qac
P ac , Subject to: (11) and

+ 1

Ch ≤ P ac

(cid:19)

(12a)

Xτh∈hpR(τSac ) (cid:18)

Qac
P ac [Ti − (P ac − Qac) − ∆S ac ] ≥ I ac

i

∀τi ∈ Γac
S

(12b)

where the set of real-time tasks with higher priority than the
server (i.e., hpR(τ ac
S ) ⊂ ΓR) is a constant for a given priority-
level and I ac
Ch is the worst-case

i = Ci +

τh∈hpac
workload generated by the security task τi and hpac
P
S (τi). Note
that the schedulability of the higher priority real-time tasks
(e.g., ∀τj ∈ hpR(τ ac

S )) is already ensured by deﬁnition.

S (τi)

m

l

Ti
Th

Remark 1. The formulation of the period adaptation and
server parameter selection problems are nonlinear constraint
optimization problems and are nontrivial to solve in their
current form. However, these problems can be transformed into
a geometric programming (GP) [26] problem. In addition, it is
also possible to reformulate the non-convex GP representation
into equivalent convex form that can be solved using known
algorithms such as interior point [27, Ch. 11] method. For
details of this reformulation, we refer the readers to Appendix.

C. Discussion on Mode Switching

As mentioned earlier, by default, Contego operates in PAS-
SIVE mode. However, when a malicious activity is suspected,
a PASSIVE-to-ACTIVE mode change request will be issued.
Similarly, an ACTIVE-to-PASSIVE mode change request will be
placed if the system seems clean after ﬁne-grained checking,
or a malicious entity is found and removed. In steady-state
(e.g., when security tasks are executing in PASSIVE or ACTIVE

7

When Contego switches from PASSIVE mode to ACTIVE
mode, the schedulability of real-time tasks will not be affected.
The reason this that all the real-time tasks are higher priority
than the security tasks in PASSIVE mode and hence do not
suffer any additional interference from security tasks during
mode change. Therefore, the schedulability of real-time tasks
during PASSIVE-to-ACTIVE mode switching is already covered
by steady-state analysis (Section IV-B1).

During ACTIVE-to-PASSIVE mode switching, observe that
schedulability of the real-time tasks that have a priority higher
than the server (i.e., hpR(τ ac
S )) is not affected. When the mode
switch request is issued, the ACTIVE mode server (and the
security tasks) stop execution and the control is then switched
to the lowest priority PASSIVE mode server. Note that the
constraints in Eq. (11) that ensures the schedulability of the
low-priority real-time tasks already captures the worst-case
interference introduced by the server. Hence the server will
not impose any more interference (even if the mode switch is
performed in the middle of the execution of a busy interval) on
the low-priority real-time tasks than what we have calculated
in the steady-state analysis (Section IV-B2). Therefore if both
the PASSIVE and ACTIVE modes task-sets are schedulable, the
system will also be schedulable with mode changes.

V. ALGORITHM DEVELOPMENT

We develop a simple scheme to obtain the security task’s
period (for both PASSIVE and ACTIVE mode) and priority-level
(for ACTIVE mode). The overall algorithm, Algorithm 1, works
as follows.

To ﬁnd the PASSIVE mode parameters, we initialize the
security task’s period with the desired period and solve the
server parameter selection problem P4 (Lines 10–11). If there
exists a solution (e.g., the constraints are satisﬁed), we then
obtain the periods of the security tasks by solving P2 (Line
13). In the event that neither of these optimization problems
returns a solution, we report the task-set as unschedulable
(Line 20), since it is not possible to execute security tasks
opportunistically without violating real-time constraints.

To select ACTIVE mode parameters, the algorithm iterates
through each of the acceptable priority-levels [lS, m] and tries
to obtain the periods that maximize tightness for periodic
monitoring without violating the real-time constraints (Lines
26–36). If there exists a solution (e.g., constraints in P5
and P3 are mutually consistent), we store the solution in a
candidate list. The algorithm then ﬁnds the best priority-level
from the candidate solution sets that provides the maximum
tightness (Line 39). In the event that no candidate solutions are
found for any of the allowable priority ranges, the algorithm
reports the task-set as unschedulable.

If both the PASSIVE and ACTIVE mode tasks are schedulable,
then Algorithm 1 returns the corresponding periods and the
ACTIVE mode priority-level (Line 4). Otherwise, the system is
considered as unschedulable (Line 7) since it is not possible
to integrate security tasks with desired requirements. This

Algorithm 1 Feasibility Checking and Parameter Selection
Input: Set of real-time tasks, ΓR, PASSIVE and ACTIVE mode security tasks

Γpa
S and Γac

S , allowable priority ranges [lS, m]

Output: The tuple {l∗, Tpa, Qpa, P pa, Tac, Qac, P ac}, e.g., ACTIVE
mode server priority-level, ACTIVE and PASSIVE mode periods of the
security tasks and ACTIVE and PASSIVE mode server parameters if the
task-set is schedulable; Unschedulable otherwise

using
Γpa
S )

the
and

PASSIVE

1: Obtain

parameters

and ACTIVE mode
PASSIVEMODEPARAMSELECTION(ΓR,

/* return the parameters */
return {l∗, Tpa, Qpa, P pa, Tac, Qac, P ac}

functions
ACTIVEMODEPARAMSELECTION(ΓR, Γac
2: if Solution Found in BOTH Modes then
3:
4:
5: else
6:
7:
8: end if

/* not possible to integrate security tasks in the system */
return Unschedulable

S , lS )

9: function PASSIVEMODEPARAMSELECTION(ΓR, Γpa
S )
, ∀τi ∈ Γpa
Initialize PASSIVE mode period Ti := T des
10:
S
Solve P4 to obtain server parameters
11:
if SolutionFound then
12:
13:
14:
15:
16:

Solve P2 to obtain security periods
if SolutionFound then

/* return the parameters */
return Tpa, Qpa, P pa where Qpa, P pa and Tpa are the
solutions obtained by P4 and P2

i

else

end if

17:
18:
19:
20:
21:
22: end function

end if

/* unable to integrate PASSIVE mode security tasks */
return Unschedulable

23: function ACTIVEMODEPARAMSELECTION(ΓR, Γac
24:
25:

Schedulable := false
Initialize ACTIVE mode security task’s period T(l′)∀l′∈[lS ,m]
[T des
i
for each priority level l′ ∈ [lS , m] do
Solve P5 to obtain server parameters
if SolutionFound then

]T
∀τi∈Γac
S

S , lS )

:=

Solve P3 to obtain security periods
if SolutionFound then

/* store the parameters for priority level l′ where Q∗, P ∗
and T∗ are the solutions obtained by P5 and P3 */
Q(l′) := Q∗, P (l′) := P ∗, T(l′) := T∗
Schedulable := true

end if

end if

end for
/* obtain the parameters that provide best metric */
if Schedulable then

l∗

the

from the

priority-level

Find
T(l′)∀l′∈[lS ,m]| tasks at l′ is schedulable
cumulative tightness ηac = Pτi∈Γac
Set Tac := T(l∗), Qac := Q(l∗), P ac := P (l∗)
/* return the parameters */
return l∗, Tac, Qac, P ac

that gives
ηi

S

/* unable to integrate ACTIVE mode security tasks */
return Unschedulable

else

40:
41:
42:
43:
44:
45:
46:
47: end function

end if

solution

vector
the maximum

26:
27:
28:
29:
30:
31:

32:
33:
34:
35:
36:
37:
38:
39:

unschedulability result hints that the designers of the system
should update system parameters (e.g., the number of security
tasks, desired and maximum allowable periods of the security
tasks, periods of the real-time tasks, if permissible, etc.) in
order to integrate security mechanisms.

8

0.5

0.45

0.4

0.35

0.3

0.25

0.2

0.15

0.1

0.05

e
d
o
M
e
v
i
t
c
A

.
s
v
e
d
o
M
e
v
s
s
a
P

i

t

s
s
e
n
h
g
T
e
v
i
t

i

l

a
u
m
u
C
n

i

e
c
n
e
r
e

f
f
i

D

0

0

0.1

0.2

0.3

0.4
0.6
0.5
Total Utilization

0.7

0.8

0.9

1

Fig. 2. PASSIVE mode vs. ACTIVE mode: difference in cumulative tightness
of achievable periodic monitoring, ηav − ηpa. Non-zero difference indicates
that the ACTIVE mode tasks achieve better tightness than PASSIVE mode
tasks. Task-sets from different base-utilization groups are represented by
different colors. Each of the data points represents schedulable task-sets.

VI. EVALUATION

We evaluate Contego with randomly generated synthetic
workloads (Section VI-A) as well as a proof-of-concept im-
plementation on an ARM-based embedded development board
and real-time Linux (Section VI-B).

A. Experiment with Synthetic Task-sets

1) Simulation Setup: In order to generate task-sets with an
even distribution of tasks, we grouped the real-time and secu-
rity task-sets by base-utilization from [0.01+0.1·i, 0.1+0.1·i],
where i ∈ Z ∧ 0 ≤ i ≤ 9. Each utilization group contained
500 task-sets. In other words, a total of 5000 task-sets were
tested for each of the experiments. The utilization of the
real-time and security tasks were generated by the UUniFast
[28] algorithm and we used GGPLAB [29] to solve the
optimization problems.

We used the parameters similar to those used in ear-
lier research [11], [16]. In particular, each task-set instance
contained [3, 10] real-time and [2, 5] security tasks in each
of the modes. Each real-time task τj ∈ ΓR had a period
Tj ∈ [10 ms, 100 ms] and we assumed lS = ⌈0.4m⌉. The
desired periods for the security tasks ∀τi ∈ {Γpa
S } were
selected from [1000 ms, 3000 ms] and the maximum allowable
period was assumed to be T max
. We considered
ωi = 1, ∀τi ∈ {Γpa
S } and the total utilization of the
security tasks was assumed to be no more than 30% of the
real-time tasks.
2) Results:

= 10T des

S ∪ Γac

S ∪ Γac

i

i

a) Impact on Cumulative Tightness: In Fig. 2 one can
see the difference in the tightnesses of the periodic monitoring
obtained by PASSIVE and ACTIVE mode (i.e., ηac − ηpa). For
fair comparison we used the same task-sets for both modes.
The x-axis of Fig. 2 represents the total system utilization (e.g.,
utilization of both real-time and security tasks). The positive
values in the y-axis of Fig. 2 imply that the ACTIVE mode
tasks obtain better tightness that the PASSIVE mode tasks.

The ﬁgure shows that ACTIVE mode tasks can achieve better
cumulative tightness, and that the cumulative tightness ηpa is

 
 
 
 
 
 
 
1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

y
t
i
r
u
c
e
S

f

o

s
s
e
n
e
v
i
t
c
e

f
f

E

100

90

80

70

60

50

40

30

20

10

)

%

(

o

i
t

a
R
e
c
n
a
p
e
c
c
A

t

Active Mode
Passive Mode

0

0

0.1

0.2

0.3

0.4
0.6
0.5
Total Utilization

0.7

0.8

0.9

1

0
0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

Total Utilization

Fig. 3. The effectiveness of security vs. total utilization of the system.
The closer the y-axis values to 1, the nearer each security task’s period is
to the desired period. Task-sets from different base-utilization groups are
distinguished by different colors.

Fig. 4. Schedulability of real-time and security tasks in both modes. The
acceptance ratio is deﬁned by the ratio of the number of accepted task sets
over the total number of generated tasks. For each of the data points, 500
individual task-sets were tested.

comparatively better in low to medium utilization. The main
reason is that in ACTIVE mode security tasks are allowed to
execute with higher priority, that causes less interference and
eventually increases the feasible region in the optimization
problems (and hence provides better tightness). For higher
utilizations the difference is close to zero. This is because, as
utilization increases there is less slack in the system, making
it difﬁcult to schedule security tasks frequently and resulting
in similar levels of tightness for both modes.

b) Effectiveness of Security: The parameter η(·) is given
by the total number of security tasks and provides insights on
cumulative measures of security. However, in this experiment
(refer to Fig. 3) we wanted to measure the effectiveness of
the security of the system by observing whether each of the
security tasks in any mode can achieve an execution frequency
closer to the desired one. Hence we used the following metric:
ξ = 1 − kT∗
−Tdesk2
where T∗ is the solution obtained
kTmax−Tdesk2
from Algorithm 1, Tdes = [T des
]T
i
∀τi
are the desired and maximum period vector (refer to Section
VI-A1), respectively, and k·k2 denotes the Euclidean norm.
The closer the value of ξ to 1, the nearer each of the security
task’s period is to the desired period.

and Tmax = [T max

]T
∀τi

i

As the total utilization increases, the feasible set of the
period adaptation problem that respects all constraints in
the optimization problems becomes more restrictive. As a
result, we see the degradation in effectiveness (in terms of
ξ) for the task-sets with higher utilization. However, from our
experiments we ﬁnd that Contego can achieve periods that are
within 18% of the desired periods.

c) Impact on the Schedulability: We used the acceptance
ratio metric to evaluate schedulability. The acceptance ratio
(y-axis in Fig. 4) is deﬁned as the number of accepted task-
sets (e.g., the task-sets that satisﬁed all the constraints) over
the total number of generated ones. As depicted in Fig. 4 the
ACTIVE mode task-set achieves better schedulability compared
to the PASSIVE ones. Recall that ACTIVE mode task-sets can

9

be promoted up to priority level lS. As a result ACTIVE mode
security tasks potentially experience less interference than the
PASSIVE ones. This ﬂexibility gives the optimization routines
a larger feasibility region to satisfy all the constraints.

B. Experiment with Security Applications in an Embedded
Platform

To observe the performance of the proposed scheme in a
practical setup, we implemented Contego on an embedded
platform. Our experimental platform [30] was conﬁgured with
1 GHz ARM Cortex-A8 single-core processor and 512 MB
RAM. We used Linux as the operating system – that allowed
us to utilize the existing Linux-based IDSes (refer to Section
VI-B2) for the evaluation. Since the vanilla Linux kernel is
unsuitable for hard real-time scheduling, we enabled the real-
time capabilities with the Xenomai [31] 2.6.3 real-time patch
(kernel version 3.8.13-r72) on top of an embedded Debian
Linux console image.

We measured the WCET of the real-time and security
tasks using ARM cycle counter registers (e.g., CCNT), giving
us nanosecond-level precision. Since these registers are not
enabled by default, we developed a Linux kernel module to
access the registers from our application codes. Our prototype
implementation was developed in C and uses a ﬁxed-priority
scheduler powered by the Xenomai real-time patch. Sporadic
real-time and security tasks in the system were deﬁned by
Xenomai rt task create() function and were suspended
after the completion of corresponding instances using the
rt task wait period() function.

1) Real-time Tasks: For a real-time application, we consid-
ered a UAV control system (refer to Table I). We implemented
it using an open-source UAV model [32]. The original ap-
plication codes were based on the STM32F4 micro-controller
(ARM Cortex M4) and developed for FreeRTOS [33]. Because
of differences in library support and execution semantics, we
updated the source codes accordingly and ported them to
Linux.

 
 
 
 
TABLE I
REAL-TIME TASK PARAMETERS FOR THE UAV CONTROL SYSTEM

Task

Function

Guidance
Controller
Reconnaissance

Select the reference trajectory (i.e., altitude and heading)
Execute closed-loop control functions (e.g., actuator commands)
Read radar/camera data, collect sensitive information and send data to the base
control station

Period
(ms)
1000
5000
10000

100

80

60

40

20

e
d
o
M
e
v
s
s
a
P

i

)

%

(
d
a
o
L
U
P
C

0

0

50

100

150

200

250
Time (s)

300

350

400

450

500

100

80

60

40

20

e
d
o
M
e
v
i
t
c
A

)

%

(

d
a
o
L
U
P
C

0

0

50

100

150

200

250
Time (s)

300

350

400

450

500

Fig. 5. The CPU load when the security tasks executed in PASSIVE (top)
and ACTIVE (bottom) mode, respectively. The dotted line represents average
load over the observation duration (500 s).

2) Security Tasks: To integrate security in the aforesaid
control system, we included additional security tasks. For
the security tasks, we considered two lightweight open-source
intrusion detection mechanisms, (i) Tripwire [21], that detects
integrity violations by storing clean system state during initial-
ization and using it later to detect intrusions by comparing the
current system state against the stored clean values, and (ii)
Bro [34] that monitors anomalies in network trafﬁc. As Table
II shows, we consider several security tasks in both modes,
e.g., protecting security task’s own binary ﬁles, protecting
system binary and library ﬁles, monitoring network trafﬁc. In
each mode, we set the desired and maximum allowable periods
of the security tasks such that utilization of the security tasks
did not exceed 50% of the total system utilization.

3) Experience and Evaluation:

a) Performance Impact in Different Modes: In the ﬁrst
set of experiments, we measured the average CPU load when
the security tasks were executing in PASSIVE and ACTIVE
modes. For that, we executed the security tasks independently
for 500 s in PASSIVE and ACTIVE modes and observed the
CPU load using /proc/stat interface (represents the y-
axis of Fig. 5). As Fig. 5 shows, running security tasks in
ACTIVE mode increased the average CPU load compared to
running them in PASSIVE mode. This is because ACTIVE
mode contains more security tasks (e.g., 4 compared to 2,
refer to Table II) and they execute more frequently than in
PASSIVE mode. Because of the nature of applications, most
RTS prefer predictability over performance. The overhead of
running security tasks in ACTIVE mode comes with increased
security guarantees that will sufﬁce for many RTS.

b) Impact on Detection Time: To study the detection
performance we injected malicious code into the system that
mimics anomalous behaviors. We assumed that an attacker can
take over8 one of the low-priority real-time tasks (referred
to as the victim task) and is able to insert malicious code
that can execute with a privilege similar to that of legitimate
tasks. We launched the attack at both the network and host-
level. We deﬁned network-level DoS attacks as too many
rejected usernames and passwords submitted from a single
address and used a real FTP DoS trace [35] to demonstrate the
attack. Malware (such as LRK, tOrn, Adore, etc.) in general-
purpose Linux environments causes damage to the system
by modifying or overwriting the system binary [36, Ch. 5].
Thus we follow a similar approach to demonstrate a host-level
attack, viz., we injected ARM shellcode [37] to override the
victim task’s code and launched the attack by modifying the
contents in the ﬁle-system binary.

We obtained the periods of the security tasks in both
modes by solving the period adaptation problem (Algorithm
1) and set it as the period of security tasks (by using the
Xenomai rt task set periodic() function). For each of
the experiments, the work-ﬂow was as follows. We started
with a clean (e.g., uncompromised) system state, launched
the DoS attack at any random time of the program execution
and then injected the shellcode after a random interval, and
ﬁnally logged the time required by security tasks to detect the
attacks. Initially the security tasks ran in PASSIVE mode. When
the network-level attack was suspected by the security task
(e.g., Bro), a mode change request was placed and the control
was switched to ACTIVE mode with the corresponding ACTIVE
mode tasks (see Table II). As mentioned in Section II-B, our
focus is not on the effectiveness of a particular IDS here but
on the effectiveness of integration of the IDSes into RTS.
Therefore we controlled the experimental environment so that
the results were not affected by the false positive/negative rates
of the IDS used in the evaluation. In particular, both of the
launched attacks were detectable by the respective IDSes used
in the evaluation. Detection times were measured using ARM
cycle counter registers (CCNT). To ensure the accuracy of the
detection time measurements, we disabled all the frequency
scaling features in the kernel (by using the cpufrequtils
utility) and allowed the platform to execute with a constant
frequency (e.g., 1 GHz, the maximum frequency of our exper-

8One way to override a task could be to use an approach similar to one
presented in the literature [6] that exploits the deterministic behavior of the
real-time scheduling.

10

 
 
 
 
 
 
TABLE II
SECURITY TASKS USED IN THE EXPERIMENTS

Task
Check own binary of the security
routine (Tripwire)

Check critical executables (Tripwire)

Function
Scan ﬁles (viz., compare their hash value) in
the following locations: /usr/sbin/siggen,
/usr/sbin/tripwire, /usr/sbin/twadmin,
/usr/sbin/twprint, /usr/local/bro/bin
Scan ﬁle-system binary (/bin, /sbin)

Check critical libraries (Tripwire)
Monitor network trafﬁc (Bro)

Scan ﬁle-system library (/lib)
Scan predeﬁned network interface (en0)

Mode

ACTIVE

ACTIVE and
PASSIVE
ACTIVE
ACTIVE and
PASSIVE

1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

F
D
C

l

a
c
i
r
i
p
m
E

0

0

0.5

1

With Mode Change
Without Mode Change

1.5

2
Detection Time (Cycle Count)

2.5

3

3.5

4
×109

Fig. 6. The empirical distribution of time to detect the intrusions when mode
change was allowed vs when security tasks were run only in PASSIVE mode.
We used ARM cycle counter registers to measure the detection time. A total
of 50 individual experiment instances were examined to obtain the timing
traces.

imental platform).

We compared the performance of Contego with that of an
earlier approach [11] that has no provision for mode changes
and in which the security tasks are run with the lowest
priority (similar to the PASSIVE mode of operation in Contego).
Speciﬁcally, we measured the time to detect both the host
and network-level intrusions, and plot the empirical cumulative
distribution function (CDF) of those detection times in Fig. 6.
The x-axis in Fig. 6 represents the detection time (in cycle
count) and the y-axis represents the probability that the attack
would be detected by that time. The empirical CDF is deﬁned

α

as

Fα() = 1
α

I
[ζi≤], where α is the total number of

i=1
X

b

experimental observations, ζi is the time taken to detect the
attack in the i-th experimental observation, and  represents
the x-axis values (viz., the detection times in cycle count) in
Fig. 6. The indicator function I
[·] outputs 1 if the condition [·]
is satisﬁed and 0 otherwise.

From Fig. 6 we can see that Contego provides better
detection time (i.e., fewer cycle counts required to detect the
intrusions). From our experiments we ﬁnd that on average
Contego detects attacks 27.29% faster than the reference
scheme does. The approach from the literature [11] allows
the security tasks to run only when other real-time tasks are
not running, leading to more interference (e.g., higher response

11

times), and does not provide any mechanisms to adapt against
abnormal behaviors (e.g., the DoS attack in the experiments).
In contrast, Contego allows quick response to anomalies (by
switching to ACTIVE mode when a DoS attack is suspected).
Since ACTIVE security tasks can run with higher priority and
less interference without impacting the timeliness constraints
of real-time tasks, Contego had a superior detection rate in
general for most of the experiments without impacting safety.

VII. DISCUSSION

Although Contego provides an integrated approach to guar-
this framework can be
antee safety and security in RTS,
extended in several directions. In the following, we brieﬂy an-
alyze Contego against different threat models and discuss the
limitations of the current framework with possible directions
of improvement.

A. Threat Analysis

The security mechanism will collapse if the adversary can
compromise all the security tasks. To do so, the adversary
would need to intrude into the system, remain undetected and
monitor the schedule [6] (to override the security tasks) over a
long period of time. Guaranteeing the integrity of the security
tasks is an interesting research problem by itself and will
be investigated in our future work. While compromising all
the security tasks could be difﬁcult in practice, it nevertheless
would be worthwhile to harden the security posture of Contego
further by randomizing task schedules while guaranteeing the
safety of the real-time tasks by using approaches similar to
one recently proposed in the literature [7]. Randomizing the
schedule of real-time and security tasks reduces the determin-
ism (and thus the predictability of security tasks’ execution)
and further reduce the chance of information leakage. Ran-
domizing task schedules in RTS, unlike traditional systems,
is not straightforward since it leads to priority inversions [38]
that, in turn, cause missed deadlines, and hence, put the safety
of the system at risk. We intend to incorporate randomization
protocols on top of Contego in future work.

The underlying detection algorithms in security tasks could
raise false positive errors that may cause the system to
switch modes unnecessarily. Again, a clever adversary may
remain undetected and provide a fake indication of malicious
activity. This may cause Contego to frequently switch modes
thus reducing performance and availability. Although Contego

 
guarantees that the system will remain schedulable (and hence
safe) even with mode changes (refer to Section IV-C), running
of security tasks in ACTIVE mode could impose additional
overheads (i.e., increased load as we have seen in Fig. 5) that
designers of the system may want to avoid.

The false positive/negative errors can be mitigated by care-
fully designing the detection algorithms based on application
requirements. Further, we argue that forced mode changes
would require an adversary to intrude in the system and remain
undetected for a long time. In practice that could be difﬁcult
and unlikely in the presence of several intrusion detection
tasks.

B. Limitations and Improvement

In Contego each security task has a desired frequency
of execution for better security coverage. Security tasks so
far have been treated as independent and preemptive, but in
practice, some security monitoring may need atomicity or non-
preemptive execution. The server-based model proposed in
this work can be extended to incorporate this feature. For
example, when a security task needs to perform a special
atomic operation, the priority of the server can be increased to
a priority that is strictly higher than all (or some) of the real-
time tasks. Further, if the security task running under server
is not the highest-priority security task, the priority of that
task itself will also be increased. If the server’s capacity is
exhausted while it is executing an atomic operation, we can
allow the server to overrun [39], i.e., the server continues
to execute at the same priority until the security checking is
completed. When the server overruns, the allocated capacity at
the start of the next server replenishment period is reduced by
the amount of the overrun. However, schedulability analysis
must be performed considering maximum blocking times of
the security tasks.

Further, security tasks may have dependencies wherein one
task depends on the output from one or more other tasks.
For example, an anomaly detection task might depend on the
outputs of multiple scanning tasks, or, the scheduling frame-
work might need to follow certain precedence constraints for
security tasks. In order to ensure the integrity of monitoring
security, the security application’s own binary might need to
be examined ﬁrst before it checks the system binary ﬁles. In
that case, the cumulative tightness of the achievable periodic
monitoring proposed in Section III might no longer be a
reasonable metric. Constraints to ensure that the dependent
security tasks are executed often enough should be included
and the optimization problem may need to be reformulated
and evaluated with different metrics.

While time-to-detect is a useful metric, it is hard to quantify
in a comprehensive way as it depends on a number of factors
such as the efﬁcacy of monitoring tasks, the kind of intrusion
etc. and is a lagging metric. Identifying and designing better
security metrics is an important and challenging problem. In
future work we will undertake it in the narrow context of
integrating monitoring and detection tasks into RTS.

VIII. RELATED WORK

In our earlier work [11] we proposed to use a server to
integrate security tasks and execute them opportunistically at
a lower priority than real-time tasks. That approach was useful
for legacy RTS where perturbing the schedule of real-time
tasks was not an option – however, the downside was longer
time for detection. In contrast, Contego can respond to anoma-
lous activities in an adaptive manner and provide improved
monitoring frequency and detection time when needed.

A new scheduler [13] and enhancements to an existing
dynamic priority scheduler [14] were proposed to meet real-
time requirements while maximizing the level of security
achieved. A state cleanup mechanism has been introduced
[16], and further generalized [15], [17] such that the ﬁxed-
priority scheduling algorithm was modiﬁed to mitigate infor-
mation leakage through shared resources. Researchers have
proposed a schedule obfuscation method [7] aimed at ran-
domizing the task schedule while providing the necessary real-
time guarantees. Such randomization techniques can improve
the security posture by minimizing the predictability of the
deterministic RTS scheduler. Recent work [9], [10] on dual-
core based hardware/software architectural frameworks has
aimed to protect RTS against security threats. However, those
approaches came at the cost of reduced schedulability or may
require architectural/scheduler-level modiﬁcations. In compar-
ison, Contego aims to integrate security without any signiﬁcant
modiﬁcation of the system properties and does not violate the
temporal constraints or schedulability of the real-time tasks.

Although not in the context of security in RTS, there exists
other work [40] in which the authors statically assign the
periods for multiple independent control tasks by considering
control delay as a cost metric and estimating the delay
through an approximate response time analysis. In contrast,
our goal is to ensure security without violating the timing
constraints of the real-time tasks. Hence, instead of minimizing
response time, we attempt to assign the best possible periods
and priority-levels so that we can minimize the perturbation
between the achievable period and desired period for all the
security tasks.

An on-demand fault detection and recovery mechanism
has been proposed [41] in which the system can operate
in different modes. Speciﬁcally, when a fault is detected, a
high-assurance controller is activated to replace the faulty
high-performance controller. While fault-tolerance may also
be a design consideration, Contego focuses primarily on
integrating mechanisms that can foil cyber-attacks. There also
exist work in the context of mixed-criticality systems (MCS)
where application tasks of different criticality requirements
(e.g., deadline and execution time) share same computation
and/or communication resources (refer to literature [42] for a
survey of MCS). MCS is different than the problem considered
in this work due to the fact that security properties (i.e.,
adaptive switching depending on runtime behavior or frequent
execution of monitoring events for faster detection) are often
different than temporal requirements (e.g., satisfying deadline

12

constraints for mixed-criticality tasks). However, the theory
and concepts emerged from MCS can also be applied to
the real-time security problems to further harden the security
posture of future RTS.

IX. CONCLUSION

The sophistication of recent attacks on UAVs [43], auto-
mobiles [2], [4], medical devices [5] as well as an industrial
control systems [3], indicates that RTS are becoming more
vulnerable. In this paper we are making steps towards the de-
velopment of a comprehensive framework to integrate security
mechanisms and provide a glimpse of security design metrics
for RTS. Designers of RTS are now able to improve their
security posture, which will also improve overall safety – and
that is essentially the main goal of such systems.

REFERENCES

[1] M. Abrams and J. Weiss, “Malicious control system cyber security
attack case study–Maroochy Water Services, Australia,” McLean, VA:
The MITRE Corporation, 2008.

[2] S. Checkoway, D. McCoy, B. Kantor, D. Anderson, H. Shacham,
S. Savage, K. Koscher, A. Czeskis, F. Roesner, T. Kohno et al.,
“Comprehensive experimental analyses of automotive attack surfaces,”
in USENIX Sec. Symp., 2011.

[3] N. Falliere, L. O. Murchu, and E. Chien, “W32. Stuxnet dossier,” White

paper, Symantec Corp., Security Response, vol. 5, p. 6, 2011.

[4] K. Koscher, A. Czeskis, F. Roesner, S. Patel, T. Kohno, S. Checkoway,
D. McCoy, B. Kantor, D. Anderson, H. Shacham et al., “Experimental
security analysis of a modern automobile,” in IEEE S&P, 2010, pp.
447–462.

[5] S. S. Clark and K. Fu, “Recent results in computer security for medical

devices,” in MobiHealth, 2011, pp. 111–118.

[6] C.-Y. Chen, R. B. Bobba, and S. Mohan, “Schedule-based side-
channel attack in ﬁxed-priority real-time systems,” University of Illinois,
http://hdl.handle.net/2142/88344, Tech. Rep., 2015, [Online].

[7] M.-K. Yoon, S. Mohan, C.-Y. Chen, and L. Sha, “TaskShufﬂer: A
schedule randomization protocol for obfuscation against timing infer-
ence attacks in real-time systems,” in IEEE RTAS, 2016, pp. 1–12.
[8] S. Mohan, “Worst-case execution time analysis of security policies for
deeply embedded real-time systems,” ACM SIGBED Review, vol. 5,
no. 1, p. 8, 2008.

[9] D. Lo, M. Ismail, T. Chen, and G. E. Suh, “Slack-aware opportunistic
monitoring for real-time systems,” in IEEE RTAS, 2014, pp. 203–214.
[10] M.-K. Yoon, S. Mohan, J. Choi, J.-E. Kim, and L. Sha, “SecureCore: A
multicore-based intrusion detection architecture for real-time embedded
systems,” in IEEE RTAS, 2013, pp. 21–32.

[11] M. Hasan, S. Mohan, R. B. Bobba, and R. Pellizzoni, “Exploring
opportunistic execution for integrating security into legacy hard real-
time systems,” in IEEE RTSS, 2016, pp. 123–134.

[12] ——, “A server model to integrate security tasks into ﬁxed-priority real-

time systems,” in IEEE CERTS, 2016, pp. 61–68.

[13] T. Xie and X. Qin, “Improving security for periodic tasks in embedded

systems through scheduling,” ACM TECS, vol. 6, no. 3, p. 20, 2007.

[14] M. Lin, L. Xu, L. T. Yang, X. Qin, N. Zheng, Z. Wu, and M. Qiu, “Static
security optimization for real-time systems,” IEEE Trans. on Indust.
Info., vol. 5, no. 1, pp. 22–37, 2009.

[15] S. Mohan, M.-K. Yoon, R. Pellizzoni, and R. B. Bobba, “Integrating se-
curity constraints into ﬁxed priority real-time schedulers,” RTS Journal,
vol. 52, no. 5, pp. 644–674, 2016.

[16] ——, “Real-time systems security through scheduler constraints,” in

IEEE ECRTS, 2014, pp. 129–140.

[17] R. Pellizzoni, N. Paryab, M.-K. Yoon, S. Bak, S. Mohan, and R. B.
Bobba, “A generalized model for preventing information leakage in hard
real-time systems,” in IEEE RTAS, 2015, pp. 271–282.

[18] A. K. Mok, “Fundamental design problems of distributed systems for
the hard-real-time environment,” Massachusetts Institute of Technology,
Tech. Rep., 1983.

[19] C. L. Liu and J. W. Layland, “Scheduling algorithms for multiprogram-
ming in a hard-real-time environment,” JACM, vol. 20, no. 1, pp. 46–61,
1973.

[20] N. Audsley, A. Burns, M. Richardson, K. Tindell, and A. J. Wellings,
“Applying new scheduling theory to static priority pre-emptive schedul-
ing,” SE Journal, vol. 8, no. 5, pp. 284–292, 1993.

[21] “Open source Tripwire,” https://github.com/Tripwire/tripwire-open-source.
[22] R. Davis and A. Burns, “An investigation into server parameter selection
for hierarchical ﬁxed priority pre-emptive systems,” in IEEE RTNS,
2008.

[23] I. Shin and I. Lee, “Periodic resource model for compositional real-time

guarantees,” in IEEE RTSS, 2003, pp. 2–13.

[24] S. Saewong, R. R. Rajkumar, J. P. Lehoczky, and M. H. Klein, “Analysis
of hierarchical ﬁxed-priority scheduling,” in IEEE ECRTS, 2002, pp.
173–181.

[25] M.-K. Yoon, J.-E. Kim, R. Bradford, and L. Sha, “Holistic design
parameter optimization of multiple periodic resources in hierarchical
scheduling,” in DATE, 2013, pp. 1313–1318.

[26] S. Boyd, S.-J. Kim, L. Vandenberghe, and A. Hassibi, “A tutorial on
geometric programming,” Opt. & Eng., vol. 8, no. 1, pp. 67–127, 2007.

[27] S. Boyd and L. Vandenberghe, Convex optimization, 2004.
[28] E. Bini and G. C. Buttazzo, “Measuring the performance of schedula-

bility tests,” RTS Journal, vol. 30, no. 1-2, pp. 129–154, 2005.

[29] A. Mutapcic, K. Koh, S. Kim, L. Vandenberghe, and S. Boyd,
“GGPLAB: a simple Matlab toolbox for geometric programming,”
2006. [Online]. Available: https://stanford.edu/∼boyd/ggplab/

[30] “BeagleBone Black,” https://beagleboard.org/black.
[31] “Xenomai – real-time framework for Linux,” https://xenomai.org.
[32] “UAV control codes,” https://github.com/Khan-drone/ﬂight-control.
[33] “FreeRTOS,” http://www.freertos.org.
[34] “The Bro network security monitor,” https://www.bro.org.
[35] “FTP brute-force attack trace,” https://github.com/bro/bro/blob/master/testing/btest/Traces/ft
[36] Ethical Hacking and Countermeasures: Secure Network Operating Sys-

tems and Infrastructures, 2nd ed. EC-Council, 2017.

[37] “Shellcode on ARM architecture,” http://shell-storm.org/shellcode.
[38] L. Sha, R. Rajkumar, and J. P. Lehoczky, “Priority inheritance protocols:
An approach to real-time synchronization,” IEEE Trans. on Comp.,
vol. 39, no. 9, pp. 1175–1185, 1990.

[39] M. K. Gardner and J. W.-S. Liu, “Performance of algorithms for
scheduling real-time systems with overrun and overload,” in IEEE
ECRTS, 1999, pp. 287–296.

[40] E. Bini and A. Cervin, “Delay-aware period assignment

in control

systems,” in IEEE RTSS, 2008, pp. 291–300.

[41] X. Liu, H. Ding, K. Lee, Q. Wang, and L. Sha, “ORTEGA: An efﬁcient
and ﬂexible software fault tolerance architecture for real-time control
systems,” in IEEE ECRTS, 2008, pp. 125–134.

[42] A. Burns and R. Davis, “Mixed criticality systems-a review,” University
of York, https://www-users.cs.york.ac.uk/∼burns/review.pdf, Tech. Rep.,
2013, [Online].

[43] D. P. Shepard, J. A. Bhatti, T. E. Humphreys, and A. A. Fansler,
“Evaluation of smart grid and civilian UAV vulnerability to GPS
spooﬁng attacks,” in Proc. of the ION GNSS Meeting, vol. 3, 2012.
[44] M. Chiang, Geometric programming for communication systems, 2005.

APPENDIX

The ACTIVE and PASSIVE modes parameter selection prob-
lems given in Section IV are constrained nonlinear optimiza-
tion problems and not very straightforward to solve. Therefore
we reformulate the optimization problems as a geometric
program (GP) [26]. A nonlinear optimization problem can be
solved by GP if the problem is formulated as follows: [26]
f0(x),

min
X

Subject to:

fi(x) ≤ 1
gi(x) = 1

i = 1, · · · , zp, and
i = 1, · · · , zm

where x = [x1, x2, · · · , xz]T denotes the vector of z opti-
mization variables. The functions f0(x), f1(x), · · · , fzp(x) are

13

constraints for the security tasks (e.g., Eqs. (9) and (12b))
as follows [11]:

P (·)(Q(·) + I (·)
h

i ) + ∆S(·) Q(·)

·

i

−1

Q(·) · ˆg(Q(·), Ti)
i
h
∀τi ∈ Γ(·)
S
(17)

≤ 1,

y0
y0 +Ti

Ti
y0 +Ti

·

Ti
Ti
y0+Ti (cid:19)

(cid:18)
i = log Q(·)

Q(·)
where ˆg(Q(·), Ti) =
and
y0
y0 +Ti (cid:19)
y0 ∈ R+ is a given initial point. After the logarithmic trans-
formation (e.g., ˜Q(·)
and replacing
the inequality constraints fi(·) ≤ 1 with log fi(·) ≤ 0),
the objective function and the constraints become a standard
convex optimization problem that is solvable in polynomial
time.

(cid:18)
i = log P (·)

, ˜P (·)

i

i

Li

ci

posynomial and g1(x), · · · , gzm(x) are monomial functions,
respectively. A monomial function is expressed as gi(x) =
xal
l , where ci ∈ R+ and al ∈ R. A posynomial
l=1
function (i.e., the sum of the monomials) can be represented as
Q
z , where cl ∈ R+ and ajl ∈ R.
fi(x) =
We can maximize a non-zero posynomial objective function
by minimizing its inverse. In addition, we can express the
constraint f (·) < g(·) as f (·)
g(·) ≤ 1.

1 xa2l

· · · xa1l

clxa1l

l=1
P

Based on the above description, we can rewrite the period

Li

2

adaptation problem in either mode as:

(P6)

Subject to:

ωi

−1(T des
i

−1
)

Ti

min
T(·)

Xτi∈Γ(·)

S

−1

CiTi

·

(cid:16) Xτi∈Γ(·)

S

(cid:17)





1
n

− 1

3−

3−2

Q
P
Q
P (cid:19)

n



(cid:18)

−1

≤ 1









−1 ≤ 1, ∀τi ∈ Γ(·)
(3P (·) − 2Q(·))Ti
S
−1 ≤ 1, ∀τi ∈ Γ(·)
S
)−1Ti ≤ 1, ∀τi ∈ Γ(·)
S

T des
i Ti
(T max
i

where for any symbol y(·) represents the corresponding vari-
able in the representative mode (e.g., PASSIVE or ACTIVE).

The above GP formulation P6 is not a convex optimization
problem since the posynomials are not convex functions [26].
However, by using logarithmic transformations (e.g., repre-
senting ˜Ti = log Ti and hence Ti = e ˜Ti, and replacing
inequality constraints of the form fi(·) ≤ 1 with log fi(·) ≤ 0),
we can convert the above formulation into a convex opti-
mization problem. This convex optimization reformulation can
be solved using standard algorithms, such as interior-point
method in polynomial time [27, Ch. 11].

The server parameter selection problem can also cast into
GP as follows. The objective function (e.g., the ratio be-
tween server capacity and period) can be represented as
Q(·)
, which is clearly a posynomial. The server
schedulability constraints (e.g., Eq. (8) and Eq. (12a)) can be
(cid:1)
(cid:0)
rewritten as

P (·)

−1

P (·)

−1

≤ 1

(15)

where ∆S(·) =

(cid:17) (cid:16)

(cid:17)

(P (·) + Th) · T −1

· Ch.

h

Q(·) + ∆S(·)
(cid:16)

τh∈hpR(τ (·)
S )
P

Likewise, the real-time task schedulability constraints for

the ACTIVE mode (e.g., Eq. (11)) can be represented as

Cj +

(cid:16)

Ch

Dj
Th (cid:25)
j ≤ 1, ∀τj ∈ lpR(τ ac

Xτh∈hpR(τj ) (cid:24)
D−1

D−1

(cid:17)

j +

S ).

Dj (P ac)−1 Qac + Qac

(cid:16)

(16)
In addition, by using the geometric mean approximation [44,
Ch. 2] of posynomials we can rewrite the schedulability

(cid:17)

14

