1
2
0
2

r
p
A
6
2

]

O
L
.
s
c
[

3
v
3
0
0
8
0
.
0
1
0
2
:
v
i
X
r
a

Categorical Semantics of Cyber-Physical Systems Theory

GEORGIOS BAKIRTZIS, University of Virginia, USA
CODY H. FLEMING, Iowa State University, USA
CHRISTINA VASILAKOPOULOU, University of Patras, Greece

Cyber-physical systems require the construction and management of various models to assure their correct, safe,
and secure operation. These various models are necessary because of the coupled physical and computational
dynamics present in cyber-physical systems. However, to date the different model views of cyber-physical
systems are largely related informally, which raises issues with the degree of formal consistency between those
various models of requirements, system behavior, and system architecture. We present a category-theoretic
framework to make different types of composition explicit in the modeling and analysis of cyber-physical
systems, which could assist in verifying the system as a whole. This compositional framework for cyber-
physical systems gives rise to unified system models, where system behavior is hierarchically decomposed and
related to a system architecture using the systems-as-algebras paradigm. As part of this paradigm, we show
that an algebra of (safety) contracts generalizes over the state of the art, providing more uniform mathematical
tools for constraining the behavior over a richer set of composite cyber-physical system models, which has
the potential of minimizing or eliminating hazardous behavior.

CCS Concepts: • Software and its engineering → Abstraction, modeling and modularity; • Hardware
→ Safety critical systems; • Computer systems organization → Embedded and cyber-physical sys-
tems; • Theory of computation → Categorical semantics.

1 INTRODUCTION
In this paper we study the problem of unification between the disparate but necessary models used
to assure correctness in cyber-physical systems (cps), including requirements, system behaviors,
and system architectures. Currently, these views are largely managed in an informal, piecemeal
fashion, with no notion of formal traceability between different types of models, which could lead
to designing and implementing systems that are ultimately unsafe due to inconsistencies between
these three views. Model-based design attempts to address some of the aforementioned issues, but
while it contains a notion of formal composition within each model view, it lacks a notion of formal
composition between different model types.

This need for formal compositional theories to support the design of cps is a consistent theme in
cps literature both in the general modeling sense [15] and particularly in contract-based design [13,
64]. First, the model-based design of cps can be greatly assisted by the composition of different
types of models, which would provide traceability between the coupled physical and computational
dynamics present in cps [2]. Second, the application of formal composition makes precise abstraction
and refinement, which are necessary in model-based design and analysis [73]. Third, by investing in a
compositional modeling paradigm we are better able to identify unsafe or uncontrolled interactions
between subsystems [75]. We posit that category theory and, specifically, the wiring diagram
formalism [77] provide an appealing framework to build and analyze compositional models of cps.
In the design and analysis of cps, the word composition appears in many different contexts and
may refer to different things. Category theory is one context where its meaning is formal and
refers to something specific, namely the partial operation on morphisms of a category. However,
we will herein also occasionally use the term composite system in its more relaxed sense, which we
formalize categorically in this work using the systems-as-algebras framework. On the contrary,

Authors’ addresses: Georgios Bakirtzis, bakirtzis@virginia.edu, University of Virginia, USA; Cody H. Fleming, flemingc@
iastate.edu, Iowa State University, USA; Christina Vasilakopoulou, cvasilak@math.upatras.gr, University of Patras, Greece.

 
 
 
 
 
 
the term compositionality is not a formal one, rather the general characteristic of an analysis that
ensures that the behavior of the whole is determined by the behavior of its building blocks.

Wiring diagrams are a particularly interesting example of the congruence between category
theory and model-based design. Wiring diagrams have been independently created by category
theorists [74, 79, 85] but surprisingly look and feel similar to engineering block diagrams used
as the basic diagrammatic framework for modeling, for example, the unified modeling language
(uml), the systems modeling language (SysML), the generic modeling environment (gme), and a
variety of tools from Mathworks including Simulink. These types of diagrams are increasingly part
of various research directions in cps, for example the Ptolemy project [22] or Möbius [55]. Systems
engineering is a discipline where diagrammatic reasoning has long been considered an important
element in managing complexity. But several challenges persist, for example using SysML for the
analysis of systems designs means a scarcity of simulation capabilities, an increased modeling
effort to capture different views of the system, and the need to maintain all these differing views
concurrently even as they evolve asynchronously. While the approach using wiring diagrams
has little tool support currently, as an intellectual framework they overcome these limitations by
augmenting this diagrammatic reasoning with stronger mathematical semantics.

In general, categorical semantics avoid modeling the internal structure of the objects they act
upon. Instead, an object is perceived through its relationships with other objects and not – as is
common with systems models – by what the object is individually. Indeed, in this context we focus
on abstraction, which we see as determining only what is essential in each layer of a given model.
This allows us to talk about how things are related instead of focusing on how things are. This
mindset as applied to systems theory gives rise to a circumspection of the system where we do not
examine a system by its individual elements but by looking at the compositional structure of the
system as a whole. This might sound familiar to safety experts where it is – arguably – accepted
that we cannot examine how safe a system is by examining its individual constituents [51]. Instead,
by modeling cps in the wiring diagram framework we examine the system both by the individual
constituents and their specific interconnections, compositionally.

Contributions. In this paper we use categories as a unifying modeling language for cps:

• We develop a categorical semantics of compositional cps theory that has the capability to
merge physical models with computational models for the design and analysis of cps. 1
• We formalize the general diagrammatic syntax of boxes and wires by adapting the systems-
as-algebras model [77] for cps, thereby producing a formal diagrammatic language for the
design and analysis of cps.

• We establish that the categorical and diagrammatic syntax equipped with a contracts algebra

generalizes over the current state of the art [12].

As diagrammatic reasoning takes an increasingly central role in the modeling, simulation, and
development of cps, such relational semantics will become important in type checking, navigating
different domains of abstraction, and ultimately assisting with providing evidence that cps operate
correctly during deployment. This requires an effort both from industry and academia to accept
that visualization (usually the domain of industry) and mathematical rigor (usually the domain
of academia) will be necessary to improve the current state of the art in system design. Wiring
diagrams are one answer to this merger by implementing formal diagrammatic reasoning for cps
modeling and analysis.

1Compositional cps theory is a flavor of what Lee calls computational dynamical systems theory [47].

2

2 CATEGORICAL BACKGROUND
In this section we present some essential categorical machinery that will be used to build up a
formal compositional cps theory.

2.1 A Few Basic Categorical Concepts
Briefly, a category C consists of a collection of objects 𝑋, 𝑌, . . . , 𝑍 and a collection of arrows
𝑓 : 𝑋 → 𝑌 , along with a composition rule

(𝑓 : 𝑋 → 𝑌, 𝑔 : 𝑌 → 𝑍 ) ↦→ 𝑔 ◦ 𝑓 : 𝑋 → 𝑍
and an identity arrow 1𝑋 : 𝑋 → 𝑋 for all objects, subject to associativity and unity conditions:
(𝑓 ◦ 𝑔) ◦ ℎ = 𝑓 ◦ (𝑔 ◦ ℎ) and 𝑓 ◦ 1𝑋 = 𝑓 = 1𝑌 ◦ 𝑓 . This definition encompasses a vast variety
of structures in mathematics and other sciences: to name a few, Set is the category of sets and
functions, whereas Lin is the category of 𝑘-linear (vector) spaces and 𝑘-linear maps between them,
and we also have the category of states and transitions between them [29]. For a complete treatment
of basic categorical concepts, consult Lawvere and Schanuel [45], Leinster [50], or Spivak [80].

A standard diagrammatic way to express composites is 𝑋

tative diagrams of the following form

𝑓
−→ 𝑌

𝑔
−→ 𝑍 and equations via commu-

𝑋

1

𝑓

𝑋

𝑓

𝑌

stands for 𝑓 ◦ 1𝑋 = 𝑓

A morphism 𝑓 : 𝑋 → 𝑌 is called invertible or an isomorphism when there exists another 𝑔 : 𝑌 → 𝑋
such that 𝑓 ◦ 𝑔 = 1𝑌 and 𝑔 ◦ 𝑓 = 1𝑋 .

A functor 𝐹 : C → D between two categories consists of a function between objects and a
function between morphisms, where we denote 𝐹 𝑓 : 𝐹𝑋 → 𝐹𝑌 , such that it preserves composition
and identities: 𝐹 (𝑓 ◦ 𝑔) = 𝐹 𝑓 ◦ 𝐹𝑔 and 𝐹 (1𝑋 ) = 1𝐹𝑋 . A functor can informally be thought of as a
structure-preserving map between domains of discourse. Interestingly, categories and functors
form a category on their own, denoted Cat, in the sense that functors compose and the rest of the
axioms hold.

A monoidal category V is a category that comes equipped with a functor called ‘tensor product’
⊗ : V × V → V

which can be thought of as multiplication of objects and morphisms, or more broadly as doing
operations in parallel. The tensor product comes with invertible morphisms (𝑋 ⊗𝑌 )⊗𝑍 (cid:27) 𝑋 ⊗(𝑌 ⊗𝑍 )
meaning that it is associative up to isomorphism. There is also a distinguished object 𝐼 ∈ V with
𝐼 ⊗ 𝑋 (cid:27) 𝑋 (cid:27) 𝑋 ⊗ 𝐼 , acting like an identity for this multiplication. All these data satisfy certain
axioms found, for example, in Joyal and Street [41], that are beyond the scope of this paper.

Widely used examples of monoidal categories include (Set, ×, {∗}) with the cartesian product of
sets and the singleton, as well as (Lin, ⊗𝑘, 𝑘) with the tensor product of 𝑘-vector spaces. Moreover,
(Cat, ×, 1) with the cartesian product of categories (similarly to that of sets) and the unit category
with a single object and single arrow forms a monoidal category. In fact, all these are examples of
symmetric monoidal categories, which come further equipped with isomorphisms 𝑋 ⊗ 𝑌 (cid:27) 𝑌 ⊗ 𝑋 ,
for example, for two sets 𝑋 × 𝑌 (cid:27) 𝑌 × 𝑋 via the mapping (𝑥, 𝑦) ↦→ (𝑦, 𝑥).

A lax monoidal functor between two monoidal categories 𝐹 : (V, ⊗V, 𝐼V) → (W, ⊗W, 𝐼W) is a
functor that preserves the monoidal structure in a lax sense (meaning not up to isomorphism).
Explicitly, it comes equipped with collections of morphisms, the ‘laxator’ 𝜙𝑋 ,𝑌 : 𝐹𝑋 ⊗W 𝐹𝑌 →
𝐹 (𝑋 ⊗V 𝑌 ) and the ‘unitor’ 𝜙0 : 𝐹 (𝐼V) → 𝐼W that express the relation between the image of the

3

tensor and the tensor of the images inside the target category W; these also adhere to certain
axioms [41]. Monoidal categories and lax monoidal functors also form a category of their own,
denoted MonCatlax.

2.2 The Category W of Wiring Diagrams
The cornerstone of this work is the category W of labeled boxes and wiring diagrams. Informally,
the objects of this category are to be thought of as empty placeholders for processes, so far only
specifying the types of the input and output data that they may receive. For example, an object
𝑋 with inputs being pairs of a real and a natural number and outputs true or false values is
diagrammatically depicted as

R

N

𝑋

{⊤,⊥}

The two input wires above can also be represented by a single wire typed R × N. A process that
can later be positioned inside that box is, for example, the function

𝑓 (𝑟, 𝑛) =

(cid:40)

⊤ if 𝑟 = 𝑛
⊥ if 𝑟 ≠ 𝑛

To begin with, however, these boxes are uninhabited: they merely represent the architecture of a
possible system.

These interfaces, with finitely many input and output wires along with their associated types,
are essentially the building blocks for forming larger interfaces from smaller ones, and this is what
is captured by the morphisms in the category W. For example, suppose
R is another box.
Intuitively, since the type of the output wire of 𝑌 matches the type of one of the input wires of 𝑋 ,
they could be linked along that wire

𝑌C

C

𝑌

R

R

N

𝑋

{⊤,⊥}

to provide a new interface that receives two inputs, one complex and one natural number, and
outputs a true or false:

R

𝑌

𝑍

𝑋

{⊤,⊥}

C

N

While combining interfaces together, we want to be able to express not only the new interface they
{⊤,⊥}, but also keep track of the intermediate wires. In
form, which in the above example is
our envisioned category, this will be expressed as a morphism from ‘𝑋 and 𝑌 ’ into 𝑍 . 2

𝑍C
N

Definition 2.1. There is a category W with pairs of sets 𝑋 = (𝑋in, 𝑋out) as objects, thought of as

the products of types of the input and output ports of an empty box as in

𝑋in

.
.
.

𝑋

.
.
.

𝑋out

2This morphism is explicitly given later in Section 3.3.

4

A morphism 𝑓 : 𝑋 → 𝑌 in this category is a pair of functions 3

(cid:40)𝑓in : 𝑋out × 𝑌in → 𝑋in
𝑓out : 𝑋out → 𝑌out

(𝑎)
(𝑏)

(1)

thought of as providing the flow of information in a picture as follows

𝑓 : 𝑋 →𝑌

𝑋

𝑌

which illustrates in diagrammatic view the system of equations 1 (where the forks correspond to
duplication and black bullets correspond to discarding). Information going through those wires can
be anything insofar as the types match between ports. The wires of the external input ports 𝑌in
can only go to the internal input ports 𝑋in (equation 1a), whereas the wires of the internal output
ports 𝑋out can be directed to the external output ports 𝑌out (equation 1b) as well as fed back to the
internal input ports 𝑋in (equation 1a).

This is a monoidal category, where the tensor product of any two labelled boxes 𝑋 and 𝑌 is

𝑋 ⊗ 𝑌 = (𝑋in × 𝑌in, 𝑋out × 𝑌out) that represents the parallel placement of the two

.
.
.

.
.
.

𝑋

𝑌

.
.
.

.
.
.

(2)

with input and output the (cartesian) product of the respective sets.

For simplicity, we often abstract the pictures for objects, morphisms and tensor in W to

𝑋in

𝑋

𝑋out

𝑌

𝑋

𝑋

𝑌

The composition in this category zooms two levels deep, and is formally defined as follows: for
𝑓 = (𝑓in, 𝑓out) : 𝑋 → 𝑌 and 𝑔 = (𝑔in, 𝑔out) : 𝑌 → 𝑍 as in the systems of equations 1, the new wiring
(cid:17)
diagram 𝑔 ◦ 𝑓 : 𝑋 → 𝑍 consists of the functions
(𝑔 ◦ 𝑓 )in : 𝑋out ×𝑍in → 𝑋in, (𝑔 ◦ 𝑓 )out : 𝑋out → 𝑌out
given by

(cid:16)

(𝑔 ◦ 𝑓 )in (𝑥 ′, 𝑧) = 𝑓in (𝑥 ′, 𝑔in (𝑓out (𝑥 ′), 𝑧))
(𝑔 ◦ 𝑓 )out (𝑥 ′) = 𝑔out(𝑓out(𝑥 ′)).

3In reality, these are not just arbitrary functions, rather generated by projections, diagonals and switchings; for more details
consult Spivak [78, Def. 3.3].

5

𝑋

𝑌

R

R

A

𝑍

R

R

R

R

(a) A zoomed-in picture of a process A.

w

u

v

𝑋

𝑌

𝑍

x

y

z

(b) View as a wiring diagram, equation (3).

Fig. 1. An example wiring diagram as a morphism in the category W.

𝐼

{∗}

The identity morphism on 𝑋 is (𝜋2 : 𝑋out × 𝑋in → 𝑋in, 1𝑋out : 𝑋out → 𝑋out), and the axioms of a
category hold. 4 Moreover, the monoidal unit is the box
{∗} and the axioms of a monoidal
category can also be verified to hold [85].

The category W as defined above is really Set-typed or labeled, namely the objects and morphisms
are described using sets. However, the formalism allows to label the wires with any category
equipped with finite products instead of (Set, ×, {∗}). For example, the types could be in linear
spaces R𝑛 or topological spaces (𝑋, 𝜏) or even more general time-related categories like lists of
signals expressed as sheaves on real-time intervals [77, § 3]. Not only do these different types
accommodate systems with such inputs and outputs, but also often provide a passage between
different models on the same system by functorially changing the types.

The construction of this category allows us to formally give meaning to arbitrary wiring diagram
pictures and as a result, coherently describe interconnections. As an example, consider three
processes 𝑋 , 𝑌 , and 𝑍 (Fig. 1a). The involved labelled boxes are 𝑋 = (R, R), 𝑌 = (R, R) and
𝑍 = (R3, R), which connected in the depicted way form the composite interface 𝐴 = (R3, R).
Although 𝐴’s inputs and outputs are to the ‘outside world’, they could also potentially interconnect
to other boxes themselves.

To implement the above as a morphism in the category W, we first ‘align’ the boxes such that
the wires follow their input and output (Fig. 1b), which then forms a morphism from the tensor
product of the three boxes 𝑋 ⊗ 𝑌 ⊗ 𝑍 (the dotted box) with input R5 and output R3, to the outside
box A = (R3, R) with explicit description

(cid:123)

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

𝐴in
(cid:125)(cid:124)

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:122)
R × R × R →
→ R

(𝑋 ⊗𝑌 ⊗𝑍 )in
(cid:123)
(cid:125)(cid:124)
(cid:122)
R × R × R × R × R,

(𝑋 ⊗𝑌 ⊗𝑍 )out
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:123)
(cid:125)(cid:124)
(cid:122)
R × R × R ×
𝑓in :
𝑓out : R × R × R
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:124)
(cid:125)
(cid:123)(cid:122)
(𝑋 ⊗𝑌 ⊗𝑍 )out



The two functions, 𝑓in and 𝑓out, specify which wires are connected to which; 𝑓in maps the three
internal outputs 𝑥, 𝑦, 𝑧 together with the external inputs 𝑤, 𝑢, 𝑣 to the internal inputs, in the order
determined by our alignment, 5 and 𝑓out projects out of the three internal outputs 𝑥, 𝑦, 𝑧 the third
one 𝑧. Even though Fig. 1a does not involve any feedback loops on individual boxes, these are

(𝑥, 𝑦, 𝑧, 𝑤, 𝑢, 𝑣) ↦→ (𝑤, 𝑢, 𝑥, 𝑦, 𝑣)
(𝑥, 𝑦, 𝑧) ↦→ 𝑧

,
(cid:124)(cid:123)(cid:122)(cid:125)
𝐴out

(3)



.

4There is a strong relation between W and the category of lenses [34], as well as the Dialectica category [27].
5We could choose a different alignment of the internal boxes, which would result to a different, but essentially equivalent,
pair of functions. This would not affect our analysis.

6

inherently used by the formalism as in Fig. 1b in order to concretely form the wiring diagram
equations (3).

To sum up, the category W provides a formal way of mathematically expressing any configuration

at hand, with sole focus on the interconnection of vacant building blocks.

3 COMPOSITIONAL CYBER-PHYSICAL SYSTEMS THEORY
Assessing the correct behavior of cps requires several model views. Before discussing them, we
must first clarify the meaning of the terminology that we will use. We choose to use the terminology
of requirements, system behavior, and system architecture to describe the different diagrammatic
abstractions of cps models. We define requirements as constraints over system behavior and system
architecture. By system behavior we mean models of the form of automata or state space models. By
system architecture we mean models of candidate implementations that, in the case of cps, include
hardware and software for the embedded system portion of cps and motors, control surfaces, and
mechanical structure for the physical portion of the cps. In the following formalism in general,
we will view the individual diagram pictures as architecture, and the particular semantics that
go into the boxes within this diagram as behavior, omitting the leading word ‘system’ when only
discussing about the diagrammatic representation. Contracts that constraint both behavior and
architecture in this sense will represent a subset of system safety requirements.

The categorical approach has the advantage of providing a compositional modeling and analysis,
in which the composite system is completely and uniquely determined from its subsystems and
their interconnections. This is achieved through the implementation of the formalism in two parts.
The first is a behavior algebra that allows the hierarchical modeling between the abstraction of
system behavior and system architecture, in a zoom-in, zoom-out approach [86], where each view
may have distinct inputs and outputs. The second is a contract algebra that applies constraints as
defined in requirements over the behavior algebra.

An analogously high-level approach using monoidal categories and compositional techniques
has already found success in categorical quantum mechanics [1, 23], where it has become the de
facto language to describe and manipulate quantum processes diagrammatically. We posit that a
similar innovation should take place in the design and assessment of safety-critical cps, due to
the concerns raised by the intertwined nature of digital control with physical processes and the
environment. We will view distinct but related system models, pertinent to assuring the correct
behavior of cps, as algebras of the monoidal category of wiring diagrams.

The wiring diagram approach diverges from input-output models. While the diagrammatic
syntax looks similar to such models, what is contained within the boxes need not be a mathematical
function. It can instead be any sort of process, from very concrete descriptions like automata, to
more abstract processes which could be deterministic or non-deterministc, to mere requirements
of a mathematically unknown formula. Similarly, the arrows do not need to contain one piece of
information, for example the input and output of a function; rather, arrows can carry arbitrary
objects of a chosen category of types. Previous compositional modeling methods for cps are often
limited to sets and functions or in the most general sense, relations. However, the state space of
a controls system need not be the set R, but could instead be a topological space like the line or
circle S. The rich interplay between topology and category theory positions category theory as a
particularly good candidate for modeling dynamics, for example see Hansen and Ghrist [38] or
earlier, in the more related area of hybrid systems, Ames [5] and Tabuada et al. [83].

We now develop the formalism for the three system views necessary to assess the correct behavior

of cps: system behavior, system architecture, and (a subset of) requirements.

7

3.1 System Behavior via Algebras on the Category W
The category of wiring diagrams does not populate the boxes with actual systems, for example,
dynamical systems (Section 2.2). This is instead done by developing extra structure on top of it. By
knowing the configuration of the component systems, the composite system can then be uniquely
determined.

Categorically, this is described as an algebra on W, namely a lax monoidal functor 𝐹 : (W, ⊗, 𝐼 ) →
(Cat, ×, 1). The idea is that each algebra assigns to a box 𝑋 = (𝑋in, 𝑋out) a category 𝐹𝑋 of systems
that can be placed in the box, and also assigns to a wiring diagram 𝑓 = (𝑓in, 𝑓out) a functor
𝐹 𝑓 : 𝐹𝑋 → 𝐹𝑌 that, given a system 𝑠 inhabiting the internal box of a wiring diagram, produces the
composite system 𝐹 (𝑓 )(𝑠) inhabiting the external box.

𝐹 : W
𝑋 =(𝑋in, 𝑋out)
𝑓
𝑌 =(𝑌in, 𝑌out)

Cat

𝐹𝑋

𝐹 (𝑓 )

𝐹𝑌

subsystems category

composite system functor

𝐹 (𝑓 )𝑠 ∈𝐹𝑌

𝑠 ∈𝐹𝑋

Intuitively, the object assignment 𝐹𝑋 and 𝐹𝑌 gives semantics to arbitrary boxes through the
subsystems category while the composite system functor 𝐹 𝑓 assembles the composite operations
of the overall system behavior. Moreover, the monoidal structure of the functor via the laxator
𝜙𝑋 ,𝑌 : 𝐹𝑋 × 𝐹𝑌 → 𝐹 (𝑋 ⊗ 𝑌 ) ensures that for given systems inside parallely placed boxes, we can
always determine a system inhabiting their tensor product

𝜙 (𝑠,𝑡 ) ∈𝐹 (𝑋 ⊗𝑌 )

𝑠 ∈𝐹𝑋

𝑡 ∈𝐹𝑌

The categorical formulation allows us to use a number of algebras according to our purposes. Below
we describe two such algebras of discrete dynamical systems, and later we will examine the algebra
of contracts (Section 3.3). There exist also other algebras, describing systems behaviors that are not
like difference equations. For example, algebras for abstract total or deterministic machines [77].
The diagrammatic representation via wiring diagrams for system modeling and analysis is rather
straightforward, particularly because wiring diagrams are similar to engineering block diagrams
and, hence, the visual syntax is equivalent to existing cps design tools. However, the current
diagrammatic representation is mathematically richer and more concrete – it also accounts for
actual composition computations as we will see below. Another important factor specifically for
cps is the richness of other possible algebras or semantics that one can develop and assign in
these boxes using as backing the notion of the monoidal category. As cps become more complex,
cooperative, and coordinated these functorial semantics can give formal relations between several
concepts important in modeling and assurance of safe cps [7].

3.1.1 Moore Machines. As an illustrative example on how to develop and use the behavior algebra
on an architecture in W, we will position the familiar Moore machines inside the boxes 𝑋 , 𝑌 and
𝑍 of Fig. 1a. This is a simple yet useful demonstration of the algebra machinery because Moore
machines model discrete dynamical systems. To concretely describe the systems composite, we
first need to verify that Moore machines form a W-algebra. Indeed, there is a monoidal functor

M : W → Cat

8

which maps each (𝑋in, 𝑋out) to the category M (𝑋in, 𝑋out) where

• objects are triples (𝑆, 𝑢, 𝑟 ) where 𝑆 is the state space set, 𝑢 : 𝑆 × 𝑋in → 𝑆 is the update function

and 𝑟 : 𝑆 → 𝑋out is the readout function;

• morphisms (𝑆, 𝑢, 𝑟 ) → (𝑆 ′, 𝑢 ′, 𝑟 ′) are functions 𝑓 : 𝑆 → 𝑆 ′ between the state spaces that
commute with the update and readout functions, namely 𝑓 (𝑢 (𝑠, 𝑥)) = 𝑢 ′(𝑓 𝑠, 𝑥) and 𝑓 (𝑟 (𝑠)) =
𝑟 ′(𝑓 𝑠).

Hence, M (𝑋in, 𝑋out) is the category of Moore machines with fixed input and output alphabet 𝑋in
and 𝑋out respectively. For example, an object of the category 𝑀 ({0, 1}, {0, 1}) with inputs and
outputs the booleans, is the ‘not’ finite state machine

1

𝑠1
0

0

1

𝑠2
1

0

with state space 𝑆 = {𝑠1, 𝑠2} and update and readout functions depicted in the above state diagram,
for example, 𝑢 (𝑠1, 0) = 𝑠2 (middle top edge) and 𝑟 (𝑠2) = 1 (bottom part of 𝑠2-node).

Having defined the categories of systems that can inhabit boxes in wiring diagram pictures for this
specific Moore machine model, we proceed to define the composite system functor M (𝑓 ) : M𝑋 →
M𝑌 , given a wiring diagram 𝑓 = (𝑓in, 𝑓out) : 𝑋 → 𝑌 . Explicitly, this functor maps a Moore machine
(𝑆, 𝑢, 𝑟 ) with input and output 𝑋in, 𝑋out to a Moore machine (𝑆, 𝑢 ′, 𝑟 ′) with input and output 𝑌in, 𝑌out
having the same state space 𝑆, but with new update and readout functions formed as follows

𝑢 ′ : 𝑌in × 𝑆 → 𝑆,
𝑟 ′ : 𝑆 → 𝑌out,

𝑢 ′(𝑦, 𝑠) = 𝑢 (𝑓in (𝑦, 𝑟 (𝑠)), 𝑠)

𝑟 ′(𝑠) = 𝑓out (𝑟 (𝑠))

(4)

Finally, we need to specify the monoidal structure of M by providing functors M (𝑋 ) × M (𝑌 ) →
M (𝑋 ⊗ 𝑌 ). Explicitly, given two Moore machines (𝑆𝑋 , 𝑢𝑋 : 𝑋in × 𝑆𝑋 → 𝑆𝑋 , 𝑟𝑋 : 𝑆𝑋 → 𝑋out) and
(𝑆𝑌 , 𝑢𝑌 : 𝑌in × 𝑆𝑌 → 𝑆𝑌 , 𝑟𝑌 : 𝑆𝑌 → 𝑌out), we construct a new Moore machine with space set 𝑆𝑋 × 𝑆𝑌
and update and readout functions

𝑢 : 𝑋in × 𝑌in × 𝑆𝑋 × 𝑆𝑌 → 𝑆𝑋 × 𝑆𝑌 ,
𝑟 : 𝑆𝑋 × 𝑆𝑌 → 𝑋out × 𝑌out,

𝑢 (𝑥, 𝑦, 𝑠, 𝑡) = (𝑢𝑋 (𝑥, 𝑠), 𝑢𝑌 (𝑦, 𝑡))
𝑟 (𝑠, 𝑡) = (𝑟𝑋 (𝑠), 𝑟𝑌 (𝑡))

(5)

It can been be verified that with the above assignments, Moore machines satisfy the axioms
of a wiring diagram algebra [77, §2.3]. We can therefore arbitrarily interconnect such systems,
in particular as in Fig. 1a, and produce a new such system with a description only in terms of
,
its components and their wiring. Suppose we have Moore machines in the boxes
, all with R-valued wires, with state spaces 𝑆𝑋 , 𝑆𝑌 and 𝑆𝑍 and update and readout functions

𝑋

𝑍

𝑌

,

respectively as in

𝑢𝑋−−→ 𝑆𝑋

(cid:40)𝑆𝑋 × R
𝑆𝑋

𝑟𝑋−−→ R

𝑢𝑌−−→ 𝑆𝑌

(cid:40)𝑆𝑌 × R
𝑆𝑌

𝑟𝑌−−→ R

𝑢𝑍−−→ 𝑆𝑍

(cid:40)𝑆𝑍 × R3
𝑟𝑍−−→ R.
𝑆𝑍

The algebra machinery (4) and (5) for the specific wiring diagram (3) produces the composite
𝐴 with state space 𝑆𝑋 × 𝑆𝑌 × 𝑆𝑍 , readout function
Moore machine which inhabits the outer box
𝑟 : 𝑆𝑋 ×𝑆𝑌 ×𝑆𝑍 → R given by (𝑠, 𝑡, 𝑝) ↦→ 𝑟𝑍 (𝑝) and update function 𝑆𝑋 ×𝑆𝑌 ×𝑆𝑍 ×R3 → 𝑆𝑋 ×𝑆𝑌 ×𝑆𝑍
given by

(𝑠, 𝑡, 𝑝, 𝑤, 𝑢, 𝑣) ↦→ (𝑢𝑋 (𝑠, 𝑤), 𝑢𝑌 (𝑡, 𝑢), 𝑢𝑍 (𝑝, 𝑟𝑋 (𝑠), 𝑟𝑌 (𝑡), 𝑣)) .

9

In general, the composite system is produced using the algebra machinery, no matter how
complicated the systems or the wiring diagram is: given any type-respecting interconnection
involving arbitrary feedback loops or parallel/serial arrangements, the monoidal functor will
determine a result. Therefore, this functoriality alleviates some of the scalability issues present in
other formalisms. As we will see later, often some pre-existing knowledge on the desired behavior
of a composite system can possibly inform not only the components’ behavior but also the choice
of wiring.

Linear Time-Invariant Systems. There is a sub-algebra of the algebra of Moore machines, for
3.1.2
linear time-invariant systems (ltis) or linear discrete dynamical systems per Spivak [78]. In fact,
the Moore machines model is an algebra of WSet, where the types of wires are sets and the wiring
diagrams are given by functions, whereas the ltis model is an algebra of WLin, where the types are
given by Lin, the category of linear spaces and linear maps.

Explicitly, there is a monoidal functor L : WLin → Cat that assigns to any box 𝑋in

𝑋out
a category L (𝑋in, 𝑋out) of systems (𝑆, 𝑢 : 𝑆 × 𝑋in → 𝑆, 𝑟 : 𝑆 → 𝑋out) like before, but where all
𝑆, 𝑋in, 𝑋out are linear spaces and both update and readout functions 𝑢 and 𝑟 are linear functions
expressed as

𝑢 (𝑠, 𝑥) = A · 𝑠 + B · 𝑥 = (cid:0)A B(cid:1)

(cid:19)

(cid:18)𝑠
𝑥

𝑟 (𝑠) = C · 𝑠

where A , B and C are matrices of appropriate dimension. For example, if the input, output and
state spaces are 𝑋in = R𝑘 , 𝑋out = Rℓ and 𝑆 = R𝑛, then
A ∈ 𝑛𝑀𝑛
B ∈ 𝑛𝑀𝑘
C ∈ ℓ𝑀𝑛

represents a linear transformation R𝑛 → R𝑛
represents a linear transformation R𝑘 → R𝑛
represents a linear transformation R𝑛 → Rℓ .

(6)

Now given an arbitrary wiring diagram 𝑓 = (𝑓in, 𝑓out) : (𝑋in, 𝑋out) → (𝑌in, 𝑌out) as formalized in
both linear functions of the wiring
𝑘 (B 𝑓 )𝑘′ (cid:1) and 𝑓out = ℓ′C 𝑓
ℓ ,

the system of equations (1), where for 𝑌in = R𝑘′
diagram are also expressed as corresponding matrices 𝑓in = (cid:0)𝑘 (A 𝑓 )ℓ
the functor L (𝑓 ) maps some system (𝑆, A , B, C ) in

and 𝑌out = Rℓ′

Rℓ to the system

R𝑘

𝑋

𝑌

(7)
Rℓ′. The earlier-used term sub-algebra precisely means that this formula is a special case

(𝑆, A + B · A 𝑓 · C , B · B 𝑓 , C 𝑓 · C )

in
of equation (4) when the functions involved are of this specific form.

R𝑘′

Finally, the monoidal structure of this assignment L : WLin → Cat is given by functors L (𝑋 ) ×
L (𝑌 ) → L (𝑋 ⊗ 𝑌 ) that map any two such systems (𝑆𝑋 , A𝑋 , B𝑋 , C𝑋 ) and (𝑆𝑌 , A𝑌 , B𝑌 , C𝑌 )
inhabiting parallel boxes as in wiring diagram (2) give rise to a parallel composite system
(cid:19)

(cid:19)(cid:19)

(cid:19)

(cid:18)
𝑆𝑋 × 𝑆𝑌 ,

(cid:18)A𝑋

0
0 A𝑌

,

(cid:18)B𝑋

0
0 B𝑌

,

(cid:18)C𝑋
0

0
C𝑌

.

Functions (as a Non-Example). If we would like to populate the boxes of a wiring intercon-
3.1.3
𝑋out a function ℎ : 𝑋in → 𝑋out,
nection with mathematical functions, namely assign to some
there is no natural way to make this assignment into an algebra W → Cat. The main reason this
fails is the existence of the feedback loop.

𝑋in

𝑋

However, we can incorporate functions into other existing models, for example Moore machines.
It is possible to express a function ℎ : 𝑋in → 𝑋out as an object of M (𝑋in, 𝑋out), with state space the
domain 𝑋in and update and readout functions 𝜋2 : 𝑋in × 𝑋in → 𝑋in projecting the second variable

10





and ℎ : 𝑋in → 𝑋out applying the said function. The resulting finite state machine at each round
replaces the old input with the new input, and outputs the function application on it. Analogously,
a linear function can be viewed as a linear time-invariant system if we set A = 0 the zero matrix,
B = 𝐼 the unit matrix and C = ℎ the matrix represents the given linear transformation.

As a result, functions can be indeed used to populate boxes, and wired with other functions or
Moore machines they produce a composite Moore machine using the algebra M : W → Cat. It is
also the case that sometimes, wiring two functions using the Moore machine algebra machinery,
we end up with another function and not a more general Moore machine – this usually happens in
serial-like wirings without loops.

Summarizing this section, the starting point is the category of wiring diagrams W with no
processes inside the boxes. We can then assign the behavior of Moore machines inside the boxes
using the corresponding W-algebra M, or the behavior of linear discrete dynamical systems
using the sub-algebra of linear time-invariant systems L, which recovers the standard model of
state-space representation in modern control albeit with a slightly different syntax. By composing
behaviors using the latter, we recover a block-diagonal state space model, a useful representation
for modeling the control portion of cps.

To model state-space representations we had to develop all the above categorical machinery.
However, the point of modeling algebraically is that now we can ensure composition and also caution
when two boxes do not compose in the strict mathematical sense using only the diagrammatic
syntax, which is familiar to develop and manipulate. At the moment, we have illustrated a couple
of examples of behavioral models that can inhabit the boxes, but the algebraic machinery is not
limited by those. We could, for example, inhabit the boxes with hybrid systems, while at the same
time composing properly – whose detailed illustration is part of future work where time is also
incorporated in the framework. Here, in the absence of the time element, behaviors are to be
observed in an instantaneous way, for example, feedback loops do not produce delay effects. Such
issues shall be tackled when the wires carry time-sensitive data.

At the moment we have developed the theory using pen and paper, but it is possible to produce
an algorithmic implementation of this algebra machinery and then enforce these rules diagram-
matically. Particularly, recent software implementations of categorical concepts and specifically
symmetric monoidal categories and wiring diagrams into software can be used to develop prototype
tools and analyses using compositional cps theory [68]. This is useful because diagrammatic lan-
guages do not scale with system design complexity [60] and this computational implementation can
allow us to both visualize important subsystems but also implement these categories and algebras
using a programming language in the same way Modelica, Lustre, or Lingua Franca [52].

3.2 System Architecture via Hierarchical Decomposition
Starting with a cps from a designer point of view, we now might want to model a candidate system
architecture. In general, decomposing a cps in certain sub-components and using a specific wiring
between them follows some choices based on the physical reality, experience, purpose and access to
particular components at the time. Having formalized an agnostic process interface where various
descriptions could live on as an object in the category of wiring diagrams W, as well as arbitrary
zoomed-in pictures of a system as a morphism in W, we have now access to all necessary tools to
realize the above system architecture design process using the general notion of a slice category.
For any category C and a fixed object 𝐶 ∈ C, the slice category C/𝐶 has as objects C-morphisms
with fixed target 𝐶, for example 𝑓 : 𝐴 → 𝐶, 𝑔 : 𝐵 → 𝐶, · · · . The arrows in that category from some

11

𝑓 to some 𝑔 are C-morphisms 𝑘 : 𝐴 → 𝐵 between the domains, making the formed triangle

𝐴

𝑓

𝑘

𝐶

𝐵

𝑔

commute, namely 𝑔 ◦ 𝑘 = 𝑓 . This data forms a category, which also illustrates the abstract nature
of the initial category definition (Section 2.1): objects and arrows can be of any sort (in this case
objects are morphisms of a certain shape in some fixed category, and arrows are also morphisms
that satisfy a property) as long as they satisfy the axioms of a category.

For our wiring diagram category W, where a morphism 𝑓 : 𝑋 → 𝑌 can be thought of as an
implementation of an interface 𝑌 into sub-interface(s) 𝑋 wired in a specific manner, the slice
category W/𝑌 of all arrows mapping into the chosen object 𝑌 essentially contains all possible
design choices available to a system engineer. This formally captures the possibility of implementing
a system in multitudes of ways.

Concretely, suppose we have a system with R3-inputs and R-outputs, namely inhabiting a box
R
R. How can we decompose it into sub-processes, and how can they be interconnected to
R
𝐴
R
form the given system? All the possible decompositions can thus be thought of as the objects of the
slice category W/𝐴. For example, Fig. 1a depicts one of these choices, namely the specific wiring
diagram 𝑓 : 𝑋 ⊗ 𝑌 ⊗ 𝑍 → 𝐴.

Now suppose we make another implementation choice to further decompose the box 𝑋 as in

𝑋

𝐷

𝐵

𝐶

meaning we choose a specific wiring diagram 𝑔 : 𝐵 ⊗ 𝐶 ⊗ 𝐷 → 𝑋 . This constitutes another level
of zoom-in for the process in 𝐴, at least for the subcomponent 𝑋 (Fig. 2). Categorically, this is a
picture of the composite morphism 𝑓 ◦ (𝑔 ⊗ 1 ⊗ 1), represented with the dashed arrow below

(𝐵 ⊗ 𝐶 ⊗ 𝐷) ⊗ 𝑌 ⊗ 𝑍

𝑔 ⊗1⊗1

𝑋 ⊗ 𝑌 ⊗ 𝑍

𝑓

𝐴

where the top arrow employs the morphism 𝑔 as the implementation of 𝑋 and identity morphisms
on 𝑌 and 𝑍 (as trivial implementations), and 𝑓 is the earlier 𝐴-implementation (Fig. 1a). In the
end, we can disregard the borders of the interface 𝑋 and map directly from the subcomponents
𝐵 ⊗ 𝐶 ⊗ 𝐷 ⊗ 𝑌 ⊗ 𝑍 to 𝐴 without passing through 𝑋 at all if desired. As a result, we are free to use
hierarchical decomposition of processes for any sub-component (or for many simultaneously) and
each time, these architectural choices add one more composite morphism to the resulting wiring
diagram that expresses an implementation of the outmost system process.

3.3 System Requirements via Contracts
The concept of a contract, fundamental for this work, is another example of an algebra for the
monoidal category of labeled boxes and wiring diagrams W. In detail, for any labeled box 𝑋 =
(𝑋in, 𝑋out), a contract is defined to be a relation

𝑅 ⊆ 𝑋in × 𝑋out

12

𝑋

𝐷

𝐵

𝐶

A

𝑌

𝑍

Fig. 2. A two-level zoomed-in picture of a process A.

expressing the allowable tuples of input and output behaviors of the process. Such a description is
one among the most widespread abstract systems modeling notions, see for example Mesarovic
and Takahara [57, §2]. We make a distinction between the explicit defining process of a system;
that is, the behavior assigned to a wiring diagram, and the system behavior. However, abstractly a
system is its behavior and therefore modeling a system in the wiring diagram paradigm makes
those two notions equivalent. The distinction is however useful for separating the behavior algebra
from the contracts algebra, which are formally related but can be used independently of each other.

Static Contracts. The algebra of static contracts is a variation of the algebra originally devel-
3.3.1
oped by Schultz et al. [77, §4.5]. Explicitly, the functor C : W → Cat bound to express conditions
𝑋out the category C(𝑋in, 𝑋out)
on inputs and outputs in a time-less manner, assigns to a box
of binary relations, that is, subsets 𝑖 : 𝑅 ↩→ 𝑋in × 𝑋out, with morphisms 𝑓 : 𝑅 → 𝑃 being subset
inclusions of the form

𝑋in

𝑋

𝑋in × 𝑋out

𝑓

𝑅

𝑃

For a given contract 𝑅𝑋 ⊆ 𝑋in ×𝑋out and a wiring diagram (𝑓in : 𝑋out ×𝑌in → 𝑋in, 𝑓out : 𝑋out → 𝑌out),
the application of the functor C(𝑓 ) on 𝑅𝑋 is the contract 𝑅𝑌 ⊆ 𝑌in × 𝑌out described by

𝑅𝑌 = {(𝑦1, 𝑦2) ∈ 𝑌in × 𝑌out | ∃𝑥2 ∈ 𝑋out such that (𝑓in (𝑥2, 𝑦1), 𝑥2) ∈ 𝑅𝑋 and 𝑓out (𝑥2) = 𝑦2}.

(8)

This formula arises categorically (appendix B). In various examples, this composite contract may
be expressed in more elementary terms depending on the form of the component contracts 𝑅𝑋 and
the wiring diagram at hand.

For the monoidal structure of the functor, suppose we have two parallel boxes (2) with contracts
𝑅𝑋 ⊆ 𝑋in × 𝑋out and 𝑅𝑌 ⊆ 𝑌in × 𝑌out. The laxator 𝜙𝑋 ,𝑌 : C(𝑋 ) × C(𝑌 ) → C(𝑋 ⊗ 𝑌 ) induces a
contract on the box (𝑋in × 𝑌in, 𝑋out × 𝑌out) which is merely the cartesian product

𝑅𝑋 × 𝑅𝑌 ↩→ 𝑋in × 𝑋out × 𝑌in × 𝑌out

(cid:27)
−→ 𝑋in × 𝑌in × 𝑋out × 𝑌out

that essentially switches the two middle variables,

𝜙𝑋 ,𝑌 (𝑅𝑋 , 𝑅𝑌 ) = {(𝑥1, 𝑦1, 𝑥2, 𝑦2) | (𝑥1, 𝑥2) ∈ 𝑅𝑋 and (𝑦1, 𝑦2) ∈ 𝑅𝑌 }.
As an example, suppose we ask that some process in 𝑋 (Fig. 1a) satisfies the contract 𝑅𝑋 ⊆ R × R,
some process in 𝑌 satisfies the contract 𝑅𝑌 ⊆ R × R and some process in 𝑍 satisfies the contract
𝑅𝑍 ⊆ R3 × R. The fact that contracts form an algebra on W ensures that the composite process in 𝐴

13

will necessarily satisfy a contract formed only in terms of 𝑅𝑋 , 𝑅𝑌 and 𝑅𝑍 and their interconnection
(𝑓in, 𝑓out), and specifically

𝑅𝐴 = {(𝑤, 𝑢, 𝑣, 𝑧) ∈ R4 | ∃(𝑥, 𝑦) ∈ R2 such that (𝑤, 𝑥) ∈ 𝑅𝑋 , (𝑢, 𝑦) ∈ 𝑅𝑌 , (𝑥, 𝑦, 𝑣, 𝑧) ∈ 𝑅𝑍 }.

The algebra machinery produces a contract that matches our intuition: whenever the interconnected
composite in Fig. 1a receives three real numbers (𝑤, 𝑢, 𝑣) as inputs, it must produce an output 𝑧
which is 𝑅𝑍 -allowable by (i.e. related to) (𝑥, 𝑦, 𝑣), for some real 𝑥 which is 𝑅𝑋 -allowable by 𝑤 and
some real 𝑦 which 𝑅𝑌 -allowable by 𝑢. Not all inputs of this composite 𝐴 will have an allowable
output, and that completely depends on the contracts of its components 𝑋 , 𝑌 and 𝑍 .

As another example, which highlights the strong connection between the contract algebra
machinery and the usual relation operators, consider a simple wiring diagram with R-typed wires
on the left, expressing serial composition of two boxes:

𝑥

X

𝑦

Y

A

𝑧

𝑥

𝑦

𝑧

X

Y

This morphism 𝑓 : 𝑋 ⊗ 𝑌 → 𝐴 is described by (𝑓in (𝑦, 𝑧, 𝑥) = (𝑥, 𝑦), 𝑓out (𝑦, 𝑧) = 𝑧) according to its
equivalent arrangement on the right, and given two contracts 𝑅𝑋 and 𝑅𝑌 the formula (8) produces
the composite contract

𝑅𝐴 = {(𝑥, 𝑧) | ∃𝑦 such that (𝑥, 𝑦) ∈ 𝑅𝑋 and (𝑦, 𝑧) ∈ 𝑅𝑌 }

which is the usual composition of binary relations.

What is particularly interesting about this algebra of contracts is that it is ‘agnostic’ to the exact
specification of the systems. This means that although categorically it is expressed the same way as,
for example, Moore machines, it is of a quite different flavor: we are not interested in giving explicit
functions that describe the composite process, but in expressing all the possible (input,output)
pairs that can be observed on it. This is very convenient especially when connecting systems of
different models, for example, a Moore machine with an ‘abstract machine’ [77, §4]. Even if we
cannot compose them in the previous sense, since they form distinct algebras (that is, they are
described by different functors W → Cat), we can still compose and examine the requirements the
composite satisfies, in this relational sense.

Independent Contracts. We will also be interested in a subclass of static contracts, called

3.3.2
independent, of the form

𝐼 = 𝐼 1 × 𝐼 2 ⊆ 𝑋in × 𝑋out
These contracts capture cases like ‘inputs are always in range 𝐼 1 and outputs are always in range
𝐼 2, independently from one another’. 6 Of course this is only a special case of arbitrary relations
𝑅 ⊆ 𝑋in×𝑋out, since not all subsets of cartesian products are cartesian products of subsets, as a simple
argument in the finite case shows: |P (𝑋in × 𝑋out)| = 2𝑛 ·𝑚 whereas |P (𝑋in)| · |P (𝑋out)| = 2𝑛+𝑚. For
example, the contract {(𝑥, 𝑦) | 𝑥 < 𝑦} ⊆ R × R is not independent.

One could expect that these contracts form themselves an algebra, namely any wiring composite
of independent contracts will also be an independent, rather than a general contract itself. However
𝑋 ⊆ 𝑋in ×𝑋out
this is not the case in general: although the parallel placement of boxes with 𝐼𝑋 = 𝐼 1

𝑋 ×𝐼 2

6These independent contracts in reality are even more special than that: not only are input restrictions separate from output
restrictions, but also each individual wire has an associated subset of allowed values on it.

14

𝑌 × 𝐼 2

𝑌 ⊆ 𝑌in × 𝑌out produces the independent contract (𝐼 1

𝑌 ) on 𝑋 ⊗ 𝑌 ,
and 𝐼𝑌 = 𝐼 1
𝑋 ⊆ 𝑋in × 𝑋out on 𝑋 ,
closure under feedback fails. Explicitly, for an independent contract 𝐼 1
and a wiring diagram (𝑓in, 𝑓out) : 𝑋 → 𝑌 , the formula (8) produces the slightly simpler composite
contract

𝑌 ) × (𝐼 2
𝑋 × 𝐼 2

𝑋 × 𝐼 2

𝑋 × 𝐼 1

𝑅𝑌 = {(𝑦1, 𝑦2) ∈ 𝑌in × 𝑌out | ∃𝑥2 ∈ 𝐼 2

𝑋 such that 𝑓in (𝑦1, 𝑥2) ∈ 𝐼 1

𝑋 and 𝑓out (𝑥2) = 𝑦2}

(9)

which shows that 𝑦1 and 𝑦2 are not independent in general, hence 𝑅𝑌 is not of the form 𝐼 1

Notice that in certain examples, 𝑅𝑌 can indeed be written as a product itself, for example, when
(𝑓in, 𝜋2) is of the form 𝑘 × 𝑠 for two functions 𝑘, 𝑠. Even more interestingly, due to the special form
of morphisms in the wiring diagram category (where they are only made up from projections,
diagonals and duplications) in our examples below we will be able to write 𝑅𝑌 as an independent
contract itself. 7

𝑌 × 𝐼 2
𝑌 .

3.3.3 Relation to Assume-Guarantee Contracts. Systems theory and design has long recognized
the need for a formal requirement engineering through mathematical models and formal analysis
techniques [12]. As part of contract-based design, there have been multiple efforts to formalize and
analyze assume-guarantee (ag) contracts [72] and incorporate them in the design as a fundamental
concept. We here discuss such examples and how they fit to the previously described static contract
model.

Given a box R
R
al. [12, § IV]) is

R, an example of an assume-guarantee contract (adapted from Benveniste et

𝑅1 :

variables:
types:
assumptions:

guarantees:






inputs 𝑥, 𝑦; outputs 𝑧
𝑥, 𝑦, 𝑧 ∈ R
𝑦 ≠ 0
𝑥
𝑧 =
𝑦

(10)

This explicitly makes the assumption that the environment (namely the inputs coming either from
the external world or from other component systems) will never provide the input 𝑦 = 0, essentially
leaving the behavior for that input undefined. In our formalism, we can express this contract as

𝑅1 = {(𝑥, 𝑦, 𝑧) | 𝑦 ≠ 0 ∧ 𝑧 =

𝑥
𝑦

} ⊆ R × R × R

indicating the fact that the input 𝑦 = 0 will never occur on the input wire of the box; and if it did,
the contract is violated. A different choice we could make, assuming the initial ag contract is really
expressing an "if-then" requirement, is

𝑅 ′
1 = {(𝑥, 𝑦, 𝑧) | 𝑦 ≠ 0 ⇒ 𝑧 =

𝑥
𝑦

} ⊆ R × R × R

which is a different subset of allowable values on the wires. For example, (3, 0, 25) ∈ 𝑅 ′
(3, 0, 25) ∉ 𝑅1.

1 whereas

We now consider a standard ag contract operator called contract composition and system integra-
tion, and we realize it from the perspective of the wiring diagram algebra machinery – consequently
a more general setting. Explicitly, the ag contract composition operator as described for example by
Benveniste et al. [12, § IV.B] or Le et al. [46], takes two ag contracts 𝑅1 = (𝐴1, 𝐺1) and 𝑅2 = (𝐴2, 𝐺2)

7It can be shown that independent contracts indeed form an algebra on W due to the special morphisms that generate it;
the proof is beyond the scope of this paper.

15

and produces a new ag contract 𝑅1 ⊗ 𝑅2 (notice that this is a completely different use of our earlier
monoidal product symbol ⊗) with

𝐺𝑅1 ⊗𝑅2 = 𝐺1 ∧ 𝐺2
𝐴𝑅1 ⊗𝑅2 = max{𝐴 | 𝐴 ∧ 𝐺2 ⇒ 𝐴1, 𝐴 ∧ 𝐺1 ⇒ 𝐴2}

(11)

only when 𝑅1 and 𝑅2 are compatible, namely 𝐴𝑅1 ⊗𝑅2 ≠ ∅. Since 𝐴𝑅1 ⊗𝑅2 is the weakest assumption
such that the two referred implications hold, if non-empty it ensures that there exists some envi-
ronment in which the two contracts properly interact: when put in the context of a process that
satisfies the first contract, the assumption of the second contract will be met and vice-versa. At
first sight, this definition looks ‘symmetric’, since it considers a certain compatibility of output
guarantee/input assumption in both directions, but in reality this is not quite the case.

One issue with the above ag contract composition is that the names of the variables and not
only the types of the wires need to match, in order to connect along them [12, 65]. For example,
the contract 𝑅1 as in (10) can be composed with the contract on R

R

inputs 𝑢; outputs 𝑥
𝑢, 𝑥 ∈ R

𝑅2 :






variables:
types:
assumptions: ⊤
guarantees:

𝑥 > 𝑢

not along any wire, as could be deduced by noticing that all wire types are R, but specifically along
the wire with variable name 𝑥. Pictorially, we can realize them as inhabiting boxes wired as

𝑢

𝑦

𝑥

𝑧

and using the formulas (11) we obtain

𝐴𝑅1 ⊗𝑅2 = max{𝐴 | (𝐴 ∧ (𝑥 > 𝑢) ⇒ 𝑦 ≠ 0) ∧ (𝐴 ∧ (𝑧 = 𝑥/𝑦) ⇒ ⊤)} = (𝑦 ≠ 0)
𝐺𝑅1 ⊗𝑅2 = (𝑥 > 𝑢) ∧ (𝑧 = 𝑥/𝑦).

On the other hand, composing 𝑅1 and 𝑅2 using the static contract algebra (Section 3.3.1) for the
above wiring diagram (𝑓in (𝑥, 𝑧, 𝑢, 𝑦) = (𝑢, 𝑥, 𝑦), 𝑓out (𝑥, 𝑧) = 𝑧), we obtain the composite contract

𝑅 = {(𝑢, 𝑦, 𝑧) ∈ R3 | ∃𝑥 ∈ R such that 𝑦 ≠ 0 ∧ 𝑥 > 𝑢 ∧ 𝑧 = 𝑥/𝑦},

which could be written in ag form as 𝐴 = {(𝑢, 𝑦) | 𝑦 ≠ 0} and 𝐺 = {𝑧 | ∃𝑥 > 𝑢 such that 𝑧 = 𝑥/𝑦}.
Notice that the contract algebra machinery does not present this variable-match problem, since it
does not prevent us from composing along the second input wire of 𝑋1 or even do first 𝑋1 and then
𝑋2 in the opposite order, since all types of wires are real numbers. In all these cases, it would be
possible to compute appropriate composite contracts in this uniform way.

The second issue, which can also be noticed from the above calculation, is that the assumptions
and guarantees of the composite contract include information that mix the variables of the resulting
input and output wires. For example, using the ag formalism, the variables of 𝑅1 ⊗ 𝑅2 are set to
be {𝑢, 𝑦} for inputs and {𝑥, 𝑧} for outputs, therefore this operation behaves as if the intermediate

16

wires of a system composition can be extracted as extra output wires to the outside world:

𝑥

𝑢

𝑦

𝑧

This ‘choice’ does not agree with the wiring diagram formalism, and moreover is somewhat ad-
hoc given that it could potentially add arbitrary many wires to the composite system, essentially
according to the result of the contract composition. Adding extra wires is of course possible for
the algebra formalism, but corresponds to a choice of architecture on how we decide to wire the
subcomponents together, rather than a necessity that arises from dealing with contracts.

Finally, the ag formalism asks that compositions (𝑅1 ⊗ 𝑅2) ⊗ 𝑅3 and 𝑅1 ⊗ (𝑅2 ⊗ 𝑅3) give equivalent
contracts, and that so do 𝑅1 ⊗ 𝑅2 and 𝑅2 ⊗ 𝑅1. In the contract algebra formalism, the first statement
follows for any W-algebra: consider a possible wiring of three boxes, each inhabited with a contract
(or a behavior)

A

𝑍

𝑋1

𝑋3

𝑌

𝑋2

First composing the contracts 𝑅1 and 𝑅2 and then the result with 𝑅3 comes from the application

of the functor C : W → Cat on a wiring diagram morphism

(𝑋1 ⊗ 𝑋2) ⊗ 𝑋3 → 𝑌 ⊗ 𝑋3 → 𝐴

whereas the other way around comes from the application of the functor 𝐶 on the morphism

𝑋1 ⊗ (𝑋2 ⊗ 𝑋3) → 𝑋1 ⊗ 𝑍 → 𝐴
which both express the same morphism 𝑋1 ⊗ 𝑋2 ⊗ 𝑋3 → 𝐴 in W as an implementation of 𝐴
(Section 3.2).

Regarding the second statement about 𝑅1 ⊗ 𝑅2 and 𝑅2 ⊗ 𝑅1, in the ag formalism this can indeed
be proved due to the symmetric formulation of composition (11) as observed earlier. However, this
refers more to the earlier variable-sharing clause (which would not allow the composition along
arbitrary wires therefore in arbitrary order) and less to composition intuition: changing the order
of two boxes and expecting the same behavior or requirements is something highly non expected,
from a categorical but also a design point of view due to the input-output directionality. As a result,
commutativity in this ag setting is slightly misleading, since it is just a technical term relevant to
the constructed formula (it does not really have an effect on the operation) rather to an actually
commuting composition which is not expected to hold – and does not, in the algebra formalism.

4 COMPOSITIONAL CYBER-PHYSICAL SYSTEMS MODELING AND ANALYSIS
In this section, we use the preceding algebraic formalism to illustrate a compositional cps theory. We
model an unmanned aerial vehicle (UAV), analyze it with respect to its control behavior, decompose
it to a system architecture and constrain it using contracts. This process manifests the power,
flexibility and further potential of the wiring diagram compositional framework in the concrete
context of cps analysis and design.

17

𝑒

R

𝑑

R

R

Sensor
𝐿

𝑠′

R

Dynamics
𝐷

𝑠

R

Controller
𝐶

𝑐

R

𝑒

𝑑

𝑠′

𝑐

𝑠

𝐿

𝐶

𝐷

𝑓in : R3 × R2 → R5, (𝑠 ′, 𝑐, 𝑠, 𝑒, 𝑑) ↦→ (𝑠, 𝑒, 𝑠 ′, 𝑑, 𝑐)
𝑓out : R3 → R, (𝑠 ′, 𝑐, 𝑠) ↦→ 𝑠

UAV

Fig. 3. The physical decomposition of the uav, where 𝑑 denotes the desired state, 𝑠 ′ the predicted state, 𝑐 the
control action, 𝑠 the current state, and 𝑒 the environmental inputs.

4.1 System Behavior
We algebraically recover a standard controls model compositionally in the behavior algebra (Sec-
tion 3.1) of the form

•𝑠 or 𝑢 (𝑠, 𝑐) using the earlier update
where 𝑠𝑘 ∈ R𝑛 is the discrete time state, 𝑠𝑘+1 (also denoted
function notation) is the subsequent time-step state and 𝑐𝑘 ∈ R𝑛 is the control signal/output, and

𝑠𝑘+1 = A 𝑠𝑘 + B𝑐𝑘,

𝑦𝑘 = C 𝑠𝑘 + D𝑐𝑘

is the measurement, which is also in R𝑛. We assume D = 0.

We are going to illustrate the algebra machinery using longitudinal equations of motion for a

fixed-winged aircraft represented in the following state-space model [58]

•𝑎
(cid:169)
•𝑞
(cid:173)
(cid:173)
(cid:173)
•
𝜃
(cid:171)

(cid:170)
(cid:174)
(cid:174)
(cid:174)
(cid:172)

56.7
−0.313
−0.0139 −0.426
= (cid:169)
(cid:173)
56.7
(cid:171)

0

0
(cid:170)
0
(cid:174)
0
(cid:172)

𝑎
𝑞
(cid:169)
(cid:173)
𝜃
(cid:171)

(cid:170)
(cid:174)
(cid:172)

0.232
0.0203
+ (cid:169)
(cid:173)
0
(cid:171)

(cid:170)
(cid:174)
(cid:172)

(cid:0)𝛿 (cid:1)

(12)

𝑦 = (cid:0)0

0

,

𝑎
1(cid:1) (cid:169)
𝑞
(cid:173)
𝜃
(cid:171)

(cid:170)
(cid:174)
(cid:172)

where 𝑎 is the angle of attack, 𝑞 is the pitch rate, 𝜃 is the pitch angle and 𝛿 is the elevator deflection
angle. This behavior is the composite one, built up from the subcomponents behavior and their
wiring (Fig. 3).

Working with the linear time-invariant system algebra L : WLin → Cat (Section 3.1.2), suppose
(𝑆𝐿, A𝐿, B𝐿, C𝐿), (𝑆𝐶, A𝐶, B𝐶, C𝐶 ) and (𝑆𝐷, A𝐷, B𝐷, C𝐷 ) are three linear systems inhabiting the
respective boxes of Fig. 3, with

𝑢𝐿 (𝑠𝐿, 𝑠, 𝑒) =A𝐿 · 𝑠𝐿 + B𝐿 · (𝑠, 𝑒)
𝑢𝐶 (𝑠𝐶, 𝑑, 𝑠 ′) =A𝐶 · 𝑠𝐶 + B𝐶 · (𝑑, 𝑠 ′)
𝑢𝐷 (𝑠𝐷, 𝑐) =A𝐷 · 𝑠𝐷 + B𝐷 · (𝑐)

𝑟𝐿 (𝑠𝐿) =C𝐿 · 𝑠𝐿
𝑟𝐶 (𝑠𝐶 ) =C𝐶 · 𝑠𝐶
𝑟𝐷 (𝑠𝐷 ) =C𝐷 · 𝑠𝐷 .

18

Using the algebra machinery for the specific wiring diagram (Fig. 3) given by matrix transformations

0
0
1
0
0
(cid:16)

0

𝑓in =

(cid:169)
(cid:173)
(cid:173)
(cid:173)
(cid:173)
(cid:173)
(cid:173)
(cid:173)
(cid:171)
𝑓out =






0
0
0
0
1

1
0
0
0
0

0

1

0
0
(cid:170)
0
1
(cid:174)
(cid:174)
(cid:174)
0
0
(cid:174)
(cid:174)
1
0
(cid:174)
(cid:174)
0
0
(cid:172)
= C 𝑓

(cid:17)

(cid:16)

=

5(A 𝑓 )3

5 (B 𝑓 )2

(cid:17)

we can compute the composite linear dynamical system that inhabits the box UAV from the formulas
(7). Its state space is 𝑆𝐿 × 𝑆𝐶 × 𝑆𝐷 , and its update and readout linear functions are

𝑢UAV : 𝑆𝐿 × 𝑆𝐶 × 𝑆𝐷 × R2 → 𝑆𝐿 × 𝑆𝐶 × 𝑆𝐷,

(𝑠𝐿, 𝑠𝐶, 𝑠𝐷, 𝑑, 𝑒) ↦→ (A𝐿𝑠𝐿 + B𝐿

(cid:19)

(cid:18)C𝐷𝑠𝐷
𝑒

, A𝐶𝑠𝐶 + B𝐶

(cid:19)

(cid:18)C𝐿𝑠𝐿
𝑑

, A𝐷𝑠𝐷 + B𝐷 C𝐶𝑠𝐶 )

𝑟UAV : 𝑆𝐿 × 𝑆𝐶 × 𝑆𝐷 → R

(𝑠𝐿, 𝑠𝐶, 𝑠𝐷 ) ↦→ C𝐷𝑠𝐷 .

We assume, for simplicity, 8 that the state spaces of the sensor and controller are in R2. Knowing
that only the dynamics 𝐷 actually relate to the triplet (𝑎, 𝑞, 𝜃 ), we deduce that 𝑆𝐷 is in R3 which
results in a composite state space 𝑆UAV in R2 × R2 × R3 (cid:27) R7. Moreover, from the shape of the boxes
according to (6) we deduce that the matrices A𝐿, A𝐶 , B𝐿 and B𝐶 are two-by-two, C𝐿 and C𝐶 are
one-by-two, whereas A𝐷 is three-by-three, B𝐷 is three-by-one and C𝐷 is one-by-three.

Unravelling the above update and readout functions of the composite linear time-invariant
system denoted by UAV, the only output of the composite system behavior is that of the dynamics
𝐷, since by tuple (7)

CUAV = C 𝑓 · C𝐿 ⊗𝐶 ⊗𝐷 = (cid:0)0
Hence for obtaining equation (12), in the specific example we deduce that C𝐷 = (cid:0)0
only 𝜃 is output to the outside world as desired.

1(C𝐷 )3

(cid:1) .

0

0

1(cid:1) meaning

For an element of the state space R7 of the form ((cid:174)𝑠𝐿, (cid:174)𝑠𝐶,

we obtain

(cid:174)𝑠𝐷
(cid:122)(cid:125)(cid:124)(cid:123)
𝑎, 𝑞, 𝜃 ), isolating the first two variables

•
(cid:174)𝑠𝐿= A𝐿(cid:174)𝑠𝐿 + 2 (B𝐿)2

and

•
(cid:174)𝑠𝐶 = A𝐶 (cid:174)𝑠𝐶 + 2(B𝐶 )2

(cid:19)

(cid:18)C𝐿(cid:174)𝑠𝐿
𝑑

,

𝜃
(cid:122)(cid:125)(cid:124)(cid:123)
(cid:169)
(cid:170)
C𝐷 (cid:174)𝑠𝐷
(cid:173)
(cid:174)
(cid:173)
(cid:174)
𝑒
(cid:171)
(cid:172)

which could be viewed as some extra information of the composite system relating to the behaviors
of the sensor and controller, not appearing in equation (12) but part of the total system’s behavior.

Now isolating the last three variables we obtain a description
•𝛼
(cid:169)
•𝑞
(cid:173)
(cid:173)
(cid:173)
•
𝜃
(cid:171)

𝛼
𝑞
= 3(A𝐷 )3 (cid:169)
(cid:173)
𝜃
(cid:171)

+ 3(B𝐷 )1C𝐶 (cid:174)𝑠𝐶 .

(cid:170)
(cid:174)
(cid:174)
(cid:174)
(cid:172)

(cid:170)
(cid:174)
(cid:172)

8See end of this section for a concrete example where 𝐿 and 𝐶 are populated by linear functions, thus their state space
matches their input linear space (Section 3.1.3).

19

Comparing with the desired equation (12), the elevator deflection angle 𝛿 is the output of the
controller C𝐶𝑠𝐶 which matches the physical reality, and the A𝐷 , B𝐷 are completely determined by
the composite description, namely

56.7
−0.313
−0.0139 −0.426
A𝐷 = (cid:169)
(cid:173)
56.7
(cid:171)

0

0
(cid:170)
0
(cid:174)
0
(cid:172)

0.232
0.0203
B𝐷 = (cid:169)
(cid:170)
(cid:173)
(cid:174)
0
(cid:171)
(cid:172)

.

The remaining data A𝐿,𝐶, B𝐿,𝐶, C𝐿,𝐶 depend on engineering and physical parameters.

We were thus able to partly reverse-engineer a given composite system behavior (12), where
for the given system architecture (Fig. 3) we completely identified the behavior of the linear time-
invariant system 𝐷 by determining 𝑆𝐷, A𝐷, B𝐷, C𝐷 . We also obtained certain information about
the other two subcomponents 𝐶 and 𝐿: for example, two possible behaviors could be the linear
functions (for example, signal concatenations) 𝑠 ′ = 𝑠 + 𝑒 for the sensor 𝐿 and the linear function
𝑐 = 𝑠 ′ + 𝑑 for the controller 𝐶. Expressing those as linear time-invariant systems (Section 3.1.3), we
obtain the following description

(𝑆𝐿, A𝐿, B𝐿, C𝐿) =

(cid:18)

R2,

(cid:18)0
0

(𝑆𝐶, A𝐶, B𝐶, C𝐶 ) =

(cid:18)

R2,

(cid:18)0
0

0
0
(cid:19)

(cid:19)

,

(cid:18)1
0

,

(cid:18)1
0

0
0

0
1
(cid:19)

0
1

(cid:19)

, (cid:0)1

(cid:19)

,

1(cid:1)

, (cid:0)1

(cid:19)

,

1(cid:1)

𝑢𝐿 ((cid:174)𝑠𝐿, 𝑠, 𝑒) = (𝑠 𝑒), 𝑟𝐿 ((cid:174)𝑠𝐿) = 𝑠1

𝐿 + 𝑠2
𝐿

𝑢𝐶 ((cid:174)𝑠𝐶, 𝑠 ′, 𝑑) = (𝑠 ′ 𝑑), 𝑟𝐶 ((cid:174)𝑠𝐶 ) = 𝑠1

𝐶 + 𝑠2
𝐶

Then the composite system’s update function is explicitly computed, using (7), as

•
(cid:174)𝑠𝐿=

•
(cid:174)𝑠𝐶 =

(cid:33)

(cid:32)𝜃
𝑒
(cid:32)𝑠1

𝐿 + 𝑠2
𝐿
𝑑

(cid:33)




•𝑎= −0.313𝑎 + 56.7𝑞 + 0.232𝑠1
•𝑞= −0.0139𝑎 − 0.426𝑞 + 0.0203𝑠1
•
𝜃 = 56.7𝑞


𝐶 + 0.232𝑠2
𝐶
𝐶 + 0.0203𝑠2
𝐶

𝐶 and 𝑠2

where 𝑠1
𝐶 are essentially the previous desired state 𝑠 ′ and input 𝑑, producing the deflection
angle 𝛿 that appears in (12). The first two equations give the functions of 𝐿 and 𝐶 (whose states are
placeholders for their inputs at each instance), whereas the last three give the dynamics 𝐷 as before.
Informally, this shows the interplay between what the system is sensing, what its desired operating
state is, and how it must react. If there were more information about the elevator deflection angle
𝛿, that would restrict the possible behaviors for 𝐶 appropriately.

From a more categorical perspective, the above process is summarized as follows: given an
algebra L and a wiring diagram 𝑓 : 𝐿 ⊗ 𝐶 ⊗ 𝐷 → UAV in WLin (Fig. 3), as well as an object of the
target category L (UAV), namely a specific linear system as in equation (12) inhabiting the outside
box UAV, the goal is to find an object in the pre-image of the given system under the composite
functor

L (𝐿) × L (𝐶) × L (𝐷)

𝜙𝐿,𝐶,𝐷
−−−−−→ L (𝐿 ⊗ 𝐶 ⊗ 𝐷)

L (𝑓 )
−−−−→ L (UAV).

Such a problem certainly does not have a unique solution, namely a unique description of the three
systems that form the composite, but for example in this specific case due to the form the wiring
diagram, the component system

(𝑆𝐷, A𝐷, B𝐷, C𝐷 )

20

𝐿

Processor
𝑃1

IMU
𝐼1

IMU
𝐼2

𝐷

Airframe
𝐹

Aileron
𝑋

Rudder
𝑌

Throttle
𝑍

Elevator
𝑊

Processor
𝑃2

𝐶

Servos
𝑉

UAV

Fig. 4. Any decomposition, including the previous one (Fig. 3) resides within the slice category W/UAV. In
this case, the slice category contains all possible design decisions that adhere to the behavioral model; we
pick one such design choice.

was completely determined by the composite behavior. Further work would aim to shed light on
possible shapes of wiring diagrams that have better identifiable solutions under algebras of interest.

4.2 System Architecture
One of the important advantages of expressing system decompositions as a morphism in the
category W is that we can perform further zoomed-in decompositions as desired in a hierarchical
way (Section 3.2), and these are all realized as composite morphisms in the wiring diagram category.
For example, consider a possible UAV architecture (Fig. 3). We may further choose to implement
the sensor box 𝐿 using two IMU units 𝐼1, 𝐼2 and a processor 𝑃1 in a certain interconnection. Expressing
this as a morphism with target 𝐿 (an object in the slice category W/𝐿) namely 𝑔 : 𝐼1 ⊗ 𝐼2 ⊗ 𝑃 → 𝐿
means that we can compose this with the original one-level implementation 𝑓 to obtain a two-level
zoomed-in decomposition

(𝐼1 ⊗ 𝐼2 ⊗ 𝑃1) ⊗ 𝐶 ⊗ 𝐷

𝑔 ⊗1⊗1
−−−−−→ 𝐿 ⊗ 𝐶 ⊗ 𝐷

𝑓
−→ UAV

that only ‘opens-up’ the box 𝐿. We could moreover implement the control as well as the dynamics
box, and decompose them in a choice of subcomponents and wires between them. An example
where the control box is decomposed into 𝑃2 followed by 𝑉 in a serial composition, and the dynamics
box is decomposed into four parallel boxes, 𝑋 , 𝑌 , 𝑍 and 𝑊 followed by 𝐹 amounts to choosing a
specific ℎ : 𝑃2 ⊗ 𝑉 → 𝐶 in W/𝐶 and a specific 𝑘 : 𝑋 ⊗ 𝑌 ⊗ 𝑍 ⊗ 𝑊 ⊗ 𝐹 → 𝐷 in W/𝐷. Combining all
these morphisms we have the composition (Fig. 4):

(𝐼1 ⊗ 𝐼2 ⊗ 𝑃1) ⊗ (𝑃2 ⊗ 𝑉 ) ⊗ (𝑋 ⊗ 𝑌 ⊗ 𝑍 ⊗ 𝑊 ⊗ 𝐹 )

𝑔 ⊗ℎ ⊗𝑘
−−−−−→ 𝐿 ⊗ 𝐶 ⊗ 𝐷

𝑓
−→ UAV

that can be considered as a single morphism from the tensor of all second-level sub-components to
the box UAV. Pictorially, this would be realized by erasing the intermediate colored dashed boxes.

4.3 System Requirements
We will use the algebra of static contracts C : W → Cat (Section 3.3.1), where all requirements
are expressed as subsets of the cartesian product of input and output types. Consider the original
system decomposition to sensor, controller, and dynamics boxes (Fig. 3) and suppose we have

21

certain contracts on these components given by

𝑅𝐿 ⊆ R2 × R,

𝑅𝐶 ⊆ R2 × R,

𝑅𝐷 ⊆ R × R.

These contracts could be any subsets, from the extreme case of equality which means that all
combinations of inputs and outputs are allowed, to some specific requirement imposed to the
example at hand, or in certain cases some maximal contract dictated by a discrete dynamical system
(governed by a difference equation) that actually inhabits the box.

The contract algebra applies to the wiring diagram of Fig. 3 and based on the formula (8) produces

a contract 𝑅UAV ⊆ R2 × R on the composite system, with the following explicit description
R3 ⊇ 𝑅UAV ={(𝑎1, 𝑎2, 𝑎3) ∈ R3 | ∃(𝑥, 𝑦) ∈ R2 such that

(𝑎3, 𝑎1, 𝑥) ∈ 𝑅𝐿, (𝑥, 𝑎2, 𝑦) ∈ 𝑅𝐶, (𝑦, 𝑎3) ∈ 𝑅𝐷 }.

Further, we could assume that all contracts are independent as per Section 3.3.2, namely they can
be written as products of subsets of each wire type independently, like
𝐿,
𝐿 × 𝑅3
𝑅𝐷 = 𝑅1

𝐶,
𝐶 × 𝑅3

𝑅𝐶 = 𝑅1

𝑅𝐿 = 𝑅1

𝐷 × 𝑅2
𝐷

𝐶 × 𝑅2

𝐿 × 𝑅2

where all components are subsets of R – i.e. the allowed values on each wire are completely
unrelated to one another. Then the composite contract (9) takes the following, also independent
contract form

𝑅UAV =

(cid:40)𝑅2

𝐿 × 𝑅2

𝐿 ∩ 𝑅2
𝐷 )

𝐶 × (𝑅1
∅

if 𝑅3
if 𝑅3

𝐿 ∩ 𝑅1
𝐿 ∩ 𝑅1

𝐶 ≠ ∅ and 𝑅3
𝐶 = ∅ or 𝑅3

𝐶 ∩ 𝑅1

𝐷 ≠ ∅

𝐶 ∩ 𝑅1

𝐷 = ∅

(13)

The above formula expresses that the allowable tuples that can be observed on the composite
system are the 𝐿- and 𝐶-external input contracts for the two input wires, along with an intersection
of contracts for the output wire, subject to whether there exists a scenario where the contracts of
the intermediate wires match: if their intersection is non-empty, there exist appropriate values
that work for both contracts and the total system ‘runs’. Otherwise the composed contracts are
incompatible and the composite system fails to adhere to a contract, namely there is no guarantee
about its observable input and output values (expressed by the empty set contract) and possibly
the whole process fails.

We now proceed to a similar process to what we have seen before (Section 4.1), which in a
sense reverse-engineered the behavior of the subcomponents, given a composite behavior of the
total system using the system behavior algebra machinery. In this setting, given a specific desired
requirement 𝑅UAV on the composite system, we will identify possible contracts on the components
that produce that specific composite; once again we do not expect unique solution to this problem.
Suppose the envisioned composite contract on the behavioral representation of our example

UAV (Fig. 3) is

𝑅UAV = [0, 100] × [−20, +20] × [−35, +35]
This contract represents a possible requirement that the desired UAV pitch is no more or less than
20 degrees and the plane really must not pitch more or less than 35 degrees for a hypothetical safe
flight. As hypothetical environmental conditions, we assume air speed does not exceed 100 km/h.
Comparing the above composite contract against equation (13), we can first of all deduce that

𝐿 = [0, 100]
𝑅2

𝐶 = [−20, +20]
𝑅2

namely the external inputs for 𝐿 and 𝐶 are necessarily constrained by the ranges of the given
composite contract on those wires. Moreover we have that 𝑅1
𝐷 = [−35, 35] and also that
𝐿 ∩ 𝑅1
necessarily the intersections 𝑅3
𝐷 are non-empty – since the composite contract is

𝐶 and 𝑅3

𝐿 ∩ 𝑅2

𝐶 ∩ 𝑅1

22

indeed non-empty. Notice how all these intersections correspond to specific wiring connections or
splittings we performed between subcomponents for the initial UAV’s implementation.

Given these restrictions, we are free to choose contracts that satisfy them, for example

𝐷 = [−35, +35], 𝑅1
𝑅2

𝐿 = 𝑅3

𝐿 = 𝑅1

𝐶 = 𝑅3

𝐶 = 𝑅1

𝐷 = R

𝐷 and 𝑅1

The above choices are made to also dispose of ‘bad scenarios’ for the given interconnection of
the boxes. For example, choosing the opposite contracts for 𝑅2
𝐿 would be mathematically
correct since their intersection is still [−35, 35], but could lead to a real value of, say, 40 degrees
entering the sensor 𝐿 which would then violate its contract (that said "all my inputs on the first wire
will be less than 35"). Although in general, processes can be wired together as long as types match,
in the contract algebra setting it is implied (by the algebra machinery) that the only values passing
through an interconnected wire are those in the intersections of the individual (independent)
contracts – so long as the composite system does not ‘break’. It is important to realize that the
contract algebra describes the observable inputs and outputs on a running composite machine,
rather than ensures that the process runs: this has to be safeguarded by the designer also. This
discussion relates to future work regarding ‘total’ or ‘deterministic’ contracts.

5 ON UNIFICATION
Having manifested the wiring diagram formalism for behavior, architecture and requirements of
an UAV, we now summarize and further discuss how this categorical interpretation of cps models
leads to unification of these aspects of system design and analysis.

Starting with some cyber-physical process 𝑌 , we usually model its behavior, mathematically
described for example via some equations, and also the requirements it satisfies or should satisfy.
We earlier discussed Moore machines and linear time-invariant systems; there can be other algebras
of system behavior, 9 so here we generically speak of the ‘behavior algebra’ which is any one of
them, using the notation B. As we saw, categorically these are certain objects 𝐵𝑌 ∈ B (𝑌 ) of the
category of all the possible behaviors (Section 3.1), and similarly the requirements are objects
𝑅𝑌 ∈ C(𝑌 ) of the category of all contracts (Section 3.3) that could be associated to such a process,
via lax monoidal functors

B, C : W → Cat.
To formally discuss and capture the behavior and requirements in terms of subprocesses, the
designer first chooses some valid architecture of 𝑌 which is categorically expressed by choosing a
morphism 𝑓 : 𝑋 → 𝑌 in the category W, namely an element of the slice category W/𝑌 (Section 3.2).
Then the behavior algebra and requirements algebra, independently, produce assignments

𝑋

𝑓

𝑌

B (𝑋 )

B ( 𝑓 )

B (𝑌 )

C(𝑋 )

C (𝑓 )

C(𝑌 )

(14)

9For example, machines serve as an all-inclusive general system notion that allows us to compose systems of different
description [77, § 4].

23

The designer then decides on ‘pre-image’ objects 𝐵𝑋 ∈ B (𝑋 ) and 𝑅𝑋 ∈ C(𝑋 ) which, under these
functors on the right-hand side, produce the original composite behavior and requirement on 𝑌 . As
we saw, there could be multiple choices for 𝐵𝑋 and 𝑅𝑋 (Sections 4.1 and 4.3). Also, the designer can
decompose even further to subprocesses, on which the analysis carries on in the same formal way
(Section 4.2). Moreover, they may choose to go back and change the architecture to some alternative
implementation 𝑔 : 𝑍 → 𝑌 , if that is physically sensible and allows to easier obtain the end results.
Later on, using algorithms such tests could assist in deciding on the most optimal solutions.

On top of the above story, which summarizes the narrative of the current work, we now sketch
some additional connections between these two independent algebras of behavior and requirements,
which further clarify their formal relation.

First of all, there is an algebra map 10 𝛼 : B ⇒ C which assigns to each specific physical behavior
of a process 𝐵𝑌 ∈ B (𝑌 ), the maximally satisfied contract by it, 𝛼𝑌 (𝐵𝑌 ) ∈ C(𝑌 ); in [77, Prop. 5.2.15]
R is inhabited by the function 𝑓 (𝑥) = 6𝑥,
this is done in an abstract setting. Informally, if a box
its maximally satisfied contract is in effect {(𝑎, 6𝑎) | 𝑎 ∈ R} ⊆ R2. However, the system also satisfies
the contracts R × 6R or R × 3R, or even R × R as the maximum such. The fact that the assignment
B (𝑌 ) ∋ 𝐵𝑌 ↦→ 𝛼𝑌 (𝐵𝑌 ) ∈ C(𝑌 ) is an algebra map signifies in particular that the above mappings
(14) are part of a commutative square relating system behavior and requirements for a specific
wiring diagram 𝑓 : 𝑋 → 𝑌

𝑋R

B (𝑋 )

𝛼𝑋

C(𝑋 )

B ( 𝑓 )

C (𝑓 )

B (𝑌 )

𝛼𝑌

C(𝑌 )

Intuitively, this says that for a given system decomposition into subcomponents, first composing
the behaviors of the internal boxes using the behavior algebra and then talking about the contract
that composite satisfies is the same as first computing the maximal contracts the components
satisfy individually and then composing using the contract algebra. This provides extra flexibility
for passing between different models, not only for this specific algebra map example but also for
other maps relating different algebras that may be established.

Another way to combine the behavior B and requirements C algebra is to construct a new
algebra of contracted behaviors that, to each process placeholder 𝑌 assigns a pair of a physical
behavior along with some contract it satisfies. This allows us to compose using both algebras
simultaneously and choosing which information to look at; this abstract algebra is already defined
[77, Prop. 4.5.5] for a specific behavior algebra and provides a tool that allows us to essentially
relate two algebras via some desired condition inside their product.

The above sketched behavior and requirements formal connections, as well as the whole method-
ology presented in detail in this paper, shall be further developed to account for the crucial notion
of time, 11 particularly a compositional model of real-time computing for cps, which to this day
raises several challenges [32, 48, 49, 81].

6 RELATED WORK
Computational and physical modeling in the context of cps is well-studied [28, 69, 90]. However,
there is still a need for research in compositional methods for model-based system design [31, 84] and
particularly for a compositional cps theory that is able to model and simulate both the computational
and the physical aspects of cps [15, 25, 47], which can formally relate those necessary views.

10Formally, this is a monoidal natural transformation between the two lax monoidal functors [54, § XI].
11The abstract categorical framework where time is added to the wiring diagram model has been formally studied using
sheaves on real-time intervals [77, § 3].

24

Category theorists have worked extensively in the area of compositional systems. Among the pri-
mary results of that general program has been the relation of different types of models, for example,
abstracting and unifying automata and dynamical systems [6]. For further discussion and references
on alternative categorical approaches on systems theory, see Schultz et al. [77, § 1]. Furthermore,
the application of algebraic structures has made seminal contributions in behavioral specification
of programs [14] and modal logic [40], both of which show up later in control [33]. Category theory
has recently been used in mobility [87, 88], planning and scheduling [17], robotics [89], and security
assessment [9], which indicates it is a developing field within engineering.

Other recent work in systems theory proposes category theory as the solution to model federation
but lacks significant theoretical development. Hasuo [39], for example, provides much of the
context and reasoning for using category theory in system design through coalgebras but the work
represents a skeleton of what should be done. An older but significantly more fleshed out version
of coalgebraic modeling for cps was proposed by Matsikoudis and Lee [56], but only focuses on
modeling the behavioral view of transition systems. Additionally, category theory lends itself as a
possible quasi-formal approach to requirements management [35, 43]. Our framework is instead
formal, in the strict sense, and we use the contracts algebra, which has shown to be effective in cps.
The theory of contracts has had significant development, especially as applied to cps [13, 76],
including notions of contract composition [66]. Recently there are also concrete applications in
the form, for example, of a toolkit on top of SysML [30], which will make contracts increasingly
accessible to system designers. Contracts have been implemented as an end-to-end requirements
engineering framework, but more importantly have also been merged with linear temporal logic
(ltl) specifications that can compile down to contracts [63]; this idea could also be implemented
into our compositional cps theory. Our approach to contracts is more general than the often used
ag formalism. Specifically, in ag contracts, names and types of variables need to match, while the
categorical formulation only requires that types match. Examples of synthesis from a contract-based
design specification [36], show that it is possible to use our generalized version of contracts to adapt
control synthesis tools [42, 73] with our notion of modeling and simulation. Therefore, we would be
able to not only have composition among requirements, system behaviors, and system architectures
but we would also be able to produce a possible implementation that is compositionally constrained
at any given level; this would represent an improvement over approaches that only consider the
compositional verification of architecture models [24].

Hybrid systems is a well-established version of computational dynamical systems theory [4]
(another being timed process algebras [21] or more recently model interfaces [70]). Ames (as well
as Tabuada et al. to some extent [82, 83]) did develop a categorical theory of hybrid systems [5],
which could be used to relate or otherwise use results from the well-established formalism of hybrid
systems in our proposed framework as future work, but also the opposite; potentially strengthening
notions of composition [3, 20] in hybrid systems from category theory. These problems have been
so far mostly tackled from a theoretical sense categorically without yet directly relating to systems
science [26]. If we desired the behavior to be modeled within the hybrid system paradigm we
are able to directly import those results within our framework. In the future, by incorporating
this hybrid systems formalism it is possible for the categorical framework to use compositional
structures into standard analysis methods, such as reachability analysis [16], modular smt-based
hybrid systems analysis [8], and passivity/stability analysis [44].

The congruence between logic and category theory also means this framework could potentially
be used to augment logic-based approaches to cps design, such as contract composition in the
KeYmaera X tool [59] or hybrid Event-B [11]. The inverse also holds true. Our framework could
become richer or manage richer semantics by incorporating a logical framework in addition to the
behavioral and requirements semantics presented in this paper while keeping composition explicit

25

within the design problem or further assist with the separation of computation and physics present
in cps [53]. The augmentation of compositional cps theory with logic can also combat the problem
of specification mismatching throughout the lifecycle of the system and its associated models [61].
Compositional cps theory can assist with model conformance [71] and model federation at
large [37]. Complementary works using category theory have shown small but useful examples of
categorical systems modeling and how they can facilitate model conformance in cps [10, 18, 19, 62].

7 CONCLUSION
The forthcoming SysML V2 standard is attempting to bridge the gap between requirement, be-
havioral, and structural models, showing an increasing need for unification and scalability of
models in system design [67]. In this paper, we present a categorical framework to achieve such a
unification of models and simulation tools as an alternative to current approaches, such as domain
metamodeling and (semi-)manual model transformations. Through the categorical framework we
also show that there is a functorial relationship between the architectural and behavioral modeling
domains, which unifies what was previously a distinct difference between these domains. We show
that there is a multidimensionality to modeling abstraction and manage it formally through the
preceding formalism.

An additional benefit of category theory in this domain is its closeness to execution by means
of dependent typed languages, which in the future could allow for a merge between modeling
and code that traverses throughout the full lifecycle of the system. This would lead to further
unification in the form of managing algebras of programming languages in addition to the algebras
we have implemented in this paper, thereby allowing for further options in regards to both models of
computation for cps and flexibility in synthesizing systems from models. These stages might include
requirements generation, control law simulation, and finally architectural design and deployment.
In the domain of cps we achieve that by unifying the controls and computation and requirement
views without inventing a new formalism but rather by zooming in and out of different layers of
abstraction with a formal composition rule. Furthermore, with this approach we are able to relate
static views of the system with their dynamics, or otherwise executable, model representations.

The use of wiring diagrams already provides both an appealing and familiar syntax (that of
boxes and arrows) as well as algebraic semantics; that is, the perspective of systems as algebras,
which formalizes mathematically the diagrammatic reasoning already used in engineering. We
posit that as systems become increasingly complex such semantics will be important to assess
a system’s dependable, safe, and secure operation. These semantics do not need to be visible to
the practitioner but provide a flexible scaffolding for interchanging between modeling paradigms
and metrics within a modeling language. Ultimately, the algebraic view of systems models has the
potential of producing more scalable modeling efforts.

ACKNOWLEDGMENTS
G. Bakirtzis and C.H. Fleming are partially supported through serc under usdod Contract HQ0034-
13-D-0004, nasa under research grant NNX16AK47A, and nsf under grant No. 1739333.

C. Vasilakopoulou is supported by the General Secretariat for Research and Technology (gsrt)

and the Hellenic Foundation for Research and Innovation (hfri).

REFERENCES
[1] S. Abramsky and B. Coecke. 2009. Categorical quantum mechanics. In Handbook of Quantum Logic and Quantum

Structures. Elsevier. https://doi.org/10.1016/B978-0-444-52869-8.50010-4

[2] F. Allgöwer, J. B. de Sousa, J. Kapinski, P. Mosterman, J. Oehlerking, P. Panciatici, M. Prandini, A. Rajhans, P. Tabuada,
and P. Wenzelburger. 2019. Position paper on the challenges posed by modern applications to cyber-physical systems

26

theory. Nonlinear Analysis: Hybrid Systems (2019). https://doi.org/10.1016/j.nahs.2019.05.007

[3] R. Alur, R. Grosu, I. Lee, and O. Sokolsky. 2006. Compositional modeling and refinement for hierarchical hybrid
systems. Journal of Logical and Algebraic Methods in Programming (2006). https://doi.org/10.1016/j.jlap.2005.10.004
[4] R. Alur, T. A. Henzinger, G. Lafferriere, and G. J. Pappas. 2000. Discrete abstractions of hybrid systems. Proc. IEEE

(2000). https://doi.org/10.1109/5.871304

[5] A. D. Ames. 2006. A categorical theory of hybrid systems. Ph.D. Dissertation. University of California, Berkeley.
[6] M. A. Arbib and E. G. Manes. 1980. Machines in a category. Journal of Pure and Applied Algebra (1980). https:

//doi.org/10.1016/0022-4049(80)90090-0

[7] P. Asare, G. Bakirtzis, R. Bernard, D. Broman, E. Lee, G. Prinsloo, M. Torngren, and S. Sunder. 2020. Cyber-Physical

Systems – A Concept Map. https://cyberphysicalsystems.org.

[8] K. Bae and S. Gao. 2017. Modular SMT-based analysis of nonlinear hybrid systems. In Proceedings of the 2017 Formal

Methods in Computer Aided Design (FMCAD 2017). IEEE. https://doi.org/10.23919/FMCAD.2017.8102258

[9] G. Bakirtzis, F. Genovese, and C. H. Fleming. 2021. Yoneda Hacking: The Algebra of Attacker Actions. (2021).

arXiv:2103.00044 [cs.CR].

[10] G. Bakirtzis, C. Vasilakopoulou, and C. H. Fleming. 2020. Compositional Cyber-Physical Systems Modeling. In
Proceedings of the 2020 Applied Category Theory Conference (ACT 2020) (Electronic Proceedings in Theoretical Computer
Science). Open Publishing Association. https://doi.org/10.4204/EPTCS.333.9

[11] R. Banach, M. J. Butler, S. Qin, and H. Zhu. 2017. Core hybrid Event-B II: Multiple cooperating hybrid Event-B machines.

Sci. Comput. Program. (2017). https://doi.org/10.1016/j.scico.2016.12.003

[12] A. Benveniste, B. Caillaud, D. Nickovic, R. Passerone, J.-B. Raclet, P. Reinkemeier, A. L. Sangiovanni-Vincentelli, W.
Damm, T. A. Henzinger, and K. G. Larsen. 2012. Contracts for System Design. Research Report, RR-8147, INRIA (2012).
[13] A. Benveniste, B. Caillaud, D. Nickovic, R. Passerone, J.-B. Raclet, P. Reinkemeier, A. L. Sangiovanni-Vincentelli, W.
Damm, T. A. Henzinger, and K. G. Larsen. 2018. Contracts for System Design. Foundations and Trends in Electronic
Design Automation (2018). https://doi.org/10.1561/1000000053

[14] M. Bidoit and R. Hennicker. 1995. Proving the correctness of behavioural implementations. In Proceedings of the
1995 International Conference on Algebraic Methodology and Software Technology (AMAST 1995). Springer. https:
//doi.org/10.1007/3-540-60043-4_51

[15] S. Bliudze, S. Furic, J. Sifakis, and A. Viel. 2019. Rigorous design of cyber-physical systems – Linking physicality and

computation. Software and Systems Modeling (2019). https://doi.org/10.1007/s10270-017-0642-5

[16] S. Bogomolov, M. Forets, G. Frehse, K. Potomkin, and C. Schilling. 2020. Reachability Analysis of Linear Hybrid
Systems via Block Decomposition. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems
(2020). https://doi.org/10.1109/TCAD.2020.3012859

[17] S. Breiner, P. Denno, and E. Subrahmanian. 2020. Categories for Planning and Scheduling. Notices of the American

Mathematical Society (2020). https://doi.org/10.1090/noti2186

[18] S. Breiner, O. Marie-Rose, B. S. Pollard, and E. Subrahmanian. 2020. Operadic diagnosis in hierarchical systems. In

Proceedings of the 2nd Applied Category Theory Conference (ACT 2019). https://doi.org/10.4204/EPTCS.323.5

[19] S. Breiner, R. D. Sriram, and E. Subrahmanian. 2019. Compositional Models for Complex Systems.
Intelligence for the Internet of Everything. Elsevier. https://doi.org/10.1016/B978-0-12-817636-8.00013-2

In Artificial

[20] D. Bresolin, P. Collins, L. Geretti, R. Segala, T. Villa, and S. Z. Gonzalez. 2020. A computable and compositional
semantics for hybrid automata. In Proceedings of the 23rd ACM International Conference on Hybrid Systems: Computation
and Control (HSCC 2020). ACM. https://doi.org/10.1145/3365365.3382202

[21] M. Broy. 1993. Functional specification of time-sensitive communicating systems. ACM Transactions on Software

Engineering and Methodology (1993). https://doi.org/10.1145/151299.151302

[22] J. Buck, S. Ha, E. A. Lee, and D. G. Messerschmitt. 2001. Ptolemy: A framework for simulating and prototyping

heterogeneous systems. In Readings in hardware/software co-design. ACM.

[23] B. Coecke. 2010. Quantum picturalism. Contemporary physics (2010). https://doi.org/10.1080/00107510903257624
[24] Darren Cofer, Andrew Gacek, Steven Miller, Michael W Whalen, Brian LaValley, and Lui Sha. 2012. Compositional
verification of architectural models. In Proceedings of the 4th International Symposium on NASA Formal Methods (NFM
2012) (Lecture Notes in Computer Science). Springer. https://doi.org/10.1007/978-3-642-28891-3_13

[25] F. Cremona, M. Lohstroh, D. Broman, E. A. Lee, M. Masin, and S. Tripakis. 2019. Hybrid co-simulation: it’s about time.

Software & Systems Modeling (2019). https://doi.org/10.1007/s10270-017-0633-6

[26] J. Culbertson, P. Gustafson, D. E. Koditschek, and P. F. Stiller. 2020. Formal composition of hybrid systems. arXiv

1911.01267 [math.CT].

[27] V. C. V. De Paiva. 1990. The Dialectica Categories. Ph.D. Dissertation. University of Cambridge, UK.
[28] P. Derler, E. A. Lee, and A. L. Sangiovanni-Vincentelli. 2012. Modeling Cyber-Physical Systems. Proc. IEEE (2012).

https://doi.org/10.1109/JPROC.2011.2160929

27

[29] Z. Diskin, T. Maibaum, and K. Czarnecki. 2015. A Model Management Imperative: Being Graphical Is Not Sufficient,
You Have to Be Categorical. In Proceedings of the 11th European Conference on Modelling Foundations and Applications
(ECMFA@STAF 2015). https://doi.org/10.1007/978-3-319-21151-0_11

[30] I. Dragomir, I. Ober, and C. Percebois. 2017. Contract-based modeling and verification of timed safety requirements

within SysML. Software & Systems Modeling (2017). https://doi.org/10.1007/s10270-015-0481-1

[31] F. Durán, R. Heinrich, D. Pérez-Palacín, C. L. Talcott, and S. Zschaler. 2020. Composing Model-Based Analysis Tools

(Dagstuhl Seminar 19481). Dagstuhl Reports (2020). https://doi.org/10.4230/DagRep.9.11.97

[32] S. A. Edwards and E. A. Lee. 2007. The case for the precision timed (PRET) machine. In Proceedings of the 44th Annual

Design Automation Conference (DAC).

[33] G. E. Fainekos, H. Kress-Gazit, and G. J. Pappas. 2005. Temporal logic motion planning for mobile robots. In Proceedings
of the 2005 IEEE International Conference on Robotics and Automation (ICRA 2005). IEEE. https://doi.org/10.1109/ROBOT.
2005.1570410

[34] J. N. Foster, M. B. Greenwald, J. T. Moore, B. C. Pierce, and A. Schmitt. 2007. Combinators for Bidirectional Tree
Transformations: A Linguistic Approach to the View-Update Problem. ACM Transactions on Programming Languages
and Systems (2007). https://doi.org/10.1145/1232420.1232424

[35] S. Gebreyohannes, W. Edmonson, and A. Esterline. 2018. Formalization of the responsive and formal design process
using category theory. In Proceedings of the 2018 Annual IEEE International Systems Conference (SysCon 2018). IEEE.
https://doi.org/10.1109/SYSCON.2018.8369508

[36] K. Ghasemi, S. Sadraddini, and C. Belta. 2020. Compositional synthesis via a convex parameterization of assume-
guarantee contracts. In Proceedings of the 23rd ACM International Conference on Hybrid Systems: Computation and
Control (HSCC 2020). ACM. https://doi.org/10.1145/3365365.3382212

[37] F. R. Golra, F. Dagnat, J. Souquières, I. Sayar, and S. Guerin. 2018. Bridging the gap between informal requirements and
formal specifications using model federation. In Proceedings of the 16th International Conference on Software Engineering
and Formal Methods (SEFM@STAF 2018). Springer. https://doi.org/10.1007/978-3-319-92970-5_4

[38] J. Hansen and R. Ghrist. 2020. Opinion Dynamics on Discourse Sheaves. arXiv:2005.12798 [math.DS] (2020).
[39] I. Hasuo. 2017. Metamathematics for Systems Design: Comprehensive Transfer of Formal Methods Techniques to

Cyber-Physical Systems. New Generation Computing (2017). https://doi.org/10.1007/s00354-017-0023-1

[40] J. Hughes. 2001. Modal operators for coequations. In Proceedings of the 2001 Coalgebraic Methods in Computer Science
(CMCS 2001) (Electronic Notes in Theoretical Computer Science). Elsevier. https://doi.org/10.1016/S1571-0661(04)80909-5
[41] A. Joyal and R. Street. 1993. Braided tensor categories. Advances in Mathematics (1993). https://doi.org/10.1006/aima.

1993.1055

[42] M. Mazo Jr., A. Davitian, and P. Tabuada. 2010. PESSOA: A Tool for Embedded Controller Synthesis. In Proceedings
of the 22nd International Conference on Computer Aided Verification (CAV 2010) (Lecture Notes in Computer Science).
Springer. https://doi.org/10.1007/978-3-642-14295-6_49

[43] N. Kibret, W. W. Edmonson, and S. Gebreyohannes. 2019. Category Theoretic Based Formalization of the Verifiable
Design Process. In Proceedings of the 2019 IEEE International Systems Conference (SysCon 2019). IEEE. https://doi.org/
10.1109/SYSCON.2019.8836804

[44] X. D. Koutsoukos, N. Kottenstette, J. F. Hall, E. Eyisi, H. LeBlanc, J. Porter, and J. Sztipanovits. 2012. A passivity approach
for model-based compositional design of networked control systems. ACM Transactions on Embedded Computing
Systems (2012). https://doi.org/10.1145/2362336.2362342

[45] F. W. Lawvere and S. H. Schanuel. 2009. Conceptual mathematics: a first introduction to categories. Cambridge University

Press.

[46] T. T. H. Le, R. Passerone, U. Fahrenberg, and A. Legay. 2016. Contract-Based Requirement Modularization via Synthesis
of Correct Decompositions. ACM Transactions on Embedded Computing Systems (2016). https://doi.org/10.1145/2885752
[47] E. A. Lee. 2006. Cyber-physical systems – Are computing foundations adequate. Position Paper for NSF Workshop on

Cyber-Physical Systems: Research Motivation, Techniques and Roadmap.

[48] E. A. Lee. 2016. Fundamental limits of cyber-physical systems modeling. ACM Transactions on Cyber-Physical Systems

(2016). https://doi.org/10.1145/2912149

[49] E. A. Lee. 2018. What Is Real Time Computing? A Personal View. IEEE Design & Test (2018). https://doi.org/10.1109/

MDAT.2017.2766560

[50] T. Leinster. 2014. Basic Category Theory. Cambridge University Press. https://doi.org/10.1017/CBO9781107360068
[51] N. G. Leveson. 2011. Engineering a safer world: Systems thinking applied to safety. MIT Press.
[52] M. Lohstroh, C. Menard, A. Schulz-Rosengarten, M. Weber, J. Castrillón, and E. A. Lee. 2020. A Language for
Deterministic Coordination Across Multiple Timelines. In Proceedings of the Forum for Specification and Design
Languages (FDL 2020). IEEE. https://doi.org/10.1109/FDL50818.2020.9232939

[53] S. Lunel, S. Mitsch, B. Boyer, and J.-P. Talpin. 2019. Parallel Composition and Modular Verification of Computer
Controlled Systems in Differential Dynamic Logic. In Proceedings of the Third World Congress of Formal Methods (FM

28

2019) (Lecture Notes in Computer Science). Springer. https://doi.org/10.1007/978-3-030-30942-8_22

[54] S. Mac Lane. 1998. Categories for the working mathematician. Springer.
[55] G. Masetti, S. Chiaradonna, F. Di Giandomenico, B. Feddersen, and W. H. Sanders. 2018. An Efficient Strategy for
Model Composition in the Möbius Modeling Environment. In Proceedings of the 14th European Dependable Computing
Conference (EDCC 2018). IEEE Computer Society. https://doi.org/10.1109/EDCC.2018.00029

[56] E. Matsikoudis and E. A. Lee. 2012. From Transitions to Executions. In Revised Selected Papers from the 11th International
Workshop Coalgebraic Methods in Computer Science (CMCS 2012), Colocated with ETAPS 2012 (Lecture Notes in Computer
Science). Springer. https://doi.org/10.1007/978-3-642-32784-1_10

[57] M. D. Mesarovic and Y. Takahara. 1989. Abstract Systems Theory. Springer.
[58] B. Messner, D. Tilbury, R. Hill, and J. D. Taylor. 2020.

Control Tutorials for Matlab and Simulink: Air-
craft Pitch. https://web.archive.org/web/20200509164711/http://ctms.engin.umich.edu/CTMS/index.php?example=
AircraftPitch&section=SystemModeling.

[59] A. Müller, S. Mitsch, W. Retschitzegger, W. Schwinger, and A. Platzer. 2018. Tactical contract composition for
hybrid system component verification. International Journal on Software Tools for Technology Transfer (2018). https:
//doi.org/10.1007/s10009-018-0502-9

[60] B. A. Myers. 1990. Taxonomies of visual programming and program visualization. Journal of Visual Languages &

Computing (1990).

[61] L. V. Nguyen, K. A. Hoque, S. Bak, S. Drager, and T. T. Johnson. 2018. Cyber-Physical Specification Mismatches. ACM

Transactions on Cyber-Physical Systems (2018). https://doi.org/10.1145/3170500

[62] J. S. Nolan, B. S. Pollard, S. Breiner, D. Anand, and E. Subrahmanian. 2020. Compositional Models for Power Systems.
In Proceedings of the 2nd Applied Category Theory Conference (ACT 2019) (Electronic Proceedings in Theoretical Computer
Science). https://doi.org/10.4204/EPTCS.323.10

[63] P. Nuzzo, M. Lora, Y. A. Feldman, and A. L. Sangiovanni-Vincentelli. 2018. CHASE: Contract-based requirement
engineering for cyber-physical system design. In Proceedings of the 2018 Design, Automation & Test in Europe Conference
& Exhibition (DATE 2018). IEEE. https://doi.org/10.23919/DATE.2018.8342122

[64] P. Nuzzo and A. L. Sangiovanni-Vincentelli. 2018. Hierarchical System Design with Vertical Contracts. In Principles of
Modeling - Essays Dedicated to Edward A. Lee on the Occasion of His 60th Birthday (Lecture Notes in Computer Science).
Springer. https://doi.org/10.1007/978-3-319-95246-8_22

[65] P. Nuzzo, A. L. Sangiovanni-Vincentelli, D. Bresolin, L. Geretti, and T. Villa. 2015. A Platform-Based Design Methodology
With Contracts and Related Tools for the Design of Cyber-Physical Systems. Proc. IEEE (2015). https://doi.org/10.
1109/JPROC.2015.2453253

[66] C. Oh, E. Kang, S. Shiraishi, and P. Nuzzo. 2019. Optimizing Assume-Guarantee Contracts for Cyber-Physical
System Design. In Proceedings of the Design, Automation & Test in Europe Conference & Exhibition (DATE 2019). IEEE.
https://doi.org/10.23919/DATE.2019.8715284

[67] OMG Systems Modeling Language. 2019. Systems Modeling Language (SysML®) v2 Request For Proposal (RFP). Technical

Report. Object Management Group (OMG).

[68] E. Patterson, D. I. Spivak, and D. Vagner. 2021. Wiring diagrams as normal forms for computing in symmetric monoidal

categories. Electronic Proceedings in Theoretical Computer Science (2021). https://doi.org/10.4204/eptcs.333.4

[69] A. Platzer. 2019. The Logical Path to Autonomous Cyber-Physical Systems. In Proceedings of the 16th International
Conference on Quantitative Evaluation of Systems (QEST 2019) (Lecture Notes in Computer Science). Springer. https:
//doi.org/10.1007/978-3-030-30281-8_2

[70] J.-B. Raclet, É. Badouel, A. Benveniste, B. Caillaud, A. Legay, and R. Passerone. 2011. A Modal Interface Theory for

Component-based Design. Fundamenta Informaticae (2011). https://doi.org/10.3233/FI-2011-416

[71] H. Roehm, J. Oehlerking, M. Woehrle, and M. Althoff. 2019. Model Conformance for Cyber-Physical Systems: A Survey.

ACM Transactions on Cyber-Physical Systems (2019). https://doi.org/10.1145/3306157

[72] Í. Í. Romeo, A. L. Sangiovanni-Vincentelli, C.-W. Lin, and E. Kang. 2018. Quotient for Assume-Guarantee Contracts. In
Proceedings of the 16th ACM/IEEE International Conference on Formal Methods and Models for System Design (MEMOCODE
2018). IEEE. https://doi.org/10.1109/MEMCOD.2018.8556872

[73] M. Rungger and P. Tabuada. 2014. Abstracting and refining robustness for cyber-physical systems. In Proceedings of
the 17th International Conference on Hybrid Systems: Computation and Control (HSCC). https://doi.org/10.1145/2562059.
2562133

[74] Dylan Rupel and David I. Spivak. 2013. The operad of temporal wiring diagrams: formalizing a graphical language for

discrete-time processes. arXiv:arXiv:1307.6894

[75] J. Rushby. 2011. Composing safe systems. In Revised Papers from the International Workshop on Formal Aspects of

Component Software (FACS 2011). Springer. https://doi.org/10.1007/978-3-642-35743-5_2

[76] A. L. Sangiovanni-Vincentelli, W. Damm, and R. Passerone. 2012. Taming Dr. Frankenstein: Contract-Based Design for

Cyber-Physical Systems. European Journal of Control (2012). https://doi.org/10.3166/ejc.18.217-238

29

[77] P. Schultz, D. I. Spivak, and C. Vasilakopoulou. 2019. Dynamical systems and sheaves. Applied Categorical Structures

(2019). https://doi.org/DOI:10.1007/s10485-019-09565

[78] D. Spivak. 2016. The steady states of coupled dynamical systems compose according to matrix arithmetic. (2016).

arXiv:1512.00802 [math.CT].

[79] D. I. Spivak. 2013. The operad of wiring diagrams: formalizing a graphical language for databases, recursion, and

plug-and-play circuits. (2013). arXiv:1305.0297 [cs.DB].
[80] D. I. Spivak. 2014. Category theory for the sciences. MIT Press.
[81] J. A. Stankovic. 1988. Misconceptions about Real-Time Computing: A Serious Problem for next-Generation Systems.

Computer (1988). https://doi.org/10.1109/2.7053

[82] P. Tabuada. 2008. Controller synthesis for bisimulation equivalence. Systems & Control Letters (2008).

https:

//doi.org/10.1016/j.sysconle.2007.11.005

[83] P. Tabuada, G. J. Pappas, and P. U. Lima. 2002. Composing Abstractions of Hybrid Systems. In Proceedings of the 5th
International Workshop on Hybrid Systems: Computation and Control (HSCC 2002) (Lecture Notes in Computer Science).
Springer. https://doi.org/10.1007/3-540-45873-5_34

[84] S. Tripakis. 2016. Compositionality in the Science of System Design. Proc. IEEE (2016). https://doi.org/10.1109/JPROC.

2015.2510366

[85] D. Vagner, D. I. Spivak, and E. Lerman. 2015. Algebras of open dynamical systems on the operad of wiring diagrams.

Theory and Applications of Categories (2015).

[86] J. C. Willems. 2007. The behavioral approach to open and interconnected systems. IEEE Control Systems Magazine

(2007). https://doi.org/10.1109/MCS.2007.906923

[87] G. Zardini, N. Lanzetti, A. Censi, E. Frazzoli, and Marco Pavone. 2020. Co-Design to Enable User-Friendly Tools to

Assess the Impact of Future Mobility Solutions. arXiv 2008.08975 [eess.SY].

[88] G. Zardini, N. Lanzetti, M. Salazar, A. Censi, E. Frazzoli, and M. Pavone. 2020. On the Co-Design of AV-Enabled
Mobility Systems. In Proceedings of the 23rd IEEE International Conference on Intelligent Transportation Systems (ITSC
2020). IEEE. https://doi.org/10.1109/ITSC45102.2020.9294499

[89] G. Zardini, D. Milojevic, A. Censi, and E. Frazzoli. 2021. A Formal Approach to the Co-Design of Embodied Intelligence.

arXiv 2011.10756 [cs.RO].

[90] Q. Zhu and A. L. Sangiovanni-Vincentelli. 2018. Codesign Methodologies and Tools for Cyber-Physical Systems. Proc.

IEEE (2018). https://doi.org/10.1109/JPROC.2018.2864271

A NOMENCLATURE
Here we summarize some of the symbols we use and their meaning in category theory as a quick
guide for working engineers to effectively navigate the preceding formalism.

𝐵
𝑔
𝐷

commutative diagram standing for equation 𝑔 ◦ 𝑓 = 𝑘 ◦ ℎ

C

1

𝑓 or

𝑓
−→

𝑔 ◦ 𝑓
𝑓

𝐴
ℎ
𝐶

𝑘

(cid:27)

(V, ⊗, 𝐼 )
𝐹
−→

𝐹 or

𝐹 (𝐴) or 𝐹𝐴

𝐹 (𝑓 ) or 𝐹 𝑓

a generic category

identity morphism

morphism in a category

composition (right to left)

isomorphism

a generic monoidal category

functor

functor application on objects

functor application on morphisms

30

C/𝐶

Set

Lin

×

slice category over object 𝐶

the category of sets and functions

the category of linear spaces and linear maps

cartesian product of sets (or linear spaces)

Δ : 𝑋 →𝑋 ×𝑋

duplication function

Cat

W

WLin

M

L

C

B

the category of categories and functors

the category of labelled boxes and wiring diagrams (with types in Set)

the category of labelled boxes and wiring diagrams (with types in Lin)

the algebra of Moore machines; a lax monoidal functor W→Cat

the algebra of linear time-invariant systems; a lax monoidal functor WLin→Cat

the algebra of (static) contracts

a generic behavior algebra; could be M or L (among others)

B CONTRACT PULLBACK
Regarding the static contract algebra (Section 3.3.1), the functor C𝑓 : C(𝑋 ) → C(𝑌 ) for a wiring
diagram 𝑓 : 𝑋 → 𝑌 (1) assigns a contract 𝑅𝑋 ⊆ 𝑋in × 𝑋out on the inside box to a contract 𝑅𝑋 ⊆
𝑋in × 𝑋out on the outside box, following a two-step procedure:

𝑃

⌟

𝑅𝑋

𝑅𝑌

𝑌in × 𝑋out

𝑋in × 𝑋out

(𝑓in,𝜋2)

(15)

1×𝑓out

𝑌in × 𝑌out

First, we compute the pullback – a limit of a diagram of two morphisms with common codomain [50,
5.1.16] – of the relation 𝑅𝑋 along the function (𝑓in, 𝜋2) which is defined by 𝑌in × 𝑋out ∋ (𝑦, 𝑥 ′) ↦→
(𝑓in (𝑦, 𝑥 ′), 𝑥 ′) ∈ 𝑋in × 𝑋out. The explicit description of that pullback in Set is

𝑃 = {(𝑦, 𝑥 ′) | (𝑓in (𝑦, 𝑥 ′), 𝑥 ′) ∈ 𝑅𝑋 }
namely those pairs of 𝑌 -inputs and 𝑋 -outputs which the bottom function actually maps to elements
of the contract 𝑅𝑋 . Second, we take the image factorization of the inclusion 𝑃 ⊆ 𝑌in × 𝑋out post-
composed with the function 1 × 𝑓out that maps some (𝑦, 𝑥 ′) to the pair (𝑦, 𝑓out (𝑥 ′)). The image of a
function is the subset of its codomain where all elements of the domain get mapped to, namely for
an arbitrary 𝑔 : 𝐴 → 𝐵, Im(𝑔) = {𝑏 ∈ 𝐵 | ∃𝑎 ∈ 𝐴 such that 𝑔(𝑎) = 𝑏}. In the end, using the above
constructions of the two-step process exhibited in (15), the explicit description of the resulting
contract is precisely equation (8).

31

