Fundamental Limits of Private User
Authentication

Narges Kazempour, Mahtab Mirmohseni and Mohammad Reza Aref

1

2
2
0
2

p
e
S
2
1

]
T
I
.
s
c
[

5
v
7
2
9
5
0
.
1
0
9
1
:
v
i
X
r
a

Abstract—Most of the security services in the connected world of cyber-physical systems necessitate authenticating a large number of
nodes privately. In this paper, the private authentication problem is considered which consists of a certiﬁcate authority, a veriﬁer (or
some veriﬁers), many legitimate users (provers), and an arbitrary number of attackers. Each legitimate user wants to be authenticated
(using his personal key) by the veriﬁer(s), while simultaneously staying completely anonymous (even to the veriﬁer). On the other hand,
an attacker must fail to be authenticated. We analyze this problem from an information-theoretical perspective and propose a general
interactive information-theoretic model for the problem. As a metric to measure the reliability, we consider the normalized total key rate
whose maximization has a trade-off with establishing privacy. The problem is considered in two different scenarios: single-server
scenario (only one veriﬁer is considered, which all the provers are connected to) and multi-server scenario (N veriﬁers are assumed,
where each veriﬁer is connected to a subset of users). For both scenarios, two regimes are considered: ﬁnite size regime (i.e., the
variables are elements of a ﬁnite ﬁeld) and asymptotic regime (i.e., the variables are considered to have large enough length). We
propose achievable schemes that satisfy the completeness, soundness, and privacy properties in both single-server and multi-server
scenarios in all cases. In the ﬁnite size regime, the main idea is to generate the authentication keys according to a secret sharing
scheme. We show that the proposed scheme in the special case of multi-server authentication in the ﬁnite size regime is optimal. In the
asymptotic regime, we use a random binning based scheme that relies on the joint typicality to generate the authentication keys.
Moreover, providing the converse proof, we show that our scheme achieves capacity in the asymptotic regime both in the single-server
and multi-server scenarios.

(cid:70)

1 INTRODUCTION

W ITH the growth of cyber-physical systems, authen-

tication is an essential security feature in commu-
nication systems. Based on the application, authentication
protocols may authenticate the user and/or the message.
In fact, an authentication protocol seeks the answer to who
sends the data is the user authorized to access the service, or
whether the message received is unaltered. The traditional
cryptography-based methods for user authentication are
mostly based on key validation, e.g., public key or password
based authentication; while the signed hash of the message
is traditionally used for the message authentication.

The nature of user authentication requires revealing the
user’s identity, at least partly. However, nowadays, by in-
creasing privacy concerns, users wish to stay anonymous
when sending authentication requests. Anonymity ensures
that a user may access a resource or service without disclos-
ing his identity. In other words, anonymity of a user means
that the user is not identiﬁable (not uniquely characterized)
within a speciﬁc set of users [2]. This has many emerging
applications such as vehicular networks [3], cloud comput-
ing, distributed servers [4], crypto-currencies and services
on blockchain [5]. In this paper, we study the inherent con-
tradiction between authentication and privacy, referred to as
the private authentication (PA) problem, where a legitimate
user while passing the authentication, does not reveal his
identity even to the server (by hiding in a group of users),
but an illegitimate user (attacker) fails to be authenticated.

• N. Kazempour, M. Mirmohseni, and M. Aref are with the Information
Systems and Security Lab (ISSL), Department of Electrical Engineering,
Sharif University of Technology, Tehran, Iran,
E-mail: Email: n.kazempour@ee.sharif.edu,{mirmohseni,aref}@sharif.edu

The material in this paper has been presented in part at ITW 2019 [1].

In practice, the PA problem is encountered when the server
should not distinguish the one who requests the service
with which key is authenticated [3]. There are cryptographic
methods such as algorithms based on zero-knowledge proof
[6], using tokens for private authentication [7], and other
cryptographic protocols, known as privacy-aware or anony-
mous authentication [8], [9]. However, to the best of our
knowledge, the fundamental limits of the PA problem have
not been studied.

With no privacy concern, the authentication problem has
been studied fundamentally in works such as [10], [11], [12],
[13], [14]. In [10], Simmons considers message authentica-
tion over a noiseless channel with a shared key between
peers of authentication, where the lower bounds on the
success probability of impersonation attack and substitution
attack are established. In [11], the results of [10] have been
extended to noisy channels. In [12], hypothesis testing is
proposed to derive generalized lower bounds on the success
probability of impersonation and substitution attacks. The
idea of using characteristics of the wireless channel for
authentication, instead of shared key, has been analyzed in
works such as [13], [14].

Privacy constraints from an information theory perspec-
tive have been studied in some problems [15], [16], [17], [18],
[19]. With no connection to the authentication problem, [15]
derives the capacity of private information retrieval, and
[16] studies privacy in database systems. The privacy leak-
age rate is studied in works such as [17], [18], [19] (biometric
security systems). In biometric security systems, a user
wishes to authenticate himself by some biometric character-
istics, such as ﬁngerprint, called enrollment sequence. The
privacy constraint is to avoid leakage of information about
the enrollment sequence. [17], [18], [19] derive the trade-off

 
 
 
 
 
 
between the secret key rate, the secret key is generated from
the enrollment sequence, and the privacy leakage.

Our contributions.

In this paper, we propose an
the user-
interactive
information-theoretic
setup for
authentication problem with privacy constraint. We con-
sider a PA problem consisting of a certiﬁcate authority (CA),
a single veriﬁer or multiple veriﬁers (e.g., servers), many
legitimate users, and an arbitrary number of attackers. A
legitimate user wishes to be authenticated to the veriﬁer to
gain access to a service, while he wants to stay anonymous
to anyone observing the authentication process (in particu-
lar the veriﬁer). An attacker wants to impersonate himself
as a legitimate user and gain unauthorized access to the
service. The veriﬁer(s) wants to understand that the user,
who requests authentication (prover), either is legitimate or
an attacker. We assume semi-honest veriﬁers; they follow
the protocol but they are curious about the identity of the
provers. CA is an entity that shares correlated randomness
between the veriﬁer(s) and the legitimate users. This ran-
domness can be used by the veriﬁer(s) in the process of
authentication to distinguish an attacker from a legitimate
user. The case of multiple veriﬁers models the scenarios
where a user wishes to access different services from dif-
ferent servers using only one single key [20].

In an authentication protocol, two conditions should be
considered: the legitimate user who follows the protocol
must pass the authentication (completeness condition), and
an attacker must fail to authenticate (soundness condition).
In a private authentication protocol, the privacy condition
must also be satisﬁed meaning that the legitimate user
stays anonymous, i.e., the veriﬁer(s) cannot distinguish the
legitimate users’ identities. In addition, it is desirable that
the exposure of the key of a legitimate user releases as
little information about the other keys as possible. Thus, we
consider a reliability metric deﬁned as the normalized total
key rate of the users. The higher the normalized total key
rate, the more reliable the private authentication protocol.

As a solution to the above problem, we propose general
interactive information-theoretic protocols. Our proposed
PA protocols are considered in two scenarios: single-server
and multi-server scenarios. In the single-server scenario,
only one veriﬁer is assumed, connected to all users. In the
multi-server scenario, N veriﬁers are assumed, such that a
subset of the users are connected to each veriﬁer. For this
scenario, we study two cases: (i) Individual authentication,
where each veriﬁer privately authenticates the users who
are connected to him (same as the single-server scenario). (ii)
Distributed authentication, where the process of privately
authenticating the user is done distributively by the veriﬁers
that are connected to the user, by collaboratively sending the
helper data.

Both single-server and multi-server scenarios are ana-
lyzed in two regimes: ﬁnite size and asymptotic regimes. In
the ﬁnite size regime, the variables used in the PA protocol
are elements of a ﬁnite ﬁeld. So, the inverse of the length
of the key vector of each user is considered as the metric,
in addition to the normalized key rate. In the asymptotic
regime, the variables of the protocol are sequences of the
length of order l, for arbitrary large l, where l is the length
of the key available at the legitimate user, required for
authentication.

2

In the single-server scenario, for both the ﬁnite size
and asymptotic regimes, we propose an achievable PA
protocol, that satisﬁes the completeness, soundness, and
privacy conditions. In the asymptotic regime, the proposed
scheme achieves capacity, proving its optimality. The pri-
vacy condition is guaranteed by generating and extracting
correlation between the information distributed among the
users, which enables us to generate correlated keys such that
checking the availability of the keys at the users does not
need the identity of the user. Our ﬁnite size scheme mainly
uses the idea that the keys of the legitimate users should
lie on a speciﬁc polynomial. Checking that this polynomial
passes through the key of the prover without knowing the
exact value of the key, satisﬁes privacy constraint. Here, the
achievable region (normalized total key rate and inverse of
the length of the key vector) is provided. For the asymptotic
regime, we propose an optimal scheme, where the main idea
is to use the random binning and joint typicality between
the keys of the legitimate users and the data available at
the veriﬁer to generate the required correlation. Using this
correlation enables us to guarantee privacy.

In the multi-server scenario, for the individual authenti-
cation case, in both the ﬁnite size and asymptotic regimes,
we propose achievable protocols. Both these protocols are
the generalization of the protocols proposed in the single-
server scenario, and thus have their properties. The pro-
posed protocol in the asymptotic regime is optimal. For
the distributed authentication case, assuming that all the
veriﬁers are connected to all the provers, we propose an
optimal scheme in the ﬁnite size regime. This protocol uses
symmetric private information retrieval (SPIR) [21] at the
veriﬁers to send the desired data by the prover privately,
and simultaneously the prover cannot gain information
about other users’ keys. In this protocol, the authentication
process is done distributively by the veriﬁers.

Organization. Section 2 presents the system framework.
Section 3 describes the results. Section 4 proposes the achiev-
able schemes. Section 5 concludes the paper and provides a
comparison of proposed authentication protocols.

Notations: Capital letters are used to show random vari-
ables and small letters are their realizations. The mutual
information between X and Y is shown with I(X; Y ),
H(X) shows the entropy of discrete random variable X.
T (l)
(X, Y ) is the set of strong jointly typical sequences
ξ
(X l, Y l). [K] = {1, 2, · · · , K}, X1:N = {X1, · · · , XN } and
X ∼ Y means that X and Y are identically distributed.
P (n, k) = n!
(n−k)! shows k permutations of n. For stating
asymptotic results (Landau notation), f (x) = Θ(g(x)) if
limx→∞

f (x)
g(x) < ∞.

2 PROBLEM STATEMENT

The PA framework consists of a CA, single or multiple ver-
iﬁers, K legitimate users, and an attacker1. Each legitimate
user wants to be authenticated without revealing his iden-
tity to the veriﬁer(s). Two scenarios are considered: Single-
server scenario (one veriﬁer) and multi-server scenario (N
veriﬁers). We ﬁrst introduce the single-server scenario.

1. Arbitrary number of attackers may exists, but considering one of

them is enough.

W

CA

V3

Ck 1

Veriﬁer

Prover (user k)

2

4

5

Q[k]

M [k]

ˆS[k]

ˆS[k] = g[k](Ck, M [k], Q[k])

(S[k], M [k]) = f [k](V, Q[k])

accept if ˆS[k] = S[k]
reject if ˆS[k] (cid:54)= S[k]

Fig. 1. Single-server PA protocol. In the key distribution phase, CA
generates C = {C1, · · · , CK } ∈ CK ; he sends Ck to the user k. In
the authentication phase, after receiving the authentication query from
the prover, CA generates V and sends V to the veriﬁer. The veriﬁer
generates S[k] as a secret and M [k] as a helper data. He sends M [k]
to the prover. If the prover is legitimate , he uses (M [k], Ck, Q[k]) to
compute ˆS[k] and sends it to the veriﬁer. If the received secret at the
veriﬁer is equal to S[k], the prover passes authentication, unless he fails.

2.1 Single-server (veriﬁer)

A single-server PA protocol consists of a CA, a veriﬁer, K le-
gitimate users, and an attacker. Each legitimate user wishes
to authenticate himself to the veriﬁer without revealing his
identity. The PA protocol, shown in Fig. 1, has two phases:
1) Key distribution phase: In this phase, the CA having access
to W, generates Ck ∈ C as the personal key of user k using
function h[k] : W → C, where W is an authentication space,
and sets C = (C1, · · · , CK) ∈ CK . CA sends Ck to the
legitimate user k, which will be used later by the veriﬁer to
authenticate user k. This phase runs only once at the setup
of the protocol to provide the users with their personal keys.
2) Authentication phase: Here, the user k ∈ [K] wants to
prove knowledge of Ck ∈ C without revealing index k
to the veriﬁer. The decoding and encoding functions of
the protocol must be designed to specify the veriﬁcation
process. The set of variables for a PA protocol is shown as
P Single =
. These parameters will
be deﬁned in the following. Any time that a prover requests
authentication from the veriﬁer, this phase runs. A prover is
a user who sends the authentication request to the veriﬁer.
We have two cases: Case I: H = 0, the prover is a legitimate
user, Case II: H = 1, the prover is an attacker. When
the prover claims that he has some ¯C ∈ C, the veriﬁer
decides on ˆH, where ˆH = 0 means that the veriﬁer accepts
the prover as a legitimate user, and ˆH = 1 means that
the veriﬁer rejects the prover. The authentication phase, as
shown in Fig. 1, consists of ﬁve steps:
Case I: H = 0

V, Q[k], M [k], S[k], ˆS[k](cid:17)
(cid:16)

S1: The prover (user k) sends authentication query

Q[k] ∈ Q to the veriﬁer, a request for authentication.

S2: CA generates V ∈ V using encoding function f c :

W → V and sends V to the veriﬁer.

S3: The veriﬁer, knowing V and receiving Q[k], uses
encoding function f [k] : V × Q → S × M to generate S[k]
and M [k], i.e., (S[k], M [k]) = f [k](V, Q[k]). The output of the
encoding function has two parts. The ﬁrst part, S[k], is used

3

as a secret in the process of authentication in the following
steps and the second part, M [k], is used as helper data for
the prover. Then, the veriﬁer keeps S[k] and sends M [k] to
the prover.

S4: The prover (legitimate user k) computes ˆS[k] =
: M × C × Q → S is a

g[k](M [k], Ck, Q[k]), where g[k]
decoding function, and sends ˆS[k] to the veriﬁer.

S5: If ˆS[k] = S[k], the veriﬁer accepts the prover and
announces ˆH = 0. Otherwise, he rejects the prover and
announces ˆH = 1.
Case II: H = 1
Since neither the veriﬁer nor the CA has knowledge of H
at the beginning of the authentication phase, the steps of
the authentication phase are similar to that of case I, except
in Step 4. In Step 4, the prover (an attacker) computes
ˆS = g(M, Q), since the only information available at the
attacker is M and Q. Function g can be any arbitrary
decoding function such that g : M × Q → S. The prover
sends ˆS to the veriﬁer.

The PA protocol should satisfy three constraints: com-

pleteness, soundness, and privacy.
The completeness property assures that a legitimate user is
accepted. We deﬁne the Pe1-completeness constraint as if
the prover is the legitimate user, then the veriﬁer announces
ˆH = 0 with probability more than 1 − Pe1. Thus,

Pe1-completeness: P[ ˆH = 1|H = 0] ≤ Pe1.

(1)

The soundness property guarantees that an attacker is re-
jected. The Pe2-soundness constraint is deﬁned as if the
prover is an attacker, then the veriﬁer announces ˆH = 1
with probability more than 1 − Pe2. Thus,

Pe2-soundness: P[ ˆH = 0|H = 1] ≤ Pe2.

(2)

To make user identity private, all provers’ requests should
be indistinguishable from the veriﬁer’s perspective, i.e.,
knowing the variables available at the veriﬁer, all requests
must be identically distributed. Thus, perfect privacy is
deﬁned as:
(V, Q[1], S[1], M [1], ˆS[1]) ∼ (V, Q[k], S[k], M [k], ˆS[k]), ∀k ∈ [K].

In the proposed model, we use the Pp-privacy property as:

Pp-privacy: P

(cid:104)

(V, Q[1], S[1], M [1], ˆS[1]) ∼

(V, Q[k], S[k], M [k], ˆS[k]),

(cid:105)
∀k ∈ [K]

≥ 1 − Pp.

(3)

Considering length(C) as the length of the keys, we deﬁne
a reliability metric, R, as the normalized total key rate:

R =

H(C1, C2, · · · , CK)
Klength(C)

.

(4)

Since Ck is the personal key of user k, it is desirable that
(C1, C2, · · · , CK) has the maximum entropy, so that expo-
sure of a user’s key reveals minimum information about
other users’ keys. In other words, users wish that others
gain as little information as possible about their keys. On
the other hand, for preserving privacy, it is desired that the
personal keys of the users have correlated information. This
correlated information is used for authentication without
revealing the identity of the user. Thus, there is a trade-off
between maximizing the entropy of (C1, C2, · · · , CK) and

establishing privacy.
The goal is to design a PA protocol that satisﬁes complete-
ness, soundness, and privacy constraints while achieving
maximum R. Two regimes are considered: ﬁnite size and
asymptotic regimes2, deﬁned in the following.

Finite size regime: In the ﬁnite size regime, the variables
of the protocol are chosen as elements of a ﬁnite ﬁeld. More
precisely, W = GF (qL), S = GF (qL), C = (GF (qL))lc ,
V = (GF (qL))lv and M = (GF (qL))lm , where q is a prime
number and L, lc, lv, and lm are integers3. For example,
for a variable X used in the protocol, X ∈ (cid:0)GF (qL)(cid:1)lx ,
meaning that X is a lx-tuple where each element is of length
L in a q-ary unit. lx will be chosen properly according
to the protocol. Thus, length(X) = lxL. All operations
in this regime are done in the ﬁnite ﬁeld GF (qL). Thus,
Ck ∈ (GF (qL))lc for k ∈ [K]. We also deﬁne the inverse of
the length of the key vector as:

Rc =

1
lc

.

Deﬁnition 1. The pair (R, Rc) is achievable for a PA protocol
in the ﬁnite size regime, if there exist encoding functions f c and
f [k], decoding functions g[k] and functions h[k] for k ∈ [K], such
that Pe1 = 0, Pe2 = 1
|S| and Pp = 0. It must be noted that since
lc ∈ Z+, the achievable region is countable.

Remark 1. It is worth noting that, since an attacker can guess
the key, the lowest possible Pe2 is equal to 1

|S| .

Deﬁnition 2. The capacity region Cﬁn for a PA protocol is the
union of all achievable pairs.

Asymptotic regime: In the asymptotic regime, the ele-
ments of the protocol are sequences of arbitrary large length.
More exactly, each variable of the protocol, e.g., X lx is a
sequence of length lx with each component chosen from X .
Thus, length(X lx ) = lx, where lx approaches inﬁnity. In
particular, considering C = Y l, we deﬁne the l-length key
Ck = Y l
k = (Yk1, · · · , Ykl) where Yki is a random variable
from alphabet Y, k ∈ [K] and i ∈ {1, 2, · · · , l}.

Deﬁnition 3. The normalized total key rate R is achievable for
a PA protocol in the asymptotic regime, if there exist encoding
functions f c and f [k], decoding functions g[k] and functions h[k]
for k ∈ [K], such that Pe1, Pe2 and Pp tend to zero as the length
of the variables goes to inﬁnity.

Deﬁnition 4. The key capacity for a PA protocol in the asymp-
totic regime is:

Casy (cid:44) sup{R : R is an achievable normalized total key rate
for a PA protocol in asymptotic regime}.

2.2 Multi-server (veriﬁers)

In this section, a multi-server version of the PA framework
is introduced. The multi-server PA protocol, shown in Fig. 2,
consists of a CA, N veriﬁers, K legitimate users, and an at-
tacker. Each legitimate user wants to gain access to a subset
of veriﬁers using only one personal key. Veriﬁer n (n ∈ [N ])

2. Both ﬁnite size and asymptotic regimes are considered in terms of

size of the variable and both of them are single round.

3. S = GF (qL)ls is feasible, but to avoid complexity, we set ls = 1.

...

CA

...

4

C1

User 1

User 2

...

User k

...

Nn

V1

Veriﬁer 1

...

Veriﬁer n

N [k]

...

CK

User K

Veriﬁer N

VN

Fig. 2. Multi-server (veriﬁers) PA Protocol.

must authenticate any legitimate user in the set Nn ⊆ [K].
Nn can be any arbitrary subset of [K] and shows the users
that are allowed to connect to the veriﬁer n. However, for
privacy reasons, the user wants to be anonymous in the set
Nn, that is, the veriﬁer n should not understand which user
in the set Nn requests accessing the service.

Deﬁnition 5. (k, n) forms a feasible pair if k ∈ Nn. This means
that the user k has the right to gain access to the veriﬁer n.

The same as the single-server scenario, the multi-server

(cid:17)

n , ˆS[k]

n , S[k]

n , M [k]

n , n ∈ [N ]

PA protocol has two phases:
1) Key distribution phase: Similar to the single-server case, CA
sends the personal key of user k, Ck, to each legitimate user.
2) Authentication phase: The user k wants to prove knowl-
edge of Ck ∈ C without revealing index k to the ver-
iﬁer n∗. Any time that a prover wants to be authenti-
cated, this phase runs. In this phase, the veriﬁcation pro-
cess is speciﬁed, which includes the variables P Multi =
(cid:16)
Vn, Q[k]
. These parameters will
be deﬁned in the following. It must be noted that the ﬂow
of the PA protocol for the single-server and the multi-server
is similar, this means that the one who takes action in each
step of the authentication phase is the same. However, con-
sidering the type of authentication in multi-server scenarios,
two situations are studied: 1) Individual authentication, 2)
distributed authentication. In these two situations, when
helper data is sent,
interactions between the parties of
the protocol are different. The details are presented in the
following in Step 3. Because of the similarities between the
overall functionality of Case I (the prover is a legitimate
user) and Case II (the prover is an attacker), only Case I
is described. Denoting N [k] as the set of veriﬁers that user
k forms a feasible pair with, the authentication phase is in
Case I is as follows.

S1: The legitimate user k sends authentication query
n ∈ Q to the veriﬁer n, where n ∈ N [k]. This query

Q[k]
consists of the request for authentication.

S2: CA generates Vn ∈ V, n ∈ [N ] using the encoding
function f c
n : W → V, where W is an authentication space.
CA sets V = {V1, V2, · · · , VN } and sends Vn to the n-th
veriﬁer.

S3: Two situations are considered:
• Individual authentication: only veriﬁer n∗ sends helper
data. In the individual authentication, the n∗-th veriﬁer,
knowing Vn∗ , uses the encoding function f [k]
n∗ to gener-
ate S[k]
n∗ ) and

n∗ , i.e., (S[k]

n∗ (Vn∗ , Q[k]

n∗ and M [k]

n∗ ) = f [k]

n∗ , M [k]

n∗ : V ×Q → S ×M. The veriﬁer keeps S[k]
f [k]
M [k]
n∗ to the prover.

n∗ and sends

n∗ , M [k]

n = f [k]

n ) and f [k]

n∗ and M [k]

n∗ , i.e., (S[k]

• Distributed authentication4: all the veriﬁers in N [k]
can send helper data to the user k. In the distributed
authentication, for each n ∈ N [k]\{n∗}, the n-th veriﬁer
uses the encoding function f [k]
n to generate M [k]
n , i.e.,
M [k]
n (Vn, Q[k]
n : V × Q → M. Also, the
veriﬁer n∗ generates S[k]
n∗ ) =
n∗ ). For n ∈ N [k], each veriﬁer n sends M [k]
f [k]
n∗ (Vn∗ , Q[k]
n
to the prover, and veriﬁer n∗ keeps S[k]
n∗ to be used in the
following steps for checking the legality of the prover.
S4: The prover (legitimate user k) computes ˆS[k]
n∗ =
g[k]
n∗ (Ck, M [k]
n∗ is a decoding function and
g[k]
n∗ : M × C × Q → S. It must be emphasized that the
prover can use the queries he sent to the veriﬁers he forms
feasible pair with and the helper data he received from
these veriﬁers to estimate the secret generated by a speciﬁc
veriﬁer. The prover sends ˆS[k]
n∗ = S[k]

n∗ , the veriﬁer accepts the prover and
announces ˆH = 0; Otherwise, he rejects the prover and
announces ˆH = 1.

n∗ to the veriﬁer n∗.

1:N ), where g[k]

S5: If ˆS[k]

1:N , Q[k]

For each feasible pair, Pe1-completeness constraint is de-
ﬁned as (1), and for each veriﬁer Pe2-soundness constraint
is deﬁned as (2). For veriﬁer n, the privacy constraint is:

Pp-privacy: P

(cid:104)

(Vn, Q[k]

n , S[k]

n , M [k]

n , S[k1]

n , M [k1]

n , ˆS[k1]

n ) ∼
(cid:105)

(Vn, Q[k1]
n , ˆS[k]
n ),

∀k, k1 ∈ Nn

≥ 1 − Pp.

(5)

Also, the normalized total key rate is deﬁned as (4).
By designing the veriﬁcation process for multi-server sce-
nario, P Multi, the deﬁnitions of the achievable pair and the
capacity region in the ﬁnite size regime and the deﬁnitions
of the achievable rate and the capacity in the asymptotic
regime are the same as Deﬁnitions 1-4, respectively, consid-
ering appropriate encoding and decoding functions.

In Subsection 3.3, these two different situations
Remark 2.
of individual authentication and distributed authentication are
considered.

3 RESULTS
3.1 Single-server, ﬁnite size regime
Theorem 1. The achievable region (R, RC) (R in q-ary unit) for
a single-server PA protocol in the ﬁnite size regime is






(R, Rc) :
Rc = 1;
Rc = 1

R ≤ 1
K

i , i ≥ 2; R ≤ 1 − Rc + Rc logq P (qL−1,K)

KL






.

(6)

Remark 3. The achievable scheme is provided in Subsection 4.1.
The achievability proof consists of two schemes, scheme 1 for Rc =
1 and scheme 2 for Rc = 1
i , i ≥ 2. The idea for the ﬁrst scheme
is to share a common key between all legitimate users. The design
of scheme 2 is depending on two facts: 1) a k degree polynomial

4. It must be mentioned that distributed authentication is the general
case of multi-server authentication and individual authentication is a
special case of distributed authentication where only veriﬁer n∗ sends
helper data.

5

can cover k + 1 randomly chosen points from GF (qL), 2) k +
1 points can uniquely determine a k degree polynomial In this
scheme, the CA generates K random points (as the keys of the
legitimate users) and computes the unique polynomial of degree
K passing through these points. The prover wishes to prove that
his key is a valid point on the polynomial f (.) to conﬁrm his
legitimacy (inspired by the idea of Shamir’s secret sharing (SSS)
[22]). It must be emphasized that even though we use polynomial
interpolation similar to SSS; however, we do not need to combine
the shares (keys of the provers), and the setup is different.

Remark 4. The normalized total key rate in (6) tends to its upper
bound ,1, as qL → ∞ for lc ≥ 2.

3.2 Single-server, asymptotic regime

In the asymptotic regime, all the variables of the protocol
are sequences of length Θ(l) for arbitrary large l.

Theorem 2. The capacity of the single-server PA protocol in
the asymptotic regime is equal to maxp(y) H(Y ), where Y is
an arbitrary random variable chosen from Y.

Remark 5. The achievable scheme is provided in Subsection 4.2.
The idea of the proposed scheme is to provide the veriﬁer and the le-
gitimate provers with correlated data (done by CA) using Wyner-
Ziv coding [23], and then verify the existence of this correlation.
This veriﬁcation is based on a random binning technique and is
done in an interactive protocol. It must be noted that applying
Wyner-Ziv coding should ﬁt the framework of the problem, and
we cannot use Wyner-Ziv coding, lonely.

Remark 6. The proposed achievable scheme in Subsection 4.2 is
optimal. This means, we show that the normalized total key rate
of the protocol achieves capacity.

3.3 Multi-server, ﬁnite size regime

The results provided in this subsection consider two dif-
ferent viewpoints of the problem of multi-server private
authentication. First, the individual authentication, where
similar to the single-server case, each server tries to au-
thenticate a group of users that it forms feasible pair with,
by considering privacy constraint. In other words, in each
veriﬁcation process, the legitimate user is connected to only
one veriﬁer, and that veriﬁer privately authenticates the
user with the corresponding key. The second viewpoint is
to use the multi-server structure to perform the veriﬁcation
process in a distributed manner. More precisely, unlike the
individual authentication, all (or a subset) of the servers
contribute in the process of privately authenticating the
users.

Theorem 3. The achievable region (R, RC) (R in q-ary unit) for
a multi-server PA protocol in the ﬁnite size regime is equal to (6).

Remark 7. The achievable scheme is proposed in Subsection 4.3,
and is for the individual authentication case. The proposed proto-
col consists of two schemes that are generalizations of the schemes
proposed in the single-server case, Theorem 1. Each veriﬁer tries
to privately authenticate the groups of users that it forms feasible
pair with. In scheme 1, a common key is shared between all users
and veriﬁers. Each prover proves his legitimacy by providing this
common key to the appropriate veriﬁer. In scheme 2, each veriﬁer
computes the unique polynomial that passes through the keys of

the users that he forms a feasible pair with. By proving that his
key lies on the polynomial constructed by the desired veriﬁer, the
prover convinces the veriﬁer of his legitimacy.

6

Theorem 4. When N1 = N2 = · · · = Nn = [K], the capacity
region of the multi-server PA protocol in ﬁnite size regime in q-ary
unit is:

(cid:26) (R, Rc) :
Rc = 1

i , i ≥ 1; R ≤ 1

(cid:27)

.

(7)

Remark 8. The achievable scheme is provided in Subsection 4.4,
and is for the distributed authentication case. In the proposed
protocol, the prover asks for required data that ﬁts his index, from
all veriﬁers. The queries are sent according to the SPIR protocol,
and the veriﬁers sends answers according to the SPIR protocol.
Using the SPIR protocol enables the prover to protect his privacy.
The prover uses his own personal key and the retrieved data to
estimate the secret.

Remark 9. The proposed achievable scheme for the distributed
authentication is optimal and achieved capacity region. However,
unlike the individual authentication, this scheme is provided for a
special case where N1 = N2 = · · · = Nn = [K].

Remark 10. The proposed scheme for the distributed authenti-
cation provides some extra features compared with the individual
authentication, that are discussed in Subsection 5.2.

3.4 Multi-server, asymptotic regime
Considering Ck = Y l

k , we have the following theorem.

Theorem 5. The capacity of the multi-server PA protocol in the
asymptotic regime is equal to maxp(y) H(Y ), where Y is an
arbitrary random variable chosen from Y.

Remark 11. The proposed achievable scheme is provided in
Subsection 4.5, and is the generalization of the scheme proposed
in Subsection 4.2. However, in the multi-server scenario each
personal key must have the correlation properties with information
available at all the veriﬁers he forms feasible pair with.

4 PROOFS

4.1 Proof of Theorem 1 (single server, ﬁnite size
regime)

The achievability proof consists of two schemes, scheme 1
for Rc = 1 and scheme 2 for Rc = 1
i , i≥2. The achievable re-
gion, shown in Fig. 3, for the proposed protocol is the union
of the achievable pairs results from these two schemes.

Scheme 1 for single-server, ﬁnite size regime (SS-FR1)

K ):

protocol (Rc = 1, R ≤ 1
1) Key distribution phase: ﬁrst, CA chooses ˜C ∈ GF (qL)
uniformly at random and sets Ck = ˜C, ∀k ∈ [K].
2) Authentication phase: Considering user k as the prover, the
encoding and decoding functions follow:

S1: The prover (user k) sends the authentication query
Q[k] to the veriﬁer. It is worth noting that this query only
consists of a request for authentication and does not ask for
speciﬁc helper data.

S2: CA sets V = { ˜C}, and sends it to the veriﬁer. It is to
be noted since V does not change in any veriﬁcation process,
V can be sent to the veriﬁer at the key distribution phase.

Fig. 3. (a) Achievable region and outer bound, Theorem 1 and 3

S3: The veriﬁer sets S[k] = ˜C. It is obvious that since all
the users have the secret as their own personal key, there is
no need to helper data. Thus M [k] is Null.

S4: Having access to Ck = ˜C, the prover sets ˆS[k] = ˜C

and sends it to the veriﬁer.

S5: The veriﬁer checks if ˆS[k] = S[k], to pass or reject the

prover.

These steps determine the variables of the veriﬁcation
process P Single. Now we analyze the completeness, sound-
ness, and privacy properties of this scheme.
0 -completeness: Each legitimate user has access to ˜C. Thus,
user k can estimate ˆS[k] = S[k] = ˜C for all k ∈ [K] and thus:
P[ ˆH = 1|H = 0] = P[ ˆS[k] (cid:54)= S[k]] = 0.

(8)

This proves the 0-completeness property of the scheme.
1
|S| -soundness: Since the helper data is null in this scheme,
we have, I(S; M [k]) = 0. This means that if the prover is
an attacker, he obtains no information about the secret. This
means that, the best possible attack strategy is to guess the
secret. Considering that S is uniformly distributed):

P[ ˆH = 0|H = 1] = P[ ˆS = S] =

1
qL .

(9)

|S| -soundness property.

Thus, the maximum success probability of the attacker is
equal to 1
qL , showing that the larger the size of the ﬁnite
ﬁeld, the lower the probability of attack. This completes the
proof of 1
0 -privacy: As stated above, every legitimate user has access
to ˜C. Thus, ˆS[1] = ˆS[k] = ˜C, and (V, Q[1], S[1], M [1], ˆS[1]) ∼
(V, Q[k], S[k], M [k], ˆS[k]) for all k ∈ [K], and 0-privacy is
satisﬁed. Intuitively, since every legitimate prover always
sends ˜C and authentication query is only a request for
authentication (no difference between the legitimate users),
the veriﬁer cannot distinguish the identity of the prover.
Now, we compute the normalized total key rate of the
proposed protocol as,

R =

H(C1, C2, · · · , CK)
Klength(C)

=

H( ˜C)
KlcL

(a)
=

H( ˜C)
KL

=

1
K

,

(10)

where (a) follows due to lc = 1.
This scheme achieves the pair ( 1
remark that, trivially, when R = 1
less than 1

K , 1), shown in Fig. 3. We
K is achievable, all rates
K can be achieved, by changing the distribution

i (i ≥ 2), R ≤ 1 − Rc + Rc

of ˜C and thus reducing its randomness. This concept will be
used in other schemes in the ﬁnite size regime, too.
Scheme 2 for single-server, ﬁnite size regime (SS-FR2) pro-
tocol (Rc = 1
KL logq P (qL − 1, K)):
1) Key distribution phase: CA chooses X1, · · · , XK (K dis-
tinct random numbers) from the ﬁnite ﬁeld GF (qL)\{0},
and chooses K variables from the ﬁeld W = GF (qL),
independently and uniformly at random and sets them
as Y1, · · · , YK . Moreover, CA chooses independently and
uniformly at random K variables from
and
sets them as Z1, · · · , ZK . CA sets Ck = (Xk, Yk, Zk) and
send Ck to user k, ∀k ∈ [K].
2) Authentication phase: Each user wishes to prove that his
key ((Xk, Yk)) ﬁts the polynomial.

(cid:0)GF (qL)(cid:1)lc−2

S1: The prover sends authentication query Q[k] to the
veriﬁer. It is worth noting that this query only consists of a
request for authentication.

S2: CA chooses a0 from GF (qL) independently and
uniformly at random, sets V = {a0, Ck| k ∈ [K]} and sends
V to the veriﬁer.

the veriﬁer

S3: Having access to V ,
Since K + 1 points

the veriﬁer sets S[k] =
a0.
can uniquely determine
a K degree polynomial,
the
unique polynomial f (.) of degree K that passes
through {(0, a0), (X1, Y1), · · · , (XK, YK)}. Then, the veri-
ﬁer chooses K new points on the polynomial f (.), i.e., the
veriﬁer chooses at random K distinct elements M1, · · · , MK
of GF (qL)\{0, Xk| k ∈ [K]}. The veriﬁer sets M [k] =
{(Mi, f (Mi)), ∀i ∈ [K]} and sends M [k] to user k.

computes

S4: Knowing M [k] and Ck, the prover has access to K +1
distinct points of the polynomial f (.) (of degree K), thus, he
can derive the polynomial f (.) and compute ˆS[k]=f (0)=a0.
The prover sends ˆS[k] to the veriﬁer.

S5: The veriﬁer checks if ˆS[k] = S[k], to pass or reject the

prover.
The above steps determine the variables of P Single of SS-FR2.

Remark 12. It is to be emphasized that, a0, selected in Step 2
of the authentication phase, must not be changed in different
veriﬁcation processes. Changing a0 results in changing the poly-
nomial f (.), and the intersection points of the old and the new
polynomials consist of the keys of the users. This violates security
and reveals the keys of the users to other legitimate users. Also,
any time the veriﬁer receives an authentication request, he must
send exactly the same helper data to the prover. More precisely, if
the prover is an attacker and the helper sets sent to him in two
requests differ in one point, then he has K + 1 points that ﬁt the
polynomial, and he can compute the secret. In Subsection 4.4, we
propose a solution which does not need the mentioned conditions.

Remark 13. The attacker only knows the helper data, M . He can
use any arbitrary decoding function g(.) to estimate the secret, ˆS.
His success probability is derived in the analysis of the soundness
property in the following.

Now, we show the 0-completeness,

1
|S| -soundness and

0-privacy properties of the proposed SS-FR2 protocol.
0 -completeness: The user k, having (Xk, Yk) and M [k] =
{(M1, f (M1)), · · · , (MK, f (MK))}, has access to K + 1
points of the polynomial, and thus he derives the polyno-
mial with Lagrange interpolation and computes a0 [22]. So,

ˆS[k] = S[k] = a0 for all k ∈ [K] and thus:

P[ ˆH = 1|H = 0] = P[ ˆS[k] (cid:54)= S[k]] = 0.

7

(11)

This proves the 0-completeness property of the scheme.
1
|S| -soundness: Due to the information-theoretic secrecy of
Shamir secret sharing, M does not give any information
about S [22], [24], i.e., I(S; M ) = 0. This means that if
the prover is an attacker, by observing M (K points of the
polynomial), the attacker obtains no information about the
secret. Considering that S is uniformly distributed, we have:

P[ ˆH = 0|H = 1] = P[ ˆS = S] =

1
qL .

(12)

|S| -soundness property and means that the best

This proves 1
possible attack strategy is to guess the secret.
0 -privacy: Every legitimate user can compute S[k] cor-
rectly. So, ˆS[1] = ˆS[k]
the
authentication query is the same for all users. Thus,
( ˆS[1], S[1], M [1], V, Q[1]) ∼ ( ˆS[k], S[k], M [k], V, Q[k]) for all
k ∈ [K], and 0-privacy is satisﬁed.
Now, we compute the normalized total key rate of the
proposed SS-FR2 protocol as,

for all k ∈ [K]. Further,

R =

=

H(C1,· · ·, CK)
Klength(C)
H(X1, · · · , XK) + (cid:80)K

H((X1, Y1, Z1), · · · , (XK, YK, ZK))
KlcL
i=1 H(Yi) + (cid:80)K
KlcL

i=1 H(Zi)

(a)
=

(b)
=

logq P (qL − 1, K) + K(lc − 1)L
KlcL

,

(13)

where (a) follows from the fact that Yi and Zi, for i ∈ [K],
are chosen independently and uniformly at random, and
(b) is obtained by considering that X1, · · · , XK are chosen
uniformly at random from all subsets of cardinality K of the
(cid:3)
ﬁeld GF (qL).

Lemma 1. The outer bound for (R, Rc) pair (R in q-ary unit) is
equal to:

(cid:26)

(cid:27)

Rc ≤ 1, R ≤ 1

.

(14)

Proof: Noting (4), we have:

R =

H(C1, C2, · · · , CK)
Klength(C)

≤

(cid:80)K

i=1 H(Ci)
KLlc

=

KLlc
KLlc

= 1.

Indicating Rc = 1
lc
shown in Fig. 3.

≤ 1, the outer bound for (R, Rc) is

4.2 Proof of Theorem 2 (single-server, asymptotic
regime)

We present the optimal single-server PA protocol for the
asymptotic regime.

Converse: Noting Ck = Y l

k , it is obvious that R ≤

maxp(y) H(Y ).

Achivability: The proof is based on the strong typicality
[25]. We propose the achievable scheme for the single-server
asymptotic regime (SS-AR) PA protocol, by deﬁning the
functions at CA, the veriﬁer, and the legitimate users.
1) Key distribution phase: First, we describe the codebook
generation at CA. Considering auxiliary random variables
X ∈ X and U ∈ U , ﬁx a joint distribution PU XY (u, x, y) =

PX (x)PY |X (y|x) PU |X (u|x), i.e., U → X → Y forms a
Markov chain, such that 0 < I(U ; Y ) ≤ I(X; Y ) = µ.
Obtaining PU (u) = (cid:80)
x PU X (u, x) and ﬁxing ξ and ξ(cid:48) such
that ξ > ξ(cid:48) > 0, form the set J by randomly and inde-
pendently generating 2l ˜R sequences of U l, each according
to (cid:81)l
i=1 PU (ui). Randomly partition the set J to 2lR(cid:48)
equal
size subsets (bins). So, each bin contains 2l( ˜R−R(cid:48)) sequences.
Each sequence U l ∈ J can be shown as U l(m, s), where m
is the bin index and s is the index of sequence in the bin.
The sequences U l(m, s) constitutes the codebook, which is
revealed to every participant of the protocol (the veriﬁer and
both the legitimate users and attackers).
CA generates an i.i.d sequence X l, from marginal distribu-
tion PX (x). Conditioned on X l, randomly and conditionally
independently, CA generates K sequences Y l
2 , · · · , Y l
K ,
each according to the conditional distribution PY |X (y|x),
i.e., Y l
i=1 PY |X (yi|xi) for k ∈ [K]. CA sets
Ck = Y l
2) Authentication phase: considering user k as the prover:

k |X l ∼ (cid:81)l
k and sends it to the user k.

1 , Y l

S1: The prover asks for authentication from the veriﬁer.
S2: CA sets V = {X l, Y l
1:K} and sends it to the veriﬁer.
S3: The veriﬁer ﬁnds a sequence U l(m, s) ∈ J that is
jointly typical with X l, i.e., (X l, U l(m, s)) ∈ T l
ξ(cid:48)(X, U ). If
no such sequence exists, the veriﬁer chooses a sequence
from J randomly. If there is more than one sequence, the
veriﬁer chooses one of them randomly. Then, the veriﬁer
sets M [k] = m and S[k] = s. He sends M [k] to the prover.

S4: Having access to Y l

k and the bin index M [k], the
prover looks for a sequence ˆU l in bin M [k] that is jointly
k , i.e., ( ˆU l(M [k], ˆs), Y l) ∈ T (l)
typical with Y l
(U, Y ). One of
the following cases occur:

ξ

• There is only one sequence in bin M [k] that is jointly

typical with Y l (cid:55)−→ the prover takes this sequence as ˆU l.

• There is more than one sequence in bin M [k] that are
jointly typical with Y l (cid:55)−→ the prover chooses one of these
sequences randomly and sets the selected sequence as ˆU l.

• There is no sequence in bin M [k] that is jointly typical
with Y l (cid:55)−→ the prover chooses ˆU l at random from bin M [k].
The index ˆs of ˆU l in bin M [k] is the output of the decoding
function, i.e., ˆS[k] = ˆs. The prover sends ˆS[k] to the veriﬁer.
S5: The veriﬁer checks if ˆS[k] = S[k], to pass or reject the

prover.

The above steps determine the variables of the veriﬁca-

tion process P single in the SS-AR protocol.

An outline of the analysis of the constraints follows. The

detailed analysis is provided in Appendix B.
For completeness, error occurs if ˆS[k]
(cid:54)= S[k]. By setting
˜R > I(U ; X), there are more than 2lI(U ;X) sequences in
J . Using covering lemma [26], with high probability the
veriﬁer ﬁnds a sequence U l that is jointly typical with X l.
On the other hand, by the law of large number (LLN), the
prover ﬁnds a sequence ˆU l that is jointly typical with Y l
k . By
setting ˜R − R(cid:48) < I(U ; Y ) and due to packing lemma, with
high probability the prover ﬁnds a unique sequence. This
proves that liml→∞ Pe1 = 0.
The soundness property is derived by showing that as l→∞,
we have 1
l I(S; M )→0 and using Lemma 2 in Appendix A.
If { ˆS[1] = ˆS[k]}, privacy is guaranteed. Thus, P[ ˆS[k] (cid:54)= ˆS[k]]
is an upper bound on the probability of the event that
privacy is violated. Utilizing a similar technique used in the

8

proof of completeness property, we show that the probabil-
ity of { ˆS[1] (cid:54)= ˆS[k]} tends to zero. Since the number of legiti-
mate provers is ﬁnite, K, the probability of { ˆS[1] (cid:54)= ˆS[k]} for
∀k ∈ [K] tends to zero.
Now, we analyze the normalized total key rate:

R =

≥

H(C1, C2, · · · , CK)
Kl
1 , · · · , Y l
Kl

K|X l)

H(Y l

=

(a)
=

H(Y l

1 , · · · , Y l
Kl

K)

1
Kl

K
(cid:88)

i=1

H(Y l

i |X l)

(b)
= H(Y |X),

1 , Y l

2 , · · · , Y l

where (a) follows from the fact that Y l
K are
mutually independent conditioned on X l and (b) is derived
by Y l
i=1 PY |X (yi|xi) for k ∈ [K].

k |X l ∼ (cid:81)l
In the converse, we have shown that R ≤ maxp(y) H(Y ).
The difference of H(Y ) and H(Y |X) is equal to I(X; Y ) =
µ. If µ → 0 and by ﬁxing p(y) such that H(Y ) equals its
maximum, then Casy = H(Y ) is achievable. µ → 0 means
negligible correlation between X and Y , which results in
(cid:3)
vanishing correlation between the keys of the users.

4.3 Proof of Theorem 3 (multi-server, individual authen-
tication, ﬁnite size regime)

Here we consider the case of individual authentication,
where the prover is connected to only one veriﬁer and
wants to be authenticated individually to that single veriﬁer,
who sends the helper data to the prover. Other veriﬁers do
not contribute in the process of authentication. It must be
emphasized that the prover has only one key, and uses this
single key for authentication to any of the veriﬁers that he
forms a feasible pair with.

Considering the feasible pair (k, n∗), the decoding and

K ):

encoding functions follow:
scheme 1 of multi-server, ﬁnite size regime (MS-FR1) proto-
col (Rc = 1, R ≤ 1
1) Key distribution phase: CA chooses ˜C ∈ W = GF (q)L
uniformly at random and sets Ck = ˜C, ∀k ∈ [K]. The CA
sends Ck to user k.
2) Authentication phase: For each feasible pair, the authentica-
tion phase is similar to the authentication phase in scheme 1
(SS-FR1 protocol) in proof of Theorem 1. More precisely, CA
sets Vn = ˜C, the veriﬁer n∗ sets S[k]
n∗ = ˜C, and the prover
(user k) sets ˆS[k]
n∗ = Ck = ˜C. The steps of the authentication
phase specify the variables of P Multi. It is worth emphasizing
that, Vn, Q[k]
n is
null ∀n ∈ [N ].

n are null for n ∈ [n]\{n∗}. M [k]

n and ˆS[k]

n ,S[k]

The analysis of completeness and soundness properties
is similar to SS-FR1, equations (8) and (9), respectively.
Since every legitimate user sends exactly the same secret,
˜C, privacy is preserved. The normalized total key rate can
be computed according to (10).
scheme 2 of multi-server, ﬁnite size regime (MS-FR2) proto-
col (Rc = 1
1) Key distribution phase: CA acts exactly the same as the key
distribution phase in protocol SS-FR2, and sets the variables
X1:K, Y1:K, Z1:K . He sets Ck = (Xk, Yk, Zk) and send Ck to
user k, ∀k ∈ [K].
2) Authentication phase:

2 (i ≥ 2), R ≤ 1 − Rc + Rc

KL logq P (qL − 1, K)):

S1: The prover sends authentication query Q[k] to the

veriﬁer n∗.

0

0
(cid:111)

0 , · · · , a(N )

0 , · · · , a(N )

S3: The veriﬁer n∗ sets S[k]

S2: CA chooses independently and uniformly at random
from the ﬁeld GF (qL). He
and sends Vn to the veriﬁer n,

0 , a(2)
N variables a(1)
(cid:110)
a(n)
sets Vn =
0 , Ck|k ∈ [K]
∀n ∈ [N ]. As stated in Remark 12, a(1)
cannot be
changed in different veriﬁcation processes. Thus, the CA can
send V1:N to the veriﬁers once at the key distribution phase.
. The veriﬁer
n∗ computes unique polynomial fn∗ (.) of degree dn∗ =
(cid:111)
(cid:110)
(0, a(n∗)
|Nn∗ | that passes through
.
Then, he selects dn∗ new points from GF (qL), that is
the veriﬁer chooses at random dn∗ distinct elements
M (n∗)
of GF (qL)\{0, Xk| k ∈ Nn∗ }.
The veriﬁer computes the value of the polynomial at the
new points and sets M [k]
)), · · · ,
(M (n∗)

(cid:110)
(M (n∗)
n∗ =
1
1
and sends M [k]
n∗ to user k.

), (Xk, Yk)|k ∈ Nn∗

, · · · , M (n∗)
dn∗

n∗ = a(n∗)

, fn∗ (M (n∗)

, M (n∗)

0

0

2

1

(cid:111)
dn∗ , fn∗ (M (n∗)
dn∗ ))
S4: Knowing M [k]

n∗ and Ck, the prover has access to dn∗+1
distinct points of the polynomial fn∗ (.) (of degree dn∗ ), so he
derives the polynomial, computes ˆS[k]
, and sends it
to the veriﬁer.

n∗ = a(n∗)

S5: The veriﬁer checks if ˆS[k]
These steps determine the variables of the veriﬁcation

n∗ = S[k]
n∗ .

0

process P Multi. Remarks 12 and 13 also apply here.
1
|S| -
Considering (11) and (12), 0-completeness and
soundness are provided. Since every legitimate user can
compute the secret correctly, (5) is satisﬁed with PP = 0 and
0-privacy is provided. R = 1 − Rc + Rc
KL logq P (qL − 1, K)
(cid:3)
can be computed according to (13).

Remark 14. Consider the case that user k1 and user k2 form
feasible pairs with both veriﬁer n1 and veriﬁer n2. Assume that
user k1 requests authentication to both veriﬁer n1 and veriﬁer
n2. After the execution of the protocol MS-FR2, user k1 computes
polynomials fn1 and fn2 . User k1 knows that the keys of the
users that are both in the Nn1 and Nn2 (e.g., user k2) are parts
of the intersection of the polynomials fn1 and fn2 . This violates
the security of the keys of users if the space of this intersection
is small. This problem can be solved if the polynomial and the
secret change in each execution of the authentication protocol.
However, changing the secrets and as a result, the polynomials
can lead to security violation (the detailed discussion is provided in
Subsection 5.2). The proposed protocol for the distributed version
of the multi-server protocol in Subsection 4.4 solves this problem.

4.4 Proof of Theorem 4 (multi-server, distributed au-
thentication, ﬁnite size regime)

Here, we consider the case of the multi-server scenario in
which all the veriﬁers contribute in the process of authenti-
cation, and so authentication is done in a distributed man-
ner, i.e., all the veriﬁers contribute in sending helper data to
the prover. For this case, we propose an optimal interactive
protocol, the distributed multi-server protocol in the ﬁnite
size regime (DMS-FR), between the CA, the veriﬁers, and
the prover that uses symmetric private information retrieval
(SPIR) [21], to deliver the prover the desired data, without
realizing the identity of the prover. DMS-FR is applicable
in the condition that all the users are connecting to all the
veriﬁers, i.e., (k, n) forms a feasible pair ∀k ∈ [K], ∀n ∈ [N ].
For better understanding, ﬁrst we present an example.

9

Example 1. Consider the case of two veriﬁers and three users
(N = 2, K = 3), and S = C = GF (23), i.e, q = 23 and
L = 1. User 2 wants to gain access to veriﬁer 1, and the following
protocol is executed:
1) Key distribution phase: CA chooses uniformly at random from
GF (23) the variables C1 = X1 = 14, C2 = X2 = 19 and
C3 = X3 = 6. These are the keys of the users that can be used in
any veriﬁcation process.
2) Authentication phase:

• User 2 sends an authentication query to all veriﬁers. In
addition to authentication request to veriﬁer 1, user 2 sends
queries to each veriﬁer according to queries of SPIR (Appendix
C) to retrieve his helper data.

• CA chooses randomly from GF (23), S = 5 as secret, R = 1
as common randomness (for SPIR algorithm) and ˜Y = 1. He also
chooses randomly ˜X = 15 from GF (23)\{0, X1, X2, X3}. CA
sends X1, X2, X3, S, R, and ( ˜X, ˜Y ) to both veriﬁers.

• Both veriﬁers compute the unique polynomial of degree one
that passes through (0, S) and ( ˜X, ˜Y ), which is equal to f (X) =
12X + 5. Then, both compute Yk = f (Xk) for k ∈ {1, 2, 3}.
Thus, Y1 = 12, Y2 = 3 and Y3 = 8. The veriﬁers store these
variables. Then according to the requests that user 2 has sent to
each veriﬁer and the SPIR algorithm, using common variable R,
the veriﬁers send answers to the user such that he can retrieve
Y2 = 3 privately without gaining any information about Y1 and
Y3. Veriﬁer 1, also, sends ( ˜X, ˜Y ) = (15, 1) to user 2.

• User 2 computes the unique polynomial that passes through
(X2, Y2) = (19, 3) and ( ˜X, ˜Y ) = (15, 1), that is equal to
f (X) = 12X + 5. Thus user 2 can compute S = f (0) = 5.
He sends S = 5 to veriﬁer 1.

Converse: According to Lemma 1, R ≤ 1 in q-ary unit

and Rc = 1
lc

≤ 1.

Achievability: We describe DMS-FR for lc = 1, but any
lc is achievable by enlarging the space of variables lc times.
Proof outline: In one hand, the veriﬁers must not gain any
information about the identity of the user by observing
the requests for helper data (privacy constraint), and on
the other hand, it is desired that the users cannot com-
pute the keys of other users observing the helper data.
Thus, the proposed DMS-FR protocol uses SPIR to pri-
vately deliver the desired data to the prover. Here, the
veriﬁers have the role of the servers with replicated data
(X1, X2, · · · , XK). In each veriﬁcation process, the veriﬁers
compute Yk = f (Xk), ∀k ∈ [K], where f (.) is a degree
one polynomial speciﬁed by the CA. So, (Y1, Y2, · · · , YK)
are stored in all the veriﬁers. SPIR is run between user k
and the veriﬁers, such that the user can attain Yk pri-
vately, without gaining any information about Y−k, where
Y−k = (Y1, Y2, · · · , Yk−1, Yk+1, · · · , YK). In addition to Yk,
another point on f (.) is sent to the user as helper data. Using
this point, Yk, and Xk, known to the user as his personal
key, the user can compute f (.), and thus he can compute
the secret. The detailed steps of the protocol are as follows:
1) Key distribution phase: The CA chooses X1, · · · , XK from
the ﬁeld C = GF (qL), independently and uniformly at ran-
dom. It is worth noting that in this protocol, the condition
that Xk’s must be distinct is not necessary. Then, CA sends
Xk to the k-th legitimate user, Ck = Xk.
2) Authentication phase: in each veriﬁcation process:

S1: User k privately generates a random variable F . This

variable is not available to the veriﬁers and represents the
randomness in the strategies followed by the user in the
SPIR protocol [21, Theorem 3] (described in Appendix C).
For n ∈ [N ], user k sends authentication query Q[k]
n to
veriﬁer n according to SPIR, to ask the veriﬁers to send M [k]
n
for him in a manner to retrieve his speciﬁed data without
revealing his identity5. More precisely, user k sends queries
in a way that he can retrieve the desired data with index
k, without revealing k to any of the veriﬁers. His query to
veriﬁer n∗ also includes a request for authentication.

S2: The CA chooses S, randomly from the ﬁeld
GF (qL) as secret, and the point ( ˜X, ˜Y ) where ˜X ∈
GF (qL)\{0, Xk| k ∈ [K]} and ˜Y ∈ GF (qL) are chosen
independently and uniformly at random. Also CA gen-
erates a common random variable R ∈ Fq. CA sends
(cid:111)
(cid:110)
X1:K, S, R, ( ˜X, ˜Y )
to all the veriﬁers.
S3: Each veriﬁer generates the unique polynomial f (.)
of degree one that passes through {(0, S), ( ˜X, ˜Y )} and com-
putes Yk = f (Xk) for k ∈ [K]. Y1,· · ·,YK are the replicated
data stored in all the veriﬁers, R is the common shared
randomness between the veriﬁers and the prover wants
to retrieve Yk privately. According to Q[k]
n and R, using
SPIR [21, Theorem 3], veriﬁer n generates answers A[k]
n . The
queries and the answers have the following properties:

H(An|Qn, Y1, · · · , YK, R) = 0
(Q[k1]
n , A[k]
n , A[k1]
I(Y−k; Q[k]

n , Y1:K, R) ∼ (Q[k]
1:N , A[k]

1:N , F) = 0, ∀k ∈ [K].

n , Y1:K, R), ∀k1, k∈[K]

(15)

(16)

(17)

n∗ as helper data. More precisely, M [k]

n∗ = S, and sends ( ˜X, ˜Y ) in addition
n for n ∈

n = A[k]

The veriﬁer n∗ sets S[k]
to A[k]
[N ]\{n∗} and M [k]

n∗ = {A[k]

n∗ , ( ˜X, ˜Y )}.
S4: According to equation (32), user k can compute
Yk using A[k]
1:n correctly. Thus, user k knows ( ˜X, ˜Y ) and
(Xk, Yk). So, he can compute the polynomial f (.) and thus
he can ﬁnd the secret. The prover sends the estimated secret
ˆS[k]
n∗ to the veriﬁer n∗.
n∗ = S[k]

n∗ the veriﬁer accepts the prover as a

S5: If ˆS[k]
legitimate user.

These steps determine the variables of P Multi. Now we

analyze completeness, soundness, and privacy conditions.
0 -Completeness: User k has Xk as his own personal key. In
each veriﬁcation process, he obtains Yk performing SPIR
and ( ˜X, ˜Y ) as a helper data. Thus, he has two points
of a polynomial of degree one, and he can compute the
polynomial and also the secret. So regardless of the veriﬁer
ˆS[k]
n∗ = S[k]
n∗ for k ∈ [K] and each legitimate user can
compute the secret correctly. Thus:

P[ ˆH = 1|H = 0] = P[ ˆS[k]

n∗ (cid:54)= S[k]

n∗ ] = 0.

(18)

This proves the 0-completeness property of the scheme.
1
|S| -Soundness: In each veriﬁcation process, the attacker can
obtain ( ˜X, ˜Y ) and Yk, where k is the index he masquerades
with. But, since he has no information about Xk (can be
any element of the ﬁeld GF (qL)), he cannot gain any

5. Considering the equivalence between GF (qL) and FL

q SPIR can be

executed.

information about the secret, i.e., I(S; M ) = 0. Considering
that S is uniformly distributed), we have:

P[ ˆH = 0|H = 1] = P[ ˆSn∗ = S] =

1
qL .

(19)

10

|S| -soundness property and means that the

This proves the 1
best possible attack strategy is guessing the secret.
0 -Privacy: Every legitimate user can compute the secret cor-
rectly and since SPIR protocol is performed (equation (16))
the veriﬁers cannot detect the index of the prover through
queries they received, Thus ∀k, k1 ∈ [K] and ∀n ∈ [N ]:
(Vn, Q[k1]

n ) ∼ (Vn, Q[k]

n , M [k1]

n , ˆS[k1]

n , ˆS[k]
n ),

n , M [k]

n , S[k]

n , S[k1]
and 0-Privacy is satisﬁed.

Now we can compute the normalized total key rate of

the proposed protocol in q-ary unit as:
H(C1, C2, · · · , CK)
Kl

R =

=

H(X1, X2, · · · , XK)
KL

(a)
=

H(X1) + · · · + H(XK)
KL

=

KH(X1)
KL

(b)
= 1,

(20)

where (a) and (b) are obtained by considering X1, · · · , XK
are chosen uniformly at random from the ﬁeld GF (qL). (cid:3)

Remark 15. In the DMS-FR protocol, any number (more than
two) of the veriﬁers can participate (in the SPIR algorithm), but
the larger the number of the veriﬁers the lower the total data rate
between the veriﬁers and the prover [21]. On the other hand, the
smaller the number of the veriﬁers the lower the total data rate
between the CA and the veriﬁers (because the CA sends Vn to the
smaller set of the veriﬁers).

4.5 Proof of Theorem 5 (multi-server, individual authen-
tication, asymptotic regime)

it

that R ≤

Here, the multi-server asymptotic version of the PA proto-
col is considered, i.e., all the variables of the protocol are
sequences of length Θ(l) for arbitrary large l.
Converse: For
is obvious
converse,
maxp(y) H(Y ).
Achivability: The proof is mostly similar to the proof of
Theorem 2. The main difference is that the key of the user
k must be correlated to the data available at all the veriﬁers
that he forms feasible pair with. The proposed achievable
scheme in the multi-server in the asymptotic regime, (MS-
AR) PA protocol, is as follows:
1) Key distribution phase: Considering auxiliary random
∈
variables X1, X2, · · · , XN
U , ﬁx a joint distribution PU1:N X1:N Y (u1:N , x1:N , y) =
(cid:0)PXn(xn)PUn|Xn (un|xn)(cid:1) PY |X1:N (y|x1:N ), such that
(cid:81)N
0 < I(Un; Y ) ≤ I(X1:N ; Y ) = µ, ∀n ∈ [N ]. Fixing ξ
and ξ(cid:48) such that ξ > ξ(cid:48) > 0 and for each n ∈ [N ],
obtaining marginal distributions PUn (un), form the sets Jn
by randomly and independently generating 2l ˜Rn sequences
of U l
i=1 PUn (uni). Randomly partition
each set Jn to 2lR(cid:48)
n equal size subsets (bins). So, each bin
contains 2l( ˜Rn−R(cid:48)
n ∈ Jn can
be shown as U l
n(mn, sn), where mn is the bin index and
sn is the index of sequence in the bin mn. The sequences
U l
n(mn, sn) constitutes the codebooks, and are revealed to
every participant of the protocol. From each marginal distri-
bution PXn (xn), CA generates i.i.d sequence X l
n. Denoting

n) sequences. Each sequence U l

n, each according to (cid:81)l

∈ X and U1, ..., UN

n=1

n|n ∈ N [k]}. For each k ∈ [K], generate
k according to the conditional distribution
N [k] ∼ (cid:81)l
k |X l
). CA
i=1 PY |X
k to the user k for k ∈ [K].

X l
N [k] = {X l
the sequence Y l
i.e., Y l
PY |X
N [k] ,
sends Ck = Y n
2) Authentication phase: Veriﬁer n acts similar to SS-AR using
U l
n(mn, sn) as codebook. The prover proves that his key,
Y l
k , is correlated to the n-th veriﬁer’s sequence X l
n using
codebook U l
n(mn, sn) and helper data mn that the veriﬁer
n sends to him the same as SS-AR.

N [k] (yi|xN [k]

i

The analysis of probabilities of error is the same as SS-
AR protocol, and for completeness the conditions ˜Rn >
I(Un; Xn) and ˜Rn − R(cid:48)
The normalized total key rate of the proposed scheme is:

n < I(Un; Y ) must be satisﬁed.

R =

H(C1, · · · , CK)
Kl
1 , . . . , Y l
Kl

K|X l

H(Y l

≥

H(Y l

=

(cid:80)K

1:N )

=

K)

1 , · · · , Y l
Kl
i=1H(Y l
Kl

i |X l

1:N )

= H(Y |X1:N ).

In the converse we showed that R ≤ maxp(y) H(Y ). The
difference of H(Y ) and H(Y|X1:N ) is equal to I(X1:N;Y ) =
µ. Thus, if µ → 0 and by ﬁxing p(y) such that H(Y ) reaches
its maximum, the optimal rate Casy = H(Y ) is achievable. (cid:3)

5 COMPARISON AND CONCLUDING REMARKS

11

• DMS-FR is proposed for the case that all the users are
making feasible pairs with all the veriﬁers, however MS-
FR and MS-AR protocols are feasible for any connection
structure.

• As stated in Remark 14, in the MS-FR2 protocol, the
users can gain information about other users’ keys (the
space of the estimated keys may be small). Thus, security of
the keys is not provided. However, in the DMS-FR, because
of the changes of the polynomial and the secret in each
veriﬁcation process, the users cannot gain any information
about other users’ keys. This happens because if a user
wants to gain information about other users’ keys, he acts
exactly the same as an attacker, which his functionality is
analyzed in soundness property in Theorem 4.

• The size of the keys are smaller in the DMS-FR com-
pared with the MS-FR2 protocol for a ﬁxed Pe2-soundness
constraint. For example for Pe2 = 1
qL , in DMS-FR Ck ∈
GF (qL), but in MS-FR2, Ck ∈ GF (qL)2.

• The complexity of computing secret in the DMS-FR
protocol is far less than the MS-FR2 protocol. Since in the
DMS-FR protocol, the participants compute a polynomial of
degree one, but in the MS-FR2 protocol, the polynomial of
veriﬁer n is of degree equal to |Nn|.

Remark 16. Some extra services are available in DMS-FR;
however, none of the MS-FR1, MS-FR2, and MS-AR can provide
these services. The detailed discussion is stated in Subsection 5.2.

In this section, we ﬁrst compare the proposed protocols and
then we introduce some notable remarks.

5.2 Extra Services

5.1 Comparison

In this subsection, ﬁrst, we compare the protocols in the
ﬁnite size and asymptotic regimes. Then, the differences
and properties of individual authentication and distributed
authentication are discussed.
Finite size vs asymptotic
In the ﬁnite size regime, the variables are elements of
ﬁnite ﬁelds, but the variables in the asymptotic regime are
sequences of length Θ(l), for arbitrary large l. Although, all
the protocols proposed for the ﬁnite size regime are practi-
cal, the SS-FR and MS-FR protocols are not optimal. Thus,
the SS-AR and MS-AR protocols (in asymptotic regime) are
proposed to show that optimal protocols are achievable.
Individual vs distributed
The main difference between these two authentication meth-
ods is how the CA and the veriﬁers cooperate jointly to
privately authenticate the prover. In the individual case in
each veriﬁcation process, the prover is connected to only
one veriﬁer and that one veriﬁer sends the helper data to the
prover. Also, except the only time that the CA sends the keys
of users (in the MS-FR1), the secret and the keys of the users
(in the MS-FR2) and X l
n and the keys of the users (in the
MS-AR) to the veriﬁers, there is no need for data exchange
between the CA and the veriﬁers in any veriﬁcation process.
In the distributed case, the prover is connected to all (or
some) of the veriﬁers and these veriﬁers send helper data
to the prover. In the DMS-FR protocol, there is a permanent
interaction between the CA and the veriﬁers in the process
of authentication. In the following some other differences
between MS-FR/MS-AR and DMS-FR are stated:

Some extra services can be considered in PA protocol, which
we describe in the following. While these services are not
central to the protocol, they can strengthen the performance
of the protocol. We discuss which of the proposed protocols
in Section 4 provide each extra service.
Auditing: This service enables the CA to recognize the
prover. There are systems and services that the CA is
required to recognize the prover, e.g., to identify the ma-
licious behavior. More precisely, auditing means while the
veriﬁer (veriﬁers) cannot distinguish the index of the prover
(i.e., legitimate user), the CA can distinguish the index
of the legitimate user by observation of the veriﬁcation
process. Noting that the CA observes the entire process and
C, Q[θ]

1:N , V variables, this means,
1:N , M [θ]
where θ is uniformly and randomly chosen from [K].

1:N , M [θ]
H(θ|C, Q[θ]

1:N , ˆS[θ]
1:N , S[θ]

1:N , V1:N ) = 0,

1:N , S[θ]

1:N , ˆS[θ]

(21)

• SS-FR1, SS-FR2, SS-AR, MS-FR1, MS-FR2 and MS-
AR: In these protocols, each legitimate prover sends the
same secret key in any veriﬁcation process. Moreover, the
authentication query is just a request for authentication and
thus, there is no difference between the users. So, neither
the veriﬁer nor the CA can detect the ID of the legitimate
prover. Thus auditing is not provided.

• DMS-FR: Since CA has access to all of the veriﬁers, he
has access to Q[k]
1:N , considering the prover is user k. More
precisely, in SPIR, if one has access to all the queries sent
from the prover he can recognize the index of the data the
prover asks for. Thus, the CA can recognize the index ”k”
and (21) is satisﬁed.
Addition and deletion of users: This service means that

the set of users, [K], and its partitioning in the multi-server
scenario can be changed in each veriﬁcation process. In
general, this service enables the CA to update the list of
users (add or delete a user) and its partitioning in each
veriﬁcation process without information leakage (to the
attackers or other users) of secret variables of the protocol.
• SS-FR1 and MS-FR1: It is possible to add a new user,
by sending the common key, ˜C, to him. Deleting a user is
only possible by re-running the key distribution phase and
generating a new ˜C, such that the deleted user does not
have access to it.

• SS-FR2 and MS-FR2: This property cannot be provided.
Adding and deleting a user change the unique polynomial
that passes through the keys of the legitimate users. The
intersection points of the polynomial before deleting or
adding a user and the new polynomial are the keys (Xk, Yk)
of the other users. Thus, this can reveal the keys. Of course,
only legitimate users can compute the polynomials, and as
a result the keys of other users.

• SS-AR and MS-AR: It is possible to add a new legit-
imate user, user K + 1, by generating Y n
K+1 using appro-
priate conditional distribution the same as the process of
generating other keys (key distribution phase in the proof of
Theorems 2 and 5). But for the deletion of a user, the entire
key distribution phase must be re-run to generate new X n
and new keys for other users. As a result, the key of the
deleted user is not jointly typical with new X n (with high
probability), and thus the deleted user cannot compute the
new secret.

• DMS-FR: Both addition and deletion of users can be
provided in this protocol. Since the degree one polynomial
function, f (.), in each veriﬁcation process does not depend
on the keys of users, addition and deletion of the keys do
not leak any information. In other words, if CA wants to
add a user to the protocol, he should select a key randomly,
update the list of the keys, and announce this update to all
the veriﬁers. On the other hand, if the CA wants to delete a
user, he declares to the veriﬁers to delete that user’s key.
Expiring secret: This condition implies that the secret must
be changed in each veriﬁcation process. The reason behind
this is that the legitimate user might be intended to reveal
the secret since their own personal keys are immune. In ad-
dition, in the veriﬁcation process or secret storing, the secret
might be exposed. Thus, if in each veriﬁcation process, the
secret changes, the security of the protocol is enhanced.

• SS-FR1 and MS-FR1: Since the secret is equal to ˜C, key
of all users, it is not possible to change the secret in each
veriﬁcation process.

• SS-FR2 and MS-FR2: Changing the secret in each ver-
iﬁcation process means changing the unique polynomial,
similar to the condition in addition and deletion service, and
by detecting the intersection points of these polynomials the
users can get (Xk, Yk) of other users. So this property is not
provided.

• SS-AR and MS-AR: In this protocol changing the secret
in each veriﬁcation process means changing X n and as a
result changing the keys of the users. So, the expiring secret
feature is not provided.

• DMS-FR: As stated in the protocol in each veriﬁcation
process the CA chooses a secret at random. So, the secret

changes in every veriﬁcation process and this feature is
available.

12

5.3 Additional Attacks

We consider the following attacks in addition to two attacks
that are considered in the system framework, 1) the (semi-
honest) veriﬁer wants to violate privacy, 2) an attacker wants
to be authenticated illegally. We analyze the resistance of our
proposed protocols against these attacks.
Colluding legitimate users: Legitimate users collude to gain
information about other users’ keys.

• SS-FR1 and MS-FR1: Since the keys of all users are the

same, this attack is not valid.

• SS-FR2 and MS-FR2: Colluding legitimate users cannot
get any information beyond the unique polynomial. So they
cannot get additional information about other users’ keys by
colluding, and the protocol is resistant against this attack.

• SS-AR and MS-AR: Since the keys of the legitimate
users have some common information, colluding users can
gain some information about other users’ keys.

• DMS-FR: Each authentication request means a new
veriﬁcation process and as a result, a new secret and a new
polynomial. Thus colluding legitimate users have access
to secret and polynomials that are independent from each
other, so they cannot get any additional information by
colluding. If a legitimate user wants to attack the protocol to
violate secrecy, his performance is like an attacker, that his
success probability is computed in (19).
Malicious Veriﬁer: We have considered semi-honest ver-
iﬁers, who follow the protocol. But, in a stronger attack
scenario, it is possible that the veriﬁers do not follow the
protocol and send helper data in a way to violate the privacy
of the prover or disrupt the process of authentication. In
this situation, the veriﬁer may send incorrect helper data to
distinguish the identity of the legitimate prover or disrupt
the authentication process.

• SS-FR1 and MS-FR1: No helper data is sent in these
schemes, thus, this attack is not valid and cannot be oc-
curred.

• SS-FR2, and MS-FR2: There are two possibilities for the

malicious veriﬁer action:

1) The malicious veriﬁer can include the key of one or
some of the users in the helper data. More precisely,
Ck1, Ck2, · · · , CKj ⊂ C can be part of helper data. In
this case, if the prover is one of K1, K2, · · · , Kj, he has
K points of the polynomial, so he cannot compute the
polynomial and cannot be authenticated as a legitimate
user. However, from the viewpoint of the veriﬁer, there
is no difference between this user and an attacker.
So, the veriﬁer cannot violate the privacy of the user.
Of course, the user realized that the veriﬁer does not
follow the protocol and can report. On the other hand, if
the prover is not any of K1, K2, · · · , Kj, authentication
continues and the veriﬁer realizes that the prover is one
of the [K]\{K1, K2, · · · , Kj}.

2) The malicious veriﬁer can send completely wrong
helper data. In this case, the veriﬁer can check that with
which key the estimated secret is computed and detect
the user.

These protocols cannot overcome this attack, unless CA
himself produces helper data, sends the helper data to the
veriﬁer and forces the veriﬁer to send this helper data.

• SS-AR and MS-AR: This means that the veriﬁer sends
the wrong bin index. These protocols cannot overcome this
attack, unless CA himself produces helper data, sends the
helper data to the veriﬁer and forces the veriﬁer to send the
correct helper data.

• DMS-FR: If the malicious veriﬁer is any veriﬁer except
n∗, since the estimated secret is not sent to him, he cannot
detect the index of the user and violate privacy. However,
the prover cannot estimate the secret correctly. If the mali-
cious veriﬁer is n∗, he can send ¯X and ¯Y in such a way to
distinguish the index of user and privacy is violated. The
protocol cannot overcome any of these situations.
Colluding veriﬁers: Veriﬁers collude to detect the prover’s
identity and violate privacy. It is worth mentioning that this
attack is possible in the multi-server scenario.

• MS-FR1, MS-FR2, and MS-AR: In these protocols, in
each veriﬁcation process only one veriﬁer is participating.
Thus, this attack is not feasible.

• DMS-FR: Colluding veriﬁer can get some information
about the index of the data requested by the prover and
thus, they may gain some information about the prover’s
identity. To overcome this attack a T -collude SPIR algo-
rithm according to [27] can be performed, which is resistant
against colluding of T veriﬁers.

5.4 Distributed Authentication for any Structure

The proposed DMS-FR PA protocol is feasible for the cases
that all the veriﬁers are connected to all the provers. Solv-
ing the distributed authentication problem in the multi-
server PA protocol scenario for any desired connection
structure between the provers and the veriﬁers is of interest.
Of course, in the case that for each prover, there exist
at least two veriﬁers such that the prover forms feasible
pair with them, N [k], and ∀k ∈ [K], we have A[k] =
{(cid:84)
n∈N [k] Nn}\{k} (cid:54)= ∅, similar protocol to DMS-FR can be
used as a solution. In the solution, when user k requests
authentication, only the veriﬁers in N [k] collaborate in the
process of authentication (especially the SPIR algorithm). In
this case, considering user k, privacy is satisﬁed between k
and provers in A[k].

5.5 Key-sharing

In the ﬁnite size regime, by repeating the veriﬁcation process
t times to improve security (soundness), then the achiev-
able region can be deﬁned in a real-valued alphabet. Then
asymptotically using key-sharing, the lower convex of the
achievable points can be achieved. Inspired by time-sharing,
we propose key-sharing scheme, where if any two points
(R1, Rc1) and (R2, Rc2) are achievable, then the line con-
necting them is achievable, too.

APPENDIX A
Lemma 2. If I(U ; J) ≤ α, where U ∈ U and J ∈ J , then
P[U = g(J)] ≤ 1+α+log |U |−H(U )
, with g : J → U be any
arbitrary function.

log |U |

13
Proof: Let ˆU = g(J). Using Fano’s inequality, we have

H(U | ˆU ) ≤ 1 + P[U (cid:54)= ˆU ] log |U|.
(22)
On the other hand, since U → J → ˆU forms a Markov chain
and I(U ; J) ≤ α, we obtain I(U ; ˆU ) ≤ α, and thus:

H(U | ˆU ) ≥ H(U ) − α.

(23)

Combining (22) and (23), we have:

H(U ) − α ≤ 1 + P[U (cid:54)= ˆU ] log |U|,

and noting that 1 − P[U (cid:54)= ˆU ] = P[U = ˆU ], we obtain:

P[U = ˆU ] ≤

1 + α + log |U| − H(U )
log |U|

.

APPENDIX B
PROBABILITY OF ERROR ANALYSIS OF THEOREM 2
To complete the proof, here we have to show that in the
proposed SS-AR protocol Pe1, Pe2, and PP tends to zero as
l goes to inﬁnity.
Completeness: The veriﬁer rejects ( ˆH = 1) the legitimate
prover (user k, H = 1) if ˆS[k] (cid:54)= S[k], and this may happen
if either of the following events occurs:

1) E1: The veriﬁer does not ﬁnd a sequence U l that is

jointly typical with X l.

2) E2: User k does not ﬁnd a sequence ˆU l that is jointly

typical with Y l
k .

3) E3: User k ﬁnds more than one sequence ˆU l in bin M [k]

that is jointly typical with Y l
k .
Using the union bound, we obtain:

P[ ˆH = 1|H = 0] = P[ ˆS[k] (cid:54)= S[k]] ≤ P[E1] + P[E2 ∩ Ec
1]

+ P[E3 ∩ Ec
1].

By covering lemma [26], if ˜R ≥ I(X; U ) + ϕ(ξ(cid:48)) (there are
more than 2lI(U ;X) sequences in J ), P[E1] → 0 when l →
∞. Also, using LLN and the fact that ξ > ξ(cid:48), P[E2 ∩ Ec
1] → 0
as l → ∞. And if ˜R − R(cid:48) ≤ I(U ; Y ) − ϕ(ξ) (there exist less
than 2lI(U ;Y ) sequences in bin M [k]), according to packing
lemma [26], P[E3 ∩ Ec
1] → 0 for large enough l. ϕ(ξ) and
ϕ(ξ(cid:48)) are functions of ξ and ξ(cid:48), respectively, that goes to
0 as ξ, ξ(cid:48) → 0. So, by setting ˜R = I(X; U ) + ϕ(ξ(cid:48)) and
R(cid:48) = I(X; U ) − I(U ; Y ) + ϕ(ξ) + ϕ(ξ(cid:48)), we obtain:

P[ ˆH = 1|H = 0] = 0.

lim
l→∞

(24)

This proves the completeness property of the proposed
scheme.
Soundness: From [17, (31)], we have I(S; M ) ≤ l(ϕ(ξ(cid:48)) + ζ),
where ζ is a function of ξ(cid:48) and goes to 0 as l → ∞.
This means that the data the veriﬁer sends to the prover
contains negligible information about the secret on average.
Substituting α = l(ϕ(ξ(cid:48)) + ζ) in Lemma 2, we conclude that
P[S = ˆS] ≤ 1+l(ϕ(ξ(cid:48))+ζ+log |S|−H(S))
. Since S ranges from
1 to 2l(I(U ;Y )−ϕ(ξ)), we have log |S| = l(I(U ; Y ) − ϕ(ξ))
and using [17, (30)], H(S) ≥ l (I(U ; Y ) − ϕ(ξ) − ϕ(ξ(cid:48)) − ζ).
Thus:

log |S|

P[ ˆH = 0|H = 1] = P[S = ˆS] ≤

1 + l(2ζ + 2ϕ(ξ(cid:48)))
l(I(U ; Y ) − ϕ(ξ))

.

(25)

Since ξ, ξ(cid:48) → 0, we have liml→∞
soundness property is proved.
Privacy: Now we analyze Pp-privacy property of the sug-
gested protocol. First, we deﬁne the event E as:

(2ζ+2ϕ(ξ(cid:48)))
(I(U ;Y )−ϕ(ξ)) → 0, and the

(cid:104)

E =

(V, Q[1], S[1], M [1], ˆS[1]) ∼

(cid:105)
(V, Q[k], S[k], M [k], ˆS[k]), ∀k ∈ [K]

.

If event E occurs with probability 1, we have perfect pri-
vacy. Now we consider the case that E does not occur.

P[Ec] = P

(cid:104)

∃k ∈ [K] : (V, Q[1], S[1], M [1], ˆS[1]) (cid:28)
(cid:105)
(V, Q[k], S[k], M [k], ˆS[k])

(a)
≤ P[∃k ∈ [K] : ˆS1 (cid:54)= ˆSk]

(b)
≤

K
(cid:88)

k=2

P[ ˆS1 (cid:54)= ˆSk],

(26)

(a)

fact

follows

from the

where
if
(V, Q[1], S[1], M [1], ˆS[1]) (cid:28) (V, Q[k], S[k], M [k], ˆS[k]), then
ˆS[1] (cid:54)= ˆS[k] (while there may exist situations that ˆS[1] (cid:54)= ˆS[k]
but (V, Q[1], S[1], M [1], ˆS[1]) ∼ (V, Q[k], S[k], M [k], ˆS[k])),
and (b) is obtained using union bound. Now, for a ﬁxed k
(cid:54)= ˆS[k]} may happen in
we compute P[ ˆS[1]
the following cases:

(cid:54)= ˆS[k]]. { ˆS[1]

that

• P1: The veriﬁer does not ﬁnd a sequence U l that is

jointly typical with X l.

• P2: Both user 1 and user k do not ﬁnd a sequence ˆU l

that is jointly typical with Y l

1 and Y l

k , respectively.

• P3: User 1 ﬁnds a unique ˆU l that is jointly typical with
1 , but user k does not ﬁnd a sequence ˆU l that is jointly
Y l
typical with Y l
k .

• P4: User k ﬁnds a unique ˆU l that is jointly typical with
k , but user 1 cannot ﬁnd a sequence ˆU l that is jointly
Y l
typical with Y l
1 .

• P5: User 1 ﬁnds a unique ˆU l that is jointly typical with
1 , but user k ﬁnds more than one sequence ˆU l that is
Y l
jointly typical with Y l
k .

• P6: User 1 does not ﬁnd a sequence ˆU l that is jointly
1 , but user k ﬁnds more than one se-

typical with Y l
quence ˆU l that is jointly typical with Y l
k .

• P7: User k ﬁnds a unique ˆU l that is jointly typical with
k , but user 1 ﬁnds more than one sequence ˆU l that is
Y l
jointly typical with Y l
1 .

• P8: User k does not ﬁnd a sequence ˆU l that is jointly
k , but user 1 ﬁnds more than one se-

typical with Y l
quence ˆU l that is jointly typical with Y l
1 .

• P9: Both user 1 and user k ﬁnd more than one sequence

ˆU l that is jointly typical with Y l

1 and Y l

k , respectively.

Using union bound, we have:

P[ ˆS[1] (cid:54)= ˆS[k]] ≤

9
(cid:88)

i=1

P[Pi].

(27)

It should be considered that there are 2l(I(U ;X)+ϕ(ξ(cid:48))) of U l
sequences in J and there are 2l(I(U ;Y )−ϕ(ξ)) of U l sequences
in each bin. As a result, by covering lemma, P[P1] → 0.
By LLN, P[P2], P[P3], and P[P4] go to zero when l is

DB1

Y1
Y2
· · ·
YK
R

(cid:56)

θ

14

DB2

Y1
Y2
· · ·
YK
R

(cid:56)

θ

Query

Answer

Query

Answer

User

Yθ (cid:52)
Y1, · · · , Yθ−1, Yθ+1, · · · , YK (cid:56)

Fig. 4. The SPIR problem with two databases and K messages.

sufﬁciently large. By packing lemma and LLN, P[Pi] for
i ∈ {5, 6, 7, 8, 9} tends to zero as l → ∞. So, we conclude:

P[ ˆS[1] (cid:54)= ˆS[k]] = 0,

lim
l→∞

(28)

and since K is ﬁxed:

lim
n→∞

P[Ec] = 0,

and

(cid:104)

P

lim
l→∞

(V, Q[1], S[1], M [1], ˆS[1]) ∼

(V, Q[k], S[k], M [k], ˆS[k]) ∀k ∈ [K]

This completes privacy property.

(cid:105)

= 1.

(29)

(cid:3)

APPENDIX C
SYMMETRIC PRIVATE INFORMATION RETRIEVAL
Here, we describe the SPIR protocol presented in [21] and is
used in our proposed DMS-FR protocol.

Consider K independent messages, Y1, Y2, · · · , YK , and
N servers that each stores all the messages. The user θ
wishes to retrieve Yθ privately, and the servers do not want
the user to get any information beyond the desired mes-
sage, Yθ (database privacy). The user generates a random
variable F privately. This random variable represents the
randomness in the strategies followed by the user, and its
realization is not available to the servers. The servers share a
common random variable R that is unknown to the user, to
achieve database privacy. An example of the SPIR problem
is illustrated in Fig. 4.

In order to retrieve message Yk, k ∈ [K] privately, the

user privately generates N queries Q[k]
H(Q[k]

1 , · · · , Q[k]

N |F) = 0.

1 , · · · , Q[k]
N ,

(30)

n to the n-th server, n ∈ [N ]. Upon
n , the n-th server generates an answer sequence
n , all messages Y1, · · · , YK ,

The user sends Q[k]
receiving Q[k]
A[k]
n , which is a function of Q[k]
and the common randomness R,
H(A[k]

n |Q[k]

n , Y1, · · · , YK, R) = 0.

(31)

The n-th server returns A[k]
Yk using the information available to him, A[k]

n to the user. The user decodes
1:N , F ,

1:N , Q[k]

15

[17] L. Lai, S.-W. Ho, and H. V. Poor, “Privacy-security tradeoffs in
biometric security systems,” in Communication, Control, and Com-
puting, 2008 46th Annual Allerton Conference on.
IEEE, 2008, pp.
268–273.

[18] T. Ignatenko and F. M. Willems, “Biometric systems: Privacy and
secrecy aspects,” IEEE Transactions on Information Forensics and
security, vol. 4, no. 4, p. 956, 2009.

[19] F. M. J. Willems and T. Ignatenko, “Authentication based on
secret-key generation,” in Proceedings of the 2012 IEEE International
Symposium on Information Theory, ISIT 2012.
IEEE, 2012, pp. 1792–
1796.

[20] H. U. Rehman, A. Ghani, S. A. Chaudhry, M. H. Alsharif, and
N. Nabipour, “A secure and improved multi server authentication
protocol using fuzzy commitment,” Multim. Tools Appl., vol. 80,
no. 11, pp. 16 907–16 931, 2021.

[21] H. Sun and S. A. Jafar, “The capacity of symmetric private infor-
mation retrieval,” IEEE Trans. Information Theory, vol. 65, no. 1, pp.
322–329, 2019.

[22] A. Shamir, “How to share a secret,” Communications of the ACM,

vol. 22, no. 11, pp. 612–613, 1979.

[23] A. D. Wyner and J. Ziv, “The rate-distortion function for source
coding with side information at the decoder,” IEEE Trans. Inf.
Theory, vol. 22, no. 1, pp. 1–10, 1976.

[24] M. Fujiwara, A. Waseda, R. Nojima, S. Moriai, W. Ogata, and
M. Sasaki, “Unbreakable distributed storage with quantum key
distribution network and password-authenticated secret sharing,”
Scientiﬁc reports, vol. 6, p. 28988, 2016.

[25] A. Orlitsky and J. R. Roche, “Coding for computing,” IEEE Trans.

Inf. Theory, vol. 47, no. 3, pp. 903–917, 2001.

[26] A. El Gamal and Y.-H. Kim, Network information theory. Cam-

bridge university press, 2011.

[27] Q. Wang and M. Skoglund, “Secure symmetric private information
retrieval from colluding databases with adversaries,” in 55th An-
nual Allerton Conference on Communication, Control, and Computing,
Allerton 2017.

IEEE, 2017, pp. 1083–1090.

according to a decoding rule speciﬁed by the SPIR scheme,
that is:

1:N , F) = o(L),

(32)

1
L
where H(Yk) = Llk, k ∈ [K].

H(Yk|A[k]

1:N , Q[k]

To protect the users’ privacy, K strategies must be indis-
tinguishable from the perspective of any individual server:

(A[k]
(A[k(cid:48)]

1:N , Q[k]
1:N , Q[k(cid:48)]

1:N , Y1:K, R) ∼
1:N , Y1:K, R) ∀k, k(cid:48) ∈ [K], ∀n ∈ [N ].

(33)

To protect the privacy of database, the user must not get

any information beyond his desired message, thus:

I(Y−k; A[k]

1:N , Q[k]

1:N , F) = 0,

∀k ∈ [K],

(34)

where Y−k = Y1, · · · , Yk−1, Yk+1, · · · , YK .

For detailed description of the SPIR problem and its

scheme, please refer to [21].

REFERENCES

[1] N. Kazempour, M. Mirmohseni, and M. R. Aref, “Private authen-
tication: Optimal information theoretic schemes,” in 2019 IEEE
Information Theory Workshop, ITW 2019.

IEEE, 2019, pp. 1–5.

[2] A. Pﬁtzmann and M. Hansen, “Anonymity, unlinkability,
undetectability, unobservability, pseudonymity, and identity
management-a consolidated proposal for terminology,” Version v0,
vol. 31, p. 15, 2008.

[3] N. Alexiou, M. Lagan`a, S. Gisdakis, M. Khodaei, and P. Pa-
padimitratos, “Vespa: Vehicular security and privacy-preserving
architecture,” in Proceedings of the 2nd ACM workshop on Hot topics
on wireless network security and privacy. ACM, 2013, pp. 19–24.
[4] R. Roman, J. Zhou, and J. Lopez, “On the features and challenges
of security and privacy in distributed internet of things,” Computer
Networks, vol. 57, no. 10, pp. 2266–2279, 2013.
[5] N. Van Saberhagen, “Cryptonote v 2.0,” 2013.
[6]

S. Goldwasser, S. Micali, and C. Rackoff, “The knowledge com-
plexity of interactive proof systems,” SIAM J. Comput., vol. 18,
no. 1, pp. 186–208, 1989.

[7] M. Chen and S. Chen, “An efﬁcient anonymous authentication
protocol for RFID systems using dynamic tokens,” in 35th IEEE
International Conference on Distributed Computing Systems, ICDCS
2015.
J.-L. Tsai and N.-W. Lo, “A privacy-aware authentication scheme
for distributed mobile cloud computing services,” IEEE systems
journal, vol. 9, no. 3, pp. 805–815, 2015.

IEEE Computer Society, 2015, pp. 756–757.

[8]

[9] D. He, S. Zeadally, N. Kumar, and J.-H. Lee, “Anonymous authen-
tication for wireless body area networks with provable security,”
IEEE Systems Journal, vol. 11, no. 4, pp. 2590–2601, 2017.

[10] G. J. Simmons, “Authentication theory/coding theory,” in Work-
shop on the Theory and Application of Cryptographic Techniques.
Springer, 1984, pp. 411–431.

[11] L. Lai, H. El Gamal, and H. V. Poor, “Authentication over noisy
channels,” IEEE Transactions on Information Theory, vol. 55, no. 2,
pp. 906–916, 2009.

[12] U. M. Maurer, “Authentication theory and hypothesis testing,”
IEEE Transactions on Information Theory, vol. 46, no. 4, pp. 1350–
1356, 2000.

[13] L. Xiao, L. J. Greenstein, N. B. Mandayam, and W. Trappe, “Using
the physical layer for wireless authentication in time-variant chan-
nels,” IEEE Transactions on Wireless Communications, vol. 7, no. 7,
2008.

[14] W. Tu and L. Lai, “Keyless authentication and authenticated
capacity,” IEEE Transactions on Information Theory, vol. 64, no. 5,
pp. 3696–3714, 2018.

[15] H. Sun and S. A. Jafar, “The capacity of private information
retrieval,” IEEE Transactions on Information Theory, vol. 63, no. 7,
pp. 4075–4088, 2017.

[16] L. Sankar, S. R. Rajagopalan, and H. V. Poor, “Utility-privacy
tradeoffs in databases: An information-theoretic approach,” IEEE
Transactions on Information Forensics and Security, vol. 8, no. 6, pp.
838–852, 2013.

