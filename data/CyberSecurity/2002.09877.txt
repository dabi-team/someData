Automata for Hyperlanguages

Borzoo Bonakdarpour1
Department of Computer Science, Iowa State University, U.S.A.
borzoo@iastate.edu

Sarai Sheinvald
Department of Software Engineering, ORT Braude College, Israel
sarai@braude.ac.il

1

2

3

4

5

6

7

Abstract

Hyperproperties lift conventional trace properties from a set of execution traces to a set of sets of execution
traces. Hyperproperties have been shown to be a powerful formalism for expressing and reasoning about
information-ﬂow security policies and important properties of cyber-physical systems such as sensitivity and
robustness, as well as consistency conditions in distributed computing such as linearizability. Although there
is an extensive body of work on automata-based representation of trace properties, we currently lack such
characterization for hyperproperties.

We introduce hyperautomata for hyperlanguages, which are languages over sets of words. Essentially,
hyperautomata allow running multiple quantiﬁed words over an automaton. We propose a speciﬁc type of
hyperautomata called nondeterministic ﬁnite hyperautomata (NFH), which accept regular hyperlanguages.
We demonstrate the ability of regular hyperlanguages to express hyperproperties for ﬁnite traces. We then
explore the fundamental properties of NFH and show their closure under the Boolean operations. We show
that while nonemptiness is undecidable in general, it is decidable for several fragments of NFH. We further
show the decidability of the membership problem for ﬁnite sets and regular languages for NFH, as well as
the containment problem for several fragments of NFH. Finally, we introduce learning algorithms based on
Angluin’s L∗ algorithm for the fragments NFH in which the quantiﬁcation is either strictly universal or strictly
existential.

2012 ACM Subject Classiﬁcation Author: Please ﬁll in 1 or more \ccsdesc macro

Keywords and phrases Author: Please ﬁll in \keywords macro

Digital Object Identiﬁer 10.4230/LIPIcs...

Funding Borzoo Bonakdarpour:

0
2
0
2

b
e
F
3
2

]
L
F
.
s
c
[

1
v
7
7
8
9
0
.
2
0
0
2
:
v
i
X
r
a

1 Optional footnote, e.g. to mark corresponding author

© B. Bonakdarpour and S. Sheinvald;
licensed under Creative Commons License CC-BY

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

 
 
 
 
 
 
XX:2

Automata for Hyperlanguages

1

Introduction

Hyperproperties [7] generalize the traditional trace properties [1] to system properties, i.e., a set of
sets of traces. Put it another way, a hyperproperty prescribes how the system should behave in its
entirety and not just based on its individual executions. Hyperproperties have been shown to be a
powerful tool for expressing and reasoning about information-ﬂow security policies [7] and important
properties of cyber-physical systems [16] such as sensitivity and robustness, as well as consistency
conditions in distributed computing such as linearizability [4].

Automata theory has been in the forefront of developing techniques for speciﬁcation and veriﬁca-
tion of computing systems. For instance, in the automata-theoretic approach to veriﬁcation [14, 15],
the model-checking problem is reduced to checking the nonemptiness of the product automaton of
the model and the complement of the speciﬁcation. In the industry and other disciplines (e.g., control
theory), automata are an appealing choice for modeling the behavior of a system. Unfortunately,
we currently lack a deep understanding about the relation between hyperproperties and automata
theory. To our knowledge, work in this area is limited to [8], in which the authors develop an
automata representation for the class of regular k-safety hyperproperties. These are hyperproperties
where execution traces are only universally quantiﬁed and their behaviors are non-refutable. They
introduce the notion of a k bad-preﬁx automaton – a ﬁnite-word automaton that recognizes sets of
k bad preﬁxes as ﬁnite words. Based on this representation, they present a learning algorithm for
k-safety hyperproperties. In [10], the authors offer a model-checking algorithm for hyperCTL∗ [6],
which constructs an alternating Büchi automaton that has both the formula and the Kripke structure
“built-in”. These approaches translate a hyperproperty-related problem to word automata.

We generalize the idea in [8] to a broader view of an automata-based representation of hyperprop-
erties, and introduce hyperautomata for hyperlanguages, which are languages whose elements are
sets of ﬁnite words, which we call hyperwords. In this paper, we propose nondeterministic ﬁnite-word
hyperautomata (NFH). An NFH runs on hyperwords that contain ﬁnite words, by using quantiﬁed
word variables that range over the words in a hyperword, and a nondeterministic ﬁnite-word auto-
maton (NFA) that runs on the set of words that are assigned to the variables. We demonstrate the idea
with two examples.

(cid:73) Example 1. Consider the NFH A1 in Figure 1 (left), whose alphabet is Σ = {a, b}, over two
word variables x1 and x2. The NFH A1 contains an underlying standard NFA, whose alphabet
comprises pairs over Σ, i.e., elements of Σ2, in which the ﬁrst letter represents the letters of the word
assigned to x1, and dually for the second letter and x2. The underlying NFA of A1 requires that
(1) these two words agree on their a (and, consequently, on their b) positions, and (2) once one of
the words has ended (denoted by #), the other must only contain b letters. Since the quantiﬁcation
condition of A1 is ∀x1∀x2, in a hyperword S that is accepted by A1, every two words agree on their
a positions. As a result, all the words in S must agree on their a positions. The hyperlanguage of A1
is then all hyperwords in which all words agree on their a positions.

(cid:73) Example 2. Next, consider the NFH A2 in Figure 1 (right), over the alphabet Σ = {a}, and
two word variables x1 and x2. The underlying NFA of A2 accepts the two words assigned to x1
and x2 iff the word assigned to x2 is longer than the word assigned to x1. Since the quantiﬁcation
condition of A2 is ∀x1∃x2, we have that A2 requires that for every word in a hyperword S accepted
by A2, there exists a longer word in S. This holds iff S contains inﬁnitely many words. Therefore,
the hyperlanguage of A2 is the set of all inﬁnite hyperwords over {a}.

We call the hyperlanguages accepted by NFH regular hyperlanguages. A regular hyperlanguage
L can also be expressed by the regular expression for the language of the underlying NFA of an NFH
A for L, augmented with the quantiﬁcation condition of A. We call such an expression a hyperregular

B. Bonakdarpour and S. Sheinvald

XX:3

Figure 1 The NFH A1 (left) and A2 (right).

expression (HRE). We demonstrate the ability of HREs to express important information-ﬂow security
policies such as different variations of noninteference [11] and observational determinism [17].

We proceed to conduct a comprehensive study of properties of NFH (see Table 1). In particular,
we show that NFH are closed under union, intersection, and complementation. We also prove that
the nonemptiness problem is in general undecidable for NFH. However, for the alternation-free
fragments (which only allow one type of quantiﬁer), as well as for the ∃∀ fragment (in which
the quantiﬁcation condition is limited to a sequence of ∃ quantiﬁers followed by a sequence of ∀
quantiﬁers), nonemptiness is decidable. These results are in line with the results on satisﬁability of
HyperLTL [9]. We also study the membership and inclusion problems. These results are aligned with
the complexity of HyperLTL model checking for tree-shaped and general Kripke structures [3]. This
shows that, surprisingly, the complexity results in [9, 3] mainly stem from the nature of quantiﬁcation
over ﬁnite words and depend on neither the full power of the temporal operators nor the inﬁnite nature
of HyperLTL semantics.

Finally, we introduce learning algorithms for the alternation-free fragments of NFH. Our al-
gorithms are based on Angluin’s L∗ algorithm [2] for regular languages, and are inspired by [8],
where the authors describe a learning algorithm that is tailored to learn a k-bad preﬁx NFA for
a k-safety formula. In fact, the algorithm there can be viewed of as a special case of learning a
hyperlanguage in the ∃-fragment of NFH.

In a learning algorithm, a learner aims to construct an automaton for an unknown target language
L, by means of querying a teacher, who knows L. The learner asks two types of queries: membership
queries (“is the word w in L?”) and equivalence queries (“is A an automaton for L?”). In case of a
failed equivalence query, the teacher returns a counterexample word on which A and L differ. The
learning algorithm describes how the learner uses the answers it gets from the teacher to construct its
candidate automaton.

In the case of NFH, the membership queries, as well as the counterexamples, are hyperwords.
The number of variables is unknown in advance, and is also part of the learning goal. We ﬁrst deﬁne
canonical forms for the alternation-free fragments of NFH, which is essential for this type of learning
algorithm. Then, we proceed to describe the learning algorithms for both fragments.
Organization. The rest of the paper is organized as follows. Preliminary concepts are presented in
Section 2. We introduce the notion of NFH and HRE in Sections 3 and 4, while their properties are
studied in Section 5. We propose our learning algorithm in Section 6. Finally, we make concluding
remarks and discuss future work in Section 7. Detailed proofs appear in the appendix.

2

Preliminaries

An alphabet is a nonempty ﬁnite set Σ of letters. A word over Σ is a ﬁnite sequence of letters from Σ.
The empty word is denoted by (cid:15), and the set of all ﬁnite words is denoted by Σ∗. A language is a
subset of Σ∗.

(cid:73) Deﬁnition
tuple
A = hΣ, Q, Q0, δ, F i, where Σ is an alphabet, Q is a nonempty ﬁnite set of states, Q0 ⊆ Q is

3. A nondeterministic

ﬁnite-word

automaton

(NFA)

is

a

𝑎,𝑎(#,𝑎)#,𝑎∀𝑥1∃𝑥2𝑎,𝑎,(𝑏,𝑏)(#,𝑏)(𝑏,#)(#,𝑏)(𝑏,#)∀𝑥1∀𝑥2XX:4

Automata for Hyperlanguages

Property

Closure

Nonemptiness

Finite membership

Regular membership
Containment

Result

Complementation, Union, Intersection (Theorem 8)
Undecidable (Theorem 9)
NL-complete (Theorem 10)
PSPACE-complete (Theorem 11)
PSPACE (Theorem 12)
NP-complete (Theorem 12)

∀∃∃
∃∗/∀∗
∃∗∀∗
NFH
O(log(k)) ∀

Decidable (Theorem 13)

∃∗/∀∗/∃∗∀∗ ⊆ ∃∗/∀∗

PSPACE-complete (Theorem 14)

Table 1 Summary of results on properties of NHF.

a set of initial states, F ⊆ Q is a set of accepting states, and δ ⊆ Q × Σ × Q is a transition relation.

Given a word w = σ1σ2 · · · σn over Σ, a run of A on w is a sequence of states (q0, q1, . . . qn),
such that q0 ∈ Q0, and for every 0 < i ≤ n, it holds that (qi−1, σi, qi) ∈ δ. The run is accepting if
qn ∈ F . We say that A accepts w if there exists an accepting run of A on w. The language of A,
denoted by L(A), is the set of all ﬁnite words that A accepts. A language L is called regular if there
exists an NFA such that L(A) = L.

An NFA A is called deterministic (DFA), if for every q ∈ Q and σ ∈ Σ, there exists exactly one
q0 for which (q, σ, q0) ∈ δ, i.e., δ is a transition function. It is well-known that every NFA has an
equivalent DFA.

3 Hyperautomata

Before deﬁning hyperautomata, we explain the idea behind them. We ﬁrst deﬁne hyperwords and
hyperlanguages.

(cid:73) Deﬁnition 4. A hyperword over Σ is a set of words over Σ and a hyperlanguage is a set of
hyperwords.

A hyperautomaton A uses a set of word variables X = {x1, x2, . . . , xk}. When running on a
hyperword S, these variables are assigned words from S. We represent an assignment v : X → S
as the k-tuple (v(x1), v(x2), . . . , v(xk)). Notice that the variables themselves do not appear in this
representation of v, and are manifested in the order of the words in the k-tuple: the i’th word is the
one assigned to xi. This allows a cleaner representation with less notations.

The hyperautomaton A consists of a quantiﬁcation condition α over X, and an underlying word
automaton ˆA, which runs on words that represent assignments to X (we explain how we represent
assignments as words later on). The condition α deﬁnes the assignments that ˆA should accept. For
example, α = ∃x1∀x2 requires that there exists a word w1 ∈ S (assigned to x1), such that for every
word w2 ∈ S (assigned to x2), the word that represents (w1, w2) is accepted by ˆA. The hyperword S
is accepted by A iff S meets these conditions.

We now elaborate on how we represent an assignment v : X → S as a word. We encode the
tuple (v(x1), v(x2), . . . v(xk)) by a word w whose letters are k-tuples in Σk, where the i’th letter
of w represents the k i’th letters of the words v(x1), . . . , v(xk) (in case that the words are not of
equal length, we “pad” the end of the word with # signs). For example, the assignment v(x1) =
aa, v(x2) = abb, represented by the tuple (aa, abb), is encoded by the word (a, a)(a, b)(#, b). We
later refer to w as the zipping of v. Once again, notice that due to the indexing of the word variables,
the variables do not explicitly appear in w.

B. Bonakdarpour and S. Sheinvald

XX:5

We now turn to formally deﬁne hyperautomata.

3.1 Nondeterminsitic Finite-Word Hyperautomata

We begin with some terms and notations.

Let s = (w1, w2, . . . , wk) be a tuple of ﬁnite words over Σ. We denote the length of the longest
word in s by dse. We represent s by a word over (Σ ∪ {#})k of length dse, which is formed by a
function zip(s) that “zips” the words in s together: the i’th letter in zip(s) represents the i’th letters
in w1, w2, . . . , wk, and # is used to pad the words that have ended. For example,

zip(aab, bc, abdd) = (a, b, a)(a, c, b)(b, #, d)(#, #, d).

Formally, we have zip(s) = s1s2 · · · sdse, where si[j] = wji if j ≤ |w|, and si[j] = #, otherwise.

Given a zipped word s, we denote the word formed by the letters in the i’th positions in s by s[i].
That is, s[i] is the word σ1σ2 · · · σm formed by deﬁning σj = sj[i], for sj[i] ∈ Σ. Notice that zip(s)
is reversible, and we can deﬁne an unzip function as unzip(s) = (s[1], s[2], . . . , s[k]). We sometimes
abuse the notation, and use unzip(s) to denote {s[1], s[2], . . . , s[k]}, and zip(S) to denote the zipping
of the words in a ﬁnite hyperword S in some arbitrary order.

(cid:73) Deﬁnition 5. A nondeterministic ﬁnite-word hyperautomaton (NFH)
is a tuple
A = hΣ, X, Q, Q0, F, δ, αi, where Σ, Q, Q0, and F are as in Deﬁnition 3, X = {x1, . . . , xk}
is a ﬁnite set of word variables, δ ⊆ Q × (Σ ∪ {#})k × Q is a transition relation, and α =
Q1x1Q2x2 . . . Qnxk is a quantiﬁcation condition, where Qi ∈ {∀, ∃} for every 1 ≤ i ≤ k.

In Deﬁnition 5, the tuple h(Σ ∪ {#})k, Q, Q0, δ, F i forms an underlying NFA of A, which we denote
by ˆA. We denote the alphabet of ˆA by ˆΣ.

Let S be a hyperword and let v : X → S be an assignment of the word variables of A to words in
S. We denote by v[x → w] the assignment obtained from v by assigning the word w ∈ S to x ∈ X.
We represent v by the word zip(v) = zip(v(x1), . . . v(xk)). We now deﬁne the acceptance condition
of a hyperword S by an NFH A. We ﬁrst deﬁne the satisfaction relation |= for S, A, a quantiﬁcation
condition α, and an assignment v : X → S, as follows.

For α = (cid:15), we denote S |=v (α, A) if ˆA accepts zip(v).
For α = ∃xiα0, we denote S |=v (α, A) if there exists w ∈ S, such that S |=v[xi→w] (α0, A).
For α = ∀xiα0, we denote S |=v (α, A) if for every w ∈ S, it holds that S |=v[xi→w] (α0, A).2
Since the quantiﬁcation condition of A includes all of X, the satisfaction is independent of the
assignment v, and we denote S |= A, in which case, we say that A accepts S.

(cid:73) Deﬁnition 6. Let A be an NFH. The hyperlanguage of A, denoted L(A), is the set of all
hyperwords that A accepts.

We call a hyperlanguage L a regular hyperlanguage if there exists an NFH A such that L(A) = L.
(cid:73) Example 7. Consider the NFH A3 in Figure 2, over the alphabet Σ = {a, b} and two word
variables x1 and x2. From the initial state, two words lead to the left component in ˆA3 iff in every
position, if the word assigned to x2 has an a, the word assigned to x1 has an a. In the right component,
the situation is dual – in every position, if the word assigned to x1 has an a, the word assigned to
x2 has an a. Since the quantiﬁcation condition of A3 is ∀x1∀x2, in a hyperword S accepted by
A3, in every two words in S, the set of a positions of one is a subset of the a positions of the other.
Therefore, L(A3) includes all hyperwords in which there is a full ordering on the a positions.

2 In case that α begins with ∀, satisfaction holds vacuously with an empty hyperword. We restrict the discussion to

nonempty hyperwords.

XX:6

Automata for Hyperlanguages

Figure 2 The NFH A3.

We consider several fragments of NFH, which limit the structure of the quantiﬁcation condition
α. NFH∀ is the fragment in which α contains only ∀ quantiﬁers, and similarly, in NFH∃, α contains
only ∃ quantiﬁers. In the fragment NFH∃∀, α is of the form ∃x1 · · · ∃xi∀xi+1 · · · ∀xk.

3.2 Additional Terms and Notations

We present several more terms and notations which we use throughout the following sections. We say
that a word w over (Σ ∪ #)k is legal if w = zip(u1, . . . uk) for some u1, u2, . . . uk ∈ Σ∗. Note that
w is legal iff there is no w[i] in which there is an occurrence of # followed by some letter σ ∈ Σ.

Consider two letter tuples σ1 = (t1, . . . tk) and σ2 = (s1, . . . sk0). We denote by σ1 + σ2 the
tuple (t1, . . . tk, s1, . . . sk0). We extend the notion to zipped words. Let w1 = zip(u1, . . . uk) and
w2 = zip(v1, . . . vk0). We denote by w1 + w2 the word zip(u1, . . . uk, v1, . . . vk0).
Consider a tuple t = (t1, t2, . . . tk) of items. A sequence of t is a tuple (t0

k), where
t0
i ∈ {t1, . . . tk} for every 1 ≤ i ≤ k. A permutation of t is a reordering of the elements of
t. We extend these notions to zipped words, to assignments, and to hyperwords, as follows. Let
ζ = (i1, i2, . . . ik) be a sequence (permutation) of (1, 2, . . . , k).

2, . . . t0

1, t0

Let w = zip(w1, . . . wk) be a word over k-tuples. The word wζ, deﬁned as zip(wi1 , wi2, . . . wik )
is a sequence (permutation) of w.
Let v be an assignment from a set of variables {x1, x2, . . . xk} to a hyperword S. The assignment
vζ, deﬁned as vζ(xj) = v(xij ) for every 1 ≤ i, j ≤ k, is a sequence (permutation) of v.
Let S be a hyperword. The tuple w = (w1, . . . wk), where wi ∈ S, is a sequence of S.
{w1, . . . wk} = S, then w is a permutation of S.

if

4 Hyperregular Expressions and Application in Security

Given an NFH A, the language of its underlying NFA ˆA can be expressed as a regular expression r.
Augmenting r with the quantiﬁcation condition α of A constitutes a hyperregular expression (HRE)
αr. For example, consider the NFH A1 in Figure 1. The HRE of A1 is:
(#, b)∗ | (b, #)∗(cid:17)
(cid:16)

(a, a) | (b, b)

(cid:17)∗(cid:16)

∀x1∀x2

We now show the application of HREs in specifying well-known information-ﬂow security policies.
Noninteference [11] requires that commands issued by users holding high clearances be removable

without affecting observations of users holding low clearances:

ϕni = ∀x1∃x2(l, lλ)∗

where l denotes a low state and lλ denotes a low state where all high commands are replaced by a
dummy value λ.

𝑏,𝑏,(𝑎,𝑎)(𝑎,𝑏)𝑎,𝑏,𝑏,𝑏,(𝑎,𝑎)(#,𝑏)𝑏,𝑎,𝑏,𝑏,(𝑎,𝑎)(𝑏,𝑎)(𝑏,#)(#,𝑏)(𝑏,#)∀𝑥1∀𝑥2(𝑏,#)(𝑎,#)(𝑏,#)(𝑎,#)(#,𝑎)(#,𝑏)(#,𝑎)(#,𝑏)B. Bonakdarpour and S. Sheinvald

XX:7

Observational determinism [17] requires that if two executions of a system start with low-security-

equivalent events, then these executions should remain low equivalent:

ϕod = ∀x1∀x2(l, l)+ | (¯l, ¯l)($, $)∗ | (l, ¯l)($, $)∗ | (¯l, l)($, $)∗

where l denotes a low event, ¯l ∈ Σ \ {l}, and $ ∈ Σ. We note that similar policies such as Boudol
and Castellani’s noninterference [5] can be formulated in the same fashion.3

Generalized noninterference (GNI) [12] allows nondeterminism in the low-observable behavior,

but requires that low-security outputs may not be altered by the injection of high-security inputs:

ϕgni = ∀x1∀x2∃x3

(cid:18)

(h, l, hl) | (¯h, l, ¯hl) | (h, ¯l, h¯l) | (¯h, ¯l, ¯h¯l)

(cid:19)∗

where h denotes the high-security input, l denotes the low-security output, ¯l ∈ Σ\{l}, and ¯h ∈ Σ\{h}.
Declassiﬁcation [13] relaxes noninterference by allowing leaking information when necessary.
Some programs need to reveal secret information to fulﬁll functional requirements. For example, a
password checker must reveal whether the entered password is correct or not:

ϕdc = ∀x1∀x2(li, li)(pw, pw)(lo, lo)+

where li denotes low-input state, pw denotes that the password is correct, and lo denotes low-output
states. We note that for brevity, in the above formula, we do not include behaviors where the ﬁrst two
events are not low or in the second event, the password is not valid.

Termination-sensitive noninterference requires that for two executions that start from low-

observable states, information leaks are not permitted by the termination behavior of the program:

ϕtsni = ∀x1∀x2(l, l)($, $)∗(l, l) | (¯l, ¯l)($, $)∗ | (l, ¯l)($, $)∗ | (¯l, l)($, $)∗

where l denotes a low state and $ ∈ Σ.

5

Properties of Regular Hyperlanguages

In this section, we consider the basic operations and decision problems for the various fragments of
NFH. We mostly provide proof sketches, and the complete details appear in the appendix. Throughout
this section, A is an NFH hΣ, X, Q, Q0, δ, F, αi, where X = {x1, . . . xk}.
We ﬁrst show that NFH are closed under all the Boolean operations.

(cid:73) Theorem 8. NFH are closed under union, intersection, and complementation.

Proof Sketch. Complementing A amounts to dualizing its quantiﬁcation condition (replacing every
∃ with ∀ and vice versa), and complementing ˆA via the standard construction for NFA.

Now, let A1 and A2 be two NFH. The NFH A∩ for L(A1) ∩ L(A2) is based on the product
construction of ˆA1 and ˆA2. The quantiﬁcation condition of A∩ is α1 · α2. The underlying automaton
ˆA∩ advances simultaneously on both A1 and A2: when ˆA1 and ˆA2 run on zipped hyperwords w1
and w2, respectively, ˆA∩ runs on w1 + w2, and accepts only if both ˆA1 and ˆA2 accept.

Similarly, the NFH A∪ for L(A1) ∪ L(A2) is based on the union construction of ˆA1 and ˆA2. The
quantiﬁcation condition of A∪ is again α1 · α2. The underlying automaton ˆA∪ advances either on A1
or A2. For every word w read by ˆA1, the NFH ˆA∪ reads w + w0, for every w0 ∈ ˆΣ∗
2, and dually, for
every word w read by ˆA2, the NFH ˆA∪ reads w0 + w, for every w0 ∈ ˆΣ∗
(cid:74)
1.

3 This policy states that every two executions that start from bisimilar states (in terms of memory low-observability),

should remain bisimilarly low-observable.

XX:8

Automata for Hyperlanguages

We now turn to study various decision problems for NFH. We begin with the nonemptiness
problem: given an NFH A, is L(A) = ∅? We show that while the problem is in general undecidable
for NFH, it is decidable for the fragments that we consider.

(cid:73) Theorem 9. The nonemptiness problem for NHF is undecidable.

The proof of Theorem 9 mimics the ideas in [9], which uses a reduction from the Post corres-

pondence problem (PCP) to prove the undecidability of HyperLTL satisﬁability.

For the alternation-free fragments, we can show that a simple reachability test on their underlying

automata sufﬁces to verify nonemptiness. Hence, we have the following.

(cid:73) Theorem 10. The nonemptiness problem for NFH∃ and NFH∀ is NL-complete.

The nonemptiness of NFH∃∀ is harder, and reachability does not sufﬁce. However, we show that

the problem is decidable.

(cid:73) Theorem 11. The nonemptiness problem for NFH∃∀ is PSPACE-complete.

Proof Sketch. We can show that an NFH∃∀ A is nonempty iff it accepts a hyperword S of size
that is bounded by the number m of ∃ quantiﬁers in α. We can then construct an NFA A whose
language is nonempty iff it accepts zip(S) for such a hyperword S. The size of A is O(|δ|)mk−m
).
Unless A only accepts hyperwords of size 1, which can be easily checked, |δ| must be exponential
in the number k − m of ∀ quantiﬁers, to account for all the assignments to the variables under ∀,
and so overall |A| is of size O(|A|k). The problem can then be decided in PSPACE by traversing A
on-the-ﬂy. We show that a similar result holds for the case that k − m is ﬁxed.

We use a reduction from the unary version of the tiling problem to prove PSPACE lower bounds
(cid:74)

both for the general case and for the case of a ﬁxed number of ∀ quantiﬁers.

We turn to study the membership problem for NFH: given an NFH A and a hyperword S, is
S ∈ L(A)? When S is ﬁnite, the set of possible assignments from X to S is ﬁnite, and so the problem
is decidable. We call this case the ﬁnite membership problem.

(cid:73) Theorem 12.

The ﬁnite membership problem for NFH is in PSPACE.

The ﬁnite membership problem for NFH with O(log(k)) ∀ quantiﬁers is NP-complete.

Proof Sketch. We can decide the membership of a hyperword S in L(A) by iterating over all
relevant assignments from X to S, and for every such assignment v, checking on-the-ﬂy whether
zip(v) is accepted by ˆA. This algorithm uses space of size that is polynomial in k and logarithmic in
|A| and in |S|.

When the number of ∀ quantiﬁers in A is |O(log(k))|, we can iterate over all assignments to the ∀
variables in polynomial time, while guessing assignments to the variables under ∃. Thus, membership
in this case is in NP.

We use a reduction from the Hamiltonian cycle problem to prove NP-hardness for this case.
Given a graph G = h{v1, . . . vn}, Ei, we construct a hyperword S with n different words of length
n over {0, 1}, each of which contains a single 1. We also construct an NFH∃ A over {0, 1} with n
variables, a graph construction similar to that of G, and a single accepting and initial state v1. From
vertex vi there are transitions to all its neighbors, labeled by the letter (0)i−1 + (1) + (0)n−i. Thus,
A accepts S iff there exists an assignment f : X → S such that zip(f ) ∈ L( ˆA). Such an assignment
f describes a cycle in G, where f (xi) = wj matches traversing vi in the j’th step. The words in S
ensure a single visit in every state, and their length ensures a cycle of length n.
Note: for every hyperword of size at least 2, the number of transitions in δ must be exponential in the
number k0 of ∀ quantiﬁers, to account for all the different assignments to these variables. Thus, if
(cid:74)
k = O(k0), an algorithm that uses a space of size k is in fact logarithmic in the size of A.

B. Bonakdarpour and S. Sheinvald

XX:9

When S is inﬁnite, it may still be ﬁnitely represented. We now address the problem of deciding
whether a regular language L (given as an NFA) is accepted by an NFH. We call this the regular
membership problem for NFH. We show that this problem is decidable for the entire class of NFH.

(cid:73) Theorem 13. The regular membership problem for NFH is decidable.

Proof Sketch. Let A be an NFA, and let A be an NFH, both over Σ. We describe a recursive
procedure for deciding whether L(A) ∈ L(A).

For the base case of k = 1, if α = ∃x1, then L(A) ∈ L(A) iff L(A) ∩ L( ˆA) 6= ∅. Otherwise, if
α = ∀x1, then L(A) ∈ L(A) iff L(A) /∈ L(A), where A is the NFH for L(A). The quantiﬁcation
condition for A is ∃x1, which conforms to the previous case.

For k > 1, we construct a sequence of NFH A1, A2, . . . , Ak. If α starts with ∃, then we set
A1 = A. Otherwise, we set A1 = A. Given Ai with a quantiﬁcation condition αi, we construct
Ai+1 as follows. If αi starts with ∃, then the set of variables of Ai+1 is {xi+1, . . . xk}, and the
quantiﬁcation condition αi+1 is Qi+1xi+1 · · · Qkxk, where αi = QixiQi+1 · · · Qkxk. The NFH
Ai+1 is roughly constructed as the intersection between A and ˆAi, based on the ﬁrst position in
every (k − i)-tuple letter in ˆΣi. Then, ˆAi+1 accepts a word zip(u1, . . . uk−i) iff there exists a word
u ∈ L(A), such that ˆAi accepts zip(u, u1, . . . uk−i). Notice that this exactly conforms to the ∃
condition. Therefore, if Qi = ∃, then L(A) ∈ L(Ai) iff L(A) ∈ L(Ai+1).

If Qi = ∀, then L(A) ∈ L(Ai) iff L(A) /∈ L(Ai). The quantiﬁcation condition of Ai begins

with ∃xi. We then construct Ai+1 w.r.t. Ai as described above, and check for non-membership.

Every ∀ quantiﬁer requires complementation, which is exponential in |Q|. Therefore, in the worst

case, the complexity of this algorithm is O(22...|Q||A|
of ∀ quantiﬁers is ﬁxed, then the complexity is O(|Q||A|k).

), where the tower is of height k. If the number
(cid:74)

Since nonemptiness of NFH is undecidable, so are its universality and containment problems.

However, we show that containment is decidable for the fragments that we consider.

(cid:73) Theorem 14. The containment problems of NFH∃ and NFH∀ in NFH∃ and NFH∀ and of NFH∃∀
in NFH∃ and NFH∀ are PSPACE-complete.

Proof Sketch. The lower bound follows from the PSPACE-hardness of the containment problem
for NFA. For the upper bound, for two NFH A1 and A2, we have that L(A1) ⊆ L(A2) iff L(A1) ∩
L(A2) = ∅. We can use the constructions in the proof of Theorem 8 to compute a matching NFH
A = A1 ∩ A2, and check its nonemptiness. Complementing A2 is exponential in its number of states,
and the intersection construction is polynomial.

If A1 ∈ NFH∃ and A2 ∈ NFH∀ or vice versa, then A is an NFH∃ or NFH∀, respectively, whose

nonemptiness can be decided in space that is logarithmic in |A|.

It follows from the construction in the proof of Theorem 8, that the quantiﬁcation condition of A
may be any interleaving of the quantiﬁcation conditions of the two intersected NFH. Therefore, for
the rest of the fragments, we can construct the intersection such that A is an NFH∃∀.

The PSPACE upper bound of Theorem 11 is derived from the number of variables and not from
the state-space of the NFH. Therefore, while | ¯A2| is exponential in the number of states of A2,
(cid:74)
checking the nonemptiness of A is in PSPACE.

6

Learning NFH

In this section, we introduce L∗-based learning algorithms for the fragments NFH∀ and NFH∃. We
ﬁrst survey the L∗ algorithm [2], and then describe the relevant adjustments for our case.

XX:10 Automata for Hyperlanguages

6.1 Angluin’s L∗ Algorithm

L∗ consists of two entities: a learner, who wishes to learn a DFA A for an unknown (regular) language
L, and a teacher, who knows L. During the learning process, the learner asks the teacher two types of
queries: membership queries (“is the word w in L?”) and equivalence queries (“is A a DFA for L?”).
The learner maintains A in the form of an observation table T of truth values, whose rows
D, D · Σ and columns E are sets of words over Σ, where D is preﬁx-closed, and E is sufﬁx-closed.
Initially, D = E = {(cid:15)}. For a row d and a column e, the entry for T (d, e) is tt iff d · e ∈ L. The
entries are ﬁlled via membership queries. The vector of truth values for row d is denoted row(d).
Intuitively, the rows in D determine the states of A, and the rows in D · Σ determine the transitions
of A: the state row(d · σ) is reached from row(d) upon reading σ.

The learner updates T until it is closed, which, intuitively, ensures a full transition relation and
consistent, which, intuitively, ensures a deterministic transition relation. If T is not closed or not
consistent then more rows or more columns are added to T , respectively.

When T is closed and consistent, the learner constructs A: The states are the rows of D, the initial
state is row((cid:15)), the accepting states are these in which T (d, (cid:15)) = tt, and the transition relation is as
described above. The learner then submits an equivalence query. If the teacher conﬁrms, the algorithm
terminates. Otherwise, the teacher returns a counterexample w ∈ L(A) but w /∈ L (which we call a
positive counterexample), or w /∈ L(A) but w ∈ L (which we call a negative counterexample). The
learner then adds w and all its sufﬁxes to E, and proceeds to construct the next candidate DFA A.

It is shown in [2] that as long as A is not a DFA for L, it has less states than a minimal DFA for L.
Further, every change in the table adds at least one state to A. Therefore, the procedure is guaranteed
to terminate successfully with a minimal DFA A for L.

The correctness of the L∗ algorithm follows from the fact that regular languages have a canonical
form, which guarantees a single minimal DFA for a regular language L. To enable an L∗-based
algorithm for NFH∀ and NFH∃, we ﬁrst deﬁne canonical forms for these fragments.

6.2 Canonical Forms for the Alternation-Free Fragments

We begin with the basic terms on which our canonical forms are based.

(cid:73) Deﬁnition 15. 1. An NFH∀ A∀ is sequence complete if for every word w, it holds that ˆA∀

accepts w iff it accepts every sequence of w.

2. An NFH∃ A∃ is permutation complete if for every word w, it holds that ˆA∃ accepts w iff it accepts

every permutation of w.

An NFH∀ A∀ accepts a hyperword S iff ˆA∀ accepts every sequence of size k of S. If some
sequence is missing from L( ˆA), then removing the rest of the sequences of S from L( ˆA∀) does not
affect the non-acceptance of S. Therefore, the underlying automata of sequence-complete NFH∀ only
accept necessary sequences. Similarly, an NFH∃ A∃ accepts a hyperword S iff ˆA∃ accepts some
permutation p of size k of words in S. Adding the rest of the permutations of p to L( ˆA∃) does not
affect the acceptance of S. Therefore, the underlying automata of permutation-complete NFH∃ only
reject the necessary permutations of every hyperword. As a conclusion, we have the following.

(cid:73) Lemma 16. 1. Let A∀ be an NFH∀, and let A0
such that for every word w, the underlying NFA ˆA0
Then L(A∀) = L(A0

∀).

∀ be a sequence-complete NFH∀ over Σ and X
∀ accepts w iff ˆA∀ accepts every sequence of w.

2. Let A∃ be an NFH∃, and let A0

every word w, the underlying NFA ˆA∃ accepts w iff ˆA0
L(A∃) = L(A0

∃).

∃ be a permutation-complete NFH∃ over Σ and X such that for
∃ accepts all permutations of w. Then

B. Bonakdarpour and S. Sheinvald

XX:11

Next, we show that we can construct a sequence- or permutation-complete NFH for a given NFH∀
or NFH∃, respectively. Intuitively, given A, for every sequence (permutation) ζ of (1, . . . k), we
construct an NFA that runs on wζ in the same way that ˆA runs on w, for every w. The underlying NFA
we construct for the NFH∀ and NFH∃ are the intersection and union, respectively, of all these NFA.

(cid:73) Lemma 17. Every NFH∀ (NFH∃) A has an equivalent sequence-complete (permutation-complete)
NFH∀ (NFH∃) A0 over the same set of variables.

Finally, as the following theorem shows, sequence- and permutation- complete NFH offer a

uniﬁed model for the alternation-free fragments.

(cid:73) Theorem 18. Let A1 and A2 be two sequence-complete (permutation-complete) NFH∀ (NFH∃)
over the same set of variables. Then L(A1) = L(A2) iff L( ˆA1) = L( ˆA2).

Regular languages have a canonical form, which are minimal DFA. We use this property to deﬁne
canonical forms for NFH∀ and NFH∃ as sequence-complete (permutation-complete) NFH∀ (NFH∃)
with a minimal number of variables and a minimal underlying DFA.

6.3 Learning NFH∀ and NFH∃

We now describe our L∗-based learning algorithms for NFH∃ and NFH∀. These algorithms aim to
learn an NFH with the canonical form deﬁned in Section 6.2 for a target hyperlanguage L. Figure 4
presents the overall ﬂow of the learning algorithms for both fragments.

In the case of hyperautomata, the membership queries and the counterexamples provided by
the teacher consist of hyperwords. Similarly to [8], we assume a teacher that returns a minimal
counterexample in terms of size of the hyperword.

During the procedure, the learner maintains an NFH A via an observation table for ˆA, over
the alphabet ˆΣ = (Σ ∪ {#})k, where k is initially set to 1. When the number of variables is
increased to k0 > k, the alphabet of ˆA is extended accordingly to (Σ ∪ {#})k0
. To this end, we
deﬁne a function ↑k0
, which replaces every letter (σ1, . . . σk), with
(σ1, . . . σk) + (σk)k0−k. That is, the last letter is duplicated to create a k0-tuple. We extend ↑k0
k
to words: ↑k0
k (σ). Notice that, for both
fragments, if unzip(d · e) ∈ L(A), then unzip(↑k0
k (d · e)) ∈ L(A). Accordingly, when the number
of variables is increased, every word w in the rows and columns of T is replaced with ↑k0
k (w), an
action which we denote by ↑k0

k (w) is obtained by replacing every letter σ in w with ↑k0

k : (Σ ∪ {#})k → (Σ ∪ {#})k0

k (T ).

6.3.1 Learning NFH∀

In the case of NFH∀, when the teacher returns a counterexample S, it holds that if |S| > k, then
S must be positive. Indeed, assume by way of contradiction that S is negative. Then, for every k
words w1, . . . , wk in S, it holds that zip(w1, . . . , wk) ∈ L( ˆA), but S /∈ L. Therefore, in an NFH∀
A0 for L, there exists some word of the form w = zip(w1, . . . wk) such that wi ∈ S for 1 ≤ i ≤ k,
and w /∈ L( ˆA0). As a result, {w1, . . . , wk} /∈ L. Since zip(w1, . . . , wk) and all its sequences are in
L( ˆA), then a smaller counterexample is {w1, . . . , wk}, a contradiction to the minimality of S.

In fact, if |S| > k, then it must be that |S| = k + 1. Indeed, since S is a positive counterexample,
and A accepts all representations of subsets of size k of S (otherwise the teacher would return a
counterexample of size k), then there exists a subset S0 ⊆ S of size k + 1 that should be represented,
but is not. Therefore, S0 is a counterexample of size k + 1.

When a counterexample S of size k + 1 is returned, the learner updates k ← k + 1, updates T to
↑k+1
(T ), arbitrarily selects a permutation p of the words in S, and adds zip(p) and all its sufﬁxes to
k
E. In addition, it updates D · ˆΣ in accordance with the new updated ˆΣ, and ﬁlls in the missing entries.

XX:12 Automata for Hyperlanguages

When |S| ≤ k, then the counterexample is either positive or negative. If S is positive, then there
exists some permutation p of the words in S such that A does not accept zip(p) (a permutation and not
a proper sequence, or there would be a smaller counterexample). The learner ﬁnds such a permutation
p, and adds zip(p) and all its sufﬁxes to E. Notice that zip(p) does not already appear in T , since a
membership query would have returned “yes”, and so ˆA would have accepted zip(p).

if S is negative, then A accepts all sequences of length k of words in S, though it should not.
Then there exists a permutation p of the words in S that does not appear in T , and which A accepts.
The learner then ﬁnds such a permutation p and adds zip(p) and all its sufﬁxes to E.

If p is a permutation of the words in S, and S is a negative counterexample, then zip(p) should
not be in L( ˆA) due to any other hyperword, and if S is a positive counterexample, then it should be
in L( ˆA) for every S0 such that S ⊆ S0. Therefore, the above actions by the learner are valid.

When an equivalence query succeeds, then A is indeed an NFH∀ for L. However, A is not
necessarily sequence-complete, as ˆA may accept a word w = zip(w1, . . . , wk) but not all of its
sequences. This check can be performed by the learner directly on ˆA. Notice that w does not
occur in T , since a membership query on w would return “no”. Once it is veriﬁed that A is not
sequence-complete, the counterexample w (and all its sufﬁxes) are added to E, and the procedure
returns to the learning loop.

As we have explained above, variables are added only when necessary, and so the output A is
indeed an NFH for L with minimally many variables. The correctness of L∗ and the minimality of
the counterexamples returned by the teacher guarantee that for each k0 ≤ k, the run learns a minimal
deterministic ˆA for hyperwords in L that are represented by k0 variables. Therefore, a smaller ˆA0
for L does not exist, as restricting ˆA0 to the ﬁrst k0 letters in each k-tuple would produce a smaller
underlying automaton for k0 variables, a contradiction.

Figure 3 The ﬁrst stages of learning L(A3) of Figure 1.

(cid:73) Example 19. Figure 3 displays the ﬁrst two stages of learning L(A3) of Figure 2. T0 displays
the initial table, with D = E = {(cid:15)}, and ˆΣ = {a, b, #}. since {a}, {b}, and {(cid:15)} are all in L(A3),
the initial candidate NFH A includes a single variable, and, following the answers to the membership
queries, a single accepting state.

Since L(A3) includes all hyperwords of size 1, which are now accepted by A, the smallest
counterexample the teacher returns is of size 2, which, in the example, is {a, b}. Table T1 is
1, updating the alphabet ˆΣ to {a, b, #}2, and updating D · ˆΣ
then obtained from T0 by applying ↑2
accordingly. T1 is ﬁlled by submitting membership queries. For example, for (b, a) ∈ D · ˆΣ and
(a, b) ∈ E, the learner submits a membership query for {ba, ab}, to which the teacher answers “no”.

6.3.2 Learning NFH∃

The learning process for NFH∃ is similar to the one for NFH∀. We brieﬂy describe the differences.

𝜖𝑇01𝜖1(𝑎)1(𝑏)1(#)1(2)(3)(𝑎,𝑏)𝜖𝑇111𝜖11(𝑎,𝑎)11(𝑏,𝑏)11(𝑎,𝑏)01(𝑎,#)(𝑎,𝑏)𝜖𝑇1(𝑐𝑜𝑛𝑡.)01(𝑏,𝑎)01(𝑏,#)01(#,𝑎)01(#,𝑏)01(#,#)(𝑎,𝑏)𝜖𝑇111𝜖11(𝑎,𝑎)11(𝑏,𝑏)11(𝑎,𝑏)01(𝑎,#)01(𝑏,𝑎)01(𝑏,#)01(#,𝑎)01(#,𝑏)01(#,#)B. Bonakdarpour and S. Sheinvald

XX:13

no: membership queries

w

x

e

c

d

d

a

o :

n

permutation/sequence
complete?

yes: A

yes

T closed
and consistent?

yes

construct A

A

equivalent?

add S

T ←↑k0

k (T )

no:addcexS

yes

no: cex S

|S| > k?

Figure 4 The learning process ﬂow for NFH∀ and NFH∃.

As in NFH∀, relying on the minimality of the counterexamples returned by the teacher guarantees
that when a counterexample S such that |S| > k is returned, it is a positive counterexample. Indeed,
assume by way of contradiction that S is a negative counterexample of size k0. Since ˆA accepts S,
there exists a word zip(w1, . . . , wk) in L( ˆA) such that {w1, . . . , wk} ∈ S. According to the semantics
of ∃, if zip(w1, w2, . . . , wk) ∈ L( ˆA) then S ∈ L(A). Since S /∈ L, we have that {w1, . . . , wk} is a
smaller counterexample, a contradiction.

Therefore, when the teacher returns a counterexample S of size k0 > k, the alphabet ˆΣ is extended

to (Σ ∪ {#})k0

, and the table T is updated by ↑k0

k , as is done for NFH∀.

If |S| ≤ k, then S may be either positive or negative. If S is negative, then there exists some
permutation of S that is accepted by ˆA. However, no such permutation is in T , as a membership
query would have returned “no”. Similarly, if S is positive, then there exists no permutation of S that
ˆA accepts. In both cases, the learner chooses a permutation of S and adds it, and all its sufﬁxes, to E.
As in the case of NFH∀, the success of an equivalence query does not necessarily imply that
A is permutation-complete. If A is not permutation-complete, the learner ﬁnds a word w that is a
permutation of w0 such that w0 ∈ L( ˆA) but w /∈ L( ˆA), and adds w as a counterexample to E. The
procedure then returns to the learning loop.

7 Conclusion and Future Work

We have introduced and studied hyperautomata and hyperlanguages, focusing on the basic model
of regular hyperlanguages, in which the underlying automaton is a standard NFA. We have shown
that regular hyperlanguages are closed under set operations (complementation, intersection, and
union) and are capable of expressing important hyperproperties for information-ﬂow security policies
over ﬁnite traces. We have also investigated fundamental decision procedures such as checking
nonemptiness and membership. We have shown that their regular properties allow the learnability of
the alternation-free fragments. Fragments that combine the two types of quantiﬁers prove to be more
challenging, and we leave their learnability to future work.

The notion of hyperlanguages, as well as the model of hyperautomata, can be lifted to handle
hyperwords that consist of inﬁnite words: instead of an underlying ﬁnite automaton, we can use any
model that accepts inﬁnite words. In fact, we believe using an underlying alternating Büchi automaton,
such hyperautomata can express the entire logic of HyperLTL [6], using the standard Vardi-Wolper
construction for LTL [15] as basis. Our complexity results for the various decision procedures for
NFH, combined with the complexity results shown in [9], suggest that using hyperautomata would be
optimal, complexity-wise, for handling HyperLTL.

Further future directions include studying non-regular hyperlanguages (e.g., context-free), and
object hyperlanguages (e.g., trees). Other open problems include a full investigation of the complexity
of decision procedures for alternating fragments of NFH.

XX:14 Automata for Hyperlanguages

References

B. Alpern and F. B. Schneider. Deﬁning liveness. Information Processing Letters, 21:181–185, 1985.
1
2 Dana Angluin. Learning regular sets from queries and counterexamples. Infornation and Computation,

3

4

75(2):87–106, 1987.
B. Bonakdarpour and B. Finkbeiner. The complexity of monitoring hyperproperties. In Proceedings of
the 31st IEEE Computer Security Foundations Symposium CSF, pages 162–174, 2018.
B. Bonakdarpour, C. Sánchez, and G. Schneider. Monitoring hyperproperties by combining static
analysis and runtime veriﬁcation. In Proceedings of the 8th Leveraging Applications of Formal Methods,
Veriﬁcation and Validation (ISoLA), pages 8–27, 2018.

5 G. Boudol and I. Castellani. Noninterference for concurrent programs and thread systems. Theoretical

Computer Science (TCS), 281(1-2):109–130, 2002.

6 M. R. Clarkson, B. Finkbeiner, M. Koleini, K. K. Micinski, M. N. Rabe, and C. Sánchez. Temporal logics
for hyperproperties. In Proceedings of the 3rd Conference on Principles of Security and Trust POST,
pages 265–284, 2014.

7 M. R. Clarkson and F. B. Schneider. Hyperproperties. Journal of Computer Security, 18(6):1157–1210,

8

9

10

11

2010.
B. Finkbeiner, L. Haas, and H. Torfah. Canonical representations of k-safety hyperproperties.
Proceedings of the 32nd IEEE Computer Security Foundations Symposium (CSF), pages 17–31, 2019.
B. Finkbeiner and C. Hahn. Deciding hyperproperties. In Proceedings of the 27th International Conference
on Concurrency Theory (CONCUR), pages 13:1–13:14, 2016.
B. Finkbeiner, M. N. Rabe, and C. Sánchez. Algorithms for model checking HyperLTL and HyperCTL*.
In Proceedings of the 27th International Conference on Computer Aided Veriﬁcation (CAV), pages 30–48,
2015.
J. A. Goguen and J. Meseguer. Security policies and security models. In IEEE Symp. on Security and
Privacy, pages 11–20, 1982.

In

12 D. McCullough. Noninterference and the composability of security properties. In Proceedings of the

13

1988 IEEE Symposium on Security and Privacy, pages 177–186, 1988.
A. Sabelfeld and D. Sands. Probabilistic noninterference for multi-threaded programs. In Proceedings of
the 13th IEEE Computer Security Foundations Workshop (CSFW), pages 200–214, 2000.

14 M.Y. Vardi and P. Wolper. Automata theoretic techniques for modal logic of programs. Journal of

Computer and System Sciences, 32:183–221, 1986.

15 M.Y. Vardi and P. Wolper. Reasoning about inﬁnite computations.

Information and Computation,

115(1):1–37, 1994.

16 Y. Wang, M. Zarei, B. Bonakdarpour, and M. Pajic. Statistical veriﬁcation of hyperproperties for cyber-
physical systems. ACM Transactions on Embedded Computing systems (TECS), 18(5s):92:1–92:23,
2019.
S. Zdancewic and A. C. Myers. Observational determinism for concurrent program security. In Proceed-
ings of the 16th IEEE Computer Security Foundations Workshop (CSFW), page 29, 2003.

17

B. Bonakdarpour and S. Sheinvald

XX:15

Appendix

A Proofs

Theorem 8

Proof. Complementation. Let A be an NFH. The NFA ˆA can be complemented with respect to its
language over ˆΣ to an NFA ˆA. Then for every assignment v : X → S, it holds that ˆA accepts zip(v)
iff ˆA does not accept zip(v). Let α be the quantiﬁcation condition obtained from α by replacing every
∃ with ∀ and vice versa. We can prove by induction on α that A, the NFH whose underlying NFA is
ˆA, and whose quantiﬁcation condition is α, accepts L(A). The size of A is exponential in |Q|, due to
the complementation construction for ˆA.

Now, let A1 = hΣ, X, Q, Q0, δ1, F1, α1i and A2 = hΣ, Y, P, P0, δ2, F2, α2i be two NFH with

|X| = k and |Y | = k0 variables, respectively.

Union. We construct an NFH A∪ = hΣ, X ∪ Y, Q ∪ P ∪ {p1, p2}, Q0 ∪ P0, δ, F1 ∪ F2 ∪ {p1, p2}, αi,
where α = α1α2 (that is, we concatenate the two quantiﬁcation conditions), and where δ is deﬁned
as follows.

For every

we set

for every t ∈ (Σ ∪ {#})k0
For every

.

we set

for every t ∈ (Σ ∪ {#})k.
For every q ∈ F1, we set

and

for every t ∈ (Σ ∪ {#})k0
For every q ∈ F2, we set

.

and

for every t ∈ (Σ ∪ {#})k.

(q1

(σ1,...,σk)
−−−−−−→ q2) ∈ δ1

(q1

(σ1,...,σk)+t
−−−−−−−−→ q2) ∈ δ

(q1

(σ1,...,σk0 )
−−−−−−−→ q2) ∈ δ2

(q1

t+(σ1,...,σk0 )
−−−−−−−−→ q2) ∈ δ

(#)k+t
−−−−−→ p1) ∈ δ

(q

(#)k+t
−−−−−→ p1) ∈ δ

(p1

t+(#)k0
−−−−−→ p2) ∈ δ

(q

t+(#)k0
−−−−−→ p2) ∈ δ

(p2

XX:16 Automata for Hyperlanguages

Let S be a hyperword. For every v : (X ∪ Y ) → S, it holds that if zip(v|X ) ∈ L( ˆA1), then
zip(v) ∈ L( ˆA∪). Indeed, according to our construction, every word assigned to the Y variables is
accepted in the A1 component of the construction, and so it satisﬁes both types of quantiﬁers. A
similar argument holds for v|Y and A2.

Also, according to our construction, for every v : (X ∪ Y ) → S, if zip(v) ∈ L( ˆA∪), then either
zip(v|X ) ∈ L( ˆA1), or zip(v|Y ) ∈ L( ˆA2). As a conclusion, we have that L(A∪) = L(A1) ∪ L(A2).
The state space of A∪ is linear in the state spaces of A1, A2. However, the size of the alphabet
of A∪ may be exponentially larger than that of A1 and A2, since we augment each letter with all
sequences of size k0 (in A1) and k (in A2).

Intersection. The proof follows the closure under union and complementation. However, we also
offer a direct translation, which avoids the need to complement. We construct an NFH A∩ =
hΣ, X ∪ Y, (Q ∪ {q} × P ∪ {p}), (Q0 × P0), δ, (F1 ∪ {q}) × (F2 ∪ {p}), α1α2i, where δ is deﬁned
as follows.

For every (q1

(σ1,...,σk)
−−−−−−→ q2) ∈ δ1 and every (p1

1,...,σ0

(σ0
−−−−−−−→ p2) ∈ δ2, we have

k0 )

(cid:16)

(q1, p1)

(σ1...,σk,σ0
1,...σ0
−−−−−−−−−−−−→ (q2, p2)

k0 )

(cid:17)

∈ δ

For every q1 ∈ F1, (p1

1,...,σ0

(σ0
−−−−−−−→ p2) ∈ δ2 we have

k0 )

(cid:16)

(q1, p1)

(#)k+(σ0
1,...σ0
−−−−−−−−−−−→ (q, p2)

k0 )

(cid:17)

(cid:16)

,

(q, p1)

(#)k+(σ0
1,...,σ0
−−−−−−−−−−−→ (q, p2)

k0 )

(cid:17)

∈ δ

For every (q1

(σ1,...,σk)
−−−−−−→ q2) ∈ δ1 and p1 ∈ F2, we have

(cid:16)

(q1, p1)

(σ1,...,σk)+(#)k0
−−−−−−−−−−−→ (q2, p)

(cid:17)

,

(cid:16)

(q1, p)

k)+(#)k0
(σ1,...,σ0
−−−−−−−−−−−→ (q2, p)

(cid:17)

∈ δ

Intuitively, the role of q, p is to keep reading (#)k and (#)k0
respectively, has ended.

after the word read by ˆA1 or ˆA2,

The NFH ˆA∩ simultaneously reads two words zip(w1, w2, . . . , wk) and zip(w0

k0) that
are read along ˆA1 and ˆA2, respectively, and accepts iff both words are accepted. The correctness
follows from the fact that for v : (X ∪ Y ) → S, we have that zip(v) is accepted by ˆA iff zip(v|X )
and zip(v|Y ) are accepted by ˆA1 and ˆA2, respectively.

2, . . . w0

1, w0

This construction is polynomial in the sizes of A1 and A2.

(cid:74)

Theorem 9

Proof. We mimic the proof idea in [9], which uses a reduction from the Post correspondence problem
(PCP). A PCP instance is a collection C of dominoes of the form:

(

h u1
v1

i

,

h u2
v2

i
, . . . ,

h uk
vk

)
i

where for all i ∈ [1, k], we have vi, ui ∈ {a, b}∗. The problem is to decide whether there exists a
ﬁnite sequence of the dominoes of the form
h ui1
vi1

ih ui2
vi2

h uim
vim

· · ·

i

i

where each index ij ∈ [1, k], such that the upper and lower ﬁnite strings of the dominoes are equal,
i.e.,

ui1ui2 · · · uim = vi1vi2 · · · vim

B. Bonakdarpour and S. Sheinvald

XX:17

For example, if the set of dominoes is

Cexmp =

(

h ab
b

i

,

i

,

h ba
a

h a
aba

)

i

Then, a possible solution is the following sequence of dominoes from Cexmp:

sol =

h a
aba

ih ba
a

ih ab
b

i
.

Given an instance C of PCP, we encode a solution as a word wsol over the following alphabet:

o
n σ
σ0 | σ, σ0 ∈ {a, b, ˙a, ˙b, $}
.
Intuitively, ˙σ marks the beginning of a new domino, and $ marks the end of a sequence of the upper
or lower parts of the dominoes sequence.

Σ =

We note that wsol encodes a legal solution iff the following conditions are met:

1. For every σ

σ0 that occurs in wsol, it holds that σ, σ0 represent the same domino letter (both a or

both b, either dotted or undotted).

2. The number of dotted letters in the upper part of wsol is equal to the number of dotted letters in

the lower part of wsol.

3. wsol starts with two dotted letters, and the word ui between the i’th and i + 1’th dotted letters in
the upper part of wsol, and the word vi between the corresponding dotted letters in the lower part
of wsol are such that [ ui
vi

] ∈ C, for every i.

We call a word that represents the removal of the ﬁrst k dominoes from wsol a partial solution,
denoted by wsol,k. Note that the upper and lower parts of wsol,k are not necessarily of equal lengths
(in terms of a and b sequences), since the upper and lower parts of a domino may be of different
lengths, and so we use letter $ to pad the end of the encoding in the shorter of the two parts.

We construct an NFH A, which, intuitively, expresses the following ideas: (1) There exists an
encoding wsol of a solution to C, and (2) For every wsol,k 6= (cid:15) in a hyperword S accepted by A, the
word wsol,k+1 is also in S.

L(A) is then the set of all hyperwords that contain an encoded solution wsol, as well as all its
sufﬁxes obtained by removing a preﬁx of dominoes from wsol. This ensures that wsol indeed encodes
a legal solution. For example, a matching hyperword S (for solution sol discussed earlier) that is
accepted by A is:

S = {wsol =

˙b
b

˙a
˙a

a
a

˙a
˙a

b
˙b

, wsol,1 =

˙b
˙a

a
˙b

˙a
$

b
$

, wsol,2 =

˙a
˙b

b
$

, wsol,3 = (cid:15)}

Thus, the acceptance condition of A is α = ∀x1∃x2∃x3, where x1 is to be assigned a potential

partial solution wsol,k, and x2 is to be assigned wsol,k+1, and x3 is to be assigned wsol.

During a run on a hyperword S and an assignment v : {x1, x2, x3} → S, the NFH A checks that
the upper and lower letters of wsol all match. In addition, A checks that the ﬁrst domino of v(x1) is
indeed in C, and that v(x2) is obtained from v(x1) by removing the ﬁrst tile. A performs the latter
task by checking that the upper and lower parts of v(x2) are the upper and lower parts of v(x1) that
have been “shifted” back appropriately. That is, if the ﬁrst tile in v(x2) is the encoding of [ wi
], then
vi
A uses states to remember, at each point, the last |wi| letters of the upper part of v(x2) and the last
|vi| letters of the lower part of v(x2), and veriﬁes, at each point, that the next letter in v(x1) matches
(cid:74)
the matching letter remembered by the state.

XX:18 Automata for Hyperlanguages

Theorem 10

Proof. The lower bound for both fragments follows from the NL-hardness of the nonemptiness
problem for NFA.

We turn to the upper bound, and begin with NFH∃. Let A∃ be an NFH∃. We claim that A∃ is
nonempty iff ˆA∃ accepts some legal word w. The ﬁrst direction is trivial. For the second direction, let
w ∈ L( ˆA∃), and let S = unzip(w). By assigning v(xi) = w[i] for every xi ∈ X, we get zip(v) = w,
and according to the semantics of ∃, we have that A∃ accepts S. To check whether ˆA∃ accepts a
legal word, we can run a reachability check on-the-ﬂy, while advancing from a letter σ to the next
letter σ0 only if σ0 contains # in all the positions in which σ contains #. While each transition
(σ1,...σn)
−−−−−−→ p in ˆA is of size k, we can encode T as a set of size k of encodings of transitions of
T = q
type q σi−→ p with a binary encoding of p, q, σi, as well as i, t, where t marks the index of T within
the set of transitions of ˆA. Therefore, the reachability test can be performed within space that is
logarithmic in the size of A∃.

Now, let A∀ be an NFH∀ over X. We claim that A∀ is nonempty iff A∀ accepts a hyperword of
size 1. For the ﬁrst direction, let S ∈ L(A∀). Then, by the semantics of ∀, we have that for every
assignment v : X → S, it holds that zip(v) ∈ L( ˆA∀). Let u ∈ S, and let vu(xi) = u for every
xi ∈ X. Then, in particular, zip(vu) ∈ L( ˆA∀). Then for every assignment v : X → {u} (which
consists of the single assignment vu), it holds that ˆA∀ accepts zip(v), and therefore A∀ accepts {u}.
The second direction is trivial.

To check whether A∀ accepts a hyperword of size 1, we restrict the reachability test on ˆA∀ to
(cid:74)

k-tuples of the form (σ, σ, . . . σ) for σ ∈ Σ.

Theorem 11

Proof. We begin with the upper bound. Let S ∈ L(A). Then, according to the semantics of
the quantiﬁers, there exist w1, . . . wm ∈ S, such that for every assignment v : X → S in which
v(xi) = wi for every 1 ≤ i ≤ m, it holds that ˆA accepts zip(v). Let v : X → S be such an
assignment. Then, ˆA accepts zip(vζ) for every sequence ζ of the form (1, 2, . . . m, i1, i2, . . . ik−m).
In particular, it holds for such sequences in which 1 ≤ ij ≤ m for every 1 ≤ j ≤ k − m, that
is, sequences in which the last k − m variables are assigned words that are assigned to the ﬁrst m
variables. Therefore, again by the semantics of the quantiﬁers, we have that {v(x1), . . . v(xm)} is in
L(A). The second direction is trivial.

(σi1 ,σi2 ,...σik )
−−−−−−−−−−→ q0 in δ, we have q

We call zip(vζ) as described above a witness to the nonemptiness of A, i.e., zip(vζ) is an instan-
tiation of the existential quantiﬁers. We construct an NFA A based on ˆA that is nonempty iff ˆA
accepts a witness to the nonemptiness of A. Let Γ be the set of all sequences of the above form. For
every sequence ζ = (i1, i2, . . . ik) in Γ, we construct an NFA Aζ = h ˆΣ, Q, Q0, δζ, F i, where for
(σ1,σ2,...σk)
−−−−−−−−→ q0 in δζ. Intuitively, Aζ runs on every word
every q
w the same way that ˆA runs on wζ. Therefore, ˆA accepts a witness w to the nonemptiness of A iff
w ∈ L(Aζ) for every ζ ∈ Γ.
We deﬁne A = T

ζ∈Γ Aζ. Then ˆA accepts a witness to the nonemptiness of A iff A is nonempty.
Since |Γ| = mk−m, the state space of A is of size O(nmk−m
), where n = |Q|, and its alphabet is of
size | ˆΣ|. Notice that for A to be nonempty, δ must be of size at least |(Σ ∪ #)|(k−m), to account for
all the permutations of letters in the words assigned to the variables under ∀ quantiﬁers (otherwise,
we can immediately return “empty”). Therefore, | ˆA| is O(n · |Σ|k). We then have that the size of A
is O(| ˆA|k). If the number k − m of ∀ quantiﬁers is ﬁxed, then mk−m is polynomial in k. However,
now | ˆA| may be polynomial in n, k, and |Σ|, and so in this case as well, the size of A is O(| ˆA|k).

Since the nonemptiness problem for NFA is NL-complete, the problem for NFH∃∀ can be decided

B. Bonakdarpour and S. Sheinvald

XX:19

in space of size that is polynomial in | ˆA|.

PSPACE hardness For the lower bound, we show a reduction from a polynomial version of the
corridor tiling problem, deﬁned as follows. We are given a ﬁnite set T of tiles, two relations
V ⊆ T × T and H ⊆ T × T , an initial tile t0, a ﬁnal tile tf , and a bound n > 0. We have to decide
whether there is some m > 0 and a tiling of a n × m-grid such that (1) The tile t0 is in the bottom left
corner and the tile tf is in the top right corner, (2) A horizontal condition: every pair of horizontal
neighbors is in H, and (3) A vertical condition: every pair of vertical neighbors is in V . When n is
given in unary notation, the problem is known to be PSPACE-complete.

Given an instance C of the tiling problem, we construct an NFH∃∀ A that is nonempty iff C has a
solution. We encode a solution to C as a word wsol = w1 · w2 · wm$ over Σ = T ∪ {1, 2, . . . n, $},
where the word wi, of the form 1 · t1,i · 2 · t2,i, . . . n · tn,i, describes the contents of row i.

To check that wsol indeed encodes a solution, we need to make sure that:

1. w1 begins with t0 and wm ends with tf $.
2. wi is of the correct form.
3. Within every wi, it holds that (tj,i, tj+1,i) ∈ H.
4. For wi, wi+1, it holds that (tj,i, tj,i+1) ∈ V for every 1 ≤ j ≤ n.

Verifying items 1 − 3 is easy via an NFA of size O(n|H|). The main obstacle is item 4.
We describe an NFH∃∀ A = hT ∪ {0, 1, 2, . . . n, $}, {y1, y2, y3, x1, . . . xlog(n)}, Q, {q0}, δ, F, αi
that is nonempty iff there exists a word that satisﬁes items 1 − 4. The quantiﬁcation condition α is
∃y1∃y2∃y3∀x1 . . . ∀xlog(n). The NFH A only proceeds on letters whose ﬁrst three positions are of
the type (r, 0, 1), where r ∈ T ∪ {1, . . . n, $}. Notice that this means that A requires the existence
of the words 0|wsol| and 1|wsol| (the 0 word and 1 word, henceforth). A makes sure that the word
assigned to y1 matches a correct solution w.r.t. items 1 − 3 described above. We proceed to describe
how to handle the requirement for V . We need to make sure that for every position j in a row, the tile
in position j in the next row matches the current one w.r.t. V . We can use a state qj to remember
the tile in position j, and compare it to the tile in the next occurrence of j. The problem is avoiding
having to check all positions simultaneously, which would require exponentially many states. To this
end, we use log(n) copies of the 0 and 1 words to form a binary encoding of the position j that is to
be remembered. The log(n) ∀ conditions make sure that every position within 1 − n is checked.

We limit the checks to words in which x1, . . . xlog(n) are the 0 or 1 words, by having ˆA accept
every word in which there is a letter that is not over 0, 1 in positions 4, . . . log(n) + 3. This takes care
of accepting all cases in which the word assigned to y1 is also assigned to one of the x variables.

To check that x1, . . . xlog(n) are the 0 or 1 words, ˆA checks that the values in positions 4 to
log(n) + 3 remain constant throughout the run. In these cases, upon reading the ﬁrst letter, ˆA
remembers the value j that is encoded by the constant assignments to x1, . . . xlog(n) in a state, and
makes sure that throughout the run, the tile that occurs in the assignment y1 in position j in the current
row matches the tile in position j in the next row.

We construct a similar reduction for the case that the number of ∀ quantiﬁers is ﬁxed: instead
of encoding the position by log(n) bits, we can directly specify the position by a word of the
form j∗, for every 1 ≤ j ≤ n. Accordingly, we construct an NFH∃∀ over {x, y1, . . . yn, z}, with
a quantiﬁcation condition α = ∃x∃y1 . . . ∃yn∀z. The NFA ˆA advances only on letters whose
assignments to y1, . . . yn are always 1, 2, . . . n, respectively, and checks only words assigned to z
that are some constant 1 ≤ j ≤ n. Notice that the ﬁxed assignments to the y variables leads to δ
of polynomial size. In a hyperword accepted by A, the word assigned to x is wsol, and the word
(cid:74)
assigned to z speciﬁes which index should be checked for conforming to V .

XX:20 Automata for Hyperlanguages

Theorem 12

Proof. We can decide the membership of S in L(A) by iterating over all relevant assignments from
X to S, and for every such assignment v, checking on-the-ﬂy whether zip(v) is accepted by ˆA. This
algorithm uses space of size that is polynomial in k and logarithmic in |A| and in |S|.

In the case that k0 = O(log k), an NP upper bound is met by iterating over all assignments to the
variables under ∀, while guessing assignments to the variables under ∃. For each such assignment v,
checking whether zip(v) ∈ L( ˆA) can be done on-the-ﬂy.

We show NP-hardness for this case by a reduction from the Hamiltonian cycle problem. Given a
graph G = hV, Ei where V = {v1, v2, . . . , vn} and |E| = m, we construct an NFH∃ A over {0, 1}
with n states, n variables, δ of size m, and a hyperword S of size n, as follows. S = {w1, . . . , wn},
where wi is the word over {0, 1} in which all letters are 0 except for the i’th. The structure of ˆA is
identical to that of G, and we set Q0 = F = {v1}. For the transition relation, for every (vi, vj) ∈ E,
we have (vi, σi, vj) ∈ δ, where σi is the letter over {0, 1}n in which all positions are 0 except for
position i. Intuitively, the i’th letter in an accepting run of ˆA marks traversing vi. Assigning wj to xi
means that the j’th step of the run traverses vi. Since the words in w make sure that every v ∈ V is
traversed exactly once, and that the run on them is of length n, we have that A accepts S iff there
exists some permutation p of the words in S such that p matches a Hamiltonian cycle in G.
remark To account for all the assignments to the ∀ variables, δ – and therefore, ˆA – must be of size
at least 2k0
(otherwise, we can return “no”). We then have that if k = O(k0), then space of size k
is logarithmic in | ˆA|, and so the problem in this case can be solved within logarithmic space. A
(cid:74)
matching NL lower bound follows from the membership problem for NFA.

Theorem 13

Proof. Let A = hΣ, P, P0, ρ, F i be an NFA, and let A = hΣ, {x1, . . . , xk}, Q, Q0, δ, F, αi be an
NFH.

First, we construct an NFA A0 = hΣ ∪ {#}, P 0, P 0

0, ρ0, F 0i by extending the alphabet of A to
Σ ∪ {#}, adding a new and accepting state pf to P with a self-loop labeled by #, and transitions
labeled by # from every q ∈ F to pf . The language of A0 is then L(A) · #∗. We describe a recursive
procedure (iterating over α) for deciding whether L(A) ∈ L(A).

For the case that k = 1, it is easy to see that if α = ∃x1, then L(A) ∈ L(A) iff L(A) ∩ L( ˆA) 6= ∅.
Otherwise, if α = ∀x1, then L(A) ∈ L(A) iff L(A) /∈ L(A), where A is the NFH for L(A)
described in Theorem 8. Notice that the quantiﬁcation condition for A is ∃x1, and so this conforms
to the base case.

For k > 1, we construct a sequence of NFH A1, A2, . . . , Ak. If Q1 = ∃ then we set A1 = A,
i , δi, Fi, αii. If αi starts with ∃,

and otherwise we set A1 = A. Let Ai = hΣ, {xi, . . . , xk}, Qi, Q0
then we construct Ai+1 as follows.

The set of variables of Ai+1 is {xi+1, . . . , xk}, and the quantiﬁcation condition αi+1 is
Qi+1xi+1 · · · Qkxk, for αi = QixiQi+1 · · · Qkxk. The set of states of Ai+1 is Qi × P 0, and the set
(σi,...,σk)
−−−−−−→ q0) ∈ δi
i × P0. The set of accepting states is Fi × F 0. For every (q
of initial states is Q0
(σi+1,...,σk)
and every (p σi−→ p0) ∈ ρ, we have ((q, p)
−−−−−−−−→ (q0, p0)) ∈ δi+1. Then, ˆAi+1 accepts a word
zip(u1, u2, . . . , uk−i) iff there exists a word u ∈ L(A), such that ˆAi accepts zip(u, u1, u2, . . . , uk−i).
Let v : {xi, . . . , xk} → L(A). Then L(A) |=v (αi, Ai) iff there exists w ∈ L(A) such
that L(A) |=v[xi→w] (αi+1, Ai). For an assignment v0 : {xi+1, . . . , xk} → L(A), it holds that
zip(v0) is accepted by ˆAi+1 iff there exists a word w ∈ L(A) such that zip(v) ∈ L( ˆAi), where v
is obtained from v0 by setting v(xi) = w. Therefore, we have that L(A) |=v[xi→w] (αi, Ai) iff
L(A) |=v0 (αi+1, Ai+1), that is, L(A) ∈ L(Ai) iff L(A) ∈ L(Ai+1).

B. Bonakdarpour and S. Sheinvald

XX:21

If αi starts with ∀, then we have that L(A) ∈ L(Ai) iff L(A) /∈ L(Ai). We construct Ai for
L(Ai) as described in Theorem 8. The quantiﬁcation condition of Ai then begins with ∃xi, and we
apply the previous case, and construct Ai+1 w.r.t. Ai, to check for non-membership.

Every ∀ quantiﬁer requires complementation, which is exponential in n, the number of states in

A. Therefore, in the worst case, the complexity of this algorithm is O(22...|Q||A|
of height k. If the number of ∀ quantiﬁers is ﬁxed, then the complexity is O(|Q||A|k).

), where the tower is
(cid:74)

Theorem 14

Proof. For the lower bound, we show a reduction from the containment problem for NFA, which is
known to be PSPACE-hard. Let A1, A2 be NFA. We “convert” them to NFH A1, A2 by adding to
both a single variable x, and a quantiﬁcation condition ∀x. By the semantics of the ∀ quantiﬁer, we
have that L(A1) = {S|S ⊆ L(A1)}, and similarly for A2. Therefore, we have that L(A1) ⊆ L(A2)
iff L(A1) ⊆ L(A2).

For the upper bound, ﬁrst notice that complementing an NFH∀ yields an NFH∃, and vice versa.
Consider two NFH A1 and A2. Then L(A1) ⊆ L(A2) iff L(A1) ∩ L(A2) = ∅. We can use the
constructions in the proof of Theorem 8 to compute a matching NFH A = A1 ∩ A2, and check its
nonemptiness. The complementation construction is exponential in n2, the number of states of A2,
and the intersection construction is polynomial in |A1|, |A2|.

If A1 ∈ NFH∃ and A2 ∈ NFH∀ or vice versa, then A is an NFH∃ or NFH∀, respectively, whose

nonemptiness can be decided in space that is logarithmic in |A|.

Now, consider the case where A1 and A2 are both NFH∃ or both NFH∀. It follows from the proof
of Theorem 8, that for two NFH A, A0, the quantiﬁcation condition of A ∩ A0 may be any interleaving
of the quantiﬁcation conditions of A and A0. Therefore, if A1, A2 ∈ NFH∃ or A1, A2 ∈ NFH∀,
we can construct A to be an NFH∃∀. This is also the case when A1 ∈ NFH∃∀ and A2 ∈ NFH∃ or
A2 ∈ NFH∀.

Either A2 or A2 is an NFH∀, whose underlying NFA has a transition relation of size that is
exponential in k (otherwise the NFH∀ is empty). The same holds for A1 ∈ NFH∃∀. The PSPACE
upper bound of Theorem 11 is derived from the number of variables and not from the state-space of the
NFH. Therefore, while | ¯A2| is exponential in the number of states of A2, checking the nonemptiness
(cid:74)
of A is in PSPACE.

Lemma 16

Proof. We begin with NFH∀. For the ﬁrst direction, since L( ˆA0
∀) ⊆
L(A∀). For the second direction, let S ∈ L(A∀). Then for every v : S → X, it holds that
zip(v) ∈ L( ˆA∀). Also, zip(v0) ∈ L( ˆA∀) for every sequence v0 of v. Then zip(v) and all its
sequences are in L( ˆA0

∀). Since this holds for every v : X → S, we have that S ∈ L(A0

∀) ⊆ L( ˆA∀), we have L(A0

We proceed to NFH∃. For the ﬁrst direction, since L( ˆA∃) ⊆ L( ˆA0

∃), we have L(A) ⊆ L(A0).
For the second direction, let S ∈ L(A0
∃).
Then zip(v) is a permutation of some word zip(v0) ∈ L( ˆA∃). According to the semantics of the ∃
(cid:74)
quantiﬁer, we have that S ∈ L(A∃).

∃). Then there exists v : S → X such that zip(v) ∈ L( ˆA0

∀).

Lemma 17

Proof. We begin with NFH∀. To construct A0
∀ given A∀, we use a similar construction to the one
presented in the proof of Theorem 11. Essentially, for every sequence ζ of (1, 2, . . . , k), we construct
an NFA Aζ, in which every run on a word w matches a run of ˆA∀ on wζ. The NFH∀ A0 is then

XX:22 Automata for Hyperlanguages

obtained from A∀ by replacing the underlying NFA with T
of (1, 2, . . . , k).

ζ∈Γ Aζ, where Γ is the set of sequences

For NFH∃, similarly to the case of NFH∀, we construct A0

every permutation ζ of (1, 2, . . . , k). In this case, the NFH∃ A0
underlying NFA with S

ζ∈Γ Aζ, where Γ is the set of permutations of (1, 2, . . . , k).

∃ given A∃ by constructing Aζ for
∃ is obtained from A∃ by replacing the
(cid:74)

Theorem 18
Proof. We begin with NFH∀. For the ﬁrst direction, let w ∈ L( ˆA∀). Since A1 is sequence-complete,
then w0 ∈ L( ˆA1) for every sequence w0 of w. Then, by the semantics of the ∀ quantiﬁer, we have that
unzip(w) ∈ L(A1). Therefore, unzip(w) ∈ L(A2), and so w (and all its sequences) are in L( ˆA2). A
similar argument can be made to show that for every w ∈ L( ˆA2), it holds that w ∈ L( ˆA1). Therefore,
L( ˆA1) = L( ˆA2). The second direction is trivial.

We continue to NFH∃. For the ﬁrst direction, let w ∈ L( ˆA1). Then unzip(w) ∈ L(A1). Then, by
the semantics of the ∃ quantiﬁer, there exists some permutation w0 of w such that w0 ∈ L( ˆA2). Since
A2 is permutation-complete, we have that w ∈ L( ˆA2). A similar argument can be made to show that
for every w ∈ L( ˆA2), it holds that w ∈ L( ˆA1). Therefore, L( ˆA1) = L( ˆA2). The second direction is
(cid:74)
trivial.

