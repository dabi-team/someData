Automata for Hyperlanguages

Borzoo Bonakdarpour1
Department of Computer Science, Iowa State University, U.S.A.
borzoo@iastate.edu

Sarai Sheinvald
Department of Software Engineering, ORT Braude College, Israel
sarai@braude.ac.il

1

2

3

4

5

6

7

Abstract

Hyperproperties lift conventional trace properties from a set of execution traces to a set of sets of execution
traces. Hyperproperties have been shown to be a powerful formalism for expressing and reasoning about
information-ï¬‚ow security policies and important properties of cyber-physical systems such as sensitivity and
robustness, as well as consistency conditions in distributed computing such as linearizability. Although there
is an extensive body of work on automata-based representation of trace properties, we currently lack such
characterization for hyperproperties.

We introduce hyperautomata for hyperlanguages, which are languages over sets of words. Essentially,
hyperautomata allow running multiple quantiï¬ed words over an automaton. We propose a speciï¬c type of
hyperautomata called nondeterministic ï¬nite hyperautomata (NFH), which accept regular hyperlanguages.
We demonstrate the ability of regular hyperlanguages to express hyperproperties for ï¬nite traces. We then
explore the fundamental properties of NFH and show their closure under the Boolean operations. We show
that while nonemptiness is undecidable in general, it is decidable for several fragments of NFH. We further
show the decidability of the membership problem for ï¬nite sets and regular languages for NFH, as well as
the containment problem for several fragments of NFH. Finally, we introduce learning algorithms based on
Angluinâ€™s Lâˆ— algorithm for the fragments NFH in which the quantiï¬cation is either strictly universal or strictly
existential.

2012 ACM Subject Classiï¬cation Author: Please ï¬ll in 1 or more \ccsdesc macro

Keywords and phrases Author: Please ï¬ll in \keywords macro

Digital Object Identiï¬er 10.4230/LIPIcs...

Funding Borzoo Bonakdarpour:

0
2
0
2

b
e
F
3
2

]
L
F
.
s
c
[

1
v
7
7
8
9
0
.
2
0
0
2
:
v
i
X
r
a

1 Optional footnote, e.g. to mark corresponding author

Â© B. Bonakdarpour and S. Sheinvald;
licensed under Creative Commons License CC-BY

Leibniz International Proceedings in Informatics
Schloss Dagstuhl â€“ Leibniz-Zentrum fÃ¼r Informatik, Dagstuhl Publishing, Germany

 
 
 
 
 
 
XX:2

Automata for Hyperlanguages

1

Introduction

Hyperproperties [7] generalize the traditional trace properties [1] to system properties, i.e., a set of
sets of traces. Put it another way, a hyperproperty prescribes how the system should behave in its
entirety and not just based on its individual executions. Hyperproperties have been shown to be a
powerful tool for expressing and reasoning about information-ï¬‚ow security policies [7] and important
properties of cyber-physical systems [16] such as sensitivity and robustness, as well as consistency
conditions in distributed computing such as linearizability [4].

Automata theory has been in the forefront of developing techniques for speciï¬cation and veriï¬ca-
tion of computing systems. For instance, in the automata-theoretic approach to veriï¬cation [14, 15],
the model-checking problem is reduced to checking the nonemptiness of the product automaton of
the model and the complement of the speciï¬cation. In the industry and other disciplines (e.g., control
theory), automata are an appealing choice for modeling the behavior of a system. Unfortunately,
we currently lack a deep understanding about the relation between hyperproperties and automata
theory. To our knowledge, work in this area is limited to [8], in which the authors develop an
automata representation for the class of regular k-safety hyperproperties. These are hyperproperties
where execution traces are only universally quantiï¬ed and their behaviors are non-refutable. They
introduce the notion of a k bad-preï¬x automaton â€“ a ï¬nite-word automaton that recognizes sets of
k bad preï¬xes as ï¬nite words. Based on this representation, they present a learning algorithm for
k-safety hyperproperties. In [10], the authors offer a model-checking algorithm for hyperCTLâˆ— [6],
which constructs an alternating BÃ¼chi automaton that has both the formula and the Kripke structure
â€œbuilt-inâ€. These approaches translate a hyperproperty-related problem to word automata.

We generalize the idea in [8] to a broader view of an automata-based representation of hyperprop-
erties, and introduce hyperautomata for hyperlanguages, which are languages whose elements are
sets of ï¬nite words, which we call hyperwords. In this paper, we propose nondeterministic ï¬nite-word
hyperautomata (NFH). An NFH runs on hyperwords that contain ï¬nite words, by using quantiï¬ed
word variables that range over the words in a hyperword, and a nondeterministic ï¬nite-word auto-
maton (NFA) that runs on the set of words that are assigned to the variables. We demonstrate the idea
with two examples.

(cid:73) Example 1. Consider the NFH A1 in Figure 1 (left), whose alphabet is Î£ = {a, b}, over two
word variables x1 and x2. The NFH A1 contains an underlying standard NFA, whose alphabet
comprises pairs over Î£, i.e., elements of Î£2, in which the ï¬rst letter represents the letters of the word
assigned to x1, and dually for the second letter and x2. The underlying NFA of A1 requires that
(1) these two words agree on their a (and, consequently, on their b) positions, and (2) once one of
the words has ended (denoted by #), the other must only contain b letters. Since the quantiï¬cation
condition of A1 is âˆ€x1âˆ€x2, in a hyperword S that is accepted by A1, every two words agree on their
a positions. As a result, all the words in S must agree on their a positions. The hyperlanguage of A1
is then all hyperwords in which all words agree on their a positions.

(cid:73) Example 2. Next, consider the NFH A2 in Figure 1 (right), over the alphabet Î£ = {a}, and
two word variables x1 and x2. The underlying NFA of A2 accepts the two words assigned to x1
and x2 iff the word assigned to x2 is longer than the word assigned to x1. Since the quantiï¬cation
condition of A2 is âˆ€x1âˆƒx2, we have that A2 requires that for every word in a hyperword S accepted
by A2, there exists a longer word in S. This holds iff S contains inï¬nitely many words. Therefore,
the hyperlanguage of A2 is the set of all inï¬nite hyperwords over {a}.

We call the hyperlanguages accepted by NFH regular hyperlanguages. A regular hyperlanguage
L can also be expressed by the regular expression for the language of the underlying NFA of an NFH
A for L, augmented with the quantiï¬cation condition of A. We call such an expression a hyperregular

B. Bonakdarpour and S. Sheinvald

XX:3

Figure 1 The NFH A1 (left) and A2 (right).

expression (HRE). We demonstrate the ability of HREs to express important information-ï¬‚ow security
policies such as different variations of noninteference [11] and observational determinism [17].

We proceed to conduct a comprehensive study of properties of NFH (see Table 1). In particular,
we show that NFH are closed under union, intersection, and complementation. We also prove that
the nonemptiness problem is in general undecidable for NFH. However, for the alternation-free
fragments (which only allow one type of quantiï¬er), as well as for the âˆƒâˆ€ fragment (in which
the quantiï¬cation condition is limited to a sequence of âˆƒ quantiï¬ers followed by a sequence of âˆ€
quantiï¬ers), nonemptiness is decidable. These results are in line with the results on satisï¬ability of
HyperLTL [9]. We also study the membership and inclusion problems. These results are aligned with
the complexity of HyperLTL model checking for tree-shaped and general Kripke structures [3]. This
shows that, surprisingly, the complexity results in [9, 3] mainly stem from the nature of quantiï¬cation
over ï¬nite words and depend on neither the full power of the temporal operators nor the inï¬nite nature
of HyperLTL semantics.

Finally, we introduce learning algorithms for the alternation-free fragments of NFH. Our al-
gorithms are based on Angluinâ€™s Lâˆ— algorithm [2] for regular languages, and are inspired by [8],
where the authors describe a learning algorithm that is tailored to learn a k-bad preï¬x NFA for
a k-safety formula. In fact, the algorithm there can be viewed of as a special case of learning a
hyperlanguage in the âˆƒ-fragment of NFH.

In a learning algorithm, a learner aims to construct an automaton for an unknown target language
L, by means of querying a teacher, who knows L. The learner asks two types of queries: membership
queries (â€œis the word w in L?â€) and equivalence queries (â€œis A an automaton for L?â€). In case of a
failed equivalence query, the teacher returns a counterexample word on which A and L differ. The
learning algorithm describes how the learner uses the answers it gets from the teacher to construct its
candidate automaton.

In the case of NFH, the membership queries, as well as the counterexamples, are hyperwords.
The number of variables is unknown in advance, and is also part of the learning goal. We ï¬rst deï¬ne
canonical forms for the alternation-free fragments of NFH, which is essential for this type of learning
algorithm. Then, we proceed to describe the learning algorithms for both fragments.
Organization. The rest of the paper is organized as follows. Preliminary concepts are presented in
Section 2. We introduce the notion of NFH and HRE in Sections 3 and 4, while their properties are
studied in Section 5. We propose our learning algorithm in Section 6. Finally, we make concluding
remarks and discuss future work in Section 7. Detailed proofs appear in the appendix.

2

Preliminaries

An alphabet is a nonempty ï¬nite set Î£ of letters. A word over Î£ is a ï¬nite sequence of letters from Î£.
The empty word is denoted by (cid:15), and the set of all ï¬nite words is denoted by Î£âˆ—. A language is a
subset of Î£âˆ—.

(cid:73) Deï¬nition
tuple
A = hÎ£, Q, Q0, Î´, F i, where Î£ is an alphabet, Q is a nonempty ï¬nite set of states, Q0 âŠ† Q is

3. A nondeterministic

ï¬nite-word

automaton

(NFA)

is

a

ğ‘,ğ‘(#,ğ‘)#,ğ‘âˆ€ğ‘¥1âˆƒğ‘¥2ğ‘,ğ‘,(ğ‘,ğ‘)(#,ğ‘)(ğ‘,#)(#,ğ‘)(ğ‘,#)âˆ€ğ‘¥1âˆ€ğ‘¥2XX:4

Automata for Hyperlanguages

Property

Closure

Nonemptiness

Finite membership

Regular membership
Containment

Result

Complementation, Union, Intersection (Theorem 8)
Undecidable (Theorem 9)
NL-complete (Theorem 10)
PSPACE-complete (Theorem 11)
PSPACE (Theorem 12)
NP-complete (Theorem 12)

âˆ€âˆƒâˆƒ
âˆƒâˆ—/âˆ€âˆ—
âˆƒâˆ—âˆ€âˆ—
NFH
O(log(k)) âˆ€

Decidable (Theorem 13)

âˆƒâˆ—/âˆ€âˆ—/âˆƒâˆ—âˆ€âˆ— âŠ† âˆƒâˆ—/âˆ€âˆ—

PSPACE-complete (Theorem 14)

Table 1 Summary of results on properties of NHF.

a set of initial states, F âŠ† Q is a set of accepting states, and Î´ âŠ† Q Ã— Î£ Ã— Q is a transition relation.

Given a word w = Ïƒ1Ïƒ2 Â· Â· Â· Ïƒn over Î£, a run of A on w is a sequence of states (q0, q1, . . . qn),
such that q0 âˆˆ Q0, and for every 0 < i â‰¤ n, it holds that (qiâˆ’1, Ïƒi, qi) âˆˆ Î´. The run is accepting if
qn âˆˆ F . We say that A accepts w if there exists an accepting run of A on w. The language of A,
denoted by L(A), is the set of all ï¬nite words that A accepts. A language L is called regular if there
exists an NFA such that L(A) = L.

An NFA A is called deterministic (DFA), if for every q âˆˆ Q and Ïƒ âˆˆ Î£, there exists exactly one
q0 for which (q, Ïƒ, q0) âˆˆ Î´, i.e., Î´ is a transition function. It is well-known that every NFA has an
equivalent DFA.

3 Hyperautomata

Before deï¬ning hyperautomata, we explain the idea behind them. We ï¬rst deï¬ne hyperwords and
hyperlanguages.

(cid:73) Deï¬nition 4. A hyperword over Î£ is a set of words over Î£ and a hyperlanguage is a set of
hyperwords.

A hyperautomaton A uses a set of word variables X = {x1, x2, . . . , xk}. When running on a
hyperword S, these variables are assigned words from S. We represent an assignment v : X â†’ S
as the k-tuple (v(x1), v(x2), . . . , v(xk)). Notice that the variables themselves do not appear in this
representation of v, and are manifested in the order of the words in the k-tuple: the iâ€™th word is the
one assigned to xi. This allows a cleaner representation with less notations.

The hyperautomaton A consists of a quantiï¬cation condition Î± over X, and an underlying word
automaton Ë†A, which runs on words that represent assignments to X (we explain how we represent
assignments as words later on). The condition Î± deï¬nes the assignments that Ë†A should accept. For
example, Î± = âˆƒx1âˆ€x2 requires that there exists a word w1 âˆˆ S (assigned to x1), such that for every
word w2 âˆˆ S (assigned to x2), the word that represents (w1, w2) is accepted by Ë†A. The hyperword S
is accepted by A iff S meets these conditions.

We now elaborate on how we represent an assignment v : X â†’ S as a word. We encode the
tuple (v(x1), v(x2), . . . v(xk)) by a word w whose letters are k-tuples in Î£k, where the iâ€™th letter
of w represents the k iâ€™th letters of the words v(x1), . . . , v(xk) (in case that the words are not of
equal length, we â€œpadâ€ the end of the word with # signs). For example, the assignment v(x1) =
aa, v(x2) = abb, represented by the tuple (aa, abb), is encoded by the word (a, a)(a, b)(#, b). We
later refer to w as the zipping of v. Once again, notice that due to the indexing of the word variables,
the variables do not explicitly appear in w.

B. Bonakdarpour and S. Sheinvald

XX:5

We now turn to formally deï¬ne hyperautomata.

3.1 Nondeterminsitic Finite-Word Hyperautomata

We begin with some terms and notations.

Let s = (w1, w2, . . . , wk) be a tuple of ï¬nite words over Î£. We denote the length of the longest
word in s by dse. We represent s by a word over (Î£ âˆª {#})k of length dse, which is formed by a
function zip(s) that â€œzipsâ€ the words in s together: the iâ€™th letter in zip(s) represents the iâ€™th letters
in w1, w2, . . . , wk, and # is used to pad the words that have ended. For example,

zip(aab, bc, abdd) = (a, b, a)(a, c, b)(b, #, d)(#, #, d).

Formally, we have zip(s) = s1s2 Â· Â· Â· sdse, where si[j] = wji if j â‰¤ |w|, and si[j] = #, otherwise.

Given a zipped word s, we denote the word formed by the letters in the iâ€™th positions in s by s[i].
That is, s[i] is the word Ïƒ1Ïƒ2 Â· Â· Â· Ïƒm formed by deï¬ning Ïƒj = sj[i], for sj[i] âˆˆ Î£. Notice that zip(s)
is reversible, and we can deï¬ne an unzip function as unzip(s) = (s[1], s[2], . . . , s[k]). We sometimes
abuse the notation, and use unzip(s) to denote {s[1], s[2], . . . , s[k]}, and zip(S) to denote the zipping
of the words in a ï¬nite hyperword S in some arbitrary order.

(cid:73) Deï¬nition 5. A nondeterministic ï¬nite-word hyperautomaton (NFH)
is a tuple
A = hÎ£, X, Q, Q0, F, Î´, Î±i, where Î£, Q, Q0, and F are as in Deï¬nition 3, X = {x1, . . . , xk}
is a ï¬nite set of word variables, Î´ âŠ† Q Ã— (Î£ âˆª {#})k Ã— Q is a transition relation, and Î± =
Q1x1Q2x2 . . . Qnxk is a quantiï¬cation condition, where Qi âˆˆ {âˆ€, âˆƒ} for every 1 â‰¤ i â‰¤ k.

In Deï¬nition 5, the tuple h(Î£ âˆª {#})k, Q, Q0, Î´, F i forms an underlying NFA of A, which we denote
by Ë†A. We denote the alphabet of Ë†A by Ë†Î£.

Let S be a hyperword and let v : X â†’ S be an assignment of the word variables of A to words in
S. We denote by v[x â†’ w] the assignment obtained from v by assigning the word w âˆˆ S to x âˆˆ X.
We represent v by the word zip(v) = zip(v(x1), . . . v(xk)). We now deï¬ne the acceptance condition
of a hyperword S by an NFH A. We ï¬rst deï¬ne the satisfaction relation |= for S, A, a quantiï¬cation
condition Î±, and an assignment v : X â†’ S, as follows.

For Î± = (cid:15), we denote S |=v (Î±, A) if Ë†A accepts zip(v).
For Î± = âˆƒxiÎ±0, we denote S |=v (Î±, A) if there exists w âˆˆ S, such that S |=v[xiâ†’w] (Î±0, A).
For Î± = âˆ€xiÎ±0, we denote S |=v (Î±, A) if for every w âˆˆ S, it holds that S |=v[xiâ†’w] (Î±0, A).2
Since the quantiï¬cation condition of A includes all of X, the satisfaction is independent of the
assignment v, and we denote S |= A, in which case, we say that A accepts S.

(cid:73) Deï¬nition 6. Let A be an NFH. The hyperlanguage of A, denoted L(A), is the set of all
hyperwords that A accepts.

We call a hyperlanguage L a regular hyperlanguage if there exists an NFH A such that L(A) = L.
(cid:73) Example 7. Consider the NFH A3 in Figure 2, over the alphabet Î£ = {a, b} and two word
variables x1 and x2. From the initial state, two words lead to the left component in Ë†A3 iff in every
position, if the word assigned to x2 has an a, the word assigned to x1 has an a. In the right component,
the situation is dual â€“ in every position, if the word assigned to x1 has an a, the word assigned to
x2 has an a. Since the quantiï¬cation condition of A3 is âˆ€x1âˆ€x2, in a hyperword S accepted by
A3, in every two words in S, the set of a positions of one is a subset of the a positions of the other.
Therefore, L(A3) includes all hyperwords in which there is a full ordering on the a positions.

2 In case that Î± begins with âˆ€, satisfaction holds vacuously with an empty hyperword. We restrict the discussion to

nonempty hyperwords.

XX:6

Automata for Hyperlanguages

Figure 2 The NFH A3.

We consider several fragments of NFH, which limit the structure of the quantiï¬cation condition
Î±. NFHâˆ€ is the fragment in which Î± contains only âˆ€ quantiï¬ers, and similarly, in NFHâˆƒ, Î± contains
only âˆƒ quantiï¬ers. In the fragment NFHâˆƒâˆ€, Î± is of the form âˆƒx1 Â· Â· Â· âˆƒxiâˆ€xi+1 Â· Â· Â· âˆ€xk.

3.2 Additional Terms and Notations

We present several more terms and notations which we use throughout the following sections. We say
that a word w over (Î£ âˆª #)k is legal if w = zip(u1, . . . uk) for some u1, u2, . . . uk âˆˆ Î£âˆ—. Note that
w is legal iff there is no w[i] in which there is an occurrence of # followed by some letter Ïƒ âˆˆ Î£.

Consider two letter tuples Ïƒ1 = (t1, . . . tk) and Ïƒ2 = (s1, . . . sk0). We denote by Ïƒ1 + Ïƒ2 the
tuple (t1, . . . tk, s1, . . . sk0). We extend the notion to zipped words. Let w1 = zip(u1, . . . uk) and
w2 = zip(v1, . . . vk0). We denote by w1 + w2 the word zip(u1, . . . uk, v1, . . . vk0).
Consider a tuple t = (t1, t2, . . . tk) of items. A sequence of t is a tuple (t0

k), where
t0
i âˆˆ {t1, . . . tk} for every 1 â‰¤ i â‰¤ k. A permutation of t is a reordering of the elements of
t. We extend these notions to zipped words, to assignments, and to hyperwords, as follows. Let
Î¶ = (i1, i2, . . . ik) be a sequence (permutation) of (1, 2, . . . , k).

2, . . . t0

1, t0

Let w = zip(w1, . . . wk) be a word over k-tuples. The word wÎ¶, deï¬ned as zip(wi1 , wi2, . . . wik )
is a sequence (permutation) of w.
Let v be an assignment from a set of variables {x1, x2, . . . xk} to a hyperword S. The assignment
vÎ¶, deï¬ned as vÎ¶(xj) = v(xij ) for every 1 â‰¤ i, j â‰¤ k, is a sequence (permutation) of v.
Let S be a hyperword. The tuple w = (w1, . . . wk), where wi âˆˆ S, is a sequence of S.
{w1, . . . wk} = S, then w is a permutation of S.

if

4 Hyperregular Expressions and Application in Security

Given an NFH A, the language of its underlying NFA Ë†A can be expressed as a regular expression r.
Augmenting r with the quantiï¬cation condition Î± of A constitutes a hyperregular expression (HRE)
Î±r. For example, consider the NFH A1 in Figure 1. The HRE of A1 is:
(#, b)âˆ— | (b, #)âˆ—(cid:17)
(cid:16)

(a, a) | (b, b)

(cid:17)âˆ—(cid:16)

âˆ€x1âˆ€x2

We now show the application of HREs in specifying well-known information-ï¬‚ow security policies.
Noninteference [11] requires that commands issued by users holding high clearances be removable

without affecting observations of users holding low clearances:

Ï•ni = âˆ€x1âˆƒx2(l, lÎ»)âˆ—

where l denotes a low state and lÎ» denotes a low state where all high commands are replaced by a
dummy value Î».

ğ‘,ğ‘,(ğ‘,ğ‘)(ğ‘,ğ‘)ğ‘,ğ‘,ğ‘,ğ‘,(ğ‘,ğ‘)(#,ğ‘)ğ‘,ğ‘,ğ‘,ğ‘,(ğ‘,ğ‘)(ğ‘,ğ‘)(ğ‘,#)(#,ğ‘)(ğ‘,#)âˆ€ğ‘¥1âˆ€ğ‘¥2(ğ‘,#)(ğ‘,#)(ğ‘,#)(ğ‘,#)(#,ğ‘)(#,ğ‘)(#,ğ‘)(#,ğ‘)B. Bonakdarpour and S. Sheinvald

XX:7

Observational determinism [17] requires that if two executions of a system start with low-security-

equivalent events, then these executions should remain low equivalent:

Ï•od = âˆ€x1âˆ€x2(l, l)+ | (Â¯l, Â¯l)($, $)âˆ— | (l, Â¯l)($, $)âˆ— | (Â¯l, l)($, $)âˆ—

where l denotes a low event, Â¯l âˆˆ Î£ \ {l}, and $ âˆˆ Î£. We note that similar policies such as Boudol
and Castellaniâ€™s noninterference [5] can be formulated in the same fashion.3

Generalized noninterference (GNI) [12] allows nondeterminism in the low-observable behavior,

but requires that low-security outputs may not be altered by the injection of high-security inputs:

Ï•gni = âˆ€x1âˆ€x2âˆƒx3

(cid:18)

(h, l, hl) | (Â¯h, l, Â¯hl) | (h, Â¯l, hÂ¯l) | (Â¯h, Â¯l, Â¯hÂ¯l)

(cid:19)âˆ—

where h denotes the high-security input, l denotes the low-security output, Â¯l âˆˆ Î£\{l}, and Â¯h âˆˆ Î£\{h}.
Declassiï¬cation [13] relaxes noninterference by allowing leaking information when necessary.
Some programs need to reveal secret information to fulï¬ll functional requirements. For example, a
password checker must reveal whether the entered password is correct or not:

Ï•dc = âˆ€x1âˆ€x2(li, li)(pw, pw)(lo, lo)+

where li denotes low-input state, pw denotes that the password is correct, and lo denotes low-output
states. We note that for brevity, in the above formula, we do not include behaviors where the ï¬rst two
events are not low or in the second event, the password is not valid.

Termination-sensitive noninterference requires that for two executions that start from low-

observable states, information leaks are not permitted by the termination behavior of the program:

Ï•tsni = âˆ€x1âˆ€x2(l, l)($, $)âˆ—(l, l) | (Â¯l, Â¯l)($, $)âˆ— | (l, Â¯l)($, $)âˆ— | (Â¯l, l)($, $)âˆ—

where l denotes a low state and $ âˆˆ Î£.

5

Properties of Regular Hyperlanguages

In this section, we consider the basic operations and decision problems for the various fragments of
NFH. We mostly provide proof sketches, and the complete details appear in the appendix. Throughout
this section, A is an NFH hÎ£, X, Q, Q0, Î´, F, Î±i, where X = {x1, . . . xk}.
We ï¬rst show that NFH are closed under all the Boolean operations.

(cid:73) Theorem 8. NFH are closed under union, intersection, and complementation.

Proof Sketch. Complementing A amounts to dualizing its quantiï¬cation condition (replacing every
âˆƒ with âˆ€ and vice versa), and complementing Ë†A via the standard construction for NFA.

Now, let A1 and A2 be two NFH. The NFH Aâˆ© for L(A1) âˆ© L(A2) is based on the product
construction of Ë†A1 and Ë†A2. The quantiï¬cation condition of Aâˆ© is Î±1 Â· Î±2. The underlying automaton
Ë†Aâˆ© advances simultaneously on both A1 and A2: when Ë†A1 and Ë†A2 run on zipped hyperwords w1
and w2, respectively, Ë†Aâˆ© runs on w1 + w2, and accepts only if both Ë†A1 and Ë†A2 accept.

Similarly, the NFH Aâˆª for L(A1) âˆª L(A2) is based on the union construction of Ë†A1 and Ë†A2. The
quantiï¬cation condition of Aâˆª is again Î±1 Â· Î±2. The underlying automaton Ë†Aâˆª advances either on A1
or A2. For every word w read by Ë†A1, the NFH Ë†Aâˆª reads w + w0, for every w0 âˆˆ Ë†Î£âˆ—
2, and dually, for
every word w read by Ë†A2, the NFH Ë†Aâˆª reads w0 + w, for every w0 âˆˆ Ë†Î£âˆ—
(cid:74)
1.

3 This policy states that every two executions that start from bisimilar states (in terms of memory low-observability),

should remain bisimilarly low-observable.

XX:8

Automata for Hyperlanguages

We now turn to study various decision problems for NFH. We begin with the nonemptiness
problem: given an NFH A, is L(A) = âˆ…? We show that while the problem is in general undecidable
for NFH, it is decidable for the fragments that we consider.

(cid:73) Theorem 9. The nonemptiness problem for NHF is undecidable.

The proof of Theorem 9 mimics the ideas in [9], which uses a reduction from the Post corres-

pondence problem (PCP) to prove the undecidability of HyperLTL satisï¬ability.

For the alternation-free fragments, we can show that a simple reachability test on their underlying

automata sufï¬ces to verify nonemptiness. Hence, we have the following.

(cid:73) Theorem 10. The nonemptiness problem for NFHâˆƒ and NFHâˆ€ is NL-complete.

The nonemptiness of NFHâˆƒâˆ€ is harder, and reachability does not sufï¬ce. However, we show that

the problem is decidable.

(cid:73) Theorem 11. The nonemptiness problem for NFHâˆƒâˆ€ is PSPACE-complete.

Proof Sketch. We can show that an NFHâˆƒâˆ€ A is nonempty iff it accepts a hyperword S of size
that is bounded by the number m of âˆƒ quantiï¬ers in Î±. We can then construct an NFA A whose
language is nonempty iff it accepts zip(S) for such a hyperword S. The size of A is O(|Î´|)mkâˆ’m
).
Unless A only accepts hyperwords of size 1, which can be easily checked, |Î´| must be exponential
in the number k âˆ’ m of âˆ€ quantiï¬ers, to account for all the assignments to the variables under âˆ€,
and so overall |A| is of size O(|A|k). The problem can then be decided in PSPACE by traversing A
on-the-ï¬‚y. We show that a similar result holds for the case that k âˆ’ m is ï¬xed.

We use a reduction from the unary version of the tiling problem to prove PSPACE lower bounds
(cid:74)

both for the general case and for the case of a ï¬xed number of âˆ€ quantiï¬ers.

We turn to study the membership problem for NFH: given an NFH A and a hyperword S, is
S âˆˆ L(A)? When S is ï¬nite, the set of possible assignments from X to S is ï¬nite, and so the problem
is decidable. We call this case the ï¬nite membership problem.

(cid:73) Theorem 12.

The ï¬nite membership problem for NFH is in PSPACE.

The ï¬nite membership problem for NFH with O(log(k)) âˆ€ quantiï¬ers is NP-complete.

Proof Sketch. We can decide the membership of a hyperword S in L(A) by iterating over all
relevant assignments from X to S, and for every such assignment v, checking on-the-ï¬‚y whether
zip(v) is accepted by Ë†A. This algorithm uses space of size that is polynomial in k and logarithmic in
|A| and in |S|.

When the number of âˆ€ quantiï¬ers in A is |O(log(k))|, we can iterate over all assignments to the âˆ€
variables in polynomial time, while guessing assignments to the variables under âˆƒ. Thus, membership
in this case is in NP.

We use a reduction from the Hamiltonian cycle problem to prove NP-hardness for this case.
Given a graph G = h{v1, . . . vn}, Ei, we construct a hyperword S with n different words of length
n over {0, 1}, each of which contains a single 1. We also construct an NFHâˆƒ A over {0, 1} with n
variables, a graph construction similar to that of G, and a single accepting and initial state v1. From
vertex vi there are transitions to all its neighbors, labeled by the letter (0)iâˆ’1 + (1) + (0)nâˆ’i. Thus,
A accepts S iff there exists an assignment f : X â†’ S such that zip(f ) âˆˆ L( Ë†A). Such an assignment
f describes a cycle in G, where f (xi) = wj matches traversing vi in the jâ€™th step. The words in S
ensure a single visit in every state, and their length ensures a cycle of length n.
Note: for every hyperword of size at least 2, the number of transitions in Î´ must be exponential in the
number k0 of âˆ€ quantiï¬ers, to account for all the different assignments to these variables. Thus, if
(cid:74)
k = O(k0), an algorithm that uses a space of size k is in fact logarithmic in the size of A.

B. Bonakdarpour and S. Sheinvald

XX:9

When S is inï¬nite, it may still be ï¬nitely represented. We now address the problem of deciding
whether a regular language L (given as an NFA) is accepted by an NFH. We call this the regular
membership problem for NFH. We show that this problem is decidable for the entire class of NFH.

(cid:73) Theorem 13. The regular membership problem for NFH is decidable.

Proof Sketch. Let A be an NFA, and let A be an NFH, both over Î£. We describe a recursive
procedure for deciding whether L(A) âˆˆ L(A).

For the base case of k = 1, if Î± = âˆƒx1, then L(A) âˆˆ L(A) iff L(A) âˆ© L( Ë†A) 6= âˆ…. Otherwise, if
Î± = âˆ€x1, then L(A) âˆˆ L(A) iff L(A) /âˆˆ L(A), where A is the NFH for L(A). The quantiï¬cation
condition for A is âˆƒx1, which conforms to the previous case.

For k > 1, we construct a sequence of NFH A1, A2, . . . , Ak. If Î± starts with âˆƒ, then we set
A1 = A. Otherwise, we set A1 = A. Given Ai with a quantiï¬cation condition Î±i, we construct
Ai+1 as follows. If Î±i starts with âˆƒ, then the set of variables of Ai+1 is {xi+1, . . . xk}, and the
quantiï¬cation condition Î±i+1 is Qi+1xi+1 Â· Â· Â· Qkxk, where Î±i = QixiQi+1 Â· Â· Â· Qkxk. The NFH
Ai+1 is roughly constructed as the intersection between A and Ë†Ai, based on the ï¬rst position in
every (k âˆ’ i)-tuple letter in Ë†Î£i. Then, Ë†Ai+1 accepts a word zip(u1, . . . ukâˆ’i) iff there exists a word
u âˆˆ L(A), such that Ë†Ai accepts zip(u, u1, . . . ukâˆ’i). Notice that this exactly conforms to the âˆƒ
condition. Therefore, if Qi = âˆƒ, then L(A) âˆˆ L(Ai) iff L(A) âˆˆ L(Ai+1).

If Qi = âˆ€, then L(A) âˆˆ L(Ai) iff L(A) /âˆˆ L(Ai). The quantiï¬cation condition of Ai begins

with âˆƒxi. We then construct Ai+1 w.r.t. Ai as described above, and check for non-membership.

Every âˆ€ quantiï¬er requires complementation, which is exponential in |Q|. Therefore, in the worst

case, the complexity of this algorithm is O(22...|Q||A|
of âˆ€ quantiï¬ers is ï¬xed, then the complexity is O(|Q||A|k).

), where the tower is of height k. If the number
(cid:74)

Since nonemptiness of NFH is undecidable, so are its universality and containment problems.

However, we show that containment is decidable for the fragments that we consider.

(cid:73) Theorem 14. The containment problems of NFHâˆƒ and NFHâˆ€ in NFHâˆƒ and NFHâˆ€ and of NFHâˆƒâˆ€
in NFHâˆƒ and NFHâˆ€ are PSPACE-complete.

Proof Sketch. The lower bound follows from the PSPACE-hardness of the containment problem
for NFA. For the upper bound, for two NFH A1 and A2, we have that L(A1) âŠ† L(A2) iff L(A1) âˆ©
L(A2) = âˆ…. We can use the constructions in the proof of Theorem 8 to compute a matching NFH
A = A1 âˆ© A2, and check its nonemptiness. Complementing A2 is exponential in its number of states,
and the intersection construction is polynomial.

If A1 âˆˆ NFHâˆƒ and A2 âˆˆ NFHâˆ€ or vice versa, then A is an NFHâˆƒ or NFHâˆ€, respectively, whose

nonemptiness can be decided in space that is logarithmic in |A|.

It follows from the construction in the proof of Theorem 8, that the quantiï¬cation condition of A
may be any interleaving of the quantiï¬cation conditions of the two intersected NFH. Therefore, for
the rest of the fragments, we can construct the intersection such that A is an NFHâˆƒâˆ€.

The PSPACE upper bound of Theorem 11 is derived from the number of variables and not from
the state-space of the NFH. Therefore, while | Â¯A2| is exponential in the number of states of A2,
(cid:74)
checking the nonemptiness of A is in PSPACE.

6

Learning NFH

In this section, we introduce Lâˆ—-based learning algorithms for the fragments NFHâˆ€ and NFHâˆƒ. We
ï¬rst survey the Lâˆ— algorithm [2], and then describe the relevant adjustments for our case.

XX:10 Automata for Hyperlanguages

6.1 Angluinâ€™s Lâˆ— Algorithm

Lâˆ— consists of two entities: a learner, who wishes to learn a DFA A for an unknown (regular) language
L, and a teacher, who knows L. During the learning process, the learner asks the teacher two types of
queries: membership queries (â€œis the word w in L?â€) and equivalence queries (â€œis A a DFA for L?â€).
The learner maintains A in the form of an observation table T of truth values, whose rows
D, D Â· Î£ and columns E are sets of words over Î£, where D is preï¬x-closed, and E is sufï¬x-closed.
Initially, D = E = {(cid:15)}. For a row d and a column e, the entry for T (d, e) is tt iff d Â· e âˆˆ L. The
entries are ï¬lled via membership queries. The vector of truth values for row d is denoted row(d).
Intuitively, the rows in D determine the states of A, and the rows in D Â· Î£ determine the transitions
of A: the state row(d Â· Ïƒ) is reached from row(d) upon reading Ïƒ.

The learner updates T until it is closed, which, intuitively, ensures a full transition relation and
consistent, which, intuitively, ensures a deterministic transition relation. If T is not closed or not
consistent then more rows or more columns are added to T , respectively.

When T is closed and consistent, the learner constructs A: The states are the rows of D, the initial
state is row((cid:15)), the accepting states are these in which T (d, (cid:15)) = tt, and the transition relation is as
described above. The learner then submits an equivalence query. If the teacher conï¬rms, the algorithm
terminates. Otherwise, the teacher returns a counterexample w âˆˆ L(A) but w /âˆˆ L (which we call a
positive counterexample), or w /âˆˆ L(A) but w âˆˆ L (which we call a negative counterexample). The
learner then adds w and all its sufï¬xes to E, and proceeds to construct the next candidate DFA A.

It is shown in [2] that as long as A is not a DFA for L, it has less states than a minimal DFA for L.
Further, every change in the table adds at least one state to A. Therefore, the procedure is guaranteed
to terminate successfully with a minimal DFA A for L.

The correctness of the Lâˆ— algorithm follows from the fact that regular languages have a canonical
form, which guarantees a single minimal DFA for a regular language L. To enable an Lâˆ—-based
algorithm for NFHâˆ€ and NFHâˆƒ, we ï¬rst deï¬ne canonical forms for these fragments.

6.2 Canonical Forms for the Alternation-Free Fragments

We begin with the basic terms on which our canonical forms are based.

(cid:73) Deï¬nition 15. 1. An NFHâˆ€ Aâˆ€ is sequence complete if for every word w, it holds that Ë†Aâˆ€

accepts w iff it accepts every sequence of w.

2. An NFHâˆƒ Aâˆƒ is permutation complete if for every word w, it holds that Ë†Aâˆƒ accepts w iff it accepts

every permutation of w.

An NFHâˆ€ Aâˆ€ accepts a hyperword S iff Ë†Aâˆ€ accepts every sequence of size k of S. If some
sequence is missing from L( Ë†A), then removing the rest of the sequences of S from L( Ë†Aâˆ€) does not
affect the non-acceptance of S. Therefore, the underlying automata of sequence-complete NFHâˆ€ only
accept necessary sequences. Similarly, an NFHâˆƒ Aâˆƒ accepts a hyperword S iff Ë†Aâˆƒ accepts some
permutation p of size k of words in S. Adding the rest of the permutations of p to L( Ë†Aâˆƒ) does not
affect the acceptance of S. Therefore, the underlying automata of permutation-complete NFHâˆƒ only
reject the necessary permutations of every hyperword. As a conclusion, we have the following.

(cid:73) Lemma 16. 1. Let Aâˆ€ be an NFHâˆ€, and let A0
such that for every word w, the underlying NFA Ë†A0
Then L(Aâˆ€) = L(A0

âˆ€).

âˆ€ be a sequence-complete NFHâˆ€ over Î£ and X
âˆ€ accepts w iff Ë†Aâˆ€ accepts every sequence of w.

2. Let Aâˆƒ be an NFHâˆƒ, and let A0

every word w, the underlying NFA Ë†Aâˆƒ accepts w iff Ë†A0
L(Aâˆƒ) = L(A0

âˆƒ).

âˆƒ be a permutation-complete NFHâˆƒ over Î£ and X such that for
âˆƒ accepts all permutations of w. Then

B. Bonakdarpour and S. Sheinvald

XX:11

Next, we show that we can construct a sequence- or permutation-complete NFH for a given NFHâˆ€
or NFHâˆƒ, respectively. Intuitively, given A, for every sequence (permutation) Î¶ of (1, . . . k), we
construct an NFA that runs on wÎ¶ in the same way that Ë†A runs on w, for every w. The underlying NFA
we construct for the NFHâˆ€ and NFHâˆƒ are the intersection and union, respectively, of all these NFA.

(cid:73) Lemma 17. Every NFHâˆ€ (NFHâˆƒ) A has an equivalent sequence-complete (permutation-complete)
NFHâˆ€ (NFHâˆƒ) A0 over the same set of variables.

Finally, as the following theorem shows, sequence- and permutation- complete NFH offer a

uniï¬ed model for the alternation-free fragments.

(cid:73) Theorem 18. Let A1 and A2 be two sequence-complete (permutation-complete) NFHâˆ€ (NFHâˆƒ)
over the same set of variables. Then L(A1) = L(A2) iff L( Ë†A1) = L( Ë†A2).

Regular languages have a canonical form, which are minimal DFA. We use this property to deï¬ne
canonical forms for NFHâˆ€ and NFHâˆƒ as sequence-complete (permutation-complete) NFHâˆ€ (NFHâˆƒ)
with a minimal number of variables and a minimal underlying DFA.

6.3 Learning NFHâˆ€ and NFHâˆƒ

We now describe our Lâˆ—-based learning algorithms for NFHâˆƒ and NFHâˆ€. These algorithms aim to
learn an NFH with the canonical form deï¬ned in Section 6.2 for a target hyperlanguage L. Figure 4
presents the overall ï¬‚ow of the learning algorithms for both fragments.

In the case of hyperautomata, the membership queries and the counterexamples provided by
the teacher consist of hyperwords. Similarly to [8], we assume a teacher that returns a minimal
counterexample in terms of size of the hyperword.

During the procedure, the learner maintains an NFH A via an observation table for Ë†A, over
the alphabet Ë†Î£ = (Î£ âˆª {#})k, where k is initially set to 1. When the number of variables is
increased to k0 > k, the alphabet of Ë†A is extended accordingly to (Î£ âˆª {#})k0
. To this end, we
deï¬ne a function â†‘k0
, which replaces every letter (Ïƒ1, . . . Ïƒk), with
(Ïƒ1, . . . Ïƒk) + (Ïƒk)k0âˆ’k. That is, the last letter is duplicated to create a k0-tuple. We extend â†‘k0
k
to words: â†‘k0
k (Ïƒ). Notice that, for both
fragments, if unzip(d Â· e) âˆˆ L(A), then unzip(â†‘k0
k (d Â· e)) âˆˆ L(A). Accordingly, when the number
of variables is increased, every word w in the rows and columns of T is replaced with â†‘k0
k (w), an
action which we denote by â†‘k0

k (w) is obtained by replacing every letter Ïƒ in w with â†‘k0

k : (Î£ âˆª {#})k â†’ (Î£ âˆª {#})k0

k (T ).

6.3.1 Learning NFHâˆ€

In the case of NFHâˆ€, when the teacher returns a counterexample S, it holds that if |S| > k, then
S must be positive. Indeed, assume by way of contradiction that S is negative. Then, for every k
words w1, . . . , wk in S, it holds that zip(w1, . . . , wk) âˆˆ L( Ë†A), but S /âˆˆ L. Therefore, in an NFHâˆ€
A0 for L, there exists some word of the form w = zip(w1, . . . wk) such that wi âˆˆ S for 1 â‰¤ i â‰¤ k,
and w /âˆˆ L( Ë†A0). As a result, {w1, . . . , wk} /âˆˆ L. Since zip(w1, . . . , wk) and all its sequences are in
L( Ë†A), then a smaller counterexample is {w1, . . . , wk}, a contradiction to the minimality of S.

In fact, if |S| > k, then it must be that |S| = k + 1. Indeed, since S is a positive counterexample,
and A accepts all representations of subsets of size k of S (otherwise the teacher would return a
counterexample of size k), then there exists a subset S0 âŠ† S of size k + 1 that should be represented,
but is not. Therefore, S0 is a counterexample of size k + 1.

When a counterexample S of size k + 1 is returned, the learner updates k â† k + 1, updates T to
â†‘k+1
(T ), arbitrarily selects a permutation p of the words in S, and adds zip(p) and all its sufï¬xes to
k
E. In addition, it updates D Â· Ë†Î£ in accordance with the new updated Ë†Î£, and ï¬lls in the missing entries.

XX:12 Automata for Hyperlanguages

When |S| â‰¤ k, then the counterexample is either positive or negative. If S is positive, then there
exists some permutation p of the words in S such that A does not accept zip(p) (a permutation and not
a proper sequence, or there would be a smaller counterexample). The learner ï¬nds such a permutation
p, and adds zip(p) and all its sufï¬xes to E. Notice that zip(p) does not already appear in T , since a
membership query would have returned â€œyesâ€, and so Ë†A would have accepted zip(p).

if S is negative, then A accepts all sequences of length k of words in S, though it should not.
Then there exists a permutation p of the words in S that does not appear in T , and which A accepts.
The learner then ï¬nds such a permutation p and adds zip(p) and all its sufï¬xes to E.

If p is a permutation of the words in S, and S is a negative counterexample, then zip(p) should
not be in L( Ë†A) due to any other hyperword, and if S is a positive counterexample, then it should be
in L( Ë†A) for every S0 such that S âŠ† S0. Therefore, the above actions by the learner are valid.

When an equivalence query succeeds, then A is indeed an NFHâˆ€ for L. However, A is not
necessarily sequence-complete, as Ë†A may accept a word w = zip(w1, . . . , wk) but not all of its
sequences. This check can be performed by the learner directly on Ë†A. Notice that w does not
occur in T , since a membership query on w would return â€œnoâ€. Once it is veriï¬ed that A is not
sequence-complete, the counterexample w (and all its sufï¬xes) are added to E, and the procedure
returns to the learning loop.

As we have explained above, variables are added only when necessary, and so the output A is
indeed an NFH for L with minimally many variables. The correctness of Lâˆ— and the minimality of
the counterexamples returned by the teacher guarantee that for each k0 â‰¤ k, the run learns a minimal
deterministic Ë†A for hyperwords in L that are represented by k0 variables. Therefore, a smaller Ë†A0
for L does not exist, as restricting Ë†A0 to the ï¬rst k0 letters in each k-tuple would produce a smaller
underlying automaton for k0 variables, a contradiction.

Figure 3 The ï¬rst stages of learning L(A3) of Figure 1.

(cid:73) Example 19. Figure 3 displays the ï¬rst two stages of learning L(A3) of Figure 2. T0 displays
the initial table, with D = E = {(cid:15)}, and Ë†Î£ = {a, b, #}. since {a}, {b}, and {(cid:15)} are all in L(A3),
the initial candidate NFH A includes a single variable, and, following the answers to the membership
queries, a single accepting state.

Since L(A3) includes all hyperwords of size 1, which are now accepted by A, the smallest
counterexample the teacher returns is of size 2, which, in the example, is {a, b}. Table T1 is
1, updating the alphabet Ë†Î£ to {a, b, #}2, and updating D Â· Ë†Î£
then obtained from T0 by applying â†‘2
accordingly. T1 is ï¬lled by submitting membership queries. For example, for (b, a) âˆˆ D Â· Ë†Î£ and
(a, b) âˆˆ E, the learner submits a membership query for {ba, ab}, to which the teacher answers â€œnoâ€.

6.3.2 Learning NFHâˆƒ

The learning process for NFHâˆƒ is similar to the one for NFHâˆ€. We brieï¬‚y describe the differences.

ğœ–ğ‘‡01ğœ–1(ğ‘)1(ğ‘)1(#)1(2)(3)(ğ‘,ğ‘)ğœ–ğ‘‡111ğœ–11(ğ‘,ğ‘)11(ğ‘,ğ‘)11(ğ‘,ğ‘)01(ğ‘,#)(ğ‘,ğ‘)ğœ–ğ‘‡1(ğ‘ğ‘œğ‘›ğ‘¡.)01(ğ‘,ğ‘)01(ğ‘,#)01(#,ğ‘)01(#,ğ‘)01(#,#)(ğ‘,ğ‘)ğœ–ğ‘‡111ğœ–11(ğ‘,ğ‘)11(ğ‘,ğ‘)11(ğ‘,ğ‘)01(ğ‘,#)01(ğ‘,ğ‘)01(ğ‘,#)01(#,ğ‘)01(#,ğ‘)01(#,#)B. Bonakdarpour and S. Sheinvald

XX:13

no: membership queries

w

x

e

c

d

d

a

o :

n

permutation/sequence
complete?

yes: A

yes

T closed
and consistent?

yes

construct A

A

equivalent?

add S

T â†â†‘k0

k (T )

no:addcexS

yes

no: cex S

|S| > k?

Figure 4 The learning process ï¬‚ow for NFHâˆ€ and NFHâˆƒ.

As in NFHâˆ€, relying on the minimality of the counterexamples returned by the teacher guarantees
that when a counterexample S such that |S| > k is returned, it is a positive counterexample. Indeed,
assume by way of contradiction that S is a negative counterexample of size k0. Since Ë†A accepts S,
there exists a word zip(w1, . . . , wk) in L( Ë†A) such that {w1, . . . , wk} âˆˆ S. According to the semantics
of âˆƒ, if zip(w1, w2, . . . , wk) âˆˆ L( Ë†A) then S âˆˆ L(A). Since S /âˆˆ L, we have that {w1, . . . , wk} is a
smaller counterexample, a contradiction.

Therefore, when the teacher returns a counterexample S of size k0 > k, the alphabet Ë†Î£ is extended

to (Î£ âˆª {#})k0

, and the table T is updated by â†‘k0

k , as is done for NFHâˆ€.

If |S| â‰¤ k, then S may be either positive or negative. If S is negative, then there exists some
permutation of S that is accepted by Ë†A. However, no such permutation is in T , as a membership
query would have returned â€œnoâ€. Similarly, if S is positive, then there exists no permutation of S that
Ë†A accepts. In both cases, the learner chooses a permutation of S and adds it, and all its sufï¬xes, to E.
As in the case of NFHâˆ€, the success of an equivalence query does not necessarily imply that
A is permutation-complete. If A is not permutation-complete, the learner ï¬nds a word w that is a
permutation of w0 such that w0 âˆˆ L( Ë†A) but w /âˆˆ L( Ë†A), and adds w as a counterexample to E. The
procedure then returns to the learning loop.

7 Conclusion and Future Work

We have introduced and studied hyperautomata and hyperlanguages, focusing on the basic model
of regular hyperlanguages, in which the underlying automaton is a standard NFA. We have shown
that regular hyperlanguages are closed under set operations (complementation, intersection, and
union) and are capable of expressing important hyperproperties for information-ï¬‚ow security policies
over ï¬nite traces. We have also investigated fundamental decision procedures such as checking
nonemptiness and membership. We have shown that their regular properties allow the learnability of
the alternation-free fragments. Fragments that combine the two types of quantiï¬ers prove to be more
challenging, and we leave their learnability to future work.

The notion of hyperlanguages, as well as the model of hyperautomata, can be lifted to handle
hyperwords that consist of inï¬nite words: instead of an underlying ï¬nite automaton, we can use any
model that accepts inï¬nite words. In fact, we believe using an underlying alternating BÃ¼chi automaton,
such hyperautomata can express the entire logic of HyperLTL [6], using the standard Vardi-Wolper
construction for LTL [15] as basis. Our complexity results for the various decision procedures for
NFH, combined with the complexity results shown in [9], suggest that using hyperautomata would be
optimal, complexity-wise, for handling HyperLTL.

Further future directions include studying non-regular hyperlanguages (e.g., context-free), and
object hyperlanguages (e.g., trees). Other open problems include a full investigation of the complexity
of decision procedures for alternating fragments of NFH.

XX:14 Automata for Hyperlanguages

References

B. Alpern and F. B. Schneider. Deï¬ning liveness. Information Processing Letters, 21:181â€“185, 1985.
1
2 Dana Angluin. Learning regular sets from queries and counterexamples. Infornation and Computation,

3

4

75(2):87â€“106, 1987.
B. Bonakdarpour and B. Finkbeiner. The complexity of monitoring hyperproperties. In Proceedings of
the 31st IEEE Computer Security Foundations Symposium CSF, pages 162â€“174, 2018.
B. Bonakdarpour, C. SÃ¡nchez, and G. Schneider. Monitoring hyperproperties by combining static
analysis and runtime veriï¬cation. In Proceedings of the 8th Leveraging Applications of Formal Methods,
Veriï¬cation and Validation (ISoLA), pages 8â€“27, 2018.

5 G. Boudol and I. Castellani. Noninterference for concurrent programs and thread systems. Theoretical

Computer Science (TCS), 281(1-2):109â€“130, 2002.

6 M. R. Clarkson, B. Finkbeiner, M. Koleini, K. K. Micinski, M. N. Rabe, and C. SÃ¡nchez. Temporal logics
for hyperproperties. In Proceedings of the 3rd Conference on Principles of Security and Trust POST,
pages 265â€“284, 2014.

7 M. R. Clarkson and F. B. Schneider. Hyperproperties. Journal of Computer Security, 18(6):1157â€“1210,

8

9

10

11

2010.
B. Finkbeiner, L. Haas, and H. Torfah. Canonical representations of k-safety hyperproperties.
Proceedings of the 32nd IEEE Computer Security Foundations Symposium (CSF), pages 17â€“31, 2019.
B. Finkbeiner and C. Hahn. Deciding hyperproperties. In Proceedings of the 27th International Conference
on Concurrency Theory (CONCUR), pages 13:1â€“13:14, 2016.
B. Finkbeiner, M. N. Rabe, and C. SÃ¡nchez. Algorithms for model checking HyperLTL and HyperCTL*.
In Proceedings of the 27th International Conference on Computer Aided Veriï¬cation (CAV), pages 30â€“48,
2015.
J. A. Goguen and J. Meseguer. Security policies and security models. In IEEE Symp. on Security and
Privacy, pages 11â€“20, 1982.

In

12 D. McCullough. Noninterference and the composability of security properties. In Proceedings of the

13

1988 IEEE Symposium on Security and Privacy, pages 177â€“186, 1988.
A. Sabelfeld and D. Sands. Probabilistic noninterference for multi-threaded programs. In Proceedings of
the 13th IEEE Computer Security Foundations Workshop (CSFW), pages 200â€“214, 2000.

14 M.Y. Vardi and P. Wolper. Automata theoretic techniques for modal logic of programs. Journal of

Computer and System Sciences, 32:183â€“221, 1986.

15 M.Y. Vardi and P. Wolper. Reasoning about inï¬nite computations.

Information and Computation,

115(1):1â€“37, 1994.

16 Y. Wang, M. Zarei, B. Bonakdarpour, and M. Pajic. Statistical veriï¬cation of hyperproperties for cyber-
physical systems. ACM Transactions on Embedded Computing systems (TECS), 18(5s):92:1â€“92:23,
2019.
S. Zdancewic and A. C. Myers. Observational determinism for concurrent program security. In Proceed-
ings of the 16th IEEE Computer Security Foundations Workshop (CSFW), page 29, 2003.

17

B. Bonakdarpour and S. Sheinvald

XX:15

Appendix

A Proofs

Theorem 8

Proof. Complementation. Let A be an NFH. The NFA Ë†A can be complemented with respect to its
language over Ë†Î£ to an NFA Ë†A. Then for every assignment v : X â†’ S, it holds that Ë†A accepts zip(v)
iff Ë†A does not accept zip(v). Let Î± be the quantiï¬cation condition obtained from Î± by replacing every
âˆƒ with âˆ€ and vice versa. We can prove by induction on Î± that A, the NFH whose underlying NFA is
Ë†A, and whose quantiï¬cation condition is Î±, accepts L(A). The size of A is exponential in |Q|, due to
the complementation construction for Ë†A.

Now, let A1 = hÎ£, X, Q, Q0, Î´1, F1, Î±1i and A2 = hÎ£, Y, P, P0, Î´2, F2, Î±2i be two NFH with

|X| = k and |Y | = k0 variables, respectively.

Union. We construct an NFH Aâˆª = hÎ£, X âˆª Y, Q âˆª P âˆª {p1, p2}, Q0 âˆª P0, Î´, F1 âˆª F2 âˆª {p1, p2}, Î±i,
where Î± = Î±1Î±2 (that is, we concatenate the two quantiï¬cation conditions), and where Î´ is deï¬ned
as follows.

For every

we set

for every t âˆˆ (Î£ âˆª {#})k0
For every

.

we set

for every t âˆˆ (Î£ âˆª {#})k.
For every q âˆˆ F1, we set

and

for every t âˆˆ (Î£ âˆª {#})k0
For every q âˆˆ F2, we set

.

and

for every t âˆˆ (Î£ âˆª {#})k.

(q1

(Ïƒ1,...,Ïƒk)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ q2) âˆˆ Î´1

(q1

(Ïƒ1,...,Ïƒk)+t
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ q2) âˆˆ Î´

(q1

(Ïƒ1,...,Ïƒk0 )
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ q2) âˆˆ Î´2

(q1

t+(Ïƒ1,...,Ïƒk0 )
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ q2) âˆˆ Î´

(#)k+t
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p1) âˆˆ Î´

(q

(#)k+t
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p1) âˆˆ Î´

(p1

t+(#)k0
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p2) âˆˆ Î´

(q

t+(#)k0
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p2) âˆˆ Î´

(p2

XX:16 Automata for Hyperlanguages

Let S be a hyperword. For every v : (X âˆª Y ) â†’ S, it holds that if zip(v|X ) âˆˆ L( Ë†A1), then
zip(v) âˆˆ L( Ë†Aâˆª). Indeed, according to our construction, every word assigned to the Y variables is
accepted in the A1 component of the construction, and so it satisï¬es both types of quantiï¬ers. A
similar argument holds for v|Y and A2.

Also, according to our construction, for every v : (X âˆª Y ) â†’ S, if zip(v) âˆˆ L( Ë†Aâˆª), then either
zip(v|X ) âˆˆ L( Ë†A1), or zip(v|Y ) âˆˆ L( Ë†A2). As a conclusion, we have that L(Aâˆª) = L(A1) âˆª L(A2).
The state space of Aâˆª is linear in the state spaces of A1, A2. However, the size of the alphabet
of Aâˆª may be exponentially larger than that of A1 and A2, since we augment each letter with all
sequences of size k0 (in A1) and k (in A2).

Intersection. The proof follows the closure under union and complementation. However, we also
offer a direct translation, which avoids the need to complement. We construct an NFH Aâˆ© =
hÎ£, X âˆª Y, (Q âˆª {q} Ã— P âˆª {p}), (Q0 Ã— P0), Î´, (F1 âˆª {q}) Ã— (F2 âˆª {p}), Î±1Î±2i, where Î´ is deï¬ned
as follows.

For every (q1

(Ïƒ1,...,Ïƒk)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ q2) âˆˆ Î´1 and every (p1

1,...,Ïƒ0

(Ïƒ0
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p2) âˆˆ Î´2, we have

k0 )

(cid:16)

(q1, p1)

(Ïƒ1...,Ïƒk,Ïƒ0
1,...Ïƒ0
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q2, p2)

k0 )

(cid:17)

âˆˆ Î´

For every q1 âˆˆ F1, (p1

1,...,Ïƒ0

(Ïƒ0
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p2) âˆˆ Î´2 we have

k0 )

(cid:16)

(q1, p1)

(#)k+(Ïƒ0
1,...Ïƒ0
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q, p2)

k0 )

(cid:17)

(cid:16)

,

(q, p1)

(#)k+(Ïƒ0
1,...,Ïƒ0
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q, p2)

k0 )

(cid:17)

âˆˆ Î´

For every (q1

(Ïƒ1,...,Ïƒk)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ q2) âˆˆ Î´1 and p1 âˆˆ F2, we have

(cid:16)

(q1, p1)

(Ïƒ1,...,Ïƒk)+(#)k0
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q2, p)

(cid:17)

,

(cid:16)

(q1, p)

k)+(#)k0
(Ïƒ1,...,Ïƒ0
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q2, p)

(cid:17)

âˆˆ Î´

Intuitively, the role of q, p is to keep reading (#)k and (#)k0
respectively, has ended.

after the word read by Ë†A1 or Ë†A2,

The NFH Ë†Aâˆ© simultaneously reads two words zip(w1, w2, . . . , wk) and zip(w0

k0) that
are read along Ë†A1 and Ë†A2, respectively, and accepts iff both words are accepted. The correctness
follows from the fact that for v : (X âˆª Y ) â†’ S, we have that zip(v) is accepted by Ë†A iff zip(v|X )
and zip(v|Y ) are accepted by Ë†A1 and Ë†A2, respectively.

2, . . . w0

1, w0

This construction is polynomial in the sizes of A1 and A2.

(cid:74)

Theorem 9

Proof. We mimic the proof idea in [9], which uses a reduction from the Post correspondence problem
(PCP). A PCP instance is a collection C of dominoes of the form:

(

h u1
v1

i

,

h u2
v2

i
, . . . ,

h uk
vk

)
i

where for all i âˆˆ [1, k], we have vi, ui âˆˆ {a, b}âˆ—. The problem is to decide whether there exists a
ï¬nite sequence of the dominoes of the form
h ui1
vi1

ih ui2
vi2

h uim
vim

Â· Â· Â·

i

i

where each index ij âˆˆ [1, k], such that the upper and lower ï¬nite strings of the dominoes are equal,
i.e.,

ui1ui2 Â· Â· Â· uim = vi1vi2 Â· Â· Â· vim

B. Bonakdarpour and S. Sheinvald

XX:17

For example, if the set of dominoes is

Cexmp =

(

h ab
b

i

,

i

,

h ba
a

h a
aba

)

i

Then, a possible solution is the following sequence of dominoes from Cexmp:

sol =

h a
aba

ih ba
a

ih ab
b

i
.

Given an instance C of PCP, we encode a solution as a word wsol over the following alphabet:

o
n Ïƒ
Ïƒ0 | Ïƒ, Ïƒ0 âˆˆ {a, b, Ë™a, Ë™b, $}
.
Intuitively, Ë™Ïƒ marks the beginning of a new domino, and $ marks the end of a sequence of the upper
or lower parts of the dominoes sequence.

Î£ =

We note that wsol encodes a legal solution iff the following conditions are met:

1. For every Ïƒ

Ïƒ0 that occurs in wsol, it holds that Ïƒ, Ïƒ0 represent the same domino letter (both a or

both b, either dotted or undotted).

2. The number of dotted letters in the upper part of wsol is equal to the number of dotted letters in

the lower part of wsol.

3. wsol starts with two dotted letters, and the word ui between the iâ€™th and i + 1â€™th dotted letters in
the upper part of wsol, and the word vi between the corresponding dotted letters in the lower part
of wsol are such that [ ui
vi

] âˆˆ C, for every i.

We call a word that represents the removal of the ï¬rst k dominoes from wsol a partial solution,
denoted by wsol,k. Note that the upper and lower parts of wsol,k are not necessarily of equal lengths
(in terms of a and b sequences), since the upper and lower parts of a domino may be of different
lengths, and so we use letter $ to pad the end of the encoding in the shorter of the two parts.

We construct an NFH A, which, intuitively, expresses the following ideas: (1) There exists an
encoding wsol of a solution to C, and (2) For every wsol,k 6= (cid:15) in a hyperword S accepted by A, the
word wsol,k+1 is also in S.

L(A) is then the set of all hyperwords that contain an encoded solution wsol, as well as all its
sufï¬xes obtained by removing a preï¬x of dominoes from wsol. This ensures that wsol indeed encodes
a legal solution. For example, a matching hyperword S (for solution sol discussed earlier) that is
accepted by A is:

S = {wsol =

Ë™b
b

Ë™a
Ë™a

a
a

Ë™a
Ë™a

b
Ë™b

, wsol,1 =

Ë™b
Ë™a

a
Ë™b

Ë™a
$

b
$

, wsol,2 =

Ë™a
Ë™b

b
$

, wsol,3 = (cid:15)}

Thus, the acceptance condition of A is Î± = âˆ€x1âˆƒx2âˆƒx3, where x1 is to be assigned a potential

partial solution wsol,k, and x2 is to be assigned wsol,k+1, and x3 is to be assigned wsol.

During a run on a hyperword S and an assignment v : {x1, x2, x3} â†’ S, the NFH A checks that
the upper and lower letters of wsol all match. In addition, A checks that the ï¬rst domino of v(x1) is
indeed in C, and that v(x2) is obtained from v(x1) by removing the ï¬rst tile. A performs the latter
task by checking that the upper and lower parts of v(x2) are the upper and lower parts of v(x1) that
have been â€œshiftedâ€ back appropriately. That is, if the ï¬rst tile in v(x2) is the encoding of [ wi
], then
vi
A uses states to remember, at each point, the last |wi| letters of the upper part of v(x2) and the last
|vi| letters of the lower part of v(x2), and veriï¬es, at each point, that the next letter in v(x1) matches
(cid:74)
the matching letter remembered by the state.

XX:18 Automata for Hyperlanguages

Theorem 10

Proof. The lower bound for both fragments follows from the NL-hardness of the nonemptiness
problem for NFA.

We turn to the upper bound, and begin with NFHâˆƒ. Let Aâˆƒ be an NFHâˆƒ. We claim that Aâˆƒ is
nonempty iff Ë†Aâˆƒ accepts some legal word w. The ï¬rst direction is trivial. For the second direction, let
w âˆˆ L( Ë†Aâˆƒ), and let S = unzip(w). By assigning v(xi) = w[i] for every xi âˆˆ X, we get zip(v) = w,
and according to the semantics of âˆƒ, we have that Aâˆƒ accepts S. To check whether Ë†Aâˆƒ accepts a
legal word, we can run a reachability check on-the-ï¬‚y, while advancing from a letter Ïƒ to the next
letter Ïƒ0 only if Ïƒ0 contains # in all the positions in which Ïƒ contains #. While each transition
(Ïƒ1,...Ïƒn)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ p in Ë†A is of size k, we can encode T as a set of size k of encodings of transitions of
T = q
type q Ïƒiâˆ’â†’ p with a binary encoding of p, q, Ïƒi, as well as i, t, where t marks the index of T within
the set of transitions of Ë†A. Therefore, the reachability test can be performed within space that is
logarithmic in the size of Aâˆƒ.

Now, let Aâˆ€ be an NFHâˆ€ over X. We claim that Aâˆ€ is nonempty iff Aâˆ€ accepts a hyperword of
size 1. For the ï¬rst direction, let S âˆˆ L(Aâˆ€). Then, by the semantics of âˆ€, we have that for every
assignment v : X â†’ S, it holds that zip(v) âˆˆ L( Ë†Aâˆ€). Let u âˆˆ S, and let vu(xi) = u for every
xi âˆˆ X. Then, in particular, zip(vu) âˆˆ L( Ë†Aâˆ€). Then for every assignment v : X â†’ {u} (which
consists of the single assignment vu), it holds that Ë†Aâˆ€ accepts zip(v), and therefore Aâˆ€ accepts {u}.
The second direction is trivial.

To check whether Aâˆ€ accepts a hyperword of size 1, we restrict the reachability test on Ë†Aâˆ€ to
(cid:74)

k-tuples of the form (Ïƒ, Ïƒ, . . . Ïƒ) for Ïƒ âˆˆ Î£.

Theorem 11

Proof. We begin with the upper bound. Let S âˆˆ L(A). Then, according to the semantics of
the quantiï¬ers, there exist w1, . . . wm âˆˆ S, such that for every assignment v : X â†’ S in which
v(xi) = wi for every 1 â‰¤ i â‰¤ m, it holds that Ë†A accepts zip(v). Let v : X â†’ S be such an
assignment. Then, Ë†A accepts zip(vÎ¶) for every sequence Î¶ of the form (1, 2, . . . m, i1, i2, . . . ikâˆ’m).
In particular, it holds for such sequences in which 1 â‰¤ ij â‰¤ m for every 1 â‰¤ j â‰¤ k âˆ’ m, that
is, sequences in which the last k âˆ’ m variables are assigned words that are assigned to the ï¬rst m
variables. Therefore, again by the semantics of the quantiï¬ers, we have that {v(x1), . . . v(xm)} is in
L(A). The second direction is trivial.

(Ïƒi1 ,Ïƒi2 ,...Ïƒik )
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ q0 in Î´, we have q

We call zip(vÎ¶) as described above a witness to the nonemptiness of A, i.e., zip(vÎ¶) is an instan-
tiation of the existential quantiï¬ers. We construct an NFA A based on Ë†A that is nonempty iff Ë†A
accepts a witness to the nonemptiness of A. Let Î“ be the set of all sequences of the above form. For
every sequence Î¶ = (i1, i2, . . . ik) in Î“, we construct an NFA AÎ¶ = h Ë†Î£, Q, Q0, Î´Î¶, F i, where for
(Ïƒ1,Ïƒ2,...Ïƒk)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ q0 in Î´Î¶. Intuitively, AÎ¶ runs on every word
every q
w the same way that Ë†A runs on wÎ¶. Therefore, Ë†A accepts a witness w to the nonemptiness of A iff
w âˆˆ L(AÎ¶) for every Î¶ âˆˆ Î“.
We deï¬ne A = T

Î¶âˆˆÎ“ AÎ¶. Then Ë†A accepts a witness to the nonemptiness of A iff A is nonempty.
Since |Î“| = mkâˆ’m, the state space of A is of size O(nmkâˆ’m
), where n = |Q|, and its alphabet is of
size | Ë†Î£|. Notice that for A to be nonempty, Î´ must be of size at least |(Î£ âˆª #)|(kâˆ’m), to account for
all the permutations of letters in the words assigned to the variables under âˆ€ quantiï¬ers (otherwise,
we can immediately return â€œemptyâ€). Therefore, | Ë†A| is O(n Â· |Î£|k). We then have that the size of A
is O(| Ë†A|k). If the number k âˆ’ m of âˆ€ quantiï¬ers is ï¬xed, then mkâˆ’m is polynomial in k. However,
now | Ë†A| may be polynomial in n, k, and |Î£|, and so in this case as well, the size of A is O(| Ë†A|k).

Since the nonemptiness problem for NFA is NL-complete, the problem for NFHâˆƒâˆ€ can be decided

B. Bonakdarpour and S. Sheinvald

XX:19

in space of size that is polynomial in | Ë†A|.

PSPACE hardness For the lower bound, we show a reduction from a polynomial version of the
corridor tiling problem, deï¬ned as follows. We are given a ï¬nite set T of tiles, two relations
V âŠ† T Ã— T and H âŠ† T Ã— T , an initial tile t0, a ï¬nal tile tf , and a bound n > 0. We have to decide
whether there is some m > 0 and a tiling of a n Ã— m-grid such that (1) The tile t0 is in the bottom left
corner and the tile tf is in the top right corner, (2) A horizontal condition: every pair of horizontal
neighbors is in H, and (3) A vertical condition: every pair of vertical neighbors is in V . When n is
given in unary notation, the problem is known to be PSPACE-complete.

Given an instance C of the tiling problem, we construct an NFHâˆƒâˆ€ A that is nonempty iff C has a
solution. We encode a solution to C as a word wsol = w1 Â· w2 Â· wm$ over Î£ = T âˆª {1, 2, . . . n, $},
where the word wi, of the form 1 Â· t1,i Â· 2 Â· t2,i, . . . n Â· tn,i, describes the contents of row i.

To check that wsol indeed encodes a solution, we need to make sure that:

1. w1 begins with t0 and wm ends with tf $.
2. wi is of the correct form.
3. Within every wi, it holds that (tj,i, tj+1,i) âˆˆ H.
4. For wi, wi+1, it holds that (tj,i, tj,i+1) âˆˆ V for every 1 â‰¤ j â‰¤ n.

Verifying items 1 âˆ’ 3 is easy via an NFA of size O(n|H|). The main obstacle is item 4.
We describe an NFHâˆƒâˆ€ A = hT âˆª {0, 1, 2, . . . n, $}, {y1, y2, y3, x1, . . . xlog(n)}, Q, {q0}, Î´, F, Î±i
that is nonempty iff there exists a word that satisï¬es items 1 âˆ’ 4. The quantiï¬cation condition Î± is
âˆƒy1âˆƒy2âˆƒy3âˆ€x1 . . . âˆ€xlog(n). The NFH A only proceeds on letters whose ï¬rst three positions are of
the type (r, 0, 1), where r âˆˆ T âˆª {1, . . . n, $}. Notice that this means that A requires the existence
of the words 0|wsol| and 1|wsol| (the 0 word and 1 word, henceforth). A makes sure that the word
assigned to y1 matches a correct solution w.r.t. items 1 âˆ’ 3 described above. We proceed to describe
how to handle the requirement for V . We need to make sure that for every position j in a row, the tile
in position j in the next row matches the current one w.r.t. V . We can use a state qj to remember
the tile in position j, and compare it to the tile in the next occurrence of j. The problem is avoiding
having to check all positions simultaneously, which would require exponentially many states. To this
end, we use log(n) copies of the 0 and 1 words to form a binary encoding of the position j that is to
be remembered. The log(n) âˆ€ conditions make sure that every position within 1 âˆ’ n is checked.

We limit the checks to words in which x1, . . . xlog(n) are the 0 or 1 words, by having Ë†A accept
every word in which there is a letter that is not over 0, 1 in positions 4, . . . log(n) + 3. This takes care
of accepting all cases in which the word assigned to y1 is also assigned to one of the x variables.

To check that x1, . . . xlog(n) are the 0 or 1 words, Ë†A checks that the values in positions 4 to
log(n) + 3 remain constant throughout the run. In these cases, upon reading the ï¬rst letter, Ë†A
remembers the value j that is encoded by the constant assignments to x1, . . . xlog(n) in a state, and
makes sure that throughout the run, the tile that occurs in the assignment y1 in position j in the current
row matches the tile in position j in the next row.

We construct a similar reduction for the case that the number of âˆ€ quantiï¬ers is ï¬xed: instead
of encoding the position by log(n) bits, we can directly specify the position by a word of the
form jâˆ—, for every 1 â‰¤ j â‰¤ n. Accordingly, we construct an NFHâˆƒâˆ€ over {x, y1, . . . yn, z}, with
a quantiï¬cation condition Î± = âˆƒxâˆƒy1 . . . âˆƒynâˆ€z. The NFA Ë†A advances only on letters whose
assignments to y1, . . . yn are always 1, 2, . . . n, respectively, and checks only words assigned to z
that are some constant 1 â‰¤ j â‰¤ n. Notice that the ï¬xed assignments to the y variables leads to Î´
of polynomial size. In a hyperword accepted by A, the word assigned to x is wsol, and the word
(cid:74)
assigned to z speciï¬es which index should be checked for conforming to V .

XX:20 Automata for Hyperlanguages

Theorem 12

Proof. We can decide the membership of S in L(A) by iterating over all relevant assignments from
X to S, and for every such assignment v, checking on-the-ï¬‚y whether zip(v) is accepted by Ë†A. This
algorithm uses space of size that is polynomial in k and logarithmic in |A| and in |S|.

In the case that k0 = O(log k), an NP upper bound is met by iterating over all assignments to the
variables under âˆ€, while guessing assignments to the variables under âˆƒ. For each such assignment v,
checking whether zip(v) âˆˆ L( Ë†A) can be done on-the-ï¬‚y.

We show NP-hardness for this case by a reduction from the Hamiltonian cycle problem. Given a
graph G = hV, Ei where V = {v1, v2, . . . , vn} and |E| = m, we construct an NFHâˆƒ A over {0, 1}
with n states, n variables, Î´ of size m, and a hyperword S of size n, as follows. S = {w1, . . . , wn},
where wi is the word over {0, 1} in which all letters are 0 except for the iâ€™th. The structure of Ë†A is
identical to that of G, and we set Q0 = F = {v1}. For the transition relation, for every (vi, vj) âˆˆ E,
we have (vi, Ïƒi, vj) âˆˆ Î´, where Ïƒi is the letter over {0, 1}n in which all positions are 0 except for
position i. Intuitively, the iâ€™th letter in an accepting run of Ë†A marks traversing vi. Assigning wj to xi
means that the jâ€™th step of the run traverses vi. Since the words in w make sure that every v âˆˆ V is
traversed exactly once, and that the run on them is of length n, we have that A accepts S iff there
exists some permutation p of the words in S such that p matches a Hamiltonian cycle in G.
remark To account for all the assignments to the âˆ€ variables, Î´ â€“ and therefore, Ë†A â€“ must be of size
at least 2k0
(otherwise, we can return â€œnoâ€). We then have that if k = O(k0), then space of size k
is logarithmic in | Ë†A|, and so the problem in this case can be solved within logarithmic space. A
(cid:74)
matching NL lower bound follows from the membership problem for NFA.

Theorem 13

Proof. Let A = hÎ£, P, P0, Ï, F i be an NFA, and let A = hÎ£, {x1, . . . , xk}, Q, Q0, Î´, F, Î±i be an
NFH.

First, we construct an NFA A0 = hÎ£ âˆª {#}, P 0, P 0

0, Ï0, F 0i by extending the alphabet of A to
Î£ âˆª {#}, adding a new and accepting state pf to P with a self-loop labeled by #, and transitions
labeled by # from every q âˆˆ F to pf . The language of A0 is then L(A) Â· #âˆ—. We describe a recursive
procedure (iterating over Î±) for deciding whether L(A) âˆˆ L(A).

For the case that k = 1, it is easy to see that if Î± = âˆƒx1, then L(A) âˆˆ L(A) iff L(A) âˆ© L( Ë†A) 6= âˆ….
Otherwise, if Î± = âˆ€x1, then L(A) âˆˆ L(A) iff L(A) /âˆˆ L(A), where A is the NFH for L(A)
described in Theorem 8. Notice that the quantiï¬cation condition for A is âˆƒx1, and so this conforms
to the base case.

For k > 1, we construct a sequence of NFH A1, A2, . . . , Ak. If Q1 = âˆƒ then we set A1 = A,
i , Î´i, Fi, Î±ii. If Î±i starts with âˆƒ,

and otherwise we set A1 = A. Let Ai = hÎ£, {xi, . . . , xk}, Qi, Q0
then we construct Ai+1 as follows.

The set of variables of Ai+1 is {xi+1, . . . , xk}, and the quantiï¬cation condition Î±i+1 is
Qi+1xi+1 Â· Â· Â· Qkxk, for Î±i = QixiQi+1 Â· Â· Â· Qkxk. The set of states of Ai+1 is Qi Ã— P 0, and the set
(Ïƒi,...,Ïƒk)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ q0) âˆˆ Î´i
i Ã— P0. The set of accepting states is Fi Ã— F 0. For every (q
of initial states is Q0
(Ïƒi+1,...,Ïƒk)
and every (p Ïƒiâˆ’â†’ p0) âˆˆ Ï, we have ((q, p)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (q0, p0)) âˆˆ Î´i+1. Then, Ë†Ai+1 accepts a word
zip(u1, u2, . . . , ukâˆ’i) iff there exists a word u âˆˆ L(A), such that Ë†Ai accepts zip(u, u1, u2, . . . , ukâˆ’i).
Let v : {xi, . . . , xk} â†’ L(A). Then L(A) |=v (Î±i, Ai) iff there exists w âˆˆ L(A) such
that L(A) |=v[xiâ†’w] (Î±i+1, Ai). For an assignment v0 : {xi+1, . . . , xk} â†’ L(A), it holds that
zip(v0) is accepted by Ë†Ai+1 iff there exists a word w âˆˆ L(A) such that zip(v) âˆˆ L( Ë†Ai), where v
is obtained from v0 by setting v(xi) = w. Therefore, we have that L(A) |=v[xiâ†’w] (Î±i, Ai) iff
L(A) |=v0 (Î±i+1, Ai+1), that is, L(A) âˆˆ L(Ai) iff L(A) âˆˆ L(Ai+1).

B. Bonakdarpour and S. Sheinvald

XX:21

If Î±i starts with âˆ€, then we have that L(A) âˆˆ L(Ai) iff L(A) /âˆˆ L(Ai). We construct Ai for
L(Ai) as described in Theorem 8. The quantiï¬cation condition of Ai then begins with âˆƒxi, and we
apply the previous case, and construct Ai+1 w.r.t. Ai, to check for non-membership.

Every âˆ€ quantiï¬er requires complementation, which is exponential in n, the number of states in

A. Therefore, in the worst case, the complexity of this algorithm is O(22...|Q||A|
of height k. If the number of âˆ€ quantiï¬ers is ï¬xed, then the complexity is O(|Q||A|k).

), where the tower is
(cid:74)

Theorem 14

Proof. For the lower bound, we show a reduction from the containment problem for NFA, which is
known to be PSPACE-hard. Let A1, A2 be NFA. We â€œconvertâ€ them to NFH A1, A2 by adding to
both a single variable x, and a quantiï¬cation condition âˆ€x. By the semantics of the âˆ€ quantiï¬er, we
have that L(A1) = {S|S âŠ† L(A1)}, and similarly for A2. Therefore, we have that L(A1) âŠ† L(A2)
iff L(A1) âŠ† L(A2).

For the upper bound, ï¬rst notice that complementing an NFHâˆ€ yields an NFHâˆƒ, and vice versa.
Consider two NFH A1 and A2. Then L(A1) âŠ† L(A2) iff L(A1) âˆ© L(A2) = âˆ…. We can use the
constructions in the proof of Theorem 8 to compute a matching NFH A = A1 âˆ© A2, and check its
nonemptiness. The complementation construction is exponential in n2, the number of states of A2,
and the intersection construction is polynomial in |A1|, |A2|.

If A1 âˆˆ NFHâˆƒ and A2 âˆˆ NFHâˆ€ or vice versa, then A is an NFHâˆƒ or NFHâˆ€, respectively, whose

nonemptiness can be decided in space that is logarithmic in |A|.

Now, consider the case where A1 and A2 are both NFHâˆƒ or both NFHâˆ€. It follows from the proof
of Theorem 8, that for two NFH A, A0, the quantiï¬cation condition of A âˆ© A0 may be any interleaving
of the quantiï¬cation conditions of A and A0. Therefore, if A1, A2 âˆˆ NFHâˆƒ or A1, A2 âˆˆ NFHâˆ€,
we can construct A to be an NFHâˆƒâˆ€. This is also the case when A1 âˆˆ NFHâˆƒâˆ€ and A2 âˆˆ NFHâˆƒ or
A2 âˆˆ NFHâˆ€.

Either A2 or A2 is an NFHâˆ€, whose underlying NFA has a transition relation of size that is
exponential in k (otherwise the NFHâˆ€ is empty). The same holds for A1 âˆˆ NFHâˆƒâˆ€. The PSPACE
upper bound of Theorem 11 is derived from the number of variables and not from the state-space of the
NFH. Therefore, while | Â¯A2| is exponential in the number of states of A2, checking the nonemptiness
(cid:74)
of A is in PSPACE.

Lemma 16

Proof. We begin with NFHâˆ€. For the ï¬rst direction, since L( Ë†A0
âˆ€) âŠ†
L(Aâˆ€). For the second direction, let S âˆˆ L(Aâˆ€). Then for every v : S â†’ X, it holds that
zip(v) âˆˆ L( Ë†Aâˆ€). Also, zip(v0) âˆˆ L( Ë†Aâˆ€) for every sequence v0 of v. Then zip(v) and all its
sequences are in L( Ë†A0

âˆ€). Since this holds for every v : X â†’ S, we have that S âˆˆ L(A0

âˆ€) âŠ† L( Ë†Aâˆ€), we have L(A0

We proceed to NFHâˆƒ. For the ï¬rst direction, since L( Ë†Aâˆƒ) âŠ† L( Ë†A0

âˆƒ), we have L(A) âŠ† L(A0).
For the second direction, let S âˆˆ L(A0
âˆƒ).
Then zip(v) is a permutation of some word zip(v0) âˆˆ L( Ë†Aâˆƒ). According to the semantics of the âˆƒ
(cid:74)
quantiï¬er, we have that S âˆˆ L(Aâˆƒ).

âˆƒ). Then there exists v : S â†’ X such that zip(v) âˆˆ L( Ë†A0

âˆ€).

Lemma 17

Proof. We begin with NFHâˆ€. To construct A0
âˆ€ given Aâˆ€, we use a similar construction to the one
presented in the proof of Theorem 11. Essentially, for every sequence Î¶ of (1, 2, . . . , k), we construct
an NFA AÎ¶, in which every run on a word w matches a run of Ë†Aâˆ€ on wÎ¶. The NFHâˆ€ A0 is then

XX:22 Automata for Hyperlanguages

obtained from Aâˆ€ by replacing the underlying NFA with T
of (1, 2, . . . , k).

Î¶âˆˆÎ“ AÎ¶, where Î“ is the set of sequences

For NFHâˆƒ, similarly to the case of NFHâˆ€, we construct A0

every permutation Î¶ of (1, 2, . . . , k). In this case, the NFHâˆƒ A0
underlying NFA with S

Î¶âˆˆÎ“ AÎ¶, where Î“ is the set of permutations of (1, 2, . . . , k).

âˆƒ given Aâˆƒ by constructing AÎ¶ for
âˆƒ is obtained from Aâˆƒ by replacing the
(cid:74)

Theorem 18
Proof. We begin with NFHâˆ€. For the ï¬rst direction, let w âˆˆ L( Ë†Aâˆ€). Since A1 is sequence-complete,
then w0 âˆˆ L( Ë†A1) for every sequence w0 of w. Then, by the semantics of the âˆ€ quantiï¬er, we have that
unzip(w) âˆˆ L(A1). Therefore, unzip(w) âˆˆ L(A2), and so w (and all its sequences) are in L( Ë†A2). A
similar argument can be made to show that for every w âˆˆ L( Ë†A2), it holds that w âˆˆ L( Ë†A1). Therefore,
L( Ë†A1) = L( Ë†A2). The second direction is trivial.

We continue to NFHâˆƒ. For the ï¬rst direction, let w âˆˆ L( Ë†A1). Then unzip(w) âˆˆ L(A1). Then, by
the semantics of the âˆƒ quantiï¬er, there exists some permutation w0 of w such that w0 âˆˆ L( Ë†A2). Since
A2 is permutation-complete, we have that w âˆˆ L( Ë†A2). A similar argument can be made to show that
for every w âˆˆ L( Ë†A2), it holds that w âˆˆ L( Ë†A1). Therefore, L( Ë†A1) = L( Ë†A2). The second direction is
(cid:74)
trivial.

