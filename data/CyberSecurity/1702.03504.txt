7
1
0
2

t
c
O
4

]

O
L
.
s
c
[

2
v
4
0
5
3
0
.
2
0
7
1
:
v
i
X
r
a

Journal of Computer Security 1 (2014) 1–7
IOS Press

1

Time, Computational Complexity, and
Probability in the Analysis of
Distance-Bounding Protocols

Max Kanovich a,b, Tajana Ban Kirigin c, Vivek Nigam d,g, Andre Scedrov e,b and
Carolyn Talcott f
a Department of Computer Science (UCL-CS), University College London, London, UK
E-mail: m.kanovich@ucl.ac.uk
b Faculty of Computer Science, National Research University Higher School of Economics, Moscow,
Russian Federation
c Department of Mathematics, University of Rijeka, Rijeka, Croatia
E-mail:bank@math.uniri.hr
d Computer Science Department, Federal University of Paraíba, João Pessoa, Brazil
E-mail: vivek@ci.ufpb.br
e Department of Mathematics, University of Pennsylvania, Philadelphia, PA, USA
E-mail: scedrov@math.upenn.edu
f Computer Science Laboratory, SRI International, Menlo Park, CA, USA
E-mail: clt@csl.sri.com
g fortiss, Munich, Germany

Abstract. Many security protocols rely on the assumptions on the physical properties in which its protocol sessions will be
carried out. For instance, Distance Bounding Protocols take into account the round trip time of messages and the transmission
velocity to infer an upper bound of the distance between two agents. We classify such security protocols as Cyber-Physical.
Time plays a key role in design and analysis of many of these protocols. This paper investigates the foundational diﬀerences
and the impacts on the analysis when using models with discrete time and models with dense time. We show that there are
attacks that can be found by models using dense time, but not when using discrete time. We illustrate this with an attack
that can be carried out on most Distance Bounding Protocols. In this attack, one exploits the execution delay of instructions
during one clock cycle to convince a veriﬁer that he is in a location diﬀerent from his actual position. We additionally present
a probabilistic analysis of this novel attack. As a formal model for representing and analyzing Cyber-Physical properties, we
propose a Multiset Rewriting model with dense time suitable for specifying cyber-physical security protocols. We introduce
Circle-Conﬁgurations and show that they can be used to symbolically solve the reachability problem for our model, and show
that for the important class of balanced theories the reachability problem is PSPACE-complete. We also show how our model
can be implemented using the computational rewriting tool Maude, the machinery that automatically searches for such attacks.

Keywords: Multiset Rewrite Systems, Cyber-Physical Security Protocols, Protocol Security, Computational Complexity, Maude

0926-227X/14/$27.50 c(cid:13) 2014 – IOS Press and the authors. All rights reserved

 
 
 
 
 
 
2 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

1. Introduction

With the development of pervasive cyber-physical systems and consequent security issues, it is often
necessary to specify protocols that not only make use of cryptographic keys and nonces,1 but also take
into account the physical properties of the environment where its protocol sessions are carried out. We
call such protocols Cyber-Physical Security Protocols. For instance, Distance Bounding Protocols [5] is
a class of cyber-physical security protocols which infers an upper bound on the distance between two
agents from the round trip time of messages. In a distance bounding protocol session, the veriﬁer (V) and
the prover (P) exchange messages:

V −→ P : m
P −→ V : m(cid:48)

(1)

where m is a challenge and m(cid:48) is a response message (constructed using m’s components). To infer the
distance to the prover, the veriﬁer remembers the time, t0, when the message m was sent, and the time,
t1, when the message m(cid:48) returns. From the diﬀerence t1 − t0 and the assumptions on the speed of the
transmission medium, v, the veriﬁer can compute an upper bound on the distance to the prover, namely
(t1−t0)×v. Typically, the veriﬁer grants the access to the prover if the inferred upper bound on the distance
does not exceed some pre-established ﬁxed time response bound, R, given by the protocol speciﬁcation.
Distance bounding protocol sessions are used in a number of cyber-physical security protocols to infer
an upper-bound on the distance of participants. Examples include Secure Neighbor Discovery, Secure
Localization Protocols [43,6,41], and Secure Time Synchronization Protocols [42,18]. The common fea-
ture in most cyber-physical security protocols is that they mention cryptographic keys, nonces and time.
(For more examples, see [3,32,13] and references therein.)

A major problem of using the traditional protocol notation for the description of distance bounding
protocols, as in (1), is that many assumptions about time, such as the time requirements for the fulﬁllment
of a protocol session, are not formally speciﬁed. It is only informally described that the veriﬁer remem-
bers the time t0 and t1 and which exact moments these correspond to. Moreover, from the above descrip-
tion, it is not clear which assumptions about the network are used, such as the transmission medium used
by the participants. Furthermore, it is not formally speciﬁed which properties does the above protocol
ensure, and in which conditions and against which intruders.

It is easy to check that the above protocol is not safe against the standard Dolev-Yao intruder [14] who
is capable of intercepting and sending messages anywhere at anytime. The Dolev-Yao intruder can easily
convince V that P is closer than he actually is. The intruder ﬁrst intercepts the message m and with zero
transmission time sends it to P. Then he intercepts the message m(cid:48) and instantaneously sends it to V,
reducing the round-trip-time (t1 − t0). Thus, V will believe that P is much closer than he actually is. Such
an attack does not occur in practice as messages take time to travel from one point to another. Indeed, the
standard Dolev-Yao intruder model is not a suitable model for the analysis of cyber-physical protocols.
Since such an intruder is able to intercept and send messages anywhere at anytime, he appears faster than
the speed of light. In fact, a major diﬀerence between cyber-physical protocols and traditional security
protocols is that there is not necessarily a network in the traditional sense, as any transmission medium
used is the part of the network.

1In protocol security literature [7,15] fresh values are usually called nonces.

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

3

Existing works have proposed and used models with time for the analysis of distance bounding proto-
cols where the attacker is constrained by some physical properties of the system. Some models have con-
sidered dense time [3], while others have used discrete time [4]. However, although these models have
included time, the foundational diﬀerences between these models and the impacts to analysis has not
been investigated in more detail. For example, these models have not investigated the fact that provers,
veriﬁers, and attackers may have diﬀerent clock rates, i.e., processing speeds, which can aﬀect security.
Indeed, already in the original paper on Distance Bounding Protocols, Brands and Chaum [5] suspected
that a veriﬁer may be subject to attack as it uses discrete clock ticking, i.e., a processor, and thus mea-
sures time in discrete units, while the environment and the powerful attacker is not limited by a particular
clock. However, until now, no careful analysis of such attacks has been carried out. This paper addresses
this gap.

A key observation of this paper is that models with dense time abstract the fact that attacker clocks
may tick at any rate. The attacker can mask his location by exploiting the fact that a message may be sent
at any point between two clock ticks of the veriﬁer’s clock, while the veriﬁer believes that it was sent at
a particular time. Depending on the speed of the veriﬁer, i.e., its clock rate, the attacker can in principle
convince the veriﬁer that he is very close to the veriﬁer (less than a meter) even though he is very far
away (many meters away). We call this attack attack in-between-ticks.

Interestingly, from a foundational point of view, in our formalization there is no complexity increase
when using a model with dense time when compared to a model with discrete time. In our previous
work [24,25], we proposed a rewriting framework which assumed discrete time. We showed that the
reachability problem is PSPACE-complete. Here we show how to formalize systems with dense time,
and that, if we extend the model with dense time, the reachability problem is still PSPACE-complete.
For this result we introduce a novel machinery called Circle-Conﬁgurations. Moreover, we show that it
is possible to automate veriﬁcation of whether a protocol written in our model is subject to an instance
of an attack in-between-ticks.

However, our symbolic analysis only provides an yes or no answer, that is, it is only possible to
infer whether a system is or not subject to an attack in-between-ticks. For a more accurate analysis,
we construct a probabilistic model for analysing Distance Bounding Protocols. This model provides
precise measure of how probable a system is subject to an attack. A diﬀerence, however, to the proposed
symbolic model is that it seems less likely to carry out analysis in an automated fashion. We leave this
investigation to future work.

The paper is organised as follows. Section 2 contains the novel attack in-between-ticks. In Section 3
we introduce a formal model based on Multiset Rewriting (MSR) which includes dense time. We also
show how to specify distance bounding protocols in this language. In Section 4 we provide a probabilistic
analysis related to distance bounding protocols and the attack in-between-ticks. In Section 5 we show
how our model can be implemented using the computational rewriting tool Maude. In particular, Maude
is able to automatically ﬁnd the novel attack in-between-ticks. Section 6 introduces a novel machinery,
called circle-conﬁgurations, that allows one to symbolically represent conﬁgurations that mention dense
time. In Section 7 we prove that the reachability problem for timed bounded memory protocols [22] is
PSPACE-complete. Finally, in Section 8, we comment on related and future work.

This paper considerably extends the conference paper [26]. Besides adding the proofs of our complex-

ity results, Section 4 and 5 contain new material.

4 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

2. Motivating Examples

In this section we point to some subtleties of cyber-physical protocol analysis and veriﬁcation. We
present examples of protocols that serve to illustrate the diﬀerences between models with discrete and
dense time.

One such an example is a timed version of the classical Needham-Schroeder protocol [33] which
we already presented in our conference paper [26]. We have shown that the timed Needham-Schroeder
protocol may be safe in the discrete time model, but an attack (similar to Lowe attack [30]) is possible
when using models with dense time. This phenomena shows that some attacks on cyber-physical security
protocols may only be found when using models with dense time.

2.1. Time-Bounding Needham-Schroeder Protocol

We ﬁrst show some subtleties of cyber-physical security protocol analysis by re-examining the original
Needham-Schroeder public key protocol [33] (NS), presented in Figure 1a. Although this protocol is
well known to be insecure [30], we look at it from another dimension, the dimension of time. We check
whether Needham and Schroeder were right after all, in the sense that their protocol can be considered
secure under some time requirements. In other words, we investigate whether NS can be ﬁxed by means
of time.

We timestamp each event in the protocol execution, that is, we explicitly mark the time of sending
and receiving messages by a participant. We then propose a timed version of this protocol, called Time-
Bounding Needham-Schroeder Protocol (Timed-NS), as depicted in Figure 1b. The protocol exchanges
the same messages as in the original version, but the last protocol message, i.e., the conﬁrmation message
{NB}KB, is sent by A only if the time diﬀerence t3 − t0 is smaller or equal to the given response bounding
time R.

The protocol is considered secure in the standard way, that is, if the “accepted” NA and NB may never
be revealed to anybody else except Alice and Bob. Recall that the well known Lowe attack on NS [30]
involves a third party, Mallory who is able to learn Bob’s nonce. At the same time Bob believes that he
communicated with Alice and that only Alice learned his nonce.

The intriguing result of the analysis of Timed-NS is that one may not ﬁnd an attack in the discrete time
model, but can ﬁnd one in the dense time model: Figure 2 depicts the Lowe attack scenario in Timed-NS.
In particular, the attack requires that events marked with t0, . . . , t7 take place and that the round trip time
of messages, that is t7 − t0, does not exceed the given response bounding time R. Assuming that both
network delay and processing time are non-zero, in the discrete time model the attack could be modeled
only for response bounding time R ≥ 7, see Figure 2a. In the discrete model, the protocol would seem
safe for response bounding time R < 7. However, in the dense time model the attack is possible for any
positive response bounding time R, see Figure 2b. Indeed, assuming continuous times, the attacker can,
in principle, be as fast as needed to satisfy the given response bounding time. Notice additionally, that
if R is set to be too low, then it may also turn the protocol unusable as legitimate players may not be
able to satisfy the response time requirement. The same is true with Distance Bounding Protocols. If
the distance bound is set to be too low, legitimate players may not be able to get access to resources.
Therefore, response bounds should be set in such a way that makes the protocol secure and still grant
resource to legitimate users.

This simple example already illustrates the challenges of timed models for cyber-physical security
protocol analysis and veriﬁcation. No rescaling of discrete time units removes the presented diﬀerence

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

5

(a) Needham-Schroeder protocol

(b) Timed Needham-Schroeder Protocol

Fig. 1. Adding time to Needham-Schroeder Protocol

(a) Discrete Time Model

(b) Dense Time Model

Fig. 2. Timed Version of Lowe Attack

between the models. For any discretization of time, such as seconds or any other inﬁnitesimal time unit,
there is a protocol for which there is an attack with continuous time and no attack is possible in the
discrete case.

We further illustrate the challenges of timed models for cyber-physical security protocol analysis and
veriﬁcation by a more realistic example of a distance bounding protocol. The novel attack in-between-
ticks appears and illustrates that for the analysis of distance bounding protocols it is necessary to consider
time assumptions of the players involved.

2.2. Attack In-Between-Ticks

Regardless of the design details of a speciﬁc distance bounding protocol, we identify a new type of
anomaly. We call it Attack In-Between-Ticks. This attack is particularly harmful when the veriﬁer and
the prover exchange messages using radio-frequency (RF), where the speed of transmission is the speed
of light. In this case an error of a 1 nanosecond (ns) already results in a distance error of 30cm. This

AB{NA,A}KB{NA,NB}KA{NB}KBAt0Bt1t2{NA,A}KBt3{NA,NB}KAt4t5{NB}KBift3−t0≤RAliceMalloryt0=0MalloryBobt1=1t2=2{NA,A}kMt3=3{NA,A}kBt4=4t5=5{NA,NB}kAt6=6t7=7{NA,NB}kAt8=8t9=9{NB}kMt10=10t11=11{NB}kBAliceMalloryt0=0MalloryBobt1=0.1t2=0.2{NA,A}kMt3=0.3{NA,A}kBt4=0.4t5=0.5{NA,NB}kAt6=0.6t7=0.7{NA,NB}kAt8=0.8t9=0.9{NB}kMt11=1t11=1.1{NB}kB6 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

(a) In diﬀerent ticks (Sequential Execution)

(b) In the same tick (Parallel Execution)

Fig. 3. Attack In-Between-Ticks. Here time response bound R = 4 ticks.

is the case with a number of cyber-physical security protocols which try to establish the property that
participants are physically close to each other, e.g., Secure Neighbor Discovery, Secure Localization
Protocols [43,6,41], Secure Time Synchronization Protocols [42,18], Protocols used by RFID payment
devices [9,10].

Consider the illustrations in Figure 3. They depict the execution of instructions by the veriﬁer in a
distance bounding protocol with the time response bound R = 4. The veriﬁer has to execute two instruc-
tions: (1) the instruction that sends the signal to the prover and (2) the instruction that measures the time
when this message is sent. Figure 3a illustrates the case when the veriﬁer is running a sequential machine
(that is, a single processor), which is the typical case as the veriﬁer is usually a not very powerful device,
e.g., door opening device. Here we optimistically assume that an instruction can be executed in one cycle.
When the ﬁrst instruction is executed, it means that the signal is sent somewhere when the clock is up,
say at time 0.6. In the following clock cycle, the veriﬁer remembers the time when the message is sent.
Say that this was already done at time 1.5. If the response message is received at time 5 it triggers an
interruption so that the veriﬁer measures the response time in the following cycle, i.e., at time 5.5. Thus
the measured round time is 4 = 5.5 − 1.5 = R ticks. Therefore, the veriﬁer grants access to the prover
although the actual round trip is 5 − 0.6 = 4.4 > R = 4 ticks. This means that the veriﬁer is granting
access to the prover although the prover’s distance to the veriﬁer may not satisfy the distance bound and
thus this is a security ﬂaw.2

Depending on the speed of veriﬁer’s processor, the diﬀerence of 0.4 tick results in a huge error. Many of
these devices use very weak processors.3 The one proposed in [40], for example, executes at a frequency
of at most 24MHz. This means a tick is equal to 41ns (in the best case). Thus, an error of 0.4 tick
corresponds to an error of 16ns or an error of 2 × 2.4 meters when using RF. In the worst case, the error
can be of 1.0 tick when the signal is sent at the beginning of the cycle, i.e., at time 0.5 tick, and the
measurements at the end of the corresponding cycles, i.e., at times 2 and 6 ticks. An error of 1.0 tick
(41ns) corresponds to an error greater than 2 × 6.15 meters.

Consider now the case when the veriﬁer can execute both instructions in the same cycle. Even in this
case there might be errors in measurement as illustrated in Figure 3b. It may happen that the signal is

2Notice that inverting the order of the instructions, i.e., ﬁrst collecting the time and then sending the signal, would imply

errors of measurement but in the opposite direction turning the system impractical.

3High precision veriﬁers are expensive and normally used only in high security applications.

12345MeasuredRoundTripTime=4ActualRoundTripTime>4ProverVeriﬁer’sClockChallengeMsgResponseMsgVeriﬁer612345MeasuredRoundTripTime=4ActualRoundTripTime>4ProverVeriﬁer’sClockChallengeMsgResponseMsgVeriﬁerM. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

7

sent before the measurement is taken thus leading to errors of at most 0.5 ticks (not as great as in the
sequential case). (Here we are again optimistically assuming that an instruction can be executed in one
cycle.)

2.3. Vulnerability of Cyber-Physical Security Protocols to Attack In-Between-Ticks

The attack in-between-ticks is based on the foundational diﬀerence between real-time in nature and
time management by discrete time processors, irrespective of their physical-layer implementations and
distance bounding protocol design. The attack in-between-ticks appears because of the discrepancy be-
tween actual real-time distance and the upper bound on time distance that is calculated by a discrete
veriﬁer from the time taken as the time of sending and receiving challenge and response messages, re-
spectively.

Distance bounding protocol sessions are used in a number of cyber-physical security protocols, such as
Secure Neighbor Discovery, Secure Localization Protocols [43,6,41], and Secure Time Synchronization
Protocols [42,18]. Therefore, all these protocols can be vulnerable to the attack in-between-ticks.

Such a discrepancy has been suspected in Brands and Chaum’s original paper introducing distance
bounding protocols [5]. However, no study on the vulnerabilities of this discrepancy has been investigated
until now. The attack in-between-ticks represents a new category of attacks that needs to be considered
in the analysis of cyber-physical protocols.

From the well-known types of attacks, such as Distance Fraud, Maﬁa Fraud, Terrorist Fraud and Dis-
tance Hijacking [13], the distance fraud, or the corresponding classiﬁcation of Lone Distance Fraud
from [13] is the closest to the attack in-between-ticks. It also leads the veriﬁer to believe that a prover
is closer than he actually is, and it does not involve additional participants, only a single prover and a
veriﬁer. However, in (lone) distance fraud, the prover is assumed to be dishonest, trying to change his
distance and appear closer to the veriﬁer than he actually is. This can be achieved in some cases by, e.g.,
prover sending the response message(s) too soon, before receiving the challenge message(s), and can
be ﬁxed by changes in the protocol design, so that the response messages are dependant of challenge
messages sent by the veriﬁer. On the other hand, in the attack in-between-ticks, even an honest prover
can result closer than he actually is, not by his intent, but because of the discrepancy between real time
and discrete processor clocks.

In order to obtain high-resolution timing information about the arrival of individual data bits, distance
bounding protocol, as well as secure-positioning protocols, are tightly integrated into the physical layer of
the communication protocol, providing sub-microsecond timing information. In this way these protocols
rely directly on the laws of physics, i.e., on the assumption that the communication is bounded by the
speed of light. Nevertheless, as we have shown above, substantial errors in measurement, up to several
meters, may appear. Veriﬁer may allow the access to a prover that is considerably outside the distance
bound speciﬁed by the protocol. This would equally appear in any distance bounding protocol, e.g., in
Brands and Chaum protocol [5] or Hancke-Kuhn protocol [19].

Formal frameworks for reasoning about distance bounding protocols that are based on discrete time
models, such as [4], clearly cannot capture the attack in-between-ticks. This is also the case with the real-
time formalisms that do not take into account the way veriﬁers with discrete clocks operate. None of the
real-time formalisms that we are aware of formalizes this treatment of time that is typical of processors.

Furthermore, we observe that these security ﬂaws may happen in principle. In practice, distance bound-
ing protocols carry out a large number of challenge and response rounds. This is generally believed to

8 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

mitigate the chances of attacks occurring. In the future, we intend to investigate the challenge-response
approach in providing security of distance bounding protocols. In particular, we are planning to analyze
whether the eﬀects of the attack in-between-ticks can be reduced by repeated challenge-response rounds
of protocols.

Finally, we also point out that these attacks have been inspired by similar issues in the analysis of

digital circuits [2].

3. A Multiset Rewriting Framework with Dense Time

For our multiset rewriting framework we assume a ﬁnite ﬁrst-order typed alphabet, Σ, with variables,
constants, function and predicate symbols. Terms and facts are constructed as usual (see [16]) by applying
symbols with correct type (or sort). For instance, if P is a predicate of type τ1 × τ2 × · · · × τn → o, where
o is the type for propositions, and u1, . . . , un are terms of types τ1, . . . , τn, respectively, then P(u1, . . . , un)
is a fact. A fact is grounded if it does not contain any variables.

In order to specify systems that explicitly mention time, we use timestamped facts of the form F@T ,
where F is a fact and T is its timestamp. In our previous work [25], timestamps were only allowed to be
natural numbers. Here, on the other hand, in order to express dense time, timestamps are allowed to be
non-negative real numbers.

We assume that there is a special predicate symbol T ime with arity zero, which will be used to represent

the global time. A conﬁguration is a multiset of ground timestamped facts,

{ T ime@t, F1@t1, . . . , Fn@tn },

with a single occurrence of a T ime fact. Conﬁgurations are to be interpreted as states of the system. For
example, the following conﬁguration

{ T ime@7.5, Deadline@10.3, T ask (1, done)@5.3, T ask (2, pending)@2.13 }

(2)

speciﬁes that the current global time is 7.5, the Task 1 was performed at time 5.3, Task 2 was issued at
time 2.13 and is still pending, and that the deadline to perform all tasks is 10.3.

We may sometimes denote the timestamp of a fact F in a given conﬁguration as TF.

3.1. Actions and Constraints

Actions are multiset rewrite rules and are either the time advancement action or instantaneous actions.

The action representing the advancement of time, called Tick Action, is the following:

T ime@T −→ T ime@(T + ε)

(3)

Here ε can be instantiated by any positive real number specifying that the global time of a conﬁgu-
ration can advance by any positive number. For example, if we apply this action with ε = 0.6 to the
conﬁguration (2) we obtain the conﬁguration

{ T ime@8.1, Deadline@10.3, T ask (1, done)@5.3, T ask (2, pending)@2.13 }

(4)

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

9

where the global time advanced from 7.5 to 8.1.

Clearly such an action is a source of unboundedness as time can always advance by any positive real
number. In particular we will need to deal with issues such as Zeno Paradoxes [1] when considering how
time should advance.

The remaining actions are the Instantaneous Actions, which do not aﬀect the global time, but may

rewrite the remaining facts.

Deﬁnition 3.1.

Instantaneous Actions are actions of the form:

T ime@T, W1@T1, . . . , Wk@Tk, F1@T (cid:48)

1, . . . , Fn@T (cid:48)

n | C −→

∃ (cid:126)X. [ T ime@T, W1@T1, . . . , Wk@Tk, Q1@(T + D1), . . . , Qm@(T + Dm) ]

(5)

where D1, . . . , Dm are natural numbers, existentially quantiﬁed variables (cid:126)X denote fresh values that are
created by the rule, and C is the guard of the action which is a set of constraints involving the time
variables appearing in the pre-condition, i.e., the variables T, T1, . . . , Tk, T (cid:48)
Time Constraints are expressions of the form:

1, . . . , T (cid:48)
n.

T (cid:48) > T (cid:48)(cid:48) ± D and

T (cid:48) = T (cid:48)(cid:48) ± D

(6)

where T (cid:48) and T (cid:48)(cid:48) are time variables, and D is a natural number. 4

We use T (cid:48) ≥ T (cid:48)(cid:48) ± D to denote the disjunction of T (cid:48) > T (cid:48)(cid:48) ± D and T (cid:48) = T (cid:48)(cid:48) ± D.
An instantaneous action can only be applied if all the constraints in its guard are satisﬁed.
We say that facts Fi@T (cid:48)

i are consumed and that the facts Qi@(T + Di) are created by the rule (5).

Notice that we allow only natural numbers for constants Ds and Dis that appear in time constraints
and timestamps of created facts. We impose such conditions because of the relevant computational com-
plexity issues. However, this is not as restrictive w.r.t. expressivness of the model as one might think. We
will address this issue in more detail later on in Section 7 when we investigate the complexity of related
computational problems.

Also, notice that the global time does not change when applying an instantaneous action. Moreover,
the timestamps of the facts that are created by the action, namely the facts Q1, . . . , Qm, are of the form
T + Di, where Di is a natural number and T is the global time. That is, their timestamps are in the present
or the future. For example, the following is an instantaneous action

T ime@T, T ask (1, done)@T1, Deadline@T2, T ask (2, pending)@T3 | { T2 ≥ T + 2 }
−→ T ime@T, T ask (1, done)@T1, Deadline@T2, T ask (2, done)@(T + 1)

which speciﬁes that one should complete Task 2, if Task 1 is already completed, and moreover, if the
Deadline is at least 2 units ahead of the current time. If these conditions are satisﬁed, then the Task 2 will
be completed in one time unit. Applying this action to the conﬁguration (4) yields

{ T ime@8.1, Deadline@10.3, T ask (1, done)@5.3, T ask (2, done)@9.1 }

4Here, and in the rest of the paper, the symbol ± stands for either + or −, that is, constraints may involve addition or

subtraction.

10 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

where Task 2 will be completed by the time 9.1.

Finally, the variables (cid:126)X that are existentially quantiﬁed in (5) are to be replaced by fresh values, also
called nonces in protocol security literature [7,15]. For example, the following action speciﬁes the cre-
ation of a new task with a fresh identiﬁer Id, which should be completed by time T + D:

T ime@T −→ ∃ Id. [ T ime@T, T ask (Id, pending)@(T + D) ]

Whenever this action is applied to a conﬁguration, the variable Id is instantiated by a fresh value. In this
way we are able to specify that the identiﬁer assigned to the new task is diﬀerent to the identiﬁers of all
other existing tasks. In the same way it is possible to specify the use of nonces in Protocol Security [7,15].
Formally, a rule W | C −→ ∃ (cid:126)X. W(cid:48) can be applied to a conﬁguration S if there is a ground substitution
σ, where the variables in (cid:126)X are fresh, such that Wσ ⊆ S and Cσ is true. The resulting conﬁguration is
(S \ W) ∪ W(cid:48)σ.

Notice that by the nature of multiset rewriting there are various aspects of non-determinism in the
model. For example, diﬀerent actions and even diﬀerent instantiations of the same rule may be applicable
to the same conﬁguration S, which may lead to diﬀerent resulting conﬁgurations S(cid:48).

More precisely, an instance of an action is obtained by substituting all variables appearing in the pre-
and post-condition of the action with constants. That applies to variables appearing in terms inside facts,
variables representing fresh values, as well as time variables used in specifying timestamps of facts. For
example, consider the following action

T ime@T, Finaltask (x, done)@T, Deadline@T1 | { T1 ≥ T + 3 }

−→ ∃ n. [ T ime@T, File (n, x, pending)@(T + 2), Deadline@T1 ]

(7)

specifying that a case record for a completed process should be ﬁled under a unique record label within
2 time units. An instance of above action is obtained by substituting constants for variables x, T , T1 and
n. For example,

T ime@3.2, Finaltask (C, done)@3.2, Deadline@10 | { 10 ≥ 3.2 + 3 }

−→ T ime@3.2, File (N, C, pending)@5.2, Deadline@10

is an instance of action (7). Recall that an instance of an action can only be applied to a conﬁguration
containing all the facts from its precondition if all the corresponding time constraints, i.e., all the time
constraints in its guard, are satisﬁed. For example, since 15.3 ≥ 8.1 + 3, action (7) is applicable to
conﬁguration

{ T ime@8.1, Finaltask (C0, done)@8.1, Deadline@15.3 } ,

resulting in conﬁguration

{ T ime@8.1, File (N1, C0, pending)@10.1, Deadline@15.3 } ,

but it is not applicable to the following conﬁguration

{ T ime@13.1, Finaltask (C0, done)@13.1, Deadline@15.3 } .

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 11

3.2. Initial, Goal Conﬁgurations and The Reachability Problem

We write S −→r S1

instance of action r. For a set of actions R, we deﬁne S −→∗
the one-step relation on all actions in R. We elide the subscript R, when it is clear from the context.

for the one-step relation where conﬁguration S is rewritten to S1 using an
R S1 as the transitive reﬂexive closure of

Deﬁnition 3.2. A goal SG is a pair of a multiset of facts and a set of constraints, written

{ F1@T1, . . . , Fn@Tn } | C

where T1, . . . , Tn are time variables, F1, . . . , Fn are facts and C is a set of constraints involving
only T1, . . . , Tn. We call a conﬁguration S1 a goal conﬁguration w.r.t. goal SG if there is a grounding
substitution σ replacing term variables by ground terms and time variables by real numbers such that
SGσ ⊆ S1 and all the constraints in Cσ are satisﬁed.

For simplicity, since goal will usually be clear from the context, we will use terminology goal conﬁg-

uration eliding the goal w.r.t. which it is deﬁned.

The reachability problem is then deﬁned for a given initial conﬁguration, a goal and a set of actions.

Deﬁnition 3.3. Given an initial conﬁguration SI, a goal SG and a set of actions R, the reachability
problem T is the problem of establishing whether there is a goal conﬁguration S1, such that SI −→∗
R S1.
Such a sequence of actions leading from an initial to a goal conﬁguration is called a plan.

We assume that goals are invariant to renaming of fresh values, that is, a goal conﬁguration SG
G if they only diﬀer in the nonce names (see [20] for more

is equivalent to the goal conﬁguration S(cid:48)
discussion on this).

Although the reachability problem is stated as a decision problem, we follow [27] and are able to prove
more than just existence of a plan. Namely, by using the notion of “scheduling” a plan we are also able
to generate a plan when there is a solution. This is useful for the complexity of the plan generation, since
the number of actions in the plan may be very large (see [20] for more details on this).

An algorithm is said to schedule a plan if it ﬁnds a plan if one exists, and on input i, if the plan contains

at least i actions, then it outputs the ith action of the plan, otherwise it outputs no.

Remark 3.4. Notice that the feature of time constraints being attached to the rules increases expres-
sivitiy of the model. Constraints may or may not be attached to a rule or to a conﬁguration. With no
constraints attached to rules and conﬁgurations, we deal with the reachability problem that does not
make use of the dimension of time to its potential. In other words, adding constraints to rules and con-
ﬁgurations is not a restriction of the model. Quite the contrary, using constraints, we are able to express
time properties both for application of rules, and states of the system. In that way we are able to formal-
ize time-sensitive actions and system conﬁgurations, and hence we can consider problems that involve
explicit time requirements.

For the complexity results of the reachability problem we will consider actions that are balanced,
i.e., actions that have the same number of facts in the pre-condition as in the post-condition. Balanced
systems that contain only balanced actions have the special property that all conﬁgurations in their plans
have the same number of facts, given by the number of facts in the initial conﬁguration. This is because

12 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

when applying a balanced action consumed facts from an enabling conﬁguration are replaced with the
same number of created facts in the resulting conﬁguration.

Indeed, balanced systems can be conceived as systems with bounded memory [20]. More precisely, if
we additionally impose a bound on the number of symbols that can be contained in a fact, such balanced
systems involve conﬁgurations with a ﬁxed number of facts of a bounded storage capacity, i.e., they can
only store a bounded number of symbols at a time.

Remark 3.5. Notice that any un-balanced rule can be made balanced by adding additional facts where
needed, either in the pre-condition or in the post-conditions of the rule. For that purpose we use so called
empty facts, E@T , that simply denote available memory slots. Notice that in such a way we do not get
the equivalent system w.r.t. the reachability problem, as some rules may not be applied in the obtained
balanced system unless there is a suﬃcient number of empty facts in the conﬁguration, even in cases
when the corresponding rule is applicable in the original system. For example, the following unbalanced
rule

T ime@T, F1@T (cid:48) −→ T ime@T, F1@T (cid:48), F1@T, F2@T

is applicable to conﬁguration T ime@0, F1@0, E@0, but its corresponding balanced rule

T ime@T, F1@T (cid:48), E@T, E@T −→ T ime@T, F1@T (cid:48), F1@T, F2@T

is not. Hence, the obtained balanced system may not have a solution to the given reachability problem,
although the original system does. However, there is no a priori bound on the number of facts in the
initial conﬁguration, i.e., we could add any number of empty facts to the given initial conﬁguration.

For our complexity results (Section 7) we necessarily consider only systems with balanced actions,
since it has been shown in [28] that the reachability problem is undecidable if actions are allowed to
be un-balanced. Multiset rewriting models considered in [28] were untimed, and the undecidability of
the reachability problem for those models implies undecidability of the reachability problem for timed
models considered in this paper.

Additionally, we will impose a bound on the size of facts, that is, a bound on a total number of sym-
bols contained in a fact. Namely, the reachability problem is undecidable even for (un-timed) balanced
systems when the size of facts is unbounded [7,15].

Furthermore, in [25] we show that by relaxing any of the main conditions on instantaneous rules,
same as conditions given in Equation (5), leads to the undecidability of the reachability problem for
multiset rewriting models with discrete time, and thus lead as well to the undecidability of the reachability
problems considered in this paper. For example, we get undecidability for systems with time constraints
that involve three or more time variables.

3.3. Equivalence Between Conﬁgurations

Extending the model to include dense time leads to additional challenges with respect to the complexity
of the corresponding problems such as the reachability problem we address in this paper. Our solution
proposed in [25] for the model with discrete time is not suitable for the dense time case. In particular
it does not address the unboundedness caused by the Tick action which allows time to advance for any

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 13

positive real number. In order to tackle this source of unboundedness, we deﬁne an equivalence relation
among conﬁgurations deﬁned below.

Many formal deﬁnitions and results in this paper mention Dmax, an upper bound on the numeric values
of a reachability problem. This value is computed from the given problem: we set Dmax to be a natural
number such that Dmax > n + 1 for any number n (both real or natural) appearing in the timestamps of
the initial conﬁguration, or the Ds and Dis in constraints or actions of the reachability problem.

The following deﬁnition establishes the equivalence of conﬁgurations.

Deﬁnition 3.6. Given a reachability problem T , let Dmax be an upper bound on the numeric values
appearing in T . Let

S = { Q1@t1, Q2@t2, . . . , Qn@tn }

and

(cid:101)S = { (cid:101)Q1@(cid:101)t1, (cid:101)Q2@(cid:101)t2, . . . , (cid:101)Qn@(cid:101)tn }

(8)

be two conﬁgurations written in canonical way where the two sequences of timestamps t1, . . . , tn and
(cid:101)t1, . . . ,(cid:101)tn are non-decreasing. (For the case of equal timestamps, we sort the facts in alphabetical order, if
necessary.) We say that conﬁgurations S and (cid:101)S are equivalent conﬁgurations if the following conditions
hold:
(i) there is a bijection σ that maps the set of all nonce names appearing in conﬁguration S to the set of
all nonce names appearing in conﬁguration (cid:101)S, such that Qiσ = (cid:101)Qi, for each i ∈ {1, . . . , n}; and

(ii) conﬁgurations S and (cid:101)S satisfy the same constraints, that is:

ti > t j ± D iﬀ (cid:101)ti > (cid:101)t j ± D and
ti = t j ± D iﬀ (cid:101)ti = (cid:101)t j ± D,

for all 1 ≤ i ≤ n, 1 ≤ j ≤ n and D ≤ Dmax.

When S and (cid:101)S are equivalent we write S ∼Dmax (cid:101)S, or simply S ∼ (cid:101)S.

Notice that equivalent conﬁgurations contain the same (untimed) facts up to renaming of fresh values.
Notice as well that by increasing or decreasing all the timestamps of a conﬁguration S by the same value
∆ the obtained conﬁguration (cid:101)S satisﬁes the same constraints as S. That is because time constraints are
relative, i.e., involve exactly two time variables, and hence for conﬁgurations S and (cid:101)S given in (8) the
following holds:

ti > t j ± D iﬀ ((cid:101)ti + ∆) > ((cid:101)t j + ∆) ± D and
ti = t j ± D iﬀ ((cid:101)ti + ∆) = ((cid:101)t j + ∆) ± D .

When compared, facts of equivalent conﬁgurations satisfy the same order. Although facts follow the

same order they need not lay at the exact same points of the real line.

For example, with Dmax = 3, conﬁgurations:

S1 = { T ime@0.2, F1(n1)@1.5, F2(n1, b)@2.3, F3(b)@2.5 }
S2 = { T ime@1.1, F1(n2)@2.7, F2(n2, b)@3.2, F3(b)@3.7 }

and

are equivalent. However, above conﬁgurations are not equivalent to conﬁguration:

S3 = { T ime@0.2, F1(n1)@1.5, F2(n1, b)@2.3, F3(b)@2.52 } .

14 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

since both S1 and S2 satisfy the constraint T3 − T1 = 1, where T1 is the timestamp of the fact F1 and T3
is the timestamp of the fact F3, while S3 does not.

As shown by the above example, same order of facts by itself is not enough for the equivalence of
conﬁgurations because all constraints of the type Ti = T j ± D need to be satisﬁed simultaneously by
both conﬁgurations. Therefore, the facts corresponding to Ti and T j from constraints Ti = T j ± D, when
placed on the real line, need to lay at the points with the same decimal parts. Moreover, matching of
corresponding facts at integer points needs to hold when placing any of the corresponding pairs of facts
at point 0 on the real line.

Moreover, because of constraints of the type Ti > T j ± D, when placing any pair of corresponding facts
at 0, all remaining pairs of corresponding facts need to lay either at the same integer point or inbetween
same consecutive integers.

In Section 6 we introduce another, more illustrative, representation of the above equivalence relation.
The following proposition captures our intuition that the notion of equivalence deﬁned above is coarse

enough to identify applicable actions and thus the reachability problem.
Proposition 3.7. Let S and S(cid:48) be two equivalent conﬁgurations for a given reachability problem T and
the upper bound Dmax. Let an action r transform S into S1. Then there is an instance of the action r such
that S(cid:48) −→r S(cid:48)

1 and that conﬁgurations S1 and S(cid:48)

1 are also equivalent.

Proof. Let S and S(cid:48) be two equivalent conﬁgurations, namely

S = { T ime@t, Q1@t1, Q2@t2, . . . , Qn@tn }
S(cid:48) = { T ime@t(cid:48), Q(cid:48)
1, Q(cid:48)
n } .

2, . . . , Q(cid:48)

1@t(cid:48)

2@t(cid:48)

n@t(cid:48)

and

Assume that S is transformed into S1 by means of an action r. By deﬁnition of equivalence between
conﬁgurations, Deﬁnition 3.6, conﬁguration S(cid:48) contains the same (untimed) facts as S up to nonce
renaming, i.e., there is a bijection σ such that Qiσ = Q(cid:48)
i, for all i = 1, . . . , n. Also, per Deﬁnition 3.6,
conﬁguration S(cid:48) satisﬁes all the time constraints corresponding to the action r, if any. Hence the action r
is indeed applicable to conﬁguration S(cid:48) and will transform S(cid:48) into some S(cid:48)
1, as depicted in the following
diagram:

S →r S1
(cid:111)
S(cid:48) →r S(cid:48)
1

Since conﬁgurations S and S(cid:48) may diﬀer in the actual values of the timestamps attached to their facts,
possibly diﬀerent instances of the action r may be applied to each of the conﬁgurations. We consider
both cases for the action r, namely time advance action i.e., action of type (3) and instantaneous actions
i.e., action of type (5), and we need to show that in both cases S1 is equivalent to S(cid:48)
1.

Assume that r is an instantaneous action. Recall that the action r does not change the global time, so t

and t(cid:48) denote the global time both in S and S1, and S(cid:48) and S(cid:48)
Hence, in showing that S1 is equivalent to S(cid:48)
1, only constraints involving facts created by the action r
2@(t(cid:48) + D2), respectively. Notice that the fact
are interesting, i.e., facts of the form F1@(t + D1) and F(cid:48)
P@(t + D), crated by an instance of r, appears in S1 iﬀ the fact P(cid:48)@(t(cid:48) + D), created by an instance of
r, appears in S(cid:48)

1, where P(cid:48) = Pσ for some nonce renaming bijection σ.

1, respectively.

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 15

Hence, the relative time diﬀerence to the global time is exactly D, both for P@(t+D) and for P(cid:48)@(t(cid:48)+D).
This implies that any given time constraint attached to r involving a created fact and the global time is
satisﬁed in S1 iﬀ it is satisﬁed in S(cid:48)
1.
1@(t(cid:48) + D1),
Similarly, time constraints involving two created facts, P1@(t + D1), P2@(t + D2) and P(cid:48)
2@(t(cid:48) + D2), respectively, involve the same relative diﬀerence D1 − D2. Hence, they are concurrently
P(cid:48)
satisﬁed.
Finally, a time constraint c involving a created fact P1@(t + D1) and a fact Qi@ti that appears in S, and,
respectively, facts P(cid:48)
1, can be associated to a time constraint involving the
global time. Clearly, for all D

1@(t(cid:48) + D1) and Q(cid:48)

i in S(cid:48)

i@t(cid:48)

is equivalent to

ti > t ± D iﬀ ti
ti = t ± D iﬀ ti

(cid:48) > t(cid:48) ± D and
(cid:48) = t(cid:48) ± D

ti > (t + D1) ± D iﬀ ti
ti = (t + D1) ± D iﬀ ti

(cid:48) > (t(cid:48) + D1) ± D and
(cid:48) = (t(cid:48) + D1) ± D .

1 concurrently satisfy constraint c iﬀ they concurrently satisfy
Above equivalence states that S1 and S(cid:48)
some constraint involving a created fact and the global time. Since the later has already been shown, we
can conclude that both S and S(cid:48) satisfy constraint c.

Having considered all the relevant types of constraints, we can conclude that, since S ∼ S(cid:48), it follows

that S1 ∼ S(cid:48)
1.

Now, assume S is transformed into S1 by means of a time advancing action r:

S1 = { T ime@(t + ε), Q1@t1, Q2@t2, . . . , Qn@tn } .

Depending on the actual value ε in r we will ﬁnd the value ε(cid:48) for the instance of time advancement
action that will transform S(cid:48) into S(cid:48)
1 holds. Recall that time
advancement action is applicable to any conﬁguration.

1 in such a way that equivalence S1 ∼ S(cid:48)

With time advancement only the timestamp denoting the global time is increased while the rest of the
conﬁguration remains unchanged. Therefore, only time constraints involving the global time are to be
considered for equivalence of S1 and S(cid:48)
1.

Firstly, assume that the new global time t + ε in S1 is equal to some timestamp t j ± B, where B is an

integer. Then we set

ε(cid:48) = t(cid:48)

j ± B − t(cid:48) .

Then the new global time in S(cid:48)

1 is t(cid:48) + ε(cid:48) = t(cid:48)

j ± B. Clearly, for any integer D it holds that

ti (cid:83) (t + ε) ± D = t j ± B ± D iﬀ ti

(cid:48) (cid:83) (t(cid:48) + ε) ± D = t(cid:48)

j ± B ± D

since ti, t(cid:48)
i and t j, t(cid:48)
same constraints.

j are corresponding timestamps from S and S(cid:48) which are equivalent, i.e., satisfy the

16 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

Next, we consider the remaining case when the decimal part of the new global time t + ε is diﬀerent
from the decimal part of any tis in S1. More precisely, if we arrange the facts in S1 according only to
their decimal parts, then the decimal part of t + ε either lays directly in between decimal parts of ti and
t j, or it is greater than the decimal part of any ti. In order to get the conﬁguration S(cid:48)
1 that is equivalent to
S1, we need to achieve the same ordering of facts. We therefore set

where δ ∈ (cid:104)0, 1(cid:105) is any number such that

ε(cid:48) = int (ε) + δ,

dec (t(cid:48)

i ) < dec (t(cid:48) + ε(cid:48)) < dec (t(cid:48)
j)
i ) < dec (t(cid:48) + ε(cid:48)),
dec (t(cid:48)

or

in case when dec (ti) < dec (t + ε) < dec (t j),
in case that dec (ti) < dec (t + ε), ∀ i = 1, . . . , n .

for some i, j

This way we obtain the same ordering of dec (t(cid:48) + ε(cid:48)) in S(cid:48)
Here int (x) is the integer part of x and dec (x) is the decimal part of x. Advancing time in S(cid:48) for such
an ε(cid:48) results in conﬁguration S(cid:48)

1 as for dec (t + ε) in S1.

1 that is equivalent to S1.

Indeed, none of the time constraints involving global time and equality, such as constraint

ti = t ± D
= t(cid:48) ± D, is satisﬁed since D is an integer and the decimal parts of both global times t and t(cid:48) are
i − t(cid:48)

i.e.,
diﬀerent from the decimal part of any other fact in the conﬁguration. Therefore, both ti − t and t(cid:48)
are not integers.

t(cid:48)
i

For the time constraints involving the global time and inequality, we consider the constraint of type

tk > t ± Di. The proof for the case of constraint of type tk < t ± Di is analogous.
From S ∼ S(cid:48) for all integers B ≤ Dmax we know that for all k ∈ {1, . . . , n}

tk > t ± B iﬀ tk

(cid:48) > t(cid:48) ± B .

We need to prove that

tk > (t + ε) ± D iﬀ tk

(cid:48) > (t(cid:48) + ε(cid:48)) ± D

(9)

(10)

for all integers D < Dmax. Notice that t + ε ± D = t + dec (ε) + int (ε) ± D involves possibly an integer
int (ε) + D greater than Dmax, for which (9) may not hold. Similarly, it is the case for integer int (ε(cid:48)) + D.
int (ε) = 0. Equivalently, we could split an arbitrary ε into

We will, therefore, assume that ε < 1, i.e.,

a ﬁnite number of εi such that (cid:80) εi = ε, and prove the result for ε by induction.
From (9) and from

int (t) ≤ int (t + ε) ≤ int (t) + 1

we can conclude that

int (tk) ≥ int (t + ε) ± D = int (t + ε ± D)

iﬀ int (tk)(cid:48) ≥ int (t(cid:48) + ε(cid:48)) ± D = int (t(cid:48) + ε(cid:48) ± D) . (11)

Additionally,

dec (tk) > dec (t + ε)

iﬀ dec (t(cid:48)

k) > dec (t(cid:48) + ε(cid:48))

(12)

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 17

holds because ε(cid:48) is chosen so that the ordering of decimal parts of timestamps in S1 and S(cid:48)
That is, either

1 is the same.

dec (ti) < dec (t + ε) < dec (t j)

and dec (t(cid:48)

i ) < dec (t(cid:48) + ε(cid:48)) < dec (t(cid:48)
j)

for some Qi@ti, Q j@t j
facts in S only by the decimal parts of their timestamps, or it is the case that

that immediately precede and follow the fact T ime@(t + ε) when sorting the

dec (ti) < dec (t + ε)

and

dec (t(cid:48)

i ) < dec (t(cid:48) + ε(cid:48)) , ∀i ∈ {1, . . . , n} .

From (11) and (12) we obtain the claim (10).

(cid:3)

Following the above Proposition, we now relate the equivalence of conﬁgurations given by Deﬁni-

tion 3.6 and the reachability problem.

Theorem 3.8. Let SI and S(cid:48)
Let Dmax be an upper bound on the numbers in R, SI, S(cid:48)
SI, SG and R is solvable if and only if the reachability problem with S(cid:48)

I be two equivalent initial conﬁgurations, SG be a goal and R a set of actions.
I and SG. Then the reachability problem with
I, SG and R is solvable.

Proof. (cid:73) Suppose the reachability problem with SI, SG has a solution. We prove the existence of the so-
lution to the reachability problem with S(cid:48)
I, SG by induction on the length of the given plan from SI to SG.
I to S(cid:48)
From Proposition 3.7 it follows that the plan from SI to SG and the plan from S(cid:48)
G contain exactly
the same actions, possibly using diﬀerent instances. It also follows that Si ∼ S(cid:48)
i for each conﬁguration
Si along the plan. This is depicted in the following diagram:

SI →r1 · · · →ri−1 Si−1 →ri Si →ri+1 · · · →rn SG
(cid:111)
(cid:111)
(cid:111)
(cid:111)
S(cid:48)
I →r1 · · · →ri−1 S(cid:48)
i−1 →ri S(cid:48)
i →ri+1 · · · →rn S(cid:48)

G

Since SG ∼ S(cid:48)
conﬁguration iﬀ S(cid:48)
solution if and only if the reachability problem with S(cid:48)

G, these conﬁgurations both satisfy the same set of constraints, therefore SG is a goal
G is a goal conﬁguration. Hence, the reachability problem with SI, SG and R has a
(cid:3)

I, SG and R has a solution. (cid:74)

3.4. Distance Bounding Protocol Formalization

To demonstrate how our model can capture the attack in-between-ticks, consider the following pro-
tocol, called DB. This protocol captures the time challenge of distance bounding protocols.5 Veriﬁer
should allow the access to his resources only if the measured round trip time of messages in the distance-
bounding phase of the protocol does not exceed the given bounding time R. We assume that the veriﬁer
and the prover have already exchanged nonces nP and nV :

V −→ P : nP
P −→ V : nV
V −→ P : OK(P)

at time t0
at time t1

iﬀ t1 − t0 ≤ R

5Another speciﬁcation that includes an intruder model, keys, and the speciﬁcation of the attack described in [3] can be

found in our workshop paper [23].

18 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

Encoding of veriﬁer’s clock The fact ClockV @T denotes the local clock of the veriﬁer i.e., the discrete
time clock that veriﬁer uses to measure the response time in the distance bounding phase of the protocol.
We encode ticking of veriﬁer’s clock in discrete units of time. Action (13) represents the ticking of

veriﬁer’s clock:

T ime@T, ClockV @T1 | { T = T1 + 1 } −→ T ime@T, ClockV @T

(13)

Notice that if this action is not executed and T advances too much, i.e., T > T1, it means that the veriﬁer
clock stopped as it no longer advances.
Network Let D(X, Y) = D(Y, X) be the integer representing the minimum time needed for a message to
reach Y from X. We also assume that participants do not move. Rule (14) models network transmission
from X to some Y:

T ime@T, N S

X (m)@T1, E@T2 | { T ≥ T1 + D(X, Y) } −→ T ime@T, N S

X (m)@T1, N R

Y (m)@T (14)

X (m) and N R

Facts N S
X (m) specify that the participant X has sent and may receive the message m, respec-
tively. Once X has sent the message m, that message can only be received by Y once it traveled from X
to Y. The fact E is an empty fact which can be interpreted as a slot of resource. This is a technical device
used to turn a theory balanced. See [22] for more details.

Remark 3.9. Notice that in the rule (14) the fact N S
X (m)@T1 is not consumed. This models the trans-
mission media, such as radio frequency, where messages are not consumed by recipients. In such media,
and as modelled by the rule (14), it is possible for multiple participants to receive the same message
m. Alternatively, as in the classical (wire) network communication, the messages are removed from the
network. In our formal model we are able to represent such transmission media as well, e.g., using the
following rule

T ime@T, N S

X (m)@T1 | { T ≥ T1 + D(X, Y) } −→ T ime@T, N R

Y (m)@T .

Measuring the round trip time of messages A protocol run creates facts denoting times when messages
of the distance bounding phase are sent and received by the veriﬁer. Predicates Start and Stop denote the
actual (real) time of these events so that the round trip time of messages is T2 − T1 for timestamps T1, T2
in Start(m)@T1, Stop(m)@T2. On the other hand predicates StartV and StopV model the veriﬁer’s view
of time: T2 − T1, for T1, T2 in StartV (m)@T1, StopV (m)@T2.
Protocol Theory Our example protocol DB is formalized in Figure 4. The ﬁrst rule speciﬁes that the ver-
iﬁer has sent a nonce and still needs to mark the time, speciﬁed by the fact V1(pending, P, NP, NV )@T .
The second rule speciﬁes veriﬁer’s instruction of remembering the current time. The third rule speciﬁes
prover’s response to the veriﬁer’s challenge. The fourth and ﬁfth rules are similar to the ﬁrst two, specify-
ing when veriﬁer actually receives prover’s response and when he executes the instruction to remember
the time. Finally, the sixth rule speciﬁes that the veriﬁer grants access to the prover if he believes that the
distance to the prover is under the given bound.

Attack In-Between-Ticks

We now show how attack in-between-ticks is detected in our formalization.

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 19

T ime@T, V0 (P, NP, NV )@T1, E@T2, E@T3 −→

T ime@T, V1 (pending, P, NP, NV )@T, N S
T ime@T, V1 (pending, P, NP, NV )@T1, ClockV @T, P@T2 |

V (NP)@T, Start (P, NP, NV )@T

{ T ≥ T1 } −→

T ime@T, V1 (start, P, NP, NV )@T, ClockV @T, StartV (P, NP, NV )@T

T ime@T, P0 (V, NV , NP)@T1, N R

T ime@T, V1 (start, P, NP, NV )@T1, N R

P (NP)@T2 | { T ≥ T2 } −→
P (NV )@T

T ime@T, P1 (V, NV , NP)@T, N S
V (NV )@T2 −→

T ime@T, V2 (pending, P, NP, NV )@T, Stop (P, NP, NV )@T

T ime@T, V2 (pending, P, NP, NV )@T1, ClockV @T, E@T2 | { T ≥ T1 } −→

T ime@T, V2 (stop, P, NP, NV )@T, ClockV @T, StopV (P, NP, NV )@T

T ime@T, StartV (P, NP, NV )@T1, StopV (P, NP, NV )@T2, V2 (stop, P, NP, NV )@T3 |

{ T2 − T1 ≤ R, T ≥ T3 } −→ T ime@T, V3 (P)@T, N S

V (Ok(P))@T, E@T

Fig. 4. Protocol Rules for DB protocol

The initial conﬁguration contains facts T ime@0, ClockV @0 denoting that global time and time on

veriﬁer’s discrete time are initially set to 0.

Given the protocol speciﬁcation in Figure 4, attack in-between-ticks is represented with the following

conﬁguration:

{ Start (P, NP, NV )@T1, Stop (P, NP, NV )@T2, N S

V (Ok(P))@T3 } | { T2 − T1 > R }

It denotes that in the session involving nonces NP, NV the veriﬁer V has allowed the access to prover P
although the distance requirement has been violated.

Notice that such an anomaly is really possible in this speciﬁcation. Consider the following example:
veriﬁers actually sends the ﬁrst message at time 1.7 while the prover responds at time 4.9. Between
moments 1.7 and 4.9, there would be 3 ticks on the veriﬁer’s clock. The veriﬁer would consider starting
time of 2 and ﬁnishing time of 5, and conﬁrm with the time bound R = 3. Actually, the real round
trip time is greater than the time bound, namely 4.9 − 1.7 = 3.2. Following facts would appear in the
conﬁguration:

StartV (n)@2, StopV (n)@5, Start (n)@1.7, Stop (n)@4.9 .

Since 5 − 2 = 3 the last rule from Figure 4, the accepting rule, would apply resulting in the conﬁguration
containing the facts:

Start (p, nP, nV )@1.7, Stop (p, nP, nV )@4.9, N S

V (Ok(p))@5 .

Since 4.9 − 1.7 = 3.2 is greater than R = 3, this conﬁguration constitutes an attack.

Finally, notice as well that in our formalization in Figure 4, prover immediately responds to the re-
ceived challenge message, see the third rule in Figure 4. In reality there is some non-zero time of pro-

20 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

cessing of messages. This could cause additional discrepancy between the actual and the measured round
trip time. Namely, once the prover receives the challenge message he needs to check whether the nonce
received is the agreed value, previously exchanged with the veriﬁer. Then, he needs to compose the re-
sponse message for sending, using the stored nonce value. This process would take some additional time
which may be calculated in the design of the distance bounding protocol itself, i.e., in the established
bounding time of the protocol, R. The diﬀerence between expected and actual processing time can be the
source of further inaccuracy.

4. Attack in Between Ticks - A Full Probabilistic Analysis

In Section 2.2 we presented the novel attack which we believe can be carried out on most distance
bounding protocols. Our symbolic model described in Section 3 formally demonstrates that the attack
can, in principle, happen. In this section we investigate how likely it is for an attacker to carry out such an
attack. We explicitly calculate the probability of such an erroneous “acceptance event” happening based
on a single challenge/response time measurement. Such a “measurement phase” is an indispensable part
of any distance bounding protocol and a basis for the ultimate veriﬁer’s decision of whether to grant the
access or not.

Our main result of this section (Theorem 4.3) is to show that the attack is not so unlikely when the
prover is beyond the established perimeter up to a distance corresponding to a half-tick of the veriﬁer,
i.e., 3 meters in the scenario discussed in Section 2. The probability of distance measurement error is
of 1/2. This probability, however, reduces to zero once the prover is further away. That is, probability of
error is zero when the prover exceeds the perimeter at the distance corresponding to one tick or more.

The attack in-between-ticks is based on the discrepancy between the observable time interval t1 − t0,
(between the moment t0 when the time of sending the challenge message is recorded, and the moment t1
when the time of receiving the response message is recorded) and the actual time interval s1 − s0. Here,
s0, s1, t0 and t1 respectively denote the actual time when the challenge message is sent, and the actual
time of receiving the response, the recorded time of sending the challenge message, and the recorded
time of receiving the response message.

For our probabilistic analysis we consider the challenge-response protocol in which the veriﬁer reacts
as quick as possible but within the time constraints that only one operation can be executed in one clock
cycle.6

In a round of the challenge-response protocol the veriﬁer performs the following actions:

(1) At a moment s0 within an initial clock cycle 1, say s0 = 1 + X, veriﬁer sends a challenge message m.

Here X is a random variable distributed on the interval [0, 1

2 ] with its probability density fX.

(2) Just after that - that is, at a moment t0 within the next clock cycle 2, say t0 = 2 + Y, veriﬁer records
2 ] with its

the fact that m has been sent. Here Y is a random variable distributed on the interval [0, 1
probability density fY .

(3) At a moment s1 within the corresponding clock cycle (cid:98)s1(cid:99), say s1 = s0 + (cid:96), veriﬁer receives a re-

sponse message m(cid:48).

6From the performance point of view, the diﬀerence between discrete time and dense time is that, in contrast with dense
time, only a ﬁxed ﬁnite number of events may occur within a bounded time interval in the case of discrete time. Without loss of
generality, we allow here no more than one action be performed in one clock cycle.

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 21

Fig. 5. In diﬀerent ticks (Sequential Execution)

(4) Just after that, that is, at a moment t1 within the next clock cycle (cid:98)s1(cid:99) + 1, say t1 = ((cid:98)s1(cid:99) + 1) + Z,
veriﬁer records the fact that m(cid:48) has been received. Here Z is a random variable distributed on the
interval [0, 1

2 ] with its probability density fZ.

For the sake of perspicuity, we assume X, Y, and Z be independent random variables uniformly dis-

tributed on the interval [0, 1
Thus, we are dealing with the model given by the system as illustrated in Figure 5:

2 ].

s0 = 1 + X,
t0 = 2 + Y,

s1 = s0 + (cid:96),
t1 = (cid:98)s1(cid:99) + 1 + Z.

The decision rule applied by the veriﬁer is described bellow.

(15)

Deﬁnition 4.1. For a ﬁxed time response bound, an integer R, veriﬁer decides to grant the access to its
resources if and only if the following holds for the measured time interval t1 − t0:

t1 − t0 ≤ R.

Thus, the “Yes” decision taken by the veriﬁer is erroneous if in reality the actual distance between

veriﬁer and prover, s1 − s0, turns out to be larger than R, say by some positive value h.

We now investigate the probability of such an event actually occurring. Firstly, we deﬁne the required

probability.

Deﬁnition 4.2. For a ﬁxed time response bound, an integer R, and an extra, a positive h, we deﬁne the
probability of the erroneous decision to grant the access , perror(R, h),

perror(R, h) = Prob { t1 − t0 ≤ R / s1 − s0 = R + h }

(16)

as the conditional probability of an “acceptance event” of the form t1 − t0 ≤ R, given that
s1 − s0 = R + h.

12345ProverVeriﬁer’sClockChallengeMsgResponseMsgVeriﬁer6‘XYZs0s1t0t122 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

We calculate the probability of the erroneous decision, perror(R, h), and obtain the explicit values of
probabilities as stated in the theorem bellow. Recall that the protocol time response bound R and the
actual challenge-response time (cid:96) denote the respective round trip time of messages, and that in case of
an erroneous “Yes” decision taken by the veriﬁer, the value of h, h = (cid:96) − R, is positive. In such a case
prover that is outside of the perimeter speciﬁed by the value R
2 appears within the perimeter from the
point of view of the veriﬁer.

The obtained results are visualized in Figure 6 which shows how the conditional probability of erro-
neous decision, perror(R, h), is classiﬁed w.r.t. time distances between the veriﬁer and the prover. This
probability is non-zero when the prover is in the zone close to the perimeter, on the outskirts up to 1
2 tick
time distance which is 1 tick in the round trip time.

Theorem 4.3. Let X, Y and Z be independent random variables uniformly distributed on [0, 1
2 ]. Then,
for a ﬁxed time response bound, an integer R, and an extra, a positive h, the probability of the erroneous
decision to grant the access, perror(R, h), is given by

perror(R, h) =






1
2 ,
1 − h,

if 0 < h ≤ 1
2 ,
1
2 < h < 1,

if

0,

if h ≥ 1.

(17)

Theorem 4.3 provides the explicit probability of veriﬁer making an erroneous decision to grant access

to a prover that is located outside of the perimeter speciﬁed by the protocol distance bound, R.

In particular, for 1

2 < h < 1, i.e., when the prover is between “half a tick” and “a single tick” further
away form the speciﬁed perimeter, the probability of the erroneous decision decreases with h. In the case
that the distance of the prover exceeds the upper bound by a “tick” or more, the probability of veriﬁer

“perror(R, h) > 0”

“perror(R, h) = 0”

1/2
(cid:122)(cid:32)(cid:125)(cid:124)(cid:32)(cid:123)

•
•
(cid:64)

Veriﬁer
(cid:64)

(cid:64)

(cid:64)

(cid:64)

(cid:64)(cid:64)(cid:82)

(cid:96)/2

(cid:63)
R/2

Fig. 6. Towards Theorem 4.3. Conditional probability of erroneous decision perror(R, h) classiﬁed w.r.t. round trip time
distances, R and (cid:96), between veriﬁer and prover. The Veriﬁer is at the center of the circles. The inner circle represents the distance
bounding area. The outer circle is the actual area where Prover can be granted access with probability greater than zero.

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 23

making the erroneous decision is zero. This is not surprising, given the nature of the attack in-between-
ticks.

However, notice that, contrary to our expectations, the probability of the erroneous decision turns out
to be 50% for any 0 < h ≤ 1
2 . That is, the probability of error is rather high when the prover is close to
the bound, under “half a tick” distance form the perimeter. This extra time distance would amount to up
to 3 meters in our example given earlier in the paper, which is not negligible.

The remainder of this section contains the proof of Theorem 4.3. A reader that is not that interested in

this more technical part of this section, can jump to Section 5.

4.1. Proof of Theorem 4.3

In order to prove Theorem 4.3 we introduce some auxiliary machinery.

Deﬁnition 4.4. To investigate perror(R, h), we introduce the following distribution function F(cid:96)(x)

F(cid:96)(x) = Prob { t1 − t0 ≤ x / s1 − s0 = (cid:96) }

(18)

deﬁned as the conditional probability of the event t1 − t0 ≤ x, given the actual time interval s1 − s0 = (cid:96).

In Figures 7 and 8 we illustrate the two cases of the graph of the conditional probability density, the

derivative F(cid:48)

(cid:96)(x), for the distribution function F(cid:96)(x).

Notice that, with (cid:96) = R + h, we have: perror(R, h) = F(cid:96)(R) = (cid:82) R

−∞ F(cid:48)

(cid:96)(x) dx.

The following lemmas provide an explicit expression for the distribution function F(cid:96)(x) and its density
(cid:96)(x). Let here, and henceforth, (cid:101)(cid:96) denote the decimal part of (cid:96): (cid:101)(cid:96) = (cid:96) − (cid:98)(cid:96)(cid:99).
F(cid:48)

Lemma 4.5. In the model (15) we are dealing with the observable period of time t1 − t0 that is calcu-
lated as:

t1 − t0 = (cid:98)X + (cid:101)(cid:96)(cid:99) + (cid:98)(cid:96)(cid:99) + Z − Y =

Proof. By simple calculation,






(cid:98)(cid:96)(cid:99) + Z − Y,

(cid:98)(cid:96)(cid:99) + Z − Y,

1 + (cid:98)(cid:96)(cid:99) + Z − Y,

if (cid:101)(cid:96) ≥ 1

if (cid:101)(cid:96) < 1
2 ,
2 but X + (cid:101)(cid:96) < 1,
2 and X + (cid:101)(cid:96) ≥ 1.

if (cid:101)(cid:96) ≥ 1

t1 − t0 = (cid:98)1 + X + (cid:96)(cid:99) + 1 + Z − (2 + Y) = (cid:98)X + (cid:101)(cid:96)(cid:99) + (cid:98)(cid:96)(cid:99) + Z − Y

(19)

(cid:3)

Lemma 4.6. Let X, Y and Z be independent random variables uniformly distributed on [0, 1
2 ]. Then for
the distribution function F(cid:96)(x) given by F(cid:96)(x) = Prob { t1 − t0 ≤ x / s1 − s0 = (cid:96) }, the following holds:

24 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

2
(cid:65)
(cid:1)
(cid:65)

(cid:1)
(cid:1)
(cid:1)

(cid:65)
(cid:65)
(cid:65)

(cid:1)
(cid:1)
(cid:1)

(cid:1)
(cid:1)
(cid:1)
•
(cid:98)(cid:96)(cid:99) − 1
2

•
(cid:98)(cid:96)(cid:99)

(cid:65)
(cid:65)
(cid:65)

(cid:96)

(cid:65)
(cid:65)
•
(cid:98)(cid:96)(cid:99)+ 1
2

•
(cid:98)(cid:96)(cid:99) + 1 (cid:98)(cid:96)(cid:99) + 3
2

•

(cid:45)

Fig. 7. The graph of the probability density, F(cid:48)
(cid:101)(cid:96) = (cid:96) − (cid:98)(cid:96)(cid:99) < 1
2 .

(cid:96)(x), for the distribution F(cid:96)(x) - The single-humped (“Dromedary camel”) case:

4(cid:101)(cid:96) − 2
(cid:1)
(cid:65)
(cid:1)

(cid:65)
(cid:65)
(cid:65)

(cid:65)
(cid:65)
(cid:65)

(cid:65)
(cid:65)
(cid:65)
•

•
(cid:98)(cid:96)(cid:99) + 1 (cid:98)(cid:96)(cid:99) + 3
2

(cid:45)

(cid:1)
(cid:1)
(cid:1)

(cid:96)

4 − 4(cid:101)(cid:96)
(cid:64)

(cid:0)

(cid:0)

(cid:0)

(cid:64)

(cid:64)

(cid:0)

(cid:0)
•
(cid:98)(cid:96)(cid:99) − 1
2

•
(cid:98)(cid:96)(cid:99)

(cid:1)
(cid:1)
(cid:1)

(cid:64)

(cid:1)
(cid:1)
(cid:64)
•
(cid:98)(cid:96)(cid:99) + 1
2

Fig. 8. The graph of the probability density, F(cid:48)
of bimodal distribution: (cid:101)(cid:96) = (cid:96) − (cid:98)(cid:96)(cid:99) > 1
2 .

(cid:96)(x), for the distribution function F(cid:96)(x) - The 2-humped (“Bactrian camel”) case

(i) In the case of (cid:101)(cid:96) = (cid:96) − (cid:98)(cid:96)(cid:99) < 1
2 ,

F(cid:96)(x) = Prob { Z − Y ≤ x − (cid:98)(cid:96)(cid:99) }

(ii) In the case of (cid:101)(cid:96) = (cid:96) − (cid:98)(cid:96)(cid:99) ≥ 1
2 ,

(20)

F(cid:96)(x) = (2 − 2(cid:101)(cid:96)) · Prob { Z − Y ≤ x − (cid:98)(cid:96)(cid:99) } + (2(cid:101)(cid:96) − 1) · Prob { Z − Y ≤ x − (cid:98)(cid:96)(cid:99) − 1 }

(21)

Proof. Given the condition s1 − s0 = (cid:96), we deal the following two cases.
(i) In the case of (cid:101)(cid:96) = (cid:96) − (cid:98)(cid:96)(cid:99) < 1

2 , by Lemma 4.5, t1 − t0 = (cid:98)(cid:96)(cid:99) + Z − Y, and, respectively,

F(cid:96)(x) = Prob { (cid:98)(cid:96)(cid:99) + Z − Y ≤ x } = Prob { Z − Y ≤ x − (cid:98)(cid:96)(cid:99) }

In Figure 7 we draw the graph of the conditional probability density, F(cid:48)
(cid:96)(x), for the distribution
function F(cid:96)(x) in the case of the uniformly distributed Z and Y. The height of the triangle there is 2.

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 25

2
(cid:65)
(cid:1)
(cid:65)

(cid:1)
(cid:1)
(cid:1)

(cid:65)
(cid:65)
(cid:65)

(cid:65)
(cid:65)
h
(cid:122)(cid:32)(cid:32)(cid:32)(cid:125)(cid:124)(cid:32)(cid:32)(cid:32)(cid:123)
(cid:65)
R
(cid:96)
•
(cid:98)(cid:96)(cid:99)

(cid:1)
(cid:1)
(cid:1)

(cid:1)
(cid:1)
(cid:1)
•
(cid:98)(cid:96)(cid:99) − 1
2

(cid:65)
(cid:65)
•
(cid:98)(cid:96)(cid:99)+ 1
2

•
(cid:98)(cid:96)(cid:99) + 1 (cid:98)(cid:96)(cid:99) + 3
2

•

(cid:45)

Fig. 9. Probability of the erroneous decision to grant the access, perror(R, h) - The single-humped case.

(cid:1)
(cid:1)
(cid:1)

4 − 4(cid:101)(cid:96)
(cid:64)

(cid:0)

(cid:0)

(cid:0)

(cid:0)

(cid:0)
•
(cid:98)(cid:96)(cid:99) − 1
2

(cid:64)

(cid:64)

(cid:1)
(cid:1)
h
(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)
(cid:1)
(cid:64)
(cid:1)
R
(cid:96)
(cid:1)
(cid:64)
•
•
(cid:98)(cid:96)(cid:99)
(cid:98)(cid:96)(cid:99) + 1
2

4(cid:101)(cid:96) − 2
(cid:1)
(cid:65)
(cid:1)

(cid:65)
(cid:65)
(cid:65)

(cid:65)
(cid:65)
(cid:65)

(cid:65)
(cid:65)
(cid:65)
•

•
(cid:98)(cid:96)(cid:99) + 1 (cid:98)(cid:96)(cid:99) + 3
2

(cid:45)

Fig. 10. Probability of the erroneous decision to grant the access, perror(R, h) - The 2-humped (“Bactrian camel”) case.

(ii) In the case of (cid:101)(cid:96) = (cid:96) − (cid:98)(cid:96)(cid:99) ≥ 1

2 , by Lemma 4.5 we have:

F(cid:96)(x) = Prob{X + (cid:101)(cid:96) < 1} · Prob { (cid:98)(cid:96)(cid:99) + Z − Y ≤ x } + Prob{X + (cid:101)(cid:96) ≥ 1} · Prob { 1 + (cid:98)(cid:96)(cid:99) + Z − Y ≤ x }.

Notice that for the X uniformly distributed on [0, 1

2 ]:

Prob{X + (cid:101)(cid:96) < 1} = Prob{X < 1 − (cid:101)(cid:96)} = 2(1 − (cid:101)(cid:96)),

resulting in

F(cid:96)(x) = (2 − 2(cid:101)(cid:96)) · Prob { Z − Y ≤ x − (cid:98)(cid:96)(cid:99) } + (2(cid:101)(cid:96) − 1) · Prob { Z − Y ≤ x − (cid:98)(cid:96)(cid:99) − 1 }

In Figure 8 we draw the graph of the conditional probability density, the derivative F(cid:48)
(cid:96)(x), for the
distribution function F(cid:96)(x) in the case of the uniformly distributed X, Z and Y. The height of the
left triangle in Figure 8 is 4 − 4(cid:101)(cid:96), and the height of the right triangle is 4(cid:101)(cid:96) − 2.

(cid:3)

We are now ready to prove the main theorem.

26 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

Proof of Theorem 4.3.
Recall that X, Y and Z are independent random variables uniformly distributed on [0, 1
Given an integer R, here (cid:96) = R + h and h = (cid:101)(cid:96) = (cid:96) − (cid:98)(cid:96)(cid:99).
(i) In the case of 0 < h ≤ 1

2 , we have (cid:98)(cid:96)(cid:99) = R,

2 ].

h = (cid:96) − R = (cid:96) − (cid:98)(cid:96)(cid:99) = (cid:101)(cid:96) ≤

1
2

,

and, by Lemma 4.6 (see Figure 9)

perror(R, h) =

(cid:90) (cid:98)(cid:96)(cid:99)

−∞

(cid:96)(x) dx = 1
F(cid:48)
2

(ii) In the case of 1

2 < h < 1, we have (cid:98)(cid:96)(cid:99) = R,

h = (cid:96) − R = (cid:96) − (cid:98)(cid:96)(cid:99) = (cid:101)(cid:96) >

1
2

,

and, by Lemma 4.6 (see Figure 10)

perror(R, h) =

(cid:90) (cid:98)(cid:96)(cid:99)

−∞

(cid:96)(x) dx = 1
F(cid:48)
2

· Prob{X + (cid:101)(cid:96) < 1} = 1
2

· 2(1 − (cid:101)(cid:96)) = 1 − h

(iii) Lastly, in the case of h > 1, we have R ≤ (cid:98)(cid:96)(cid:99) − 1, and (see Figures 9 and 10)

perror(R, h) ≤

(cid:90) (cid:98)(cid:96)(cid:99)−1

−∞

F(cid:48)
(cid:96)(x) dx = 0.

which completes the proof of Theorem 4.3.

(cid:3)

5. Implementation in Maude

We have formalized the scenario of the attack in-between-ticks in an extension with SMT-solver of the
rewriting logic tool Maude. The tool was able to automatically ﬁnd this attack. We considered a scenario
with two players, a veriﬁer (v) and a prover (p) such that messages take dvp time units to navigate from
one another. The function recSend(PV) returns v if PV is p and vice-versa.

Although the speciﬁcation detailed in Section 3.4 could be speciﬁed in Maude, it would be impractical
to use it to search for an attack as the state space is inﬁnite. Moreover, using the machinery of circle-
conﬁgurations described in Section 6, although resulting in a ﬁnite search space, is still intractable.

Instead, we show in this section that by using constrained variables and relying on SMT solvers allows
us to verify distance bounding protocols in practice. During veriﬁcation (search), the variables in the time
constraints are not instantiated, but are accumulated. The SMT solver is, then, used to determine whether
a set of accumulated constraints (in a branch of search) is consistent. If it is consistent, then search may
proceed; otherwise, Maude backtracks and continues with the veriﬁcation.

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 27

crl [Network]:

{ S (Time @ T) (Ns(PV,M) @ T1) } =>
{ S (Time @ T2) (Nr(VP,M) @ T2) }

if (T2 >= T1 + dvp and (T2 >= T)) = true /\ VP := recSend(PV) [nonexec] .

crl [Tick]:

{ S (Time @ T) (vTime @ T1) } =>
{ S (Time @ T2) (vTime @ T1) }
if (T2 > T and (T2 < T1 + 1/1))

= true [nonexec] .

crl [Tick-Vclock]:

{ S (Time @ T) (vTime @ T1) } =>
{ S (Time @ T1 + 1/1) (vTime @ T1 + 1/1) }

if (T1 + 1/1 >= T)

= true [nonexec] .

crl [Real-V-Send]:

{ S (Time @ T) (V0(P,NP,NV) @ T1)
{ S (Time @ T) (V1(pending,P,NP,NV) @ T)
(Start(P,NP,NV) @ T) (Ns(p,NP) @ T ) }

} =>

if (T1 + 1/1 > T and T >= T1 )

= true [nonexec] .

crl [Real-P-Rcv]:

{ S (Time @ T) (P0(V,NV,NP) @ T1) (Nr(p,NP) @ T2) } =>
{ S (Time @ T3) (P1(V,NV,NP) @ T3) (Ns(p,NV) @ T3)}

if ((T2 >= T) and (T3 >= T2)) = true [nonexec] .

crl [Real-V-Rec]:
{ S (Time @ T) (V1(start,P,NP,NV) @ T1) (Nr(v,NV) @ T2 ) } =>
{ S (Time @ T2) (V2(pending,P,NP,NV) @ T2) (Stop(P,NP,NV) @ T2)
if (T2 >= T ) = true [nonexec] .

}

crl [Dis-V-Rec]:

{ S (Time @ T) (vTime @ T1) (V2(pending,P,NP,NV) @ T2) } =>
{S (Time @ toReal(toInteger(T2)) + 1/1) (vTime @ toReal(toInteger(T2)) + 1/1)

(V2(stop,P,NP,NV) @ toReal(toInteger(T2)) + 1/1)
(StopV(P,NP,NV) @ toReal(toInteger(T2)) + 1/1) }

if ( (T2 >= T1)) = true [nonexec] .

crl [ok]:

{ S (Time @ T) (StartV(P,NP,NV) @ T1) (StopV(P,NP,NV) @ T2) (V2(stop,P,NP,NV) @ T3)} =>
{S (Time @ T) (Ok(P) @ T) }

if (T2 - T1 <= 2/1 * 3/1)

= true [nonexec] .

Fig. 11. Rewrite Rules Speciﬁcation of a Distance Bounding Protocol in Maude

28 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

The modiﬁcations to the theory in Section 3.4 are minor simply those involving the constrained vari-
ables. The Maude rewrite rules are depicted in Figure 11. To illustrate the use of SMT, consider the
Network rule. It speciﬁes that a message sent Ns(P,M) at time T1 can be received at any time T2 such
that T2 >= T1 + dvp and T2 >= T. Notice that Maude does not instantiate these time variables with
concrete values, but only with time symbols accumulating time constraints. Maude backtracks whenever
the collection of accumulated constraints is unsatisﬁable.

Our formalization encodes the Tick rule in the MSR theory which advances global time by any real
number using two rewrite rules Tick and Tick-Vclock. The former rewrite rule advances time to any
value T2 within the veriﬁer’s current clock cycle. This is speciﬁed by the constraint T2 < T1 + 1/1. The
second rewrite advances time to the beginning of the next veriﬁer’s clock cycle (T1 + 1/1). Intuitively,
we consider a veriﬁer’s clock cycle as an event thus controlling how time advances and avoiding state
space explosion.

A second diﬀerence to the the theory in Section 3.4 is that we assume a powerful veriﬁer which mea-
sures the time of sending and receiving a message exactly at the beginning of clock cycle following the
time when message is actually sent and received. This is speciﬁed, for example, by the rule Dis-V-Rec,
in particular, by using the timestamp toReal(toInteger(T2)) + 1/1 where 1/1 represents the real
number one. If there is an attack with this more powerful veriﬁer, then there is an attack in a less powerful
veriﬁer, i.e., it is sound.

Finally, the third diﬀerence is on the way time advances. While it is convenient to separate the tick
rules from the instantaneous rules in our theoretical framework as described in Section 3, this distinction
increases considerably search space. Instead, we advance time according to the events processed. This
is similar to the behavior of Real-Time Maude [35], but here we use time symbols. Thus, whenever a
message is received or sent or whenever the veriﬁer’s clock ticks, global time advances to the time of the
corresponding event. For example, in rule Real-P-Rcv, the global time advances to a time T3 greater
than the time, T2, when a message is received. This time sampling is sound as no events are processed
before they should, e.g., a message is not received before the corresponding time to travel elapses.

For completeness, it seems possible to apply results from the literature, e.g., the completeness results
of the time sampling used by Real-Time Maude [36]. More recently, Nigam et al. [34] have proved the
completeness of time intruders using symbolic time constraints.

We used the smt-search to ﬁnd a symbolic representation of a family of attacks. Using Maude SMT
the potentially inﬁnite search space becomes ﬁnite, by treating the distance between the veriﬁer and the
prover as a constrained variable.

As an example, we considered the distance bound to be 3 and set (dva > 3/1) = true which means

that the prover should not succeed the distance bound challenge as shown below:

Maude> smt-search [1]
{ (Time @ 0/1) (vTime @ 0/1) (V0(p,n(0),n(10)) @ 0/1) (P0(v,n(10),n(0)) @ 0/1) (dist(dvp)) }

=>+

{ (Ok(p) @ T:Real) S:Soup }
such that (dva > 3/1) = true .

The following (simpliﬁed) solution is obtained after few seconds (ca 10 seconds) of computation:

S --> ...
(Time @ toReal(toInteger(#3-T2:Real)) + 1/1)

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 29

(Start(p, n(0), n(10)) @ 0/1) (Stop(p, n(0), n(10)) @ #3-T2:Real)
V2(stop,p,n(0),n(10)) @ toReal(toInteger(#3-T2:Real)) + 1/1
where dvp > 3/1
...
and (#1-T2:Real >= 0/1 + dvp) and (#1-T2:Real >= #1-T2:Real and #2-T3:Real >= #1-T2:Real)
and (#3-T2:Real >= #2-T3:Real + dvp) and #3-T2:Real >= #3-T2:Real
and toReal(toInteger(#3-T2:Real)) + 1/1 - (0/1 + 1/1) <= 2/1 * 3/1

It states that the veriﬁer grants the resource to the prover, as the message Ok has been sent, although

the prover is further away than the distance bound of 3.

6. Circle-Conﬁgurations

This Section introduces the machinery, called Circle-Conﬁgurations, that can symbolically represent
conﬁgurations and plans that mention dense time. Dealing with dense time leads to some diﬃculties,
which have puzzled us for some time now, in particular, means to handle Zeno paradoxes. When we use
discrete domains to represent time, such as the natural numbers, time always advances by one, speciﬁed
by the rule:

T ime@T −→ T ime@(T + 1)

There is no other choice.7 On the other hand, when considering systems with dense time, the problem
is much more involved, as the non-determinism is much harder to deal with: the value that the time
advances, the ε in

T ime@T −→ T ime@(T + ε)

can be instantiated by any positive real number.

Our claim is that we can symbolically represent any plan involving dense time by using a canoni-
cal form called circle-conﬁgurations. We show that circle-conﬁgurations provide a sound and complete
representation of plans with dense time (Theorem 6.4).

Recall Deﬁnition 3.6 and Theorem 3.8 where we show that the introduced equivalence between con-
ﬁgurations corresponds to the reachability problem in the sense that a solution of a reachability problem
is independent of the choice of equivalent (initial) conﬁgurations. Indeed, we will show that using circle-
conﬁgurations we can symbolically represent the entire class of equivalent conﬁgurations and, moreover,
we can consider reachability problem over circle-conﬁgurations.

A circle-conﬁguration consists of two components: a δ-Conﬁguration, ∆, and a Unit Circle, U, written
(cid:104)∆, U(cid:105). Intuitively, the former accounts for the integer part of the timestamps of facts in the conﬁguration,
while the latter deals with the decimal part of the timestamps.

In order to deﬁne these components, however, we need some additional machinery. For a real-number,
r, int (r) denotes the integer part of r and dec (r) its decimal part. For example, int (2.12) is 2 and

7However, as time can always advance, a plan may use an unbounded number of natural numbers. This source of unbound-

edness was handled in our previous work [25]. This solution, however, does not scale to dense time.

30 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

dec (2.12) is 0.12. Given a natural number Dmax, the truncated time diﬀerence (w.r.t. Dmax) between two
facts P@tP and Q@tQ such that tQ ≥ tP is deﬁned as follows

(cid:40)

δP,Q =

int (tQ) − int (tP), if int (tQ) − int (tP) ≤ Dmax
∞, otherwise

For example, if Dmax = 3 for the facts F@3.12, G@1.01, H@5.05 we have δF,H = 2 and δG,H = ∞.
Notice that whenever we have δP,Q = ∞ for two timestamped facts, P@tP and Q@tQ, we can infer that
tQ > tP + D for any natural number D in the theory. Thus, we can truncate time diﬀerence without
sacriﬁcing soundness and completeness. This was pretty much the idea used in [25] to handle systems
with discrete-time.

δ-Conﬁguration
We now explain the ﬁrst component, ∆, of circle-conﬁgurations, (cid:104)∆, U(cid:105), namely the δ-conﬁguration, to
only later enter into the details of the second component.

Given a conﬁguration S = {F1@t1, . . . , Fn@tn, T ime@t}, we construct its δ-conﬁguration as follows:
We ﬁrst sort the facts using the integer part of their timestamps, obtaining the sequence of timestamped
i+1 for 1 ≤ i ≤ n + 1 and {Q1, . . . , Qn+1} = {F1, . . . , Fn, T ime}.
facts Q1@t(cid:48)
We then aggregate in classes facts with the same integer part of the timestamps obtaining a sequence of
classes

1, . . . , Qn+1@t(cid:48)

n+1, where t(cid:48)

i ≤ t(cid:48)

{Q1

1, . . . , Q1
m1

}, {Q2

1, . . . , Q2
m2

}, . . . , {Q j

1, . . . , Q j

m j} ,

where δQk

i ,Qk
j

= 0 for any 1 ≤ i ≤ mk and 1 ≤ k ≤ j, and {Q1

1, . . . , Q j

m j} = {Q1, . . . , Qn+1}.

The δ-conﬁguration of S is then:

∆ = (cid:68)

{Q1

1, . . . , Q1
m1

}, δ1,2, {Q2

1, . . . , Q2
m2

}, . . . , {Q j−1

1

, . . . , Q j−1

m j−1}, δ j−1, j, {Q j

1, . . . , Q j

m j}

(cid:69)

where δi,i+1 = δQi
1,Qi+1
For such a δ-conﬁguration, ∆, we deﬁne

1

is the truncated time diﬀerence between the facts in class i and class i + 1.

∆(Ql

i, Qh

j) =






k=h−1(cid:80)
k=l
k=l−1(cid:80)
k=h

−

δk,k+1

if h ≥ l

δk,k+1 otherwise

which is the truncated time diﬀerence between any two facts of ∆, Ql
j from the classes l and
h, respectively. Here we assume ∞ is the addition absorbing element, i.e., ∞ + D = ∞ for any natural
number D and ∞ + ∞ = ∞.

i and Qh

Notice that, for a given upper bound Dmax, diﬀerent conﬁgurations may have the same δ-conﬁguration.

For example, with Dmax = 4, conﬁgurations

S1 = { M@3.01, R@3.11, P@4.12, T ime@11.12, Q@12.58, S @14 }
= { M@0.2, R@0.5, P@1.6, T ime@6.57, Q@7.12, S @9.01 }

S(cid:48)
1

and

(22)

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 31

have both the following δ-conﬁguration:

∆S1

= (cid:104) {M, R}, 1, {P}, ∞, {T ime}, 1, {Q}, 2, {S } (cid:105).

This δ-conﬁguration speciﬁes the truncated time diﬀerences between the facts from S(cid:48)
1. For example,
∆S1(R, P) = 1, that is, the integer part of the timestamp of the fact P is ahead one unit with respect to the
integer part of the timestamp of the fact R. Moreover, the timestamp of the fact T ime is more than Dmax
units ahead with respect to the timestamp of P. This is indeed true for both conﬁgurations S1 and S(cid:48)
1
given above.

Unit Circle
In order to handle the decimal part of the timestamps, we use intervals instead of concrete values. These
intervals are represented by a circle, called Unit Circle, which together with a δ-conﬁguration composes a
circle-conﬁguration. The unit circle of a conﬁguration S = {F1@t1, . . . , Fn@tn, T ime@t} is constructed
by ﬁrst ordering the facts from S according to the decimal part of their timestamps in the increasing order.
In such a way we obtain the sequence of facts Q1, . . . , Qn+1, where {Q1, . . . , Qn+1} = {F1, . . . , Fn, T ime}.
Then the unit circle of the given conﬁguration S is obtained by aggregating facts that have the same
decimal part obtaining a sequence of classes:

U = [ {Q0

1, . . . , Q0
m0

}Z, {Q1

1, . . . , Q1
m1

}, . . . , {Q j

1, . . . , Q j

m j} ]

1, . . . , Q j
m j} = {Q1, . . . , Qn+1}, the facts in the same class have the same decimal part, i.e.,
where {Q1
k) = dec (Qi
dec (Qi
l), for all 1 ≤ k ≤ mi, 1 ≤ l ≤ mi and 1 ≤ i ≤ j, classes are ordered in the increasing
k) < dec (Qi(cid:48)
i (cid:44) i(cid:48), where 1 ≤ k ≤ mi, 1 ≤ l ≤ mi(cid:48), 0 ≤ i ≤ j, 1 ≤ i(cid:48) ≤ j,
order, i.e., dec (Qi
l ) for all
and the ﬁrst class {Q0
1, . . . , Q0
}Z, marked with the subscript Z contains all facts whose timestamp’s
m1
i ) = 0, for 1 ≤ i ≤ m0.
decimal part is zero, i.e., dec (Q0
1, . . . , Q0
}Z the Zero Point. Notice that the zero point may be empty.
m1
j) = i to denote the class in which the fact Qi

We call the class {Q0
For a unit circle, U, we deﬁne: U(Qi

j appears in U.

For example, the unit circle of conﬁguration S1 given in (22) is the sequence:

US1

= [ {S }Z, {M}, {R}, {P, T ime}, {Q} ] .

Notice that P and T ime are in the same class as the decimal parts of their timestamps are the same,
namely 0.12. Moreover, we have that US1(S ) = 0 < 2 = US1(R), specifying that the decimal part of the
timestamp of the fact R is greater than the decimal part of the timestamp of the fact S .

We will graphically represent a unit circle as shown in Figure 12. The (green) ellipse at the top of
the circle marks the zero point, while the remaining classes are placed on the circle in the (red) squares
ordered clockwise starting from the zero point. Thus, from the above graphical representation it can be
seen that the decimal part of the timestamp of the fact Q1
1 is smaller than the decimal of the timestamp of
the fact Q2
2 are equal. The exact points
where the squares are placed are not important, only their relative positions matter, e.g., the square for
the class containing the fact Q1
1 should be placed on the circle somewhere in between the zero point and
the square for the class containing the fact Q2

1, while the decimal part of the timestamps of the facts Qi

1 and Qi

1, clockwise.

32 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

Fig. 12. Unit Circle

Deﬁnition 6.1. Let T be a reachability problem, Dmax an upper bound on the numeric values appearing
in T and S = { F1@t1, F2@t2, . . . , Fn@tn, T ime@t }. Let

∆S = (cid:68)

{P1

1, . . . , P1
m1

}, δ1,2, {P2

1, . . . , P2
m2

}, . . . {P j−1

1

, . . . , P j−1

m j−1}, δ j−1, j, {P j

1, . . . , P j

m j}

(cid:69)

1, . . . , P1

where {P1
mi have the same
integer part, t i, ∀i = 1, . . . , j , and δi,i+1 is the truncated time diﬀerence (w.r.t. Dmax) between a fact in
class i and a fact in class i + 1. Let

m j} = {F1, . . . , Fn, T ime}, timestamps of facts Pi

1, . . . , Pi

m1, P2

1, . . . , P j

US = [ {Q0

1, . . . , Q0
m0

}Z, {Q1

1, . . . , Q1
m1

}, . . . , {Qk

1, . . . , Qk
mk

} ]

m0, Q1

1, . . . , Q0

1, . . . , Qk
mk

1, . . . , Qi
where {Q0
mi have the
same decimal part, ∀i = 0, . . . , k , and timestamps of facts Q0
m0 are integers. We say that ∆S is
the δ-conﬁguration of S, US is the unit-circle of S, and AS = (cid:104)∆S, US(cid:105) is the circle-conﬁguration of
the conﬁguration S (or the circle-conﬁguration corresponding to S).

timestamps of facts Qi
1, . . . , Q0

} = {F1, . . . , Fn, T ime},

For example, with Dmax = 4, conﬁguration

S1 = { M@3.01, R@3.11, P@4.12, T ime@11.12, Q@12.58, S @14 }

(23)

has the circle-conﬁguration (cid:104)∆S1, US1(cid:105), where

∆S1
US1

= (cid:104) {M, R}1, {P}, ∞, {T ime}, 1, {Q}, 2, {S } (cid:105)
= [ {S }Z, {M}, {R}, {P, T ime}, {Q} ] ,

as depicted in Figure 13 .

For simplicity, we sometimes write A and (cid:104)∆, U(cid:105) instead of AS and (cid:104)∆S, US(cid:105), when the corresponding

conﬁguration is clear from the context.

Notice that δi,i+1 is well deﬁned, since all the facts in the same class Pk

1, . . . , Pk

mk have the same integer

part, t k, ∀k = 1, . . . , j. Namely,

δi,i+1 = δQi

1,Qi+1

1

(cid:40)

=

t i+1 − t i,
∞,

t i+1 − t i ≤ Dmax

if
otherwise

,

i = 1, . . . , j − 1 .

Q11,...,Q1m1Qi1,...,QimiQj1,...,QjmjQ01,...,Q0m0M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 33

Fig. 13. Circle-Conﬁguration

6.1. Constraint Satisfaction

A circle-conﬁguration (cid:104)∆, U(cid:105) contains all the information needed in order to determine whether a

constraint of the form used in our model, i.e., given in (6), is satisﬁed or not.

Consider the circle-conﬁguration in Figure 13 which corresponds to conﬁguration S1 given in (23).
To determine, for instance, whether tQ > tT ime + 1, we compute the integer diﬀerence between tQ and
tT ime from the δ-conﬁguration. This turns out to be 1 and means that we need to look at the decimal part
of these timestamps to determine whether the constraint is satisﬁed or not. Since the decimal part of tQ
is greater than the decimal part of tT ime, as can be observed in the unit circle, we can conclude that the
constraint is satisﬁed. Similarly, one can also conclude that the constraint tQ > tT ime + 2 is not satisﬁed
as int (tQ) = int (tT ime) + 1. The following results formalize this intuition.

Lemma 6.2. Let (cid:104)∆, U(cid:105) be a circle-conﬁguration of the conﬁguration S. Then for two arbitrary facts
P@tp and Q@tQ in S and a natural number D < Dmax the following holds:
– tP > tQ + D iﬀ ∆(Q, P) > D or ( ∆(Q, P) = D and U(P) > U(Q) ) ;
– tP > tQ − D iﬀ ∆(P, Q) < D or ( ∆(P, Q) = D and U(P) > U(Q) ) ;
– tP = tQ + D iﬀ ∆(Q, P) = D and U(Q) = U(P);
– tP = tQ − D iﬀ ∆(P, Q) = D and U(Q) = U(P);

Proof. Let tP ≥ tQ. Recall that, as per deﬁnition of circle-conﬁgurations, there are i and j such that
Q = Qi and P = Q j, and that

∆(Q, P) = ∆(Qi, Q j) = (cid:80) δk,k+1

= int (Q j) − int (Q j−1) + int (Q j−1) − int (Q j−2) + · · · − int (Qi)
= int (Q j) − int (Qi) = int (P) − int (Q)

Then, for a natural number D ≤ Dmax it holds that

tP = tQ + D iﬀ int (tP − tQ) = D and dec (tP − tQ) = 0

iﬀ ∆(Q, P) = D and U(Q) = U(P)

because dec (tP) = dec (tQ) implies int (tP − tQ) = D iﬀ int (tP) − int (tQ) = D. Similarly,

tP > tQ + D iﬀ int (tP − tQ) > D or
∆(Q, P) > D or

iﬀ

(cid:0) int (tP − tQ) = D and dec (tP − tQ) > 0 (cid:1)
(cid:0) ∆(Q, P) = D and U(P) > U(Q) (cid:1)

The remaining cases are proven similarly.

(cid:3)

SMP,TimeQh{M,R},1,{P},∞,{Time},1,{Q},2,{S}iR34 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

Following the above result we say that a circle-conﬁguration (cid:104)∆, U(cid:105) corresponding to a conﬁguration
S satisﬁes the constraint c if the conﬁguration S satisﬁes the constraint c. We also say that a circle-
conﬁguration is a goal circle-conﬁguration if it corresponds to a goal conﬁguration. Furthermore, we also
say that an action is applicable to a circle-conﬁguration if that action is applicable to the corresponding
conﬁguration.

6.2. Rewrite Rules and Plans with Circle-Conﬁgurations

This section shows that given a reachability problem with a set of rules, R, involving dense time, and
an upper bound on the numbers appearing in the problem, Dmax, we can compile a set of rewrite rules,
A, over circle-conﬁgurations. Moreover, we show that any plan generated using the rules from R can
be soundly and faithfully represented by a plan using the set of rules A. We ﬁrst explain how we apply
instantaneous rules to circle-conﬁgurations and then we explain how to handle the time advancement
rule.

Instantaneous Actions

Let Dmax be an upper bound on the numeric values in the given problem and let the following rule be

an instantaneous rule (see Section 3.1) from the set of actions R:

T ime@T, W1@T1, . . . , Wk@Tk, F1@T (cid:48)

1, . . . , Fn@T (cid:48)

n | C −→

∃ (cid:126)X. [ T ime@T, W1@T1, . . . , Wk@Tk, Q1@(T + D1), . . . , Qm@(T + Dm) ]

The above rule is compiled into a sequence of operations that may rewrite a given circle-conﬁguration
(cid:104)∆, U(cid:105) into another circle-conﬁguration (cid:104)∆1, U1(cid:105) as follows:
(1). Check whether there are occurrences of W1, . . . , Wk and F1, . . . , Fn in (cid:104)∆, U(cid:105) such that the guard
C is satisﬁed by (cid:104)∆, U(cid:105). If it is the case, then continue to the next step; otherwise the rule is not
applicable;

(2). We obtain the circle-conﬁguration (cid:104)∆(cid:48), U(cid:48)(cid:105) by removing a single occurrence of each of the facts
F1, . . . , Fn in (cid:104)∆, U(cid:105) used in step 1, and recomputing the truncated time diﬀerences so that for all
the remaining facts P and R in ∆, we have ∆(cid:48)(P, R) = ∆(P, R), i.e., the truncated time diﬀerence
between P and R is preserved;

(3). Create fresh values, (cid:126)e, for the existentially quantiﬁed variables (cid:126)X;
(4). We obtain the circle-conﬁguration (cid:104)∆1, U1(cid:105) by adding the facts Q1[(cid:126)e/ (cid:126)X], . . . , Qm[(cid:126)e/ (cid:126)X] to ∆(cid:48) so that
∆1(T ime, Qi) = Di, for 1 ≤ i ≤ m, and that ∆1(P, R) = ∆(cid:48)(P, R) for all the remaining facts P and R
in ∆(cid:48). We then obtain U1 by adding the facts Q1, . . . , Qm to the class of the fact T ime in the unit
circle U(cid:48);

(5). Return the circle-conﬁguration (cid:104)∆1, U1(cid:105).

The sequence of operations described above has the eﬀect one would expect: replace the facts
F1, . . . , Fn in the pre-condition of the action with facts Q1, . . . , Qm appearing in the post-condition of the
action but taking care to update the truncated time diﬀerences in the δ-conﬁguration. Moreover, all steps
can be computed in polynomial time.

For example, consider the conﬁguration S1 given in (22) and the rule:

T ime@T, R@T1, P@T2 −→ T ime@T, P@T2, N@(T + 2)

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 35

• Time in the zero point and not in the last class in the unit circle, where n ≥ 0:

• Time alone and not in the zero point nor in the last class in the unit circle:

• Time not alone and not in the zero point nor in the last class in the unit circle:

• Time not alone and in the last class in the unit circle which may be at the zero point:

Fig. 14. Rewrite Rules for Time Advancement using Circle-Conﬁgurations.

If we apply this rule to S1, we obtain the conﬁguration

S2 = { M@3.01, P@4.12, T ime@11.12, Q@12.58, N@13.12, S @14 }.

On the other hand, if we apply the above steps to the
circle-conﬁguration of S1, shown in Figure 13, we obtain
the circle-conﬁguration shown to the right. It is easy to
check that this is indeed the circle-conﬁguration of S2.
The truncated time diﬀerences are updated and the fact
N is added to the class of T ime in the unit circle.

Time Advancement Rule

Specifying the time advancement rule

T ime@T −→ T ime@(T + ε)

over circle-conﬁgurations is more interesting. This action is translated into the rules depicted in Fig-
ures 14 and 15. There are eight rules that rewrite a circle-conﬁguration, (cid:104)∆, U(cid:105), depending on the position
of the fact T ime in the unit circle U.

Rule 0 speciﬁes the case when the fact T ime appears in the zero point of U. Then U is re-written so
that a new class is created immediately after the zero point clockwise before any other class on the unit
circle, and T ime is moved to that new class. This denotes that the decimal part of T ime is greater than
zero and less than the decimal part of the facts in the following class G1, . . . , Gn.

Rule 1 speciﬁes the case when the fact T ime appears alone in a class on the unit circle and not in
the last class. This means that there are some facts, F1, . . . , Fn, that appear in a class immediately after
T ime, i.e., U(Fi) > U(T ime) and for any other fact G, G (cid:60) {F1, . . . , Fn}, such that U(G) > U(T ime),

Time,F1,...,Fn∆Rule0:∆G1,...,GmF1,...,FnG1,...,GmTimeTime∆F1,...,FnTime,F1,...,FnRule1:∆Time,Q1,...,Qm∆F1,...,FnRule2:Q1,...,QmF1,...,FnTime∆Time,Q1,...,Qm∆Rule3:Q1,...,QmTime∆SMP,Time,NQh{M},1,{P},∞,{Time},1,{Q},1,{N},1,{S}i36 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

• Time alone and in the last class in unit circle - Case 1: m > 0, k ≥ 0, n ≥ 0 and δ1 > 1:

• Time alone and in the last class in unit circle - Case 2: m > 0, k ≥ 1 and n ≥ 0:

• Time alone and in the last class in unit circle - Case 3: k ≥ 0 such that δ1 > 1 when k > 0 and γ−1 is the
truncated time of δ−1 + 1:

• Time alone and in the last class in unit circle - Case 4: k ≥ 1 and γ−1 is the truncated time of δ−1 + 1:

• Time alone and in the last class in unit circle and in ∆ - Case 5: γ−1 is the truncated time of δ−1 + 1:

Fig. 15. (Cont.) Rewrite Rules for Time Advancement using Circle-Conﬁgurations.

U(G) > U(Fi) holds. In this case, then time can advance so that it ends up in the same class as Fi, i.e.,
time has advanced so much that its decimal part is the same as the decimal part of the timestamps of
F1, . . . , Fn. Therefore a constraint of the form TFi > TT ime + D that was satisﬁed by (cid:104)∆, U(cid:105) might no
longer be satisﬁed by the resulting circle-conﬁguration, depending on D and the δ-conﬁguration ∆.

Rule 2 is similar, but is only applicable when T ime is not alone in the unit circle class, i.e., there is at
least one fact Qi such that U(T ime) = U(Qi) and this class is not the last one, as in Rule 1. Then, Rule 2
advances time enough so that its decimal part is greater than the decimal part of the timestamps of Qi,
but not greater than the decimal part of the timestamps of the facts in the class that immediately follows
on the circle.

For example, Rule 2 could be applied to the
circle-conﬁguration AS1 shown in Figure 13. We
obtain the following circle-conﬁguration, where the
δ-conﬁguration does not change, but the fact T ime
is moved to a new class on the unit circle, obtain-
ing the circle-conﬁguration AS3 shown to the right,
Figure 16.

Rule 3 is similar to Rule 2, but it is applicable

Fig. 16.: circle-conﬁguration AS3

when T ime is in the last equivalence class, in which case a new class is created and placed clockwise
immediately before the zero point of the circle.

Time∆=h...,P−1,δ−1,{Time,Q1,...,Qm},δ1,P1,...,PkiRule4:F1,...,FnTime,F1,...,Fn∆0=h...,P−1,δ−1,{Q1,...,Qm},1,{Time},δ1−1,P1,...,PkiTime∆=h...,P−1,δ−1,{Time,Q1,...,Qm},1,P1,...,PkiRule5:F1,...,FnTime,F1,...,Fn∆0=h...,P−1,δ−1,{Q1,...,Qm},1,{Time}∪P1,...,PkiTime∆=h...,P−1,δ−1,{Time},δ1,P1,...,PkiRule6:F1,...,FnTime,F1,...,Fn∆0=h...,P−1,γ−1,{Time},δ1−1,P1,...,PkiTime∆=h...,P−1,δ−1,{Time},1,P1,...,PkiRule7:F1,...,FnTime,F1,...,Fn∆0=h...,P−1,γ−1,{Time}∪P1,...,PkiSMPQh{M,R},1,{P},∞,{Time},1,{Q},2,{S}iRTimeM. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 37

Notice that the δ-conﬁguration is not changed by Rules 0-3. The only rules that change the δ-
conﬁguration are the Rules 4, 5, 6 and 7, as in these cases T ime advances enough to complete the unit
circle, i.e., reach the zero point.

Rules 4 and 5 handle the case when T ime initially has the same integer part as timestamps of other
facts Q1, . . . , Qm, in which case it might create a new class in the δ-conﬁguration (Rule 4) or merge with
the following class P1 (Rule 5). Rules 6 and 7 handle the case when T ime does not have the same integer
part as the timestamp of any other fact, i.e., it appears alone in ∆, in which case it might still remain alone
in the same class (Rule 6) or merge with the following class P1 (Rule 7). Notice that the time diﬀerence,
δ−1, to the class, P−1, immediately before the class of T ime is incremented by one and truncated by the
value of Dmax if necessary.

For example, consider the circle-conﬁguration AS3 il-
lustrated in Figure 16. It is easy to check that by applying
Rule 1, followed by Rule 3 to AS3 we obtain a circle-
conﬁguration for which the Rule 7 is applicable. After
applying Rule 7 we obtain the conﬁguration AS4 shown
to the right.

Given a reachability problem T and an upper bound Dmax on the numeric values of T with the set
of rules R containing an instantaneous rule r, we write [r] for the corresponding rewrite rule of r over
circle-conﬁgurations as described above. Moreover, let Next be the set of 8 time advancing rules shown
in Figures 14 and 15. Notice that for a given circle-conﬁguration only one of these rules is applicable.

Therefore, we write

(cid:101)R = { [r] : r ∈ R } ∪ Next

for the set of rules over circle-conﬁgurations corresponding to the set of rules R over conﬁgurations.

We use A −→a A1

for the one-step reachability relation between circle-conﬁgurations using the
rewrite rule a, i.e., the circle-conﬁguration A may be rewritten to the circle-conﬁguration A1 using the
rewrite rule a. Finally, A −→∗ A1 (respectively, A −→∗
R(cid:48) A1) denotes the reﬂexive transitive closure
relation of the one-step relation (respectively, using only rules from the set R(cid:48) ⊆ (cid:101)R ).

Lemma 6.3. Let T be a reachability problem and Dmax be an upper bound on the numeric values in
T . Let A1 be the circle-conﬁguration of the conﬁguration S1, and r be an instantaneous action in T .
Then S1 −→r S2 if and only if A1 −→[r] A2, where A2 is the circle-conﬁguration of S2. Moreover,
S1 −→T ick S2 if and only if A1 −→∗

Next A2, where A2 is the circle-conﬁguration of S2.

Proof. Following Lemma 6.2 we only need to prove the claim regarding T ick and Next rules as S1
satisﬁes the time constraints of rule r if and only if its circle-conﬁguration A1 also satisﬁes the constraints
in [r]. Moreover A2 is the circle-conﬁguration of S2 by construction.

In order to prove that, given a transition Next over circle-conﬁgurations, there is the matching pair of
conﬁgurations and the appropriate instance of T ick rule, we ﬁrst show how to extract a corresponding
concrete conﬁguration S from a given circle-conﬁguration A = (cid:104)∆, U(cid:105), where

∆ = (cid:68)
{P1
U = [ {Q0

1, . . . , P1
m1
1, . . . , Q0
m0

}, δ1,2, {P2
}Z, {Q1

}, . . . {P j−1
, . . . , P j−1
m j−1}, δ j−1, j, {P j
1, . . . , P2
m2
1
1, . . . , Qk
}, . . . , {Qk
1, . . . , Q1
} ] .
mk
m1

1, . . . , P j

m j}

(cid:69)

,

MPQh{M,R},1,{P},∞,{Time,Q},2,{S}iRTime,S38 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

1, . . . , P j

m1, P2

1, . . . , P1

m j} = {F1, . . . , Fn, T ime} so we easily obtain (untimed) facts of the
Recall that {P1
conﬁguration S. We timestamp these facts as follows. From ∆ we can extract natural numbers to be
assigned as integer values of timestamps of facts: We assign I1 = 0 as the integer part of the times-
tamp of each of the facts P1
m1. As Ii+1, the integer part of the timestamp of each of the facts
1 , . . . , Pi+1
Pi+1

mi+1, we set

1, . . . , P1

(cid:40)

Ii+1 =

Ii + δi,i+1 ,

if δi,i+1 ≤ Dmax

Ii + Dmax + 1 , if δi,i+1 = ∞

,

i = 1, . . . , j − 1 .

Then, from U we can extract values to be assigned as decimal values of timestamps. We set 0 as the dec-
mi, ∀i = 1, . . . , k. Obtained
k+1 as the decimal part of facts Qi
imal part of facts Q0
timestamped facts form conﬁguration S corresponding to circle-conﬁguration A.

m0, and i

1, . . . , Q0

1, . . . , Qi

Let A1 →Next A2. From A1 we extract a corresponding concrete conﬁguration S1 as described above.
Recall that Next is a set of 8 rules representing time advancement over circle-conﬁgurations, as given
in Figures 14 and 15. Depending on the position of the fact T ime in A1 only one of the 8 rules from
Next applies. Assume that A ﬁts the ﬁrst case, i.e., Rule 0 in Figure 14. Then, any value ε ∈ (cid:104)0, 1
k+1 (cid:105),
e.g., ε = 1
2(k+1) , is suitable for an instance of the T ick rule, T ime@T −→ T ime@(T +ε), in S1 −→T ick S2
so that A2 corresponds to conﬁguration S2.
In the same way we can take ε ∈ (cid:104)0, 1

For the remaining rules, i.e., Rule 1 and Rule 4 to Rule 7, taking ε = 1
conﬁguration S2. That is because the timestamp of T ime, say j
the decimal part of next group of facts, that is j+1

k+1 (cid:105) in cases corresponding to Rule 2 and Rule 3 from Figure 14.
k+1 results in A2 that corresponds to
k+1 , is increased exactly so that it matches

k+1 or 0.

For the opposite direction let S1 −→T ick S2 by means of the instance of T ick using the actual value ε,
written S1 −→T ickε S2. Conﬁgurations S1 and S2 diﬀer only in the timestamp of the fact T ime. It may
well be that S1 and S2 correspond to the same circle-conﬁguration A1 = A2. Then, to the given T ick
action, S1 −→T ick S2, corresponds the empty sequence of Next actions, A1 −→∗
Next A2. In the rest of
the proof we assume that S1 and S2 do not correspond to the same circle conﬁguration.

The eﬀect of the T ickε rule is the same as the eﬀect of consecutively applying a series of T ick rules
using εi where ε1 + · · · + εn = ε . We can choose a sequence of values εi so that to the T ick for εi, for
each i, corresponds a single application of the Next rule:

S1 →T ickε2
(cid:33)

S1 →T ickε1
(cid:33)
A1 →Next A1 →Next A2 →Next

S2 →T ickε3
(cid:33)

. . . →T ickεn
. . .

S2
(cid:33)
. . . →Next A2

Consecutive application of such T ickεi corresponds to a series of the Next rules as given in Figures 14
and 15. Namely, each εi corresponds to one of the 8 Next rules.

Concrete values of timestamps in S reﬂect in the position of the fact T ime in A1. Let the fact Q@TQ
be one of the facts in S with the smallest diﬀerence dec (TQ) − dec (T ) > 0. If the global time T has the
decimal part equal to some other fact in the conﬁguration, taking 0 < ε < dec (TQ) − dec (T ) corresponds
to the application of either Rule 0, Rule 2 or Rule 3. Otherwise, if the decimal part of T is diﬀerent than
the decimal part of all other facts in S1, taking εi = dec (TQ) − dec (T ) results in the new global time
(cid:3)
that matches the timestamp TQ in its decimal part.

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 39

Theorem 6.4. Let T be a reachability problem, Dmax be an upper bound on the numeric values in T .
Then SI −→∗ SG for some initial and goal conﬁgurations SI and SG in T if and only if AI −→∗ AG
where AI and AG are the circle-conﬁgurations of SI and SG, respectively.

Proof. The proof is by induction on the length of the given plan. Additionally, as in the proof of
Lemma 6.3, we can assume that each instance of the time advancement rule in the plan over conﬁg-
urations uses a concrete value ε that corresponds to a single application of one of the Next rules in
the matching plan over circle-conﬁgurations, or to no action at all (i.e., to an empty sequence of Next
actions). We get the following bisimulation:

SI →r1 · · · →ri−1 Si−1 →ri Si →ri+1 · · · →rn SG
(cid:33)
(cid:33)
AI →r(cid:48)
AG

(cid:33)
Ai−1 →r(cid:48)

(cid:33)
Ai →r(cid:48)
i+1

· · · →r(cid:48)
i−1

· · · →r(cid:48)

n

1

i

where r(cid:48)
Figures 14 and 15, or an empty action (in which case Ai−1 = Ai ).

i is either the instantaneous action [ri] over circle-conﬁgurations, one of the Next rule as given in
(cid:3)

This theorem establishes that the set of plans over circle-conﬁgurations is a sound and complete rep-
resentation of the set of plans with dense time. This means that we can search for solutions of problems
symbolically, that is, without writing down the explicit values of the timestamps, i.e., the real numbers,
in a plan.

7. Complexity Results

This section details some of the complexity results for the reachability problem.
Reachability problem is a rather general problem that can have various applications. For example, the
secrecy problem from the ﬁeld of protocol security can be considered as an instance of the reachability
problem. Namely, by interacting with the protocol run, the goal of the intruder is to learn a secret that is
initially only known to another participant of the protocol.

In our previous work we have already considered such an application of our formal models in protocol
security. In [20,21] we consider bounded memory protocol theories and intruder theories and the cor-
responding secrecy problem. These formalizations bound the number of concurrent protocol sessions.
However, the total number of protocol sessions and the total number of fresh values created is unbounded.
The model introduced in this paper can similarly be applied in the protocol security analysis. As
in [20,21], when using only balanced actions, one can necessarily consider only a bounded number
of concurrent sessions. Nevertheless, the analysis would consider an unbounded number of protocol
sessions in total.

In addition, by containing the dimension of time, our model presented in this paper can be used for the

analysis of time-sensitive protocols, such as cyber-physical security protocols, and their properties.

Conditions for Decidability

From the literature, we can infer some conditions for decidability of the reachability problem in gen-

eral:

40 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

(1). Upper Bound on the Size of Facts: In general, if we do not assume an upper bound on the size of
facts appearing in a plan, where the size of facts is the total number of predicate, function, constant
and variable symbols it contains (e.g., the size of P( f (a), x, a) is 5), then it is easy to encode the Post-
Correspondence problem which is undecidable, see [7,15].8 Thus we will assume an upper bound
on the size of facts, denoted by the symbol k.

(2). Balanced Actions: An action is balanced if its pre-condition has the same number of facts as its
post-condition [27]. The reachability problem is undecidable for (un-timed) systems with possibly
unbalanced actions even if the size of facts is bounded [7,15]. In a balanced system, on the other
hand, the number of facts in any conﬁguration in a plan is the same as the number of facts of
the initial conﬁguration, allowing one to recover decidability under some additional conditions. We
denote the number of facts in the conﬁguration by the symbol m.
Both undecidability results related to (un)balanced actions as well as the upper bound on the size of
facts are time irrelevant, they carry over to systems with dense time.

(3). Conditions for Timestamps and Time Constraints: Recall the form of instantaneous rules in our
systems (Equation (5) in Section 3) and the conditions the form of the rules imposes on timestamps
and time constraints.
In particular, the form of instantaneous rules imposes the restriction on using only natural numbers
(for Ds and Dis) in time constraints and timestamps of created facts. This is not as restrictive as
it may appear. Namely, we are able to capture systems that would allow rational numbers as well.
These numbers are constants in any given concrete model, and they are used to specify concrete time
requirements. By allowing rational numbers we would not add to expressivity of the system, since
these constants can be multiplied with a common multiple of their denominators, to obtain natural
numbers. The only diﬀerence between the original model (with rationals) and the obtained model
(with only natural numbers) is the intended denotation of the time units used in the model. For ex-
ample, one could use minutes instead of days or hours. The intended semantics of the system repre-
sented would not change. In fact, to maintain all our results valid, it suﬃces to assume that all these
numerical constants mentioned within the above constraints and timestamps are commensurable,
that is, these constants can be given in terms of a common unit.
Furthermore, the form of instantaneous rules restricts the form of timestamps of created facts and
the form of time constraints. Timestamps are necessarily of the form T + D, where T is the current
time of the enabling conﬁguration and D a natural number, and time constraints are relative, i.e.,
involve exactly two time variables from the pre-condition of the rule. In [25] we have shown that
relaxing either of the form of timestamps or the form of time constraints leads to the undecidability
of the reachability problem for multiset rewriting models with discrete time. The same would thus
lead to the undecidability of the reachability problems considered in this paper. In particular, we
get undecidability for systems with non-relative time constraints that involve three or more time
variables. Similarly, we fall into undecidabilty if we allow timestamps of the created facts to be
(already linear) polynomials of time variables from the pre-condition of the rule. See [25] for more
details.

Corollary 7.1. The reachability problem for our model is undecidable in general.

8We leave for Future Work the investigation of speciﬁc cases, e.g., protocol with tagging mechanisms, where this upper

bound may be lifted [39].

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 41

Proof. To an instance of a reachability problem for (un-timed) systems with possibly unbalanced actions,
we associate a timed version of the same problem as follows.

We attach arbitrary timestamps to facts in the initial conﬁguration. Similarly, to each (untimed) fact in
the goal conﬁguration we attach a diﬀerent time variable. We put no constraints to the initial and goal
conﬁgurations. This way, timestamps of facts in the initial and the goal conﬁguration play no particular
role in the reachability problem.

Finally, we consider the following set of instantaneous rules: For every rule

W1 . . . , Wk, F1, . . . , Fn −→ ∃ (cid:126)X. [ W1, . . . , Wk, Q1, . . . , Qm ]

in the un-timed system we take the corresponding rule

T ime@T, W1@T1, . . . , Wk@Tk, F1@T (cid:48)

1, . . . , Fn@T (cid:48)

n −→

∃ (cid:126)X. [ T ime@T, W1@T1, . . . , Wk@Tk, Q1@T, . . . , Qm@T ]

Notice that above rules have no guards attached and since facts have arbitrary timestamps, the application
of rules in the timed system is independent from the time aspect.

Clearly, the original (untimed) reachability problem has a solution if and only if its associated timed
version (as described above) has a solution. Since the reachability problem for (untimed) systems with
possibly unbalanced actions is undecidable, the reachability problem for timed systems with possibly
(cid:3)
unbalanced actions is undecidable as well.

PSPACE-Completeness We show that the reachability problem for our model with dense time and bal-
anced actions is PSPACE-complete. Interestingly, the same problem is also PSPACE-complete when
using models with discrete time [24].

Given the machinery in Section 6, we can re-use many results in the literature to show that the reach-
ability problem is also PSPACE-complete for balanced systems with dense time that can create fresh
values, as given in Section 3, assuming an upper bound on the size of facts. For instance, we use the
machinery detailed in [20] to handle the fact that a plan may contain an unbounded number of fresh
values.

The PSPACE lower bound can be inferred from [20]. The interesting bit is to show PSPACE mem-
bership of the reachability problem. The following lemma establishes an upper bound on the number of
diﬀerent circle-conﬁgurations:
Lemma 7.2. Given a reachability problem T under a ﬁnite alphabet Σ, an upper bound on the size of
facts, k, and an upper bound, Dmax, on the numeric values appearing in T , then the number of diﬀerent
circle-conﬁgurations, denoted by LT (m, k, Dmax), with m facts (counting repetitions) is

LT (m, k, Dmax) ≤ Jm(D + 2mk)mkmm(Dmax + 2)(m−1),

where J and D are, respectively, the number of predicate and the number of constant and function
symbols in Σ.

Proof. A circle-conﬁguration consists of a δ-conﬁguration ∆:

∆ = (cid:68)

{Q1

1, . . . , Q1
m1

}, δ1,2, {Q2

1, . . . , Q2
m2

}, . . . , δ j−1, j, {Q j

1, . . . , Q j

m j}

(cid:69)

42 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

and unit circle U:

U = [ {Q0

1, . . . , Q0
m0

}Z, {Q1

1, . . . , Q1
m1

}, . . . , {Q j

1, . . . , Q j

m j} ] .

In each component, ∆ and U, there are m facts, therefore there are m slots for predicate names and at
most mk slots for constants and function symbols. Constants can be either constants in the initial alphabet
Σ or names for fresh values (nonces). Following [20] and Deﬁnition 3.6, we need to consider only 2mk
names for fresh values (nonces). Finally, only time diﬀerences up to Dmax have to be considered together
with the symbol ∞, and there are at most m − 1 slots for time diﬀerences δi, j in ∆.

Finally, for each δ-conﬁguration, there are at most mm unit circles as for each fact F we can assign a
(cid:3)

class, U(F), and there are at most m classes.

Intuitively, our upper bound algorithm keeps track of the length of the plan it is constructing and if
its length exceeds LT (m, k, Dmax), then it knows that it has reached the same circle-conﬁguration twice.
Hence, there is a loop in the plan which can be avoided. If there is a solution plan of length that ex-
ceeds LT (m, k, Dmax), there is also a shorter plan that is the solution to the same reachability problem.
Therefore, we can nondeterministically search for plans of bounded length. This search is possible in
PSPACE since the above number, when stored in binary, occupies only polynomial space with respect to
its parameters.

For the given reachability problem T , where m is the number of facts in the initial conﬁguration and
k an upper bound on the size of facts, assume functions G and R that return the value 1 in Turing space
bounded by a polynomial in m, k and log2(Dmax) when given as input, respectively, a circle-conﬁguration
that is a goal circle-conﬁguration, and a pair of a circle-conﬁguration and a transition that is valid, i.e., an
instance of an action in T that is applicable to the given circle-conﬁguration, and return 0 otherwise.

Theorem 7.3. Let T be a reachability problem with balanced actions, S0 be an initial conﬁguration with
exactly m facts, Dmax be an upper bound on the numeric values appearing in T , k an upper bound on the
size of facts and let G and R be functions as described above. Then there is an algorithm that given an
initial conﬁguration S0 decides the problem T and the algorithm runs in polynomial space with respect
to m, k and log2(Dmax).

Proof. Let m be the number of facts in the initial conﬁguration SI, k an upper bound on the size of
facts, Dmax a natural number that is an upper bound on the numeric values appearing in the reachability
problem T , that is in the timestamps of the initial conﬁguration, or the Ds and Dis in constraints or
actions of the given reachability problem.

We modify the algorithms given in [20] and in [25] in order to accommodate explicit dense time.
The algorithm must accept whenever there is a sequence of actions from T leading from the initial
conﬁguration SI to a goal conﬁguration. In order to do so, we construct an algorithm that searches
non-deterministically whether such a plan exists. Then we apply Savitch’s Theorem to determinize this
algorithm.

A crucial point here is that instead of searching for a plan using concrete values, we rely on the equiv-
alence among conﬁgurations given in Deﬁnition 3.6 and use circle-conﬁgurations only. Theorem 6.4
guarantees that this abstraction is sound and faithful.

Let i be a natural number such that 0 ≤ i ≤ LT (m, k, Dmax).
The algorithm begins with A0 set to be the circle-conﬁguration of SI and iterates the following se-

quence of operations:

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 43

(1). If Ai is representing a goal conﬁguration, i.e., if G(Ai) = 1, then return ACCEPT; otherwise con-

tinue;

(2). If i > LT (m, k, Dmax), then FAIL; else continue;
(3). Guess non-deterministically an action, r, from T applicable to Ai, i.e., such an action r that
R(Ai, r) = 1. If no such action exists, then return FAIL. Otherwise replace Ai with the circle-
conﬁguration Ai+1 resulting from applying the action r to the circle-conﬁguration Ai.

(4). Set i = i + 1.

We now show that this algorithm runs in polynomial space. We start with the step-counter i: The
greatest number reached by this counter is LT (m, k, Dmax). When stored in binary encoding, this number
only takes space that is polynomial in the given inputs:

log(LT (m, k, Dmax)) ≤ m log(J) + mk log(D + 2mk) + m log m + (m − 1) log(Dmax + 2).

Therefore, one only needs polynomial space to store the values of the step-counter.

We must also be careful to check that any circle-conﬁguration, Wi = (cid:104)∆, U(cid:105), where

∆ = (cid:68)
{Q1
U = [ {Q0

1, . . . , Q1
m1
1, . . . , Q0
m0

}, δ1,2, {Q2
}Z, {Q1

1, . . . , Q2
m2
}, . . . , {Q j
1, . . . , Q1
m1

}, . . . , δk−1,k, {Qk
1, . . . , Q j
m j} ]

1, . . . , Qk
mk

(cid:69)

}

,

can be stored in space that is polynomial to the given inputs. Since our system is balanced, the size
of facts is bounded, and the values of the truncated time diﬀerences, δi, j, are bounded, it follows that
the size of any circle-conﬁguration (cid:104)∆, U(cid:105) in a plan is polynomially bounded with respect to m, k and
log(Dmax + 2).

Finally, the algorithm needs to keep track of the action r guessed when moving from one circle-
conﬁguration to another, and for the scheduling of a plan. It has to store the action that has been used at
the ith step. Since any action can be stored by remembering two circle-conﬁgurations, one can also store
(cid:3)
these actions in space polynomial to the inputs.

8. Related and Future Work

The formalization of timed models and their use in the analysis of cyber-physical security protocols

has already been investigated. We review this literature.

Meadows et al. [32] and Pavlovic and Meadows in [38] propose and use a logic called Protocol Deriva-
tion Logic (PDL) to formalize and prove the safety of a number of cyber-physical protocols. In particu-
lar, they specify the assumptions and protocol executions in the form of axioms, specifying the allowed
order of events that can happen, and show that safety properties are implied by the axiomatization used.
They do not formalize an intruder model. Another diﬀerence from our work is that their PDL speciﬁ-
cation is not an executable speciﬁcation, while we have implemented our speciﬁcation in Maude [11].
Finally, they do not investigate the complexity of protocol analysis nor investigate the expressiveness of
formalizations using discrete and continuous time.

Another approach similar to [32] in the sense that it uses a theorem proving approach is given by
Schaller et al. [3]. They formalize an intruder model and some cyber-physical security protocols in
Isabelle. They then prove the correctness of these protocols under some speciﬁc conditions and also
identify attacks when some conditions are not satisﬁed. Their work was a source of inspiration for our

44 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

intruder model speciﬁed in [23], which uses the model described in Section 3. Although their model
includes time, their model is not reﬁned enough to capture the attack in-between-ticks as they do not
consider the discrete behavior of the veriﬁer.

Boureanu et al. [4] proposed a discrete time model for formalizing distance bounding protocols and
their security requirements. Thus they are more interested in the computational soundness of distance
bounding protocols by considering an adversary model based on probabilistic Turing machines. They
claim that their SKI protocol is secure against a number of attacks. However, their time model is discrete
where all players are running at the same clock rate. Therefore, their model is not able to capture attacks
that exploit the fact that players might run at diﬀerent speeds.

Pavlovic and Meadows [37] construct a probabilistic model for analysing distance bounding protocols
against guessing attacks. The nature of the attack we consider and the attack considered in [37] are quite
diﬀerent leading to diﬀerent probabilistic models with diﬀerent goals.

The Timed Automata [2] (TA) literature contains models for cyber-physical protocol analysis. Corin
et al. [12] formalize protocols and the standard Dolev-Yao intruder as timed automata and demonstrate
that these can be used for the analysis. They are able to formalize the generation of nonces by using
timed automata, but they need to assume that there is a bound on the number of nonces. This means that
they assume a bound on the total number of protocol sessions. Our model based on rewrite theory, on
the other hand, allows for an unbounded number of nonces, even in the case of balanced theories [20].
Also they do not investigate the complexity of the analysis problems nor the expressiveness diﬀerence
between models with discrete and continuous time. Lanotte et al. [29] specify cyber-physical protocols,
but protocols where messages can be re-transmitted or alternatively a protocol session can be terminated,
i.e., timeouts, in case a long time time elapses. They formalize the standard Dolev-Yao intruder. Finally,
they also obtain a decidability result for their formalism and an EXPSPACE-hard lower bound for the
reachability problem. It seems possible to specify features like timeouts and message re-transmission, in
our rewriting formalism.

We also point out some important diﬀerences between our PSPACE-completeness proof and PSPACE-
completeness proof for timed automata [2]. A more detailed account can be found in the Related Work
section of [25]. The ﬁrst diﬀerence is that we do not impose any bounds on the number of nonces created,
while the TA proof normally assumes a bound. The second diﬀerence is due to the ﬁrst-order nature of
rewrite rules. The encoding of a ﬁrst-order system in TA leads to an exponential blow-up on the number
of states of the automata as one needs take into account all instantiations of rules. Finally, the main
abstractions that we use, namely circle-conﬁgurations, are one-dimensional, while regions used in the
TA PSPACE proof are multidimensional.

Malladi et al. [31] formalize distance bounding protocols in strand spaces. They then construct an
automated tool for protocol analysis using a constraint solver. They did not take into account the fact that
the veriﬁer is running a clock in their analysis and therefore are not able to detect the attack in-between-
ticks.

Cheval and Cortier [8] propose a way to prove the properties based on the observational equivalence of
processes taking account the time processes execute with time by reducing this problem to the observa-
tional equivalence based on the length of inputs. They are able to automatically show that RFID protocols
used by passports suﬀer a privacy attack. While the problems considered are diﬀerent, it seems possible
to use our machinery to prove complexity results on problems based on observational equivalence. We
leave this as future work.

Nigam et al. [34] investigated further the properties of timed intruder models formalized in a language
similar to our timed MSR framework. It is possible to infer an upper-bound on the number of time intrud-

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 45

ers to consider for cyber-physical security protocol veriﬁcation. Based on this result, they implemented in
Maude, also using SMT solvers, a prover that automates such a veriﬁcation of protocol security including
the attack in-between-ticks introduced here.

Finally, [13] introduces a taxonomy of attacks on distance bounding protocols, which include a new
attack called Distance Hijacking Attack. This attack was caused by failures not in the time challenges
phase of distance bounding protocols, but rather in the authentication phases. It would be interesting to
understand how these attacks can be combined with the attack in-between-ticks to build more powerful
attacks.

As future work, we also intend to investigate the challenge-response approach in providing security
of distance bounding protocols by expanding our probabilistic analysis to such a scenario. Repeating a
number of challenge and response rounds in distance bounding protocols is generally believed to mitigate
the chances of an attack occurring. In particular, we are planning to analyze whether the eﬀects of the
attack in-between-ticks can be reduced by repeated challenge-response rounds of protocols. Moreover,
we are investigating improvements on our implementation in order to check for a wider number of attacks
automatically.

Acknowledgments: Nigam is supported by the Brazilian Research Agencies CNPq and Capes. Talcott
is partially supported by NSF grant CNS-1318848, by a grant from ONR and by a grant from Capes
Science without Borders. Scedrov is supported in part by the AFOSR MURI “Science of Cyber Security:
Modeling, Composition, and Measurement”. Additional support for Scedrov from ONR. Part of the
work was done while Kanovich and Scedrov were visiting the National Research University Higher
School of Economics, Moscow. They would like to thank Sergei O. Kuznetsov for providing a very
pleasant environment for work. This article was prepared within the framework of the Basic Research
Program at the National Research University Higher School of Economics (HSE) and supported within
the framework of a subsidy by the Russian Academic Excellence Project ’5-100’. We would like to thank
Robin Pemantle for discussions, suggestions, and advice regarding the probabilistic analysis.

References

[1] R. Alur. Principles of Cyber-Physical Systems. MIT Press, 2015.
[2] R. Alur and P. Madhusudan. Decision problems for timed automata: A survey. In SFM, pages 1–24, 2004.
[3] D. A. Basin, S. Capkun, P. Schaller, and B. Schmidt. Formal reasoning about physical properties of security protocols.

ACM Trans. Inf. Syst. Secur., 14(2):16, 2011.

[4] I. Boureanu, A. Mitrokotsa, and S. Vaudenay. Practical & provably secure distance-bounding. IACR Cryptology ePrint

Archive, 2013:465, 2013.

[5] S. Brands and D. Chaum. Distance-bounding protocols (extended abstract). In EUROCRYPT, pages 344–359, 1993.
[6] S. Capkun and J.-P. Hubaux. Secure positioning in wireless networks. IEEE Journal on Selected Areas in Communica-

tions, 24(2):221–232, 2006.

[7] I. Cervesato, N. A. Durgin, P. Lincoln, J. C. Mitchell, and A. Scedrov. A meta-notation for protocol analysis. In CSFW,

pages 55–69, 1999.

[8] V. Cheval and V. Cortier. Timing attacks in security protocols: Symbolic framework and proof techniques. In Principles
of Security and Trust - 4th International Conference, POST 2015, Held as Part of the European Joint Conferences on
Theory and Practice of Software, ETAPS 2015, London, UK, April 11-18, 2015, Proceedings, pages 280–299, 2015.
[9] T. Chothia, F. D. Garcia, J. de Ruiter, J. van den Breekel, and M. Thompson. Relay cost bounding for contactless emv

payments. In Financial Cryptography and Data Security, 2015.

[10] T. Chothia and V. Smirnov. A traceability attack against e-passports. In Financial Cryptography and Data Security, pages

20–34, 2010.

[11] M. Clavel, F. Durán, S. Eker, P. Lincoln, N. Mart ´Ä´s-Oliet, J. Meseguer, and C. Talcott. All About Maude: A High-

Performance Logical Framework, volume 4350 of LNCS. 2007.

[12] R. Corin, S. Etalle, P. H. Hartel, and A. Mader. Timed analysis of security protocols. J. Comput. Secur., 15(6):619–645,

dec 2007.

46 M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols

[13] C. J. F. Cremers, K. B. Rasmussen, B. Schmidt, and S. Capkun. Distance hijacking attacks on distance bounding protocols.

In SP, 2012.

[14] D. Dolev and A. Yao. On the security of public key protocols. IEEE Transactions on Information Theory, 29(2):198–208,

1983.

[15] N. A. Durgin, P. Lincoln, J. C. Mitchell, and A. Scedrov. Multiset rewriting and the complexity of bounded security

protocols. Journal of Computer Security, 12(2):247–311, 2004.

[16] H. B. Enderton. A mathematical introduction to logic. Academic Press, 1972.
[17] S. Escobar, C. Meadows, J. Meseguer Maude-NPA: Cryptographic Protocol Analysis Modulo Equational Properties.

Foundations of Security Analysis and Design V, 2009.

[18] S. Ganeriwal, C. Pöpper, S. Capkun, and M. B. Srivastava. Secure time synchronization in sensor networks. ACM Trans.

Inf. Syst. Secur., 11(4), 2008.

[19] G. Hancke, and M. Kuhn, An RFID distance bounding protocol. First International Conference on Security and Privacy

for Emerging Areas in Communications Networks (SECURECOMM’05), 67–73, 2005.

[20] M. Kanovich, T. Ban Kirigin, V. Nigam, and A. Scedrov. Bounded memory Dolev-Yao adversaries in collaborative

systems. Inf. Comput., 2014.

[21] M. I. Kanovich, T. Ban Kirigin, V. Nigam, and A. Scedrov. Bounded memory protocols. Computer Languages, Systems

& Structures, pages 40(3-4):137–154, 2014.

[22] M. I. Kanovich, T. Ban Kirigin, V. Nigam, and A. Scedrov. Bounded memory protocols and progressing collaborative

systems. In ESORICS, pages 309–326, 2013.

[23] M. I. Kanovich, T. Ban Kirigin, V. Nigam, A. Scedrov, and C. L. Talcott. Towards timed models for cyber-physical

security protocols. Available on Nigam’s homepage, 2014.

[24] M. I. Kanovich, T. Ban Kirigin, V. Nigam, A. Scedrov, C. L. Talcott, and R. Perovic. A rewriting framework for activities

subject to regulations. In RTA, pages 305–322, 2012.

[25] M. Kanovich, T. Ban Kirigin, V. Nigam, A. Scedrov, C. Talcott, R. Perovic. A Rewriting Framework and Logic for
Activities Subject to Regulations, Mathematical Structures in Computer Science, 2015, 44 pages, Published online 02
June 2015. http://journals.cambridge.org/article_S096012951500016X

[26] M. Kanovich, T. Ban Kirigin, V. Nigam, A. Scedrov, C. Talcott. Discrete vs. Dense Times in the Analysis of Cyber-
Physical Security Protocols. 4th Conference on Principles of Security and Trust (POST), London, UK, April 2015.
Springer LNCS, Volume 9036, Springer-Verlag, pages 259 - 279, 2015.

[27] M. I. Kanovich, P. Rowe, and A. Scedrov. Collaborative planning with conﬁdentiality. J. Autom. Reasoning, 46(3-4):389–

421, 2011.

[28] M. I. Kanovich, P. Rowe, and A. Scedrov. Policy Compliance in Collaborative Systems. In CSF ’09: Proceedings of the

2009 22nd IEEE Computer Security Foundations Symposium, pages 218-233, 2009.

[29] R. Lanotte, A. Maggiolo-Schettini, and A. Troina. Reachability results for timed automata with unbounded data structures.

Acta Inf., 47(5-6):279–311, 2010.

[30] G. Lowe. Breaking and ﬁxing the Needham-Schroeder public-key protocol using FDR. In TACAS, pages 147–166, 1996.
[31] S. Malladi, B. Bruhadeshwar, and K. Kothapalli. Automatic analysis of distance bounding protocols. CoRR,

abs/1003.5383, 2010.

[32] C. Meadows, R. Poovendran, D. Pavlovic, L. Chang, and P. F. Syverson. Distance bounding protocols: Authentication
logic analysis and collusion attacks. In Secure Localization and Time Synchronization for Wireless Sensor and Ad Hoc
Networks, pages 279–298. 2007.

[33] R. M. Needham and M. D. Schroeder. Using encryption for authentication in large networks of computers. Commun.

ACM, 21(12):993–999, 1978.

[34] Vivek Nigam and Carolyn L. Talcott and Abraão Aires Urquiza Towards the Automated Veriﬁcation of Cyber-Physical
Security Protocols: Bounding the Number of Timed Intruders In Computer Security - ESORICS 2016 - 21st European
Symposium on Research in Computer Security, Proceedings, Part II, 450–470, 2016

[35] P. C. Ölveczky and J. Meseguer. Semantics and pragmatics of Real-Time Maude. In Higher-Order and Symbolic Com-

putation, 20 (1-2) 161–196, 2007.

[36] P. C. Ölveczky and J. Meseguer. Abstraction and Completeness for Real-Time Maude. Electr. Notes Theor. Comput. Sci.

volume 176, number 4, 5–27, 2007

[37] D. Pavlovic and C. Meadows. Bayesian Authentication: Quantifying Security of the Hancke-Kuhn Protocol. In Electr.

Notes Theor. Comput. Sci., pages 97–122, 2010.

[38] D. Pavlovic and C. Meadows. Deriving ephemeral authentication using channel axioms. In Security Protocols Workshop,

pages 240–261, 2009.

[39] R. Ramanujam and S. P. Suresh. Tagging makes secrecy decidable with unbounded nonces as well. In FST TCS, 2003.
[40] K. Ravi, G.H.Varun, and P. T.Vamsi. Rﬁd based security system. International Journal of Innovative Technology and

Exploring Engineering, 2, 2013.

M. Kanovich et al. / Time, Computational Complexity, and Probability in the Analysis of Distance-Bounding Protocols 47

[41] V. Shmatikov and M.-H. Wang. Secure veriﬁcation of location claims with simultaneous distance modiﬁcation. In ASIAN,

pages 181–195, 2007.

[42] K. Sun, P. Ning, and C. Wang. Tinysersync: secure and resilient time synchronization in wireless sensor networks. In

CCS, pages 264–277, 2006.

[43] N. O. Tippenhauer and S. Capkun. Id-based secure distance bounding and localization. In ESORICS, pages 621–636,

2009.

