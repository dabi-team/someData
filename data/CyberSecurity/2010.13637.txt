Enabling Efﬁcient Cyber Threat Hunting With
Cyber Threat Intelligence

Peng Gao∗, Fei Shao†, Xiaoyuan Liu∗, Xusheng Xiao†, Zheng Qin‡, Fengyuan Xu‡
Prateek Mittal§, Sanjeev R. Kulkarni§, Dawn Song∗
∗University of California, Berkeley †Case Western Reserve University
‡National Key Lab for Novel Software Technology, Nanjing University §Princeton University
∗{penggao,xiaoyuanliu,dawnsong}@berkeley.edu †{fxs128,xusheng.xiao}@case.edu
‡{qinzheng,fengyuan.xu}@nju.edu.cn §{pmittal,kulkarni}@princeton.edu

1
2
0
2

b
e
F
5
2

]

R
C
.
s
c
[

2
v
7
3
6
3
1
.
0
1
0
2
:
v
i
X
r
a

Abstract—Log-based cyber threat hunting has emerged as
an important solution to counter sophisticated attacks. How-
ever, existing approaches require non-trivial efforts of manual
query construction and have overlooked the rich external threat
knowledge provided by open-source Cyber Threat Intelligence
(OSCTI). To bridge the gap, we propose THREATRAPTOR, a
system that facilitates threat hunting in computer systems using
OSCTI. Built upon system auditing frameworks, THREATRAP-
TOR provides (1) an unsupervised, light-weight, and accurate
NLP pipeline that extracts structured threat behaviors from
unstructured OSCTI text, (2) a concise and expressive domain-
speciﬁc query language, TBQL, to hunt for malicious system
activities, (3) a query synthesis mechanism that automatically
synthesizes a TBQL query for hunting, and (4) an efﬁcient query
execution engine to search the big audit logging data. Evaluations
on a broad set of attack cases demonstrate the accuracy and
efﬁciency of THREATRAPTOR in practical threat hunting.

I. INTRODUCTION
Recent cyber attacks have plagued many well-protected
businesses [1], [2]. These attacks often exploit multiple types
of vulnerabilities to inﬁltrate into target systems in multiple
stages, posing challenges for effective countermeasures. To
counter these attacks, ubiquitous system auditing has emerged
as an important approach for monitoring system activities [3]–
[6]. System auditing collects system-level auditing events
about system calls from OS kernel as system audit logs. The
collected system audit logging data further enables approaches
to hunt for cyber threats via query processing [7]–[9].

Cyber threat hunting is the process of proactively and itera-
tively searching for malicious actors and indicators in various
logs, which is critical to early-stage detection. Despite nu-
merous research outcomes [7]–[9] and industry solutions [10],
[11], existing approaches, however, require non-trivial efforts
of manual query construction and have overlooked the rich
external knowledge about threats provided by open-source
Cyber Threat Intelligence (OSCTI). Hence, the current threat
hunting process is labor-intensive and error-prone.

OSCTI [12] is a form of evidence-based knowledge and
has received growing attention from the community, en-
abling companies and organizations to gain visibility into the
fast-evolving threat landscape. Commonly, knowledge about
threats is presented in a vast number of publicly available
OSCTI sources. Structured OSCTI feeds [13]–[16] have pri-
marily focused on Indicators of Compromise (IOCs) [17],

which are forensic artifacts of an intrusion such as malicious
ﬁle/process names, virus signatures, and IPs/domains of bot-
nets. Though useful in capturing fragmented views of threats,
these disconnected IOCs lack the capability to uncover the
complete threat scenario as to how the threat unfolds into
multiple steps. Consequently, defensive solutions that rely on
these low-level, fragmented indicators [10], [11] can be easily
evaded when the attacker re-purposes the tools and changes
their signatures. In contrast, unstructured OSCTI reports [18]–
[20] contain more comprehensive knowledge about threats.
For example, descriptive relationships between IOCs contain
knowledge about multi-step threat behaviors (e.g., “read”
relationship between two IOCs “/bin/tar” and “/etc/passwd”
in Figure 2), which is critical to uncovering the complete
threat scenario. Besides, such connected threat behaviors are
tied to the attacker’s goals and thus more difﬁcult to change.
Unfortunately, prior approaches do not provide an automated
way to harvest such knowledge and use it for threat hunting.

Challenges. In this work, we seek to design automated tech-
niques to (1) extract knowledge about threat behaviors (IOCs
and their relationships) from unstructured OSCTI reports, and
(2) use the extracted knowledge to facilitate threat hunting.
We identify two major challenges. First, accurately extracting
threat knowledge from natural-language OSCTI text is not
trivial. This is due to the presence of massive nuances par-
ticular to the security context, such as special characters (e.g.,
dots, underscores) in IOCs. These nuances confuse most NLP
modules (e.g., sentence segmentation, tokenization), making
existing information extraction tools ineffective [21], [22].
Second, system auditing often produces a huge amount of
daily logs (0.5 GB ∼ 1 GB for 1 enterprise host [23]), and
hence threat hunting is a procedure of “ﬁnding a needle in a
haystack”. Such big data poses challenges for solutions to store
and query the data efﬁciently to hunt for malicious activities.
To meet the requirement of timely threat hunting, knowledge
extraction from OSCTI text also needs to be efﬁcient.

Contribution. We propose THREATRAPTOR, a system that
facilitates threat hunting in computer systems using OSCTI.
We built THREATRAPTOR (∼ 25K LOC) upon mature system
auditing frameworks [24]–[26] for system audit logging data
collection (Section III-A), and databases (PostgreSQL [27],

 
 
 
 
 
 
Fig. 1: The architecture of THREATRAPTOR

Neo4j [28]) for data storage (Section III-B). This enables
our system to leverage the services provided by these ma-
ture infrastructures, such as data management, querying, and
recovery. Besides, THREATRAPTOR has three novel designs:
(1) Unsupervised, Light-Weight, and Accurate NLP Pipeline
for Threat Behavior Extraction: THREATRAPTOR employs a
specialized NLP pipeline that targets the unique problem of
IOC and IOC relation extraction from OSCTI text, which has
not been studied in prior work. To handle nuances and meet
the requirement of timely threat hunting, the pipeline adopts
a collection of techniques (e.g., IOC protection, dependency
parsing-based IOC relation extraction) to achieve accurate
and efﬁcient threat behavior extraction. The extracted threat
behaviors are represented in a structured threat behavior
graph, in which nodes represent IOCs and edges represent
IOC relations. Compared to the unstructured OSCTI text, such
structured threat behavior representation is more amenable to
automated processing and integration (Section III-C).

(2) Domain-Speciﬁc Query Language & Query Synthesis:
To facilitate threat hunting over system audit logging data,
THREATRAPTOR has an efﬁcient query subsystem that em-
ploys a concise and expressive domain-speciﬁc query lan-
guage, Threat Behavior Query Language (TBQL), to query the
log data stored in database backends. TBQL is a declarative
language that integrates a collection of critical primitives for
threat hunting in computer systems. For example, TBQL treats
system entities (i.e., ﬁles, processes, network connections) and
system events (i.e., ﬁle events, process events, network events)
as ﬁrst-class citizens, and provides explicit constructs for
entity/event types, event operations, and event path patterns.
With TBQL, complex multi-step system behaviors can be
easily speciﬁed and searched (Section III-D).

To bridge the threat behavior graph with the query sub-
system, THREATRAPTOR employs a query synthesis mecha-
nism that automatically synthesizes a TBQL query from the
constructed graph. This way, external knowledge about threat
behaviors can be automatically integrated in threat hunting.
No prior work has proposed a query language for threat
hunting that supports the same set of features as supported
in TBQL, and has considered the automation of the threat
hunting procedure via query synthesis (Section III-E).

It is important to note that THREATRAPTOR also supports
human-in-the-loop analysis via query editing:
the security
analyst can further revise the synthesized query to encode
domain knowledge about the speciﬁc enterprise. In practice,

threat hunting is an iterative process that involves multiple
rounds of query editing and execution, and the conciseness
and declarative nature of TBQL make this process efﬁcient.

(3) Efﬁcient Query Execution: To query the big data efﬁ-
ciently, THREATRAPTOR employs specialized optimizations
for data storage and query execution engine. Speciﬁcally,
THREATRAPTOR employs data reduction techniques to merge
excessive system events while preserving adequate informa-
tion. To execute a TBQL query, THREATRAPTOR decomposes
it into parts and compiles each part into a semantically equiv-
alent data query (i.e., a small SQL [29] or Cypher [30] query
that will be executed in PostgreSQL or Neo4j databases).
THREATRAPTOR then employs a scheduling algorithm to
schedule the execution of these data queries, based on their es-
timated pruning power and semantic dependencies. Compared
to the naive plan that compiles the TBQL query into a giant
SQL or Cypher query to execute, our execution plan avoids the
weaving of many joins and constraints together (which often
leads to slow performance) and leverages the query semantics
to speed up the execution. In addition to the exact search
mode, THREATRAPTOR supports a fuzzy search mode based
on inexact graph pattern matching, by extending [6]. This
mode generalizes to cases where the searched graph pattern
in a TBQL query deviates from the ground truth (could due
to IOC changes or structural differences), which improves the
generality of TBQL queries in threat hunting (Section III-F).
Evaluation. We deployed THREATRAPTOR on a physical
testbed and performed a broad set of attacks to evaluate
the system. The evaluation results demonstrate that:
(1)
THREATRAPTOR is able to accurately extract threat behaviors
from OSCTI text (96.64% F1 for IOC extraction, 92.59%
F1 for IOC relation extraction), performing much better than
general information extraction approaches (< 5% F1); (2)
THREATRAPTOR is able to accurately ﬁnd malicious system
activities using OSCTI text (98.34% F1); (3) the entire pipeline
of THREATRAPTOR is efﬁcient. The threat behavior extraction
and query synthesis parts take 0.52s on average. For query
execution (in exact search mode), TBQL queries execute 22.7x
faster than SQL queries for PostgreSQL backend, and 9.1x
faster than Cypher queries for Neo4j backend; (4) TBQL
queries are more concise than SQL queries (> 2.8x) and
Cypher queries (> 2.2x). To the best of our knowledge,
THREATRAPTOR is the ﬁrst system that bridges OSCTI with
system auditing to facilitate cyber threat hunting in computer
systems. A system demo video is available at [31].

OSCTIReportThreat Behavior ExtractionOSCTI Report ParsingIOC Entity ExtractionIOC RelationExtractionThreat Behavior GraphConstructionLogParsingSystem AuditLogging DataSystem AuditingOS KernelThreatRaptorThreat Behavior QueryLanguage (TBQL)TBQL QuerySynthesisTBQL QueryExecution EngineTBQL Query ParserThreat BehaviorGraphQuery-Based Threat HuntingThreatsSecurity AnalystDomain KnowledgeFig. 2: An example data leakage attack case demonstrating the whole processing pipeline of THREATRAPTOR

II. SYSTEM OVERVIEW

Figure 1 shows the architecture of THREATRAPTOR, which
consists of two subsystems: (1) a threat behavior extraction
pipeline for automated threat knowledge extraction, and (2) a
query subsystem built upon system auditing, which provides a
domain-speciﬁc query language, TBQL, to hunt for threats in
computer systems. In the query subsystem, monitoring agents
built upon mature frameworks [24]–[26] are deployed across
hosts to collect system audit logging data. The collected data
is sent to the central database for storage. Given an input
OSCTI report, THREATRAPTOR ﬁrst extracts IOCs (e.g., ﬁle
names/paths, IPs) and their relations, and constructs a threat
behavior graph. THREATRAPTOR then synthesizes a TBQL
query from the constructed graph, and executes the query to
ﬁnd the matched system auditing records. The security analyst
can optionally revise the synthesized query to encode domain
knowledge. In the situation where the OSCTI report is not
available, THREATRAPTOR can be used as a proactive threat
hunting tool with TBQL queries manually constructed.
Demo Example. Figure 2 shows an example data leakage
attack case demonstrating the whole pipeline. The case was
constructed based on the Cyber Kill Chain framework [32]
and CVE [33], and used in our evaluation (i.e., Case ra_2).
As we can see, the threat behavior graph clearly shows how the
threat unfolds into multiple connected steps, where each step
is represented by an IOC node-edge triplet. Furthermore, each
edge is associated with a sequence number indicating the step
order. Such sequential information is essential to uncovering
the correct threat scenario and has not been considered in
prior work [21], [22]. The synthesized TBQL query further
encodes the threat knowledge into formal query constructs,
which is more amenable to human-in-the-loop analysis and
iterative exploration. Nodes and edges in the threat behavior
graph are synthesized into system entities and system event
patterns in the TBQL query, and sequence numbers of edges
are used to construct a with clause that speciﬁes the temporal
order constraints of system event patterns. By default, the
synthesized TBQL query speciﬁes the default attributes of all
system entities (i.e., “name” for ﬁles, “exename” for processes,
and “dstip” for network connections) in the return clause.
Threat Model. Our threat model follows the prior work on
system auditing [3]–[8]. We assume an attacker that attacks the
computer system from outside: the attacker either utilizes the
vulnerabilities in the system or convinces the user to download
ﬁles with malicious payload. We also assume that OS kernels

Event Category
ProcessToFile
ProcessToProcess
ProcessToNetwork

Relevant System Call
read, readv, write, writev, execve, rename
execve, fork, clone
read, readv, recvfrom, recvmsg, sendto, write, writev

TABLE I: Representative system calls processed

Entity
File
Process
Network Connection

Attributes
Name, Path, User, Group
PID, Executable Name, User, Group, CMD
SRC/DST IP, SRC/DST Port, Protocol

TABLE II: Representative attributes of system entities

Operation Type
Time
Misc.

Read, Write, Execute, Start, End, Rename
Start Time, End Time, Duration
Subject ID, Object ID, Data Amount, Failure Code

TABLE III: Representative attributes of system events

and kernel-layer auditing frameworks are part of our trusted
computing base, and the system audit logging data collected
from kernel space is not tampered. We also do not consider
attacks that do not go through kernel-layer auditing (e.g., side
channel attacks, memory-based attacks) and thus cannot be
captured by system auditing frameworks.

III. DESIGN OF THREATRAPTOR

A. System Auditing

THREATRAPTOR leverages mature system auditing frame-
works [24]–[26] to collect system-level audit logs about sys-
tem calls from the OS kernel. The collected kernel audit logs
consist of system events that describe the interactions among
system entities, which are crucial for security analysis. As
shown in previous studies [3]–[8], on mainstream operating
systems, system entities in most cases are ﬁles, processes,
and network connections, and the monitored system calls are
mapped to three major types of system events: ﬁle access,
processes creation and destruction, and network access. Hence,
in THREATRAPTOR, we consider system entities as ﬁles, pro-
cesses, and network connections. We consider a system event
as the interaction between two system entities represented as
(cid:104)subject_entity, operation, object_entity(cid:105), which consists of the
initiator of the interaction, the type of the interaction, and the
target of the interaction. Subjects are processes originating
from software applications (e.g., Chrome), and objects can
be ﬁles, processes, and network connections. We categorize
system events into three types according to the types of their
object entities: ﬁle events, process events, and network events.
THREATRAPTOR parses the collected audit logs of system
calls (Table I) into a sequence of system events among system
entities, and extracts a set of attributes that are crucial for se-
curity analysis (Tables II and III). To uniquely identify system
entities, for a process entity, THREATRAPTOR uses the process

After the lateral movement stage, the attacker attempts to steal valuable assets from the host. This stage mainly involves the behaviors of local and remote file system scanning activities, copying and compressing of important files, and transferring the files to its C2 host. The details of the data leakage attack are as follows. As a first step, the attacker used /bin/tar to read user credentials from /etc/passwd. It wrote the gathered information to a file /tmp/upload.tar. Then, the attacker leveraged /bin/bzip2 utility to compress the tar file. /bin/bzip2 read from /tmp/upload.tar and wrote to /tmp/upload.tar.bz2. After compression, the attacker used Gnu Privacy Guard (GnuPG) tool to encrypt the zipped file, which corresponds to the launched process /usr/bin/gpg reading from /tmp/upload.tar.bz2. /usr/bin/gpg then wrote the sensitive information to /tmp/upload. Finally, the attacker leveraged the curl utility (/usr/bin/curl) to read the data from /tmp/upload. He leaked the gathered sensitive information back to the attacker C2 host by using /usr/bin/curl to connect to 192.168.29.128./bin/tar, /etc/passwd,/tmp/upload.tar,/bin/bzip2,/tmp/upload.tar.bz2,/usr/bin/gpg, /tmp/upload,/usr/bin/curl,192.168.29.128/32OSCTI TextThreat Behavior GraphTBQL QuerySystem AuditingRecordsproc p1["%/bin/tar%"] read filef1["%/etc/passwd%"] as evt1proc p1 write file f2["%/tmp/upload.tar%"] as evt2proc p2["%/bin/bzip2%"] read file f2 as evt3proc p2 write file f3["%/tmp/upload.tar.bz2%"] asevt4proc p3["%/usr/bin/gpg%"] read file f3 as evt5proc p3 write file f4["%/tmp/upload%"] as evt6proc p4["%/usr/bin/curl%"] read file f4 as evt7proc p4["%/usr/bin/curl%"] connect ipi1["192.168.29.128"] as evt8with evt1 before evt2, evt2 before evt3, evt3before evt4, evt4 before evt5, evt5 before evt6,evt6 before evt7, evt7 before evt8return distinct p1, f1, f2, p2, f3, p3, f4, p4, i1Threat BehaviorExtractionTBQL QuerySynthesisTBQL QueryExecutionexecutable name and PID as its unique identiﬁer. For a ﬁle
entity, THREATRAPTOR uses the absolute path as its unique
identiﬁer. For a network connection entity, THREATRAPTOR
uses the 5-tuple (cid:104)srcip, srcport, dstip, dstport, protocol(cid:105) as its
unique identiﬁer [5]. Failing to distinguish different entities
will cause problems in relating events to entities.

B. Data Storage

THREATRAPTOR stores the parsed system entities and sys-
tem events in databases, so that the system audit logging data
can be persisted. Prior work has modeled system audit logging
data as either relational tables [7] or provenance graphs [5].
Inspired by such designs, THREATRAPTOR adopts two types
of database models for its storage component: relational model
and graph model. Relational databases come with mature
indexing mechanisms and are scalable to massive data, which
are suitable for queries that involve many joins and constraints.
Graph databases represent data as nodes and edges, which are
suitable for queries that involve graph pattern search.

Currently, THREATRAPTOR adopts PostgreSQL [27] for
its relational storage and Neo4j [28] for its graph storage.
For PostgreSQL, THREATRAPTOR stores system entities and
system events in separate tables. For Neo4j, THREATRAPTOR
stores system entities as nodes and system events as edges.
Data is replicated across the two databases, which supports
the execution of different types of queries (Section III-F) and
improves data availability. Indexes are created on key attributes
(e.g., ﬁle name, process executable name, source/destination
IP) for both databases to speed up the search.
Data Reduction. THREATRAPTOR further reduces the data
size before storing it in databases, so that the search can
be done more efﬁciently while the critical information about
malicious behaviors is still preserved. System audit logging
data often has many excessive events between the same
entity pair [23]. The reason is that OS typically ﬁnishes
a read/write task (e.g., ﬁle read/write) by distributing the
data proportionally to multiple system calls. Inspired by a
log reduction work [23], THREATRAPTOR merges the events
between two entities using the following criteria: (1) two
events e1(u1, v1) and e2(u2, v2) (u1, u2 are subjects and
v1, v2 are objects; suppose e1 occurs before e2) will be
merged if: u1 = u2 && v1 = v2 && e1.operationT ype =
e2.operationT ype && 0 ≤ e2.startT ime − e1.endT ime ≤
threshold; (2) the attributes of the merged event em are
updated as: em.startT ime = e1.startT ime, em.endT ime =
e2.endT ime,
em.dataAmount = e1.dataAmount +
e2.dataAmount. We experimented with different threshold
and chose 1 second, as it has reasonable reduction performance
in merging system events for ﬁle manipulations, ﬁle transfers,
and network communications, with no false events generated.

C. Threat Behavior Extraction

As mentioned in Section I, massive nuances exist in OS-
CTI text (e.g., dots, underscores in IOCs), which limit the
performance of most NLP modules and existing information
extraction tools [21], [22]. To address the unique challenge,

Algorithm 1: Threat Behavior Extraction Pipeline

Input
: OSCTI Text: document
Output: Threat Behavior Graph: graph

Initialize all_block_trees;
Initialize all_ioc_relations;
for block in SegmentBlock(document) do

Initialize trees;
block, replacementRecord ← ProtectIoc(block);
for sentence in SegmentSentence(block) do

tree ← ParseDependency(sentence);
Align replacementRecord with tree;
tree ← RemoveIocProtection(tree, replacementRecord);
tree ← AnnotateTree(tree);
tree ← SimplifyTree(tree);
Add tree to trees;

for tree in trees do

tree ← ResolveCoref(tree, trees);

1

2

3

4

5

6

7

8

9

10

11

12

13

14

Add all tree in trees to all_block_trees;

15
16 all_iocs ← ScanMergeIoc(all_block_trees);
17 for tree in trees do
18

ioc_relations ← ExtractIocRelation(tree, trees, all_iocs);
Add ioc_relations to all_ioc_relations;

19
20 graph ← ConstructGraph(all_iocs, all_ioc_relations);

THREATRAPTOR employs a specialized NLP pipeline to han-
dle nuances and accurately extract IOCs and their relations to
construct a threat behavior graph. Furthermore, our pipeline is
unsupervised and light-weight. Algorithm 1 gives the pipeline:
Step 1: Block Segmentation (Line 3): We segment an article
into blocks, and extract IOCs and their relations from each
block. Later on, when we construct the threat behavior graph,
we will link the same IOCs that appear across multiple blocks.
Step 2: IOC Recognition and IOC Protection (Line 5):
We construct a set of regex rules by extending an open-
source IOC parser [34] (we made improvements to improve
its coverage, e.g., distinguishing Linux/Windows ﬁle paths) to
recognize different types of IOCs (e.g., ﬁle name, ﬁle path,
IP). Furthermore, we protect the security context by replacing
the IOCs with a dummy word (we use the word “something”)
and leave a replacement record. This makes the NLP modules
designed for processing general text work well for OSCTI text.
Step 3: Sentence Segmentation (Line 6): We segment a block
into sentences using a sentence segmentation component [35].
Step 4: Dependency Parsing (Line 7): We construct a
dependency tree for each sentence using a dependency parsing
component [35] pretrained on a large general corpus. We then
use the replacement record of IOCs to restore the security
context by replacing the dummy word with the original IOCs.
Step 5: Tree Annotation (Line 10): Among all nodes in
the dependency trees, there are some nodes whose associated
tokens are particularly useful for coreference resolution and
relation extraction (e.g., IOCs, candidate IOC relation verbs,
pronouns). We annotate these nodes of interest in the trees. We
curated a list of keywords that correspond to candidate IOC
relation verbs (e.g., “read”, “write”, “download”, “open”).

Step 6: Tree Simpliﬁcation (Line 11): We simplify the
annotated trees by removing irrelevant nodes and paths (i.e.,
removing the trees without any candidate IOC relation verbs or
the paths without any IOC nodes). This step does not inﬂuence
the extraction outcome, but helps speed up the performance.
Step 7: Coreference Resolution (Line 14): Across all trees
of all sentences within a block, we resolve the coreferenced

nodes for the same IOC by checking their POS tags and
dependencies, and create connections between the nodes in
the trees. After this step, we have a set of ﬁnal annotated,
simpliﬁed dependency trees for the OSCTI text.

Step 8: IOC Scan and Merge (Line 16): As the same IOC
may appear across different blocks in different phrases, we
scan all IOCs in the dependency trees of all blocks, and merge
similar ones based on both the character-level overlap and the
semantic similarity of word vectors (we used word vectors in
spaCy [35]). This is different from Step 7, which performs
coreference resolution within a block. After this step, we have
a set of ﬁnal IOCs served as nodes in the threat behavior graph.
Step 9: IOC Relation Extraction (Line 18): We present the
details of our dependency parsing-based IOC relation extrac-
tion algorithm: (1) For each dependency tree, we enumerate
all pairs of IOCs nodes; (2) Then, for each pair of IOC nodes,
we check whether they satisfy the subject-object relation by
considering their dependency types in the tree. In particular,
we consider three parts of their dependency path: one common
path from the root to the LCA (Lowest Common Ancestor);
two individual paths from the LCA to each of the nodes, and
construct a set of dependency type rules to do the checking;
(3) Next, for the pair that passes the checking, we extract
its relation verb by ﬁrst scanning all the annotated candidate
verbs (annotations are done in Step 5 using our curated list)
in the aforementioned three parts of dependency path, and
then selecting the one that is closest to the object IOC node;
(4) The candidate IOC node pair and the selected verb (after
lemmatization) form the ﬁnal IOC entity-relation triplet. Note
that for a token to be output as the ﬁnal relation verb, it needs
to be both covered by our keyword list and form the correct
subject-verb-object relation with the IOC node pair tokens.

Step 10: Threat Behavior Graph Construction (Line 20):
We iterate over all IOC entity-relation triplets sorted by the
occurrence offset of the relation verb in OSCTI text, and
construct a threat behavior graph. Each edge in the graph is
associated with a sequence number, indicating the step order.

D. Threat Behavior Query Language (TBQL)

THREATRAPTOR provides a domain-speciﬁc language,
TBQL (Grammar 1), to facilitate threat hunting over system
audit logging data. Compared to low-level and verbose general
query languages (SQL [29], Cypher [30]), TBQL integrates
a collection of critical primitives, making it easy to specify
complex multi-step system behaviors for hunting.

(1) Event Pattern Syntax: The basic syntax of TBQL follows
our prior work [7], which speciﬁes one or more system
event patterns in the format of (cid:104)subject_entity, operation,
object_entity(cid:105), with optional ﬁlters on temporal and attribute
relationships between event patterns. System entities have
explicit types and identiﬁers, with optional ﬁlters on attributes.
Essentially, the speciﬁed event patterns form a subgraph of
system events to be searched. Figure 2 shows an example.

Speciﬁcally, in Grammar 1, the (cid:104)patt(cid:105) rule speciﬁes an
event pattern, including the subject/object entity ((cid:104)entity(cid:105)),
the operation ((cid:104)op_exp(cid:105)), the pattern ID ((cid:104)patt_id(cid:105)), and the

::= ((cid:104)global_ﬁlter(cid:105))* ((cid:104)patt(cid:105))+ (cid:104)rel(cid:105)? (cid:104)return(cid:105)

(cid:104)tbql(cid:105)
(cid:104)global_ﬁlter(cid:105) ::= (cid:104)attr_exp(cid:105) | (cid:104)wind(cid:105)
(cid:104)patt(cid:105)
(cid:104)entity(cid:105)
(cid:104)entity_type(cid:105) ::= ‘file’ | ‘proc’ | ‘ip’
(cid:104)op_exp(cid:105)

::= (cid:104)op(cid:105)

::= (cid:104)entity(cid:105) ((cid:104)op_exp(cid:105) | (cid:104)op_path(cid:105)) (cid:104)entity(cid:105) (cid:104)patt_id(cid:105)? (cid:104)wind(cid:105)?
::= (cid:104)entity_type(cid:105) (cid:104)id(cid:105) (‘[’ (cid:104)attr_exp(cid:105)‘]’)?

|
|
|

‘!’(cid:104)op_exp(cid:105)
(cid:104)op_exp(cid:105) (‘&&’ | ‘||’) (cid:104)op_exp(cid:105)
‘(’ (cid:104)op_exp(cid:105) ‘)’

(cid:104)op(cid:105)
(cid:104)op_path(cid:105)
(cid:104)patt_id(cid:105)
(cid:104)attr_exp(cid:105)

::= ‘read’ | ‘write’ | ‘start’ | ‘execute’|...
::= (‘~>’ | ‘->’) (‘(’(cid:104)int(cid:105)? ‘~’? (cid:104)int(cid:105)? ‘)’)? (‘[’ (cid:104)op_exp(cid:105) ‘]’)?
::= ‘as’ (cid:104)id(cid:105) (‘[’ (cid:104)attr_exp(cid:105)‘]’)?
::= (cid:104)attr(cid:105) (cid:104)bop(cid:105) (cid:104)val(cid:105)

|
|
|
|

‘!’? (cid:104)val(cid:105)
(cid:104)attr(cid:105) ‘not’? ‘in’ (cid:104)val_set(cid:105)
(cid:104)attr_exp(cid:105) (‘&&’ | ‘||’) (cid:104)attr_exp(cid:105)
‘(’ (cid:104)attr_exp(cid:105) ‘)’

::= (cid:104)id(cid:105) (‘.’ (cid:104)id(cid:105))?
::= ‘from’ (cid:104)datetime(cid:105) ‘to’ (cid:104)datetime(cid:105)

|
|

(‘at’ | ‘before’ | ‘after’) (cid:104)datatime(cid:105)
‘last’ (cid:104)num(cid:105) (cid:104)time_unit(cid:105)

(cid:104)attr(cid:105)
(cid:104)wind(cid:105)

(cid:104)rel(cid:105)

::= ‘with’ (cid:104)id(cid:105) (‘before’ | ‘after’ | ‘within’) (‘[’ (cid:104)num(cid:105)

‘-’ (cid:104)num(cid:105) (cid:104)time_unit(cid:105)‘]’)? (cid:104)id(cid:105)
‘with’ (cid:104)attr(cid:105) (cid:104)bop(cid:105) (cid:104)attr(cid:105)

|

(cid:104)return(cid:105)

::= ‘return’ ‘distinct’? (cid:104)attr(cid:105) (‘,’ (cid:104)attr(cid:105))*

Grammar 1: Representative BNF grammar of TBQL

optional time window ((cid:104)wind(cid:105)). The (cid:104)entity(cid:105) rule speciﬁes
the entity type, the entity ID, and the optional attribute ﬁlter
expression ((cid:104)attr_exp(cid:105)). Operators (e.g., logical, comparison)
are supported in (cid:104)op_exp(cid:105) and (cid:104)attr_exp(cid:105) to form complex
expressions (e.g., proc p[pid = 1 && exename = "%chrome.
exe%"] read || write file f, where % matches any charac-
ter sequence). The (cid:104)wind(cid:105) rule speciﬁes a time window that
narrows down the search. The (cid:104)global_ﬁlter(cid:105) rule speciﬁes the
global ﬁlters for all event patterns. The (cid:104)rel(cid:105) rule speciﬁes the
relationship between event patterns. TBQL supports two types
of relationships: temporal relationship (e.g., evt1 before[0-5
min] evt2 speciﬁes a temporal order of events), and attribute
the two
relationship (e.g., p1.pid = p2.pid speciﬁes that
processes have the same PID). The (cid:104)return(cid:105) rule speciﬁes the
attributes of the matched events for return.

In addition, TBQL provides different types of syntactic

sugars to facilitate the query construction:

• Default attributes for system entities: default attribute names
will be inferred if the user only speciﬁes attribute values
in an event pattern, or entity IDs in the return clause.
We select the most commonly used attributes in security
analysis as default attributes: “name” for ﬁles, “exename”
for processes, and “dstip” for network connections.

• Entity ID reuse: reusing an entity ID in multiple event
patterns implicitly indicates that the entities are the same.

file f1["%/etc/passwd%"],

in the TBQL query in Figure 2, proc
For example,
p1["%/bin/tar%"],
ip i1[
"192.168.29.128"], and return p1 will be inferred as
proc p1[exename = "%/bin/tar%"],
file f1[name = "%/
etc/passwd%"],
and
return p1.exename. Besides, the entity ID p1 is used in both
evt1 and evt2, indicating the same system entity.

ip i1[dstip = "192.168.29.128"],

(2) Variable-Length Event Path Pattern Syntax: In addition
to the basic event pattern syntax, THREATRAPTOR uniquely
provides an advanced syntax that speciﬁes various types of
variable-length paths of system event patterns. The (cid:104)op_path(cid:105)

rule gives the core syntax, which provides several alternatives:
• proc p ~>[read] file f: a path of arbitrary length from a
process entity p to a ﬁle entity f. The operation type of the
ﬁnal hop (i.e., system event where f is an object) is read.
• proc p ~>(2~4)[read] file f: the path has a minimum

length of 2 and a maximum length of 4.

• proc p ~>(2~)[read] file f:

the path has a minimum

length of 2. The maximum length is not restricted.

• proc p ~>(~4)[read] file f: the path has a maximum

length of 4. The minimum length is 1.

• proc p ->[read] file f: the path has a length of 1. This
is semantically equivalent to the basic event pattern syntax,
e.g., proc p read file f. The difference lies in the execu-
tion: this length-1 event path pattern will be compiled into
a Cypher data query executed on the Neo4j database, while
the basic event pattern will be compiled into a SQL data
query executed on the PostgreSQL database.

• proc p ~> file f: the operation type of the ﬁnal hop is
omitted, indicating that the search allows any operation type.
This syntax is particularly useful when doing query syn-
thesis: in certain cases, an edge in the threat behavior graph
(hence a threat step between two IOCs in OSCTI text) may
correspond to a path of system events in system audit logs.
This happens often when intermediate processes are created to
chain system events, but are omitted in the OSCTI text by the
human writer. With this syntax, the information ﬂow between
two system entities can be easily speciﬁed and the semantic
gap between the OSCTI text and the system audit logs can
be bridged. We use “TBQL pattern” to refer to both the event
pattern and the variable-length event path pattern.

E. TBQL Query Synthesis

To facilitate threat hunting with OSCTI, THREATRAPTOR
provides a query synthesis mechanism that automatically syn-
thesizes a TBQL query from the threat behavior graph.

Step 1: Pre-Synthesis Screening & IOC Relation Mapping:
One challenge in query synthesis is the semantic gap between
the types of IOCs and IOC relations, and the types of system
entities and their operations. To bridge the gap, THREATRAP-
TOR ﬁrst performs a pre-synthesis screening to ﬁlter out nodes
(and connected edges) in the threat behavior graph whose
associated IOC types are not currently captured by the system
auditing component (e.g., registry entries). Then, for each
remaining edge, THREATRAPTOR maps its associated IOC
relation to the TBQL operation type (e.g., (cid:104)op(cid:105) rule in Gram-
mar 1). We constructed a set of rules for IOC relation mapping,
which consider both the semantic meaning of the IOC relation
and the types of the connected IOC nodes. For example, the
“download” relation between two “Filepath” IOCs will be
mapped to the “write” operation in TBQL, indicating a process
writes data to a ﬁle. In contrast, the “download” relation from a
“Filepath” IOC to an “IP” IOC will be mapped to the “read”
operation in TBQL, indicating a process reads data from a
network connection. THREATRAPTOR further ﬁlters out edges
whose associated IOC relations do not match any rules.

Step 2: TBQL Pattern Synthesis: For each node in the threat
behavior graph, THREATRAPTOR synthesizes a TBQL system
entity (i.e., rule (cid:104)entity(cid:105)) and assigns a unique entity ID: (1)
for a source node, THREATRAPTOR synthesizes a process
entity; (2) for a sink node, THREATRAPTOR synthesizes a
network connection entity if its associated IOC type is an
IP. Otherwise, THREATRAPTOR synthesizes a ﬁle entity or
a process entity depending on the associated IOC relation of
the edge. THREATRAPTOR then synthesizes the attribute of the
entity using the associated IOC content. Wildcard operators %
are added around the attribute string by default.

THREATRAPTOR synthesize a TBQL pattern (i.e., rule
(cid:104)patt(cid:105)) by connecting the synthesized TBQL subject & object
entities and the mapped TBQL operation. By default, an event
pattern is synthesized. System administrator can conﬁgure the
system to synthesize a variable-length event path pattern.

Step 3: TBQL Pattern Relationship Synthesis: For TBQL
event patterns, THREATRAPTOR synthesizes their temporal
relationships by following an ascending order of the sequence
numbers of corresponding edges in the threat behavior graph.
For variable-length event path patterns, this step is omitted
since event paths in TBQL do not have temporal relationships.
Step 4: TBQL Return Synthesis: To synthesize the TBQL
return clause, THREATRAPTOR by default appends all entity
IDs to the “return” string. Default attribute names will be
inferred when the query is executed and the corresponding
attribute values will be returned (i.e., TBQL syntactic sugars).
Figure 2 shows an example TBQL query synthesized using
the default synthesis plan. In addition, THREATRAPTOR sup-
ports user-deﬁned synthesis plans to overwrite the default plan
and synthesize attributes that are supported but not captured
in the threat behavior graph (e.g., hostname, time window).

F. TBQL Query Execution

To efﬁciently execute a TBQL query with many TBQL
patterns (could be a mix of event patterns and variable-
length event path patterns), THREATRAPTOR extends our
prior work [7] by (1) compiling each TBQL pattern into a
semantically equivalent SQL or Cypher data query, and (2)
scheduling the execution of these data queries in different
database backends (i.e., PostgreSQL and Neo4j) based on
their estimated pruning power and semantic dependencies ( [7]
does not involve variable-length event path patterns and Neo4j
backend). Speciﬁcally, for an event pattern, THREATRAPTOR
compiles it into a SQL data query, so that the mature indexing
mechanism and the efﬁcient support for joins in relational
databases can be leveraged. The compiled SQL query joins
two system entity tables with one system event table, and
applies the ﬁlters in the WHERE clause. For a variable-length
event path pattern, since it is difﬁcult to perform graph pattern
search using SQL, THREATRAPTOR compiles it into a Cypher
data query by leveraging Cypher’s path pattern syntax [30].

We now present our data query scheduling algorithm: For
each TBQL pattern, THREATRAPTOR computes a pruning
score by counting the number of constraints declared; a
TBQL pattern with more constraints has a higher score. For a

variable-length event path pattern, we additionally consider the
length of the path when computing the score; a pattern with a
smaller maximum path length has a higher score. Then, when
scheduling the execution of the data queries, THREATRAPTOR
considers both the pruning scores and the pattern dependen-
cies: if two TBQL patterns have dependencies (e.g., connected
by the same system entity), THREATRAPTOR will ﬁrst execute
the data query whose associated pattern has a higher pruning
score, and then use the execution results to constrain the
execution of the other data query (by adding ﬁlters). This way,
complex TBQL queries with various TBQL patterns can be
efﬁciently executed in different database backends seamlessly.
In addition to the search mode based on exact matching,
THREATRAPTOR supports a fuzzy search mode based on
inexact graph pattern matching [6]. The user can use this mode
as an alternative when the exact search mode fails to retrieve
meaningful results, allowing the generality of searching while
at the cost of a longer execution time. Intuitively, a TBQL
query speciﬁes a subgraph of system events to be searched,
and inexact graph pattern matching can be naturally leveraged
in query execution to enable fuzzy search. In the current
design, our fuzzy search mode leverages Poirot [6] to search
for both node-level alignment and graph-level alignment: (1)
For node-level alignment, we use Levenshtein distance [36]
to perform similarity matching of IOC strings speciﬁed in
the TBQL query and attributes of system entities stored in
the database, so that typos or small changes in IOCs can
still retrieve the correct system entities; (2) For graph-level
alignment, we match the subgraph pattern speciﬁed in the
TBQL query with the provenance graph of system events.
We borrow Poirot’s idea that measures the potential attacker
inﬂuence by the number of compromised ancestor processes.
By calculating Poirot’s graph alignment scores for all candi-
date alignments, THREATRAPTOR’s query execution engine
produces an exhaustive searching result for aligned subgraphs
of system events, and returns the entity attributes speciﬁed in
the return clause as ﬁnal results. Sections IV-B4 and VI
include evaluation results and comparison with Poirot.

IV. EVALUATION

We built THREATRAPTOR (∼ 25K LOC) upon several
tools: Sysdig [26] for system auditing, PostgreSQL [27] and
Neo4j [28] for system audit logging data storage, Python and
spaCy [35] for threat behavior extraction, ANTLR 4 [37] for
TBQL language parser, and Java for the whole system.

We deployed THREATRAPTOR on a physical testbed to
collect real system audit logs and hunt for malicious activities.
We evaluated THREATRAPTOR on a broad set of attack
cases. In total, the audit logs used in our evaluations contain
47, 688, 033 system entities and 55, 840, 381 system events.
We aim to answer the following research questions:
• RQ1: How accurate is THREATRAPTOR in extracting threat
behaviors from OSCTI text compared to general information
extraction approaches?

• RQ2: How accurate is THREATRAPTOR in ﬁnding mali-

cious system activities using OSCTI text?

Case ID
tc_clearscope_1
tc_clearscope_2
tc_clearscope_3
tc_ﬁvedirections_1
tc_ﬁvedirections_2
tc_ﬁvedirections_3
tc_theia_1
tc_theia_2
tc_theia_3
tc_theia_4
tc_trace_1
tc_trace_2
tc_trace_3
tc_trace_4
tc_trace_5
password_crack
data_leak
vpnﬁlter

Case Name
20180406 1500 ClearScope – Phishing E-mail Link
20180411 1400 ClearScope – Firefox Backdoor w/ Drakon In-Memory
20180413 ClearScope
20180409 1500 FiveDirections – Phishing E-mail w/ Excel Macro
20180411 1000 FiveDirections – Firefox Backdoor w/ Drakon In-Memory
20180412 1100 FiveDirections – Browser Extension w/ Drakon Dropper
20180410 1400 THEIA – Firefox Backdoor w/ Drakon In-Memory
20180410 1300 THEIA - Phishing Email w/ Link
20180412 THEIA - Browser Extension w/ Drakon Dropper
20180413 1400 THEIA - Phishing E-mail w/ Executable Attachment
20180410 1000 TRACE – Firefox Backdoor w/ Drakon In-Memory
20180410 1200 TRACE – Phishing E-mail Link
20180412 1300 TRACE – Browser Extension w/ Drakon Dropper
20180413 1200 TRACE – Pine Backdoor w/ Drakon Dropper
20180413 1400 TRACE – Phishing E-mail w/ Executable Attachment
Password Cracking After Shellshock Penetration
Data Leakage After Shellshock Penetration
VPNFilter

TABLE IV: 18 attack cases in our evaluation benchmark

• RQ3: How efﬁcient is THREATRAPTOR in extracting threat
behaviors from OSCTI text, constructing a threat behavior
graph, and synthesizing a TBQL query?

• RQ4: How efﬁcient is THREATRAPTOR in executing TBQL

queries over the big system audit logging data?

• RQ5: How concise is TBQL in specifying malicious system
behaviors compared to general-purpose query languages?
RQ1 aims evaluate the accuracy of THREATRAPTOR in
threat behavior extraction. RQ2 aims to evaluate the end-
to-end accuracy of THREATRAPTOR in threat hunting using
OSCTI. RQ3 aims to evaluate the efﬁciency of THREATRAP-
TOR in threat behavior extraction, threat behavior graph con-
struction, and TBQL query synthesis. RQ4 aims to evaluate
the efﬁciency of THREATRAPTOR in TBQL query execution,
and measure the performance speedup achieved by the TBQL
query scheduler. RQ5 aims to evaluate the conciseness of
TBQL in expressing complex system behaviors.

A. Evaluation Setup

The deployed server has an Intel(R) Xeon(R) CPU E5-2637
v4 (3.50GHz), 256GB RAM running 64bit Ubuntu 18.04.1.
The server is frequently used by > 15 active users to perform
various daily tasks, including ﬁle manipulation, text editing,
and software development. To evaluate THREATRAPTOR, we
constructed an evaluation benchmark of 18 attack cases from
two sources: 15 cases released in the DARPA TC dataset [38],
and 3 multi-step intrusive attacks that we performed ourselves
on the testbed based on the Cyber Kill Chain framework [32]
and CVE [33]. When we perform the attacks and conduct
the evaluations, the sever continues to serve other users. This
setup ensures that enough noise of benign background trafﬁc is
collected in together with malicious activities, representing the
real-world deployment. Furthermore, benign activities signiﬁ-
cantly outnumber attack activities (55 million vs. thousands),
demonstrating the challenge in threat hunting. Table IV shows
the list of cases. The total monitoring length is 41 days for
DARPA TC cases and 16 hours for our three attacks.

1) DARPA TC Attack Cases: We selected 15 cases from
the DARPA TC Engagement 3 data release [38], which cover
various combinations of OSs (e.g., Linux, Windows, An-
droid), vulnerabilities (e.g., Nginx backdoor, Firefox backdoor,
browser extension), and exploits (e.g., Drakon APT, micro
APT, phishing email with malicious Excel attachment).

Speciﬁcally, the dataset consists of the captured audit logs
of six performer systems (ClearScope, FiveDirections, THEIA,

TRACE, CADETS, and TA5.2) under the penetration of the
red team using different attack strategies, which include both
benign and malicious system activities. The dataset also in-
cludes a ground-truth report that has attack descriptions for the
cases. After examining the descriptions and the logs, we found
that the logs for TA5.2 are missing in the released dataset and
the logs for CADETS lack key attributes (e.g., ﬁle name). This
makes us unable to conﬁrm the attack ground truth to conduct
faithful evaluations. Thus, we do not consider these cases
in our evaluations. Nevertheless, similar attacks were already
performed for other performer systems and their descriptions
and logs are covered in our evaluations. For the other four
performer systems, we selected all the 15 attack cases in our
evaluation benchmark. For each case, we parsed the provided
audit logs and loaded the data in THREATRAPTOR’s databases.
We then extracted the attack description text from the ground-
truth report and use it as input to THREATRAPTOR.

2) Multi-Step Intrusive Attack Cases: To increase the cov-
erage of our benchmark, we constructed 3 multi-step intrusive
attack cases, based on CVE [33] and capture the important
traits of attacks depicted in the Cyber Kill Chain frame-
work [32] (e.g., including the stages of initial penetration, data
exﬁltration). We performed these attacks on the testbed and
collected system audit logs. The attack description texts were
constructed according to the way the attacks were performed.

Attack 1: Password Cracking After Shellshock Penetra-
tion. The attacker penetrates into the victim host (i.e., the
testbed) by exploiting the Shellshock vulnerability [39]. After
penetration, the attacker ﬁrst connects to cloud services (Drop-
box) and downloads an image where C2 (Command & Con-
trol) server’s IP address is encoded in the EXIF metadata. This
behavior is a common practice shared by APT attacks [40] to
evade DNS blacklisting based detection systems. Using the IP,
the attacker downloads a password cracker from the C2 server
to the victim host, and then runs the password cracker against
password shadow ﬁles to extract clear text.

Attack 2: Data Leakage After Shellshock Penetration.
After the reconnaissance, the attacker attempts to steal all
the valuable assets from the victim host. This stage mainly
involves the behaviors of local and remote ﬁle system scanning
activities, copying and compressing of important ﬁles, and
transferring the ﬁles to the C2 server. The attacker scans the
ﬁle system, scrapes ﬁles into a single compressed ﬁle, and
transfers it back to the C2 server.

Attack 3: VPNFilter. The attacker seeks to maintain a direct
connection to the victim host from the C2 server. The attacker
utilizes the notorious VPNFilter malware [41] which infected
millions of IoT devices by exploiting a number of known or
zero-day vulnerabilities. After the initial penetration on the
victim host, the attacker downloads the VPNFilter stage 1
malware from the C2 server, which accesses a public image
repository to get an image. In the EXIF metadata of the image,
the IP address for the stage 2 server is encoded. The stage 1
malware then downloads the VPNFilter stage 2 malware from

the stage 2 server, and executes it to launch the VPNFilter
attack, which establishes a direct connection to the C2 server.

B. Evaluation Results

1) RQ1: Accuracy of Threat Behavior Extraction: To eval-
uate the accuracy of THREATRAPTOR in extracting threat
behaviors from OSCTI text, we labeled the OSCTI texts based
on the ground truth and measure the precision, recall, and F1
of the extracted IOC entities and IOC relations. We compare
THREATRAPTOR with two state-of-the-art open information
extraction approaches for entity and relation extraction from
general text: Stanford Open IE [21] and Open IE 5 [22].
Furthermore, we are interested in studying the effect of IOC
Protection on the accuracy of IOC entity and relation extrac-
tion. Thus, we also compare THREATRAPTOR with the version
of THREATRAPTOR without IOC Protection, Stanford Open
IE with IOC Protection, and Open IE 5 with IOC Protection.
Table V shows the precision, recall, and F1 score aggregated
over all evaluation cases. We have the following observations:
(1) THREATRAPTOR achieves the highest precision, recall,
and F1 score for both IOC entity extraction and IOC relation
extraction. In particular, THREATRAPTOR has 96.64% F1 for
IOC entity extraction and 92.59% F1 for IOC relation extrac-
tion. In contrast, the scores of Stanford Open IE and Open IE
5 are very low: < 5% F1 for IOC entitiy extraction and 0%
F1 for IOC relation extraction. These results demonstrate the
effectiveness of THREATRAPTOR’s specialized threat behavior
extraction NLP pipeline in processing OSCTI text; (2) When
removing IOC Protection, the scores of THREATRAPTOR drop
signiﬁcantly (59.26% F1 for IOC entity extraction and 16.39%
F1 for IOC relation extraction). The reason for the accuracy
drop is that if the OSCTI text is processed directly by an NLP
component without ﬁrst applying IOC Protection, the sentence
segmentation component and the tokenizer will break the
IOC entities (e.g., ﬁle paths, process executable names, IPs)
into pieces, making it impossible to annotate the pieces and
analyzing the correct grammatical structure of sentences. This
demonstrates the effectiveness of IOC Protection in protecting
the security context in OSCTI text; (3) When adding IOC
Protection, the scores of Stanford Open IE and Open IE 5
increase a bit, but not much. This again demonstrates the
effectiveness of IOC Protection in improving the accuracy of
other NLP components. Though, as these approaches target
general information extraction instead of threat behavior ex-
traction from OSCTI text, their performance is limited.

2) RQ2: Accuracy of Threat Hunting: To measure the end-
to-end accuracy of THREATRAPTOR in threat hunting, for each
attack case, we compare the system events found by the event
patterns in the synthesized TBQL query, and the ground-truth
system events that are related to the attack. Table VI shows the
precision and recall. We have the following observations: (1)
THREATRAPTOR is able to accurately ﬁnd malicious system
events using OSCTI texts, achieving 100% precision, 96.74%
recall, and 98.34% F1. This is largely due to the high accu-
racy achieved by THREATRAPTOR’s threat behavior extraction
pipeline; (2) Though some excessive event patterns may be

Approaches
THREATRAPTOR
THREATRAPTOR- IOC Protection
Stanford Open IE
Stanford Open IE + IOC Protection
Open IE 5
Open IE 5 + IOC Protection

Entity Precision
96.00%
94.12%
1.82%
4.39%
0.25%
3.49%

Entity Recall
97.30%
43.24%
14.86%
36.49%
1.35%
20.27%

Entity F1
96.64%
59.26%
3.24%
7.84%
0.43%
5.95%

Relation Precision
96.15%
100.00%
0.00%
0.88%
0.00%
0.00%

Relation Recall
89.29%
8.93%
0.00%
8.93%
0.00%
0.00%

Relation F1
92.59%
16.39%
0.00%
1.59%
0.00%
0.00%

TABLE V: Precision, recall, and F1 of IOC entity extraction and IOC relation extraction of THREATRAPTOR and
baseline approaches. The results are aggregated overall all 18 cases.

Case

tc_clearscope_1
tc_clearscope_2
tc_clearscope_3
tc_ﬁvedirections_1
tc_ﬁvedirections_2
tc_ﬁvedirections_3
tc_theia_1
tc_theia_2
tc_theia_3
tc_theia_4
tc_trace_1
tc_trace_2
tc_trace_3
tc_trace_4
tc_trace_5
password_crack
data_leak
vpnﬁlter
Total

Precision
TP/(TP+FP)
6/6
3/3
1/1
51/51
3/3
0/0
3/3
115/115
3/3
421/421
39/39
7/7
0/0
1/1
578/578
10/10
6/6
178/178

Recall
TP/(TP+FN)
6/6
3/3
1/1
51/51
3/3
0/3
3/3
115/115
3/3
421/421
39/76
7/7
0/2
1/3
578/578
10/12
6/8
178/178

1425/1425 = 100.00% 1425/1473 = 96.74%

TABLE VI: Precision and recall of THREATRAPTOR in
ﬁnding malicious system events

occasionally synthesized (e.g., in password_crack, one exces-
sive event pattern is synthesized: proc p3["%/tmp/libfoo.so
%"] write file f2["%/tmp/john.zip%"] as evt5), the de-
sign of THREATRAPTOR ensures that these excessive event
patterns will rarely retrieve benign activities. The reason is
because these excessive patterns have IOCs as subject/ob-
ject constraints, which are extracted by a set of highly-
precise regex rules in THREATRAPTOR. As a result, very
few benign activities are falsely retrieved (e.g., 0 false pos-
itive rate in our evaluation benchmark); (3) For queries that
have false negatives, the primary reason is due to the se-
mantic ambiguity in query synthesis for certain IOC rela-
tions. For example, in tc_trace_1, there is an edge pointing
from the “Filepath” IOC “/home/admin/cache” to itself with
the “run” relation. Both the IOC and the relation are cor-
rected extracted from OSCTI text. However, when performing
query synthesis,
there is no way to differentiate whether
it
represents a ﬁle event proc p1["%/home/admin/cache
%"] execute file f1["%/home/admin/cache%"] or a pro-
cess event proc p1["%/home/admin/cache%"] start proc
p2["%/home/admin/cache%"], as both events are related to
process creation. The default synthesis plan in THREATRAP-
TOR synthesizes the ﬁrst pattern, while for this case, the second
pattern has matched ground-truth system events. As a result, 37
system events are missed. One way to mitigate this is to let the
security analyst revise the query to improve the coverage, and
the synthesized event patterns serve as a base for exploration.
It is worth mentioning that the three cases for ClearScope
were conducted on Android OS and the ground-truth sys-
tem events have Android package names as process exe-
cutable names (e.g., proc p1["%com.android.defcontainer
%"] open file f1["%MsgApp-instr.apk%"]), which are dif-
ferent from other cases in which process executables are
normal Linux/Windows ﬁles. Nevertheless, THREATRAPTOR
is able to accurately extract such information and use the

information to ﬁnd the malicious system events, thanks to the
coverage of a wide range of IOC types and IOC relations in
THREATRAPTOR’s threat behavior extraction pipeline.

3) RQ3: Efﬁciency of Threat Behavior Extraction: Ta-
ble VII shows the execution time of different stages of
THREATRAPTOR: threat behavior extraction, threat behavior
graph construction, and query synthesis. For threat behavior
extraction, we also compare with other baseline approaches.
We have the following observations: (1) THREATRAPTOR is
efﬁcient in processing the input OSCTI texts, constructing
threat behavior graphs, and synthesizing TBQL queries. The
average time for the three stages is 0.52s; (2) Stanford Open
IE and Open IE 5 are more expensive in extracting threat
behaviors compared to THREATRAPTOR (0.76s and 13.46s vs.
0.42s), since these general information extraction approaches
spend a long time analyzing texts that are unrelated to threat
behaviors; (3) IOC Protection adds trivial overhead.

4) RQ4: Efﬁciency of TBQL Query Execution: We measure
the runtime performance of THREATRAPTOR in executing
TBQL queries, particularly the performance speedup provided
by the TBQL query scheduler in different database backends.
To prepare for evaluation, for each case, we construct four
types of semantically equivalent queries according to the
corresponding synthesized TBQL query by THREATRAPTOR:
(a) TBQL query using the event pattern syntax (e.g., proc

p open file f as evt).

(b) SQL query that encodes all event patterns and ﬁlters in

the FROM and WHERE clauses.

(c) TBQL query using the length-1 event path pattern syntax

(e.g., proc p ->[open] file f as evt).

(d) Cypher query that encodes all length-1 event path patterns

and ﬁlters in the MATCH and WHERE clauses.

All these four types queries search for the same system
behaviors and return the same results. The difference lies in
the query scheduler and the database: Queries (a) and (b) are
executed in PostgreSQL, and Queries (c) and (d) are executed
in Neo4j. Queries (a) and (c) beneﬁt from optimizations in
TBQL query scheduler, and Queries (b) and (d) do not.

Table VIII shows the execution time of the queries aggre-
gated over 20 rounds. We have the following observations:
(1) TBQL query scheduler provided by THREATRAPTOR is
generally more efﬁcient than the query schedulers provided by
PostgreSQL and Neo4j. Speciﬁcally, for PostgreSQL backend,
THREATRAPTOR is 3810.17/168.18 = 22.7x faster; for Neo4j
backend, THREATRAPTOR is 3104.68/343.04 = 9.1x faster;
(2) There also exist a few cases in which TBQL queries
run slightly slower than SQL queries and Cypher queries.
Particularly, when the TBQL query only contains 1 pattern
(i.e., tc_clearscope_3, tc_trace_3), TBQL query runs slower

Case

tc_clearscope_1
tc_clearscope_2
tc_clearscope_3
tc_ﬁvedirections_1
tc_ﬁvedirections_2
tc_ﬁvedirections_3
tc_theia_1
tc_theia_2
tc_theia_3
tc_theia_4
tc_trace_1
tc_trace_2
tc_trace_3
tc_trace_4
tc_trace_5
password_crack
data_leak
vpnﬁlter
Total
Average

Text -> E. & R.
0.43
0.42
0.37
0.33
0.39
0.36
0.52
0.52
0.56
0.26
0.44
0.45
0.31
0.46
0.42
0.43
0.47
0.35
7.50
0.42

THREATRAPTOR
E. & R. -> Graph Graph -> TBQL

0.08
0.08
0.02
0.08
0.08
0.08
0.09
0.08
0.09
0.09
0.11
0.16
0.09
0.09
0.08
0.09
0.09
0.08
1.55
0.09

0.00
0.00
0.00
0.01
0.01
0.00
0.01
0.01
0.01
0.01
0.01
0.01
0.00
0.00
0.00
0.01
0.01
0.01
0.11
0.01

THREATRAPTOR − IOC Protection
Text -> E. & R.
0.42
0.39
0.24
0.35
0.38
0.35
0.46
0.47
0.51
0.27
0.48
0.44
0.31
0.46
0.43
0.44
0.51
0.30
7.21
0.40

Stanford Open IE
Text -> E. & R.
0.74
0.46
0.76
0.61
0.56
0.63
0.59
0.31
0.72
0.73
1.06
0.63
1.10
0.96
0.91
0.87
0.84
1.15
13.63
0.76

Stanford Open IE + IOC Protection
Text -> E. & R.
0.74
0.46
0.76
0.61
0.56
0.63
0.59
0.31
0.72
0.73
1.06
0.63
1.10
0.96
0.91
0.87
0.84
1.16
13.64
0.76

Open IE 5
Text -> E. & R.
7.69
1.53
15.29
7.84
0.67
0.50
16.53
48.85
7.79
0.19
4.01
47.13
1.00
1.76
41.92
25.54
10.06
4.05
242.35
13.46

Open IE 5 + IOC Protection
Text -> E. & R.
7.69
1.53
15.29
7.84
0.67
0.50
16.53
48.85
7.79
0.19
4.01
47.13
1.00
1.76
41.92
25.54
10.07
4.05
242.36
13.46

TABLE VII: Execution time (second) of different stages of THREATRAPTOR: threat behavior extraction (text -> E. &
R.), threat behavior graph construction (E. & R. -> graph), and TBQL query synthesis (graph -> TBQL)

Case

tc_clearscope_1
tc_clearscope_2
tc_clearscope_3
tc_ﬁvedirections_1
tc_ﬁvedirections_2
tc_ﬁvedirections_3
tc_theia_1
tc_theia_2
tc_theia_3
tc_theia_4
tc_trace_1
tc_trace_2
tc_trace_3
tc_trace_4
tc_trace_5
password_crack
data_leak
vpnﬁlter
Total
Average

TBQL

SQL

20-r mean
1.07
1.39
0.92
2.48
1.79
1.46
3.86
1.91
4.43
4.37
44.21
50.66
1.97
37.66
5.43
1.52
1.45
1.60
168.18
9.34

20-r std
0.14
0.16
0.15
0.04
0.16
0.14
0.08
0.17
0.40
0.15
0.57
0.77
0.05
0.37
0.10
0.20
0.43
0.29

20-r std
0.54
0.12
0.11
0.48
0.12
0.17
0.55
0.17
0.34
0.29
1.91
0.42
0.06
0.26
0.37
0.45
67.43
0.28

20-r mean
1.41
1.34
0.90
32.24
1.94
1.87
43.15
1.88
12.07
5.28
85.63
52.94
1.95
38.88
13.79
40.32
3,456.12
18.44
3,810.17
211.68

TBQL (length-1 path)
20-r std
20-r mean
0.21
3.86
0.33
4.14
0.24
3.51
0.38
5.38
0.31
4.52
0.28
3.89
0.38
10.41
0.41
5.17
0.35
9.84
0.32
8.54
0.81
82.16
0.66
85.90
0.01
2.25
0.85
89.39
0.12
6.46
0.34
6.06
0.67
6.28
5.28
0.42
343.04
19.06

Cypher

20-r std
0.19
0.20
0.17
1.01
0.36
0.36
5.31
1.11
0.59
0.43
18.74
1.94
0.01
0.53
0.11
1.02
34.92
0.61

20-r mean
3.91
3.93
3.47
44.79
4.50
5.40
234.31
77.66
32.66
8.09
366.11
348.23
2.24
91.33
6.19
57.70
1,803.14
11.04
3,104.68
172.48

TABLE VIII: Execution time (second) of queries in TBQL,
SQL, TBQL in length-1 event path pattern syntax, and
Cypher. Each query was executed for 20 rounds.

Case

tc_clearscope_1
tc_clearscope_2
tc_clearscope_3
tc_ﬁvedirections_1
tc_ﬁvedirections_2
tc_ﬁvedirections_3
tc_theia_1
tc_theia_2
tc_theia_3
tc_theia_4
tc_trace_1
tc_trace_2
tc_trace_3
tc_trace_4
tc_trace_5
password_crack
data_leak
vpnﬁlter

THREATRAPTOR-Fuzzy

Poirot

Loading
7.71
7.69
7.69
18.11
18.05
18.09
37.25
37.36
36.98
37.02
297.35
295.01
295.30
294.23
294.53
1.36
2.37
2.07

Preprocessing
6.03
6.32
6.02
12.99
12.52
12.37
34.10
33.06
35.15
33.10
510.99
504.08
340.92
412.82
401.28
1.12
1.75
1.83

Searching
577.01

>3600

21.30
58.33
705.13
33.28

>3600
>3600
>3600
>3600

249.71

>3600

111.55
301.30

>3600

37.97
19.01

>3600

Total
590.75
>3600
35.01
89.42
735.69
63.74
>3600
>3600
>3600
>3600
1,058.05
>3600
747.77
1,008.34
>3600
40.45
23.13
>3600

Loading
7.94
7.74
7.75
18.15
18.15
18.08
37.35
37.36
37.34
37.31
296.65
297.02
297.22
297.43
297.24
1.37
2.36
2.07

Preprocessing
6.08
6.20
5.86
12.80
12.36
12.08
33.25
31.68
34.23
32.65
489.12
483.31
328.44
401.04
389.22
1.54
1.72
1.83

Searching
542.59
431.22
22.21
57.83
663.13
32.64

>3600
>3600
>3600
>3600

109.20

>3600

114.32
304.09

>3600

22.02
18.46
2,069.69

Total
556.61
445.17
35.81
88.78
693.64
62.80
>3600
>3600
>3600
>3600
894.97
>3600
739.97
1,002.56
>3600
24.93
22.55
2,073.59

TABLE IX: Execution time (second) of THREATRAPTOR’s
fuzzy search mode and Poirot [6].

than SQL query and Cypher query as additional time is taken
to parse the TBQL query and compile into SQL or Cypher
data queries. When the number of patterns becomes large,
SQL queries and Cypher queries become much slower (e.g.,
data_leak), as these giant queries have many joins and con-
straints mixed together, which may suffer from indeterministic
optimizations and take long to ﬁnish execution; (3) Post-
greSQL is generally faster than Neo4j, as relational databases
have better support for joins; (4) The standard deviation is
small compared to the mean. This indicates that the 20-round
mean values are representative. These results demonstrates
the superiority of TBQL query scheduler in speeding up the
execution of TBQL queries in different database backends.

Performance of THREATRAPTOR’s Fuzzy Search Mode: We
further study the performance of THREATRAPTOR’s fuzzy
search mode and Poirot [6] (the difference is that Poirot
does not search for all aligned system provenance subgraphs).
Table IX shows the execution time (second). The execution
consists of three parts: loading all system entities and system
events from database into memory (loading time), constructing

the provenance graph from system entities and system events
(preprocessing time), and searching for alignments in the
provenance graph (searching time).

We have the following observations: (1) THREATRAP-
TOR’s fuzzy search mode (THREATRAPTOR-Fuzzy) based
on Poirot improves generality at the cost of efﬁciency. In
particular, THREATRAPTOR’s exact search mode is a lot faster
than THREATRAPTOR-Fuzzy and Poirot. Besides, given that
THREATRAPTOR-Fuzzy additionally performs an exhaustive
search, it is within our expectation that THREATRAPTOR-
Fuzzy in general runs longer than Poirot; (2) There are several
cases that both Poirot and THREATRAPTOR-Fuzzy cannot
ﬁnish within 1 hour (e.g.,
tc_theia cases). After proﬁling
the execution, we identify two major bottlenecks in Poirot’s
searching iterations that affect both approaches: (a) a large
number of candidate node alignments often result in a longer
running time; (b) graph traversals required by candidate se-
lection on dense graphs are time-consuming. For example, al-
though the provenance graph of tc_theia_1 (1.5M nodes, 8.7M
edges) is a lot smaller than tc_trace_1 (44.7M nodes, 39.8M
edges), tc_theia_1 (78K alignments) has more candidate node
alignments than tc_trace_1 (131 alignments). Furthermore, the
average degree of tc_theia is 5.9 while the average degree
of tc_trace is only 0.9. As a result, searching for aligned
subgraphs for tc_theia cases is more time-consuming; (3) For
cases that THREATRAPTOR-Fuzzy ﬁnishes within 1 hour, all
ground-truth attack activities are found.

Based on the evaluation results, we recommend the user to
use THREATRAPTOR’s exact search mode if possible, which
is much more efﬁcient. The fuzzy search mode can be used
as an alternative when the exact search mode fails to retrieve
meaningful results. How to enable more efﬁcient inexact graph
pattern matching (and exhaustive graph alignment search) in
dense, high-alignment system provenance graphs is an open
question, which we leave for future work.

5) RQ5: Conciseness of TBQL: For the four types of
queries mentioned in RQ4, we further compare their con-
ciseness by measuring the number of characters (exclud-
ing spaces and comments) and words. Table X shows the
results. We observe that: (1) TBQL is more concise than
SQL and Cypher for all cases. Speciﬁcally, for # charac-
ters, TBQL is 15007/4460 = 3.4x more concise than SQL
and 13601/4772 = 2.9x more concise than Cypher; for #
words, TBQL is 2670/945 = 2.8x more concise than SQL

Case

# Patterns

tc_clearscope_1
tc_clearscope_2
tc_clearscope_3
tc_ﬁvedirections_1
tc_ﬁvedirections_2
tc_ﬁvedirections_3
tc_theia_1
tc_theia_2
tc_theia_3
tc_theia_4
tc_trace_1
tc_trace_2
tc_trace_3
tc_trace_4
tc_trace_5
password_crack
data_leak
vpnﬁlter
Total
Average

2
2
1
3
3
2
3
3
5
2
4
3
1
3
2
8
8
5
60
3.33

TBQL

SQL

# Chars
131
213
93
219
164
111
238
235
329
195
249
264
109
187
211
551
561
400
4460
247.78

# Words
30
36
16
47
39
25
51
51
77
39
55
57
19
40
40
122
121
80
945
52.50

# Chars
584
588
218
737
750
376
711
888
1385
562
927
933
240
656
585
1866
1841
1160
15007
833.72

# Words
102
102
40
134
133
70
130
152
252
102
169
168
42
120
103
311
328
212
2670
148.33

TBQL (length-l path)
# Words
# Chars
32
145
37
224
16
97
48
234
41
182
26
125
52
253
53
253
81
361
40
206
56
268
59
282
20
116
41
202
41
222
123
586
122
596
80
420
968
4772
53.78
265.11

Cypher

# Chars
530
556
205
674
665
330
648
803
1261
530
833
882
222
599
553
1639
1614
1057
13601
755.61

# Words
84
83
30
105
105
51
101
124
206
83
130
140
33
91
84
252
249
162
2113
117.39

TABLE X: Conciseness of queries in TBQL, SQL, TBQL
in length-1 event path pattern syntax, and Cypher

and 2113/968 = 2.2x more concise than Cypher. This is
because TBQL directly models the high-level, domain-speciﬁc
concepts like system entities and system events, instead of
the low-level concepts like tables or nodes/relationships; (2)
The conciseness saving of TBQL compared to SQL and
Cypher increases when more patterns are declared (e.g., pass-
word_crack, data_leak); (3) Cypher queries are generally more
concise than SQL queries. This is within our expectation as
Cypher has a concise syntax to specify linked nodes and
relationships, while SQL models everything as tables and has
to explicitly specify table joins to represent system events.

V. DISCUSSION

Limitations. As mentioned in Section II, attacks on OS ker-
nels, system auditing frameworks, and databases, and attacks
that are not captured by system auditing are not considered by
THREATRAPTOR. Besides, THREATRAPTOR’s threat behavior
extraction pipeline is not applicable if the OSCTI text for the
attack is not available or contains little useful information (e.g.,
no IOCs, no sentence structures that contain IOC relations).
When there are deviations between the OSCTI text and the
ground truth (e.g., typos or changes in IOCs), THREATRAP-
TOR’s exact search mode may miss attack activities. In such
cases, THREATRAPTOR’s fuzzy search mode can be used as
an alternative to increase the generality of searching. Once
some attack activities are found, the user can switch back to
the exact search mode and revise the query (e.g., adding event
patterns) to expand the search for connected activities.
CTI Collection. In general, CTI reports can be collected
from various public sources (a.k.a., OSCTI), such as security
websites [18], [19] and blogs [20]. Enterprises may also
have access to proprietary sources such as internal reports
provided by domain experts, which might better reﬂect the
particular enterprise environment. This work does not target
CTI collection. Instead, THREATRAPTOR targets automated
extraction of threat knowledge from an input report and use
of the extracted knowledge for threat hunting.
Design Alternatives. THREATRAPTOR currently leverages
regex rules to extract IOCs and dependency parsing to extract
IOC relations. Besides IOCs, other types of entities may also
exist in OSCTI text that constitute threat behaviors, such as
threat actors (e.g., CozyDuke [42]) and security tools (e.g.,
Mimikatz [43]), which are hard to extract using ﬁxed regex
rules. To extend the support for these entities and their rela-
tions, one approach is to adopt learning-based approaches to

perform Named Entity Recognition (NER) [44] and Relation
Extraction (RE) [45]. Different from THREATRAPTOR’s cur-
rent unsupervised NLP pipeline, these approaches are typically
supervised, which require large annotated corpora for model
training. Such large annotated corpora is very costly to obtain
manually. In future work, we plan to explore techniques
to programmatically synthesize annotations for OSCTI texts
(e.g., via data programming [46]) and leverage learning-based
approaches to expand our threat behavior extraction scope.

In query synthesis, THREATRAPTOR has a pre-synthesis
screening step to ﬁlter out nodes in the threat behavior graph
whose associated IOC types are not captured by the system
auditing component. In future work, we plan to expand our
monitoring scope by including more types of entities and
events (e.g., Windows registry entries and Linux pipes).

VI. RELATED WORK

Forensic Analysis via System Audit Logs. Research has
logs for forensic anal-
proposed to leverage system audit
ysis. Causality analysis plays a critical role in identifying
root causes and ramiﬁcations of attacks [3]. Efforts have
been made to mitigate the dependency explosion problem
by performing ﬁne-grained causality analysis [4], prioritiz-
ing dependencies [5], and reducing data size [23]. Besides,
research has proposed to query system audit logs for attack
investigation and anomaly detection [7]–[9], [47], [48]. The
scope of THREATRAPTOR is different from these works, as
none of these works proposed to facilitate threat hunting
via automated extraction of threat knowledge from OSCTI
text and automated synthesis of threat hunting queries from
the extracted knowledge. Besides, the TBQL query language
provided in THREATRAPTOR has a set of features particularly
designed for threat hunting (e.g., variable-length event path
pattern syntax) that are not supported in prior query tools.

Poirot [6] is an approach for threat hunting that ﬁnds the
aligned system provenance subgraph of an input query graph.
Its core contribution is an inexact graph pattern matching
algorithm for ﬁnding the alignment. It is important to note
that Poirot’s scope is signiﬁcantly different from THREATRAP-
TOR’s scope: Poirot does not search for all aligned subgraphs.
Instead, Poirot stops its searching iteration after ﬁnding the
ﬁrst acceptable alignment that surpasses a threshold. This is
different from the goal of THREATRAPTOR’s query subsystem.
Besides, unlike THREATRAPTOR’s automated threat behavior
graph construction, Poirot’s query graph requires non-trivial
efforts of cyber analysts to manually construct it. Furthermore,
unlike THREATRAPTOR, Poirot does not
involve database
storage for storing the massive log data, a query language
for proactive threat hunting, and a query synthesis mechanism
for automating the process. Nevertheless, Poirot’s inexact
graph pattern matching algorithm can be leveraged to improve
the generality of searching: THREATRAPTOR’s current fuzzy
search mode extends it to support exhaustive search.

OSCTI Analysis and Management. Research progress has
been made for automated OSCTI analysis, including extract-

ing IOCs [17], extracting threat action terms from semi-
structured Symantec reports [49], and measuring information
inconsistency [50]. There also exist platforms and standards
for OSCTI management and exchange [14]–[16], [51], [52].
THREATRAPTOR distinguishes from these works in the sense
that it seeks to extract both IOCs and IOC relations from OS-
CTI text, and use the extracted knowledge for threat hunting.

Open Information Extraction. Information extraction (IE)
extracts structured information from unstructured natural lan-
guage text. Open information extraction (Open IE) is a new
paradigm of IE that is not limited to a restricted set of target
relations known in advance, but rather extracts all types of
relations found in the text. Research has proposed to leverage
rule-based approaches or learning-based approaches for more
accurate Open IE [21], [22]. THREATRAPTOR distinguishes
from these works in the sense that it focuses on threat behavior
extraction from OSCTI text, which requires special designs to
handle massive nuances particular to the security domain.

VII. CONCLUSION

We have proposed THREATRAPTOR, a system that facili-
tates cyber threat hunting in computer systems using OSCTI.

Acknowledgement. Peng Gao, Xiaoyuan Liu, and Dawn
Song are supported in part by DARPA N66001-15-C-4066
and the Center for Long-Term Cybersecurity. Fei Shao and
Xusheng Xiao are supported in part by NSF CNS-2028748.
Zheng Qin and Fengyuan Xu are supported in part by NSFC-
61872180, Jiangsu "Shuang-Chuang" Program, and Jiangsu
"Six-Talent-Peaks" Program. Prateek Mittal is supported in
part by NSF CNS-1553437 and CNS-1704105, the ARL’s
Army Artiﬁcial Intelligence Innovation Institute (A2I2), the
Ofﬁce of Naval Research Young Investigator Award, and the
Army Research Ofﬁce Young Investigator Prize. Sanjeev R.
Kulkarni is supported in part by the Center for Science of
Information (CSoI), an NSF Science and Technology Center,
under grant agreement CCF-0939370.

REFERENCES

[1] “Target Data Breach Incident,” http://www.nytimes.com/2014/02/27/

business/target-reports-on-fourth-quarter-earnings.html?_r=1.

[2] “The Equifax Data Breach,” https://www.ftc.gov/equifax-data-breach.
[3] S. T. King and P. M. Chen, “Backtracking intrusions,” in SOSP, 2003.
[4] K. H. Lee, X. Zhang, and D. Xu, “High accuracy attack provenance via

binary-based execution partition.” in NDSS, 2013.

[5] Y. Liu, M. Zhang, D. Li, K. Jee, Z. Li, Z. Wu, J. Rhee, and P. Mittal,
“Towards a timely causality analysis for enterprise security,” in NDSS,
2018.

[6] S. M. Milajerdi, B. Eshete, R. Gjomemo, and V. Venkatakrishnan,
“Poirot: Aligning attack behavior with kernel audit records for cyber
threat hunting,” in CCS, 2019.

[7] P. Gao, X. Xiao, Z. Li, F. Xu, S. R. Kulkarni, and P. Mittal, “AIQL:
Enabling efﬁcient attack investigation from system monitoring data,” in
USENIX ATC, 2018.

[8] P. Gao, X. Xiao, D. Li, Z. Li, K. Jee, Z. Wu, C. H. Kim, S. R.
Kulkarni, and P. Mittal, “SAQL: A stream-based query system for real-
time abnormal system behavior detection,” in USENIX Security, 2018.
[9] T. Pasquier, X. Han, T. Moyer, A. Bates, O. Hermant, D. Eyers, J. Bacon,
and M. Seltzer, “Runtime Analysis of Whole-system Provenance,” in
CCS, 2018.

[10] “Splunk Search Processing Language,” https://www.splunk.com/en_us/

resources/search-processing-language.html.

[11] “Elastic SIEM,” https://www.elastic.co/siem.
[12] “Open Source Threat

Intelligence Feeds,” https://www.senki.org/

operators-security-toolkit/open-source-threat-intelligence-feeds/.

[13] “PhishTank,” https://www.phishtank.com/.
[14] “Structured Threat Information eXpression,” http://stixproject.github.io/.
[15] “MISP - Open Source Threat Intelligence Platform & Open Standards
For Threat Information Sharing,” https://www.misp-project.org/.

[16] “The History

of OpenIOC,”

https://www.ﬁreeye.com/blog/threat-

research/2013/09/history-openioc.html.

[17] X. Liao, K. Yuan, X. Wang, Z. Li, L. Xing, and R. Beyah, “Acing the ioc
game: Toward automatic discovery and analysis of open-source cyber
threat intelligence,” in CCS, 2016.

[18] “AlienVault,” https://www.alienvault.com/blogs/labs-research/.
[19] “SecureList,” https://securelist.com/.
[20] “KrebsonSecurity,” https://krebsonsecurity.com/.
[21] G. Angeli, M. J. J. Premkumar, and C. D. Manning, “Leveraging
linguistic structure for open domain information extraction,” in ACL,
2015.

[22] “Open IE 5,” https://github.com/dair-iitd/OpenIE-standalone.
[23] Z. Xu, Z. Wu, Z. Li, K. Jee, J. Rhee, X. Xiao, F. Xu, H. Wang, and
G. Jiang, “High ﬁdelity data reduction for big data security dependency
analyses,” in CCS, 2016.

[24] “The Linux Audit Framework,” https://github.com/linux-audit/.
for Windows,”
[25] “Event Tracing

https://docs.microsoft.com/en-us/

windows/win32/etw/event-tracing-portal.

[26] “Sysdig,” http://www.sysdig.org/.
[27] “PostgreSQL,” http://www.postgresql.org/.
[28] “Neo4j,” http://neo4j.com/.
[29] “SQL: Structured Query Language,” http://www.iso.org/iso/catalogue_

detail.htm?csnumber=45498.

[30] “Cypher Query Language,” http://neo4j.com/developer/cypher/.
[31] “ThreatRaptor Demo Video,” https://youtu.be/SrcTDQwRF_M.
[32] “Cyber

https://www.lockheedmartin.com/en-

Chain,”

Kill

us/capabilities/cyber/cyber-kill-chain.html.

[33] “Common Vulnerabilities and Exposures,” https://cve.mitre.org/.
[34] “ioc-parser,” https://github.com/armbues/ioc_parser.
[35] “spaCy,” https://spacy.io/usage/linguistic-features.
[36] V. I. Levenshtein, “Binary codes capable of correcting deletions, inser-

tions, and reversals,” in Soviet physics doklady, 1966.

[37] “ANTLR,” http://www.antlr.org/.
[38] “Transparent computing engagement 3 data release,” https://github.com/
darpa-i2o/Transparent-Computing/blob/master/README-E3.md.

[39] “CVE-2014-6271,”

https://cve.mitre.org/cgi-

bin/cvename.cgi?name=CVE-2014-6271.

[40] “VPNFilter: New Router Malware with Destructive Capabilities,”
https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/
vpnﬁlter-iot-malware.

[41] “Router Vulnerability and the VPNFilter Botnet,” https://www.schneier.

com/blog/archives/2018/06/router_vulnerab.html.
[42] “APT29,” https://attack.mitre.org/groups/G0016/.
[43] “Mimikatz,” https://attack.mitre.org/software/S0002/.
[44] G. Lample, M. Ballesteros, S. Subramanian, K. Kawakami, and C. Dyer,
“Neural architectures for named entity recognition,” in NAACL-HLT,
2016.

[45] Y. Lin, S. Shen, Z. Liu, H. Luan, and M. Sun, “Neural relation extraction

with selective attention over instances,” in ACL, 2016.

[46] A. J. Ratner, C. M. De Sa, S. Wu, D. Selsam, and C. Ré, “Data
programming: Creating large training sets, quickly,” in NeurIPS, 2016.
[47] P. Gao, X. Xiao, Z. Li, K. Jee, F. Xu, S. R. Kulkarni, and P. Mittal, “A
query system for efﬁciently investigating complex attack behaviors for
enterprise security,” in VLDB, 2019.

[48] P. Gao, X. Xiao, D. Li, K. Jee, H. Chen, S. R. Kulkarni, and P. Mittal,
“Querying streaming system monitoring data for enterprise system
anomaly detection,” in ICDE, 2020.

[49] G. Husari, E. Al-Shaer, M. Ahmed, B. Chu, and X. Niu, “Ttpdrill:
Automatic and accurate extraction of threat actions from unstructured
text of cti sources,” in ACSAC, 2017.

[50] Y. Dong, W. Guo, Y. Chen, X. Xing, Y. Zhang, and G. Wang, “Towards
the detection of inconsistencies in public security vulnerability reports,”
in USENIX Security, 2019.

[51] P. Gao, X. Liu, E. Choi, B. Soman, C. Mishra, K. Farris, and D. Song,
“A system for automated threat intelligence gathering and management,”
in SIGMOD, 2021.

[52] “ThreatMiner,” https://www.threatminer.org/.

